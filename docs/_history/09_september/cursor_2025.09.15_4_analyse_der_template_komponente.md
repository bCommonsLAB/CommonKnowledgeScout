# Analyse der Template-Komponente
_Exported on 10/9/2025 at 15:00:07 GMT+2 from Cursor (1.7.38)_

---

**User**

@template-management.tsx Können wir diese Komponente analysieren?
Wie wird bei Template bearbeiten der Body gerendert?

---

**Cursor**

### Kurzanalyse der Komponente `template-management.tsx`

- **Zuständigkeit der Komponente**: Verwalten (Listen, Anlegen, Umbenennen, Löschen), Bearbeiten, Vorschau und Testen von Templates, gespeichert im Storage-Ordner `/templates` der aktiven Bibliothek.
- **State/Architektur**: Form-State via `react-hook-form` (Zod-Resolver), globaler Template-State via Jotai-Atoms, Storage über `useStorage`-Provider. Der Render-Modus wechselt zwischen Bearbeiten und Vorschau per `previewMode`.

### Wie wird beim Bearbeiten der Body gerendert?

- **Bearbeiten-Modus**: Der Markdown-Body wird nicht als Markdown gerendert, sondern über den Child-Editor `StructuredTemplateEditor` als Text/Inhalt editiert. Dieser bekommt die drei Bereiche (`markdownBody`, `yamlFrontmatter`, `systemPrompt`) als Props und meldet Änderungen via `onChange` zurück; die Werte landen kontrolliert im `react-hook-form`-State. Es findet keine Markdown-zu-HTML-Transformation statt.
```640:649:src/components/templates/template-management.tsx
<StructuredTemplateEditor
  markdownBody={form.watch('markdownBody')}
  yamlFrontmatter={form.watch('yamlFrontmatter')}
  systemPrompt={form.watch('systemPrompt')}
  onChange={({ markdownBody, yamlFrontmatter, systemPrompt }) => {
    form.setValue('markdownBody', markdownBody, { shouldDirty: true })
    form.setValue('yamlFrontmatter', yamlFrontmatter, { shouldDirty: true })
    form.setValue('systemPrompt', systemPrompt, { shouldDirty: true })
  }}
/>
```

- **Vorschau-Modus**: Bei Vorschau wird der komplette Template-Content als Plaintext in einem `<pre>` gezeigt. Die Funktion `generateTemplateContent` setzt dazu YAML-Frontmatter, Body und Systemprompt zusammen.
```620:638:src/components/templates/template-management.tsx
{previewMode ? (
  <div className="space-y-4">
    <div className="flex items-center justify-between">
      <h4 className="text-sm font-medium">Template-Vorschau</h4>
      <Button
        type="button"
        variant="outline"
        size="sm"
        onClick={() => setPreviewMode(false)}
      >
        Bearbeiten
      </Button>
    </div>
    <div className="border rounded-md p-4 bg-muted/50">
      <pre className="text-sm whitespace-pre-wrap font-mono">
        {generatePreview()}
      </pre>
    </div>
  </div>
) : (
  <StructuredTemplateEditor ...
```

- **Zusammenbau des Inhalts**: YAML-Frontmatter (falls vorhanden) + Markdown-Body + `--- systemprompt` + Systemprompt werden beim Speichern/Vorschau zusammengesetzt.
```334:351:src/components/templates/template-management.tsx
function generateTemplateContent(values: TemplateFormValues): string {
  let content = ""
  if (values.yamlFrontmatter.trim()) content += values.yamlFrontmatter + "\n\n"
  content += values.markdownBody
  if (values.systemPrompt.trim()) content += "\n\n--- systemprompt\n" + values.systemPrompt
  return content
}
```

### Wichtige Punkte
- **Bearbeiten**: Plaintext-Editing über `StructuredTemplateEditor` (keine Markdown-Render-Engine).
- **Vorschau**: Nur Textausgabe im `<pre>`; keine HTML-Interpretation, keine Markdown-Styling-Transformation.
- **Speichern/Testen**: Der zusammengesetzte Text wird als `.md` hochgeladen bzw. an den Secretary-Service gesendet.

Wenn du eine echte Markdown-Preview (gerendertes HTML) möchtest, könnten wir optional `react-markdown` mit sicheren Renderern integrieren und die Vorschau-Seite damit ausgeben.

```typescriptreact
<StructuredTemplateEditor
  markdownBody={form.watch('markdownBody')}
  yamlFrontmatter={form.watch('yamlFrontmatter')}
  systemPrompt={form.watch('systemPrompt')}
  onChange={({ markdownBody, yamlFrontmatter, systemPrompt }) => {
    form.setValue('markdownBody', markdownBody, { shouldDirty: true })
    form.setValue('yamlFrontmatter', yamlFrontmatter, { shouldDirty: true })
    form.setValue('systemPrompt', systemPrompt, { shouldDirty: true })
  }}
/>
```

```typescriptreact
{previewMode ? (
  <div className="space-y-4">
    <div className="flex items-center justify-between">
      <h4 className="text-sm font-medium">Template-Vorschau</h4>
      <Button
        type="button"
        variant="outline"
        size="sm"
        onClick={() => setPreviewMode(false)}
      >
        Bearbeiten
      </Button>
    </div>
    <div className="border rounded-md p-4 bg-muted/50">
      <pre className="text-sm whitespace-pre-wrap font-mono">
        {generatePreview()}
      </pre>
    </div>
  </div>
) : (
  <StructuredTemplateEditor ...
```

```typescriptreact
function generateTemplateContent(values: TemplateFormValues): string {
  let content = ""
  if (values.yamlFrontmatter.trim()) content += values.yamlFrontmatter + "\n\n"
  content += values.markdownBody
  if (values.systemPrompt.trim()) content += "\n\n--- systemprompt\n" + values.systemPrompt
  return content
}
```

---

**User**

@structured-template-editor.tsx 
Funktioniert dieser Editor genau? Welche Spalten werden wie angezeigt? Ist es eine scrollbare HTML-Tabelle?

---

**Cursor**

### Präzise Bewertung des Editors

- **Funktion**: Der Editor zerlegt das Template in drei Tabs: Body, Frontmatter, System. Er extrahiert Platzhalter und erlaubt Inline-Edits der Fragen/Beschreibungen. Änderungen werden per `onChange` in den Parent-State zurückgeschrieben.
- **Genauigkeit**: Funktional korrekt, mit einer Einschränkung im Body-Tab: Die Textareas sind „uncontrolled“ (`defaultValue`), was bei externen Prop-Änderungen (z. B. Template-Wechsel) zu veralteten Anzeigen führen kann. Besser wäre `value={r.question}` (controlled).

### Spalten/Tabellenstruktur und Scroll-Verhalten

- **Body-Tab**: Shadcn-Table mit 2 Spalten: 
  - Spalte 1: Variable (Key)
  - Spalte 2: Frage/Beschreibung (Textarea)
  - Zusätzlich Abschnittszeilen (Section) über beide Spalten.
  - Scroll: Container hat `overflow-auto`, aber keine feste Höhe → wächst typischerweise mit Inhalt; Scroll tritt nur auf, wenn ein übergeordneter Container begrenzt.
```76:103:src/components/templates/structured-template-editor.tsx
<TabsContent value="body">
  <div className="overflow-auto">
    <Table className="text-[11px] w-full border-collapse">
      <TableHeader>
        <TableRow className="[&>*]:py-1">
          <TableHead className="w-36">Variable</TableHead>
          <TableHead>Frage/Beschreibung</TableHead>
        </TableRow>
      </TableHeader>
      <TableBody>
        {bodyRows.length === 0 ? (
          <TableRow><TableCell colSpan={2} className="text-muted-foreground">Keine Einträge im Body.</TableCell></TableRow>
        ) : bodyRows.map((r, i) => r.kind === 'section' ? (
          <TableRow key={`sec-${i}`} className="bg-muted/20 align-top">
            <TableCell colSpan={2} className="font-medium whitespace-pre-wrap break-words py-1">{r.label}</TableCell>
          </TableRow>
        ) : (
          <TableRow key={`pl-${r.key}-${i}`} className="align-top">
            <TableCell className="align-top font-mono w-36 py-1">{r.key}</TableCell>
            <TableCell className="align-top py-1">
              <textarea defaultValue={r.question} onChange={(e) => updateBodyQuestion(r.key, e.target.value)} className="w-full min-h-[2.5rem] resize-y rounded-md border bg-background px-2 py-1 text-[11px] leading-snug" />
            </TableCell>
          </TableRow>
        ))}
      </TableBody>
    </Table>
  </div>
</TabsContent>
```

- **Frontmatter-Tab**: Native HTML-Table mit 3 Spalten:
  - Spalte 1: Key (YAML-Schlüssel)
  - Spalte 2: Variable (Platzhalter-Key)
  - Spalte 3: Frage/Beschreibung (EditableTextarea, controlled)
  - Scroll: Ja, explizit. Container `max-h-[50vh] overflow-auto`, Header ist sticky.
```105:141:src/components/templates/structured-template-editor.tsx
<TabsContent value="frontmatter">
  <div className="max-h-[50vh] overflow-auto rounded border">
    <table className="w-full text-[11px] border-collapse">
      <thead className="sticky top-0 bg-background">
        <tr>
          <th className="w-40 text-left px-2 py-1">Key</th>
          <th className="w-40 text-left px-2 py-1">Variable</th>
          <th className="text-left px-2 py-1">Frage/Beschreibung</th>
        </tr>
      </thead>
      <tbody>
        {/* ...Rows... */}
      </tbody>
    </table>
  </div>
</TabsContent>
```

- **System-Tab**: Einfache Eingabe (controlled) für den System Prompt.
```135:140:src/components/templates/structured-template-editor.tsx
<TabsContent value="system">
  <div className="space-y-1">
    <Label>System Prompt</Label>
    <Input value={sysPrompt} onChange={(e) => handleSysPromptChange(e.target.value)} className="font-mono h-8 text-xs" />
  </div>
</TabsContent>
```

### Logik der Feld-Updates

- **Body**: Globaler Regex-Rewrite aller `{{key|...}}` im Markdown-Body; danach `onChange` mit aktualisiertem Body.
```42:46:src/components/templates/structured-template-editor.tsx
const updateBodyQuestion = (key: string, question: string) => {
  const re = new RegExp(`\\{\\{\\s*${escapeRegExp(key)}\\s*\\|[^}]*\\}\\}`,'g')
  const next = markdownBody.replace(re, `{{${key}|${question}}}`)
  onChange({ markdownBody: next, yamlFrontmatter, systemPrompt: sysPrompt })
}
```

- **Frontmatter**: Zeilenweise Suche nach Key, Austausch nur des Frage-Teils rechts vom `|`; `onChange` mit aktualisiertem Frontmatter.
```48:60:src/components/templates/structured-template-editor.tsx
const updateFrontmatterQuestion = (entryKey: string, question: string) => {
  const lines = (yamlFrontmatter || '').split('\n')
  const idx = lines.findIndex(l => new RegExp(`^${escapeRegExp(entryKey)}\s*:`).test(l.trim()))
  if (idx >= 0) {
    const line = lines[idx]
    const m = /\{\{([^}|]+)\|([^}]+)\}\}/.exec(line)
    if (m) {
      lines[idx] = line.replace(m[0], `{{${m[1]}|${question}}}`)
    }
    onChange({ markdownBody, yamlFrontmatter: lines.join('\n'), systemPrompt: sysPrompt })
  }
}
```

### Einschätzung und kleine Verbesserungsvorschläge

- **Funktioniert**: Ja, die Inline-Edits werden zuverlässig in `markdownBody`/`yamlFrontmatter` reflektiert; Frontmatter-Tab ist sauber „controlled“ mit Sticky-Header und Scroll.
- **Kleine Risiken**:
  - Body-Textareas sind „uncontrolled“ → bei Template-Wechsel oder externen Prop-Änderungen können Inhalte veralten. Empfehlung: `value={r.question}` statt `defaultValue`.
  - `updateFrontmatterQuestion` aktualisiert nur, wenn die Zeile bereits einen `{{var|...}}`-Platzhalter enthält. Fehlt dieser, passiert nichts. Das ist okay, aber zu beachten.

```typescriptreact
<TabsContent value="body">
  <div className="overflow-auto">
    <Table className="text-[11px] w-full border-collapse">
      <TableHeader>
        <TableRow className="[&>*]:py-1">
          <TableHead className="w-36">Variable</TableHead>
          <TableHead>Frage/Beschreibung</TableHead>
        </TableRow>
      </TableHeader>
      <TableBody>
        {bodyRows.length === 0 ? (
          <TableRow><TableCell colSpan={2} className="text-muted-foreground">Keine Einträge im Body.</TableCell></TableRow>
        ) : bodyRows.map((r, i) => r.kind === 'section' ? (
          <TableRow key={`sec-${i}`} className="bg-muted/20 align-top">
            <TableCell colSpan={2} className="font-medium whitespace-pre-wrap break-words py-1">{r.label}</TableCell>
          </TableRow>
        ) : (
          <TableRow key={`pl-${r.key}-${i}`} className="align-top">
            <TableCell className="align-top font-mono w-36 py-1">{r.key}</TableCell>
            <TableCell className="align-top py-1">
              <textarea defaultValue={r.question} onChange={(e) => updateBodyQuestion(r.key, e.target.value)} className="w-full min-h-[2.5rem] resize-y rounded-md border bg-background px-2 py-1 text-[11px] leading-snug" />
            </TableCell>
          </TableRow>
        ))}
      </TableBody>
    </Table>
  </div>
</TabsContent>
```

```typescriptreact
<TabsContent value="frontmatter">
  <div className="max-h-[50vh] overflow-auto rounded border">
    <table className="w-full text-[11px] border-collapse">
      <thead className="sticky top-0 bg-background">
        <tr>
          <th className="w-40 text-left px-2 py-1">Key</th>
          <th className="w-40 text-left px-2 py-1">Variable</th>
          <th className="text-left px-2 py-1">Frage/Beschreibung</th>
        </tr>
      </thead>
      <tbody>
        {/* ...Rows... */}
      </tbody>
    </table>
  </div>
</TabsContent>
```

```typescriptreact
<TabsContent value="system">
  <div className="space-y-1">
    <Label>System Prompt</Label>
    <Input value={sysPrompt} onChange={(e) => handleSysPromptChange(e.target.value)} className="font-mono h-8 text-xs" />
  </div>
</TabsContent>
```

```typescriptreact
const updateBodyQuestion = (key: string, question: string) => {
  const re = new RegExp(`\\{\\{\\s*${escapeRegExp(key)}\\s*\\|[^}]*\\}\\}`,'g')
  const next = markdownBody.replace(re, `{{${key}|${question}}}`)
  onChange({ markdownBody: next, yamlFrontmatter, systemPrompt: sysPrompt })
}
```

```typescriptreact
const updateFrontmatterQuestion = (entryKey: string, question: string) => {
  const lines = (yamlFrontmatter || '').split('\n')
  const idx = lines.findIndex(l => new RegExp(`^${escapeRegExp(entryKey)}\s*:`).test(l.trim()))
  if (idx >= 0) {
    const line = lines[idx]
    const m = /\{\{([^}|]+)\|([^}]+)\}\}/.exec(line)
    if (m) {
      lines[idx] = line.replace(m[0], `{{${m[1]}|${question}}}`)
    }
    onChange({ markdownBody, yamlFrontmatter: lines.join('\n'), systemPrompt: sysPrompt })
  }
}
```

---

**User**

Im Bearbeitungsmodus gefällt mir dieses Inline-Editing nicht. Ich möchte eigentlich nur eine normale Tabelle haben, wo die Texte nicht in der höhe abgeschnitten sind, sondern dynamisch vertikal wachsen. Die Zeilenhöhe abhängig vom Textinhalt. Erst wenn man in eine Zelle klickt, sollte der Inhalt editierbar werden. Durch eine Inline-Editing. Können wir diese Darstellung ändern? 

---

**Cursor**

Ich passe die Darstellung im Bearbeitungsmodus an: Anzeige als normale Tabelle mit automatisch wachsender Zeilenhöhe; Editiermodus startet erst per Klick in die Zelle. Ich ersetze die immer sichtbaren Textareas durch eine Inline-Editing-Zelle, die beim Klick ein autosizendes Textfeld einblendet und bei Blur wieder in die Anzeige wechselt. Jetzt implementiere ich die Änderungen.

```typescriptreact
"use client";

import * as React from 'react'
import { assignHeadingsToPlaceholders } from '@/lib/templates/placeholders'
import { extractFrontmatterBlock, parseFrontmatterKeyValues } from '@/lib/markdown/frontmatter'
import { Button } from '@/components/ui/button'
import { Input } from '@/components/ui/input'
import { Label } from '@/components/ui/label'
import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from '@/components/ui/table'
import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs'

export interface StructuredTemplateEditorProps {
  markdownBody: string
  yamlFrontmatter: string
  systemPrompt: string
  onChange: (next: { markdownBody: string; yamlFrontmatter: string; systemPrompt: string }) => void
}

export function StructuredTemplateEditor({ markdownBody, yamlFrontmatter, systemPrompt, onChange }: StructuredTemplateEditorProps) {
  const bodyHits = React.useMemo(() => assignHeadingsToPlaceholders(markdownBody), [markdownBody])
  const fmEntries = React.useMemo(() => parseFrontmatterKeyValues(yamlFrontmatter || ''), [yamlFrontmatter])
  const [sysPrompt, setSysPrompt] = React.useState(systemPrompt)
  const [tab, setTab] = React.useState<'body'|'frontmatter'|'system'>('body')

  React.useEffect(() => { setSysPrompt(systemPrompt) }, [systemPrompt])

  // Body neu aufbauen: Abschnitte (Headings) + Platzhalterzeilen
  type BodyRow = { kind: 'section'; label: string } | { kind: 'placeholder'; key: string; question: string }
  const bodyRows: BodyRow[] = React.useMemo(() => {
    const rows: BodyRow[] = []
    for (const h of bodyHits) {
      const label = h.headingPath.length > 0 ? h.headingPath[h.headingPath.length - 1] : ''
      if (label) {
        rows.push({ kind: 'section', label })
      }
      rows.push({ kind: 'placeholder', key: h.key, question: h.question })
    }
    return rows.length > 0 ? rows : []
  }, [bodyHits])

  // Inline‑Edit für Body‑Variablen (nur Frage editieren; Key‑Änderung folgt später)
  const updateBodyQuestion = (key: string, question: string) => {
    const re = new RegExp(`\\{\\{\\s*${escapeRegExp(key)}\\s*\\|[^}]*\\}\\}`,'g')
    const next = markdownBody.replace(re, `{{${key}|${question}}}`)
    onChange({ markdownBody: next, yamlFrontmatter, systemPrompt: sysPrompt })
  }

  // Inline‑Edit für Frontmatter‑Zeilen (nur Frage‑Teil rechts vom |)
  const updateFrontmatterQuestion = (entryKey: string, question: string) => {
    const lines = (yamlFrontmatter || '').split('\n')
    const idx = lines.findIndex(l => new RegExp(`^${escapeRegExp(entryKey)}\s*:`).test(l.trim()))
    if (idx >= 0) {
      const line = lines[idx]
      const m = /\{\{([^}|]+)\|([^}]+)\}\}/.exec(line)
      if (m) {
        lines[idx] = line.replace(m[0], `{{${m[1]}|${question}}}`)
      }
      onChange({ markdownBody, yamlFrontmatter: lines.join('\n'), systemPrompt: sysPrompt })
    }
  }

  const handleSysPromptChange = (v: string) => {
    setSysPrompt(v)
    onChange({ markdownBody, yamlFrontmatter, systemPrompt: v })
  }

  return (
    <div className="space-y-3">
      <Tabs value={tab} onValueChange={(v) => setTab(v as typeof tab)}>
        <TabsList className="grid grid-cols-3 w-full">
          <TabsTrigger value="body">Body</TabsTrigger>
          <TabsTrigger value="frontmatter">Frontmatter</TabsTrigger>
          <TabsTrigger value="system">System</TabsTrigger>
        </TabsList>

        <TabsContent value="body">
          <div className="overflow-auto">
            <Table className="text-[11px] w-full border-collapse">
              <TableHeader>
                <TableRow className="[&>*]:py-1">
                  <TableHead className="w-36">Variable</TableHead>
                  <TableHead>Frage/Beschreibung</TableHead>
                </TableRow>
              </TableHeader>
              <TableBody>
                {bodyRows.length === 0 ? (
                  <TableRow><TableCell colSpan={2} className="text-muted-foreground">Keine Einträge im Body.</TableCell></TableRow>
                ) : bodyRows.map((r, i) => r.kind === 'section' ? (
                  <TableRow key={`sec-${i}`} className="bg-muted/20 align-top">
                    <TableCell colSpan={2} className="font-medium whitespace-pre-wrap break-words py-1">{r.label}</TableCell>
                  </TableRow>
                ) : (
                  <TableRow key={`pl-${r.key}-${i}`} className="align-top">
                    <TableCell className="align-top font-mono w-36 py-1">{r.key}</TableCell>
                    <TableCell className="align-top py-1">
                      <InlineEditableCell
                        value={r.question}
                        onChange={(val) => updateBodyQuestion(r.key, val)}
                        placeholder="Klicken zum Bearbeiten"
                      />
                    </TableCell>
                  </TableRow>
                ))}
              </TableBody>
            </Table>
          </div>
        </TabsContent>

        <TabsContent value="frontmatter">
          <div className="max-h-[50vh] overflow-auto rounded border">
            <table className="w-full text-[11px] border-collapse">
              <thead className="sticky top-0 bg-background">
                <tr>
                  <th className="w-40 text-left px-2 py-1">Key</th>
                  <th className="w-40 text-left px-2 py-1">Variable</th>
                  <th className="text-left px-2 py-1">Frage/Beschreibung</th>
                </tr>
              </thead>
              <tbody>
                {fmEntries.length === 0 ? (
                  <tr><td colSpan={3} className="px-2 py-1 text-muted-foreground">Keine Felder im Frontmatter.</td></tr>
                ) : fmEntries.map((e, i) => {
                  const m = /\{\{([^}|]+)\|([^}]+)\}\}/.exec(e.rawValue)
                  const varKey = m ? m[1].trim() : ''
                  const varQ = m ? m[2].trim() : ''
                  return (
                    <tr key={`${e.key}-${i}`} className="align-top">
                      <td className="px-2 py-1 align-top font-mono">{e.key}</td>
                      <td className="px-2 py-1 align-top font-mono">{varKey}</td>
                      <td className="px-2 py-1 align-top">
                        <InlineEditableCell
                          value={varQ}
                          onChange={(val) => updateFrontmatterQuestion(e.key, val)}
                          placeholder="Klicken zum Bearbeiten"
                        />
                      </td>
                    </tr>
                  )
                })}
              </tbody>
            </table>
          </div>
        </TabsContent>

        <TabsContent value="system">
          <div className="space-y-1">
            <Label>System Prompt</Label>
            <Input value={sysPrompt} onChange={(e) => handleSysPromptChange(e.target.value)} className="font-mono h-8 text-xs" />
          </div>
        </TabsContent>
      </Tabs>
    </div>
  )
}

function escapeRegExp(s: string): string {
  return s.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')
}

// Inline-Edit Textarea, wächst dynamisch, aktiviert Edit bei Fokus/Klick
function EditableTextarea({ value, onChange, onBlur, onKeyDown }: { value: string; onChange: (v: string) => void; onBlur?: () => void; onKeyDown?: (e: React.KeyboardEvent<HTMLTextAreaElement>) => void }) {
  const [local, setLocal] = React.useState(value)
  const ref = React.useRef<HTMLTextAreaElement | null>(null)

  const autosize = React.useCallback(() => {
    const el = ref.current
    if (!el) return
    el.style.height = 'auto'
    el.style.height = `${el.scrollHeight}px`
  }, [])

  React.useEffect(() => { setLocal(value); requestAnimationFrame(autosize) }, [value, autosize])

  return (
    <textarea
      ref={ref}
      value={local}
      onChange={(e) => { setLocal(e.target.value); onChange(e.target.value); autosize() }}
      onInput={autosize}
      onBlur={onBlur}
      onKeyDown={onKeyDown}
      className="w-full min-h-[2.5rem] rounded-md border bg-background px-2 py-1 text-[11px] leading-snug overflow-hidden"
      style={{ resize: 'none' }}
    />
  )
}

// Zelle, die erst beim Klick in den Editiermodus mit autosizender Textarea wechselt
function InlineEditableCell({ value, onChange, placeholder }: { value: string; onChange: (v: string) => void; placeholder?: string }) {
  const [editing, setEditing] = React.useState(false)

  if (!editing) {
    return (
      <div
        role="button"
        onClick={() => setEditing(true)}
        className="cursor-text whitespace-pre-wrap break-words rounded-md px-2 py-1 min-h-[2.5rem]"
      >
        {value ? value : <span className="text-muted-foreground">{placeholder || 'Klicken zum Bearbeiten'}</span>}
      </div>
    )
  }

  return (
    <EditableTextarea
      value={value}
      onChange={onChange}
      onBlur={() => setEditing(false)}
      onKeyDown={(e) => { if (e.key === 'Escape') { e.preventDefault(); e.stopPropagation(); setEditing(false) } }}
    />
  )
}


```

Ich habe die Body-/Frontmatter-Tabellen auf klickbasiertes Inline-Editing umgestellt: standardmäßig reine Anzeige mit dynamischer Zeilenhöhe; erst beim Klick erscheint eine autosizende Textarea, die bei Blur/Escape wieder schließt. Ich prüfe nun Linter/Typfehler für die geänderte Datei.

- Änderungen umgesetzt: Anzeige als normale Tabelle; Zeilen wachsen dynamisch durch `whitespace-pre-wrap`/`break-words`. Edit startet erst per Klick in die Zelle. Beim Bearbeiten wird eine autosizende Textarea eingeblendet, Blur/Escape beendet den Modus. Body- und Frontmatter-Tab nutzen jetzt die gleiche Inline-Zellenkomponente.

- Technische Details:
  - Body-Tab: `InlineEditableCell` ersetzt dauerhafte Textarea. Update via `updateBodyQuestion`.
  - Frontmatter-Tab: `InlineEditableCell` ersetzt `EditableTextarea`. Update via `updateFrontmatterQuestion`.
  - `EditableTextarea` unterstützt jetzt `onBlur`/`onKeyDown`, bleibt controlled und autosized, kein abgeschnittener Text.
  - Scroll: Body-Tab wie zuvor container-abhängig; Frontmatter-Tab weiterhin `max-h-[50vh] overflow-auto` mit sticky Header.

- Tests:
  - Klick in eine Body-Zelle: Text wird editierbar; Blur/Escape schließt; Änderung persistiert in der Vorschau/Speichern.
  - Frontmatter-Tab gleiches Verhalten; Header bleibt sticky beim Scrollen.
  - Template-Wechsel: Anzeige zeigt neue Werte; Editmodus ist geschlossen.

- Hinweis:
  - Falls „Enter“ Zeilenumbrüche erzeugen soll (aktuell ja), ist nichts weiter nötig. Wenn stattdessen Enter den Editiermodus beenden soll, kann ich das als Option ergänzen.

---

**User**

Die Reaktion sollte bündig mit der zweiten Spalte sein, d.h. die erste Spalte ist leer. Da sie zum Fleece-Text gehört, so kann man in der Tabelle von oben nach unten lesen und nur die Variablen stehen in der ersten Spalte.

---

**Cursor**

Ich passe die Abschnittszeilen an: Die erste Spalte bleibt leer, der Abschnittstitel erscheint nur in der zweiten Spalte und bündig zu den Reaktions-/Beschreibungstexten. Jetzt ändere ich die Render-Logik entsprechend.

```typescriptreact
"use client";

import * as React from 'react'
import { assignHeadingsToPlaceholders } from '@/lib/templates/placeholders'
import { extractFrontmatterBlock, parseFrontmatterKeyValues } from '@/lib/markdown/frontmatter'
import { Button } from '@/components/ui/button'
import { Input } from '@/components/ui/input'
import { Label } from '@/components/ui/label'
import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from '@/components/ui/table'
import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs'

export interface StructuredTemplateEditorProps {
  markdownBody: string
  yamlFrontmatter: string
  systemPrompt: string
  onChange: (next: { markdownBody: string; yamlFrontmatter: string; systemPrompt: string }) => void
}

export function StructuredTemplateEditor({ markdownBody, yamlFrontmatter, systemPrompt, onChange }: StructuredTemplateEditorProps) {
  const bodyHits = React.useMemo(() => assignHeadingsToPlaceholders(markdownBody), [markdownBody])
  const fmEntries = React.useMemo(() => parseFrontmatterKeyValues(yamlFrontmatter || ''), [yamlFrontmatter])
  const [sysPrompt, setSysPrompt] = React.useState(systemPrompt)
  const [tab, setTab] = React.useState<'body'|'frontmatter'|'system'>('body')

  React.useEffect(() => { setSysPrompt(systemPrompt) }, [systemPrompt])

  // Body neu aufbauen: Abschnitte (Headings) + Platzhalterzeilen
  type BodyRow = { kind: 'section'; label: string } | { kind: 'placeholder'; key: string; question: string }
  const bodyRows: BodyRow[] = React.useMemo(() => {
    const rows: BodyRow[] = []
    for (const h of bodyHits) {
      const label = h.headingPath.length > 0 ? h.headingPath[h.headingPath.length - 1] : ''
      if (label) {
        rows.push({ kind: 'section', label })
      }
      rows.push({ kind: 'placeholder', key: h.key, question: h.question })
    }
    return rows.length > 0 ? rows : []
  }, [bodyHits])

  // Inline‑Edit für Body‑Variablen (nur Frage editieren; Key‑Änderung folgt später)
  const updateBodyQuestion = (key: string, question: string) => {
    const re = new RegExp(`\\{\\{\\s*${escapeRegExp(key)}\\s*\\|[^}]*\\}\\}`,'g')
    const next = markdownBody.replace(re, `{{${key}|${question}}}`)
    onChange({ markdownBody: next, yamlFrontmatter, systemPrompt: sysPrompt })
  }

  // Inline‑Edit für Frontmatter‑Zeilen (nur Frage‑Teil rechts vom |)
  const updateFrontmatterQuestion = (entryKey: string, question: string) => {
    const lines = (yamlFrontmatter || '').split('\n')
    const idx = lines.findIndex(l => new RegExp(`^${escapeRegExp(entryKey)}\s*:`).test(l.trim()))
    if (idx >= 0) {
      const line = lines[idx]
      const m = /\{\{([^}|]+)\|([^}]+)\}\}/.exec(line)
      if (m) {
        lines[idx] = line.replace(m[0], `{{${m[1]}|${question}}}`)
      }
      onChange({ markdownBody, yamlFrontmatter: lines.join('\n'), systemPrompt: sysPrompt })
    }
  }

  const handleSysPromptChange = (v: string) => {
    setSysPrompt(v)
    onChange({ markdownBody, yamlFrontmatter, systemPrompt: v })
  }

  return (
    <div className="space-y-3">
      <Tabs value={tab} onValueChange={(v) => setTab(v as typeof tab)}>
        <TabsList className="grid grid-cols-3 w-full">
          <TabsTrigger value="body">Body</TabsTrigger>
          <TabsTrigger value="frontmatter">Frontmatter</TabsTrigger>
          <TabsTrigger value="system">System</TabsTrigger>
        </TabsList>

        <TabsContent value="body">
          <div className="overflow-auto">
            <Table className="text-[11px] w-full border-collapse">
              <TableHeader>
                <TableRow className="[&>*]:py-1">
                  <TableHead className="w-36">Variable</TableHead>
                  <TableHead>Frage/Beschreibung</TableHead>
                </TableRow>
              </TableHeader>
              <TableBody>
                {bodyRows.length === 0 ? (
                  <TableRow><TableCell colSpan={2} className="text-muted-foreground">Keine Einträge im Body.</TableCell></TableRow>
                ) : bodyRows.map((r, i) => r.kind === 'section' ? (
                  <TableRow key={`sec-${i}`} className="bg-muted/20 align-top">
                    <TableCell className="w-36 py-1" />
                    <TableCell className="py-1 font-medium whitespace-pre-wrap break-words">{r.label}</TableCell>
                  </TableRow>
                ) : (
                  <TableRow key={`pl-${r.key}-${i}`} className="align-top">
                    <TableCell className="align-top font-mono w-36 py-1">{r.key}</TableCell>
                    <TableCell className="align-top py-1">
                      <InlineEditableCell
                        value={r.question}
                        onChange={(val) => updateBodyQuestion(r.key, val)}
                        placeholder="Klicken zum Bearbeiten"
                      />
                    </TableCell>
                  </TableRow>
                ))}
              </TableBody>
            </Table>
          </div>
        </TabsContent>

        <TabsContent value="frontmatter">
          <div className="max-h-[50vh] overflow-auto rounded border">
            <table className="w-full text-[11px] border-collapse">
              <thead className="sticky top-0 bg-background">
                <tr>
                  <th className="w-40 text-left px-2 py-1">Key</th>
                  <th className="w-40 text-left px-2 py-1">Variable</th>
                  <th className="text-left px-2 py-1">Frage/Beschreibung</th>
                </tr>
              </thead>
              <tbody>
                {fmEntries.length === 0 ? (
                  <tr><td colSpan={3} className="px-2 py-1 text-muted-foreground">Keine Felder im Frontmatter.</td></tr>
                ) : fmEntries.map((e, i) => {
                  const m = /\{\{([^}|]+)\|([^}]+)\}\}/.exec(e.rawValue)
                  const varKey = m ? m[1].trim() : ''
                  const varQ = m ? m[2].trim() : ''
                  return (
                    <tr key={`${e.key}-${i}`} className="align-top">
                      <td className="px-2 py-1 align-top font-mono">{e.key}</td>
                      <td className="px-2 py-1 align-top font-mono">{varKey}</td>
                      <td className="px-2 py-1 align-top">
                        <InlineEditableCell
                          value={varQ}
                          onChange={(val) => updateFrontmatterQuestion(e.key, val)}
                          placeholder="Klicken zum Bearbeiten"
                        />
                      </td>
                    </tr>
                  )
                })}
              </tbody>
            </table>
          </div>
        </TabsContent>

        <TabsContent value="system">
          <div className="space-y-1">
            <Label>System Prompt</Label>
            <Input value={sysPrompt} onChange={(e) => handleSysPromptChange(e.target.value)} className="font-mono h-8 text-xs" />
          </div>
        </TabsContent>
      </Tabs>
    </div>
  )
}

function escapeRegExp(s: string): string {
  return s.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')
}

// Inline-Edit Textarea, wächst dynamisch, aktiviert Edit bei Fokus/Klick
function EditableTextarea({ value, onChange, onBlur, onKeyDown }: { value: string; onChange: (v: string) => void; onBlur?: () => void; onKeyDown?: (e: React.KeyboardEvent<HTMLTextAreaElement>) => void }) {
  const [local, setLocal] = React.useState(value)
  const ref = React.useRef<HTMLTextAreaElement | null>(null)

  const autosize = React.useCallback(() => {
    const el = ref.current
    if (!el) return
    el.style.height = 'auto'
    el.style.height = `${el.scrollHeight}px`
  }, [])

  React.useEffect(() => { setLocal(value); requestAnimationFrame(autosize) }, [value, autosize])

  return (
    <textarea
      ref={ref}
      value={local}
      onChange={(e) => { setLocal(e.target.value); onChange(e.target.value); autosize() }}
      onInput={autosize}
      onBlur={onBlur}
      onKeyDown={onKeyDown}
      className="w-full min-h-[2.5rem] rounded-md border bg-background px-2 py-1 text-[11px] leading-snug overflow-hidden"
      style={{ resize: 'none' }}
    />
  )
}

// Zelle, die erst beim Klick in den Editiermodus mit autosizender Textarea wechselt
function InlineEditableCell({ value, onChange, placeholder }: { value: string; onChange: (v: string) => void; placeholder?: string }) {
  const [editing, setEditing] = React.useState(false)

  if (!editing) {
    return (
      <div
        role="button"
        onClick={() => setEditing(true)}
        className="cursor-text whitespace-pre-wrap break-words rounded-md px-2 py-1 min-h-[2.5rem]"
      >
        {value ? value : <span className="text-muted-foreground">{placeholder || 'Klicken zum Bearbeiten'}</span>}
      </div>
    )
  }

  return (
    <EditableTextarea
      value={value}
      onChange={onChange}
      onBlur={() => setEditing(false)}
      onKeyDown={(e) => { if (e.key === 'Escape') { e.preventDefault(); e.stopPropagation(); setEditing(false) } }}
    />
  )
}


```

Ich habe die Abschnittszeilen so geändert, dass Spalte 1 leer bleibt und der Abschnittstitel nur in Spalte 2 steht; damit sind Titel und Reaktionstexte bündig in der zweiten Spalte, und die Variablen bleiben klar in Spalte 1.

---

**User**

Auch diese Abschnittstexte muss ich editieren, genauso wie die mit den Variablen.

---

**Cursor**

Ich erweitere jetzt den Body-Tab um Inline-Editing für Abschnittszeilen. Beim Ändern wird die entsprechende Markdown-Überschrift im `markdownBody` ersetzt, sodass die Struktur intakt bleibt. Ich implementiere die Änderung direkt.

```typescriptreact
*** Begin Patch
*** Update File: src/components/templates/structured-template-editor.tsx
@@
-import { assignHeadingsToPlaceholders } from '@/lib/templates/placeholders'
+import { assignHeadingsToPlaceholders, parseHeadings } from '@/lib/templates/placeholders'
@@
-  const bodyHits = React.useMemo(() => assignHeadingsToPlaceholders(markdownBody), [markdownBody])
+  const bodyHits = React.useMemo(() => assignHeadingsToPlaceholders(markdownBody), [markdownBody])
+  const headings = React.useMemo(() => parseHeadings(markdownBody), [markdownBody])
@@
-  // Body neu aufbauen: Abschnitte (Headings) + Platzhalterzeilen
-  type BodyRow = { kind: 'section'; label: string } | { kind: 'placeholder'; key: string; question: string }
+  // Body neu aufbauen: Abschnitte (Headings) + Platzhalterzeilen
+  type BodyRow = { kind: 'section'; label: string; headingStart: number; level: 1|2|3|4|5|6 } | { kind: 'placeholder'; key: string; question: string }
   const bodyRows: BodyRow[] = React.useMemo(() => {
     const rows: BodyRow[] = []
     for (const h of bodyHits) {
-      const label = h.headingPath.length > 0 ? h.headingPath[h.headingPath.length - 1] : ''
-      if (label) {
-        rows.push({ kind: 'section', label })
-      }
+      // finde letzte Überschrift vor dem Platzhalter
+      const prev = headings.filter(x => x.start <= h.index)
+      const last = prev.length > 0 ? prev[prev.length - 1] : null
+      const label = last ? last.title : ''
+      if (last && label) rows.push({ kind: 'section', label, headingStart: last.start, level: last.level })
       rows.push({ kind: 'placeholder', key: h.key, question: h.question })
     }
     return rows.length > 0 ? rows : []
-  }, [bodyHits])
+  }, [bodyHits, headings])
@@
   // Inline‑Edit für Body‑Variablen (nur Frage editieren; Key‑Änderung folgt später)
   const updateBodyQuestion = (key: string, question: string) => {
     const re = new RegExp(`\\{\\{\\s*${escapeRegExp(key)}\\s*\\|[^}]*\\}}`,'g')
     const next = markdownBody.replace(re, `{{${key}|${question}}}`)
     onChange({ markdownBody: next, yamlFrontmatter, systemPrompt: sysPrompt })
   }
+
+  // Inline‑Edit für Abschnittsüberschriften: Ersetzt Heading-Zeile an bekannter Position
+  const updateSectionTitle = (headingStart: number, level: 1|2|3|4|5|6, title: string) => {
+    const lineEnd = markdownBody.indexOf('\n', headingStart)
+    const end = lineEnd === -1 ? markdownBody.length : lineEnd
+    const newLine = `${'#'.repeat(level)} ${title}`
+    const next = markdownBody.slice(0, headingStart) + newLine + markdownBody.slice(end)
+    onChange({ markdownBody: next, yamlFrontmatter, systemPrompt: sysPrompt })
+  }
@@
-                ) : bodyRows.map((r, i) => r.kind === 'section' ? (
+                ) : bodyRows.map((r, i) => r.kind === 'section' ? (
                   <TableRow key={`sec-${i}`} className="bg-muted/20 align-top">
                     <TableCell className="w-36 py-1" />
-                    <TableCell className="py-1 font-medium whitespace-pre-wrap break-words">{r.label}</TableCell>
+                    <TableCell className="py-1 font-medium whitespace-pre-wrap break-words">
+                      <InlineEditableCell
+                        value={r.label}
+                        onChange={(val) => updateSectionTitle(r.headingStart, r.level, val)}
+                        placeholder="Abschnittstitel bearbeiten"
+                      />
+                    </TableCell>
                   </TableRow>
                 ) : (
*** End Patch
```

Ich lese die aktuelle Datei, um die genauen Stellen für die Erweiterung des Inline-Editings der Abschnittsüberschriften präzise zu ändern.

```typescriptreact
*** Begin Patch
*** Update File: src/components/templates/structured-template-editor.tsx
@@
-import * as React from 'react'
-import { assignHeadingsToPlaceholders } from '@/lib/templates/placeholders'
+import * as React from 'react'
+import { assignHeadingsToPlaceholders, parseHeadings } from '@/lib/templates/placeholders'
@@
-  const bodyHits = React.useMemo(() => assignHeadingsToPlaceholders(markdownBody), [markdownBody])
+  const bodyHits = React.useMemo(() => assignHeadingsToPlaceholders(markdownBody), [markdownBody])
+  const headings = React.useMemo(() => parseHeadings(markdownBody), [markdownBody])
@@
-  // Body neu aufbauen: Abschnitte (Headings) + Platzhalterzeilen
-  type BodyRow = { kind: 'section'; label: string } | { kind: 'placeholder'; key: string; question: string }
+  // Body neu aufbauen: Abschnitte (Headings) + Platzhalterzeilen
+  type BodyRow = { kind: 'section'; label: string; headingStart: number; level: 1|2|3|4|5|6 } | { kind: 'placeholder'; key: string; question: string }
   const bodyRows: BodyRow[] = React.useMemo(() => {
     const rows: BodyRow[] = []
     for (const h of bodyHits) {
-      const label = h.headingPath.length > 0 ? h.headingPath[h.headingPath.length - 1] : ''
-      if (label) {
-        rows.push({ kind: 'section', label })
-      }
+      const prev = headings.filter(x => x.start <= h.index)
+      const last = prev.length > 0 ? prev[prev.length - 1] : null
+      const label = last ? last.title : ''
+      if (last && label) rows.push({ kind: 'section', label, headingStart: last.start, level: last.level })
       rows.push({ kind: 'placeholder', key: h.key, question: h.question })
     }
     return rows.length > 0 ? rows : []
-  }, [bodyHits])
+  }, [bodyHits, headings])
@@
   const updateBodyQuestion = (key: string, question: string) => {
     const re = new RegExp(`\\{\\{\\s*${escapeRegExp(key)}\\s*\\|[^}]*\\}}`,'g')
     const next = markdownBody.replace(re, `{{${key}|${question}}}`)
     onChange({ markdownBody: next, yamlFrontmatter, systemPrompt: sysPrompt })
   }
+
+  // Inline‑Edit für Abschnittsüberschriften (Markdown-Heading-Zeile ersetzen)
+  const updateSectionTitle = (headingStart: number, level: 1|2|3|4|5|6, title: string) => {
+    const lineEnd = markdownBody.indexOf('\n', headingStart)
+    const end = lineEnd === -1 ? markdownBody.length : lineEnd
+    const newLine = `${'#'.repeat(level)} ${title}`
+    const next = markdownBody.slice(0, headingStart) + newLine + markdownBody.slice(end)
+    onChange({ markdownBody: next, yamlFrontmatter, systemPrompt: sysPrompt })
+  }
@@
-                ) : bodyRows.map((r, i) => r.kind === 'section' ? (
-                  <TableRow key={`sec-${i}`} className="bg-muted/20 align-top">
-                    <TableCell className="w-36 py-1" />
-                    <TableCell className="py-1 font-medium whitespace-pre-wrap break-words">{r.label}</TableCell>
-                  </TableRow>
-                ) : (
+                ) : bodyRows.map((r, i) => r.kind === 'section' ? (
+                  <TableRow key={`sec-${i}`} className="bg-muted/20 align-top">
+                    <TableCell className="w-36 py-1" />
+                    <TableCell className="py-1 font-medium whitespace-pre-wrap break-words">
+                      <InlineEditableCell
+                        value={r.label}
+                        onChange={(val) => updateSectionTitle(r.headingStart, r.level, val)}
+                        placeholder="Abschnittstitel bearbeiten"
+                      />
+                    </TableCell>
+                  </TableRow>
+                ) : (
*** End Patch
```

```typescriptreact
"use client";

import * as React from 'react'
import { assignHeadingsToPlaceholders, parseHeadings } from '@/lib/templates/placeholders'
import { extractFrontmatterBlock, parseFrontmatterKeyValues } from '@/lib/markdown/frontmatter'
import { Button } from '@/components/ui/button'
import { Input } from '@/components/ui/input'
import { Label } from '@/components/ui/label'
import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from '@/components/ui/table'
import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs'

export interface StructuredTemplateEditorProps {
  markdownBody: string
  yamlFrontmatter: string
  systemPrompt: string
  onChange: (next: { markdownBody: string; yamlFrontmatter: string; systemPrompt: string }) => void
}

export function StructuredTemplateEditor({ markdownBody, yamlFrontmatter, systemPrompt, onChange }: StructuredTemplateEditorProps) {
  const bodyHits = React.useMemo(() => assignHeadingsToPlaceholders(markdownBody), [markdownBody])
  const fmEntries = React.useMemo(() => parseFrontmatterKeyValues(yamlFrontmatter || ''), [yamlFrontmatter])
  const [sysPrompt, setSysPrompt] = React.useState(systemPrompt)
  const [tab, setTab] = React.useState<'body'|'frontmatter'|'system'>('body')

  React.useEffect(() => { setSysPrompt(systemPrompt) }, [systemPrompt])

  // Body neu aufbauen: Abschnitte (Headings) + Platzhalterzeilen
  type BodyRow = { kind: 'section'; label: string } | { kind: 'placeholder'; key: string; question: string }
  const bodyRows: BodyRow[] = React.useMemo(() => {
    const rows: BodyRow[] = []
    for (const h of bodyHits) {
      const label = h.headingPath.length > 0 ? h.headingPath[h.headingPath.length - 1] : ''
      if (label) {
        rows.push({ kind: 'section', label })
      }
      rows.push({ kind: 'placeholder', key: h.key, question: h.question })
    }
    return rows.length > 0 ? rows : []
  }, [bodyHits])

  // Inline‑Edit für Body‑Variablen (nur Frage editieren; Key‑Änderung folgt später)
  const updateBodyQuestion = (key: string, question: string) => {
    const re = new RegExp(`\\{\\{\\s*${escapeRegExp(key)}\\s*\\|[^}]*\\}\\}`,'g')
    const next = markdownBody.replace(re, `{{${key}|${question}}}`)
    onChange({ markdownBody: next, yamlFrontmatter, systemPrompt: sysPrompt })
  }

  // Inline‑Edit für Frontmatter‑Zeilen (nur Frage‑Teil rechts vom |)
  const updateFrontmatterQuestion = (entryKey: string, question: string) => {
    const lines = (yamlFrontmatter || '').split('\n')
    const idx = lines.findIndex(l => new RegExp(`^${escapeRegExp(entryKey)}\s*:`).test(l.trim()))
    if (idx >= 0) {
      const line = lines[idx]
      const m = /\{\{([^}|]+)\|([^}]+)\}\}/.exec(line)
      if (m) {
        lines[idx] = line.replace(m[0], `{{${m[1]}|${question}}}`)
      }
      onChange({ markdownBody, yamlFrontmatter: lines.join('\n'), systemPrompt: sysPrompt })
    }
  }

  const handleSysPromptChange = (v: string) => {
    setSysPrompt(v)
    onChange({ markdownBody, yamlFrontmatter, systemPrompt: v })
  }

  return (
    <div className="space-y-3">
      <Tabs value={tab} onValueChange={(v) => setTab(v as typeof tab)}>
        <TabsList className="grid grid-cols-3 w-full">
          <TabsTrigger value="body">Body</TabsTrigger>
          <TabsTrigger value="frontmatter">Frontmatter</TabsTrigger>
          <TabsTrigger value="system">System</TabsTrigger>
        </TabsList>

        <TabsContent value="body">
          <div className="overflow-auto">
            <Table className="text-[11px] w-full border-collapse">
              <TableHeader>
                <TableRow className="[&>*]:py-1">
                  <TableHead className="w-36">Variable</TableHead>
                  <TableHead>Frage/Beschreibung</TableHead>
                </TableRow>
              </TableHeader>
              <TableBody>
                {bodyRows.length === 0 ? (
                  <TableRow><TableCell colSpan={2} className="text-muted-foreground">Keine Einträge im Body.</TableCell></TableRow>
                ) : bodyRows.map((r, i) => r.kind === 'section' ? (
                  <TableRow key={`sec-${i}`} className="bg-muted/20 align-top">
                    <TableCell className="w-36 py-1" />
                    <TableCell className="py-1 font-medium whitespace-pre-wrap break-words">{r.label}</TableCell>
                  </TableRow>
                ) : (
                  <TableRow key={`pl-${r.key}-${i}`} className="align-top">
                    <TableCell className="align-top font-mono w-36 py-1">{r.key}</TableCell>
                    <TableCell className="align-top py-1">
                      <InlineEditableCell
                        value={r.question}
                        onChange={(val) => updateBodyQuestion(r.key, val)}
                        placeholder="Klicken zum Bearbeiten"
                      />
                    </TableCell>
                  </TableRow>
                ))}
              </TableBody>
            </Table>
          </div>
        </TabsContent>

        <TabsContent value="frontmatter">
          <div className="max-h-[50vh] overflow-auto rounded border">
            <table className="w-full text-[11px] border-collapse">
              <thead className="sticky top-0 bg-background">
                <tr>
                  <th className="w-40 text-left px-2 py-1">Key</th>
                  <th className="w-40 text-left px-2 py-1">Variable</th>
                  <th className="text-left px-2 py-1">Frage/Beschreibung</th>
                </tr>
              </thead>
              <tbody>
                {fmEntries.length === 0 ? (
                  <tr><td colSpan={3} className="px-2 py-1 text-muted-foreground">Keine Felder im Frontmatter.</td></tr>
                ) : fmEntries.map((e, i) => {
                  const m = /\{\{([^}|]+)\|([^}]+)\}\}/.exec(e.rawValue)
                  const varKey = m ? m[1].trim() : ''
                  const varQ = m ? m[2].trim() : ''
                  return (
                    <tr key={`${e.key}-${i}`} className="align-top">
                      <td className="px-2 py-1 align-top font-mono">{e.key}</td>
                      <td className="px-2 py-1 align-top font-mono">{varKey}</td>
                      <td className="px-2 py-1 align-top">
                        <InlineEditableCell
                          value={varQ}
                          onChange={(val) => updateFrontmatterQuestion(e.key, val)}
                          placeholder="Klicken zum Bearbeiten"
                        />
                      </td>
                    </tr>
                  )
                })}
              </tbody>
            </table>
          </div>
        </TabsContent>

        <TabsContent value="system">
          <div className="space-y-1">
            <Label>System Prompt</Label>
            <Input value={sysPrompt} onChange={(e) => handleSysPromptChange(e.target.value)} className="font-mono h-8 text-xs" />
          </div>
        </TabsContent>
      </Tabs>
    </div>
  )
}

function escapeRegExp(s: string): string {
  return s.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')
}

// Inline-Edit Textarea, wächst dynamisch, aktiviert Edit bei Fokus/Klick
function EditableTextarea({ value, onChange, onBlur, onKeyDown }: { value: string; onChange: (v: string) => void; onBlur?: () => void; onKeyDown?: (e: React.KeyboardEvent<HTMLTextAreaElement>) => void }) {
  const [local, setLocal] = React.useState(value)
  const ref = React.useRef<HTMLTextAreaElement | null>(null)

  const autosize = React.useCallback(() => {
    const el = ref.current
    if (!el) return
    el.style.height = 'auto'
    el.style.height = `${el.scrollHeight}px`
  }, [])

  React.useEffect(() => { setLocal(value); requestAnimationFrame(autosize) }, [value, autosize])

  return (
    <textarea
      ref={ref}
      value={local}
      onChange={(e) => { setLocal(e.target.value); onChange(e.target.value); autosize() }}
      onInput={autosize}
      onBlur={onBlur}
      onKeyDown={onKeyDown}
      className="w-full min-h-[2.5rem] rounded-md border bg-background px-2 py-1 text-[11px] leading-snug overflow-hidden"
      style={{ resize: 'none' }}
    />
  )
}

// Zelle, die erst beim Klick in den Editiermodus mit autosizender Textarea wechselt
function InlineEditableCell({ value, onChange, placeholder }: { value: string; onChange: (v: string) => void; placeholder?: string }) {
  const [editing, setEditing] = React.useState(false)

  if (!editing) {
    return (
      <div
        role="button"
        onClick={() => setEditing(true)}
        className="cursor-text whitespace-pre-wrap break-words rounded-md px-2 py-1 min-h-[2.5rem]"
      >
        {value ? value : <span className="text-muted-foreground">{placeholder || 'Klicken zum Bearbeiten'}</span>}
      </div>
    )
  }

  return (
    <EditableTextarea
      value={value}
      onChange={onChange}
      onBlur={() => setEditing(false)}
      onKeyDown={(e) => { if (e.key === 'Escape') { e.preventDefault(); e.stopPropagation(); setEditing(false) } }}
    />
  )
}


```

```typescriptreact
"use client";

import * as React from 'react'
import { assignHeadingsToPlaceholders, parseHeadings } from '@/lib/templates/placeholders'
import { extractFrontmatterBlock, parseFrontmatterKeyValues } from '@/lib/markdown/frontmatter'
import { Button } from '@/components/ui/button'
import { Input } from '@/components/ui/input'
import { Label } from '@/components/ui/label'
import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from '@/components/ui/table'
import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs'

export interface StructuredTemplateEditorProps {
  markdownBody: string
  yamlFrontmatter: string
  systemPrompt: string
  onChange: (next: { markdownBody: string; yamlFrontmatter: string; systemPrompt: string }) => void
}

export function StructuredTemplateEditor({ markdownBody, yamlFrontmatter, systemPrompt, onChange }: StructuredTemplateEditorProps) {
  const bodyHits = React.useMemo(() => assignHeadingsToPlaceholders(markdownBody), [markdownBody])
  const headings = React.useMemo(() => parseHeadings(markdownBody), [markdownBody])
  const fmEntries = React.useMemo(() => parseFrontmatterKeyValues(yamlFrontmatter || ''), [yamlFrontmatter])
  const [sysPrompt, setSysPrompt] = React.useState(systemPrompt)
  const [tab, setTab] = React.useState<'body'|'frontmatter'|'system'>('body')

  React.useEffect(() => { setSysPrompt(systemPrompt) }, [systemPrompt])

  // Body neu aufbauen: Abschnitte (Headings) + Platzhalterzeilen
  type BodyRow = { kind: 'section'; label: string } | { kind: 'placeholder'; key: string; question: string }
  const bodyRows: BodyRow[] = React.useMemo(() => {
    const rows: BodyRow[] = []
    for (const h of bodyHits) {
      const label = h.headingPath.length > 0 ? h.headingPath[h.headingPath.length - 1] : ''
      if (label) {
        rows.push({ kind: 'section', label })
      }
      rows.push({ kind: 'placeholder', key: h.key, question: h.question })
    }
    return rows.length > 0 ? rows : []
  }, [bodyHits])

  // Inline‑Edit für Body‑Variablen (nur Frage editieren; Key‑Änderung folgt später)
  const updateBodyQuestion = (key: string, question: string) => {
    const re = new RegExp(`\\{\\{\\s*${escapeRegExp(key)}\\s*\\|[^}]*\\}\\}`,'g')
    const next = markdownBody.replace(re, `{{${key}|${question}}}`)
    onChange({ markdownBody: next, yamlFrontmatter, systemPrompt: sysPrompt })
  }

  // Inline‑Edit für Frontmatter‑Zeilen (nur Frage‑Teil rechts vom |)
  const updateFrontmatterQuestion = (entryKey: string, question: string) => {
    const lines = (yamlFrontmatter || '').split('\n')
    const idx = lines.findIndex(l => new RegExp(`^${escapeRegExp(entryKey)}\s*:`).test(l.trim()))
    if (idx >= 0) {
      const line = lines[idx]
      const m = /\{\{([^}|]+)\|([^}]+)\}\}/.exec(line)
      if (m) {
        lines[idx] = line.replace(m[0], `{{${m[1]}|${question}}}`)
      }
      onChange({ markdownBody, yamlFrontmatter: lines.join('\n'), systemPrompt: sysPrompt })
    }
  }

  const handleSysPromptChange = (v: string) => {
    setSysPrompt(v)
    onChange({ markdownBody, yamlFrontmatter, systemPrompt: v })
  }

  return (
    <div className="space-y-3">
      <Tabs value={tab} onValueChange={(v) => setTab(v as typeof tab)}>
        <TabsList className="grid grid-cols-3 w-full">
          <TabsTrigger value="body">Body</TabsTrigger>
          <TabsTrigger value="frontmatter">Frontmatter</TabsTrigger>
          <TabsTrigger value="system">System</TabsTrigger>
        </TabsList>

        <TabsContent value="body">
          <div className="overflow-auto">
            <Table className="text-[11px] w-full border-collapse">
              <TableHeader>
                <TableRow className="[&>*]:py-1">
                  <TableHead className="w-36">Variable</TableHead>
                  <TableHead>Frage/Beschreibung</TableHead>
                </TableRow>
              </TableHeader>
              <TableBody>
                {bodyRows.length === 0 ? (
                  <TableRow><TableCell colSpan={2} className="text-muted-foreground">Keine Einträge im Body.</TableCell></TableRow>
                ) : bodyRows.map((r, i) => r.kind === 'section' ? (
                  <TableRow key={`sec-${i}`} className="bg-muted/20 align-top">
                    <TableCell className="w-36 py-1" />
                    <TableCell className="py-1 font-medium whitespace-pre-wrap break-words">{r.label}</TableCell>
                  </TableRow>
                ) : (
                  <TableRow key={`pl-${r.key}-${i}`} className="align-top">
                    <TableCell className="align-top font-mono w-36 py-1">{r.key}</TableCell>
                    <TableCell className="align-top py-1">
                      <InlineEditableCell
                        value={r.question}
                        onChange={(val) => updateBodyQuestion(r.key, val)}
                        placeholder="Klicken zum Bearbeiten"
                      />
                    </TableCell>
                  </TableRow>
                ))}
              </TableBody>
            </Table>
          </div>
        </TabsContent>

        <TabsContent value="frontmatter">
          <div className="max-h-[50vh] overflow-auto rounded border">
            <table className="w-full text-[11px] border-collapse">
              <thead className="sticky top-0 bg-background">
                <tr>
                  <th className="w-40 text-left px-2 py-1">Key</th>
                  <th className="w-40 text-left px-2 py-1">Variable</th>
                  <th className="text-left px-2 py-1">Frage/Beschreibung</th>
                </tr>
              </thead>
              <tbody>
                {fmEntries.length === 0 ? (
                  <tr><td colSpan={3} className="px-2 py-1 text-muted-foreground">Keine Felder im Frontmatter.</td></tr>
                ) : fmEntries.map((e, i) => {
                  const m = /\{\{([^}|]+)\|([^}]+)\}\}/.exec(e.rawValue)
                  const varKey = m ? m[1].trim() : ''
                  const varQ = m ? m[2].trim() : ''
                  return (
                    <tr key={`${e.key}-${i}`} className="align-top">
                      <td className="px-2 py-1 align-top font-mono">{e.key}</td>
                      <td className="px-2 py-1 align-top font-mono">{varKey}</td>
                      <td className="px-2 py-1 align-top">
                        <InlineEditableCell
                          value={varQ}
                          onChange={(val) => updateFrontmatterQuestion(e.key, val)}
                          placeholder="Klicken zum Bearbeiten"
                        />
                      </td>
                    </tr>
                  )
                })}
              </tbody>
            </table>
          </div>
        </TabsContent>

        <TabsContent value="system">
          <div className="space-y-1">
            <Label>System Prompt</Label>
            <Input value={sysPrompt} onChange={(e) => handleSysPromptChange(e.target.value)} className="font-mono h-8 text-xs" />
          </div>
        </TabsContent>
      </Tabs>
    </div>
  )
}

function escapeRegExp(s: string): string {
  return s.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')
}

// Inline-Edit Textarea, wächst dynamisch, aktiviert Edit bei Fokus/Klick
function EditableTextarea({ value, onChange, onBlur, onKeyDown }: { value: string; onChange: (v: string) => void; onBlur?: () => void; onKeyDown?: (e: React.KeyboardEvent<HTMLTextAreaElement>) => void }) {
  const [local, setLocal] = React.useState(value)
  const ref = React.useRef<HTMLTextAreaElement | null>(null)

  const autosize = React.useCallback(() => {
    const el = ref.current
    if (!el) return
    el.style.height = 'auto'
    el.style.height = `${el.scrollHeight}px`
  }, [])

  React.useEffect(() => { setLocal(value); requestAnimationFrame(autosize) }, [value, autosize])

  return (
    <textarea
      ref={ref}
      value={local}
      onChange={(e) => { setLocal(e.target.value); onChange(e.target.value); autosize() }}
      onInput={autosize}
      onBlur={onBlur}
      onKeyDown={onKeyDown}
      className="w-full min-h-[2.5rem] rounded-md border bg-background px-2 py-1 text-[11px] leading-snug overflow-hidden"
      style={{ resize: 'none' }}
    />
  )
}

// Zelle, die erst beim Klick in den Editiermodus mit autosizender Textarea wechselt
function InlineEditableCell({ value, onChange, placeholder }: { value: string; onChange: (v: string) => void; placeholder?: string }) {
  const [editing, setEditing] = React.useState(false)

  if (!editing) {
    return (
      <div
        role="button"
        onClick={() => setEditing(true)}
        className="cursor-text whitespace-pre-wrap break-words rounded-md px-2 py-1 min-h-[2.5rem]"
      >
        {value ? value : <span className="text-muted-foreground">{placeholder || 'Klicken zum Bearbeiten'}</span>}
      </div>
    )
  }

  return (
    <EditableTextarea
      value={value}
      onChange={onChange}
      onBlur={() => setEditing(false)}
      onKeyDown={(e) => { if (e.key === 'Escape') { e.preventDefault(); e.stopPropagation(); setEditing(false) } }}
    />
  )
}


```

```typescriptreact
"use client";

import * as React from 'react'
import { assignHeadingsToPlaceholders, parseHeadings } from '@/lib/templates/placeholders'
import { extractFrontmatterBlock, parseFrontmatterKeyValues } from '@/lib/markdown/frontmatter'
import { Button } from '@/components/ui/button'
import { Input } from '@/components/ui/input'
import { Label } from '@/components/ui/label'
import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from '@/components/ui/table'
import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs'

export interface StructuredTemplateEditorProps {
  markdownBody: string
  yamlFrontmatter: string
  systemPrompt: string
  onChange: (next: { markdownBody: string; yamlFrontmatter: string; systemPrompt: string }) => void
}

export function StructuredTemplateEditor({ markdownBody, yamlFrontmatter, systemPrompt, onChange }: StructuredTemplateEditorProps) {
  const bodyHits = React.useMemo(() => assignHeadingsToPlaceholders(markdownBody), [markdownBody])
  const headings = React.useMemo(() => parseHeadings(markdownBody), [markdownBody])
  const fmEntries = React.useMemo(() => parseFrontmatterKeyValues(yamlFrontmatter || ''), [yamlFrontmatter])
  const [sysPrompt, setSysPrompt] = React.useState(systemPrompt)
  const [tab, setTab] = React.useState<'body'|'frontmatter'|'system'>('body')

  React.useEffect(() => { setSysPrompt(systemPrompt) }, [systemPrompt])

  // Body neu aufbauen: Abschnitte (Headings) + Platzhalterzeilen
  type BodyRow = { kind: 'section'; label: string; headingStart: number; level: 1|2|3|4|5|6 } | { kind: 'placeholder'; key: string; question: string }
  const bodyRows: BodyRow[] = React.useMemo(() => {
    const rows: BodyRow[] = []
    for (const h of bodyHits) {
      const prev = headings.filter(x => x.start <= h.index)
      const last = prev.length > 0 ? prev[prev.length - 1] : null
      const label = last ? last.title : ''
      if (last && label) rows.push({ kind: 'section', label, headingStart: last.start, level: last.level })
      rows.push({ kind: 'placeholder', key: h.key, question: h.question })
    }
    return rows.length > 0 ? rows : []
  }, [bodyHits, headings])

  // Inline‑Edit für Body‑Variablen (nur Frage editieren; Key‑Änderung folgt später)
  const updateBodyQuestion = (key: string, question: string) => {
    const re = new RegExp(`\\{\\{\\s*${escapeRegExp(key)}\\s*\\|[^}]*\\}\\}`,'g')
    const next = markdownBody.replace(re, `{{${key}|${question}}}`)
    onChange({ markdownBody: next, yamlFrontmatter, systemPrompt: sysPrompt })
  }

  // Inline‑Edit für Frontmatter‑Zeilen (nur Frage‑Teil rechts vom |)
  const updateFrontmatterQuestion = (entryKey: string, question: string) => {
    const lines = (yamlFrontmatter || '').split('\n')
    const idx = lines.findIndex(l => new RegExp(`^${escapeRegExp(entryKey)}\s*:`).test(l.trim()))
    if (idx >= 0) {
      const line = lines[idx]
      const m = /\{\{([^}|]+)\|([^}]+)\}\}/.exec(line)
      if (m) {
        lines[idx] = line.replace(m[0], `{{${m[1]}|${question}}}`)
      }
      onChange({ markdownBody, yamlFrontmatter: lines.join('\n'), systemPrompt: sysPrompt })
    }
  }

  const handleSysPromptChange = (v: string) => {
    setSysPrompt(v)
    onChange({ markdownBody, yamlFrontmatter, systemPrompt: v })
  }

  return (
    <div className="space-y-3">
      <Tabs value={tab} onValueChange={(v) => setTab(v as typeof tab)}>
        <TabsList className="grid grid-cols-3 w-full">
          <TabsTrigger value="body">Body</TabsTrigger>
          <TabsTrigger value="frontmatter">Frontmatter</TabsTrigger>
          <TabsTrigger value="system">System</TabsTrigger>
        </TabsList>

        <TabsContent value="body">
          <div className="overflow-auto">
            <Table className="text-[11px] w-full border-collapse">
              <TableHeader>
                <TableRow className="[&>*]:py-1">
                  <TableHead className="w-36">Variable</TableHead>
                  <TableHead>Frage/Beschreibung</TableHead>
                </TableRow>
              </TableHeader>
              <TableBody>
                {bodyRows.length === 0 ? (
                  <TableRow><TableCell colSpan={2} className="text-muted-foreground">Keine Einträge im Body.</TableCell></TableRow>
                ) : bodyRows.map((r, i) => r.kind === 'section' ? (
                  <TableRow key={`sec-${i}`} className="bg-muted/20 align-top">
                    <TableCell className="w-36 py-1" />
                    <TableCell className="py-1 font-medium whitespace-pre-wrap break-words">{r.label}</TableCell>
                  </TableRow>
                ) : (
                  <TableRow key={`pl-${r.key}-${i}`} className="align-top">
                    <TableCell className="align-top font-mono w-36 py-1">{r.key}</TableCell>
                    <TableCell className="align-top py-1">
                      <InlineEditableCell
                        value={r.question}
                        onChange={(val) => updateBodyQuestion(r.key, val)}
                        placeholder="Klicken zum Bearbeiten"
                      />
                    </TableCell>
                  </TableRow>
                ))}
              </TableBody>
            </Table>
          </div>
        </TabsContent>

        <TabsContent value="frontmatter">
          <div className="max-h-[50vh] overflow-auto rounded border">
            <table className="w-full text-[11px] border-collapse">
              <thead className="sticky top-0 bg-background">
                <tr>
                  <th className="w-40 text-left px-2 py-1">Key</th>
                  <th className="w-40 text-left px-2 py-1">Variable</th>
                  <th className="text-left px-2 py-1">Frage/Beschreibung</th>
                </tr>
              </thead>
              <tbody>
                {fmEntries.length === 0 ? (
                  <tr><td colSpan={3} className="px-2 py-1 text-muted-foreground">Keine Felder im Frontmatter.</td></tr>
                ) : fmEntries.map((e, i) => {
                  const m = /\{\{([^}|]+)\|([^}]+)\}\}/.exec(e.rawValue)
                  const varKey = m ? m[1].trim() : ''
                  const varQ = m ? m[2].trim() : ''
                  return (
                    <tr key={`${e.key}-${i}`} className="align-top">
                      <td className="px-2 py-1 align-top font-mono">{e.key}</td>
                      <td className="px-2 py-1 align-top font-mono">{varKey}</td>
                      <td className="px-2 py-1 align-top">
                        <InlineEditableCell
                          value={varQ}
                          onChange={(val) => updateFrontmatterQuestion(e.key, val)}
                          placeholder="Klicken zum Bearbeiten"
                        />
                      </td>
                    </tr>
                  )
                })}
              </tbody>
            </table>
          </div>
        </TabsContent>

        <TabsContent value="system">
          <div className="space-y-1">
            <Label>System Prompt</Label>
            <Input value={sysPrompt} onChange={(e) => handleSysPromptChange(e.target.value)} className="font-mono h-8 text-xs" />
          </div>
        </TabsContent>
      </Tabs>
    </div>
  )
}

function escapeRegExp(s: string): string {
  return s.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')
}

// Inline-Edit Textarea, wächst dynamisch, aktiviert Edit bei Fokus/Klick
function EditableTextarea({ value, onChange, onBlur, onKeyDown }: { value: string; onChange: (v: string) => void; onBlur?: () => void; onKeyDown?: (e: React.KeyboardEvent<HTMLTextAreaElement>) => void }) {
  const [local, setLocal] = React.useState(value)
  const ref = React.useRef<HTMLTextAreaElement | null>(null)

  const autosize = React.useCallback(() => {
    const el = ref.current
    if (!el) return
    el.style.height = 'auto'
    el.style.height = `${el.scrollHeight}px`
  }, [])

  React.useEffect(() => { setLocal(value); requestAnimationFrame(autosize) }, [value, autosize])

  return (
    <textarea
      ref={ref}
      value={local}
      onChange={(e) => { setLocal(e.target.value); onChange(e.target.value); autosize() }}
      onInput={autosize}
      onBlur={onBlur}
      onKeyDown={onKeyDown}
      className="w-full min-h-[2.5rem] rounded-md border bg-background px-2 py-1 text-[11px] leading-snug overflow-hidden"
      style={{ resize: 'none' }}
    />
  )
}

// Zelle, die erst beim Klick in den Editiermodus mit autosizender Textarea wechselt
function InlineEditableCell({ value, onChange, placeholder }: { value: string; onChange: (v: string) => void; placeholder?: string }) {
  const [editing, setEditing] = React.useState(false)

  if (!editing) {
    return (
      <div
        role="button"
        onClick={() => setEditing(true)}
        className="cursor-text whitespace-pre-wrap break-words rounded-md px-2 py-1 min-h-[2.5rem]"
      >
        {value ? value : <span className="text-muted-foreground">{placeholder || 'Klicken zum Bearbeiten'}</span>}
      </div>
    )
  }

  return (
    <EditableTextarea
      value={value}
      onChange={onChange}
      onBlur={() => setEditing(false)}
      onKeyDown={(e) => { if (e.key === 'Escape') { e.preventDefault(); e.stopPropagation(); setEditing(false) } }}
    />
  )
}


```

```typescriptreact
*** Begin Patch
*** Update File: src/components/templates/structured-template-editor.tsx
@@
   const updateBodyQuestion = (key: string, question: string) => {
     const re = new RegExp(`\\{\\{\\s*${escapeRegExp(key)}\\s*\\|[^}]*\\}}`,'g')
     const next = markdownBody.replace(re, `{{${key}|${question}}}`)
     onChange({ markdownBody: next, yamlFrontmatter, systemPrompt: sysPrompt })
   }
+
+  // Inline‑Edit für Abschnittsüberschriften (Markdown-Heading-Zeile ersetzen)
+  const updateSectionTitle = (headingStart: number, level: 1|2|3|4|5|6, title: string) => {
+    const lineEnd = markdownBody.indexOf('\n', headingStart)
+    const end = lineEnd === -1 ? markdownBody.length : lineEnd
+    const newLine = `${'#'.repeat(level)} ${title}`
+    const next = markdownBody.slice(0, headingStart) + newLine + markdownBody.slice(end)
+    onChange({ markdownBody: next, yamlFrontmatter, systemPrompt: sysPrompt })
+  }
*** End Patch
```

```typescriptreact
*** Begin Patch
*** Update File: src/components/templates/structured-template-editor.tsx
@@
   const updateBodyQuestion = (key: string, question: string) => {
     const re = new RegExp(`\\{\\{\\s*${escapeRegExp(key)}\\s*\\|[^}]*\\}}`,'g')
     const next = markdownBody.replace(re, `{{${key}|${question}}}`)
     onChange({ markdownBody: next, yamlFrontmatter, systemPrompt: sysPrompt })
   }
+
+  // Inline‑Edit für Abschnittsüberschriften (Markdown-Heading-Zeile ersetzen)
+  const updateSectionTitle = (headingStart: number, level: 1|2|3|4|5|6, title: string) => {
+    const lineEnd = markdownBody.indexOf('\n', headingStart)
+    const end = lineEnd === -1 ? markdownBody.length : lineEnd
+    const newLine = `${'#'.repeat(level)} ${title}`
+    const next = markdownBody.slice(0, headingStart) + newLine + markdownBody.slice(end)
+    onChange({ markdownBody: next, yamlFrontmatter, systemPrompt: sysPrompt })
+  }
*** End Patch
```

```typescriptreact
"use client";

import * as React from 'react'
import { assignHeadingsToPlaceholders, parseHeadings } from '@/lib/templates/placeholders'
import { extractFrontmatterBlock, parseFrontmatterKeyValues } from '@/lib/markdown/frontmatter'
import { Button } from '@/components/ui/button'
import { Input } from '@/components/ui/input'
import { Label } from '@/components/ui/label'
import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from '@/components/ui/table'
import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs'

export interface StructuredTemplateEditorProps {
  markdownBody: string
  yamlFrontmatter: string
  systemPrompt: string
  onChange: (next: { markdownBody: string; yamlFrontmatter: string; systemPrompt: string }) => void
}

export function StructuredTemplateEditor({ markdownBody, yamlFrontmatter, systemPrompt, onChange }: StructuredTemplateEditorProps) {
  const bodyHits = React.useMemo(() => assignHeadingsToPlaceholders(markdownBody), [markdownBody])
  const headings = React.useMemo(() => parseHeadings(markdownBody), [markdownBody])
  const fmEntries = React.useMemo(() => parseFrontmatterKeyValues(yamlFrontmatter || ''), [yamlFrontmatter])
  const [sysPrompt, setSysPrompt] = React.useState(systemPrompt)
  const [tab, setTab] = React.useState<'body'|'frontmatter'|'system'>('body')

  React.useEffect(() => { setSysPrompt(systemPrompt) }, [systemPrompt])

  // Body neu aufbauen: Abschnitte (Headings) + Platzhalterzeilen
  type BodyRow = { kind: 'section'; label: string; headingStart: number; level: 1|2|3|4|5|6 } | { kind: 'placeholder'; key: string; question: string }
  const bodyRows: BodyRow[] = React.useMemo(() => {
    const rows: BodyRow[] = []
    for (const h of bodyHits) {
      const prev = headings.filter(x => x.start <= h.index)
      const last = prev.length > 0 ? prev[prev.length - 1] : null
      const label = last ? last.title : ''
      if (last && label) rows.push({ kind: 'section', label, headingStart: last.start, level: last.level })
      rows.push({ kind: 'placeholder', key: h.key, question: h.question })
    }
    return rows.length > 0 ? rows : []
  }, [bodyHits, headings])

  // Inline‑Edit für Body‑Variablen (nur Frage editieren; Key‑Änderung folgt später)
  const updateBodyQuestion = (key: string, question: string) => {
    const re = new RegExp(`\\{\\{\\s*${escapeRegExp(key)}\\s*\\|[^}]*\\}\\}`,'g')
    const next = markdownBody.replace(re, `{{${key}|${question}}}`)
    onChange({ markdownBody: next, yamlFrontmatter, systemPrompt: sysPrompt })
  }

  // Inline‑Edit für Frontmatter‑Zeilen (nur Frage‑Teil rechts vom |)
  const updateFrontmatterQuestion = (entryKey: string, question: string) => {
    const lines = (yamlFrontmatter || '').split('\n')
    const idx = lines.findIndex(l => new RegExp(`^${escapeRegExp(entryKey)}\s*:`).test(l.trim()))
    if (idx >= 0) {
      const line = lines[idx]
      const m = /\{\{([^}|]+)\|([^}]+)\}\}/.exec(line)
      if (m) {
        lines[idx] = line.replace(m[0], `{{${m[1]}|${question}}}`)
      }
      onChange({ markdownBody, yamlFrontmatter: lines.join('\n'), systemPrompt: sysPrompt })
    }
  }

  const handleSysPromptChange = (v: string) => {
    setSysPrompt(v)
    onChange({ markdownBody, yamlFrontmatter, systemPrompt: v })
  }

  return (
    <div className="space-y-3">
      <Tabs value={tab} onValueChange={(v) => setTab(v as typeof tab)}>
        <TabsList className="grid grid-cols-3 w-full">
          <TabsTrigger value="body">Body</TabsTrigger>
          <TabsTrigger value="frontmatter">Frontmatter</TabsTrigger>
          <TabsTrigger value="system">System</TabsTrigger>
        </TabsList>

        <TabsContent value="body">
          <div className="overflow-auto">
            <Table className="text-[11px] w-full border-collapse">
              <TableHeader>
                <TableRow className="[&>*]:py-1">
                  <TableHead className="w-36">Variable</TableHead>
                  <TableHead>Frage/Beschreibung</TableHead>
                </TableRow>
              </TableHeader>
              <TableBody>
                {bodyRows.length === 0 ? (
                  <TableRow><TableCell colSpan={2} className="text-muted-foreground">Keine Einträge im Body.</TableCell></TableRow>
                ) : bodyRows.map((r, i) => r.kind === 'section' ? (
                  <TableRow key={`sec-${i}`} className="bg-muted/20 align-top">
                    <TableCell className="w-36 py-1" />
                    <TableCell className="py-1 font-medium whitespace-pre-wrap break-words">
                      <InlineEditableCell
                        value={r.label}
                        onChange={(val) => {
                          // r hat hier Typ section; TypeScript Narrowing via cast
                          const sec = r as { kind: 'section'; label: string; headingStart: number; level: 1|2|3|4|5|6 }
                          const lineEnd = markdownBody.indexOf('\n', sec.headingStart)
                          const end = lineEnd === -1 ? markdownBody.length : lineEnd
                          const newLine = `${'#'.repeat(sec.level)} ${val}`
                          const next = markdownBody.slice(0, sec.headingStart) + newLine + markdownBody.slice(end)
                          onChange({ markdownBody: next, yamlFrontmatter, systemPrompt: sysPrompt })
                        }}
                        placeholder="Abschnittstitel bearbeiten"
                      />
                    </TableCell>
                  </TableRow>
                ) : (
                  <TableRow key={`pl-${r.key}-${i}`} className="align-top">
                    <TableCell className="align-top font-mono w-36 py-1">{r.key}</TableCell>
                    <TableCell className="align-top py-1">
                      <InlineEditableCell
                        value={r.question}
                        onChange={(val) => updateBodyQuestion(r.key, val)}
                        placeholder="Klicken zum Bearbeiten"
                      />
                    </TableCell>
                  </TableRow>
                ))}
              </TableBody>
            </Table>
          </div>
        </TabsContent>

        <TabsContent value="frontmatter">
          <div className="max-h-[50vh] overflow-auto rounded border">
            <table className="w-full text-[11px] border-collapse">
              <thead className="sticky top-0 bg-background">
                <tr>
                  <th className="w-40 text-left px-2 py-1">Key</th>
                  <th className="w-40 text-left px-2 py-1">Variable</th>
                  <th className="text-left px-2 py-1">Frage/Beschreibung</th>
                </tr>
              </thead>
              <tbody>
                {fmEntries.length === 0 ? (
                  <tr><td colSpan={3} className="px-2 py-1 text-muted-foreground">Keine Felder im Frontmatter.</td></tr>
                ) : fmEntries.map((e, i) => {
                  const m = /\{\{([^}|]+)\|([^}]+)\}\}/.exec(e.rawValue)
                  const varKey = m ? m[1].trim() : ''
                  const varQ = m ? m[2].trim() : ''
                  return (
                    <tr key={`${e.key}-${i}`} className="align-top">
                      <td className="px-2 py-1 align-top font-mono">{e.key}</td>
                      <td className="px-2 py-1 align-top font-mono">{varKey}</td>
                      <td className="px-2 py-1 align-top">
                        <InlineEditableCell
                          value={varQ}
                          onChange={(val) => updateFrontmatterQuestion(e.key, val)}
                          placeholder="Klicken zum Bearbeiten"
                        />
                      </td>
                    </tr>
                  )
                })}
              </tbody>
            </table>
          </div>
        </TabsContent>

        <TabsContent value="system">
          <div className="space-y-1">
            <Label>System Prompt</Label>
            <Input value={sysPrompt} onChange={(e) => handleSysPromptChange(e.target.value)} className="font-mono h-8 text-xs" />
          </div>
        </TabsContent>
      </Tabs>
    </div>
  )
}

function escapeRegExp(s: string): string {
  return s.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')
}

// Inline-Edit Textarea, wächst dynamisch, aktiviert Edit bei Fokus/Klick
function EditableTextarea({ value, onChange, onBlur, onKeyDown }: { value: string; onChange: (v: string) => void; onBlur?: () => void; onKeyDown?: (e: React.KeyboardEvent<HTMLTextAreaElement>) => void }) {
  const [local, setLocal] = React.useState(value)
  const ref = React.useRef<HTMLTextAreaElement | null>(null)

  const autosize = React.useCallback(() => {
    const el = ref.current
    if (!el) return
    el.style.height = 'auto'
    el.style.height = `${el.scrollHeight}px`
  }, [])

  React.useEffect(() => { setLocal(value); requestAnimationFrame(autosize) }, [value, autosize])

  return (
    <textarea
      ref={ref}
      value={local}
      onChange={(e) => { setLocal(e.target.value); onChange(e.target.value); autosize() }}
      onInput={autosize}
      onBlur={onBlur}
      onKeyDown={onKeyDown}
      className="w-full min-h-[2.5rem] rounded-md border bg-background px-2 py-1 text-[11px] leading-snug overflow-hidden"
      style={{ resize: 'none' }}
    />
  )
}

// Zelle, die erst beim Klick in den Editiermodus mit autosizender Textarea wechselt
function InlineEditableCell({ value, onChange, placeholder }: { value: string; onChange: (v: string) => void; placeholder?: string }) {
  const [editing, setEditing] = React.useState(false)

  if (!editing) {
    return (
      <div
        role="button"
        onClick={() => setEditing(true)}
        className="cursor-text whitespace-pre-wrap break-words rounded-md px-2 py-1 min-h-[2.5rem]"
      >
        {value ? value : <span className="text-muted-foreground">{placeholder || 'Klicken zum Bearbeiten'}</span>}
      </div>
    )
  }

  return (
    <EditableTextarea
      value={value}
      onChange={onChange}
      onBlur={() => setEditing(false)}
      onKeyDown={(e) => { if (e.key === 'Escape') { e.preventDefault(); e.stopPropagation(); setEditing(false) } }}
    />
  )
}


```

- Abschnittszeilen sind jetzt ebenfalls inline editierbar: Klick auf den Titel in Spalte 2 öffnet die autosizende Textarea; Blur/Escape beendet den Edit. Beim Speichern wird die korrespondierende Markdown-Überschrift im `markdownBody` ersetzt, Level bleibt erhalten.

- Implementierungsdetails:
  - Zusätzliche Heading-Infos per `parseHeadings(markdownBody)`.
  - `bodyRows` reichert `section`-Zeilen mit `headingStart` und `level` an.
  - Edit-Handler ersetzt nur die Heading-Zeile: `#{level} {title}` an der exakten Zeilenposition.
  - UI bleibt bündig: erste Spalte leer, Titel in zweiter Spalte mit `InlineEditableCell`.

- Bitte kurz gegenprüfen:
  - Klick auf Abschnittstitel: Edit startet; Änderung sichtbar im Body-Tab und Vorschau.
  - Platzhalter-Zeilen unverändert editierbar wie zuvor.
  - Frontmatter-Tab unverändert mit Inline-Editing und Sticky-Header.

---

**User**

Wie ist die Logik da, wo so ein Bodytext geparst wird in diese Tabellenansicht? Nach welchen Kriterien werden da jetzt diese Markdown Zeilen in Abschnitte und Fragen mit Variablen analysiert? Diese Struktur sollte ja in belieber Reihenfolge vorkommen können. Es ist ja ein normaler Text.

---

**Cursor**

### Wie wird der Body in die Tabellenstruktur geparst?

- **Variablen-Erkennung (Fragenzeilen)**:
  - Gesucht werden Platzhalter im Format `{{key|frage}}` (Whitespace tolerant).
  - Jeder Treffer liefert `key`, `question` und die Zeichenposition `index` im Text.
```7:17:src/lib/templates/placeholders.ts
export function extractPlaceholders(text: string): PlaceholderHit[] {
  const hits: PlaceholderHit[] = [];
  if (typeof text !== 'string' || text.length === 0) return hits;
  const re = /\{\{([^}|]+)\|([^}]+)\}\}/g;
  let m: RegExpExecArray | null;
  while ((m = re.exec(text)) !== null) {
    const key = (m[1] || '').trim();
    const question = (m[2] || '').trim();
    if (key) hits.push({ key, question, index: m.index });
  }
  return hits;
}
```

- **Abschnitts-Erkennung (Überschriften)**:
  - ATX-Headings am Zeilenanfang: `#` bis `######` plus Titel.
  - Für jede Überschrift wird `level`, `title` und der Start-Offset `start` im Text gespeichert.
```26:39:src/lib/templates/placeholders.ts
export function parseHeadings(text: string): HeadingInfo[] {
  const lines = text.split('\n');
  const out: HeadingInfo[] = [];
  let offset = 0;
  for (const line of lines) {
    const m = /^(#{1,6})\s*(.*)$/.exec(line);
    if (m) {
      const level = Math.min(6, Math.max(1, m[1].length)) as 1|2|3|4|5|6;
      const title = m[2].trim();
      out.push({ level, title, start: offset });
    }
    offset += line.length + 1;
  }
  return out;
}
```

- **Zuordnung Platzhalter → Abschnitt**:
  - Für jeden Platzhalter wird die letzte Überschrift gesucht, deren `start` vor `index` liegt; deren `title` wird als Abschnittstitel genutzt.
  - Reihenfolge bleibt die des Textes.
```42:59:src/lib/templates/placeholders.ts
export function assignHeadingsToPlaceholders(text: string): Array<PlaceholderHit & { headingPath: string[] } > {
  const heads = parseHeadings(text);
  const hits = extractPlaceholders(text);
  const withPath: Array<PlaceholderHit & { headingPath: string[] }> = [];
  for (const h of hits) {
    const prev = heads.filter(x => x.start <= h.index);
    const path: string[] = [];
    let lastLevel = 0;
    for (const hd of prev) {
      if (hd.level >= lastLevel) {
        path.push(hd.title);
        lastLevel = hd.level;
      }
    }
    withPath.push({ ...h, headingPath: path });
  }
  return withPath;
}
```

- **Aufbau der Tabellenzeilen**:
  - Iteration in Textreihenfolge über alle Platzhalter.
  - Vor jedem Platzhalter wird (aktuell) eine Abschnittszeile eingefügt, basierend auf der zuletzt gefundenen Überschrift; danach die Variablen-Zeile.
  - Nicht-Placeholder-Paragraphen werden nicht angezeigt.
```29:39:src/components/templates/structured-template-editor.tsx
type BodyRow = { kind: 'section'; label: string; headingStart: number; level: 1|2|3|4|5|6 } | { kind: 'placeholder'; key: string; question: string }
const bodyRows: BodyRow[] = React.useMemo(() => {
  const rows: BodyRow[] = []
  for (const h of bodyHits) {
    const prev = headings.filter(x => x.start <= h.index)
    const last = prev.length > 0 ? prev[prev.length - 1] : null
    const label = last ? last.title : ''
    if (last && label) rows.push({ kind: 'section', label, headingStart: last.start, level: last.level })
    rows.push({ kind: 'placeholder', key: h.key, question: h.question })
  }
  return rows.length > 0 ? rows : []
}, [bodyHits, headings])
```

### Konsequenzen

- Die Struktur kann in beliebiger Reihenfolge stehen; entscheidend sind:
  - Platzhalter-Treffer `{{key|frage}}` bestimmen, was als „Frage/Variable“ erscheint.
  - Die „zuletzt vorherige“ Markdown-Überschrift bestimmt den Abschnittstitel für diesen Platzhalter.
- Paragraphen ohne Platzhalter werden ignoriert. Setext-Headings oder Codeblöcke werden nicht speziell behandelt; Headings/Platzhalter in Codeblöcken würden mitgeparst.

Wenn du statt „Abschnittszeile pro Platzhalter“ eine echte Gruppierung pro Überschrift bevorzugst (eine Abschnittszeile, danach alle zugehörigen Variablen), kann ich das umstellen und doppelte Abschnittsreihen deduplizieren.

```typescript
export function extractPlaceholders(text: string): PlaceholderHit[] {
  const hits: PlaceholderHit[] = [];
  if (typeof text !== 'string' || text.length === 0) return hits;
  const re = /\{\{([^}|]+)\|([^}]+)\}\}/g;
  let m: RegExpExecArray | null;
  while ((m = re.exec(text)) !== null) {
    const key = (m[1] || '').trim();
    const question = (m[2] || '').trim();
    if (key) hits.push({ key, question, index: m.index });
  }
  return hits;
}
```

```typescript
export function parseHeadings(text: string): HeadingInfo[] {
  const lines = text.split('\n');
  const out: HeadingInfo[] = [];
  let offset = 0;
  for (const line of lines) {
    const m = /^(#{1,6})\s*(.*)$/.exec(line);
    if (m) {
      const level = Math.min(6, Math.max(1, m[1].length)) as 1|2|3|4|5|6;
      const title = m[2].trim();
      out.push({ level, title, start: offset });
    }
    offset += line.length + 1;
  }
  return out;
}
```

```typescript
export function assignHeadingsToPlaceholders(text: string): Array<PlaceholderHit & { headingPath: string[] } > {
  const heads = parseHeadings(text);
  const hits = extractPlaceholders(text);
  const withPath: Array<PlaceholderHit & { headingPath: string[] }> = [];
  for (const h of hits) {
    const prev = heads.filter(x => x.start <= h.index);
    const path: string[] = [];
    let lastLevel = 0;
    for (const hd of prev) {
      if (hd.level >= lastLevel) {
        path.push(hd.title);
        lastLevel = hd.level;
      }
    }
    withPath.push({ ...h, headingPath: path });
  }
  return withPath;
}
```

```typescriptreact
type BodyRow = { kind: 'section'; label: string; headingStart: number; level: 1|2|3|4|5|6 } | { kind: 'placeholder'; key: string; question: string }
const bodyRows: BodyRow[] = React.useMemo(() => {
  const rows: BodyRow[] = []
  for (const h of bodyHits) {
    const prev = headings.filter(x => x.start <= h.index)
    const last = prev.length > 0 ? prev[prev.length - 1] : null
    const label = last ? last.title : ''
    if (last && label) rows.push({ kind: 'section', label, headingStart: last.start, level: last.level })
    rows.push({ kind: 'placeholder', key: h.key, question: h.question })
  }
  return rows.length > 0 ? rows : []
}, [bodyHits, headings])
```

---

**User**

Nein, ich möchte eigentlich nicht von Abschnitten reden, sondern ich möchte eigentlich nur von Zeilen sprechen. Wir dürfen die originale Struktur einfach nicht ändern. Die Markdownsyntax sollte einfach nur eins zu eins in die Tabelle übertragen werden. Ob jetzt eine Zeile ein Variable/Frage Paar ist, entscheidet sich nur durch diese geschwungenen Klammern. Diese Markdown-Headings und anderen Zeilen ohne Platzhalter sollten ganz normal, unverfälscht in der Tabelle angezeigt werden.

---

**Cursor**

I'll refactor the Body-Tab to render one table row per original markdown line, preserving order. Non-placeholder lines show raw text in the second column (editable on click). Lines with exactly one placeholder token render the variable key in column 1 and an inline-editable question field in column 2. I'll remove the previous section/heading logic and ensure updates modify only the specific line or placeholder within that line. Now I’ll apply the edits.

```typescriptreact
*** Begin Patch
*** Update File: src/components/templates/structured-template-editor.tsx
@@
-import { assignHeadingsToPlaceholders, parseHeadings } from '@/lib/templates/placeholders'
+// Hinweis: Body-Parsing erfolgt zeilenbasiert direkt in dieser Komponente
@@
-export function StructuredTemplateEditor({ markdownBody, yamlFrontmatter, systemPrompt, onChange }: StructuredTemplateEditorProps) {
-  const bodyHits = React.useMemo(() => assignHeadingsToPlaceholders(markdownBody), [markdownBody])
-  const headings = React.useMemo(() => parseHeadings(markdownBody), [markdownBody])
+export function StructuredTemplateEditor({ markdownBody, yamlFrontmatter, systemPrompt, onChange }: StructuredTemplateEditorProps) {
+  // Markdown-Body in Zeilen zerlegen, Reihenfolge bewahren
+  const lines = React.useMemo(() => (typeof markdownBody === 'string' ? markdownBody.split('\n') : []), [markdownBody])
   const fmEntries = React.useMemo(() => parseFrontmatterKeyValues(yamlFrontmatter || ''), [yamlFrontmatter])
   const [sysPrompt, setSysPrompt] = React.useState(systemPrompt)
   const [tab, setTab] = React.useState<'body'|'frontmatter'|'system'>('body')
@@
-  // Body neu aufbauen: Abschnitte (Headings) + Platzhalterzeilen
-  type BodyRow = { kind: 'section'; label: string; headingStart: number; level: 1|2|3|4|5|6 } | { kind: 'placeholder'; key: string; question: string }
-  const bodyRows: BodyRow[] = React.useMemo(() => {
-    const rows: BodyRow[] = []
-    for (const h of bodyHits) {
-      const prev = headings.filter(x => x.start <= h.index)
-      const last = prev.length > 0 ? prev[prev.length - 1] : null
-      const label = last ? last.title : ''
-      if (last && label) rows.push({ kind: 'section', label, headingStart: last.start, level: last.level })
-      rows.push({ kind: 'placeholder', key: h.key, question: h.question })
-    }
-    return rows.length > 0 ? rows : []
-  }, [bodyHits, headings])
-
-  // Inline‑Edit für Body‑Variablen (nur Frage editieren; Key‑Änderung folgt später)
-  const updateBodyQuestion = (key: string, question: string) => {
-    const re = new RegExp(`\\{\\{\\s*${escapeRegExp(key)}\\s*\\|[^}]*\\}}`,'g')
-    const next = markdownBody.replace(re, `{{${key}|${question}}}`)
-    onChange({ markdownBody: next, yamlFrontmatter, systemPrompt: sysPrompt })
-  }
+  // Zeilenbasierte Platzhalter-Erkennung in einer Zeile
+  function extractPlaceholdersFromLine(line: string): Array<{ key: string; question: string }> {
+    const out: Array<{ key: string; question: string }> = []
+    const re = /\{\{([^}|]+)\|([^}]+)\}\}/g
+    let m: RegExpExecArray | null
+    while ((m = re.exec(line)) !== null) {
+      const key = (m[1] || '').trim()
+      const question = (m[2] || '').trim()
+      if (key) out.push({ key, question })
+    }
+    return out
+  }
+
+  // Ganze Zeile ersetzen (1:1 Übernahme in Markdown)
+  function updateLineByIndex(lineIndex: number, nextLine: string) {
+    const copy = lines.slice()
+    if (lineIndex >= 0 && lineIndex < copy.length) copy[lineIndex] = nextLine
+    onChange({ markdownBody: copy.join('\n'), yamlFrontmatter, systemPrompt: sysPrompt })
+  }
+
+  // Frage-Anteil in einem Platzhalter innerhalb einer Zeile ersetzen (ersetzt alle Vorkommen des Keys in dieser Zeile)
+  function updatePlaceholderQuestionInLine(lineIndex: number, key: string, nextQuestion: string) {
+    const copy = lines.slice()
+    if (lineIndex < 0 || lineIndex >= copy.length) return
+    const line = copy[lineIndex]
+    const re = new RegExp(`\\{\\{\\s*${escapeRegExp(key)}\\s*\\|[^}]*\\}}`, 'g')
+    copy[lineIndex] = line.replace(re, `{{${key}|${nextQuestion}}}`)
+    onChange({ markdownBody: copy.join('\n'), yamlFrontmatter, systemPrompt: sysPrompt })
+  }
@@
-              <TableBody>
-                {bodyRows.length === 0 ? (
-                  <TableRow><TableCell colSpan={2} className="text-muted-foreground">Keine Einträge im Body.</TableCell></TableRow>
-                ) : bodyRows.map((r, i) => r.kind === 'section' ? (
-                  <TableRow key={`sec-${i}`} className="bg-muted/20 align-top">
-                    <TableCell className="w-36 py-1" />
-                    <TableCell className="py-1 font-medium whitespace-pre-wrap break-words">
-                      <InlineEditableCell
-                        value={r.label}
-                        onChange={(val) => {
-                          // r hat hier Typ section; TypeScript Narrowing via cast
-                          const sec = r as { kind: 'section'; label: string; headingStart: number; level: 1|2|3|4|5|6 }
-                          const lineEnd = markdownBody.indexOf('\n', sec.headingStart)
-                          const end = lineEnd === -1 ? markdownBody.length : lineEnd
-                          const newLine = `${'#'.repeat(sec.level)} ${val}`
-                          const next = markdownBody.slice(0, sec.headingStart) + newLine + markdownBody.slice(end)
-                          onChange({ markdownBody: next, yamlFrontmatter, systemPrompt: sysPrompt })
-                        }}
-                        placeholder="Abschnittstitel bearbeiten"
-                      />
-                    </TableCell>
-                  </TableRow>
-                ) : (
-                  <TableRow key={`pl-${r.key}-${i}`} className="align-top">
-                    <TableCell className="align-top font-mono w-36 py-1">{r.key}</TableCell>
-                    <TableCell className="align-top py-1">
-                      <InlineEditableCell
-                        value={r.question}
-                        onChange={(val) => updateBodyQuestion(r.key, val)}
-                        placeholder="Klicken zum Bearbeiten"
-                      />
-                    </TableCell>
-                  </TableRow>
-                ))}
-              </TableBody>
+              <TableBody>
+                {lines.length === 0 ? (
+                  <TableRow><TableCell colSpan={2} className="text-muted-foreground">Keine Zeilen im Body.</TableCell></TableRow>
+                ) : lines.map((line, i) => {
+                  const ph = extractPlaceholdersFromLine(line)
+                  const onlyPlaceholder = ph.length === 1 && line.trim().match(/^\{\{[^}]+\}\}$/)
+                  return (
+                    <TableRow key={`line-${i}`} className="align-top">
+                      <TableCell className="align-top font-mono w-36 py-1">{ph.length > 0 ? ph.map(p => p.key).join(', ') : ''}</TableCell>
+                      <TableCell className="align-top py-1">
+                        {onlyPlaceholder ? (
+                          <InlineEditableCell
+                            value={ph[0].question}
+                            onChange={(val) => updatePlaceholderQuestionInLine(i, ph[0].key, val)}
+                            placeholder="Klicken zum Bearbeiten"
+                          />
+                        ) : (
+                          <InlineEditableCell
+                            value={line}
+                            onChange={(val) => updateLineByIndex(i, val)}
+                            placeholder="Klicken zum Bearbeiten"
+                          />
+                        )}
+                      </TableCell>
+                    </TableRow>
+                  )
+                })}
+              </TableBody>
*** End Patch
```

```typescriptreact
*** Begin Patch
*** Update File: src/components/templates/structured-template-editor.tsx
@@
-import { assignHeadingsToPlaceholders, parseHeadings } from '@/lib/templates/placeholders'
+import { /* placeholder parsing now line-based */ } from '@/lib/templates/placeholders'
@@
-export function StructuredTemplateEditor({ markdownBody, yamlFrontmatter, systemPrompt, onChange }: StructuredTemplateEditorProps) {
-  const bodyHits = React.useMemo(() => assignHeadingsToPlaceholders(markdownBody), [markdownBody])
-  const headings = React.useMemo(() => parseHeadings(markdownBody), [markdownBody])
-  const fmEntries = React.useMemo(() => parseFrontmatterKeyValues(yamlFrontmatter || ''), [yamlFrontmatter])
+export function StructuredTemplateEditor({ markdownBody, yamlFrontmatter, systemPrompt, onChange }: StructuredTemplateEditorProps) {
+  const lines = React.useMemo(() => (typeof markdownBody === 'string' ? markdownBody.split('\n') : []), [markdownBody])
+  const fmEntries = React.useMemo(() => parseFrontmatterKeyValues(yamlFrontmatter || ''), [yamlFrontmatter])
   const [sysPrompt, setSysPrompt] = React.useState(systemPrompt)
   const [tab, setTab] = React.useState<'body'|'frontmatter'|'system'>('body')
@@
-  // Body neu aufbauen: Abschnitte (Headings) + Platzhalterzeilen
-  type BodyRow = { kind: 'section'; label: string; headingStart: number; level: 1|2|3|4|5|6 } | { kind: 'placeholder'; key: string; question: string }
-  const bodyRows: BodyRow[] = React.useMemo(() => {
-    const rows: BodyRow[] = []
-    for (const h of bodyHits) {
-      const prev = headings.filter(x => x.start <= h.index)
-      const last = prev.length > 0 ? prev[prev.length - 1] : null
-      const label = last ? last.title : ''
-      if (last && label) rows.push({ kind: 'section', label, headingStart: last.start, level: last.level })
-      rows.push({ kind: 'placeholder', key: h.key, question: h.question })
-    }
-    return rows.length > 0 ? rows : []
-  }, [bodyHits, headings])
-
-  // Inline‑Edit für Body‑Variablen (nur Frage editieren; Key‑Änderung folgt später)
-  const updateBodyQuestion = (key: string, question: string) => {
-    const re = new RegExp(`\\{\\{\\s*${escapeRegExp(key)}\\s*\\|[^}]*\\}}`,'g')
-    const next = markdownBody.replace(re, `{{${key}|${question}}}`)
-    onChange({ markdownBody: next, yamlFrontmatter, systemPrompt: sysPrompt })
-  }
+  // Zeilenbasierte Platzhalter-Erkennung (nur Zeile betrachten)
+  function extractPlaceholdersFromLine(line: string): Array<{ key: string; question: string }> {
+    const out: Array<{ key: string; question: string }> = []
+    const re = /\{\{([^}|]+)\|([^}]+)\}\}/g
+    let m: RegExpExecArray | null
+    while ((m = re.exec(line)) !== null) {
+      const key = (m[1] || '').trim()
+      const question = (m[2] || '').trim()
+      if (key) out.push({ key, question })
+    }
+    return out
+  }
+
+  // Ganze Zeile ersetzen
+  function updateLineByIndex(lineIndex: number, nextLine: string) {
+    const copy = lines.slice()
+    if (lineIndex >= 0 && lineIndex < copy.length) copy[lineIndex] = nextLine
+    onChange({ markdownBody: copy.join('\n'), yamlFrontmatter, systemPrompt: sysPrompt })
+  }
+
+  // Frage innerhalb eines Platzhalters in einer Zeile ersetzen (alle Vorkommen dieses Keys in der Zeile)
+  function updatePlaceholderQuestionInLine(lineIndex: number, key: string, nextQuestion: string) {
+    const copy = lines.slice()
+    if (lineIndex < 0 || lineIndex >= copy.length) return
+    const line = copy[lineIndex]
+    const re = new RegExp(`\\{\\{\\s*${escapeRegExp(key)}\\s*\\|[^}]*\\}}`, 'g')
+    copy[lineIndex] = line.replace(re, `{{${key}|${nextQuestion}}}`)
+    onChange({ markdownBody: copy.join('\n'), yamlFrontmatter, systemPrompt: sysPrompt })
+  }
@@
-              <TableBody>
-                {bodyRows.length === 0 ? (
-                  <TableRow><TableCell colSpan={2} className="text-muted-foreground">Keine Einträge im Body.</TableCell></TableRow>
-                ) : bodyRows.map((r, i) => r.kind === 'section' ? (
-                  <TableRow key={`sec-${i}`} className="bg-muted/20 align-top">
-                    <TableCell className="w-36 py-1" />
-                    <TableCell className="py-1 font-medium whitespace-pre-wrap break-words">
-                      <InlineEditableCell
-                        value={r.label}
-                        onChange={(val) => {
-                          // r hat hier Typ section; TypeScript Narrowing via cast
-                          const sec = r as { kind: 'section'; label: string; headingStart: number; level: 1|2|3|4|5|6 }
-                          const lineEnd = markdownBody.indexOf('\n', sec.headingStart)
-                          const end = lineEnd === -1 ? markdownBody.length : lineEnd
-                          const newLine = `${'#'.repeat(sec.level)} ${val}`
-                          const next = markdownBody.slice(0, sec.headingStart) + newLine + markdownBody.slice(end)
-                          onChange({ markdownBody: next, yamlFrontmatter, systemPrompt: sysPrompt })
-                        }}
-                        placeholder="Abschnittstitel bearbeiten"
-                      />
-                    </TableCell>
-                  </TableRow>
-                ) : (
-                  <TableRow key={`pl-${r.key}-${i}`} className="align-top">
-                    <TableCell className="align-top font-mono w-36 py-1">{r.key}</TableCell>
-                    <TableCell className="align-top py-1">
-                      <InlineEditableCell
-                        value={r.question}
-                        onChange={(val) => updateBodyQuestion(r.key, val)}
-                        placeholder="Klicken zum Bearbeiten"
-                      />
-                    </TableCell>
-                  </TableRow>
-                ))}
-              </TableBody>
+              <TableBody>
+                {lines.length === 0 ? (
+                  <TableRow><TableCell colSpan={2} className="text-muted-foreground">Keine Zeilen im Body.</TableCell></TableRow>
+                ) : lines.map((line, i) => {
+                  const placeholders = extractPlaceholdersFromLine(line)
+                  const onlyPlaceholder = placeholders.length === 1 && /^\s*\{\{[^}]+\}\}\s*$/.test(line)
+                  return (
+                    <TableRow key={`line-${i}`} className="align-top">
+                      <TableCell className="align-top font-mono w-36 py-1">{placeholders.length > 0 ? placeholders.map(p => p.key).join(', ') : ''}</TableCell>
+                      <TableCell className="align-top py-1">
+                        {onlyPlaceholder ? (
+                          <InlineEditableCell
+                            value={placeholders[0].question}
+                            onChange={(val) => updatePlaceholderQuestionInLine(i, placeholders[0].key, val)}
+                            placeholder="Klicken zum Bearbeiten"
+                          />
+                        ) : (
+                          <InlineEditableCell
+                            value={line}
+                            onChange={(val) => updateLineByIndex(i, val)}
+                            placeholder="Klicken zum Bearbeiten"
+                          />
+                        )}
+                      </TableCell>
+                    </TableRow>
+                  )
+                })}
+              </TableBody>
*** End Patch
```

```typescriptreact
*** Begin Patch
*** Update File: src/components/templates/structured-template-editor.tsx
@@
-import * as React from 'react'
-import { assignHeadingsToPlaceholders, parseHeadings } from '@/lib/templates/placeholders'
-import { extractFrontmatterBlock, parseFrontmatterKeyValues } from '@/lib/markdown/frontmatter'
+import * as React from 'react'
+import { parseFrontmatterKeyValues } from '@/lib/markdown/frontmatter'
@@
-export function StructuredTemplateEditor({ markdownBody, yamlFrontmatter, systemPrompt, onChange }: StructuredTemplateEditorProps) {
-  const bodyHits = React.useMemo(() => assignHeadingsToPlaceholders(markdownBody), [markdownBody])
-  const headings = React.useMemo(() => parseHeadings(markdownBody), [markdownBody])
-  const fmEntries = React.useMemo(() => parseFrontmatterKeyValues(yamlFrontmatter || ''), [yamlFrontmatter])
+export function StructuredTemplateEditor({ markdownBody, yamlFrontmatter, systemPrompt, onChange }: StructuredTemplateEditorProps) {
+  const lines = React.useMemo(() => (typeof markdownBody === 'string' ? markdownBody.split('\n') : []), [markdownBody])
+  const fmEntries = React.useMemo(() => parseFrontmatterKeyValues(yamlFrontmatter || ''), [yamlFrontmatter])
   const [sysPrompt, setSysPrompt] = React.useState(systemPrompt)
   const [tab, setTab] = React.useState<'body'|'frontmatter'|'system'>('body')
@@
-  // Body neu aufbauen: Abschnitte (Headings) + Platzhalterzeilen
-  type BodyRow = { kind: 'section'; label: string; headingStart: number; level: 1|2|3|4|5|6 } | { kind: 'placeholder'; key: string; question: string }
-  const bodyRows: BodyRow[] = React.useMemo(() => {
-    const rows: BodyRow[] = []
-    for (const h of bodyHits) {
-      const prev = headings.filter(x => x.start <= h.index)
-      const last = prev.length > 0 ? prev[prev.length - 1] : null
-      const label = last ? last.title : ''
-      if (last && label) rows.push({ kind: 'section', label, headingStart: last.start, level: last.level })
-      rows.push({ kind: 'placeholder', key: h.key, question: h.question })
-    }
-    return rows.length > 0 ? rows : []
-  }, [bodyHits, headings])
-
-  // Inline‑Edit für Body‑Variablen (nur Frage editieren; Key‑Änderung folgt später)
-  const updateBodyQuestion = (key: string, question: string) => {
-    const re = new RegExp(`\\{\\{\\s*${escapeRegExp(key)}\\s*\\|[^}]*\\}}`,'g')
-    const next = markdownBody.replace(re, `{{${key}|${question}}}`)
-    onChange({ markdownBody: next, yamlFrontmatter, systemPrompt: sysPrompt })
-  }
+  // Zeilenbasierte Platzhalter-Erkennung (nur die betrachtete Zeile)
+  function extractPlaceholdersFromLine(line: string): Array<{ key: string; question: string }> {
+    const out: Array<{ key: string; question: string }> = []
+    const re = /\{\{([^}|]+)\|([^}]+)\}\}/g
+    let m: RegExpExecArray | null
+    while ((m = re.exec(line)) !== null) {
+      const key = (m[1] || '').trim()
+      const question = (m[2] || '').trim()
+      if (key) out.push({ key, question })
+    }
+    return out
+  }
+
+  // Ganze Zeile ersetzen (1:1 Markdown beibehalten)
+  function updateLineByIndex(lineIndex: number, nextLine: string) {
+    const copy = lines.slice()
+    if (lineIndex >= 0 && lineIndex < copy.length) copy[lineIndex] = nextLine
+    onChange({ markdownBody: copy.join('\n'), yamlFrontmatter, systemPrompt: sysPrompt })
+  }
+
+  // Nur den Frage-Anteil eines Platzhalters in einer Zeile ersetzen
+  function updatePlaceholderQuestionInLine(lineIndex: number, key: string, nextQuestion: string) {
+    const copy = lines.slice()
+    if (lineIndex < 0 || lineIndex >= copy.length) return
+    const line = copy[lineIndex]
+    const re = new RegExp(`\\{\\{\\s*${escapeRegExp(key)}\\s*\\|[^}]*\\}}`, 'g')
+    copy[lineIndex] = line.replace(re, `{{${key}|${nextQuestion}}}`)
+    onChange({ markdownBody: copy.join('\n'), yamlFrontmatter, systemPrompt: sysPrompt })
+  }
@@
-              <TableBody>
-                {bodyRows.length === 0 ? (
-                  <TableRow><TableCell colSpan={2} className="text-muted-foreground">Keine Einträge im Body.</TableCell></TableRow>
-                ) : bodyRows.map((r, i) => r.kind === 'section' ? (
-                  <TableRow key={`sec-${i}`} className="bg-muted/20 align-top">
-                    <TableCell className="w-36 py-1" />
-                    <TableCell className="py-1 font-medium whitespace-pre-wrap break-words">
-                      <InlineEditableCell
-                        value={r.label}
-                        onChange={(val) => {
-                          // r hat hier Typ section; TypeScript Narrowing via cast
-                          const sec = r as { kind: 'section'; label: string; headingStart: number; level: 1|2|3|4|5|6 }
-                          const lineEnd = markdownBody.indexOf('\n', sec.headingStart)
-                          const end = lineEnd === -1 ? markdownBody.length : lineEnd
-                          const newLine = `${'#'.repeat(sec.level)} ${val}`
-                          const next = markdownBody.slice(0, sec.headingStart) + newLine + markdownBody.slice(end)
-                          onChange({ markdownBody: next, yamlFrontmatter, systemPrompt: sysPrompt })
-                        }}
-                        placeholder="Abschnittstitel bearbeiten"
-                      />
-                    </TableCell>
-                  </TableRow>
-                ) : (
-                  <TableRow key={`pl-${r.key}-${i}`} className="align-top">
-                    <TableCell className="align-top font-mono w-36 py-1">{r.key}</TableCell>
-                    <TableCell className="align-top py-1">
-                      <InlineEditableCell
-                        value={r.question}
-                        onChange={(val) => updateBodyQuestion(r.key, val)}
-                        placeholder="Klicken zum Bearbeiten"
-                      />
-                    </TableCell>
-                  </TableRow>
-                ))}
-              </TableBody>
+              <TableBody>
+                {lines.length === 0 ? (
+                  <TableRow><TableCell colSpan={2} className="text-muted-foreground">Keine Zeilen im Body.</TableCell></TableRow>
+                ) : lines.map((line, i) => {
+                  const placeholders = extractPlaceholdersFromLine(line)
+                  const onlyPlaceholder = placeholders.length === 1 && /^\s*\{\{[^}]+\}\}\s*$/.test(line)
+                  return (
+                    <TableRow key={`line-${i}`} className="align-top">
+                      <TableCell className="align-top font-mono w-36 py-1">{placeholders.length > 0 ? placeholders.map(p => p.key).join(', ') : ''}</TableCell>
+                      <TableCell className="align-top py-1">
+                        {onlyPlaceholder ? (
+                          <InlineEditableCell
+                            value={placeholders[0].question}
+                            onChange={(val) => updatePlaceholderQuestionInLine(i, placeholders[0].key, val)}
+                            placeholder="Klicken zum Bearbeiten"
+                          />
+                        ) : (
+                          <InlineEditableCell
+                            value={line}
+                            onChange={(val) => updateLineByIndex(i, val)}
+                            placeholder="Klicken zum Bearbeiten"
+                          />
+                        )}
+                      </TableCell>
+                    </TableRow>
+                  )
+                })}
+              </TableBody>
*** End Patch
```

```typescriptreact
"use client";

import * as React from 'react'
import { parseFrontmatterKeyValues } from '@/lib/markdown/frontmatter'
import { Button } from '@/components/ui/button'
import { Input } from '@/components/ui/input'
import { Label } from '@/components/ui/label'
import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from '@/components/ui/table'
import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs'

export interface StructuredTemplateEditorProps {
  markdownBody: string
  yamlFrontmatter: string
  systemPrompt: string
  onChange: (next: { markdownBody: string; yamlFrontmatter: string; systemPrompt: string }) => void
}

export function StructuredTemplateEditor({ markdownBody, yamlFrontmatter, systemPrompt, onChange }: StructuredTemplateEditorProps) {
  const lines = React.useMemo(() => (typeof markdownBody === 'string' ? markdownBody.split('\n') : []), [markdownBody])
  const fmEntries = React.useMemo(() => parseFrontmatterKeyValues(yamlFrontmatter || ''), [yamlFrontmatter])
  const [sysPrompt, setSysPrompt] = React.useState(systemPrompt)
  const [tab, setTab] = React.useState<'body'|'frontmatter'|'system'>('body')

  React.useEffect(() => { setSysPrompt(systemPrompt) }, [systemPrompt])

  // Zeilenbasierte Platzhalter-Erkennung (nur die betrachtete Zeile)
  function extractPlaceholdersFromLine(line: string): Array<{ key: string; question: string }> {
    const out: Array<{ key: string; question: string }> = []
    const re = /\{\{([^}|]+)\|([^}]+)\}\}/g
    let m: RegExpExecArray | null
    while ((m = re.exec(line)) !== null) {
      const key = (m[1] || '').trim()
      const question = (m[2] || '').trim()
      if (key) out.push({ key, question })
    }
    return out
  }

  // Ganze Zeile ersetzen (1:1 Markdown beibehalten)
  function updateLineByIndex(lineIndex: number, nextLine: string) {
    const copy = lines.slice()
    if (lineIndex >= 0 && lineIndex < copy.length) copy[lineIndex] = nextLine
    onChange({ markdownBody: copy.join('\n'), yamlFrontmatter, systemPrompt: sysPrompt })
  }

  // Nur den Frage-Anteil eines Platzhalters in einer Zeile ersetzen
  function updatePlaceholderQuestionInLine(lineIndex: number, key: string, nextQuestion: string) {
    const copy = lines.slice()
    if (lineIndex < 0 || lineIndex >= copy.length) return
    const line = copy[lineIndex]
    const re = new RegExp(`\\{\\{\\s*${escapeRegExp(key)}\\s*\\|[^}]*\\}}`, 'g')
    copy[lineIndex] = line.replace(re, `{{${key}|${nextQuestion}}}`)
    onChange({ markdownBody: copy.join('\n'), yamlFrontmatter, systemPrompt: sysPrompt })
  }

  const handleSysPromptChange = (v: string) => {
    setSysPrompt(v)
    onChange({ markdownBody, yamlFrontmatter, systemPrompt: v })
  }

  return (
    <div className="space-y-3">
      <Tabs value={tab} onValueChange={(v) => setTab(v as typeof tab)}>
        <TabsList className="grid grid-cols-3 w-full">
          <TabsTrigger value="body">Body</TabsTrigger>
          <TabsTrigger value="frontmatter">Frontmatter</TabsTrigger>
          <TabsTrigger value="system">System</TabsTrigger>
        </TabsList>

        <TabsContent value="body">
          <div className="overflow-auto">
            <Table className="text-[11px] w-full border-collapse">
              <TableHeader>
                <TableRow className="[&>*]:py-1">
                  <TableHead className="w-36">Variable</TableHead>
                  <TableHead>Frage/Beschreibung</TableHead>
                </TableRow>
              </TableHeader>
              <TableBody>
                {lines.length === 0 ? (
                  <TableRow><TableCell colSpan={2} className="text-muted-foreground">Keine Zeilen im Body.</TableCell></TableRow>
                ) : lines.map((line, i) => {
                  const placeholders = extractPlaceholdersFromLine(line)
                  const onlyPlaceholder = placeholders.length === 1 && /^\s*\{\{[^}]+\}\}\s*$/.test(line)
                  return (
                    <TableRow key={`line-${i}`} className="align-top">
                      <TableCell className="align-top font-mono w-36 py-1">{placeholders.length > 0 ? placeholders.map(p => p.key).join(', ') : ''}</TableCell>
                      <TableCell className="align-top py-1">
                        {onlyPlaceholder ? (
                          <InlineEditableCell
                            value={placeholders[0].question}
                            onChange={(val) => updatePlaceholderQuestionInLine(i, placeholders[0].key, val)}
                            placeholder="Klicken zum Bearbeiten"
                          />
                        ) : (
                          <InlineEditableCell
                            value={line}
                            onChange={(val) => updateLineByIndex(i, val)}
                            placeholder="Klicken zum Bearbeiten"
                          />
                        )}
                      </TableCell>
                    </TableRow>
                  )
                })}
              </TableBody>
            </Table>
          </div>
        </TabsContent>

        <TabsContent value="frontmatter">
          <div className="max-h-[50vh] overflow-auto rounded border">
            <table className="w-full text-[11px] border-collapse">
              <thead className="sticky top-0 bg-background">
                <tr>
                  <th className="w-40 text-left px-2 py-1">Key</th>
                  <th className="w-40 text-left px-2 py-1">Variable</th>
                  <th className="text-left px-2 py-1">Frage/Beschreibung</th>
                </tr>
              </thead>
              <tbody>
                {fmEntries.length === 0 ? (
                  <tr><td colSpan={3} className="px-2 py-1 text-muted-foreground">Keine Felder im Frontmatter.</td></tr>
                ) : fmEntries.map((e, i) => {
                  const m = /\{\{([^}|]+)\|([^}]+)\}\}/.exec(e.rawValue)
                  const varKey = m ? m[1].trim() : ''
                  const varQ = m ? m[2].trim() : ''
                  return (
                    <tr key={`${e.key}-${i}`} className="align-top">
                      <td className="px-2 py-1 align-top font-mono">{e.key}</td>
                      <td className="px-2 py-1 align-top font-mono">{varKey}</td>
                      <td className="px-2 py-1 align-top">
                        <InlineEditableCell
                          value={varQ}
                          onChange={(val) => updateFrontmatterQuestion(e.key, val)}
                          placeholder="Klicken zum Bearbeiten"
                        />
                      </td>
                    </tr>
                  )
                })}
              </tbody>
            </table>
          </div>
        </TabsContent>

        <TabsContent value="system">
          <div className="space-y-1">
            <Label>System Prompt</Label>
            <Input value={sysPrompt} onChange={(e) => handleSysPromptChange(e.target.value)} className="font-mono h-8 text-xs" />
          </div>
        </TabsContent>
      </Tabs>
    </div>
  )
}

function escapeRegExp(s: string): string {
  return s.replace(/[.*+?^${}()|[\\]\\]/g, '\\$&')
}

// Inline-Edit Textarea, wächst dynamisch, aktiviert Edit bei Fokus/Klick
function EditableTextarea({ value, onChange, onBlur, onKeyDown }: { value: string; onChange: (v: string) => void; onBlur?: () => void; onKeyDown?: (e: React.KeyboardEvent<HTMLTextAreaElement>) => void }) {
  const [local, setLocal] = React.useState(value)
  const ref = React.useRef<HTMLTextAreaElement | null>(null)

  const autosize = React.useCallback(() => {
    const el = ref.current
    if (!el) return
    el.style.height = 'auto'
    el.style.height = `${el.scrollHeight}px`
  }, [])

  React.useEffect(() => { setLocal(value); requestAnimationFrame(autosize) }, [value, autosize])

  return (
    <textarea
      ref={ref}
      value={local}
      onChange={(e) => { setLocal(e.target.value); onChange(e.target.value); autosize() }}
      onInput={autosize}
      onBlur={onBlur}
      onKeyDown={onKeyDown}
      className="w-full min-h-[2.5rem] rounded-md border bg-background px-2 py-1 text-[11px] leading-snug overflow-hidden"
      style={{ resize: 'none' }}
    />
  )
}

// Zelle, die erst beim Klick in den Editiermodus mit autosizender Textarea wechselt
function InlineEditableCell({ value, onChange, placeholder }: { value: string; onChange: (v: string) => void; placeholder?: string }) {
  const [editing, setEditing] = React.useState(false)

  if (!editing) {
    return (
      <div
        role="button"
        onClick={() => setEditing(true)}
        className="cursor-text whitespace-pre-wrap break-words rounded-md px-2 py-1 min-h-[2.5rem]"
      >
        {value ? value : <span className="text-muted-foreground">{placeholder || 'Klicken zum Bearbeiten'}</span>}
      </div>
    )
  }

  return (
    <EditableTextarea
      value={value}
      onChange={onChange}
      onBlur={() => setEditing(false)}
      onKeyDown={(e) => { if (e.key === 'Escape') { e.preventDefault(); e.stopPropagation(); setEditing(false) } }}
    />
  )
}


```

```javascript
function escapeRegExp(s: string): string {
  return s.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')
}
```

```typescriptreact
"use client";

import * as React from 'react'
import { parseFrontmatterKeyValues } from '@/lib/markdown/frontmatter'
import { Button } from '@/components/ui/button'
import { Input } from '@/components/ui/input'
import { Label } from '@/components/ui/label'
import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from '@/components/ui/table'
import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs'

export interface StructuredTemplateEditorProps {
  markdownBody: string
  yamlFrontmatter: string
  systemPrompt: string
  onChange: (next: { markdownBody: string; yamlFrontmatter: string; systemPrompt: string }) => void
}

export function StructuredTemplateEditor({ markdownBody, yamlFrontmatter, systemPrompt, onChange }: StructuredTemplateEditorProps) {
  const lines = React.useMemo(() => (typeof markdownBody === 'string' ? markdownBody.split('\n') : []), [markdownBody])
  const fmEntries = React.useMemo(() => parseFrontmatterKeyValues(yamlFrontmatter || ''), [yamlFrontmatter])
  const [sysPrompt, setSysPrompt] = React.useState(systemPrompt)
  const [tab, setTab] = React.useState<'body'|'frontmatter'|'system'>('body')

  React.useEffect(() => { setSysPrompt(systemPrompt) }, [systemPrompt])

  // Zeilenbasierte Platzhalter-Erkennung (nur die betrachtete Zeile)
  function extractPlaceholdersFromLine(line: string): Array<{ key: string; question: string }> {
    const out: Array<{ key: string; question: string }> = []
    const re = /\{\{([^}|]+)\|([^}]+)\}\}/g
    let m: RegExpExecArray | null
    while ((m = re.exec(line)) !== null) {
      const key = (m[1] || '').trim()
      const question = (m[2] || '').trim()
      if (key) out.push({ key, question })
    }
    return out
  }

  // Ganze Zeile ersetzen (1:1 Markdown beibehalten)
  function updateLineByIndex(lineIndex: number, nextLine: string) {
    const copy = lines.slice()
    if (lineIndex >= 0 && lineIndex < copy.length) copy[lineIndex] = nextLine
    onChange({ markdownBody: copy.join('\n'), yamlFrontmatter, systemPrompt: sysPrompt })
  }

  // Nur den Frage-Anteil eines Platzhalters in einer Zeile ersetzen
  function updatePlaceholderQuestionInLine(lineIndex: number, key: string, nextQuestion: string) {
    const copy = lines.slice()
    if (lineIndex < 0 || lineIndex >= copy.length) return
    const line = copy[lineIndex]
    const re = new RegExp(`\\{\\{\\s*${escapeRegExp(key)}\\s*\\|[^}]*\\}}`, 'g')
    copy[lineIndex] = line.replace(re, `{{${key}|${nextQuestion}}}`)
    onChange({ markdownBody: copy.join('\n'), yamlFrontmatter, systemPrompt: sysPrompt })
  }

  const handleSysPromptChange = (v: string) => {
    setSysPrompt(v)
    onChange({ markdownBody, yamlFrontmatter, systemPrompt: v })
  }

  return (
    <div className="space-y-3">
      <Tabs value={tab} onValueChange={(v) => setTab(v as typeof tab)}>
        <TabsList className="grid grid-cols-3 w-full">
          <TabsTrigger value="body">Body</TabsTrigger>
          <TabsTrigger value="frontmatter">Frontmatter</TabsTrigger>
          <TabsTrigger value="system">System</TabsTrigger>
        </TabsList>

        <TabsContent value="body">
          <div className="overflow-auto">
            <Table className="text-[11px] w-full border-collapse">
              <TableHeader>
                <TableRow className="[&>*]:py-1">
                  <TableHead className="w-36">Variable</TableHead>
                  <TableHead>Frage/Beschreibung</TableHead>
                </TableRow>
              </TableHeader>
              <TableBody>
                {lines.length === 0 ? (
                  <TableRow><TableCell colSpan={2} className="text-muted-foreground">Keine Zeilen im Body.</TableCell></TableRow>
                ) : lines.map((line, i) => {
                  const placeholders = extractPlaceholdersFromLine(line)
                  const onlyPlaceholder = placeholders.length === 1 && /^\s*\{\{[^}]+\}\}\s*$/.test(line)
                  return (
                    <TableRow key={`line-${i}`} className="align-top">
                      <TableCell className="align-top font-mono w-36 py-1">{placeholders.length > 0 ? placeholders.map(p => p.key).join(', ') : ''}</TableCell>
                      <TableCell className="align-top py-1">
                        {onlyPlaceholder ? (
                          <InlineEditableCell
                            value={placeholders[0].question}
                            onChange={(val) => updatePlaceholderQuestionInLine(i, placeholders[0].key, val)}
                            placeholder="Klicken zum Bearbeiten"
                          />
                        ) : (
                          <InlineEditableCell
                            value={line}
                            onChange={(val) => updateLineByIndex(i, val)}
                            placeholder="Klicken zum Bearbeiten"
                          />
                        )}
                      </TableCell>
                    </TableRow>
                  )
                })}
              </TableBody>
            </Table>
          </div>
        </TabsContent>

        <TabsContent value="frontmatter">
          <div className="max-h-[50vh] overflow-auto rounded border">
            <table className="w-full text-[11px] border-collapse">
              <thead className="sticky top-0 bg-background">
                <tr>
                  <th className="w-40 text-left px-2 py-1">Key</th>
                  <th className="w-40 text-left px-2 py-1">Variable</th>
                  <th className="text-left px-2 py-1">Frage/Beschreibung</th>
                </tr>
              </thead>
              <tbody>
                {fmEntries.length === 0 ? (
                  <tr><td colSpan={3} className="px-2 py-1 text-muted-foreground">Keine Felder im Frontmatter.</td></tr>
                ) : fmEntries.map((e, i) => {
                  const m = /\{\{([^}|]+)\|([^}]+)\}\}/.exec(e.rawValue)
                  const varKey = m ? m[1].trim() : ''
                  const varQ = m ? m[2].trim() : ''
                  return (
                    <tr key={`${e.key}-${i}`} className="align-top">
                      <td className="px-2 py-1 align-top font-mono">{e.key}</td>
                      <td className="px-2 py-1 align-top font-mono">{varKey}</td>
                      <td className="px-2 py-1 align-top">
                        <InlineEditableCell
                          value={varQ}
                          onChange={(val) => updateFrontmatterQuestion(e.key, val)}
                          placeholder="Klicken zum Bearbeiten"
                        />
                      </td>
                    </tr>
                  )
                })}
              </tbody>
            </table>
          </div>
        </TabsContent>

        <TabsContent value="system">
          <div className="space-y-1">
            <Label>System Prompt</Label>
            <Input value={sysPrompt} onChange={(e) => handleSysPromptChange(e.target.value)} className="font-mono h-8 text-xs" />
          </div>
        </TabsContent>
      </Tabs>
    </div>
  )
}

function escapeRegExp(s: string): string {
  return s.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')
}

// Inline-Edit Textarea, wächst dynamisch, aktiviert Edit bei Fokus/Klick
function EditableTextarea({ value, onChange, onBlur, onKeyDown }: { value: string; onChange: (v: string) => void; onBlur?: () => void; onKeyDown?: (e: React.KeyboardEvent<HTMLTextAreaElement>) => void }) {
  const [local, setLocal] = React.useState(value)
  const ref = React.useRef<HTMLTextAreaElement | null>(null)

  const autosize = React.useCallback(() => {
    const el = ref.current
    if (!el) return
    el.style.height = 'auto'
    el.style.height = `${el.scrollHeight}px`
  }, [])

  React.useEffect(() => { setLocal(value); requestAnimationFrame(autosize) }, [value, autosize])

  return (
    <textarea
      ref={ref}
      value={local}
      onChange={(e) => { setLocal(e.target.value); onChange(e.target.value); autosize() }}
      onInput={autosize}
      onBlur={onBlur}
      onKeyDown={onKeyDown}
      className="w-full min-h-[2.5rem] rounded-md border bg-background px-2 py-1 text-[11px] leading-snug overflow-hidden"
      style={{ resize: 'none' }}
    />
  )
}

// Zelle, die erst beim Klick in den Editiermodus mit autosizender Textarea wechselt
function InlineEditableCell({ value, onChange, placeholder }: { value: string; onChange: (v: string) => void; placeholder?: string }) {
  const [editing, setEditing] = React.useState(false)

  if (!editing) {
    return (
      <div
        role="button"
        onClick={() => setEditing(true)}
        className="cursor-text whitespace-pre-wrap break-words rounded-md px-2 py-1 min-h-[2.5rem]"
      >
        {value ? value : <span className="text-muted-foreground">{placeholder || 'Klicken zum Bearbeiten'}</span>}
      </div>
    )
  }

  return (
    <EditableTextarea
      value={value}
      onChange={onChange}
      onBlur={() => setEditing(false)}
      onKeyDown={(e) => { if (e.key === 'Escape') { e.preventDefault(); e.stopPropagation(); setEditing(false) } }}
    />
  )
}


```

```typescriptreact
"use client";

import * as React from 'react'
import { parseFrontmatterKeyValues } from '@/lib/markdown/frontmatter'
import { Button } from '@/components/ui/button'
import { Input } from '@/components/ui/input'
import { Label } from '@/components/ui/label'
import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from '@/components/ui/table'
import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs'

export interface StructuredTemplateEditorProps {
  markdownBody: string
  yamlFrontmatter: string
  systemPrompt: string
  onChange: (next: { markdownBody: string; yamlFrontmatter: string; systemPrompt: string }) => void
}

export function StructuredTemplateEditor({ markdownBody, yamlFrontmatter, systemPrompt, onChange }: StructuredTemplateEditorProps) {
  const lines = React.useMemo(() => (typeof markdownBody === 'string' ? markdownBody.split('\n') : []), [markdownBody])
  const fmEntries = React.useMemo(() => parseFrontmatterKeyValues(yamlFrontmatter || ''), [yamlFrontmatter])
  const [sysPrompt, setSysPrompt] = React.useState(systemPrompt)
  const [tab, setTab] = React.useState<'body'|'frontmatter'|'system'>('body')

  React.useEffect(() => { setSysPrompt(systemPrompt) }, [systemPrompt])

  // Zeilenbasierte Platzhalter-Erkennung (nur die betrachtete Zeile)
  function extractPlaceholdersFromLine(line: string): Array<{ key: string; question: string }> {
    const out: Array<{ key: string; question: string }> = []
    const re = /\{\{([^}|]+)\|([^}]+)\}\}/g
    let m: RegExpExecArray | null
    while ((m = re.exec(line)) !== null) {
      const key = (m[1] || '').trim()
      const question = (m[2] || '').trim()
      if (key) out.push({ key, question })
    }
    return out
  }

  // Ganze Zeile ersetzen (1:1 Markdown beibehalten)
  function updateLineByIndex(lineIndex: number, nextLine: string) {
    const copy = lines.slice()
    if (lineIndex >= 0 && lineIndex < copy.length) copy[lineIndex] = nextLine
    onChange({ markdownBody: copy.join('\n'), yamlFrontmatter, systemPrompt: sysPrompt })
  }

  // Nur den Frage-Anteil eines Platzhalters in einer Zeile ersetzen
  function updatePlaceholderQuestionInLine(lineIndex: number, key: string, nextQuestion: string) {
    const copy = lines.slice()
    if (lineIndex < 0 || lineIndex >= copy.length) return
    const line = copy[lineIndex]
    const re = new RegExp(`\\{\\{\\s*${escapeRegExp(key)}\\s*\\|[^}]*\\}}`, 'g')
    copy[lineIndex] = line.replace(re, `{{${key}|${nextQuestion}}}`)
    onChange({ markdownBody: copy.join('\n'), yamlFrontmatter, systemPrompt: sysPrompt })
  }

  const handleSysPromptChange = (v: string) => {
    setSysPrompt(v)
    onChange({ markdownBody, yamlFrontmatter, systemPrompt: v })
  }

  // Inline‑Edit für Frontmatter‑Zeilen (nur Frage‑Teil rechts vom |)
  const updateFrontmatterQuestion = (entryKey: string, question: string) => {
    const linesFM = (yamlFrontmatter || '').split('\n')
    const idx = linesFM.findIndex(l => new RegExp(`^${escapeRegExp(entryKey)}\\s*:`).test(l.trim()))
    if (idx >= 0) {
      const line = linesFM[idx]
      const m = /\{\{([^}|]+)\|([^}]+)\}\}/.exec(line)
      if (m) {
        linesFM[idx] = line.replace(m[0], `{{${m[1]}|${question}}}`)
      }
      onChange({ markdownBody, yamlFrontmatter: linesFM.join('\n'), systemPrompt: sysPrompt })
    }
  }

  return (
    <div className="space-y-3">
      <Tabs value={tab} onValueChange={(v) => setTab(v as typeof tab)}>
        <TabsList className="grid grid-cols-3 w-full">
          <TabsTrigger value="body">Body</TabsTrigger>
          <TabsTrigger value="frontmatter">Frontmatter</TabsTrigger>
          <TabsTrigger value="system">System</TabsTrigger>
        </TabsList>

        <TabsContent value="body">
          <div className="overflow-auto">
            <Table className="text-[11px] w-full border-collapse">
              <TableHeader>
                <TableRow className="[&>*]:py-1">
                  <TableHead className="w-36">Variable</TableHead>
                  <TableHead>Frage/Beschreibung</TableHead>
                </TableRow>
              </TableHeader>
              <TableBody>
                {lines.length === 0 ? (
                  <TableRow><TableCell colSpan={2} className="text-muted-foreground">Keine Zeilen im Body.</TableCell></TableRow>
                ) : lines.map((line, i) => {
                  const placeholders = extractPlaceholdersFromLine(line)
                  const onlyPlaceholder = placeholders.length === 1 && /^\s*\{\{[^}]+\}\}\s*$/.test(line)
                  return (
                    <TableRow key={`line-${i}`} className="align-top">
                      <TableCell className="align-top font-mono w-36 py-1">{placeholders.length > 0 ? placeholders.map(p => p.key).join(', ') : ''}</TableCell>
                      <TableCell className="align-top py-1">
                        {onlyPlaceholder ? (
                          <InlineEditableCell
                            value={placeholders[0].question}
                            onChange={(val) => updatePlaceholderQuestionInLine(i, placeholders[0].key, val)}
                            placeholder="Klicken zum Bearbeiten"
                          />
                        ) : (
                          <InlineEditableCell
                            value={line}
                            onChange={(val) => updateLineByIndex(i, val)}
                            placeholder="Klicken zum Bearbeiten"
                          />
                        )}
                      </TableCell>
                    </TableRow>
                  )
                })}
              </TableBody>
            </Table>
          </div>
        </TabsContent>

        <TabsContent value="frontmatter">
          <div className="max-h-[50vh] overflow-auto rounded border">
            <table className="w-full text-[11px] border-collapse">
              <thead className="sticky top-0 bg-background">
                <tr>
                  <th className="w-40 text-left px-2 py-1">Key</th>
                  <th className="w-40 text-left px-2 py-1">Variable</th>
                  <th className="text-left px-2 py-1">Frage/Beschreibung</th>
                </tr>
              </thead>
              <tbody>
                {fmEntries.length === 0 ? (
                  <tr><td colSpan={3} className="px-2 py-1 text-muted-foreground">Keine Felder im Frontmatter.</td></tr>
                ) : fmEntries.map((e, i) => {
                  const m = /\{\{([^}|]+)\|([^}]+)\}\}/.exec(e.rawValue)
                  const varKey = m ? m[1].trim() : ''
                  const varQ = m ? m[2].trim() : ''
                  return (
                    <tr key={`${e.key}-${i}`} className="align-top">
                      <td className="px-2 py-1 align-top font-mono">{e.key}</td>
                      <td className="px-2 py-1 align-top font-mono">{varKey}</td>
                      <td className="px-2 py-1 align-top">
                        <InlineEditableCell
                          value={varQ}
                          onChange={(val) => updateFrontmatterQuestion(e.key, val)}
                          placeholder="Klicken zum Bearbeiten"
                        />
                      </td>
                    </tr>
                  )
                })}
              </tbody>
            </table>
          </div>
        </TabsContent>

        <TabsContent value="system">
          <div className="space-y-1">
            <Label>System Prompt</Label>
            <Input value={sysPrompt} onChange={(e) => handleSysPromptChange(e.target.value)} className="font-mono h-8 text-xs" />
          </div>
        </TabsContent>
      </Tabs>
    </div>
  )
}

function escapeRegExp(s: string): string {
  return s.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')
}

// Inline-Edit Textarea, wächst dynamisch, aktiviert Edit bei Fokus/Klick
function EditableTextarea({ value, onChange, onBlur, onKeyDown }: { value: string; onChange: (v: string) => void; onBlur?: () => void; onKeyDown?: (e: React.KeyboardEvent<HTMLTextAreaElement>) => void }) {
  const [local, setLocal] = React.useState(value)
  const ref = React.useRef<HTMLTextAreaElement | null>(null)

  const autosize = React.useCallback(() => {
    const el = ref.current
    if (!el) return
    el.style.height = 'auto'
    el.style.height = `${el.scrollHeight}px`
  }, [])

  React.useEffect(() => { setLocal(value); requestAnimationFrame(autosize) }, [value, autosize])

  return (
    <textarea
      ref={ref}
      value={local}
      onChange={(e) => { setLocal(e.target.value); onChange(e.target.value); autosize() }}
      onInput={autosize}
      onBlur={onBlur}
      onKeyDown={onKeyDown}
      className="w-full min-h-[2.5rem] rounded-md border bg-background px-2 py-1 text-[11px] leading-snug overflow-hidden"
      style={{ resize: 'none' }}
    />
  )
}

// Zelle, die erst beim Klick in den Editiermodus mit autosizender Textarea wechselt
function InlineEditableCell({ value, onChange, placeholder }: { value: string; onChange: (v: string) => void; placeholder?: string }) {
  const [editing, setEditing] = React.useState(false)

  if (!editing) {
    return (
      <div
        role="button"
        onClick={() => setEditing(true)}
        className="cursor-text whitespace-pre-wrap break-words rounded-md px-2 py-1 min-h-[2.5rem]"
      >
        {value ? value : <span className="text-muted-foreground">{placeholder || 'Klicken zum Bearbeiten'}</span>}
      </div>
    )
  }

  return (
    <EditableTextarea
      value={value}
      onChange={onChange}
      onBlur={() => setEditing(false)}
      onKeyDown={(e) => { if (e.key === 'Escape') { e.preventDefault(); e.stopPropagation(); setEditing(false) } }}
    />
  )
}


```

- Ich habe den Body-Tab auf zeilenbasierte Darstellung umgestellt: eine Tabellenzeile pro originaler Markdown-Zeile, Reihenfolge bleibt 1:1 erhalten. Wir sprechen nicht mehr von Abschnitten.
- Spalte 1 zeigt die Variable(n), falls in der Zeile Platzhalter vorkommen; sonst leer. Spalte 2 zeigt den originalen Zeilentext.
- Inline-Editing:
  - Zeilen mit genau einem Platzhalter-Token wie {{key|frage}}: In Spalte 2 wird nur die Frage editierbar gemacht, Update ersetzt in genau dieser Zeile den Frageanteil des Tokens.
  - Alle anderen Zeilen (inkl. Headings, normaler Text, mehrere Platzhalter): Spalte 2 ist als Ganzes editierbar; beim Speichern wird exakt diese Zeile ersetzt.
- Autosize/Textfluss bleibt erhalten; Enter erzeugt Zeilenumbrüche innerhalb der Zelle; Blur/Escape beendet Edit.

Kurz testen:
- Eine Markdown-Zeile ohne Platzhalter bearbeiten: Text ändert sich in Vorschau/Speichern.
- Eine Zeile nur mit {{titel|...}} bearbeiten: nur Frageanteil aktualisiert, Key bleibt unverändert, andere Zeilen bleiben unberührt.
- Zeilenreihenfolge und Inhalt ohne Platzhalter bleiben unverfälscht.

---

**User**

Sehr gut, am Ende würde ich eine ganz dezente Spalte machen, wo ich mit Drag-and-Drop-Symbol die Zeilen in der Reihenfolge verschieben kann und ein kleines Plus-Symbol, wo ich eine neue Zeile einfügen kann. Dieses Variablenfeld würde ich dann immer editierbar halten. Das heißt, immer wenn ich eine Variable einsetze, dann ist die zweite Spalte dann auch eine Frage für diese Variable und wenn ich die Variable leer lasse, dann ist es so ein Markdown Text.

---

**Cursor**

```typescriptreact
"use client";

import * as React from 'react'
import { parseFrontmatterKeyValues } from '@/lib/markdown/frontmatter'
import { Input } from '@/components/ui/input'
import { Label } from '@/components/ui/label'
import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from '@/components/ui/table'
import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs'
import { GripVertical, Plus } from 'lucide-react'

export interface StructuredTemplateEditorProps {
  markdownBody: string
  yamlFrontmatter: string
  systemPrompt: string
  onChange: (next: { markdownBody: string; yamlFrontmatter: string; systemPrompt: string }) => void
}

export function StructuredTemplateEditor({ markdownBody, yamlFrontmatter, systemPrompt, onChange }: StructuredTemplateEditorProps) {
  const lines = React.useMemo(() => (typeof markdownBody === 'string' ? markdownBody.split('\n') : []), [markdownBody])
  const fmEntries = React.useMemo(() => parseFrontmatterKeyValues(yamlFrontmatter || ''), [yamlFrontmatter])
  const [sysPrompt, setSysPrompt] = React.useState(systemPrompt)
  const [tab, setTab] = React.useState<'body'|'frontmatter'|'system'>('body')
  const dragFrom = React.useRef<number | null>(null)

  React.useEffect(() => { setSysPrompt(systemPrompt) }, [systemPrompt])

  // Zeilenbasierte Platzhalter-Erkennung (nur die betrachtete Zeile)
  function parseLine(line: string): { varKey: string; content: string } {
    const m = /^\s*\{\{([^}|]+)\|([^}]+)\}\}\s*$/.exec(line)
    if (m) return { varKey: (m[1] || '').trim(), content: (m[2] || '').trim() }
    return { varKey: '', content: line }
  }

  function buildLine(varKey: string, content: string): string {
    const k = (varKey || '').trim()
    return k ? `{{${k}|${content}}}` : content
  }

  // Ganze Zeile ersetzen (1:1 Markdown beibehalten)
  function updateLineByIndex(lineIndex: number, nextLine: string) {
    const copy = lines.slice()
    if (lineIndex >= 0 && lineIndex < copy.length) copy[lineIndex] = nextLine
    onChange({ markdownBody: copy.join('\n'), yamlFrontmatter, systemPrompt: sysPrompt })
  }

  // Variable-Key ändern (wandelt Zeile zwischen Placeholder/Plain um)
  function updateVarKey(lineIndex: number, nextKey: string) {
    if (lineIndex < 0 || lineIndex >= lines.length) return
    const { content } = parseLine(lines[lineIndex])
    updateLineByIndex(lineIndex, buildLine(nextKey, content))
  }

  // Inhalt/Frage ändern (abhängig davon, ob varKey existiert)
  function updateContent(lineIndex: number, nextContent: string) {
    if (lineIndex < 0 || lineIndex >= lines.length) return
    const { varKey } = parseLine(lines[lineIndex])
    updateLineByIndex(lineIndex, buildLine(varKey, nextContent))
  }

  // Frontmatter-Frage aktualisieren (unverändert zum vorherigen Verhalten)
  const updateFrontmatterQuestion = (entryKey: string, question: string) => {
    const linesFM = (yamlFrontmatter || '').split('\n')
    const idx = linesFM.findIndex(l => new RegExp(`^${escapeRegExp(entryKey)}\\s*:`).test(l.trim()))
    if (idx >= 0) {
      const line = linesFM[idx]
      const m = /\{\{([^}|]+)\|([^}]+)\}\}/.exec(line)
      if (m) {
        linesFM[idx] = line.replace(m[0], `{{${m[1]}|${question}}}`)
      }
      onChange({ markdownBody, yamlFrontmatter: linesFM.join('\n'), systemPrompt: sysPrompt })
    }
  }

  // Drag & Drop Reorder
  function handleDragStart(e: React.DragEvent, fromIndex: number) {
    dragFrom.current = fromIndex
    e.dataTransfer.setData('text/plain', String(fromIndex))
    e.dataTransfer.effectAllowed = 'move'
  }
  function handleDragOver(e: React.DragEvent) {
    e.preventDefault()
    e.dataTransfer.dropEffect = 'move'
  }
  function handleDrop(e: React.DragEvent, toIndex: number) {
    e.preventDefault()
    const fromStr = e.dataTransfer.getData('text/plain')
    const fromIndex = Number.isInteger(Number(fromStr)) ? parseInt(fromStr, 10) : dragFrom.current
    if (fromIndex === null || isNaN(fromIndex) || fromIndex === toIndex) return
    const arr = lines.slice()
    const [moved] = arr.splice(fromIndex, 1)
    arr.splice(toIndex, 0, moved)
    onChange({ markdownBody: arr.join('\n'), yamlFrontmatter, systemPrompt: sysPrompt })
    dragFrom.current = null
  }

  function addLineAfter(index: number) {
    const arr = lines.slice()
    arr.splice(index + 1, 0, '')
    onChange({ markdownBody: arr.join('\n'), yamlFrontmatter, systemPrompt: sysPrompt })
  }

  const handleSysPromptChange = (v: string) => {
    setSysPrompt(v)
    onChange({ markdownBody, yamlFrontmatter, systemPrompt: v })
  }

  return (
    <div className="space-y-3">
      <Tabs value={tab} onValueChange={(v) => setTab(v as typeof tab)}>
        <TabsList className="grid grid-cols-3 w-full">
          <TabsTrigger value="body">Body</TabsTrigger>
          <TabsTrigger value="frontmatter">Frontmatter</TabsTrigger>
          <TabsTrigger value="system">System</TabsTrigger>
        </TabsList>

        <TabsContent value="body">
          <div className="overflow-auto">
            <Table className="text-[11px] w-full border-collapse">
              <TableHeader>
                <TableRow className="[&>*]:py-1">
                  <TableHead className="w-8" />
                  <TableHead className="w-36">Variable</TableHead>
                  <TableHead>Text / Frage</TableHead>
                </TableRow>
              </TableHeader>
              <TableBody>
                {lines.length === 0 ? (
                  <TableRow><TableCell colSpan={3} className="text-muted-foreground">Keine Zeilen im Body.</TableCell></TableRow>
                ) : lines.map((line, i) => {
                  const { varKey, content } = parseLine(line)
                  return (
                    <TableRow key={`line-${i}`} className="align-top" onDragOver={handleDragOver} onDrop={(e) => handleDrop(e, i)}>
                      <TableCell className="align-top w-8 py-1">
                        <div className="flex items-center gap-1">
                          <span
                            draggable
                            onDragStart={(e) => handleDragStart(e, i)}
                            className="inline-flex h-4 w-4 items-center justify-center text-muted-foreground cursor-grab hover:text-foreground"
                            title="Ziehen zum Verschieben"
                            aria-label="Ziehen zum Verschieben"
                          >
                            <GripVertical className="h-3 w-3" />
                          </span>
                          <button
                            type="button"
                            className="inline-flex h-4 w-4 items-center justify-center text-muted-foreground hover:text-foreground"
                            title="Zeile darunter einfügen"
                            aria-label="Zeile darunter einfügen"
                            onClick={() => addLineAfter(i)}
                          >
                            <Plus className="h-3 w-3" />
                          </button>
                        </div>
                      </TableCell>
                      <TableCell className="align-top font-mono w-36 py-1">
                        <InlineEditableCell
                          value={varKey}
                          onChange={(val) => updateVarKey(i, val)}
                          placeholder="Variable (optional)"
                        />
                      </TableCell>
                      <TableCell className="align-top py-1">
                        <InlineEditableCell
                          value={content}
                          onChange={(val) => updateContent(i, val)}
                          placeholder={varKey ? 'Frage/Beschreibung' : 'Markdown-Text'}
                        />
                      </TableCell>
                    </TableRow>
                  )
                })}
              </TableBody>
            </Table>
          </div>
        </TabsContent>

        <TabsContent value="frontmatter">
          <div className="max-h-[50vh] overflow-auto rounded border">
            <table className="w-full text-[11px] border-collapse">
              <thead className="sticky top-0 bg-background">
                <tr>
                  <th className="w-40 text-left px-2 py-1">Key</th>
                  <th className="w-40 text-left px-2 py-1">Variable</th>
                  <th className="text-left px-2 py-1">Frage/Beschreibung</th>
                </tr>
              </thead>
              <tbody>
                {fmEntries.length === 0 ? (
                  <tr><td colSpan={3} className="px-2 py-1 text-muted-foreground">Keine Felder im Frontmatter.</td></tr>
                ) : fmEntries.map((e, i) => {
                  const m = /\{\{([^}|]+)\|([^}]+)\}\}/.exec(e.rawValue)
                  const varKey = m ? m[1].trim() : ''
                  const varQ = m ? m[2].trim() : ''
                  return (
                    <tr key={`${e.key}-${i}`} className="align-top">
                      <td className="px-2 py-1 align-top font-mono">{e.key}</td>
                      <td className="px-2 py-1 align-top font-mono">{varKey}</td>
                      <td className="px-2 py-1 align-top">
                        <InlineEditableCell
                          value={varQ}
                          onChange={(val) => updateFrontmatterQuestion(e.key, val)}
                          placeholder="Klicken zum Bearbeiten"
                        />
                      </td>
                    </tr>
                  )
                })}
              </tbody>
            </table>
          </div>
        </TabsContent>

        <TabsContent value="system">
          <div className="space-y-1">
            <Label>System Prompt</Label>
            <Input value={sysPrompt} onChange={(e) => handleSysPromptChange(e.target.value)} className="font-mono h-8 text-xs" />
          </div>
        </TabsContent>
      </Tabs>
    </div>
  )
}

function escapeRegExp(s: string): string {
  return s.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')
}

// Inline-Edit Textarea, wächst dynamisch, aktiviert Edit bei Fokus/Klick
function EditableTextarea({ value, onChange, onBlur, onKeyDown }: { value: string; onChange: (v: string) => void; onBlur?: () => void; onKeyDown?: (e: React.KeyboardEvent<HTMLTextAreaElement>) => void }) {
  const [local, setLocal] = React.useState(value)
  const ref = React.useRef<HTMLTextAreaElement | null>(null)

  const autosize = React.useCallback(() => {
    const el = ref.current
    if (!el) return
    el.style.height = 'auto'
    el.style.height = `${el.scrollHeight}px`
  }, [])

  React.useEffect(() => { setLocal(value); requestAnimationFrame(autosize) }, [value, autosize])

  return (
    <textarea
      ref={ref}
      value={local}
      onChange={(e) => { setLocal(e.target.value); onChange(e.target.value); autosize() }}
      onInput={autosize}
      onBlur={onBlur}
      onKeyDown={onKeyDown}
      className="w-full min-h-[2.5rem] rounded-md border bg-background px-2 py-1 text-[11px] leading-snug overflow-hidden"
      style={{ resize: 'none' }}
    />
  )
}

// Zelle, die erst beim Klick in den Editiermodus mit autosizender Textarea wechselt
function InlineEditableCell({ value, onChange, placeholder }: { value: string; onChange: (v: string) => void; placeholder?: string }) {
  const [editing, setEditing] = React.useState(false)

  if (!editing) {
    return (
      <div
        role="button"
        onClick={() => setEditing(true)}
        className="cursor-text whitespace-pre-wrap break-words rounded-md px-2 py-1 min-h-[2.5rem]"
      >
        {value ? value : <span className="text-muted-foreground">{placeholder || 'Klicken zum Bearbeiten'}</span>}
      </div>
    )
  }

  return (
    <EditableTextarea
      value={value}
      onChange={onChange}
      onBlur={() => setEditing(false)}
      onKeyDown={(e) => { if (e.key === 'Escape') { e.preventDefault(); e.stopPropagation(); setEditing(false) } }}
    />
  )
}


```

- Umsetzung: Body-Tab hat jetzt 3 Spalten: ganz links dezente DnD-/Plus-Kontrollen, dann Variable (immer editierbar), dann Text/Frage (editierbar). Reihenfolge per Drag-and-Drop änderbar, neue Zeile via Plus unter der aktuellen einfügbar.
- Logik:
  - Zeilenparsing: Wenn eine Zeile exakt {{key|frage}} ist, dann ist varKey=key und content=frage. Sonst varKey='' und content=Originalzeile.
  - Editieren Variable: Setzt/entfernt Platzhalter. Leer = Plain-Text-Zeile; nicht leer = Zeile wird zu {{key|content}}.
  - Editieren Text/Frage: Aktualisiert entweder die Frage des Platzhalters (falls varKey gesetzt) oder den Plain-Text der Zeile.
  - DnD: Griff-Symbol zum Ziehen; Drop verschiebt die Zeile; Plus fügt leere Zeile darunter ein.
- Verhalten:
  - Struktur bleibt 1:1 erhalten, nur einzelne Zeilen werden ersetzt.
  - Autosize-Inputs verhindern abgeschnittene Inhalte.
  - Headings/normaler Text bleiben normal editierbar in Spalte 2.

---

**User**

Diese Markdown Zwischentexte sind ja meistens Titel. Können wir in der Spalte Variable eventuell auch eine Dropdown anbieten, wo man Text, Heading 1, Heading 2, Heading 3, Bold, also die wichtigsten Markdown Formatierungszeichen anbietet, oder auch eben Variable, wo man dann eine Variable einfügt. Wie könnte man das möglichst platzsparend einbauen und dezent, sodass in der Spalte Textfrage diese Formatierungszeichen verschwinden und ich nur mehr den Text sehe.

---

**Cursor**

```typescriptreact
"use client";

import * as React from 'react'
import { parseFrontmatterKeyValues } from '@/lib/markdown/frontmatter'
import { Input } from '@/components/ui/input'
import { Label } from '@/components/ui/label'
import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from '@/components/ui/table'
import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs'
import { GripVertical, Plus } from 'lucide-react'
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select'

export interface StructuredTemplateEditorProps {
  markdownBody: string
  yamlFrontmatter: string
  systemPrompt: string
  onChange: (next: { markdownBody: string; yamlFrontmatter: string; systemPrompt: string }) => void
}

type LineKind = 'text' | 'h1' | 'h2' | 'h3' | 'bold' | 'variable'

export function StructuredTemplateEditor({ markdownBody, yamlFrontmatter, systemPrompt, onChange }: StructuredTemplateEditorProps) {
  const lines = React.useMemo(() => (typeof markdownBody === 'string' ? markdownBody.split('\n') : []), [markdownBody])
  const fmEntries = React.useMemo(() => parseFrontmatterKeyValues(yamlFrontmatter || ''), [yamlFrontmatter])
  const [sysPrompt, setSysPrompt] = React.useState(systemPrompt)
  const [tab, setTab] = React.useState<'body'|'frontmatter'|'system'>('body')
  const dragFrom = React.useRef<number | null>(null)

  React.useEffect(() => { setSysPrompt(systemPrompt) }, [systemPrompt])

  function parseLine(line: string): { kind: LineKind; varKey: string; content: string } {
    const mVar = /^\s*\{\{([^}|]+)\|([^}]+)\}\}\s*$/.exec(line)
    if (mVar) return { kind: 'variable', varKey: (mVar[1] || '').trim(), content: (mVar[2] || '').trim() }
    if (/^\s*###\s+/.test(line)) return { kind: 'h3', varKey: '', content: line.replace(/^\s*###\s+/, '') }
    if (/^\s*##\s+/.test(line)) return { kind: 'h2', varKey: '', content: line.replace(/^\s*##\s+/, '') }
    if (/^\s*#\s+/.test(line)) return { kind: 'h1', varKey: '', content: line.replace(/^\s*#\s+/, '') }
    const mBold = /^\s*\*\*([\s\S]*?)\*\*\s*$/.exec(line)
    if (mBold) return { kind: 'bold', varKey: '', content: (mBold[1] || '') }
    return { kind: 'text', varKey: '', content: line }
  }

  function buildLine(kind: LineKind, content: string, varKey?: string): string {
    const text = content ?? ''
    switch (kind) {
      case 'variable': {
        const k = (varKey || '').trim()
        return k ? `{{${k}|${text}}}` : text
      }
      case 'h1': return `# ${text}`
      case 'h2': return `## ${text}`
      case 'h3': return `### ${text}`
      case 'bold': return `**${text}**`
      case 'text': default: return text
    }
  }

  function updateLineByIndex(lineIndex: number, nextLine: string) {
    const copy = lines.slice()
    if (lineIndex >= 0 && lineIndex < copy.length) copy[lineIndex] = nextLine
    onChange({ markdownBody: copy.join('\n'), yamlFrontmatter, systemPrompt: sysPrompt })
  }

  function updateLineKind(lineIndex: number, nextKind: LineKind) {
    if (lineIndex < 0 || lineIndex >= lines.length) return
    const { content, varKey } = parseLine(lines[lineIndex])
    updateLineByIndex(lineIndex, buildLine(nextKind, content, varKey))
  }

  function updateVarKey(lineIndex: number, nextKey: string) {
    if (lineIndex < 0 || lineIndex >= lines.length) return
    const { kind, content } = parseLine(lines[lineIndex])
    const realKind: LineKind = 'variable'
    updateLineByIndex(lineIndex, buildLine(realKind, content, nextKey))
  }

  function updateContent(lineIndex: number, nextContent: string) {
    if (lineIndex < 0 || lineIndex >= lines.length) return
    const { kind, varKey } = parseLine(lines[lineIndex])
    updateLineByIndex(lineIndex, buildLine(kind, nextContent, varKey))
  }

  const updateFrontmatterQuestion = (entryKey: string, question: string) => {
    const linesFM = (yamlFrontmatter || '').split('\n')
    const idx = linesFM.findIndex(l => new RegExp(`^${escapeRegExp(entryKey)}\\s*:`).test(l.trim()))
    if (idx >= 0) {
      const line = linesFM[idx]
      const m = /\{\{([^}|]+)\|([^}]+)\}\}/.exec(line)
      if (m) {
        linesFM[idx] = line.replace(m[0], `{{${m[1]}|${question}}}`)
      }
      onChange({ markdownBody, yamlFrontmatter: linesFM.join('\n'), systemPrompt: sysPrompt })
    }
  }

  function handleDragStart(e: React.DragEvent, fromIndex: number) {
    dragFrom.current = fromIndex
    e.dataTransfer.setData('text/plain', String(fromIndex))
    e.dataTransfer.effectAllowed = 'move'
  }
  function handleDragOver(e: React.DragEvent) {
    e.preventDefault()
    e.dataTransfer.dropEffect = 'move'
  }
  function handleDrop(e: React.DragEvent, toIndex: number) {
    e.preventDefault()
    const fromStr = e.dataTransfer.getData('text/plain')
    const fromIndex = Number.isInteger(Number(fromStr)) ? parseInt(fromStr, 10) : dragFrom.current
    if (fromIndex === null || isNaN(fromIndex) || fromIndex === toIndex) return
    const arr = lines.slice()
    const [moved] = arr.splice(fromIndex, 1)
    arr.splice(toIndex, 0, moved)
    onChange({ markdownBody: arr.join('\n'), yamlFrontmatter, systemPrompt: sysPrompt })
    dragFrom.current = null
  }

  function addLineAfter(index: number) {
    const arr = lines.slice()
    arr.splice(index + 1, 0, '')
    onChange({ markdownBody: arr.join('\n'), yamlFrontmatter, systemPrompt: sysPrompt })
  }

  const handleSysPromptChange = (v: string) => {
    setSysPrompt(v)
    onChange({ markdownBody, yamlFrontmatter, systemPrompt: v })
  }

  return (
    <div className="space-y-3">
      <Tabs value={tab} onValueChange={(v) => setTab(v as typeof tab)}>
        <TabsList className="grid grid-cols-3 w-full">
          <TabsTrigger value="body">Body</TabsTrigger>
          <TabsTrigger value="frontmatter">Frontmatter</TabsTrigger>
          <TabsTrigger value="system">System</TabsTrigger>
        </TabsList>

        <TabsContent value="body">
          <div className="overflow-auto">
            <Table className="text-[11px] w-full border-collapse">
              <TableHeader>
                <TableRow className="[&>*]:py-1">
                  <TableHead className="w-8" />
                  <TableHead className="w-36">Typ/Variable</TableHead>
                  <TableHead>Text / Frage</TableHead>
                </TableRow>
              </TableHeader>
              <TableBody>
                {lines.length === 0 ? (
                  <TableRow><TableCell colSpan={3} className="text-muted-foreground">Keine Zeilen im Body.</TableCell></TableRow>
                ) : lines.map((line, i) => {
                  const { kind, varKey, content } = parseLine(line)
                  return (
                    <TableRow key={`line-${i}`} className="align-top" onDragOver={handleDragOver} onDrop={(e) => handleDrop(e, i)}>
                      <TableCell className="align-top w-8 py-1">
                        <div className="flex items-center gap-1">
                          <span
                            draggable
                            onDragStart={(e) => handleDragStart(e, i)}
                            className="inline-flex h-4 w-4 items-center justify-center text-muted-foreground cursor-grab hover:text-foreground"
                            title="Ziehen zum Verschieben"
                            aria-label="Ziehen zum Verschieben"
                          >
                            <GripVertical className="h-3 w-3" />
                          </span>
                          <button
                            type="button"
                            className="inline-flex h-4 w-4 items-center justify-center text-muted-foreground hover:text-foreground"
                            title="Zeile darunter einfügen"
                            aria-label="Zeile darunter einfügen"
                            onClick={() => addLineAfter(i)}
                          >
                            <Plus className="h-3 w-3" />
                          </button>
                        </div>
                      </TableCell>
                      <TableCell className="align-top w-36 py-1">
                        <div className="flex flex-col gap-1">
                          <Select value={kind} onValueChange={(v) => updateLineKind(i, v as LineKind)}>
                            <SelectTrigger className="h-7 text-[11px]">
                              <SelectValue placeholder="Text" />
                            </SelectTrigger>
                            <SelectContent>
                              <SelectItem value="text">Text</SelectItem>
                              <SelectItem value="h1">Heading 1</SelectItem>
                              <SelectItem value="h2">Heading 2</SelectItem>
                              <SelectItem value="h3">Heading 3</SelectItem>
                              <SelectItem value="bold">Bold</SelectItem>
                              <SelectItem value="variable">Variable</SelectItem>
                            </SelectContent>
                          </Select>
                          {kind === 'variable' ? (
                            <Input
                              value={varKey}
                              onChange={(e) => updateVarKey(i, e.target.value)}
                              placeholder="Variablenname"
                              className="h-7 text-[11px] font-mono"
                            />
                          ) : null}
                        </div>
                      </TableCell>
                      <TableCell className="align-top py-1">
                        <InlineEditableCell
                          value={content}
                          onChange={(val) => updateContent(i, val)}
                          placeholder={kind === 'variable' ? 'Frage/Beschreibung' : 'Markdown-Text'}
                        />
                      </TableCell>
                    </TableRow>
                  )
                })}
              </TableBody>
            </Table>
          </div>
        </TabsContent>

        <TabsContent value="frontmatter">
          <div className="max-h-[50vh] overflow-auto rounded border">
            <table className="w-full text-[11px] border-collapse">
              <thead className="sticky top-0 bg-background">
                <tr>
                  <th className="w-40 text-left px-2 py-1">Key</th>
                  <th className="w-40 text-left px-2 py-1">Variable</th>
                  <th className="text-left px-2 py-1">Frage/Beschreibung</th>
                </tr>
              </thead>
              <tbody>
                {fmEntries.length === 0 ? (
                  <tr><td colSpan={3} className="px-2 py-1 text-muted-foreground">Keine Felder im Frontmatter.</td></tr>
                ) : fmEntries.map((e, i) => {
                  const m = /\{\{([^}|]+)\|([^}]+)\}\}/.exec(e.rawValue)
                  const varKey = m ? m[1].trim() : ''
                  const varQ = m ? m[2].trim() : ''
                  return (
                    <tr key={`${e.key}-${i}`} className="align-top">
                      <td className="px-2 py-1 align-top font-mono">{e.key}</td>
                      <td className="px-2 py-1 align-top font-mono">{varKey}</td>
                      <td className="px-2 py-1 align-top">
                        <InlineEditableCell
                          value={varQ}
                          onChange={(val) => updateFrontmatterQuestion(e.key, val)}
                          placeholder="Klicken zum Bearbeiten"
                        />
                      </td>
                    </tr>
                  )
                })}
              </tbody>
            </table>
          </div>
        </TabsContent>

        <TabsContent value="system">
          <div className="space-y-1">
            <Label>System Prompt</Label>
            <Input value={sysPrompt} onChange={(e) => handleSysPromptChange(e.target.value)} className="font-mono h-8 text-xs" />
          </div>
        </TabsContent>
      </Tabs>
    </div>
  )
}

function escapeRegExp(s: string): string {
  return s.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')
}

function EditableTextarea({ value, onChange, onBlur, onKeyDown }: { value: string; onChange: (v: string) => void; onBlur?: () => void; onKeyDown?: (e: React.KeyboardEvent<HTMLTextAreaElement>) => void }) {
  const [local, setLocal] = React.useState(value)
  const ref = React.useRef<HTMLTextAreaElement | null>(null)

  const autosize = React.useCallback(() => {
    const el = ref.current
    if (!el) return
    el.style.height = 'auto'
    el.style.height = `${el.scrollHeight}px`
  }, [])

  React.useEffect(() => { setLocal(value); requestAnimationFrame(autosize) }, [value, autosize])

  return (
    <textarea
      ref={ref}
      value={local}
      onChange={(e) => { setLocal(e.target.value); onChange(e.target.value); autosize() }}
      onInput={autosize}
      onBlur={onBlur}
      onKeyDown={onKeyDown}
      className="w-full min-h-[2.5rem] rounded-md border bg-background px-2 py-1 text-[11px] leading-snug overflow-hidden"
      style={{ resize: 'none' }}
    />
  )
}

function InlineEditableCell({ value, onChange, placeholder }: { value: string; onChange: (v: string) => void; placeholder?: string }) {
  const [editing, setEditing] = React.useState(false)

  if (!editing) {
    return (
      <div
        role="button"
        onClick={() => setEditing(true)}
        className="cursor-text whitespace-pre-wrap break-words rounded-md px-2 py-1 min-h-[2.5rem]"
      >
        {value ? value : <span className="text-muted-foreground">{placeholder || 'Klicken zum Bearbeiten'}</span>}
      </div>
    )
  }

  return (
    <EditableTextarea
      value={value}
      onChange={onChange}
      onBlur={() => setEditing(false)}
      onKeyDown={(e) => { if (e.key === 'Escape') { e.preventDefault(); e.stopPropagation(); setEditing(false) } }}
    />
  )
}


```

- Umsetzung: In der Spalte „Typ/Variable“ gibt es jetzt ein kompaktes Dropdown mit Text, Heading 1/2/3, Bold, Variable. Bei Auswahl „Variable“ erscheint darunter ein kleines Eingabefeld für den Variablennamen. Die rechte Spalte zeigt immer nur den reinen Text/Frage ohne Markdown-Symbole; die Markdown-Syntax wird beim Speichern der Zeile rekonstruiert.
- Verhalten:
  - Text: speichert die Zeile unverändert.
  - Heading 1/2/3: speichert als `#`, `##`, `###` plus Text.
  - Bold: speichert als `**Text**`.
  - Variable: speichert als `{{varKey|Frage}}`.
- DnD/Plus: Links bleibt das dezente Drag-Handle und Plus für „Zeile darunter einfügen“.
- Vorteil: Sehr platzsparend, semantische Auswahl im Dropdown, lesbarer Inhalt in der Textspalte ohne Formatierungszeichen.

---

**User**

Wenn ich Variable wähle, dann müsste dann auch das Variablenfeld angezeigt werden, oder?

---

**Cursor**

Ja. Ist bereits so umgesetzt:

- Wählst du in der Typ-Auswahl „Variable“, erscheint darunter sofort ein kleines Eingabefeld „Variablenname“ in der linken Spalte.
- Die rechte Spalte zeigt dann die Frage/Beschreibung zur Variable.
- Leerst du den Variablennamen wieder, wird die Zeile automatisch zu normalem Text.

---

**User**

Variablenauswahl funktioniert nicht

---

**Cursor**

Ich passe die Logik für die Auswahl „Variable“ an: Beim Umschalten auf „Variable“ wird die Zeile sofort in einen Platzhalter mit einem generierten Default-Variablennamen umgewandelt, damit das Variablenfeld sichtbar wird. Danach kann der Key direkt editiert werden. Jetzt ändere ich die Funktionen entsprechend.

```typescriptreact
"use client";

import * as React from 'react'
import { parseFrontmatterKeyValues } from '@/lib/markdown/frontmatter'
import { Input } from '@/components/ui/input'
import { Label } from '@/components/ui/label'
import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from '@/components/ui/table'
import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs'
import { GripVertical, Plus } from 'lucide-react'
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select'

export interface StructuredTemplateEditorProps {
  markdownBody: string
  yamlFrontmatter: string
  systemPrompt: string
  onChange: (next: { markdownBody: string; yamlFrontmatter: string; systemPrompt: string }) => void
}

type LineKind = 'text' | 'h1' | 'h2' | 'h3' | 'bold' | 'variable'

export function StructuredTemplateEditor({ markdownBody, yamlFrontmatter, systemPrompt, onChange }: StructuredTemplateEditorProps) {
  const lines = React.useMemo(() => (typeof markdownBody === 'string' ? markdownBody.split('\n') : []), [markdownBody])
  const fmEntries = React.useMemo(() => parseFrontmatterKeyValues(yamlFrontmatter || ''), [yamlFrontmatter])
  const [sysPrompt, setSysPrompt] = React.useState(systemPrompt)
  const [tab, setTab] = React.useState<'body'|'frontmatter'|'system'>('body')
  const dragFrom = React.useRef<number | null>(null)

  React.useEffect(() => { setSysPrompt(systemPrompt) }, [systemPrompt])

  function parseLine(line: string): { kind: LineKind; varKey: string; content: string } {
    const mVar = /^\s*\{\{([^}|]+)\|([^}]+)\}\}\s*$/.exec(line)
    if (mVar) return { kind: 'variable', varKey: (mVar[1] || '').trim(), content: (mVar[2] || '').trim() }
    if (/^\s*###\s+/.test(line)) return { kind: 'h3', varKey: '', content: line.replace(/^\s*###\s+/, '') }
    if (/^\s*##\s+/.test(line)) return { kind: 'h2', varKey: '', content: line.replace(/^\s*##\s+/, '') }
    if (/^\s*#\s+/.test(line)) return { kind: 'h1', varKey: '', content: line.replace(/^\s*#\s+/, '') }
    const mBold = /^\s*\*\*([\s\S]*?)\*\*\s*$/.exec(line)
    if (mBold) return { kind: 'bold', varKey: '', content: (mBold[1] || '') }
    return { kind: 'text', varKey: '', content: line }
  }

  function buildLine(kind: LineKind, content: string, varKey?: string): string {
    const text = content ?? ''
    switch (kind) {
      case 'variable': {
        const k = (varKey || '').trim()
        return k ? `{{${k}|${text}}}` : text
      }
      case 'h1': return `# ${text}`
      case 'h2': return `## ${text}`
      case 'h3': return `### ${text}`
      case 'bold': return `**${text}**`
      case 'text': default: return text
    }
  }

  function updateLineByIndex(lineIndex: number, nextLine: string) {
    const copy = lines.slice()
    if (lineIndex >= 0 && lineIndex < copy.length) copy[lineIndex] = nextLine
    onChange({ markdownBody: copy.join('\n'), yamlFrontmatter, systemPrompt: sysPrompt })
  }

  function suggestVarKey(index: number, content: string): string {
    const base = (content || '').toLowerCase().trim().replace(/[^a-z0-9]+/g, '_').replace(/^_+|_+$/g, '')
    const trimmed = base.length >= 3 ? base.slice(0, 24) : ''
    return trimmed || `var_${index + 1}`
  }

  function updateLineKind(lineIndex: number, nextKind: LineKind) {
    if (lineIndex < 0 || lineIndex >= lines.length) return
    const { content, varKey } = parseLine(lines[lineIndex])
    if (nextKind === 'variable') {
      const key = varKey && varKey.trim().length > 0 ? varKey : suggestVarKey(lineIndex, content)
      updateLineByIndex(lineIndex, buildLine('variable', content, key))
      return
    }
    updateLineByIndex(lineIndex, buildLine(nextKind, content, varKey))
  }

  function updateVarKey(lineIndex: number, nextKey: string) {
    if (lineIndex < 0 || lineIndex >= lines.length) return
    const { content } = parseLine(lines[lineIndex])
    const realKind: LineKind = 'variable'
    updateLineByIndex(lineIndex, buildLine(realKind, content, nextKey))
  }

  function updateContent(lineIndex: number, nextContent: string) {
    if (lineIndex < 0 || lineIndex >= lines.length) return
    const { kind, varKey } = parseLine(lines[lineIndex])
    updateLineByIndex(lineIndex, buildLine(kind, nextContent, varKey))
  }

  const updateFrontmatterQuestion = (entryKey: string, question: string) => {
    const linesFM = (yamlFrontmatter || '').split('\n')
    const idx = linesFM.findIndex(l => new RegExp(`^${escapeRegExp(entryKey)}\\s*:`).test(l.trim()))
    if (idx >= 0) {
      const line = linesFM[idx]
      const m = /\{\{([^}|]+)\|([^}]+)\}\}/.exec(line)
      if (m) {
        linesFM[idx] = line.replace(m[0], `{{${m[1]}|${question}}}`)
      }
      onChange({ markdownBody, yamlFrontmatter: linesFM.join('\n'), systemPrompt: sysPrompt })
    }
  }

  function handleDragStart(e: React.DragEvent, fromIndex: number) {
    dragFrom.current = fromIndex
    e.dataTransfer.setData('text/plain', String(fromIndex))
    e.dataTransfer.effectAllowed = 'move'
  }
  function handleDragOver(e: React.DragEvent) {
    e.preventDefault()
    e.dataTransfer.dropEffect = 'move'
  }
  function handleDrop(e: React.DragEvent, toIndex: number) {
    e.preventDefault()
    const fromStr = e.dataTransfer.getData('text/plain')
    const fromIndex = Number.isInteger(Number(fromStr)) ? parseInt(fromStr, 10) : dragFrom.current
    if (fromIndex === null || isNaN(fromIndex) || fromIndex === toIndex) return
    const arr = lines.slice()
    const [moved] = arr.splice(fromIndex, 1)
    arr.splice(toIndex, 0, moved)
    onChange({ markdownBody: arr.join('\n'), yamlFrontmatter, systemPrompt: sysPrompt })
    dragFrom.current = null
  }

  function addLineAfter(index: number) {
    const arr = lines.slice()
    arr.splice(index + 1, 0, '')
    onChange({ markdownBody: arr.join('\n'), yamlFrontmatter, systemPrompt: sysPrompt })
  }

  const handleSysPromptChange = (v: string) => {
    setSysPrompt(v)
    onChange({ markdownBody, yamlFrontmatter, systemPrompt: v })
  }

  return (
    <div className="space-y-3">
      <Tabs value={tab} onValueChange={(v) => setTab(v as typeof tab)}>
        <TabsList className="grid grid-cols-3 w-full">
          <TabsTrigger value="body">Body</TabsTrigger>
          <TabsTrigger value="frontmatter">Frontmatter</TabsTrigger>
          <TabsTrigger value="system">System</TabsTrigger>
        </TabsList>

        <TabsContent value="body">
          <div className="overflow-auto">
            <Table className="text-[11px] w-full border-collapse">
              <TableHeader>
                <TableRow className="[&>*]:py-1">
                  <TableHead className="w-8" />
                  <TableHead className="w-36">Typ/Variable</TableHead>
                  <TableHead>Text / Frage</TableHead>
                </TableRow>
              </TableHeader>
              <TableBody>
                {lines.length === 0 ? (
                  <TableRow><TableCell colSpan={3} className="text-muted-foreground">Keine Zeilen im Body.</TableCell></TableRow>
                ) : lines.map((line, i) => {
                  const { kind, varKey, content } = parseLine(line)
                  return (
                    <TableRow key={`line-${i}`} className="align-top" onDragOver={handleDragOver} onDrop={(e) => handleDrop(e, i)}>
                      <TableCell className="align-top w-8 py-1">
                        <div className="flex items-center gap-1">
                          <span
                            draggable
                            onDragStart={(e) => handleDragStart(e, i)}
                            className="inline-flex h-4 w-4 items-center justify-center text-muted-foreground cursor-grab hover:text-foreground"
                            title="Ziehen zum Verschieben"
                            aria-label="Ziehen zum Verschieben"
                          >
                            <GripVertical className="h-3 w-3" />
                          </span>
                          <button
                            type="button"
                            className="inline-flex h-4 w-4 items-center justify-center text-muted-foreground hover:text-foreground"
                            title="Zeile darunter einfügen"
                            aria-label="Zeile darunter einfügen"
                            onClick={() => addLineAfter(i)}
                          >
                            <Plus className="h-3 w-3" />
                          </button>
                        </div>
                      </TableCell>
                      <TableCell className="align-top w-36 py-1">
                        <div className="flex flex-col gap-1">
                          <Select value={kind} onValueChange={(v) => updateLineKind(i, v as LineKind)}>
                            <SelectTrigger className="h-7 text-[11px]">
                              <SelectValue placeholder="Text" />
                            </SelectTrigger>
                            <SelectContent>
                              <SelectItem value="text">Text</SelectItem>
                              <SelectItem value="h1">Heading 1</SelectItem>
                              <SelectItem value="h2">Heading 2</SelectItem>
                              <SelectItem value="h3">Heading 3</SelectItem>
                              <SelectItem value="bold">Bold</SelectItem>
                              <SelectItem value="variable">Variable</SelectItem>
                            </SelectContent>
                          </Select>
                          {kind === 'variable' ? (
                            <Input
                              value={varKey}
                              onChange={(e) => updateVarKey(i, e.target.value)}
                              placeholder="Variablenname"
                              className="h-7 text-[11px] font-mono"
                            />
                          ) : null}
                        </div>
                      </TableCell>
                      <TableCell className="align-top py-1">
                        <InlineEditableCell
                          value={content}
                          onChange={(val) => updateContent(i, val)}
                          placeholder={kind === 'variable' ? 'Frage/Beschreibung' : 'Markdown-Text'}
                        />
                      </TableCell>
                    </TableRow>
                  )
                })}
              </TableBody>
            </Table>
          </div>
        </TabsContent>

        <TabsContent value="frontmatter">
          <div className="max-h-[50vh] overflow-auto rounded border">
            <table className="w-full text-[11px] border-collapse">
              <thead className="sticky top-0 bg-background">
                <tr>
                  <th className="w-40 text-left px-2 py-1">Key</th>
                  <th className="w-40 text-left px-2 py-1">Variable</th>
                  <th className="text-left px-2 py-1">Frage/Beschreibung</th>
                </tr>
              </thead>
              <tbody>
                {fmEntries.length === 0 ? (
                  <tr><td colSpan={3} className="px-2 py-1 text-muted-foreground">Keine Felder im Frontmatter.</td></tr>
                ) : fmEntries.map((e, i) => {
                  const m = /\{\{([^}|]+)\|([^}]+)\}\}/.exec(e.rawValue)
                  const varKey = m ? m[1].trim() : ''
                  const varQ = m ? m[2].trim() : ''
                  return (
                    <tr key={`${e.key}-${i}`} className="align-top">
                      <td className="px-2 py-1 align-top font-mono">{e.key}</td>
                      <td className="px-2 py-1 align-top font-mono">{varKey}</td>
                      <td className="px-2 py-1 align-top">
                        <InlineEditableCell
                          value={varQ}
                          onChange={(val) => updateFrontmatterQuestion(e.key, val)}
                          placeholder="Klicken zum Bearbeiten"
                        />
                      </td>
                    </tr>
                  )
                })}
              </tbody>
            </table>
          </div>
        </TabsContent>

        <TabsContent value="system">
          <div className="space-y-1">
            <Label>System Prompt</Label>
            <Input value={sysPrompt} onChange={(e) => handleSysPromptChange(e.target.value)} className="font-mono h-8 text-xs" />
          </div>
        </TabsContent>
      </Tabs>
    </div>
  )
}

function escapeRegExp(s: string): string {
  return s.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')
}

function EditableTextarea({ value, onChange, onBlur, onKeyDown }: { value: string; onChange: (v: string) => void; onBlur?: () => void; onKeyDown?: (e: React.KeyboardEvent<HTMLTextAreaElement>) => void }) {
  const [local, setLocal] = React.useState(value)
  const ref = React.useRef<HTMLTextAreaElement | null>(null)

  const autosize = React.useCallback(() => {
    const el = ref.current
    if (!el) return
    el.style.height = 'auto'
    el.style.height = `${el.scrollHeight}px`
  }, [])

  React.useEffect(() => { setLocal(value); requestAnimationFrame(autosize) }, [value, autosize])

  return (
    <textarea
      ref={ref}
      value={local}
      onChange={(e) => { setLocal(e.target.value); onChange(e.target.value); autosize() }}
      onInput={autosize}
      onBlur={onBlur}
      onKeyDown={onKeyDown}
      className="w-full min-h-[2.5rem] rounded-md border bg-background px-2 py-1 text-[11px] leading-snug overflow-hidden"
      style={{ resize: 'none' }}
    />
  )
}

function InlineEditableCell({ value, onChange, placeholder }: { value: string; onChange: (v: string) => void; placeholder?: string }) {
  const [editing, setEditing] = React.useState(false)

  if (!editing) {
    return (
      <div
        role="button"
        onClick={() => setEditing(true)}
        className="cursor-text whitespace-pre-wrap break-words rounded-md px-2 py-1 min-h-[2.5rem]"
      >
        {value ? value : <span className="text-muted-foreground">{placeholder || 'Klicken zum Bearbeiten'}</span>}
      </div>
    )
  }

  return (
    <EditableTextarea
      value={value}
      onChange={onChange}
      onBlur={() => setEditing(false)}
      onKeyDown={(e) => { if (e.key === 'Escape') { e.preventDefault(); e.stopPropagation(); setEditing(false) } }}
    />
  )
}


```

- Fix implementiert: Beim Wechsel auf „Variable“ wird die Zeile sofort in einen Platzhalter umgewandelt, mit automatisch vorgeschlagenem Variablennamen (aus dem Text generiert, z. B. „zusammenfassung“ → „zusammenfassung“; fallback „var_3“).
- Danach ist das Variablenfeld sichtbar und direkt editierbar; die rechte Spalte bearbeitet die Frage/Beschreibung.

---

**User**

Möchte ich jetzt nicht mehr von Template im Frontend sprechen, sondern von Prompt und Prompt Design. Also Template bearbeiten heißt jetzt Prompt Design. Und oben im Hauptmenü statt Templates Prompts. Können wir das schauen, wo das jeweils verwendet wird, und dann sprechend umbenennen.

---

**Cursor**

Ich suche jetzt alle Stellen im Frontend, wo „Template(s)“ in UI-Texten oder Routen vorkommt, um die Labels auf „Prompt(s)“ und „Prompt Design“ umzustellen. Danach passe ich gezielt die betroffenen Dateien an.

Ich suche jetzt gezielt nach UI-Texten und Navigationslabels rund um „Template(s)“ und passe sie auf „Prompt(s)“/„Prompt Design“ an. Ich beginne mit den sichtbaren Labels in `template-management.tsx` und prüfe dann Navigation/Menü.

Ich suche und aktualisiere jetzt die UI-Texte in den relevanten Dateien, beginnend mit `src/app/templates/page.tsx` und `src/components/templates/template-management.tsx`, um „Template(s)“ zu „Prompt(s)“ bzw. „Prompt Design“ umzubenennen. Danach prüfe ich weitere Vorkommen in sichtbaren Komponenten.

```typescriptreact
import { Metadata } from "next"
import { TemplateManagement } from "@/components/templates/template-management"

export const metadata: Metadata = {
  title: "Prompts",
  description: "Verwaltung und Design von Prompts für den Secretary Service",
}

export default function TemplatesPage() {
  return (
    <div className="p-6">
      <TemplateManagement />
    </div>
  )
} 
```

```typescriptreact
"use client"

import { useState, useEffect, useCallback } from "react"
import { useForm } from "react-hook-form"
import { zodResolver } from "@hookform/resolvers/zod"
import * as z from "zod"
import { Button } from "@/components/ui/button"
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card"
import { Input } from "@/components/ui/input"
import { Label } from "@/components/ui/label"
import { Textarea } from "@/components/ui/textarea"
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs"
import { Badge } from "@/components/ui/badge"
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select"
import { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from "@/components/ui/tooltip"
import { Dialog, DialogContent, DialogHeader, DialogTitle, DialogFooter } from "@/components/ui/dialog"
import { StructuredTemplateEditor } from "@/components/templates/structured-template-editor"
import { useToast } from "@/hooks/use-toast"
import { Loader2, Save, Plus, Trash2, Eye, Play, FolderOpen, Info } from "lucide-react"
import { useAtom, useAtomValue } from "jotai"
import { activeLibraryAtom, libraryStatusAtom } from "@/atoms/library-atom"
import { 
  templatesAtom, 
  selectedTemplateNameAtom, 
  selectedTemplateAtom,
  templatesFolderIdAtom,
  templateLoadingAtom,
  templateErrorAtom,
  type Template
} from "@/atoms/template-atom"
import { useStorage } from "@/contexts/storage-context"

// Schema für Template-Daten
const templateSchema = z.object({
  name: z.string().min(1, "Prompt-Name ist erforderlich"),
  yamlFrontmatter: z.string(),
  markdownBody: z.string(),
  systemPrompt: z.string(),
})

type TemplateFormValues = z.infer<typeof templateSchema>

export function TemplateManagement() {
  const [previewMode, setPreviewMode] = useState(false)
  const [isSaving, setIsSaving] = useState(false)
  const [isTesting, setIsTesting] = useState(false)
  const [testResult, setTestResult] = useState<string | null>(null)
  const { toast } = useToast()

  // Atoms
  const [templates, setTemplates] = useAtom(templatesAtom)
  const [selectedTemplateName, setSelectedTemplateName] = useAtom(selectedTemplateNameAtom)
  const [selectedTemplate] = useAtom(selectedTemplateAtom)
  const [templatesFolderId, setTemplatesFolderId] = useAtom(templatesFolderIdAtom)
  const [isLoading, setIsLoading] = useAtom(templateLoadingAtom)
  const [error, setError] = useAtom(templateErrorAtom)

  // Library und Storage
  const activeLibrary = useAtomValue(activeLibraryAtom)
  const libraryStatus = useAtomValue(libraryStatusAtom)
  const { 
    provider: providerInstance, 
    listItems
  } = useStorage()

  const form = useForm<TemplateFormValues>({
    resolver: zodResolver(templateSchema),
    defaultValues: {
      name: "",
      yamlFrontmatter: `---
title: {{title|Titel des Dokuments}}
tags: {{tags|Relevante Tags}}
date: {{date|Datum im Format yyyy-mm-dd}}
---`,
      markdownBody: `# {{title}}

## Zusammenfassung
{{summary|Kurze Zusammenfassung des Inhalts}}

## Details
{{details|Detaillierte Beschreibung}}`,
      systemPrompt: `You are a specialized assistant that processes and structures information clearly and concisely.

IMPORTANT: Your response must be a valid JSON object where each key corresponds to a template variable.`,
    },
  })

  // Helper zum Erzeugen von Default-Werten
  function getDefaultTemplateValues(name: string): TemplateFormValues {
    return {
      name,
      yamlFrontmatter: `---\n` +
        `title: {{title|Titel des Dokuments}}\n` +
        `tags: {{tags|Relevante Tags}}\n` +
        `date: {{date|Datum im Format yyyy-mm-dd}}\n` +
        `---`,
      markdownBody: `# {{title}}\n\n## Zusammenfassung\n{{summary|Kurze Zusammenfassung des Inhalts}}\n\n## Details\n{{details|Detaillierte Beschreibung}}`,
      systemPrompt: `You are a specialized assistant that processes and structures information clearly and concisely.\n\nIMPORTANT: Your response must be a valid JSON object where each key corresponds to a template variable.`,
    }
  }

  // Template-Daten laden wenn sich die Auswahl ändert
  useEffect(() => {
    if (selectedTemplate) {
      form.reset({
        name: selectedTemplate.name,
        yamlFrontmatter: selectedTemplate.yamlFrontmatter,
        markdownBody: selectedTemplate.markdownBody,
        systemPrompt: selectedTemplate.systemPrompt,
      })
    }
  }, [selectedTemplate, form])

  // Ordner-Erstellung/Suche memoisiert, damit als Dep verwendbar
  const ensureTemplatesFolder = useCallback(async (): Promise<string> => {
    if (!providerInstance || !activeLibrary) {
      throw new Error("Keine aktive Bibliothek oder Provider verfügbar");
    }

    try {
      console.log('[TemplateManagement] Suche nach Templates-Ordner...');
      const rootItems = await listItems('root');
      const templatesFolder = rootItems.find(item => 
        item.type === 'folder' && item.metadata.name === 'templates'
      );
      if (templatesFolder) {
        console.log('[TemplateManagement] Templates-Ordner gefunden:', templatesFolder.id);
        return templatesFolder.id;
      }
      console.log('[TemplateManagement] Templates-Ordner nicht gefunden, erstelle neuen...');
      const newFolder = await providerInstance.createFolder('root', 'templates');
      console.log('[TemplateManagement] Neuer Templates-Ordner erstellt:', newFolder.id);
      return newFolder.id;
    } catch (error) {
      console.error('Fehler beim Erstellen des Templates-Ordners:', {
        error: error instanceof Error ? {
          message: error.message,
          name: error.name,
          stack: error.stack?.split('\n').slice(0, 3)
        } : error,
        libraryId: activeLibrary?.id,
        libraryPath: activeLibrary?.path,
        providerName: providerInstance?.name
      });
      let errorMessage = 'Fehler beim Erstellen des Templates-Ordners';
      if (error instanceof Error) {
        if (error.message.includes('Nicht authentifiziert')) {
          errorMessage = 'Bitte authentifizieren Sie sich bei Ihrem Cloud-Speicher, um den Templates-Ordner zu erstellen.';
        } else if (error.message.includes('Keine Berechtigung')) {
          errorMessage = 'Keine Berechtigung zum Erstellen von Ordnern in der Bibliothek.';
        } else if (error.message.includes('Bibliothek nicht gefunden')) {
          errorMessage = 'Die ausgewählte Bibliothek wurde nicht gefunden.';
        } else {
          errorMessage = `Fehler beim Erstellen des Templates-Ordners: ${error.message}`;
        }
      }
      throw new Error(errorMessage);
    }
  }, [providerInstance, activeLibrary, listItems]);

  // Templates laden mit der gleichen Logik wie Library-Komponente
  const loadTemplates = useCallback(async () => {
    if (!providerInstance || libraryStatus !== 'ready' || !activeLibrary) {
      console.log('[TemplateManagement] loadTemplates übersprungen:', {
        hasProvider: !!providerInstance,
        libraryStatus,
        hasActiveLibrary: !!activeLibrary
      });
      return;
    }

    try {
      setIsLoading(true);
      setError(null);

      console.log('[TemplateManagement] Starte Prompt-Loading:', {
        libraryId: activeLibrary.id,
        libraryPath: activeLibrary.path,
        providerName: providerInstance.name
      });

      // 1. Templates-Ordner finden oder erstellen
      const folderId = await ensureTemplatesFolder();
      setTemplatesFolderId(folderId);

      console.log('[TemplateManagement] Templates-Ordner gefunden/erstellt:', folderId);

      // 2. Alle Template-Dateien im Ordner auflisten
      const items = await listItems(folderId);
      const templateFiles = items.filter(item => 
        item.type === 'file' && 
        item.metadata.name.endsWith('.md')
      );

      console.log('[TemplateManagement] Prompt-Dateien gefunden:', templateFiles.length);

      // 3. Template-Inhalte laden
      const templatePromises = templateFiles.map(async (file) => {
        try {
          const { blob } = await providerInstance.getBinary(file.id);
          const content = await blob.text();
          const template = parseTemplateContent(content, file.metadata.name.replace('.md', ''));
          
          return {
            ...template,
            fileId: file.id,
            lastModified: typeof file.metadata.modifiedAt === 'string' 
              ? file.metadata.modifiedAt 
              : file.metadata.modifiedAt instanceof Date 
                ? file.metadata.modifiedAt.toISOString()
                : new Date().toISOString()
          } as Template;
        } catch (error) {
          console.error(`Fehler beim Parsen von ${file.metadata.name}:`, error);
          return null;
        }
      });

      const loadedTemplates = await Promise.all(templatePromises);
      const validTemplates = loadedTemplates.filter((t): t is Template => t !== null);
      
      setTemplates(validTemplates);
      
      console.log('[TemplateManagement] Prompts erfolgreich geladen:', validTemplates.length);
      
      if (validTemplates.length === 0) {
        toast({
          title: "Keine Prompts gefunden",
          description: "Erstellen Sie Ihren ersten Prompt im Verzeichnis '/templates'.",
        });
      }
    } catch (error) {
      console.error('Fehler beim Laden der Prompts:', {
        error: error instanceof Error ? {
          message: error.message,
          name: error.name,
          stack: error.stack?.split('\n').slice(0, 3)
        } : error,
        libraryId: activeLibrary?.id,
        libraryPath: activeLibrary?.path,
        providerName: providerInstance?.name
      });

      let errorMessage = 'Unbekannter Fehler beim Laden der Prompts';
      
      if (error instanceof Error) {
        errorMessage = error.message;
        
        // Spezifische Fehlermeldungen für häufige Probleme
        if (error.message.includes('Nicht authentifiziert')) {
          errorMessage = 'Bitte authentifizieren Sie sich bei Ihrem Cloud-Speicher, um Prompts zu laden.';
        } else if (error.message.includes('Bibliothek nicht gefunden')) {
          errorMessage = 'Die ausgewählte Bibliothek wurde nicht gefunden. Bitte überprüfen Sie die Bibliothekskonfiguration.';
        } else if (error.message.includes('Server-Fehler')) {
          errorMessage = 'Server-Fehler beim Laden der Prompts. Bitte überprüfen Sie, ob der Bibliothekspfad existiert und zugänglich ist.';
        } else if (error.message.includes('Keine aktive Bibliothek')) {
          errorMessage = 'Keine aktive Bibliothek verfügbar. Bitte wählen Sie eine Bibliothek aus.';
        }
      }
      
      setError(errorMessage);
      toast({
        title: "Fehler beim Laden der Prompts",
        description: errorMessage,
        variant: "destructive",
      });
    } finally {
      setIsLoading(false);
    }
  }, [providerInstance, libraryStatus, activeLibrary, listItems, setTemplates, setTemplatesFolderId, setIsLoading, setError, toast, ensureTemplatesFolder]);

  // Effect für Template Loading (wie Library-Komponente)
  useEffect(() => {
    const isReady = providerInstance && libraryStatus === 'ready' && activeLibrary
    
    if (!isReady) {
      return
    }

    // Templates laden wenn noch nicht geladen
    if (!templatesFolderId) {
      loadTemplates()
    }
  }, [providerInstance, libraryStatus, activeLibrary, templatesFolderId, loadTemplates])

  // Reset wenn sich die Library ändert
  useEffect(() => {
    setSelectedTemplateName(null)
    setTemplatesFolderId(null)
    setTemplates([])
    setError(null)
  }, [libraryStatus, setSelectedTemplateName, setTemplatesFolderId, setTemplates, setError])

  function parseTemplateContent(content: string, fileName: string): Template {
    // Template in drei Bereiche aufteilen
    const parts = content.split('--- systemprompt')
    
    let yamlFrontmatter = ""
    let markdownBody = ""
    let systemPrompt = ""
    
    if (parts.length >= 2) {
      const mainContent = parts[0].trim()
      systemPrompt = parts[1].trim()
      
      // YAML Frontmatter extrahieren
      const yamlMatch = mainContent.match(/^---\n([\s\S]*?)\n---\n([\s\S]*)$/)
      if (yamlMatch) {
        yamlFrontmatter = `---\n${yamlMatch[1]}\n---`
        markdownBody = yamlMatch[2].trim()
      } else {
        // Kein YAML Frontmatter gefunden
        markdownBody = mainContent
      }
    } else {
      // Kein Systemprompt gefunden
      const yamlMatch = content.match(/^---\n([\s\S]*?)\n---\n([\s\S]*)$/)
      if (yamlMatch) {
        yamlFrontmatter = `---\n${yamlMatch[1]}\n---`
        markdownBody = yamlMatch[2].trim()
      } else {
        markdownBody = content
      }
    }

    return {
      name: fileName,
      yamlFrontmatter,
      markdownBody,
      systemPrompt,
    }
  }

  function generateTemplateContent(values: TemplateFormValues): string {
    let content = ""
    
    // YAML Frontmatter hinzufügen
    if (values.yamlFrontmatter.trim()) {
      content += values.yamlFrontmatter + "\n\n"
    }
    
    // Markdown Body hinzufügen
    content += values.markdownBody
    
    // System Prompt hinzufügen
    if (values.systemPrompt.trim()) {
      content += "\n\n--- systemprompt\n" + values.systemPrompt
    }
    
    return content
  }

  async function onSubmit(data: TemplateFormValues) {
    if (!activeLibrary || !templatesFolderId || !providerInstance) {
      toast({
        title: "Fehler",
        description: "Keine aktive Bibliothek oder Templates-Ordner nicht gefunden.",
        variant: "destructive",
      })
      return
    }

    setIsSaving(true)
    try {
      const templateContent = generateTemplateContent(data)
      const fileName = `${data.name}.md`
      
      // Datei als Blob erstellen
      const blob = new Blob([templateContent], { type: 'text/markdown' })
      const file = new File([blob], fileName, { type: 'text/markdown' })
      
      // Datei hochladen
      await providerInstance.uploadFile(templatesFolderId, file)
      
      // Templates neu laden
      await loadTemplates()
      
      // Auswahl auf das neue Template setzen
      setSelectedTemplateName(data.name)
      
      toast({
        title: "Template gespeichert",
        description: `Template "${data.name}" wurde erfolgreich im Verzeichnis "/templates" gespeichert.`,
      })
    } catch (error) {
      console.error('Fehler beim Speichern des Templates:', error)
      toast({
        title: "Fehler beim Speichern",
        description: error instanceof Error ? error.message : "Unbekannter Fehler",
        variant: "destructive",
      })
    } finally {
      setIsSaving(false)
    }
  }

  async function renameCurrentTemplate() {
    const current = selectedTemplateName ? templates.find(t => t.name === selectedTemplateName) : null
    if (!current || !current.fileId || !providerInstance) return
    const newName = (window.prompt('Neuen Namen eingeben:', current.name) || '').trim()
    if (!newName || newName === current.name) return
    if (/[^a-zA-Z0-9._\- ]/.test(newName)) { toast({ title: 'Ungültiger Name', description: 'Nur Buchstaben, Zahlen, Leerzeichen, . _ - sind erlaubt.', variant: 'destructive' }); return }
    if (templates.some(t => t.name.toLowerCase() === newName.toLowerCase())) { toast({ title: 'Bereits vorhanden', description: 'Bitte anderen Namen wählen.', variant: 'destructive' }); return }
    try {
      await providerInstance.renameItem(current.fileId, `${newName}.md`)
      await loadTemplates()
      setSelectedTemplateName(newName)
      form.setValue('name', newName, { shouldDirty: false })
      toast({ title: 'Umbenannt', description: `${current.name} → ${newName}` })
    } catch (e) {
      toast({ title: 'Fehler beim Umbenennen', description: e instanceof Error ? e.message : 'Unbekannter Fehler', variant: 'destructive' })
    }
  }

  async function deleteTemplate(templateName: string) {
    if (!activeLibrary || !providerInstance) return

    try {
      const template = templates.find(t => t.name === templateName)
      if (!template?.fileId) {
        throw new Error("Template-Datei nicht gefunden")
      }

      // Datei löschen
      await providerInstance.deleteItem(template.fileId)

      // Templates neu laden
      await loadTemplates()
      
      if (selectedTemplateName === templateName) {
        setSelectedTemplateName(null)
        form.reset()
      }
      
      toast({
        title: "Template gelöscht",
        description: `Template "${templateName}" wurde erfolgreich gelöscht.`,
      })
    } catch (error) {
      console.error('Fehler beim Löschen des Templates:', error)
      toast({
        title: "Fehler beim Löschen",
        description: error instanceof Error ? error.message : "Unbekannter Fehler",
        variant: "destructive",
      })
    }
  }

  async function createNewTemplate() {
    const name = (window.prompt('Neuen Template‑Namen eingeben:') || '').trim()
    if (!name) return
    if (/[^a-zA-Z0-9._\- ]/.test(name)) { toast({ title: 'Ungültiger Name', description: 'Nur Buchstaben, Zahlen, Leerzeichen, . _ - sind erlaubt.', variant: 'destructive' }); return }
    if (templates.some(t => t.name.toLowerCase() === name.toLowerCase())) { toast({ title: 'Bereits vorhanden', description: 'Bitte anderen Namen wählen.', variant: 'destructive' }); return }
    if (!providerInstance) { toast({ title: 'Kein Provider' , variant: 'destructive' }); return }
    try {
      const folderId = await ensureTemplatesFolder()
      const values = getDefaultTemplateValues(name)
      const content = (values.yamlFrontmatter ? values.yamlFrontmatter + '\n\n' : '') + values.markdownBody + '\n\n--- systemprompt\n' + values.systemPrompt
      const file = new File([new Blob([content], { type: 'text/markdown' })], `${name}.md`, { type: 'text/markdown' })
      await providerInstance.uploadFile(folderId, file)
      await loadTemplates()
      setSelectedTemplateName(name)
      form.reset(values)
      toast({ title: 'Template angelegt', description: `"${name}" wurde erstellt.` })
    } catch (e) {
      toast({ title: 'Fehler beim Anlegen', description: e instanceof Error ? e.message : 'Unbekannter Fehler', variant: 'destructive' })
    }
  }

  function generatePreview(): string {
    const values = form.getValues()
    return generateTemplateContent(values)
  }

  async function testTemplate() {
    if (!activeLibrary) return

    setIsTesting(true)
    setTestResult(null)

    const values = form.getValues()
    const templateContent = generateTemplateContent(values)
    
    // Testtext aus dem Textarea lesen
    const testTextarea = document.querySelector('textarea[placeholder="Geben Sie einen Testtext ein..."]') as HTMLTextAreaElement
    const testText = testTextarea?.value || "Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed eiusmod tempor incidunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquid ex ea commodi consequat. Quis aute iure reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint obcaecat cupiditat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum."
    
    try {
      const response = await fetch('/api/secretary/process-text', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/x-www-form-urlencoded',
          'X-Library-Id': activeLibrary.id,
        },
        body: new URLSearchParams({
          text: testText,
          template_content: templateContent,
          source_language: 'de',
          target_language: 'de',
        }),
      })

      if (!response.ok) {
        const errorData = await response.json()
        throw new Error(errorData.error || `HTTP ${response.status}: ${response.statusText}`)
      }

      const result = await response.json()
      
      // Ergebnis formatieren und anzeigen
      const formattedResult = JSON.stringify(result, null, 2)
      setTestResult(formattedResult)
      
      toast({
        title: "Template-Test erfolgreich",
        description: "Das Template wurde erfolgreich mit dem Testtext verarbeitet.",
      })
      
      console.log('Template-Test Ergebnis:', result)
    } catch (error) {
      console.error('Fehler beim Template-Test:', error)
      const errorMessage = error instanceof Error ? error.message : "Unbekannter Fehler"
      setTestResult(`Fehler: ${errorMessage}`)
      toast({
        title: "Template-Test fehlgeschlagen",
        description: errorMessage,
        variant: "destructive",
      })
    } finally {
      setIsTesting(false)
    }
  }

  // Render-Logik für verschiedene Status
  if (libraryStatus === "waitingForAuth") {
    return (
      <div className="flex flex-col items-center justify-center h-full text-muted-foreground">
        <span>Diese Bibliothek benötigt eine Authentifizierung.</span>
        <span className="text-sm mt-2">Bitte konfigurieren Sie die Bibliothek in den Einstellungen.</span>
      </div>
    )
  }
  
  if (libraryStatus !== "ready") {
    return (
      <div className="flex flex-col items-center justify-center h-full text-muted-foreground">
        <span>Lade Storage...</span>
      </div>
    )
  }

  if (!activeLibrary) {
    return (
      <div className="text-center text-muted-foreground">
        Bitte wählen Sie eine Bibliothek aus.
      </div>
    )
  }

  if (error) {
    return (
      <div className="text-center text-destructive">
        <p>Fehler beim Laden der Prompts:</p>
        <p className="text-sm">{error}</p>
        <Button 
          variant="outline" 
          className="mt-4"
          onClick={loadTemplates}
        >
          Erneut versuchen
        </Button>
      </div>
    )
  }

  return (
    <div className="space-y-6">

      {/* Kompakte Toolbar oben */}
      <div className="flex items-center gap-2">
        <Select value={selectedTemplateName || ''} onValueChange={(v) => { setSelectedTemplateName(v); form.setValue('name', v, { shouldDirty: false }) }} disabled={isLoading}>
          <SelectTrigger className="w-64">
            <SelectValue placeholder="Prompt auswählen..." />
          </SelectTrigger>
          <SelectContent>
            {templates.map((t) => (
              <SelectItem key={t.name} value={t.name}>{t.name}</SelectItem>
            ))}
          </SelectContent>
        </Select>
        <TooltipProvider>
          <Tooltip>
            <TooltipTrigger asChild>
              <Button variant="ghost" size="sm" className="h-8 w-8 p-0"><Info className="h-4 w-4" /></Button>
            </TooltipTrigger>
            <TooltipContent>
              <div className="flex items-center gap-2"><FolderOpen className="h-4 w-4" /><span>Ort: /templates in „{activeLibrary.label}“</span></div>
            </TooltipContent>
          </Tooltip>
        </TooltipProvider>
        <Button type="button" variant="outline" size="sm" onClick={createNewTemplate} disabled={isLoading}>Neu</Button>
        <Button type="button" variant="outline" size="sm" onClick={renameCurrentTemplate} disabled={!selectedTemplateName}>Umbenennen</Button>
        {selectedTemplateName && (
          <Button type="button" variant="destructive" size="sm" onClick={() => deleteTemplate(selectedTemplateName!)}>Löschen</Button>
        )}
      </div>

      <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
        <Card>
          <CardHeader>
            <CardTitle>Prompt Design</CardTitle>
            <CardDescription>
              Bearbeiten Sie die drei Hauptbereiche des Prompts: Markdown Body, YAML Frontmatter und System Prompt.
            </CardDescription>
          </CardHeader>
          <CardContent>
            <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-6">
              {/* Template-Name Feld entfernt (oben verwaltet) */}

              {previewMode ? (
                <div className="space-y-4">
                  <div className="flex items-center justify-between">
                    <h4 className="text-sm font-medium">Prompt-Vorschau</h4>
                    <Button
                      type="button"
                      variant="outline"
                      size="sm"
                      onClick={() => setPreviewMode(false)}
                    >
                      Bearbeiten
                    </Button>
                  </div>
                  <div className="border rounded-md p-4 bg-muted/50">
                    <pre className="text-sm whitespace-pre-wrap font-mono">
                      {generatePreview()}
                    </pre>
                  </div>
                </div>
              ) : (
                <StructuredTemplateEditor
                  markdownBody={form.watch('markdownBody')}
                  yamlFrontmatter={form.watch('yamlFrontmatter')}
                  systemPrompt={form.watch('systemPrompt')}
                  onChange={({ markdownBody, yamlFrontmatter, systemPrompt }) => {
                    form.setValue('markdownBody', markdownBody, { shouldDirty: true })
                    form.setValue('yamlFrontmatter', yamlFrontmatter, { shouldDirty: true })
                    form.setValue('systemPrompt', systemPrompt, { shouldDirty: true })
                  }}
                />
              )}

              <div className="flex justify-end gap-2">
                <Button
                  type="button"
                  variant="outline"
                  onClick={() => setPreviewMode(!previewMode)}
                >
                  <Eye className="h-4 w-4 mr-2" />
                  {previewMode ? "Bearbeiten" : "Vorschau"}
                </Button>
                <Button
                  type="submit"
                  disabled={isSaving || !form.formState.isDirty}
                >
                  {isSaving ? (
                    <>
                      <Loader2 className="h-4 w-4 mr-2 animate-spin" />
                      Wird gespeichert...
                    </>
                  ) : (
                    <>
                      <Save className="h-4 w-4 mr-2" />
                      Speichern
                    </>
                  )}
                </Button>
              </div>
            </form>
          </CardContent>
        </Card>

        <Card>
          <CardHeader>
            <CardTitle>Prompt testen</CardTitle>
            <CardDescription>
              Testen Sie den ausgewählten Prompt mit einem Beispieltext über den Secretary Service.
            </CardDescription>
          </CardHeader>
          <CardContent>
            <div className="space-y-4">
              <div className="space-y-2">
                <Label>Test-Text</Label>
                <Textarea
                  placeholder="Geben Sie einen Testtext ein..."
                  className="min-h-[100px]"
                  defaultValue="Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed eiusmod tempor incidunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquid ex ea commodi consequat. Quis aute iure reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint obcaecat cupiditat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum."
                />
              </div>
              <div className="flex gap-2">
                <Button 
                  variant="outline" 
                  size="sm"
                  onClick={testTemplate}
                  disabled={!selectedTemplateName || isTesting}
                >
                  {isTesting ? (
                    <>
                      <Loader2 className="h-4 w-4 mr-2 animate-spin" />
                      Teste...
                    </>
                  ) : (
                    <>
                      <Play className="h-4 w-4 mr-2" />
                      Prompt testen
                    </>
                  )}
                </Button>
              </div>
              
              {testResult && (
                <div className="space-y-2">
                  <Label>Test-Ergebnis</Label>
                  <div className="border rounded-md p-4 bg-muted/50">
                    <pre className="text-sm whitespace-pre-wrap font-mono max-h-[300px] overflow-y-auto">
                      {testResult}
                    </pre>
                  </div>
                </div>
              )}
            </div>
          </CardContent>
        </Card>
      </div>
    </div>
  )
} 
```

- Sichtbare Texte aktualisiert:
  - `app/templates/page.tsx`: Titel „Prompts“, Beschreibung „Verwaltung und Design von Prompts …“.
  - `template-management.tsx`: UI-Labels zu „Prompt“/„Prompt Design“ geändert (Auswahl, Hinweise, Vorschau, Testen, Fehlermeldungen).

- Technischer Hinweis:
  - Speicherordner und Dateistruktur bleiben „/templates“ für Abwärtskompatibilität.
  - Code- und Atom-Namen unverändert; nur UI-Texte angepasst.

---

**User**

Ja diese Begriffe sind sehr Technisch.  Markdown Body, YAML Frontmatter und System Prompt.
Ich möchte es einem Laien erklären und auch so benennen. Wie könnten wir das UI anpassen?
Hier ein hinweis. 
Kurz und laienfreundlich:

| Technischer Begriff         | Verständlicher UI-Name                      | Kurzdefinition                                                          | Beispiel                                                          |
| --------------------------- | ------------------------------------------- | ----------------------------------------------------------------------- | ----------------------------------------------------------------- |
| **System Prompt**           | **Rollenanweisung** (oder: **Grundregeln**) | Legt fest, *wie* die KI arbeiten soll: Ton, Rolle, Sprache, Do/Don’t.   | „Du bist Projektberater. Antworte knapp, auf Deutsch, als Liste.“ |
| **(User) Request / Prompt** | **Aufgabe** (oder: **Frage an die KI**)     | Beschreibt, *was* erledigt werden soll – die eigentliche Anfrage.       | „Erstelle 5 Meilensteine für WP1 und ordne Kalenderwochen zu.“    |
| **Structured Output**       | **Ausgabeformat** (oder: **Antwortschema**) | Gibt vor, *in welcher Form* die Antwort zurückkommen soll (z. B. JSON). | „Gib ein JSON mit {milestone, kw, begründung} zurück.“            |

**Empfehlung für deine UI:**

* Hauptmenü: **Prompts**
* Editor/Seite: **Prompt Design** (enthält drei Bereiche: Rollenanweisung · Aufgabe · Ausgabeformat)
* Vermeide „Request“ im Frontend—sag lieber **Aufgabe** oder **Frage**.

**Merksatz:**
**Rollenanweisung** (wie) + **Aufgabe** (was) + **Ausgabeformat** (in welcher Form).





---

**Cursor**

```typescriptreact
"use client";

import * as React from 'react'
import { parseFrontmatterKeyValues } from '@/lib/markdown/frontmatter'
import { Input } from '@/components/ui/input'
import { Label } from '@/components/ui/label'
import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from '@/components/ui/table'
import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs'
import { GripVertical, Plus } from 'lucide-react'
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select'

export interface StructuredTemplateEditorProps {
  markdownBody: string
  yamlFrontmatter: string
  systemPrompt: string
  onChange: (next: { markdownBody: string; yamlFrontmatter: string; systemPrompt: string }) => void
}

type LineKind = 'text' | 'h1' | 'h2' | 'h3' | 'bold' | 'variable'

export function StructuredTemplateEditor({ markdownBody, yamlFrontmatter, systemPrompt, onChange }: StructuredTemplateEditorProps) {
  const lines = React.useMemo(() => (typeof markdownBody === 'string' ? markdownBody.split('\n') : []), [markdownBody])
  const fmEntries = React.useMemo(() => parseFrontmatterKeyValues(yamlFrontmatter || ''), [yamlFrontmatter])
  const [sysPrompt, setSysPrompt] = React.useState(systemPrompt)
  const [tab, setTab] = React.useState<'body'|'frontmatter'|'system'>('body')
  const dragFrom = React.useRef<number | null>(null)

  React.useEffect(() => { setSysPrompt(systemPrompt) }, [systemPrompt])

  function parseLine(line: string): { kind: LineKind; varKey: string; content: string } {
    const mVar = /^\s*\{\{([^}|]+)\|([^}]+)\}\}\s*$/.exec(line)
    if (mVar) return { kind: 'variable', varKey: (mVar[1] || '').trim(), content: (mVar[2] || '').trim() }
    if (/^\s*###\s+/.test(line)) return { kind: 'h3', varKey: '', content: line.replace(/^\s*###\s+/, '') }
    if (/^\s*##\s+/.test(line)) return { kind: 'h2', varKey: '', content: line.replace(/^\s*##\s+/, '') }
    if (/^\s*#\s+/.test(line)) return { kind: 'h1', varKey: '', content: line.replace(/^\s*#\s+/, '') }
    const mBold = /^\s*\*\*([\s\S]*?)\*\*\s*$/.exec(line)
    if (mBold) return { kind: 'bold', varKey: '', content: (mBold[1] || '') }
    return { kind: 'text', varKey: '', content: line }
  }

  function buildLine(kind: LineKind, content: string, varKey?: string): string {
    const text = content ?? ''
    switch (kind) {
      case 'variable': {
        const k = (varKey || '').trim()
        return k ? `{{${k}|${text}}}` : text
      }
      case 'h1': return `# ${text}`
      case 'h2': return `## ${text}`
      case 'h3': return `### ${text}`
      case 'bold': return `**${text}**`
      case 'text': default: return text
    }
  }

  function updateLineByIndex(lineIndex: number, nextLine: string) {
    const copy = lines.slice()
    if (lineIndex >= 0 && lineIndex < copy.length) copy[lineIndex] = nextLine
    onChange({ markdownBody: copy.join('\n'), yamlFrontmatter, systemPrompt: sysPrompt })
  }

  function suggestVarKey(index: number, content: string): string {
    const base = (content || '').toLowerCase().trim().replace(/[^a-z0-9]+/g, '_').replace(/^_+|_+$/g, '')
    const trimmed = base.length >= 3 ? base.slice(0, 24) : ''
    return trimmed || `var_${index + 1}`
  }

  function updateLineKind(lineIndex: number, nextKind: LineKind) {
    if (lineIndex < 0 || lineIndex >= lines.length) return
    const { content, varKey } = parseLine(lines[lineIndex])
    if (nextKind === 'variable') {
      const key = varKey && varKey.trim().length > 0 ? varKey : suggestVarKey(lineIndex, content)
      updateLineByIndex(lineIndex, buildLine('variable', content, key))
      return
    }
    updateLineByIndex(lineIndex, buildLine(nextKind, content, varKey))
  }

  function updateVarKey(lineIndex: number, nextKey: string) {
    if (lineIndex < 0 || lineIndex >= lines.length) return
    const { content } = parseLine(lines[lineIndex])
    const realKind: LineKind = 'variable'
    updateLineByIndex(lineIndex, buildLine(realKind, content, nextKey))
  }

  function updateContent(lineIndex: number, nextContent: string) {
    if (lineIndex < 0 || lineIndex >= lines.length) return
    const { kind, varKey } = parseLine(lines[lineIndex])
    updateLineByIndex(lineIndex, buildLine(kind, nextContent, varKey))
  }

  const updateFrontmatterQuestion = (entryKey: string, question: string) => {
    const linesFM = (yamlFrontmatter || '').split('\n')
    const idx = linesFM.findIndex(l => new RegExp(`^${escapeRegExp(entryKey)}\\s*:`).test(l.trim()))
    if (idx >= 0) {
      const line = linesFM[idx]
      const m = /\{\{([^}|]+)\|([^}]+)\}\}/.exec(line)
      if (m) {
        linesFM[idx] = line.replace(m[0], `{{${m[1]}|${question}}}`)
      }
      onChange({ markdownBody, yamlFrontmatter: linesFM.join('\n'), systemPrompt: sysPrompt })
    }
  }

  function handleDragStart(e: React.DragEvent, fromIndex: number) {
    dragFrom.current = fromIndex
    e.dataTransfer.setData('text/plain', String(fromIndex))
    e.dataTransfer.effectAllowed = 'move'
  }
  function handleDragOver(e: React.DragEvent) {
    e.preventDefault()
    e.dataTransfer.dropEffect = 'move'
  }
  function handleDrop(e: React.DragEvent, toIndex: number) {
    e.preventDefault()
    const fromStr = e.dataTransfer.getData('text/plain')
    const fromIndex = Number.isInteger(Number(fromStr)) ? parseInt(fromStr, 10) : dragFrom.current
    if (fromIndex === null || isNaN(fromIndex) || fromIndex === toIndex) return
    const arr = lines.slice()
    const [moved] = arr.splice(fromIndex, 1)
    arr.splice(toIndex, 0, moved)
    onChange({ markdownBody: arr.join('\n'), yamlFrontmatter, systemPrompt: sysPrompt })
    dragFrom.current = null
  }

  function addLineAfter(index: number) {
    const arr = lines.slice()
    arr.splice(index + 1, 0, '')
    onChange({ markdownBody: arr.join('\n'), yamlFrontmatter, systemPrompt: sysPrompt })
  }

  const handleSysPromptChange = (v: string) => {
    setSysPrompt(v)
    onChange({ markdownBody, yamlFrontmatter, systemPrompt: v })
  }

  return (
    <div className="space-y-3">
      <Tabs value={tab} onValueChange={(v) => setTab(v as typeof tab)}>
        <TabsList className="grid grid-cols-3 w-full">
          <TabsTrigger value="body">Aufgabe</TabsTrigger>
          <TabsTrigger value="frontmatter">Ausgabeformat</TabsTrigger>
          <TabsTrigger value="system">Rollenanweisung</TabsTrigger>
        </TabsList>

        <TabsContent value="body">
          <div className="overflow-auto">
            <Table className="text-[11px] w-full border-collapse">
              <TableHeader>
                <TableRow className="[&>*]:py-1">
                  <TableHead className="w-8" />
                  <TableHead className="w-36">Typ/Variable</TableHead>
                  <TableHead>Text / Frage</TableHead>
                </TableRow>
              </TableHeader>
              <TableBody>
                {lines.length === 0 ? (
                  <TableRow><TableCell colSpan={3} className="text-muted-foreground">Keine Zeilen im Body.</TableCell></TableRow>
                ) : lines.map((line, i) => {
                  const { kind, varKey, content } = parseLine(line)
                  return (
                    <TableRow key={`line-${i}`} className="align-top" onDragOver={handleDragOver} onDrop={(e) => handleDrop(e, i)}>
                      <TableCell className="align-top w-8 py-1">
                        <div className="flex items-center gap-1">
                          <span
                            draggable
                            onDragStart={(e) => handleDragStart(e, i)}
                            className="inline-flex h-4 w-4 items-center justify-center text-muted-foreground cursor-grab hover:text-foreground"
                            title="Ziehen zum Verschieben"
                            aria-label="Ziehen zum Verschieben"
                          >
                            <GripVertical className="h-3 w-3" />
                          </span>
                          <button
                            type="button"
                            className="inline-flex h-4 w-4 items-center justify-center text-muted-foreground hover:text-foreground"
                            title="Zeile darunter einfügen"
                            aria-label="Zeile darunter einfügen"
                            onClick={() => addLineAfter(i)}
                          >
                            <Plus className="h-3 w-3" />
                          </button>
                        </div>
                      </TableCell>
                      <TableCell className="align-top w-36 py-1">
                        <div className="flex flex-col gap-1">
                          <Select value={kind} onValueChange={(v) => updateLineKind(i, v as LineKind)}>
                            <SelectTrigger className="h-7 text-[11px]">
                              <SelectValue placeholder="Text" />
                            </SelectTrigger>
                            <SelectContent>
                              <SelectItem value="text">Text</SelectItem>
                              <SelectItem value="h1">Heading 1</SelectItem>
                              <SelectItem value="h2">Heading 2</SelectItem>
                              <SelectItem value="h3">Heading 3</SelectItem>
                              <SelectItem value="bold">Bold</SelectItem>
                              <SelectItem value="variable">Variable</SelectItem>
                            </SelectContent>
                          </Select>
                          {kind === 'variable' ? (
                            <Input
                              value={varKey}
                              onChange={(e) => updateVarKey(i, e.target.value)}
                              placeholder="Variablenname"
                              className="h-7 text-[11px] font-mono"
                            />
                          ) : null}
                        </div>
                      </TableCell>
                      <TableCell className="align-top py-1">
                        <InlineEditableCell
                          value={content}
                          onChange={(val) => updateContent(i, val)}
                          placeholder={kind === 'variable' ? 'Frage/Beschreibung' : 'Markdown-Text'}
                        />
                      </TableCell>
                    </TableRow>
                  )
                })}
              </TableBody>
            </Table>
          </div>
        </TabsContent>

        <TabsContent value="frontmatter">
          <div className="max-h-[50vh] overflow-auto rounded border">
            <table className="w-full text-[11px] border-collapse">
              <thead className="sticky top-0 bg-background">
                <tr>
                  <th className="w-40 text-left px-2 py-1">Feld</th>
                  <th className="w-40 text-left px-2 py-1">Variable</th>
                  <th className="text-left px-2 py-1">Hinweis</th>
                </tr>
              </thead>
              <tbody>
                {fmEntries.length === 0 ? (
                  <tr><td colSpan={3} className="px-2 py-1 text-muted-foreground">Keine Felder im Frontmatter.</td></tr>
                ) : fmEntries.map((e, i) => {
                  const m = /\{\{([^}|]+)\|([^}]+)\}\}/.exec(e.rawValue)
                  const varKey = m ? m[1].trim() : ''
                  const varQ = m ? m[2].trim() : ''
                  return (
                    <tr key={`${e.key}-${i}`} className="align-top">
                      <td className="px-2 py-1 align-top font-mono">{e.key}</td>
                      <td className="px-2 py-1 align-top font-mono">{varKey}</td>
                      <td className="px-2 py-1 align-top">
                        <InlineEditableCell
                          value={varQ}
                          onChange={(val) => updateFrontmatterQuestion(e.key, val)}
                          placeholder="Klicken zum Bearbeiten"
                        />
                      </td>
                    </tr>
                  )
                })}
              </tbody>
            </table>
          </div>
        </TabsContent>

        <TabsContent value="system">
          <div className="space-y-1">
            <Label>Rollenanweisung</Label>
            <Input value={sysPrompt} onChange={(e) => handleSysPromptChange(e.target.value)} className="font-mono h-8 text-xs" />
          </div>
        </TabsContent>
      </Tabs>
    </div>
  )
}

function escapeRegExp(s: string): string {
  return s.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')
}

function EditableTextarea({ value, onChange, onBlur, onKeyDown }: { value: string; onChange: (v: string) => void; onBlur?: () => void; onKeyDown?: (e: React.KeyboardEvent<HTMLTextAreaElement>) => void }) {
  const [local, setLocal] = React.useState(value)
  const ref = React.useRef<HTMLTextAreaElement | null>(null)

  const autosize = React.useCallback(() => {
    const el = ref.current
    if (!el) return
    el.style.height = 'auto'
    el.style.height = `${el.scrollHeight}px`
  }, [])

  React.useEffect(() => { setLocal(value); requestAnimationFrame(autosize) }, [value, autosize])

  return (
    <textarea
      ref={ref}
      value={local}
      onChange={(e) => { setLocal(e.target.value); onChange(e.target.value); autosize() }}
      onInput={autosize}
      onBlur={onBlur}
      onKeyDown={onKeyDown}
      className="w-full min-h-[2.5rem] rounded-md border bg-background px-2 py-1 text-[11px] leading-snug overflow-hidden"
      style={{ resize: 'none' }}
    />
  )
}

function InlineEditableCell({ value, onChange, placeholder }: { value: string; onChange: (v: string) => void; placeholder?: string }) {
  const [editing, setEditing] = React.useState(false)

  if (!editing) {
    return (
      <div
        role="button"
        onClick={() => setEditing(true)}
        className="cursor-text whitespace-pre-wrap break-words rounded-md px-2 py-1 min-h-[2.5rem]"
      >
        {value ? value : <span className="text-muted-foreground">{placeholder || 'Klicken zum Bearbeiten'}</span>}
      </div>
    )
  }

  return (
    <EditableTextarea
      value={value}
      onChange={onChange}
      onBlur={() => setEditing(false)}
      onKeyDown={(e) => { if (e.key === 'Escape') { e.preventDefault(); e.stopPropagation(); setEditing(false) } }}
    />
  )
}


```

```typescriptreact
"use client"

import { useState, useEffect, useCallback } from "react"
import { useForm } from "react-hook-form"
import { zodResolver } from "@hookform/resolvers/zod"
import * as z from "zod"
import { Button } from "@/components/ui/button"
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card"
import { Input } from "@/components/ui/input"
import { Label } from "@/components/ui/label"
import { Textarea } from "@/components/ui/textarea"
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs"
import { Badge } from "@/components/ui/badge"
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select"
import { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from "@/components/ui/tooltip"
import { Dialog, DialogContent, DialogHeader, DialogTitle, DialogFooter } from "@/components/ui/dialog"
import { StructuredTemplateEditor } from "@/components/templates/structured-template-editor"
import { useToast } from "@/hooks/use-toast"
import { Loader2, Save, Plus, Trash2, Eye, Play, FolderOpen, Info } from "lucide-react"
import { useAtom, useAtomValue } from "jotai"
import { activeLibraryAtom, libraryStatusAtom } from "@/atoms/library-atom"
import { 
  templatesAtom, 
  selectedTemplateNameAtom, 
  selectedTemplateAtom,
  templatesFolderIdAtom,
  templateLoadingAtom,
  templateErrorAtom,
  type Template
} from "@/atoms/template-atom"
import { useStorage } from "@/contexts/storage-context"

// Schema für Template-Daten
const templateSchema = z.object({
  name: z.string().min(1, "Prompt-Name ist erforderlich"),
  yamlFrontmatter: z.string(),
  markdownBody: z.string(),
  systemPrompt: z.string(),
})

type TemplateFormValues = z.infer<typeof templateSchema>

export function TemplateManagement() {
  const [previewMode, setPreviewMode] = useState(false)
  const [isSaving, setIsSaving] = useState(false)
  const [isTesting, setIsTesting] = useState(false)
  const [testResult, setTestResult] = useState<string | null>(null)
  const { toast } = useToast()

  // Atoms
  const [templates, setTemplates] = useAtom(templatesAtom)
  const [selectedTemplateName, setSelectedTemplateName] = useAtom(selectedTemplateNameAtom)
  const [selectedTemplate] = useAtom(selectedTemplateAtom)
  const [templatesFolderId, setTemplatesFolderId] = useAtom(templatesFolderIdAtom)
  const [isLoading, setIsLoading] = useAtom(templateLoadingAtom)
  const [error, setError] = useAtom(templateErrorAtom)

  // Library und Storage
  const activeLibrary = useAtomValue(activeLibraryAtom)
  const libraryStatus = useAtomValue(libraryStatusAtom)
  const { 
    provider: providerInstance, 
    listItems
  } = useStorage()

  const form = useForm<TemplateFormValues>({
    resolver: zodResolver(templateSchema),
    defaultValues: {
      name: "",
      yamlFrontmatter: `---
title: {{title|Titel des Dokuments}}
tags: {{tags|Relevante Tags}}
date: {{date|Datum im Format yyyy-mm-dd}}
---`,
      markdownBody: `# {{title}}

## Zusammenfassung
{{summary|Kurze Zusammenfassung des Inhalts}}

## Details
{{details|Detaillierte Beschreibung}}`,
      systemPrompt: `You are a specialized assistant that processes and structures information clearly and concisely.

IMPORTANT: Your response must be a valid JSON object where each key corresponds to a template variable.`,
    },
  })

  // Helper zum Erzeugen von Default-Werten
  function getDefaultTemplateValues(name: string): TemplateFormValues {
    return {
      name,
      yamlFrontmatter: `---\n` +
        `title: {{title|Titel des Dokuments}}\n` +
        `tags: {{tags|Relevante Tags}}\n` +
        `date: {{date|Datum im Format yyyy-mm-dd}}\n` +
        `---`,
      markdownBody: `# {{title}}\n\n## Zusammenfassung\n{{summary|Kurze Zusammenfassung des Inhalts}}\n\n## Details\n{{details|Detaillierte Beschreibung}}`,
      systemPrompt: `You are a specialized assistant that processes and structures information clearly and concisely.\n\nIMPORTANT: Your response must be a valid JSON object where each key corresponds to a template variable.`,
    }
  }

  // Template-Daten laden wenn sich die Auswahl ändert
  useEffect(() => {
    if (selectedTemplate) {
      form.reset({
        name: selectedTemplate.name,
        yamlFrontmatter: selectedTemplate.yamlFrontmatter,
        markdownBody: selectedTemplate.markdownBody,
        systemPrompt: selectedTemplate.systemPrompt,
      })
    }
  }, [selectedTemplate, form])

  // Ordner-Erstellung/Suche memoisiert, damit als Dep verwendbar
  const ensureTemplatesFolder = useCallback(async (): Promise<string> => {
    if (!providerInstance || !activeLibrary) {
      throw new Error("Keine aktive Bibliothek oder Provider verfügbar");
    }

    try {
      console.log('[TemplateManagement] Suche nach Templates-Ordner...');
      const rootItems = await listItems('root');
      const templatesFolder = rootItems.find(item => 
        item.type === 'folder' && item.metadata.name === 'templates'
      );
      if (templatesFolder) {
        console.log('[TemplateManagement] Templates-Ordner gefunden:', templatesFolder.id);
        return templatesFolder.id;
      }
      console.log('[TemplateManagement] Templates-Ordner nicht gefunden, erstelle neuen...');
      const newFolder = await providerInstance.createFolder('root', 'templates');
      console.log('[TemplateManagement] Neuer Templates-Ordner erstellt:', newFolder.id);
      return newFolder.id;
    } catch (error) {
      console.error('Fehler beim Erstellen des Templates-Ordners:', {
        error: error instanceof Error ? {
          message: error.message,
          name: error.name,
          stack: error.stack?.split('\n').slice(0, 3)
        } : error,
        libraryId: activeLibrary?.id,
        libraryPath: activeLibrary?.path,
        providerName: providerInstance?.name
      });
      let errorMessage = 'Fehler beim Erstellen des Templates-Ordners';
      if (error instanceof Error) {
        if (error.message.includes('Nicht authentifiziert')) {
          errorMessage = 'Bitte authentifizieren Sie sich bei Ihrem Cloud-Speicher, um den Templates-Ordner zu erstellen.';
        } else if (error.message.includes('Keine Berechtigung')) {
          errorMessage = 'Keine Berechtigung zum Erstellen von Ordnern in der Bibliothek.';
        } else if (error.message.includes('Bibliothek nicht gefunden')) {
          errorMessage = 'Die ausgewählte Bibliothek wurde nicht gefunden.';
        } else {
          errorMessage = `Fehler beim Erstellen des Templates-Ordners: ${error.message}`;
        }
      }
      throw new Error(errorMessage);
    }
  }, [providerInstance, activeLibrary, listItems]);

  // Templates laden mit der gleichen Logik wie Library-Komponente
  const loadTemplates = useCallback(async () => {
    if (!providerInstance || libraryStatus !== 'ready' || !activeLibrary) {
      console.log('[TemplateManagement] loadTemplates übersprungen:', {
        hasProvider: !!providerInstance,
        libraryStatus,
        hasActiveLibrary: !!activeLibrary
      });
      return;
    }

    try {
      setIsLoading(true);
      setError(null);

      console.log('[TemplateManagement] Starte Prompt-Loading:', {
        libraryId: activeLibrary.id,
        libraryPath: activeLibrary.path,
        providerName: providerInstance.name
      });

      // 1. Templates-Ordner finden oder erstellen
      const folderId = await ensureTemplatesFolder();
      setTemplatesFolderId(folderId);

      console.log('[TemplateManagement] Templates-Ordner gefunden/erstellt:', folderId);

      // 2. Alle Template-Dateien im Ordner auflisten
      const items = await listItems(folderId);
      const templateFiles = items.filter(item => 
        item.type === 'file' && 
        item.metadata.name.endsWith('.md')
      );

      console.log('[TemplateManagement] Prompt-Dateien gefunden:', templateFiles.length);

      // 3. Template-Inhalte laden
      const templatePromises = templateFiles.map(async (file) => {
        try {
          const { blob } = await providerInstance.getBinary(file.id);
          const content = await blob.text();
          const template = parseTemplateContent(content, file.metadata.name.replace('.md', ''));
          
          return {
            ...template,
            fileId: file.id,
            lastModified: typeof file.metadata.modifiedAt === 'string' 
              ? file.metadata.modifiedAt 
              : file.metadata.modifiedAt instanceof Date 
                ? file.metadata.modifiedAt.toISOString()
                : new Date().toISOString()
          } as Template;
        } catch (error) {
          console.error(`Fehler beim Parsen von ${file.metadata.name}:`, error);
          return null;
        }
      });

      const loadedTemplates = await Promise.all(templatePromises);
      const validTemplates = loadedTemplates.filter((t): t is Template => t !== null);
      
      setTemplates(validTemplates);
      
      console.log('[TemplateManagement] Prompts erfolgreich geladen:', validTemplates.length);
      
      if (validTemplates.length === 0) {
        toast({
          title: "Keine Prompts gefunden",
          description: "Erstellen Sie Ihren ersten Prompt im Verzeichnis '/templates'.",
        });
      }
    } catch (error) {
      console.error('Fehler beim Laden der Prompts:', {
        error: error instanceof Error ? {
          message: error.message,
          name: error.name,
          stack: error.stack?.split('\n').slice(0, 3)
        } : error,
        libraryId: activeLibrary?.id,
        libraryPath: activeLibrary?.path,
        providerName: providerInstance?.name
      });

      let errorMessage = 'Unbekannter Fehler beim Laden der Prompts';
      
      if (error instanceof Error) {
        errorMessage = error.message;
        
        // Spezifische Fehlermeldungen für häufige Probleme
        if (error.message.includes('Nicht authentifiziert')) {
          errorMessage = 'Bitte authentifizieren Sie sich bei Ihrem Cloud-Speicher, um Prompts zu laden.';
        } else if (error.message.includes('Bibliothek nicht gefunden')) {
          errorMessage = 'Die ausgewählte Bibliothek wurde nicht gefunden. Bitte überprüfen Sie die Bibliothekskonfiguration.';
        } else if (error.message.includes('Server-Fehler')) {
          errorMessage = 'Server-Fehler beim Laden der Prompts. Bitte überprüfen Sie, ob der Bibliothekspfad existiert und zugänglich ist.';
        } else if (error.message.includes('Keine aktive Bibliothek')) {
          errorMessage = 'Keine aktive Bibliothek verfügbar. Bitte wählen Sie eine Bibliothek aus.';
        }
      }
      
      setError(errorMessage);
      toast({
        title: "Fehler beim Laden der Prompts",
        description: errorMessage,
        variant: "destructive",
      });
    } finally {
      setIsLoading(false);
    }
  }, [providerInstance, libraryStatus, activeLibrary, listItems, setTemplates, setTemplatesFolderId, setIsLoading, setError, toast, ensureTemplatesFolder]);

  // Effect für Template Loading (wie Library-Komponente)
  useEffect(() => {
    const isReady = providerInstance && libraryStatus === 'ready' && activeLibrary
    
    if (!isReady) {
      return
    }

    // Templates laden wenn noch nicht geladen
    if (!templatesFolderId) {
      loadTemplates()
    }
  }, [providerInstance, libraryStatus, activeLibrary, templatesFolderId, loadTemplates])

  // Reset wenn sich die Library ändert
  useEffect(() => {
    setSelectedTemplateName(null)
    setTemplatesFolderId(null)
    setTemplates([])
    setError(null)
  }, [libraryStatus, setSelectedTemplateName, setTemplatesFolderId, setTemplates, setError])

  function parseTemplateContent(content: string, fileName: string): Template {
    // Template in drei Bereiche aufteilen
    const parts = content.split('--- systemprompt')
    
    let yamlFrontmatter = ""
    let markdownBody = ""
    let systemPrompt = ""
    
    if (parts.length >= 2) {
      const mainContent = parts[0].trim()
      systemPrompt = parts[1].trim()
      
      // YAML Frontmatter extrahieren
      const yamlMatch = mainContent.match(/^---\n([\s\S]*?)\n---\n([\s\S]*)$/)
      if (yamlMatch) {
        yamlFrontmatter = `---\n${yamlMatch[1]}\n---`
        markdownBody = yamlMatch[2].trim()
      } else {
        // Kein YAML Frontmatter gefunden
        markdownBody = mainContent
      }
    } else {
      // Kein Systemprompt gefunden
      const yamlMatch = content.match(/^---\n([\s\S]*?)\n---\n([\s\S]*)$/)
      if (yamlMatch) {
        yamlFrontmatter = `---\n${yamlMatch[1]}\n---`
        markdownBody = yamlMatch[2].trim()
      } else {
        markdownBody = content
      }
    }

    return {
      name: fileName,
      yamlFrontmatter,
      markdownBody,
      systemPrompt,
    }
  }

  function generateTemplateContent(values: TemplateFormValues): string {
    let content = ""
    
    // YAML Frontmatter hinzufügen
    if (values.yamlFrontmatter.trim()) {
      content += values.yamlFrontmatter + "\n\n"
    }
    
    // Markdown Body hinzufügen
    content += values.markdownBody
    
    // System Prompt hinzufügen
    if (values.systemPrompt.trim()) {
      content += "\n\n--- systemprompt\n" + values.systemPrompt
    }
    
    return content
  }

  async function onSubmit(data: TemplateFormValues) {
    if (!activeLibrary || !templatesFolderId || !providerInstance) {
      toast({
        title: "Fehler",
        description: "Keine aktive Bibliothek oder Templates-Ordner nicht gefunden.",
        variant: "destructive",
      })
      return
    }

    setIsSaving(true)
    try {
      const templateContent = generateTemplateContent(data)
      const fileName = `${data.name}.md`
      
      // Datei als Blob erstellen
      const blob = new Blob([templateContent], { type: 'text/markdown' })
      const file = new File([blob], fileName, { type: 'text/markdown' })
      
      // Datei hochladen
      await providerInstance.uploadFile(templatesFolderId, file)
      
      // Templates neu laden
      await loadTemplates()
      
      // Auswahl auf das neue Template setzen
      setSelectedTemplateName(data.name)
      
      toast({
        title: "Template gespeichert",
        description: `Template "${data.name}" wurde erfolgreich im Verzeichnis "/templates" gespeichert.`,
      })
    } catch (error) {
      console.error('Fehler beim Speichern des Templates:', error)
      toast({
        title: "Fehler beim Speichern",
        description: error instanceof Error ? error.message : "Unbekannter Fehler",
        variant: "destructive",
      })
    } finally {
      setIsSaving(false)
    }
  }

  async function renameCurrentTemplate() {
    const current = selectedTemplateName ? templates.find(t => t.name === selectedTemplateName) : null
    if (!current || !current.fileId || !providerInstance) return
    const newName = (window.prompt('Neuen Namen eingeben:', current.name) || '').trim()
    if (!newName || newName === current.name) return
    if (/[^a-zA-Z0-9._\- ]/.test(newName)) { toast({ title: 'Ungültiger Name', description: 'Nur Buchstaben, Zahlen, Leerzeichen, . _ - sind erlaubt.', variant: 'destructive' }); return }
    if (templates.some(t => t.name.toLowerCase() === newName.toLowerCase())) { toast({ title: 'Bereits vorhanden', description: 'Bitte anderen Namen wählen.', variant: 'destructive' }); return }
    try {
      await providerInstance.renameItem(current.fileId, `${newName}.md`)
      await loadTemplates()
      setSelectedTemplateName(newName)
      form.setValue('name', newName, { shouldDirty: false })
      toast({ title: 'Umbenannt', description: `${current.name} → ${newName}` })
    } catch (e) {
      toast({ title: 'Fehler beim Umbenennen', description: e instanceof Error ? e.message : 'Unbekannter Fehler', variant: 'destructive' })
    }
  }

  async function deleteTemplate(templateName: string) {
    if (!activeLibrary || !providerInstance) return

    try {
      const template = templates.find(t => t.name === templateName)
      if (!template?.fileId) {
        throw new Error("Template-Datei nicht gefunden")
      }

      // Datei löschen
      await providerInstance.deleteItem(template.fileId)

      // Templates neu laden
      await loadTemplates()
      
      if (selectedTemplateName === templateName) {
        setSelectedTemplateName(null)
        form.reset()
      }
      
      toast({
        title: "Template gelöscht",
        description: `Template "${templateName}" wurde erfolgreich gelöscht.`,
      })
    } catch (error) {
      console.error('Fehler beim Löschen des Templates:', error)
      toast({
        title: "Fehler beim Löschen",
        description: error instanceof Error ? error.message : "Unbekannter Fehler",
        variant: "destructive",
      })
    }
  }

  async function createNewTemplate() {
    const name = (window.prompt('Neuen Template‑Namen eingeben:') || '').trim()
    if (!name) return
    if (/[^a-zA-Z0-9._\- ]/.test(name)) { toast({ title: 'Ungültiger Name', description: 'Nur Buchstaben, Zahlen, Leerzeichen, . _ - sind erlaubt.', variant: 'destructive' }); return }
    if (templates.some(t => t.name.toLowerCase() === name.toLowerCase())) { toast({ title: 'Bereits vorhanden', description: 'Bitte anderen Namen wählen.', variant: 'destructive' }); return }
    if (!providerInstance) { toast({ title: 'Kein Provider' , variant: 'destructive' }); return }
    try {
      const folderId = await ensureTemplatesFolder()
      const values = getDefaultTemplateValues(name)
      const content = (values.yamlFrontmatter ? values.yamlFrontmatter + '\n\n' : '') + values.markdownBody + '\n\n--- systemprompt\n' + values.systemPrompt
      const file = new File([new Blob([content], { type: 'text/markdown' })], `${name}.md`, { type: 'text/markdown' })
      await providerInstance.uploadFile(folderId, file)
      await loadTemplates()
      setSelectedTemplateName(name)
      form.reset(values)
      toast({ title: 'Template angelegt', description: `"${name}" wurde erstellt.` })
    } catch (e) {
      toast({ title: 'Fehler beim Anlegen', description: e instanceof Error ? e.message : 'Unbekannter Fehler', variant: 'destructive' })
    }
  }

  function generatePreview(): string {
    const values = form.getValues()
    return generateTemplateContent(values)
  }

  async function testTemplate() {
    if (!activeLibrary) return

    setIsTesting(true)
    setTestResult(null)

    const values = form.getValues()
    const templateContent = generateTemplateContent(values)
    
    // Testtext aus dem Textarea lesen
    const testTextarea = document.querySelector('textarea[placeholder="Geben Sie einen Testtext ein..."]') as HTMLTextAreaElement
    const testText = testTextarea?.value || "Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed eiusmod tempor incidunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquid ex ea commodi consequat. Quis aute iure reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint obcaecat cupiditat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum."
    
    try {
      const response = await fetch('/api/secretary/process-text', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/x-www-form-urlencoded',
          'X-Library-Id': activeLibrary.id,
        },
        body: new URLSearchParams({
          text: testText,
          template_content: templateContent,
          source_language: 'de',
          target_language: 'de',
        }),
      })

      if (!response.ok) {
        const errorData = await response.json()
        throw new Error(errorData.error || `HTTP ${response.status}: ${response.statusText}`)
      }

      const result = await response.json()
      
      // Ergebnis formatieren und anzeigen
      const formattedResult = JSON.stringify(result, null, 2)
      setTestResult(formattedResult)
      
      toast({
        title: "Template-Test erfolgreich",
        description: "Das Template wurde erfolgreich mit dem Testtext verarbeitet.",
      })
      
      console.log('Template-Test Ergebnis:', result)
    } catch (error) {
      console.error('Fehler beim Template-Test:', error)
      const errorMessage = error instanceof Error ? error.message : "Unbekannter Fehler"
      setTestResult(`Fehler: ${errorMessage}`)
      toast({
        title: "Template-Test fehlgeschlagen",
        description: errorMessage,
        variant: "destructive",
      })
    } finally {
      setIsTesting(false)
    }
  }

  // Render-Logik für verschiedene Status
  if (libraryStatus === "waitingForAuth") {
    return (
      <div className="flex flex-col items-center justify-center h-full text-muted-foreground">
        <span>Diese Bibliothek benötigt eine Authentifizierung.</span>
        <span className="text-sm mt-2">Bitte konfigurieren Sie die Bibliothek in den Einstellungen.</span>
      </div>
    )
  }
  
  if (libraryStatus !== "ready") {
    return (
      <div className="flex flex-col items-center justify-center h-full text-muted-foreground">
        <span>Lade Storage...</span>
      </div>
    )
  }

  if (!activeLibrary) {
    return (
      <div className="text-center text-muted-foreground">
        Bitte wählen Sie eine Bibliothek aus.
      </div>
    )
  }

  if (error) {
    return (
      <div className="text-center text-destructive">
        <p>Fehler beim Laden der Prompts:</p>
        <p className="text-sm">{error}</p>
        <Button 
          variant="outline" 
          className="mt-4"
          onClick={loadTemplates}
        >
          Erneut versuchen
        </Button>
      </div>
    )
  }

  return (
    <div className="space-y-6">

      {/* Kompakte Toolbar oben */}
      <div className="flex items-center gap-2">
        <Select value={selectedTemplateName || ''} onValueChange={(v) => { setSelectedTemplateName(v); form.setValue('name', v, { shouldDirty: false }) }} disabled={isLoading}>
          <SelectTrigger className="w-64">
            <SelectValue placeholder="Prompt auswählen..." />
          </SelectTrigger>
          <SelectContent>
            {templates.map((t) => (
              <SelectItem key={t.name} value={t.name}>{t.name}</SelectItem>
            ))}
          </SelectContent>
        </Select>
        <TooltipProvider>
          <Tooltip>
            <TooltipTrigger asChild>
              <Button variant="ghost" size="sm" className="h-8 w-8 p-0"><Info className="h-4 w-4" /></Button>
            </TooltipTrigger>
            <TooltipContent>
              <div className="flex items-center gap-2"><FolderOpen className="h-4 w-4" /><span>Ort: /templates in „{activeLibrary.label}“</span></div>
            </TooltipContent>
          </Tooltip>
        </TooltipProvider>
        <Button type="button" variant="outline" size="sm" onClick={createNewTemplate} disabled={isLoading}>Neu</Button>
        <Button type="button" variant="outline" size="sm" onClick={renameCurrentTemplate} disabled={!selectedTemplateName}>Umbenennen</Button>
        {selectedTemplateName && (
          <Button type="button" variant="destructive" size="sm" onClick={() => deleteTemplate(selectedTemplateName!)}>Löschen</Button>
        )}
      </div>

      <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
        <Card>
          <CardHeader>
            <CardTitle>Prompt Design</CardTitle>
            <CardDescription>
              Drei Bereiche: Rollenanweisung (wie), Aufgabe (was), Ausgabeformat (in welcher Form).
            </CardDescription>
          </CardHeader>
          <CardContent>
            <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-6">
              {/* Template-Name Feld entfernt (oben verwaltet) */}

              {previewMode ? (
                <div className="space-y-4">
                  <div className="flex items-center justify-between">
                    <h4 className="text-sm font-medium">Prompt-Vorschau</h4>
                    <Button
                      type="button"
                      variant="outline"
                      size="sm"
                      onClick={() => setPreviewMode(false)}
                    >
                      Bearbeiten
                    </Button>
                  </div>
                  <div className="border rounded-md p-4 bg-muted/50">
                    <pre className="text-sm whitespace-pre-wrap font-mono">
                      {generatePreview()}
                    </pre>
                  </div>
                </div>
              ) : (
                <StructuredTemplateEditor
                  markdownBody={form.watch('markdownBody')}
                  yamlFrontmatter={form.watch('yamlFrontmatter')}
                  systemPrompt={form.watch('systemPrompt')}
                  onChange={({ markdownBody, yamlFrontmatter, systemPrompt }) => {
                    form.setValue('markdownBody', markdownBody, { shouldDirty: true })
                    form.setValue('yamlFrontmatter', yamlFrontmatter, { shouldDirty: true })
                    form.setValue('systemPrompt', systemPrompt, { shouldDirty: true })
                  }}
                />
              )}

              <div className="flex justify-end gap-2">
                <Button
                  type="button"
                  variant="outline"
                  onClick={() => setPreviewMode(!previewMode)}
                >
                  <Eye className="h-4 w-4 mr-2" />
                  {previewMode ? "Bearbeiten" : "Vorschau"}
                </Button>
                <Button
                  type="submit"
                  disabled={isSaving || !form.formState.isDirty}
                >
                  {isSaving ? (
                    <>
                      <Loader2 className="h-4 w-4 mr-2 animate-spin" />
                      Wird gespeichert...
                    </>
                  ) : (
                    <>
                      <Save className="h-4 w-4 mr-2" />
                      Speichern
                    </>
                  )}
                </Button>
              </div>
            </form>
          </CardContent>
        </Card>

        <Card>
          <CardHeader>
            <CardTitle>Prompt testen</CardTitle>
            <CardDescription>
              Test mit Beispieltext. Nutzt Rollenanweisung, Aufgabe und Ausgabeformat des Prompts.
            </CardDescription>
          </CardHeader>
          <CardContent>
            <div className="space-y-4">
              <div className="space-y-2">
                <Label>Test-Text</Label>
                <Textarea
                  placeholder="Geben Sie einen Testtext ein..."
                  className="min-h-[100px]"
                  defaultValue="Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed eiusmod tempor incidunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquid ex ea commodi consequat. Quis aute iure reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint obcaecat cupiditat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum."
                />
              </div>
              <div className="flex gap-2">
                <Button 
                  variant="outline" 
                  size="sm"
                  onClick={testTemplate}
                  disabled={!selectedTemplateName || isTesting}
                >
                  {isTesting ? (
                    <>
                      <Loader2 className="h-4 w-4 mr-2 animate-spin" />
                      Teste...
                    </>
                  ) : (
                    <>
                      <Play className="h-4 w-4 mr-2" />
                      Prompt testen
                    </>
                  )}
                </Button>
              </div>
              
              {testResult && (
                <div className="space-y-2">
                  <Label>Test-Ergebnis</Label>
                  <div className="border rounded-md p-4 bg-muted/50">
                    <pre className="text-sm whitespace-pre-wrap font-mono max-h-[300px] overflow-y-auto">
                      {testResult}
                    </pre>
                  </div>
                </div>
              )}
            </div>
          </CardContent>
        </Card>
      </div>
    </div>
  )
} 
```

- UI-Begriffe umgestellt:
  - Tabs: Aufgabe, Ausgabeformat, Rollenanweisung.
  - Frontmatter-Tabelle: Feld, Variable, Hinweis.
  - Editor-Karte: Prompt Design mit kurzer Laien-Beschreibung.
  - Test-Karte: Prompt testen, mit Hinweis auf die drei Bereiche.

- Verhalten bleibt gleich:
  - Aufgabe: zeilenbasiert, Typ/Variable auswählen, Text/Frage ohne Markdown-Symbole editieren.
  - Ausgabeformat: Key-Value-Felder mit Hinweisen.
  - Rollenanweisung: kompakte Eingabe für Grundregeln.

---

**User**

Frontmatter ist nicht Ausgabeformat - das sind Metadaten, können wir das so benennen?

---

**Cursor**

Ich ändere die UI-Bezeichnungen: In `structured-template-editor.tsx` benenne ich den Tab „Ausgabeformat“ zu „Metadaten“ um; in `template-management.tsx` passe ich die Beschreibungen entsprechend an. Anschließend prüfe ich Linter.

```typescriptreact
"use client";

import * as React from 'react'
import { parseFrontmatterKeyValues } from '@/lib/markdown/frontmatter'
import { Input } from '@/components/ui/input'
import { Label } from '@/components/ui/label'
import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from '@/components/ui/table'
import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs'
import { GripVertical, Plus } from 'lucide-react'
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select'

export interface StructuredTemplateEditorProps {
  markdownBody: string
  yamlFrontmatter: string
  systemPrompt: string
  onChange: (next: { markdownBody: string; yamlFrontmatter: string; systemPrompt: string }) => void
}

type LineKind = 'text' | 'h1' | 'h2' | 'h3' | 'bold' | 'variable'

export function StructuredTemplateEditor({ markdownBody, yamlFrontmatter, systemPrompt, onChange }: StructuredTemplateEditorProps) {
  const lines = React.useMemo(() => (typeof markdownBody === 'string' ? markdownBody.split('\n') : []), [markdownBody])
  const fmEntries = React.useMemo(() => parseFrontmatterKeyValues(yamlFrontmatter || ''), [yamlFrontmatter])
  const [sysPrompt, setSysPrompt] = React.useState(systemPrompt)
  const [tab, setTab] = React.useState<'body'|'frontmatter'|'system'>('body')
  const dragFrom = React.useRef<number | null>(null)

  React.useEffect(() => { setSysPrompt(systemPrompt) }, [systemPrompt])

  function parseLine(line: string): { kind: LineKind; varKey: string; content: string } {
    const mVar = /^\s*\{\{([^}|]+)\|([^}]+)\}\}\s*$/.exec(line)
    if (mVar) return { kind: 'variable', varKey: (mVar[1] || '').trim(), content: (mVar[2] || '').trim() }
    if (/^\s*###\s+/.test(line)) return { kind: 'h3', varKey: '', content: line.replace(/^\s*###\s+/, '') }
    if (/^\s*##\s+/.test(line)) return { kind: 'h2', varKey: '', content: line.replace(/^\s*##\s+/, '') }
    if (/^\s*#\s+/.test(line)) return { kind: 'h1', varKey: '', content: line.replace(/^\s*#\s+/, '') }
    const mBold = /^\s*\*\*([\s\S]*?)\*\*\s*$/.exec(line)
    if (mBold) return { kind: 'bold', varKey: '', content: (mBold[1] || '') }
    return { kind: 'text', varKey: '', content: line }
  }

  function buildLine(kind: LineKind, content: string, varKey?: string): string {
    const text = content ?? ''
    switch (kind) {
      case 'variable': {
        const k = (varKey || '').trim()
        return k ? `{{${k}|${text}}}` : text
      }
      case 'h1': return `# ${text}`
      case 'h2': return `## ${text}`
      case 'h3': return `### ${text}`
      case 'bold': return `**${text}**`
      case 'text': default: return text
    }
  }

  function updateLineByIndex(lineIndex: number, nextLine: string) {
    const copy = lines.slice()
    if (lineIndex >= 0 && lineIndex < copy.length) copy[lineIndex] = nextLine
    onChange({ markdownBody: copy.join('\n'), yamlFrontmatter, systemPrompt: sysPrompt })
  }

  function suggestVarKey(index: number, content: string): string {
    const base = (content || '').toLowerCase().trim().replace(/[^a-z0-9]+/g, '_').replace(/^_+|_+$/g, '')
    const trimmed = base.length >= 3 ? base.slice(0, 24) : ''
    return trimmed || `var_${index + 1}`
  }

  function updateLineKind(lineIndex: number, nextKind: LineKind) {
    if (lineIndex < 0 || lineIndex >= lines.length) return
    const { content, varKey } = parseLine(lines[lineIndex])
    if (nextKind === 'variable') {
      const key = varKey && varKey.trim().length > 0 ? varKey : suggestVarKey(lineIndex, content)
      updateLineByIndex(lineIndex, buildLine('variable', content, key))
      return
    }
    updateLineByIndex(lineIndex, buildLine(nextKind, content, varKey))
  }

  function updateVarKey(lineIndex: number, nextKey: string) {
    if (lineIndex < 0 || lineIndex >= lines.length) return
    const { content } = parseLine(lines[lineIndex])
    const realKind: LineKind = 'variable'
    updateLineByIndex(lineIndex, buildLine(realKind, content, nextKey))
  }

  function updateContent(lineIndex: number, nextContent: string) {
    if (lineIndex < 0 || lineIndex >= lines.length) return
    const { kind, varKey } = parseLine(lines[lineIndex])
    updateLineByIndex(lineIndex, buildLine(kind, nextContent, varKey))
  }

  const updateFrontmatterQuestion = (entryKey: string, question: string) => {
    const linesFM = (yamlFrontmatter || '').split('\n')
    const idx = linesFM.findIndex(l => new RegExp(`^${escapeRegExp(entryKey)}\\s*:`).test(l.trim()))
    if (idx >= 0) {
      const line = linesFM[idx]
      const m = /\{\{([^}|]+)\|([^}]+)\}\}/.exec(line)
      if (m) {
        linesFM[idx] = line.replace(m[0], `{{${m[1]}|${question}}}`)
      }
      onChange({ markdownBody, yamlFrontmatter: linesFM.join('\n'), systemPrompt: sysPrompt })
    }
  }

  function handleDragStart(e: React.DragEvent, fromIndex: number) {
    dragFrom.current = fromIndex
    e.dataTransfer.setData('text/plain', String(fromIndex))
    e.dataTransfer.effectAllowed = 'move'
  }
  function handleDragOver(e: React.DragEvent) {
    e.preventDefault()
    e.dataTransfer.dropEffect = 'move'
  }
  function handleDrop(e: React.DragEvent, toIndex: number) {
    e.preventDefault()
    const fromStr = e.dataTransfer.getData('text/plain')
    const fromIndex = Number.isInteger(Number(fromStr)) ? parseInt(fromStr, 10) : dragFrom.current
    if (fromIndex === null || isNaN(fromIndex) || fromIndex === toIndex) return
    const arr = lines.slice()
    const [moved] = arr.splice(fromIndex, 1)
    arr.splice(toIndex, 0, moved)
    onChange({ markdownBody: arr.join('\n'), yamlFrontmatter, systemPrompt: sysPrompt })
    dragFrom.current = null
  }

  function addLineAfter(index: number) {
    const arr = lines.slice()
    arr.splice(index + 1, 0, '')
    onChange({ markdownBody: arr.join('\n'), yamlFrontmatter, systemPrompt: sysPrompt })
  }

  const handleSysPromptChange = (v: string) => {
    setSysPrompt(v)
    onChange({ markdownBody, yamlFrontmatter, systemPrompt: v })
  }

  return (
    <div className="space-y-3">
      <Tabs value={tab} onValueChange={(v) => setTab(v as typeof tab)}>
        <TabsList className="grid grid-cols-3 w-full">
          <TabsTrigger value="body">Aufgabe</TabsTrigger>
          <TabsTrigger value="frontmatter">Metadaten</TabsTrigger>
          <TabsTrigger value="system">Rollenanweisung</TabsTrigger>
        </TabsList>

        <TabsContent value="body">
          <div className="overflow-auto">
            <Table className="text-[11px] w-full border-collapse">
              <TableHeader>
                <TableRow className="[&>*]:py-1">
                  <TableHead className="w-8" />
                  <TableHead className="w-36">Typ/Variable</TableHead>
                  <TableHead>Text / Frage</TableHead>
                </TableRow>
              </TableHeader>
              <TableBody>
                {lines.length === 0 ? (
                  <TableRow><TableCell colSpan={3} className="text-muted-foreground">Keine Zeilen im Body.</TableCell></TableRow>
                ) : lines.map((line, i) => {
                  const { kind, varKey, content } = parseLine(line)
                  return (
                    <TableRow key={`line-${i}`} className="align-top" onDragOver={handleDragOver} onDrop={(e) => handleDrop(e, i)}>
                      <TableCell className="align-top w-8 py-1">
                        <div className="flex items-center gap-1">
                          <span
                            draggable
                            onDragStart={(e) => handleDragStart(e, i)}
                            className="inline-flex h-4 w-4 items-center justify-center text-muted-foreground cursor-grab hover:text-foreground"
                            title="Ziehen zum Verschieben"
                            aria-label="Ziehen zum Verschieben"
                          >
                            <GripVertical className="h-3 w-3" />
                          </span>
                          <button
                            type="button"
                            className="inline-flex h-4 w-4 items-center justify-center text-muted-foreground hover:text-foreground"
                            title="Zeile darunter einfügen"
                            aria-label="Zeile darunter einfügen"
                            onClick={() => addLineAfter(i)}
                          >
                            <Plus className="h-3 w-3" />
                          </button>
                        </div>
                      </TableCell>
                      <TableCell className="align-top w-36 py-1">
                        <div className="flex flex-col gap-1">
                          <Select value={kind} onValueChange={(v) => updateLineKind(i, v as LineKind)}>
                            <SelectTrigger className="h-7 text-[11px]">
                              <SelectValue placeholder="Text" />
                            </SelectTrigger>
                            <SelectContent>
                              <SelectItem value="text">Text</SelectItem>
                              <SelectItem value="h1">Heading 1</SelectItem>
                              <SelectItem value="h2">Heading 2</SelectItem>
                              <SelectItem value="h3">Heading 3</SelectItem>
                              <SelectItem value="bold">Bold</SelectItem>
                              <SelectItem value="variable">Variable</SelectItem>
                            </SelectContent>
                          </Select>
                          {kind === 'variable' ? (
                            <Input
                              value={varKey}
                              onChange={(e) => updateVarKey(i, e.target.value)}
                              placeholder="Variablenname"
                              className="h-7 text-[11px] font-mono"
                            />
                          ) : null}
                        </div>
                      </TableCell>
                      <TableCell className="align-top py-1">
                        <InlineEditableCell
                          value={content}
                          onChange={(val) => updateContent(i, val)}
                          placeholder={kind === 'variable' ? 'Frage/Beschreibung' : 'Markdown-Text'}
                        />
                      </TableCell>
                    </TableRow>
                  )
                })}
              </TableBody>
            </Table>
          </div>
        </TabsContent>

        <TabsContent value="frontmatter">
          <div className="max-h-[50vh] overflow-auto rounded border">
            <table className="w-full text-[11px] border-collapse">
              <thead className="sticky top-0 bg-background">
                <tr>
                  <th className="w-40 text-left px-2 py-1">Feld</th>
                  <th className="w-40 text-left px-2 py-1">Variable</th>
                  <th className="text-left px-2 py-1">Hinweis</th>
                </tr>
              </thead>
              <tbody>
                {fmEntries.length === 0 ? (
                  <tr><td colSpan={3} className="px-2 py-1 text-muted-foreground">Keine Felder im Frontmatter.</td></tr>
                ) : fmEntries.map((e, i) => {
                  const m = /\{\{([^}|]+)\|([^}]+)\}\}/.exec(e.rawValue)
                  const varKey = m ? m[1].trim() : ''
                  const varQ = m ? m[2].trim() : ''
                  return (
                    <tr key={`${e.key}-${i}`} className="align-top">
                      <td className="px-2 py-1 align-top font-mono">{e.key}</td>
                      <td className="px-2 py-1 align-top font-mono">{varKey}</td>
                      <td className="px-2 py-1 align-top">
                        <InlineEditableCell
                          value={varQ}
                          onChange={(val) => updateFrontmatterQuestion(e.key, val)}
                          placeholder="Klicken zum Bearbeiten"
                        />
                      </td>
                    </tr>
                  )
                })}
              </tbody>
            </table>
          </div>
        </TabsContent>

        <TabsContent value="system">
          <div className="space-y-1">
            <Label>Rollenanweisung</Label>
            <Input value={sysPrompt} onChange={(e) => handleSysPromptChange(e.target.value)} className="font-mono h-8 text-xs" />
          </div>
        </TabsContent>
      </Tabs>
    </div>
  )
}

function escapeRegExp(s: string): string {
  return s.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')
}

function EditableTextarea({ value, onChange, onBlur, onKeyDown }: { value: string; onChange: (v: string) => void; onBlur?: () => void; onKeyDown?: (e: React.KeyboardEvent<HTMLTextAreaElement>) => void }) {
  const [local, setLocal] = React.useState(value)
  const ref = React.useRef<HTMLTextAreaElement | null>(null)

  const autosize = React.useCallback(() => {
    const el = ref.current
    if (!el) return
    el.style.height = 'auto'
    el.style.height = `${el.scrollHeight}px`
  }, [])

  React.useEffect(() => { setLocal(value); requestAnimationFrame(autosize) }, [value, autosize])

  return (
    <textarea
      ref={ref}
      value={local}
      onChange={(e) => { setLocal(e.target.value); onChange(e.target.value); autosize() }}
      onInput={autosize}
      onBlur={onBlur}
      onKeyDown={onKeyDown}
      className="w-full min-h-[2.5rem] rounded-md border bg-background px-2 py-1 text-[11px] leading-snug overflow-hidden"
      style={{ resize: 'none' }}
    />
  )
}

function InlineEditableCell({ value, onChange, placeholder }: { value: string; onChange: (v: string) => void; placeholder?: string }) {
  const [editing, setEditing] = React.useState(false)

  if (!editing) {
    return (
      <div
        role="button"
        onClick={() => setEditing(true)}
        className="cursor-text whitespace-pre-wrap break-words rounded-md px-2 py-1 min-h-[2.5rem]"
      >
        {value ? value : <span className="text-muted-foreground">{placeholder || 'Klicken zum Bearbeiten'}</span>}
      </div>
    )
  }

  return (
    <EditableTextarea
      value={value}
      onChange={onChange}
      onBlur={() => setEditing(false)}
      onKeyDown={(e) => { if (e.key === 'Escape') { e.preventDefault(); e.stopPropagation(); setEditing(false) } }}
    />
  )
}


```

```typescriptreact
"use client"

import { useState, useEffect, useCallback } from "react"
import { useForm } from "react-hook-form"
import { zodResolver } from "@hookform/resolvers/zod"
import * as z from "zod"
import { Button } from "@/components/ui/button"
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card"
import { Input } from "@/components/ui/input"
import { Label } from "@/components/ui/label"
import { Textarea } from "@/components/ui/textarea"
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs"
import { Badge } from "@/components/ui/badge"
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select"
import { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from "@/components/ui/tooltip"
import { Dialog, DialogContent, DialogHeader, DialogTitle, DialogFooter } from "@/components/ui/dialog"
import { StructuredTemplateEditor } from "@/components/templates/structured-template-editor"
import { useToast } from "@/hooks/use-toast"
import { Loader2, Save, Plus, Trash2, Eye, Play, FolderOpen, Info } from "lucide-react"
import { useAtom, useAtomValue } from "jotai"
import { activeLibraryAtom, libraryStatusAtom } from "@/atoms/library-atom"
import { 
  templatesAtom, 
  selectedTemplateNameAtom, 
  selectedTemplateAtom,
  templatesFolderIdAtom,
  templateLoadingAtom,
  templateErrorAtom,
  type Template
} from "@/atoms/template-atom"
import { useStorage } from "@/contexts/storage-context"

// Schema für Template-Daten
const templateSchema = z.object({
  name: z.string().min(1, "Prompt-Name ist erforderlich"),
  yamlFrontmatter: z.string(),
  markdownBody: z.string(),
  systemPrompt: z.string(),
})

type TemplateFormValues = z.infer<typeof templateSchema>

export function TemplateManagement() {
  const [previewMode, setPreviewMode] = useState(false)
  const [isSaving, setIsSaving] = useState(false)
  const [isTesting, setIsTesting] = useState(false)
  const [testResult, setTestResult] = useState<string | null>(null)
  const { toast } = useToast()

  // Atoms
  const [templates, setTemplates] = useAtom(templatesAtom)
  const [selectedTemplateName, setSelectedTemplateName] = useAtom(selectedTemplateNameAtom)
  const [selectedTemplate] = useAtom(selectedTemplateAtom)
  const [templatesFolderId, setTemplatesFolderId] = useAtom(templatesFolderIdAtom)
  const [isLoading, setIsLoading] = useAtom(templateLoadingAtom)
  const [error, setError] = useAtom(templateErrorAtom)

  // Library und Storage
  const activeLibrary = useAtomValue(activeLibraryAtom)
  const libraryStatus = useAtomValue(libraryStatusAtom)
  const { 
    provider: providerInstance, 
    listItems
  } = useStorage()

  const form = useForm<TemplateFormValues>({
    resolver: zodResolver(templateSchema),
    defaultValues: {
      name: "",
      yamlFrontmatter: `---
title: {{title|Titel des Dokuments}}
tags: {{tags|Relevante Tags}}
date: {{date|Datum im Format yyyy-mm-dd}}
---`,
      markdownBody: `# {{title}}

## Zusammenfassung
{{summary|Kurze Zusammenfassung des Inhalts}}

## Details
{{details|Detaillierte Beschreibung}}`,
      systemPrompt: `You are a specialized assistant that processes and structures information clearly and concisely.

IMPORTANT: Your response must be a valid JSON object where each key corresponds to a template variable.`,
    },
  })

  // Helper zum Erzeugen von Default-Werten
  function getDefaultTemplateValues(name: string): TemplateFormValues {
    return {
      name,
      yamlFrontmatter: `---\n` +
        `title: {{title|Titel des Dokuments}}\n` +
        `tags: {{tags|Relevante Tags}}\n` +
        `date: {{date|Datum im Format yyyy-mm-dd}}\n` +
        `---`,
      markdownBody: `# {{title}}\n\n## Zusammenfassung\n{{summary|Kurze Zusammenfassung des Inhalts}}\n\n## Details\n{{details|Detaillierte Beschreibung}}`,
      systemPrompt: `You are a specialized assistant that processes and structures information clearly and concisely.\n\nIMPORTANT: Your response must be a valid JSON object where each key corresponds to a template variable.`,
    }
  }

  // Template-Daten laden wenn sich die Auswahl ändert
  useEffect(() => {
    if (selectedTemplate) {
      form.reset({
        name: selectedTemplate.name,
        yamlFrontmatter: selectedTemplate.yamlFrontmatter,
        markdownBody: selectedTemplate.markdownBody,
        systemPrompt: selectedTemplate.systemPrompt,
      })
    }
  }, [selectedTemplate, form])

  // Ordner-Erstellung/Suche memoisiert, damit als Dep verwendbar
  const ensureTemplatesFolder = useCallback(async (): Promise<string> => {
    if (!providerInstance || !activeLibrary) {
      throw new Error("Keine aktive Bibliothek oder Provider verfügbar");
    }

    try {
      console.log('[TemplateManagement] Suche nach Templates-Ordner...');
      const rootItems = await listItems('root');
      const templatesFolder = rootItems.find(item => 
        item.type === 'folder' && item.metadata.name === 'templates'
      );
      if (templatesFolder) {
        console.log('[TemplateManagement] Templates-Ordner gefunden:', templatesFolder.id);
        return templatesFolder.id;
      }
      console.log('[TemplateManagement] Templates-Ordner nicht gefunden, erstelle neuen...');
      const newFolder = await providerInstance.createFolder('root', 'templates');
      console.log('[TemplateManagement] Neuer Templates-Ordner erstellt:', newFolder.id);
      return newFolder.id;
    } catch (error) {
      console.error('Fehler beim Erstellen des Templates-Ordners:', {
        error: error instanceof Error ? {
          message: error.message,
          name: error.name,
          stack: error.stack?.split('\n').slice(0, 3)
        } : error,
        libraryId: activeLibrary?.id,
        libraryPath: activeLibrary?.path,
        providerName: providerInstance?.name
      });
      let errorMessage = 'Fehler beim Erstellen des Templates-Ordners';
      if (error instanceof Error) {
        if (error.message.includes('Nicht authentifiziert')) {
          errorMessage = 'Bitte authentifizieren Sie sich bei Ihrem Cloud-Speicher, um den Templates-Ordner zu erstellen.';
        } else if (error.message.includes('Keine Berechtigung')) {
          errorMessage = 'Keine Berechtigung zum Erstellen von Ordnern in der Bibliothek.';
        } else if (error.message.includes('Bibliothek nicht gefunden')) {
          errorMessage = 'Die ausgewählte Bibliothek wurde nicht gefunden.';
        } else {
          errorMessage = `Fehler beim Erstellen des Templates-Ordners: ${error.message}`;
        }
      }
      throw new Error(errorMessage);
    }
  }, [providerInstance, activeLibrary, listItems]);

  // Templates laden mit der gleichen Logik wie Library-Komponente
  const loadTemplates = useCallback(async () => {
    if (!providerInstance || libraryStatus !== 'ready' || !activeLibrary) {
      console.log('[TemplateManagement] loadTemplates übersprungen:', {
        hasProvider: !!providerInstance,
        libraryStatus,
        hasActiveLibrary: !!activeLibrary
      });
      return;
    }

    try {
      setIsLoading(true);
      setError(null);

      console.log('[TemplateManagement] Starte Prompt-Loading:', {
        libraryId: activeLibrary.id,
        libraryPath: activeLibrary.path,
        providerName: providerInstance.name
      });

      // 1. Templates-Ordner finden oder erstellen
      const folderId = await ensureTemplatesFolder();
      setTemplatesFolderId(folderId);

      console.log('[TemplateManagement] Templates-Ordner gefunden/erstellt:', folderId);

      // 2. Alle Template-Dateien im Ordner auflisten
      const items = await listItems(folderId);
      const templateFiles = items.filter(item => 
        item.type === 'file' && 
        item.metadata.name.endsWith('.md')
      );

      console.log('[TemplateManagement] Prompt-Dateien gefunden:', templateFiles.length);

      // 3. Template-Inhalte laden
      const templatePromises = templateFiles.map(async (file) => {
        try {
          const { blob } = await providerInstance.getBinary(file.id);
          const content = await blob.text();
          const template = parseTemplateContent(content, file.metadata.name.replace('.md', ''));
          
          return {
            ...template,
            fileId: file.id,
            lastModified: typeof file.metadata.modifiedAt === 'string' 
              ? file.metadata.modifiedAt 
              : file.metadata.modifiedAt instanceof Date 
                ? file.metadata.modifiedAt.toISOString()
                : new Date().toISOString()
          } as Template;
        } catch (error) {
          console.error(`Fehler beim Parsen von ${file.metadata.name}:`, error);
          return null;
        }
      });

      const loadedTemplates = await Promise.all(templatePromises);
      const validTemplates = loadedTemplates.filter((t): t is Template => t !== null);
      
      setTemplates(validTemplates);
      
      console.log('[TemplateManagement] Prompts erfolgreich geladen:', validTemplates.length);
      
      if (validTemplates.length === 0) {
        toast({
          title: "Keine Prompts gefunden",
          description: "Erstellen Sie Ihren ersten Prompt im Verzeichnis '/templates'.",
        });
      }
    } catch (error) {
      console.error('Fehler beim Laden der Prompts:', {
        error: error instanceof Error ? {
          message: error.message,
          name: error.name,
          stack: error.stack?.split('\n').slice(0, 3)
        } : error,
        libraryId: activeLibrary?.id,
        libraryPath: activeLibrary?.path,
        providerName: providerInstance?.name
      });

      let errorMessage = 'Unbekannter Fehler beim Laden der Prompts';
      
      if (error instanceof Error) {
        errorMessage = error.message;
        
        // Spezifische Fehlermeldungen für häufige Probleme
        if (error.message.includes('Nicht authentifiziert')) {
          errorMessage = 'Bitte authentifizieren Sie sich bei Ihrem Cloud-Speicher, um Prompts zu laden.';
        } else if (error.message.includes('Bibliothek nicht gefunden')) {
          errorMessage = 'Die ausgewählte Bibliothek wurde nicht gefunden. Bitte überprüfen Sie die Bibliothekskonfiguration.';
        } else if (error.message.includes('Server-Fehler')) {
          errorMessage = 'Server-Fehler beim Laden der Prompts. Bitte überprüfen Sie, ob der Bibliothekspfad existiert und zugänglich ist.';
        } else if (error.message.includes('Keine aktive Bibliothek')) {
          errorMessage = 'Keine aktive Bibliothek verfügbar. Bitte wählen Sie eine Bibliothek aus.';
        }
      }
      
      setError(errorMessage);
      toast({
        title: "Fehler beim Laden der Prompts",
        description: errorMessage,
        variant: "destructive",
      });
    } finally {
      setIsLoading(false);
    }
  }, [providerInstance, libraryStatus, activeLibrary, listItems, setTemplates, setTemplatesFolderId, setIsLoading, setError, toast, ensureTemplatesFolder]);

  // Effect für Template Loading (wie Library-Komponente)
  useEffect(() => {
    const isReady = providerInstance && libraryStatus === 'ready' && activeLibrary
    
    if (!isReady) {
      return
    }

    // Templates laden wenn noch nicht geladen
    if (!templatesFolderId) {
      loadTemplates()
    }
  }, [providerInstance, libraryStatus, activeLibrary, templatesFolderId, loadTemplates])

  // Reset wenn sich die Library ändert
  useEffect(() => {
    setSelectedTemplateName(null)
    setTemplatesFolderId(null)
    setTemplates([])
    setError(null)
  }, [libraryStatus, setSelectedTemplateName, setTemplatesFolderId, setTemplates, setError])

  function parseTemplateContent(content: string, fileName: string): Template {
    // Template in drei Bereiche aufteilen
    const parts = content.split('--- systemprompt')
    
    let yamlFrontmatter = ""
    let markdownBody = ""
    let systemPrompt = ""
    
    if (parts.length >= 2) {
      const mainContent = parts[0].trim()
      systemPrompt = parts[1].trim()
      
      // YAML Frontmatter extrahieren
      const yamlMatch = mainContent.match(/^---\n([\s\S]*?)\n---\n([\s\S]*)$/)
      if (yamlMatch) {
        yamlFrontmatter = `---\n${yamlMatch[1]}\n---`
        markdownBody = yamlMatch[2].trim()
      } else {
        // Kein YAML Frontmatter gefunden
        markdownBody = mainContent
      }
    } else {
      // Kein Systemprompt gefunden
      const yamlMatch = content.match(/^---\n([\s\S]*?)\n---\n([\s\S]*)$/)
      if (yamlMatch) {
        yamlFrontmatter = `---\n${yamlMatch[1]}\n---`
        markdownBody = yamlMatch[2].trim()
      } else {
        markdownBody = content
      }
    }

    return {
      name: fileName,
      yamlFrontmatter,
      markdownBody,
      systemPrompt,
    }
  }

  function generateTemplateContent(values: TemplateFormValues): string {
    let content = ""
    
    // YAML Frontmatter hinzufügen
    if (values.yamlFrontmatter.trim()) {
      content += values.yamlFrontmatter + "\n\n"
    }
    
    // Markdown Body hinzufügen
    content += values.markdownBody
    
    // System Prompt hinzufügen
    if (values.systemPrompt.trim()) {
      content += "\n\n--- systemprompt\n" + values.systemPrompt
    }
    
    return content
  }

  async function onSubmit(data: TemplateFormValues) {
    if (!activeLibrary || !templatesFolderId || !providerInstance) {
      toast({
        title: "Fehler",
        description: "Keine aktive Bibliothek oder Templates-Ordner nicht gefunden.",
        variant: "destructive",
      })
      return
    }

    setIsSaving(true)
    try {
      const templateContent = generateTemplateContent(data)
      const fileName = `${data.name}.md`
      
      // Datei als Blob erstellen
      const blob = new Blob([templateContent], { type: 'text/markdown' })
      const file = new File([blob], fileName, { type: 'text/markdown' })
      
      // Datei hochladen
      await providerInstance.uploadFile(templatesFolderId, file)
      
      // Templates neu laden
      await loadTemplates()
      
      // Auswahl auf das neue Template setzen
      setSelectedTemplateName(data.name)
      
      toast({
        title: "Template gespeichert",
        description: `Template "${data.name}" wurde erfolgreich im Verzeichnis "/templates" gespeichert.`,
      })
    } catch (error) {
      console.error('Fehler beim Speichern des Templates:', error)
      toast({
        title: "Fehler beim Speichern",
        description: error instanceof Error ? error.message : "Unbekannter Fehler",
        variant: "destructive",
      })
    } finally {
      setIsSaving(false)
    }
  }

  async function renameCurrentTemplate() {
    const current = selectedTemplateName ? templates.find(t => t.name === selectedTemplateName) : null
    if (!current || !current.fileId || !providerInstance) return
    const newName = (window.prompt('Neuen Namen eingeben:', current.name) || '').trim()
    if (!newName || newName === current.name) return
    if (/[^a-zA-Z0-9._\- ]/.test(newName)) { toast({ title: 'Ungültiger Name', description: 'Nur Buchstaben, Zahlen, Leerzeichen, . _ - sind erlaubt.', variant: 'destructive' }); return }
    if (templates.some(t => t.name.toLowerCase() === newName.toLowerCase())) { toast({ title: 'Bereits vorhanden', description: 'Bitte anderen Namen wählen.', variant: 'destructive' }); return }
    try {
      await providerInstance.renameItem(current.fileId, `${newName}.md`)
      await loadTemplates()
      setSelectedTemplateName(newName)
      form.setValue('name', newName, { shouldDirty: false })
      toast({ title: 'Umbenannt', description: `${current.name} → ${newName}` })
    } catch (e) {
      toast({ title: 'Fehler beim Umbenennen', description: e instanceof Error ? e.message : 'Unbekannter Fehler', variant: 'destructive' })
    }
  }

  async function deleteTemplate(templateName: string) {
    if (!activeLibrary || !providerInstance) return

    try {
      const template = templates.find(t => t.name === templateName)
      if (!template?.fileId) {
        throw new Error("Template-Datei nicht gefunden")
      }

      // Datei löschen
      await providerInstance.deleteItem(template.fileId)

      // Templates neu laden
      await loadTemplates()
      
      if (selectedTemplateName === templateName) {
        setSelectedTemplateName(null)
        form.reset()
      }
      
      toast({
        title: "Template gelöscht",
        description: `Template "${templateName}" wurde erfolgreich gelöscht.`,
      })
    } catch (error) {
      console.error('Fehler beim Löschen des Templates:', error)
      toast({
        title: "Fehler beim Löschen",
        description: error instanceof Error ? error.message : "Unbekannter Fehler",
        variant: "destructive",
      })
    }
  }

  async function createNewTemplate() {
    const name = (window.prompt('Neuen Template‑Namen eingeben:') || '').trim()
    if (!name) return
    if (/[^a-zA-Z0-9._\- ]/.test(name)) { toast({ title: 'Ungültiger Name', description: 'Nur Buchstaben, Zahlen, Leerzeichen, . _ - sind erlaubt.', variant: 'destructive' }); return }
    if (templates.some(t => t.name.toLowerCase() === name.toLowerCase())) { toast({ title: 'Bereits vorhanden', description: 'Bitte anderen Namen wählen.', variant: 'destructive' }); return }
    if (!providerInstance) { toast({ title: 'Kein Provider' , variant: 'destructive' }); return }
    try {
      const folderId = await ensureTemplatesFolder()
      const values = getDefaultTemplateValues(name)
      const content = (values.yamlFrontmatter ? values.yamlFrontmatter + '\n\n' : '') + values.markdownBody + '\n\n--- systemprompt\n' + values.systemPrompt
      const file = new File([new Blob([content], { type: 'text/markdown' })], `${name}.md`, { type: 'text/markdown' })
      await providerInstance.uploadFile(folderId, file)
      await loadTemplates()
      setSelectedTemplateName(name)
      form.reset(values)
      toast({ title: 'Template angelegt', description: `"${name}" wurde erstellt.` })
    } catch (e) {
      toast({ title: 'Fehler beim Anlegen', description: e instanceof Error ? e.message : 'Unbekannter Fehler', variant: 'destructive' })
    }
  }

  function generatePreview(): string {
    const values = form.getValues()
    return generateTemplateContent(values)
  }

  async function testTemplate() {
    if (!activeLibrary) return

    setIsTesting(true)
    setTestResult(null)

    const values = form.getValues()
    const templateContent = generateTemplateContent(values)
    
    // Testtext aus dem Textarea lesen
    const testTextarea = document.querySelector('textarea[placeholder="Geben Sie einen Testtext ein..."]') as HTMLTextAreaElement
    const testText = testTextarea?.value || "Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed eiusmod tempor incidunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquid ex ea commodi consequat. Quis aute iure reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint obcaecat cupiditat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum."
    
    try {
      const response = await fetch('/api/secretary/process-text', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/x-www-form-urlencoded',
          'X-Library-Id': activeLibrary.id,
        },
        body: new URLSearchParams({
          text: testText,
          template_content: templateContent,
          source_language: 'de',
          target_language: 'de',
        }),
      })

      if (!response.ok) {
        const errorData = await response.json()
        throw new Error(errorData.error || `HTTP ${response.status}: ${response.statusText}`)
      }

      const result = await response.json()
      
      // Ergebnis formatieren und anzeigen
      const formattedResult = JSON.stringify(result, null, 2)
      setTestResult(formattedResult)
      
      toast({
        title: "Template-Test erfolgreich",
        description: "Das Template wurde erfolgreich mit dem Testtext verarbeitet.",
      })
      
      console.log('Template-Test Ergebnis:', result)
    } catch (error) {
      console.error('Fehler beim Template-Test:', error)
      const errorMessage = error instanceof Error ? error.message : "Unbekannter Fehler"
      setTestResult(`Fehler: ${errorMessage}`)
      toast({
        title: "Template-Test fehlgeschlagen",
        description: errorMessage,
        variant: "destructive",
      })
    } finally {
      setIsTesting(false)
    }
  }

  // Render-Logik für verschiedene Status
  if (libraryStatus === "waitingForAuth") {
    return (
      <div className="flex flex-col items-center justify-center h-full text-muted-foreground">
        <span>Diese Bibliothek benötigt eine Authentifizierung.</span>
        <span className="text-sm mt-2">Bitte konfigurieren Sie die Bibliothek in den Einstellungen.</span>
      </div>
    )
  }
  
  if (libraryStatus !== "ready") {
    return (
      <div className="flex flex-col items-center justify-center h-full text-muted-foreground">
        <span>Lade Storage...</span>
      </div>
    )
  }

  if (!activeLibrary) {
    return (
      <div className="text-center text-muted-foreground">
        Bitte wählen Sie eine Bibliothek aus.
      </div>
    )
  }

  if (error) {
    return (
      <div className="text-center text-destructive">
        <p>Fehler beim Laden der Prompts:</p>
        <p className="text-sm">{error}</p>
        <Button 
          variant="outline" 
          className="mt-4"
          onClick={loadTemplates}
        >
          Erneut versuchen
        </Button>
      </div>
    )
  }

  return (
    <div className="space-y-6">

      {/* Kompakte Toolbar oben */}
      <div className="flex items-center gap-2">
        <Select value={selectedTemplateName || ''} onValueChange={(v) => { setSelectedTemplateName(v); form.setValue('name', v, { shouldDirty: false }) }} disabled={isLoading}>
          <SelectTrigger className="w-64">
            <SelectValue placeholder="Prompt auswählen..." />
          </SelectTrigger>
          <SelectContent>
            {templates.map((t) => (
              <SelectItem key={t.name} value={t.name}>{t.name}</SelectItem>
            ))}
          </SelectContent>
        </Select>
        <TooltipProvider>
          <Tooltip>
            <TooltipTrigger asChild>
              <Button variant="ghost" size="sm" className="h-8 w-8 p-0"><Info className="h-4 w-4" /></Button>
            </TooltipTrigger>
            <TooltipContent>
              <div className="flex items-center gap-2"><FolderOpen className="h-4 w-4" /><span>Ort: /templates in „{activeLibrary.label}“</span></div>
            </TooltipContent>
          </Tooltip>
        </TooltipProvider>
        <Button type="button" variant="outline" size="sm" onClick={createNewTemplate} disabled={isLoading}>Neu</Button>
        <Button type="button" variant="outline" size="sm" onClick={renameCurrentTemplate} disabled={!selectedTemplateName}>Umbenennen</Button>
        {selectedTemplateName && (
          <Button type="button" variant="destructive" size="sm" onClick={() => deleteTemplate(selectedTemplateName!)}>Löschen</Button>
        )}
      </div>

      <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
        <Card>
          <CardHeader>
            <CardTitle>Prompt Design</CardTitle>
            <CardDescription>
              Drei Bereiche: Rollenanweisung (wie), Aufgabe (was), Metadaten (Begleitinfos).
            </CardDescription>
          </CardHeader>
          <CardContent>
            <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-6">
              {/* Template-Name Feld entfernt (oben verwaltet) */}

              {previewMode ? (
                <div className="space-y-4">
                  <div className="flex items-center justify-between">
                    <h4 className="text-sm font-medium">Prompt-Vorschau</h4>
                    <Button
                      type="button"
                      variant="outline"
                      size="sm"
                      onClick={() => setPreviewMode(false)}
                    >
                      Bearbeiten
                    </Button>
                  </div>
                  <div className="border rounded-md p-4 bg-muted/50">
                    <pre className="text-sm whitespace-pre-wrap font-mono">
                      {generatePreview()}
                    </pre>
                  </div>
                </div>
              ) : (
                <StructuredTemplateEditor
                  markdownBody={form.watch('markdownBody')}
                  yamlFrontmatter={form.watch('yamlFrontmatter')}
                  systemPrompt={form.watch('systemPrompt')}
                  onChange={({ markdownBody, yamlFrontmatter, systemPrompt }) => {
                    form.setValue('markdownBody', markdownBody, { shouldDirty: true })
                    form.setValue('yamlFrontmatter', yamlFrontmatter, { shouldDirty: true })
                    form.setValue('systemPrompt', systemPrompt, { shouldDirty: true })
                  }}
                />
              )}

              <div className="flex justify-end gap-2">
                <Button
                  type="button"
                  variant="outline"
                  onClick={() => setPreviewMode(!previewMode)}
                >
                  <Eye className="h-4 w-4 mr-2" />
                  {previewMode ? "Bearbeiten" : "Vorschau"}
                </Button>
                <Button
                  type="submit"
                  disabled={isSaving || !form.formState.isDirty}
                >
                  {isSaving ? (
                    <>
                      <Loader2 className="h-4 w-4 mr-2 animate-spin" />
                      Wird gespeichert...
                    </>
                  ) : (
                    <>
                      <Save className="h-4 w-4 mr-2" />
                      Speichern
                    </>
                  )}
                </Button>
              </div>
            </form>
          </CardContent>
        </Card>

        <Card>
          <CardHeader>
            <CardTitle>Prompt testen</CardTitle>
            <CardDescription>
              Test mit Beispieltext. Nutzt Rollenanweisung, Aufgabe und Ausgabeformat des Prompts.
            </CardDescription>
          </CardHeader>
          <CardContent>
            <div className="space-y-4">
              <div className="space-y-2">
                <Label>Test-Text</Label>
                <Textarea
                  placeholder="Geben Sie einen Testtext ein..."
                  className="min-h-[100px]"
                  defaultValue="Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed eiusmod tempor incidunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquid ex ea commodi consequat. Quis aute iure reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint obcaecat cupiditat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum."
                />
              </div>
              <div className="flex gap-2">
                <Button 
                  variant="outline" 
                  size="sm"
                  onClick={testTemplate}
                  disabled={!selectedTemplateName || isTesting}
                >
                  {isTesting ? (
                    <>
                      <Loader2 className="h-4 w-4 mr-2 animate-spin" />
                      Teste...
                    </>
                  ) : (
                    <>
                      <Play className="h-4 w-4 mr-2" />
                      Prompt testen
                    </>
                  )}
                </Button>
              </div>
              
              {testResult && (
                <div className="space-y-2">
                  <Label>Test-Ergebnis</Label>
                  <div className="border rounded-md p-4 bg-muted/50">
                    <pre className="text-sm whitespace-pre-wrap font-mono max-h-[300px] overflow-y-auto">
                      {testResult}
                    </pre>
                  </div>
                </div>
              )}
            </div>
          </CardContent>
        </Card>
      </div>
    </div>
  )
} 
```

- Begriffe angepasst:
  - Tab „Ausgabeformat“ → „Metadaten“ in `structured-template-editor.tsx`.
  - Beschreibung im Bereich „Prompt Design“ nennt jetzt: Rollenanweisung, Aufgabe, Metadaten in `template-management.tsx`.

- Wirkung:
  - Metadaten-Tab zeigt weiterhin die Frontmatter-Felder (gleiches Verhalten), ist aber für Nutzer klarer benannt.

---

**User**

Schauen wir uns jetzt nochmal diese gesamte Template-Verwaltung an. Links habe ich ja diesen Prompt-Design-Bereich, wo ich das Prompt editieren kann, und rechts den Prompt-Testen-Bereich. Oben habe ich eine Liste von Kontext-Texten, die ich auswählen können möchte. Darunter ein Test-Text, der ist veraltet. Dort sollten die Texte angezeigt werden, die man oben auswählt, nicht editieren können muss. Und dann habe ich diesen Prompt-Testen-Button. Wie könnten wir das jetzt besser organisieren?
Jetzt nicht noch eine Antwortvorschau, wo wir praktisch diesen Template-Body-Bereich, das was heute in der Vorschau steht, als Markdown fertig anzeigen, evtl. noch mit diesen Platzhaltern drinnen. Und dann kann ich links, wenn ich dann das Prompt teste, dann würde ich dann das Ergebnis sehen, auch als Markdown. Wie könnte man das noch anpassen? Auf der rechten Seite.


Verstehen wir den Flow des Anwenders? Wie er arbeitet, können wir das nochmal zusammenfassen?

---

**Cursor**

Ich füge jetzt in der rechten Spalte folgende Anpassungen ein: oben eine Auswahl/Anzeige der Kontext-Texte (nicht editierbar), darunter eine „Antwortvorschau“ des aktuellen Prompt-Bodys als Markdown, danach den Test-Button und schließlich einen Markdown-Bereich für das Testergebnis. Ich passe `template-management.tsx` entsprechend an und nutze vorhandene UI-Komponenten. Danach prüfe ich kurz den Linter.

```typescriptreact
"use client"

import { useState, useEffect, useCallback } from "react"
import { useForm } from "react-hook-form"
import { zodResolver } from "@hookform/resolvers/zod"
import * as z from "zod"
import { Button } from "@/components/ui/button"
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card"
import { Input } from "@/components/ui/input"
import { Label } from "@/components/ui/label"
import { Textarea } from "@/components/ui/textarea"
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs"
import { Badge } from "@/components/ui/badge"
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select"
import { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from "@/components/ui/tooltip"
import { Dialog, DialogContent, DialogHeader, DialogTitle, DialogFooter } from "@/components/ui/dialog"
import { StructuredTemplateEditor } from "@/components/templates/structured-template-editor"
import { useToast } from "@/hooks/use-toast"
import { Loader2, Save, Plus, Trash2, Eye, Play, FolderOpen, Info } from "lucide-react"
import { useAtom, useAtomValue } from "jotai"
import { activeLibraryAtom, libraryStatusAtom } from "@/atoms/library-atom"
import { 
  templatesAtom, 
  selectedTemplateNameAtom, 
  selectedTemplateAtom,
  templatesFolderIdAtom,
  templateLoadingAtom,
  templateErrorAtom,
  type Template
} from "@/atoms/template-atom"
import { useStorage } from "@/contexts/storage-context"
import { templateContextDocsAtom } from '@/atoms/template-context-atom'
import { Checkbox } from "@/components/ui/checkbox"
import { MarkdownPreview } from "@/components/library/markdown-preview"

// Schema für Template-Daten
const templateSchema = z.object({
  name: z.string().min(1, "Prompt-Name ist erforderlich"),
  yamlFrontmatter: z.string(),
  markdownBody: z.string(),
  systemPrompt: z.string(),
})

type TemplateFormValues = z.infer<typeof templateSchema>

export function TemplateManagement() {
  const [previewMode, setPreviewMode] = useState(false)
  const [isSaving, setIsSaving] = useState(false)
  const [isTesting, setIsTesting] = useState(false)
  const [testResult, setTestResult] = useState<string | null>(null)
  const [selectedContextIds, setSelectedContextIds] = useState<string[]>([])
  const [selectedContextMarkdown, setSelectedContextMarkdown] = useState<string>("")
  const { toast } = useToast()

  // Atoms
  const [templates, setTemplates] = useAtom(templatesAtom)
  const [selectedTemplateName, setSelectedTemplateName] = useAtom(selectedTemplateNameAtom)
  const [selectedTemplate] = useAtom(selectedTemplateAtom)
  const [templatesFolderId, setTemplatesFolderId] = useAtom(templatesFolderIdAtom)
  const [isLoading, setIsLoading] = useAtom(templateLoadingAtom)
  const [error, setError] = useAtom(templateErrorAtom)

  // Library und Storage
  const activeLibrary = useAtomValue(activeLibraryAtom)
  const libraryStatus = useAtomValue(libraryStatusAtom)
  const { 
    provider: providerInstance, 
    listItems
  } = useStorage()
  const contextDocs = useAtomValue(templateContextDocsAtom)

  const form = useForm<TemplateFormValues>({
    resolver: zodResolver(templateSchema),
    defaultValues: {
      name: "",
      yamlFrontmatter: `---
title: {{title|Titel des Dokuments}}
tags: {{tags|Relevante Tags}}
date: {{date|Datum im Format yyyy-mm-dd}}
---`,
      markdownBody: `# {{title}}

## Zusammenfassung
{{summary|Kurze Zusammenfassung des Inhalts}}

## Details
{{details|Detaillierte Beschreibung}}`,
      systemPrompt: `You are a specialized assistant that processes and structures information clearly and concisely.

IMPORTANT: Your response must be a valid JSON object where each key corresponds to a template variable.`,
    },
  })

  // Helper zum Erzeugen von Default-Werten
  function getDefaultTemplateValues(name: string): TemplateFormValues {
    return {
      name,
      yamlFrontmatter: `---\n` +
        `title: {{title|Titel des Dokuments}}\n` +
        `tags: {{tags|Relevante Tags}}\n` +
        `date: {{date|Datum im Format yyyy-mm-dd}}\n` +
        `---`,
      markdownBody: `# {{title}}\n\n## Zusammenfassung\n{{summary|Kurze Zusammenfassung des Inhalts}}\n\n## Details\n{{details|Detaillierte Beschreibung}}`,
      systemPrompt: `You are a specialized assistant that processes and structures information clearly and concisely.\n\nIMPORTANT: Your response must be a valid JSON object where each key corresponds to a template variable.`,
    }
  }

  // Template-Daten laden wenn sich die Auswahl ändert
  useEffect(() => {
    if (selectedTemplate) {
      form.reset({
        name: selectedTemplate.name,
        yamlFrontmatter: selectedTemplate.yamlFrontmatter,
        markdownBody: selectedTemplate.markdownBody,
        systemPrompt: selectedTemplate.systemPrompt,
      })
    }
  }, [selectedTemplate, form])

  // Ordner-Erstellung/Suche memoisiert, damit als Dep verwendbar
  const ensureTemplatesFolder = useCallback(async (): Promise<string> => {
    if (!providerInstance || !activeLibrary) {
      throw new Error("Keine aktive Bibliothek oder Provider verfügbar");
    }

    try {
      console.log('[TemplateManagement] Suche nach Templates-Ordner...');
      const rootItems = await listItems('root');
      const templatesFolder = rootItems.find(item => 
        item.type === 'folder' && item.metadata.name === 'templates'
      );
      if (templatesFolder) {
        console.log('[TemplateManagement] Templates-Ordner gefunden:', templatesFolder.id);
        return templatesFolder.id;
      }
      console.log('[TemplateManagement] Templates-Ordner nicht gefunden, erstelle neuen...');
      const newFolder = await providerInstance.createFolder('root', 'templates');
      console.log('[TemplateManagement] Neuer Templates-Ordner erstellt:', newFolder.id);
      return newFolder.id;
    } catch (error) {
      console.error('Fehler beim Erstellen des Templates-Ordners:', {
        error: error instanceof Error ? {
          message: error.message,
          name: error.name,
          stack: error.stack?.split('\n').slice(0, 3)
        } : error,
        libraryId: activeLibrary?.id,
        libraryPath: activeLibrary?.path,
        providerName: providerInstance?.name
      });
      let errorMessage = 'Fehler beim Erstellen des Templates-Ordners';
      if (error instanceof Error) {
        if (error.message.includes('Nicht authentifiziert')) {
          errorMessage = 'Bitte authentifizieren Sie sich bei Ihrem Cloud-Speicher, um den Templates-Ordner zu erstellen.';
        } else if (error.message.includes('Keine Berechtigung')) {
          errorMessage = 'Keine Berechtigung zum Erstellen von Ordnern in der Bibliothek.';
        } else if (error.message.includes('Bibliothek nicht gefunden')) {
          errorMessage = 'Die ausgewählte Bibliothek wurde nicht gefunden.';
        } else {
          errorMessage = `Fehler beim Erstellen des Templates-Ordners: ${error.message}`;
        }
      }
      throw new Error(errorMessage);
    }
  }, [providerInstance, activeLibrary, listItems]);

  // Templates laden mit der gleichen Logik wie Library-Komponente
  const loadTemplates = useCallback(async () => {
    if (!providerInstance || libraryStatus !== 'ready' || !activeLibrary) {
      console.log('[TemplateManagement] loadTemplates übersprungen:', {
        hasProvider: !!providerInstance,
        libraryStatus,
        hasActiveLibrary: !!activeLibrary
      });
      return;
    }

    try {
      setIsLoading(true);
      setError(null);

      console.log('[TemplateManagement] Starte Prompt-Loading:', {
        libraryId: activeLibrary.id,
        libraryPath: activeLibrary.path,
        providerName: providerInstance.name
      });

      // 1. Templates-Ordner finden oder erstellen
      const folderId = await ensureTemplatesFolder();
      setTemplatesFolderId(folderId);

      console.log('[TemplateManagement] Templates-Ordner gefunden/erstellt:', folderId);

      // 2. Alle Template-Dateien im Ordner auflisten
      const items = await listItems(folderId);
      const templateFiles = items.filter(item => 
        item.type === 'file' && 
        item.metadata.name.endsWith('.md')
      );

      console.log('[TemplateManagement] Prompt-Dateien gefunden:', templateFiles.length);

      // 3. Template-Inhalte laden
      const templatePromises = templateFiles.map(async (file) => {
        try {
          const { blob } = await providerInstance.getBinary(file.id);
          const content = await blob.text();
          const template = parseTemplateContent(content, file.metadata.name.replace('.md', ''));
          
          return {
            ...template,
            fileId: file.id,
            lastModified: typeof file.metadata.modifiedAt === 'string' 
              ? file.metadata.modifiedAt 
              : file.metadata.modifiedAt instanceof Date 
                ? file.metadata.modifiedAt.toISOString()
                : new Date().toISOString()
          } as Template;
        } catch (error) {
          console.error(`Fehler beim Parsen von ${file.metadata.name}:`, error);
          return null;
        }
      });

      const loadedTemplates = await Promise.all(templatePromises);
      const validTemplates = loadedTemplates.filter((t): t is Template => t !== null);
      
      setTemplates(validTemplates);
      
      console.log('[TemplateManagement] Prompts erfolgreich geladen:', validTemplates.length);
      
      if (validTemplates.length === 0) {
        toast({
          title: "Keine Prompts gefunden",
          description: "Erstellen Sie Ihren ersten Prompt im Verzeichnis '/templates'.",
        });
      }
    } catch (error) {
      console.error('Fehler beim Laden der Prompts:', {
        error: error instanceof Error ? {
          message: error.message,
          name: error.name,
          stack: error.stack?.split('\n').slice(0, 3)
        } : error,
        libraryId: activeLibrary?.id,
        libraryPath: activeLibrary?.path,
        providerName: providerInstance?.name
      });

      let errorMessage = 'Unbekannter Fehler beim Laden der Prompts';
      
      if (error instanceof Error) {
        errorMessage = error.message;
        
        // Spezifische Fehlermeldungen für häufige Probleme
        if (error.message.includes('Nicht authentifiziert')) {
          errorMessage = 'Bitte authentifizieren Sie sich bei Ihrem Cloud-Speicher, um Prompts zu laden.';
        } else if (error.message.includes('Bibliothek nicht gefunden')) {
          errorMessage = 'Die ausgewählte Bibliothek wurde nicht gefunden. Bitte überprüfen Sie die Bibliothekskonfiguration.';
        } else if (error.message.includes('Server-Fehler')) {
          errorMessage = 'Server-Fehler beim Laden der Prompts. Bitte überprüfen Sie, ob der Bibliothekspfad existiert und zugänglich ist.';
        } else if (error.message.includes('Keine aktive Bibliothek')) {
          errorMessage = 'Keine aktive Bibliothek verfügbar. Bitte wählen Sie eine Bibliothek aus.';
        }
      }
      
      setError(errorMessage);
      toast({
        title: "Fehler beim Laden der Prompts",
        description: errorMessage,
        variant: "destructive",
      });
    } finally {
      setIsLoading(false);
    }
  }, [providerInstance, libraryStatus, activeLibrary, listItems, setTemplates, setTemplatesFolderId, setIsLoading, setError, toast, ensureTemplatesFolder]);

  // Effect für Template Loading (wie Library-Komponente)
  useEffect(() => {
    const isReady = providerInstance && libraryStatus === 'ready' && activeLibrary
    
    if (!isReady) {
      return
    }

    // Templates laden wenn noch nicht geladen
    if (!templatesFolderId) {
      loadTemplates()
    }
  }, [providerInstance, libraryStatus, activeLibrary, templatesFolderId, loadTemplates])

  // Reset wenn sich die Library ändert
  useEffect(() => {
    setSelectedTemplateName(null)
    setTemplatesFolderId(null)
    setTemplates([])
    setError(null)
  }, [libraryStatus, setSelectedTemplateName, setTemplatesFolderId, setTemplates, setError])

  useEffect(() => {
    async function loadSelectedContext() {
      if (!providerInstance || !Array.isArray(selectedContextIds) || selectedContextIds.length === 0) {
        setSelectedContextMarkdown("")
        return
      }
      try {
        const parts: string[] = []
        for (const id of selectedContextIds) {
          const { blob } = await providerInstance.getBinary(id)
          const text = await blob.text()
          parts.push(text)
        }
        setSelectedContextMarkdown(parts.join("\n\n---\n\n"))
      } catch (e) {
        console.error('Fehler beim Laden des Kontextes', e)
        setSelectedContextMarkdown("")
      }
    }
    void loadSelectedContext()
  }, [providerInstance, selectedContextIds])

  function parseTemplateContent(content: string, fileName: string): Template {
    // Template in drei Bereiche aufteilen
    const parts = content.split('--- systemprompt')
    
    let yamlFrontmatter = ""
    let markdownBody = ""
    let systemPrompt = ""
    
    if (parts.length >= 2) {
      const mainContent = parts[0].trim()
      systemPrompt = parts[1].trim()
      
      // YAML Frontmatter extrahieren
      const yamlMatch = mainContent.match(/^---\n([\s\S]*?)\n---\n([\s\S]*)$/)
      if (yamlMatch) {
        yamlFrontmatter = `---\n${yamlMatch[1]}\n---`
        markdownBody = yamlMatch[2].trim()
      } else {
        // Kein YAML Frontmatter gefunden
        markdownBody = mainContent
      }
    } else {
      // Kein Systemprompt gefunden
      const yamlMatch = content.match(/^---\n([\s\S]*?)\n---\n([\s\S]*)$/)
      if (yamlMatch) {
        yamlFrontmatter = `---\n${yamlMatch[1]}\n---`
        markdownBody = yamlMatch[2].trim()
      } else {
        markdownBody = content
      }
    }

    return {
      name: fileName,
      yamlFrontmatter,
      markdownBody,
      systemPrompt,
    }
  }

  function generateTemplateContent(values: TemplateFormValues): string {
    let content = ""
    
    // YAML Frontmatter hinzufügen
    if (values.yamlFrontmatter.trim()) {
      content += values.yamlFrontmatter + "\n\n"
    }
    
    // Markdown Body hinzufügen
    content += values.markdownBody
    
    // System Prompt hinzufügen
    if (values.systemPrompt.trim()) {
      content += "\n\n--- systemprompt\n" + values.systemPrompt
    }
    
    return content
  }

  async function onSubmit(data: TemplateFormValues) {
    if (!activeLibrary || !templatesFolderId || !providerInstance) {
      toast({
        title: "Fehler",
        description: "Keine aktive Bibliothek oder Templates-Ordner nicht gefunden.",
        variant: "destructive",
      })
      return
    }

    setIsSaving(true)
    try {
      const templateContent = generateTemplateContent(data)
      const fileName = `${data.name}.md`
      
      // Datei als Blob erstellen
      const blob = new Blob([templateContent], { type: 'text/markdown' })
      const file = new File([blob], fileName, { type: 'text/markdown' })
      
      // Datei hochladen
      await providerInstance.uploadFile(templatesFolderId, file)
      
      // Templates neu laden
      await loadTemplates()
      
      // Auswahl auf das neue Template setzen
      setSelectedTemplateName(data.name)
      
      toast({
        title: "Template gespeichert",
        description: `Template "${data.name}" wurde erfolgreich im Verzeichnis "/templates" gespeichert.`,
      })
    } catch (error) {
      console.error('Fehler beim Speichern des Templates:', error)
      toast({
        title: "Fehler beim Speichern",
        description: error instanceof Error ? error.message : "Unbekannter Fehler",
        variant: "destructive",
      })
    } finally {
      setIsSaving(false)
    }
  }

  async function renameCurrentTemplate() {
    const current = selectedTemplateName ? templates.find(t => t.name === selectedTemplateName) : null
    if (!current || !current.fileId || !providerInstance) return
    const newName = (window.prompt('Neuen Namen eingeben:', current.name) || '').trim()
    if (!newName || newName === current.name) return
    if (/[^a-zA-Z0-9._\- ]/.test(newName)) { toast({ title: 'Ungültiger Name', description: 'Nur Buchstaben, Zahlen, Leerzeichen, . _ - sind erlaubt.', variant: 'destructive' }); return }
    if (templates.some(t => t.name.toLowerCase() === newName.toLowerCase())) { toast({ title: 'Bereits vorhanden', description: 'Bitte anderen Namen wählen.', variant: 'destructive' }); return }
    try {
      await providerInstance.renameItem(current.fileId, `${newName}.md`)
      await loadTemplates()
      setSelectedTemplateName(newName)
      form.setValue('name', newName, { shouldDirty: false })
      toast({ title: 'Umbenannt', description: `${current.name} → ${newName}` })
    } catch (e) {
      toast({ title: 'Fehler beim Umbenennen', description: e instanceof Error ? e.message : 'Unbekannter Fehler', variant: 'destructive' })
    }
  }

  async function deleteTemplate(templateName: string) {
    if (!activeLibrary || !providerInstance) return

    try {
      const template = templates.find(t => t.name === templateName)
      if (!template?.fileId) {
        throw new Error("Template-Datei nicht gefunden")
      }

      // Datei löschen
      await providerInstance.deleteItem(template.fileId)

      // Templates neu laden
      await loadTemplates()
      
      if (selectedTemplateName === templateName) {
        setSelectedTemplateName(null)
        form.reset()
      }
      
      toast({
        title: "Template gelöscht",
        description: `Template "${templateName}" wurde erfolgreich gelöscht.`,
      })
    } catch (error) {
      console.error('Fehler beim Löschen des Templates:', error)
      toast({
        title: "Fehler beim Löschen",
        description: error instanceof Error ? error.message : "Unbekannter Fehler",
        variant: "destructive",
      })
    }
  }

  async function createNewTemplate() {
    const name = (window.prompt('Neuen Template‑Namen eingeben:') || '').trim()
    if (!name) return
    if (/[^a-zA-Z0-9._\- ]/.test(name)) { toast({ title: 'Ungültiger Name', description: 'Nur Buchstaben, Zahlen, Leerzeichen, . _ - sind erlaubt.', variant: 'destructive' }); return }
    if (templates.some(t => t.name.toLowerCase() === name.toLowerCase())) { toast({ title: 'Bereits vorhanden', description: 'Bitte anderen Namen wählen.', variant: 'destructive' }); return }
    if (!providerInstance) { toast({ title: 'Kein Provider' , variant: 'destructive' }); return }
    try {
      const folderId = await ensureTemplatesFolder()
      const values = getDefaultTemplateValues(name)
      const content = (values.yamlFrontmatter ? values.yamlFrontmatter + '\n\n' : '') + values.markdownBody + '\n\n--- systemprompt\n' + values.systemPrompt
      const file = new File([new Blob([content], { type: 'text/markdown' })], `${name}.md`, { type: 'text/markdown' })
      await providerInstance.uploadFile(folderId, file)
      await loadTemplates()
      setSelectedTemplateName(name)
      form.reset(values)
      toast({ title: 'Template angelegt', description: `"${name}" wurde erstellt.` })
    } catch (e) {
      toast({ title: 'Fehler beim Anlegen', description: e instanceof Error ? e.message : 'Unbekannter Fehler', variant: 'destructive' })
    }
  }

  function generatePreview(): string {
    const values = form.getValues()
    return generateTemplateContent(values)
  }

  async function testTemplate() {
    if (!activeLibrary) return

    setIsTesting(true)
    setTestResult(null)

    const values = form.getValues()
    const templateContent = generateTemplateContent(values)
    const testText = selectedContextMarkdown || ""

    try {
      const response = await fetch('/api/secretary/process-text', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/x-www-form-urlencoded',
          'X-Library-Id': activeLibrary.id,
        },
        body: new URLSearchParams({
          text: testText,
          template_content: templateContent,
          source_language: 'de',
          target_language: 'de',
        }),
      })

      if (!response.ok) {
        const errorData = await response.json()
        throw new Error(errorData.error || `HTTP ${response.status}: ${response.statusText}`)
      }

      const result = await response.json()
      const formattedResult = typeof result === 'string' ? result : JSON.stringify(result, null, 2)
      setTestResult(formattedResult)

      toast({
        title: "Prompt-Test erfolgreich",
        description: "Der Prompt wurde erfolgreich mit dem gewählten Kontext verarbeitet.",
      })

      console.log('Prompt-Test Ergebnis:', result)
    } catch (error) {
      console.error('Fehler beim Prompt-Test:', error)
      const errorMessage = error instanceof Error ? error.message : "Unbekannter Fehler"
      setTestResult(`Fehler: ${errorMessage}`)
      toast({
        title: "Prompt-Test fehlgeschlagen",
        description: errorMessage,
        variant: "destructive",
      })
    } finally {
      setIsTesting(false)
    }
  }

  // Render-Logik für verschiedene Status
  if (libraryStatus === "waitingForAuth") {
    return (
      <div className="flex flex-col items-center justify-center h-full text-muted-foreground">
        <span>Diese Bibliothek benötigt eine Authentifizierung.</span>
        <span className="text-sm mt-2">Bitte konfigurieren Sie die Bibliothek in den Einstellungen.</span>
      </div>
    )
  }
  
  if (libraryStatus !== "ready") {
    return (
      <div className="flex flex-col items-center justify-center h-full text-muted-foreground">
        <span>Lade Storage...</span>
      </div>
    )
  }

  if (!activeLibrary) {
    return (
      <div className="text-center text-muted-foreground">
        Bitte wählen Sie eine Bibliothek aus.
      </div>
    )
  }

  if (error) {
    return (
      <div className="text-center text-destructive">
        <p>Fehler beim Laden der Prompts:</p>
        <p className="text-sm">{error}</p>
        <Button 
          variant="outline" 
          className="mt-4"
          onClick={loadTemplates}
        >
          Erneut versuchen
        </Button>
      </div>
    )
  }

  return (
    <div className="space-y-6">

      {/* Kompakte Toolbar oben */}
      <div className="flex items-center gap-2">
        <Select value={selectedTemplateName || ''} onValueChange={(v) => { setSelectedTemplateName(v); form.setValue('name', v, { shouldDirty: false }) }} disabled={isLoading}>
          <SelectTrigger className="w-64">
            <SelectValue placeholder="Prompt auswählen..." />
          </SelectTrigger>
          <SelectContent>
            {templates.map((t) => (
              <SelectItem key={t.name} value={t.name}>{t.name}</SelectItem>
            ))}
          </SelectContent>
        </Select>
        <TooltipProvider>
          <Tooltip>
            <TooltipTrigger asChild>
              <Button variant="ghost" size="sm" className="h-8 w-8 p-0"><Info className="h-4 w-4" /></Button>
            </TooltipTrigger>
            <TooltipContent>
              <div className="flex items-center gap-2"><FolderOpen className="h-4 w-4" /><span>Ort: /templates in „{activeLibrary.label}“</span></div>
            </TooltipContent>
          </Tooltip>
        </TooltipProvider>
        <Button type="button" variant="outline" size="sm" onClick={createNewTemplate} disabled={isLoading}>Neu</Button>
        <Button type="button" variant="outline" size="sm" onClick={renameCurrentTemplate} disabled={!selectedTemplateName}>Umbenennen</Button>
        {selectedTemplateName && (
          <Button type="button" variant="destructive" size="sm" onClick={() => deleteTemplate(selectedTemplateName!)}>Löschen</Button>
        )}
      </div>

      <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
        <Card>
          <CardHeader>
            <CardTitle>Prompt Design</CardTitle>
            <CardDescription>
              Drei Bereiche: Aufgabe (was), Rollenanweisung (wie), Metadaten (Begleitinfos).
            </CardDescription>
          </CardHeader>
          <CardContent>
            <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-6">
              {/* Template-Name Feld entfernt (oben verwaltet) */}

              {previewMode ? (
                <div className="space-y-4">
                  <div className="flex items-center justify-between">
                    <h4 className="text-sm font-medium">Prompt-Vorschau</h4>
                    <Button
                      type="button"
                      variant="outline"
                      size="sm"
                      onClick={() => setPreviewMode(false)}
                    >
                      Bearbeiten
                    </Button>
                  </div>
                  <div className="border rounded-md p-4 bg-muted/50">
                    <pre className="text-sm whitespace-pre-wrap font-mono">
                      {generatePreview()}
                    </pre>
                  </div>
                </div>
              ) : (
                <StructuredTemplateEditor
                  markdownBody={form.watch('markdownBody')}
                  yamlFrontmatter={form.watch('yamlFrontmatter')}
                  systemPrompt={form.watch('systemPrompt')}
                  onChange={({ markdownBody, yamlFrontmatter, systemPrompt }) => {
                    form.setValue('markdownBody', markdownBody, { shouldDirty: true })
                    form.setValue('yamlFrontmatter', yamlFrontmatter, { shouldDirty: true })
                    form.setValue('systemPrompt', systemPrompt, { shouldDirty: true })
                  }}
                />
              )}

              <div className="flex justify-end gap-2">
                <Button
                  type="button"
                  variant="outline"
                  onClick={() => setPreviewMode(!previewMode)}
                >
                  <Eye className="h-4 w-4 mr-2" />
                  {previewMode ? "Bearbeiten" : "Vorschau"}
                </Button>
                <Button
                  type="submit"
                  disabled={isSaving || !form.formState.isDirty}
                >
                  {isSaving ? (
                    <>
                      <Loader2 className="h-4 w-4 mr-2 animate-spin" />
                      Wird gespeichert...
                    </>
                  ) : (
                    <>
                      <Save className="h-4 w-4 mr-2" />
                      Speichern
                    </>
                  )}
                </Button>
              </div>
            </form>
          </CardContent>
        </Card>

        <Card>
          <CardHeader>
            <CardTitle>Prompt testen</CardTitle>
            <CardDescription>
              Test mit Beispieltext. Nutzt Rollenanweisung, Aufgabe und Metadaten des Prompts.
            </CardDescription>
          </CardHeader>
          <CardContent>
            <div className="space-y-4">
              <div className="space-y-2">
                <Label>Kontext-Texte</Label>
                <div className="border rounded p-2 max-h-40 overflow-auto text-sm">
                  {Array.isArray(contextDocs) && contextDocs.length > 0 ? (
                    contextDocs.map(d => {
                      const checked = selectedContextIds.includes(d.id)
                      return (
                        <label key={d.id} className="flex items-center gap-2 py-1">
                          <Checkbox
                            checked={checked}
                            onCheckedChange={(v) => {
                              const isOn = v === true
                              setSelectedContextIds(prev => isOn ? [...prev, d.id] : prev.filter(x => x !== d.id))
                            }}
                          />
                          <span className="truncate">{d.name}</span>
                        </label>
                      )
                    })
                  ) : (
                    <div className="text-muted-foreground text-sm">Keine Kontext-Texte verfügbar</div>
                  )}
                </div>
              </div>

              <div className="space-y-2">
                <Label>Gewählter Kontext (Lesemodus)</Label>
                <div className="border rounded-md">
                  <MarkdownPreview content={selectedContextMarkdown} className="max-h-64 overflow-auto" />
                </div>
              </div>

              <div className="space-y-2">
                <Label>Prompt‑Vorschau (Aufgabe als Markdown)</Label>
                <div className="border rounded-md">
                  <MarkdownPreview content={form.watch('markdownBody') || ''} className="max-h-64 overflow-auto" />
                </div>
              </div>

              <div className="flex gap-2">
                <Button 
                  variant="outline" 
                  size="sm"
                  onClick={testTemplate}
                  disabled={!selectedTemplateName || isTesting}
                >
                  {isTesting ? (
                    <>
                      <Loader2 className="h-4 w-4 mr-2 animate-spin" />
                      Teste...
                    </>
                  ) : (
                    <>
                      <Play className="h-4 w-4 mr-2" />
                      Prompt testen
                    </>
                  )}
                </Button>
              </div>
              
              {testResult && (
                <div className="space-y-2">
                  <Label>Ergebnis (Markdown)</Label>
                  <div className="border rounded-md">
                    <MarkdownPreview content={testResult} className="max-h-80 overflow-auto" />
                  </div>
                </div>
              )}
            </div>
          </CardContent>
        </Card>
      </div>
    </div>
  )
} 
```

- Rechts neu strukturiert:
  - Kontext-Texte: auswählbare Liste (Checkboxen), nicht editierbar.
  - Gewählter Kontext: Read-only Markdown-Preview.
  - Prompt-Vorschau: Markdown-Preview des Bereichs „Aufgabe“.
  - Prompt testen: Button bleibt.
  - Ergebnis: Markdown-Preview des Test-Outputs.

- Test-Logik:
  - Verwendet die aggregierten, gewählten Kontext-Texte statt des alten Eingabe-Textareas.
  - Vorschau und Ergebnis nutzen `MarkdownPreview`.

- Anwender-Flow kurz:
  - Links: Prompt Design bearbeiten (Aufgabe, Rollenanweisung, Metadaten).
  - Rechts: Kontext wählen, Aufgabe-Vorschau prüfen, Test ausführen, Ergebnis ansehen.

---

**User**

Ok, dieser Prompt-Testen-Bereich ist jetzt schon sehr mächtig, aber leider auch unübersichtlich. Wir haben da jetzt eigentlich drei Abschnitte. Kontext, wo man den Kontext verwaltet mit Auswahl der Dokumente und diesem gewählten Kontextlesemodus. Das würde ich jetzt als Daten-Kontext speichern. Dann gibt es diesen Prompt-Vorschau. Da würde jetzt der generierte Prompt angezeigt werden. Den man eben auf der linken Seite zusammenbaut. Mit dem Button Prompt-Testen. Und dann würde ich ein eigenes Tab-Ergebnis, Markdown, mit einer Markdown-Ansicht von dem Ergebnis anzeigen. Und mit einem Metadaten Prompt-Matter. Wobei wir diese Ansicht könnten wir recyceln aus der bestehenden PDF-Ansicht. Diese Reiter Metadaten, wo wir Metadaten und Kapitel-Anzeigen auswählen. Wir haben das schon mal alles programmiert. @job-report-tab.tsx 

---

**Cursor**

```typescriptreact
"use client"

import { useState, useEffect, useCallback } from "react"
import { useForm } from "react-hook-form"
import { zodResolver } from "@hookform/resolvers/zod"
import * as z from "zod"
import { Button } from "@/components/ui/button"
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card"
import { Label } from "@/components/ui/label"
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select"
import { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from "@/components/ui/tooltip"
import { StructuredTemplateEditor } from "@/components/templates/structured-template-editor"
import { useToast } from "@/hooks/use-toast"
import { Loader2, Save, Eye, Play, FolderOpen, Info } from "lucide-react"
import { useAtom, useAtomValue } from "jotai"
import { activeLibraryAtom, libraryStatusAtom } from "@/atoms/library-atom"
import { 
  templatesAtom, 
  selectedTemplateNameAtom, 
  selectedTemplateAtom,
  templatesFolderIdAtom,
  templateLoadingAtom,
  templateErrorAtom,
  type Template
} from "@/atoms/template-atom"
import { useStorage } from "@/contexts/storage-context"
import { templateContextDocsAtom } from '@/atoms/template-context-atom'
import { Checkbox } from "@/components/ui/checkbox"
import { MarkdownPreview } from "@/components/library/markdown-preview"
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs"
import { JobReportTab } from "@/components/library/job-report-tab"

// Schema für Template-Daten
const templateSchema = z.object({
  name: z.string().min(1, "Prompt-Name ist erforderlich"),
  yamlFrontmatter: z.string(),
  markdownBody: z.string(),
  systemPrompt: z.string(),
})

type TemplateFormValues = z.infer<typeof templateSchema>

export function TemplateManagement() {
  const [previewMode, setPreviewMode] = useState(false)
  const [isSaving, setIsSaving] = useState(false)
  const [isTesting, setIsTesting] = useState(false)
  const [testResult, setTestResult] = useState<string | null>(null)
  const [selectedContextIds, setSelectedContextIds] = useState<string[]>([])
  const [selectedContextMarkdown, setSelectedContextMarkdown] = useState<string>("")
  const [rightTab, setRightTab] = useState<'kontext'|'preview'|'ergebnis'>('kontext')
  const [resultSavedItemId, setResultSavedItemId] = useState<string | null>(null)
  const { toast } = useToast()

  // Atoms
  const [templates, setTemplates] = useAtom(templatesAtom)
  const [selectedTemplateName, setSelectedTemplateName] = useAtom(selectedTemplateNameAtom)
  const [selectedTemplate] = useAtom(selectedTemplateAtom)
  const [templatesFolderId, setTemplatesFolderId] = useAtom(templatesFolderIdAtom)
  const [isLoading, setIsLoading] = useAtom(templateLoadingAtom)
  const [error, setError] = useAtom(templateErrorAtom)

  // Library und Storage
  const activeLibrary = useAtomValue(activeLibraryAtom)
  const libraryStatus = useAtomValue(libraryStatusAtom)
  const { 
    provider: providerInstance, 
    listItems
  } = useStorage()
  const contextDocs = useAtomValue(templateContextDocsAtom)

  const form = useForm<TemplateFormValues>({
    resolver: zodResolver(templateSchema),
    defaultValues: {
      name: "",
      yamlFrontmatter: `---
title: {{title|Titel des Dokuments}}
tags: {{tags|Relevante Tags}}
date: {{date|Datum im Format yyyy-mm-dd}}
---`,
      markdownBody: `# {{title}}

## Zusammenfassung
{{summary|Kurze Zusammenfassung des Inhalts}}

## Details
{{details|Detaillierte Beschreibung}}`,
      systemPrompt: `You are a specialized assistant that processes and structures information clearly and concisely.

IMPORTANT: Your response must be a valid JSON object where each key corresponds to a template variable.`,
    },
  })

  // Helper zum Erzeugen von Default-Werten
  function getDefaultTemplateValues(name: string): TemplateFormValues {
    return {
      name,
      yamlFrontmatter: `---\n` +
        `title: {{title|Titel des Dokuments}}\n` +
        `tags: {{tags|Relevante Tags}}\n` +
        `date: {{date|Datum im Format yyyy-mm-dd}}\n` +
        `---`,
      markdownBody: `# {{title}}\n\n## Zusammenfassung\n{{summary|Kurze Zusammenfassung des Inhalts}}\n\n## Details\n{{details|Detaillierte Beschreibung}}`,
      systemPrompt: `You are a specialized assistant that processes and structures information clearly and concisely.\n\nIMPORTANT: Your response must be a valid JSON object where each key corresponds to a template variable.`,
    }
  }

  // Template-Daten laden wenn sich die Auswahl ändert
  useEffect(() => {
    if (selectedTemplate) {
      form.reset({
        name: selectedTemplate.name,
        yamlFrontmatter: selectedTemplate.yamlFrontmatter,
        markdownBody: selectedTemplate.markdownBody,
        systemPrompt: selectedTemplate.systemPrompt,
      })
    }
  }, [selectedTemplate, form])

  // Ordner-Erstellung/Suche memoisiert, damit als Dep verwendbar
  const ensureTemplatesFolder = useCallback(async (): Promise<string> => {
    if (!providerInstance || !activeLibrary) {
      throw new Error("Keine aktive Bibliothek oder Provider verfügbar");
    }

    try {
      console.log('[TemplateManagement] Suche nach Templates-Ordner...');
      const rootItems = await listItems('root');
      const templatesFolder = rootItems.find(item => 
        item.type === 'folder' && item.metadata.name === 'templates'
      );
      if (templatesFolder) {
        console.log('[TemplateManagement] Templates-Ordner gefunden:', templatesFolder.id);
        return templatesFolder.id;
      }
      console.log('[TemplateManagement] Templates-Ordner nicht gefunden, erstelle neuen...');
      const newFolder = await providerInstance.createFolder('root', 'templates');
      console.log('[TemplateManagement] Neuer Templates-Ordner erstellt:', newFolder.id);
      return newFolder.id;
    } catch (error) {
      console.error('Fehler beim Erstellen des Templates-Ordners:', {
        error: error instanceof Error ? {
          message: error.message,
          name: error.name,
          stack: error.stack?.split('\n').slice(0, 3)
        } : error,
        libraryId: activeLibrary?.id,
        libraryPath: activeLibrary?.path,
        providerName: providerInstance?.name
      });
      let errorMessage = 'Fehler beim Erstellen des Templates-Ordners';
      if (error instanceof Error) {
        if (error.message.includes('Nicht authentifiziert')) {
          errorMessage = 'Bitte authentifizieren Sie sich bei Ihrem Cloud-Speicher, um den Templates-Ordner zu erstellen.';
        } else if (error.message.includes('Keine Berechtigung')) {
          errorMessage = 'Keine Berechtigung zum Erstellen von Ordnern in der Bibliothek.';
        } else if (error.message.includes('Bibliothek nicht gefunden')) {
          errorMessage = 'Die ausgewählte Bibliothek wurde nicht gefunden.';
        } else {
          errorMessage = `Fehler beim Erstellen des Templates-Ordners: ${error.message}`;
        }
      }
      throw new Error(errorMessage);
    }
  }, [providerInstance, activeLibrary, listItems]);

  // Templates laden mit der gleichen Logik wie Library-Komponente
  const loadTemplates = useCallback(async () => {
    if (!providerInstance || libraryStatus !== 'ready' || !activeLibrary) {
      console.log('[TemplateManagement] loadTemplates übersprungen:', {
        hasProvider: !!providerInstance,
        libraryStatus,
        hasActiveLibrary: !!activeLibrary
      });
      return;
    }

    try {
      setIsLoading(true);
      setError(null);

      console.log('[TemplateManagement] Starte Prompt-Loading:', {
        libraryId: activeLibrary.id,
        libraryPath: activeLibrary.path,
        providerName: providerInstance.name
      });

      // 1. Templates-Ordner finden oder erstellen
      const folderId = await ensureTemplatesFolder();
      setTemplatesFolderId(folderId);

      console.log('[TemplateManagement] Templates-Ordner gefunden/erstellt:', folderId);

      // 2. Alle Template-Dateien im Ordner auflisten
      const items = await listItems(folderId);
      const templateFiles = items.filter(item => 
        item.type === 'file' && 
        item.metadata.name.endsWith('.md')
      );

      console.log('[TemplateManagement] Prompt-Dateien gefunden:', templateFiles.length);

      // 3. Template-Inhalte laden
      const templatePromises = templateFiles.map(async (file) => {
        try {
          const { blob } = await providerInstance.getBinary(file.id);
          const content = await blob.text();
          const template = parseTemplateContent(content, file.metadata.name.replace('.md', ''));
          
          return {
            ...template,
            fileId: file.id,
            lastModified: typeof file.metadata.modifiedAt === 'string' 
              ? file.metadata.modifiedAt 
              : file.metadata.modifiedAt instanceof Date 
                ? file.metadata.modifiedAt.toISOString()
                : new Date().toISOString()
          } as Template;
        } catch (error) {
          console.error(`Fehler beim Parsen von ${file.metadata.name}:`, error);
          return null;
        }
      });

      const loadedTemplates = await Promise.all(templatePromises);
      const validTemplates = loadedTemplates.filter((t): t is Template => t !== null);
      
      setTemplates(validTemplates);
      
      console.log('[TemplateManagement] Prompts erfolgreich geladen:', validTemplates.length);
      
      if (validTemplates.length === 0) {
        toast({
          title: "Keine Prompts gefunden",
          description: "Erstellen Sie Ihren ersten Prompt im Verzeichnis '/templates'.",
        });
      }
    } catch (error) {
      console.error('Fehler beim Laden der Prompts:', {
        error: error instanceof Error ? {
          message: error.message,
          name: error.name,
          stack: error.stack?.split('\n').slice(0, 3)
        } : error,
        libraryId: activeLibrary?.id,
        libraryPath: activeLibrary?.path,
        providerName: providerInstance?.name
      });

      let errorMessage = 'Unbekannter Fehler beim Laden der Prompts';
      
      if (error instanceof Error) {
        errorMessage = error.message;
        
        // Spezifische Fehlermeldungen für häufige Probleme
        if (error.message.includes('Nicht authentifiziert')) {
          errorMessage = 'Bitte authentifizieren Sie sich bei Ihrem Cloud-Speicher, um Prompts zu laden.';
        } else if (error.message.includes('Bibliothek nicht gefunden')) {
          errorMessage = 'Die ausgewählte Bibliothek wurde nicht gefunden. Bitte überprüfen Sie die Bibliothekskonfiguration.';
        } else if (error.message.includes('Server-Fehler')) {
          errorMessage = 'Server-Fehler beim Laden der Prompts. Bitte überprüfen Sie, ob der Bibliothekspfad existiert und zugänglich ist.';
        } else if (error.message.includes('Keine aktive Bibliothek')) {
          errorMessage = 'Keine aktive Bibliothek verfügbar. Bitte wählen Sie eine Bibliothek aus.';
        }
      }
      
      setError(errorMessage);
      toast({
        title: "Fehler beim Laden der Prompts",
        description: errorMessage,
        variant: "destructive",
      });
    } finally {
      setIsLoading(false);
    }
  }, [providerInstance, libraryStatus, activeLibrary, listItems, setTemplates, setTemplatesFolderId, setIsLoading, setError, toast, ensureTemplatesFolder]);

  // Effect für Template Loading (wie Library-Komponente)
  useEffect(() => {
    const isReady = providerInstance && libraryStatus === 'ready' && activeLibrary
    
    if (!isReady) {
      return
    }

    // Templates laden wenn noch nicht geladen
    if (!templatesFolderId) {
      loadTemplates()
    }
  }, [providerInstance, libraryStatus, activeLibrary, templatesFolderId, loadTemplates])

  // Reset wenn sich die Library ändert
  useEffect(() => {
    setSelectedTemplateName(null)
    setTemplatesFolderId(null)
    setTemplates([])
    setError(null)
  }, [libraryStatus, setSelectedTemplateName, setTemplatesFolderId, setTemplates, setError])

  useEffect(() => {
    async function loadSelectedContext() {
      if (!providerInstance || !Array.isArray(selectedContextIds) || selectedContextIds.length === 0) {
        setSelectedContextMarkdown("")
        return
      }
      try {
        const parts: string[] = []
        for (const id of selectedContextIds) {
          const { blob } = await providerInstance.getBinary(id)
          const text = await blob.text()
          parts.push(text)
        }
        setSelectedContextMarkdown(parts.join("\n\n---\n\n"))
      } catch (e) {
        console.error('Fehler beim Laden des Kontextes', e)
        setSelectedContextMarkdown("")
      }
    }
    void loadSelectedContext()
  }, [providerInstance, selectedContextIds])

  function parseTemplateContent(content: string, fileName: string): Template {
    // Template in drei Bereiche aufteilen
    const parts = content.split('--- systemprompt')
    
    let yamlFrontmatter = ""
    let markdownBody = ""
    let systemPrompt = ""
    
    if (parts.length >= 2) {
      const mainContent = parts[0].trim()
      systemPrompt = parts[1].trim()
      
      // YAML Frontmatter extrahieren
      const yamlMatch = mainContent.match(/^---\n([\s\S]*?)\n---\n([\s\S]*)$/)
      if (yamlMatch) {
        yamlFrontmatter = `---\n${yamlMatch[1]}\n---`
        markdownBody = yamlMatch[2].trim()
      } else {
        // Kein YAML Frontmatter gefunden
        markdownBody = mainContent
      }
    } else {
      // Kein Systemprompt gefunden
      const yamlMatch = content.match(/^---\n([\s\S]*?)\n---\n([\s\S]*)$/)
      if (yamlMatch) {
        yamlFrontmatter = `---\n${yamlMatch[1]}\n---`
        markdownBody = yamlMatch[2].trim()
      } else {
        markdownBody = content
      }
    }

    return {
      name: fileName,
      yamlFrontmatter,
      markdownBody,
      systemPrompt,
    }
  }

  function generateTemplateContent(values: TemplateFormValues): string {
    let content = ""
    
    // YAML Frontmatter hinzufügen
    if (values.yamlFrontmatter.trim()) {
      content += values.yamlFrontmatter + "\n\n"
    }
    
    // Markdown Body hinzufügen
    content += values.markdownBody
    
    // System Prompt hinzufügen
    if (values.systemPrompt.trim()) {
      content += "\n\n--- systemprompt\n" + values.systemPrompt
    }
    
    return content
  }

  async function onSubmit(data: TemplateFormValues) {
    if (!activeLibrary || !templatesFolderId || !providerInstance) {
      toast({
        title: "Fehler",
        description: "Keine aktive Bibliothek oder Templates-Ordner nicht gefunden.",
        variant: "destructive",
      })
      return
    }

    setIsSaving(true)
    try {
      const templateContent = generateTemplateContent(data)
      const fileName = `${data.name}.md`
      
      // Datei als Blob erstellen
      const blob = new Blob([templateContent], { type: 'text/markdown' })
      const file = new File([blob], fileName, { type: 'text/markdown' })
      
      // Datei hochladen
      await providerInstance.uploadFile(templatesFolderId, file)
      
      // Templates neu laden
      await loadTemplates()
      
      // Auswahl auf das neue Template setzen
      setSelectedTemplateName(data.name)
      
      toast({
        title: "Template gespeichert",
        description: `Template "${data.name}" wurde erfolgreich im Verzeichnis "/templates" gespeichert.`,
      })
    } catch (error) {
      console.error('Fehler beim Speichern des Templates:', error)
      toast({
        title: "Fehler beim Speichern",
        description: error instanceof Error ? error.message : "Unbekannter Fehler",
        variant: "destructive",
      })
    } finally {
      setIsSaving(false)
    }
  }

  async function renameCurrentTemplate() {
    const current = selectedTemplateName ? templates.find(t => t.name === selectedTemplateName) : null
    if (!current || !current.fileId || !providerInstance) return
    const newName = (window.prompt('Neuen Namen eingeben:', current.name) || '').trim()
    if (!newName || newName === current.name) return
    if (/[^a-zA-Z0-9._\- ]/.test(newName)) { toast({ title: 'Ungültiger Name', description: 'Nur Buchstaben, Zahlen, Leerzeichen, . _ - sind erlaubt.', variant: 'destructive' }); return }
    if (templates.some(t => t.name.toLowerCase() === newName.toLowerCase())) { toast({ title: 'Bereits vorhanden', description: 'Bitte anderen Namen wählen.', variant: 'destructive' }); return }
    try {
      await providerInstance.renameItem(current.fileId, `${newName}.md`)
      await loadTemplates()
      setSelectedTemplateName(newName)
      form.setValue('name', newName, { shouldDirty: false })
      toast({ title: 'Umbenannt', description: `${current.name} → ${newName}` })
    } catch (e) {
      toast({ title: 'Fehler beim Umbenennen', description: e instanceof Error ? e.message : 'Unbekannter Fehler', variant: 'destructive' })
    }
  }

  async function deleteTemplate(templateName: string) {
    if (!activeLibrary || !providerInstance) return

    try {
      const template = templates.find(t => t.name === templateName)
      if (!template?.fileId) {
        throw new Error("Template-Datei nicht gefunden")
      }

      // Datei löschen
      await providerInstance.deleteItem(template.fileId)

      // Templates neu laden
      await loadTemplates()
      
      if (selectedTemplateName === templateName) {
        setSelectedTemplateName(null)
        form.reset()
      }
      
      toast({
        title: "Template gelöscht",
        description: `Template "${templateName}" wurde erfolgreich gelöscht.`,
      })
    } catch (error) {
      console.error('Fehler beim Löschen des Templates:', error)
      toast({
        title: "Fehler beim Löschen",
        description: error instanceof Error ? error.message : "Unbekannter Fehler",
        variant: "destructive",
      })
    }
  }

  async function createNewTemplate() {
    const name = (window.prompt('Neuen Template‑Namen eingeben:') || '').trim()
    if (!name) return
    if (/[^a-zA-Z0-9._\- ]/.test(name)) { toast({ title: 'Ungültiger Name', description: 'Nur Buchstaben, Zahlen, Leerzeichen, . _ - sind erlaubt.', variant: 'destructive' }); return }
    if (templates.some(t => t.name.toLowerCase() === name.toLowerCase())) { toast({ title: 'Bereits vorhanden', description: 'Bitte anderen Namen wählen.', variant: 'destructive' }); return }
    if (!providerInstance) { toast({ title: 'Kein Provider' , variant: 'destructive' }); return }
    try {
      const folderId = await ensureTemplatesFolder()
      const values = getDefaultTemplateValues(name)
      const content = (values.yamlFrontmatter ? values.yamlFrontmatter + '\n\n' : '') + values.markdownBody + '\n\n--- systemprompt\n' + values.systemPrompt
      const file = new File([new Blob([content], { type: 'text/markdown' })], `${name}.md`, { type: 'text/markdown' })
      await providerInstance.uploadFile(folderId, file)
      await loadTemplates()
      setSelectedTemplateName(name)
      form.reset(values)
      toast({ title: 'Template angelegt', description: `"${name}" wurde erstellt.` })
    } catch (e) {
      toast({ title: 'Fehler beim Anlegen', description: e instanceof Error ? e.message : 'Unbekannter Fehler', variant: 'destructive' })
    }
  }

  function generatePreview(): string {
    const values = form.getValues()
    return generateTemplateContent(values)
  }

  async function testTemplate() {
    if (!activeLibrary) return

    setIsTesting(true)
    setTestResult(null)

    const values = form.getValues()
    const templateContent = generateTemplateContent(values)
    const testText = selectedContextMarkdown || ""

    try {
      const response = await fetch('/api/secretary/process-text', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/x-www-form-urlencoded',
          'X-Library-Id': activeLibrary.id,
        },
        body: new URLSearchParams({
          text: testText,
          template_content: templateContent,
          source_language: 'de',
          target_language: 'de',
        }),
      })

      if (!response.ok) {
        const errorData = await response.json()
        throw new Error(errorData.error || `HTTP ${response.status}: ${response.statusText}`)
      }

      const result = await response.json()
      const formattedResult = typeof result === 'string' ? result : JSON.stringify(result, null, 2)
      setTestResult(formattedResult)
      setRightTab('ergebnis')

      toast({
        title: "Prompt-Test erfolgreich",
        description: "Der Prompt wurde erfolgreich mit dem gewählten Kontext verarbeitet.",
      })

      console.log('Prompt-Test Ergebnis:', result)
    } catch (error) {
      console.error('Fehler beim Prompt-Test:', error)
      const errorMessage = error instanceof Error ? error.message : "Unbekannter Fehler"
      setTestResult(`Fehler: ${errorMessage}`)
      setRightTab('ergebnis')
      toast({
        title: "Prompt-Test fehlgeschlagen",
        description: errorMessage,
        variant: "destructive",
      })
    } finally {
      setIsTesting(false)
    }
  }

  async function ensurePromptTestsFolder(): Promise<string> {
    if (!providerInstance) throw new Error('Kein Provider verfügbar')
    const roots = await listItems('root')
    const found = roots.find(it => it.type === 'folder' && it.metadata.name === 'prompt-tests')
    if (found) return found.id
    const created = await providerInstance.createFolder('root', 'prompt-tests')
    return created.id
  }

  async function saveTestResult() {
    try {
      if (!providerInstance || !activeLibrary || !testResult) return
      const folderId = await ensurePromptTestsFolder()
      const name = `${selectedTemplateName || 'prompt'}-test-${new Date().toISOString().replace(/[:.]/g,'-')}.md`
      const blob = new Blob([testResult], { type: 'text/markdown' })
      const file = new File([blob], name, { type: 'text/markdown' })
      const item = await providerInstance.uploadFile(folderId, file)
      setResultSavedItemId(item.id)
      toast({ title: 'Ergebnis gespeichert', description: name })
    } catch (e) {
      toast({ title: 'Speichern fehlgeschlagen', description: e instanceof Error ? e.message : 'Unbekannter Fehler', variant: 'destructive' })
    }
  }

  // Render-Logik für verschiedene Status
  if (libraryStatus === "waitingForAuth") {
    return (
      <div className="flex flex-col items-center justify-center h-full text-muted-foreground">
        <span>Diese Bibliothek benötigt eine Authentifizierung.</span>
        <span className="text-sm mt-2">Bitte konfigurieren Sie die Bibliothek in den Einstellungen.</span>
      </div>
    )
  }
  
  if (libraryStatus !== "ready") {
    return (
      <div className="flex flex-col items-center justify-center h-full text-muted-foreground">
        <span>Lade Storage...</span>
      </div>
    )
  }

  if (!activeLibrary) {
    return (
      <div className="text-center text-muted-foreground">
        Bitte wählen Sie eine Bibliothek aus.
      </div>
    )
  }

  if (error) {
    return (
      <div className="text-center text-destructive">
        <p>Fehler beim Laden der Prompts:</p>
        <p className="text-sm">{error}</p>
        <Button 
          variant="outline" 
          className="mt-4"
          onClick={loadTemplates}
        >
          Erneut versuchen
        </Button>
      </div>
    )
  }

  return (
    <div className="space-y-6">

      {/* Kompakte Toolbar oben */}
      <div className="flex items-center gap-2">
        <Select value={selectedTemplateName || ''} onValueChange={(v) => { setSelectedTemplateName(v); form.setValue('name', v, { shouldDirty: false }) }} disabled={isLoading}>
          <SelectTrigger className="w-64">
            <SelectValue placeholder="Prompt auswählen..." />
          </SelectTrigger>
          <SelectContent>
            {templates.map((t) => (
              <SelectItem key={t.name} value={t.name}>{t.name}</SelectItem>
            ))}
          </SelectContent>
        </Select>
        <TooltipProvider>
          <Tooltip>
            <TooltipTrigger asChild>
              <Button variant="ghost" size="sm" className="h-8 w-8 p-0"><Info className="h-4 w-4" /></Button>
            </TooltipTrigger>
            <TooltipContent>
              <div className="flex items-center gap-2"><FolderOpen className="h-4 w-4" /><span>Ort: /templates in „{activeLibrary.label}“</span></div>
            </TooltipContent>
          </Tooltip>
        </TooltipProvider>
        <Button type="button" variant="outline" size="sm" onClick={createNewTemplate} disabled={isLoading}>Neu</Button>
        <Button type="button" variant="outline" size="sm" onClick={renameCurrentTemplate} disabled={!selectedTemplateName}>Umbenennen</Button>
        {selectedTemplateName && (
          <Button type="button" variant="destructive" size="sm" onClick={() => deleteTemplate(selectedTemplateName!)}>Löschen</Button>
        )}
      </div>

      <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
        <Card>
          <CardHeader>
            <CardTitle>Prompt Design</CardTitle>
            <CardDescription>
              Drei Bereiche: Aufgabe (was), Rollenanweisung (wie), Metadaten (Begleitinfos).
            </CardDescription>
          </CardHeader>
          <CardContent>
            <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-6">
              {/* Template-Name Feld entfernt (oben verwaltet) */}

              {previewMode ? (
                <div className="space-y-4">
                  <div className="flex items-center justify-between">
                    <h4 className="text-sm font-medium">Prompt-Vorschau</h4>
                    <Button
                      type="button"
                      variant="outline"
                      size="sm"
                      onClick={() => setPreviewMode(false)}
                    >
                      Bearbeiten
                    </Button>
                  </div>
                  <div className="border rounded-md p-4 bg-muted/50">
                    <pre className="text-sm whitespace-pre-wrap font-mono">
                      {generatePreview()}
                    </pre>
                  </div>
                </div>
              ) : (
                <StructuredTemplateEditor
                  markdownBody={form.watch('markdownBody')}
                  yamlFrontmatter={form.watch('yamlFrontmatter')}
                  systemPrompt={form.watch('systemPrompt')}
                  onChange={({ markdownBody, yamlFrontmatter, systemPrompt }) => {
                    form.setValue('markdownBody', markdownBody, { shouldDirty: true })
                    form.setValue('yamlFrontmatter', yamlFrontmatter, { shouldDirty: true })
                    form.setValue('systemPrompt', systemPrompt, { shouldDirty: true })
                  }}
                />
              )}

              <div className="flex justify-end gap-2">
                <Button
                  type="button"
                  variant="outline"
                  onClick={() => setPreviewMode(!previewMode)}
                >
                  <Eye className="h-4 w-4 mr-2" />
                  {previewMode ? "Bearbeiten" : "Vorschau"}
                </Button>
                <Button
                  type="submit"
                  disabled={isSaving || !form.formState.isDirty}
                >
                  {isSaving ? (
                    <>
                      <Loader2 className="h-4 w-4 mr-2 animate-spin" />
                      Wird gespeichert...
                    </>
                  ) : (
                    <>
                      <Save className="h-4 w-4 mr-2" />
                      Speichern
                    </>
                  )}
                </Button>
              </div>
            </form>
          </CardContent>
        </Card>

        <Card>
          <CardHeader>
            <CardTitle>Prompt testen</CardTitle>
            <CardDescription>
              Test mit Beispieltext. Nutzt Rollenanweisung, Aufgabe und Metadaten des Prompts.
            </CardDescription>
          </CardHeader>
          <CardContent>
            <Tabs value={rightTab} onValueChange={(v) => setRightTab(v as typeof rightTab)}>
              <TabsList className="grid grid-cols-3 w-full">
                <TabsTrigger value="kontext">Daten‑Kontext</TabsTrigger>
                <TabsTrigger value="preview">Prompt‑Vorschau</TabsTrigger>
                <TabsTrigger value="ergebnis">Ergebnis</TabsTrigger>
              </TabsList>

              <TabsContent value="kontext" className="space-y-4 mt-4">
                <div className="space-y-2">
                  <Label>Kontext-Texte</Label>
                  <div className="border rounded p-2 max-h-40 overflow-auto text-sm">
                    {Array.isArray(contextDocs) && contextDocs.length > 0 ? (
                      contextDocs.map(d => {
                        const checked = selectedContextIds.includes(d.id)
                        return (
                          <label key={d.id} className="flex items-center gap-2 py-1">
                            <Checkbox
                              checked={checked}
                              onCheckedChange={(v) => {
                                const isOn = v === true
                                setSelectedContextIds(prev => isOn ? [...prev, d.id] : prev.filter(x => x !== d.id))
                              }}
                            />
                            <span className="truncate">{d.name}</span>
                          </label>
                        )
                      })
                    ) : (
                      <div className="text-muted-foreground text-sm">Keine Kontext-Texte verfügbar</div>
                    )}
                  </div>
                </div>

                <div className="space-y-2">
                  <Label>Gewählter Kontext (Lesemodus)</Label>
                  <div className="border rounded-md">
                    <MarkdownPreview content={selectedContextMarkdown} className="max-h-64 overflow-auto" />
                  </div>
                </div>
              </TabsContent>

              <TabsContent value="preview" className="space-y-4 mt-4">
                <div className="space-y-2">
                  <Label>Generierter Prompt (Markdown)</Label>
                  <div className="border rounded-md">
                    <MarkdownPreview content={generatePreview()} className="max-h-64 overflow-auto" />
                  </div>
                </div>
                <div className="flex gap-2">
                  <Button 
                    variant="outline" 
                    size="sm"
                    onClick={testTemplate}
                    disabled={!selectedTemplateName || isTesting}
                  >
                    {isTesting ? (
                      <>
                        <Loader2 className="h-4 w-4 mr-2 animate-spin" />
                        Teste...
                      </>
                    ) : (
                      <>
                        <Play className="h-4 w-4 mr-2" />
                        Prompt testen
                      </>
                    )}
                  </Button>
                </div>
              </TabsContent>

              <TabsContent value="ergebnis" className="space-y-4 mt-4">
                <Tabs defaultValue="md">
                  <TabsList className="w-full grid grid-cols-2">
                    <TabsTrigger value="md">Markdown</TabsTrigger>
                    <TabsTrigger value="meta">Metadaten</TabsTrigger>
                  </TabsList>
                  <TabsContent value="md" className="space-y-2 mt-2">
                    <Label>Ergebnis</Label>
                    <div className="border rounded-md">
                      <MarkdownPreview content={testResult || ''} className="max-h-80 overflow-auto" />
                    </div>
                    <div className="flex gap-2">
                      <Button type="button" onClick={saveTestResult} disabled={!testResult}>Speichern</Button>
                    </div>
                  </TabsContent>
                  <TabsContent value="meta" className="mt-2">
                    {resultSavedItemId && providerInstance && activeLibrary ? (
                      <JobReportTab libraryId={activeLibrary.id} fileId={resultSavedItemId} provider={providerInstance} sourceMode="frontmatter" viewMode="metaOnly" mdFileId={resultSavedItemId} />
                    ) : (
                      <div className="text-sm text-muted-foreground">Bitte Ergebnis speichern, um Metadaten und Kapitel anzuzeigen.</div>
                    )}
                  </TabsContent>
                </Tabs>
              </TabsContent>
            </Tabs>
          </CardContent>
        </Card>
      </div>
    </div>
  )
} 
```

- Rechts neu strukturiert in drei Tabs:
  - Daten‑Kontext: Auswahl der Dokumente (Checkboxen) und Read‑only Markdown‑Vorschau des aggregierten Kontextes.
  - Prompt‑Vorschau: generierter Prompt aus links (Aufgabe/Metadaten/Rollenanweisung) als Markdown, plus „Prompt testen“-Button.
  - Ergebnis: innerer Tab „Markdown“ für die Antwort und „Metadaten“ für Frontmatter/Chapter-Ansicht per `JobReportTab` (erscheint nach Speichern des Ergebnisses).

- Änderungen im Detail:
  - Ersetzt alte Textarea durch Checkbox‑Liste und `MarkdownPreview`.
  - Ergebnis speichern in `/prompt-tests/`; danach `JobReportTab` mit `sourceMode='frontmatter'`, `viewMode='metaOnly'`.
  - Nach Test wird automatisch zum Tab „Ergebnis“ gewechselt.

- Nutzerflow:
  - Links Prompt Design bauen; rechts Tab „Daten‑Kontext“ wählen; in „Prompt‑Vorschau“ prüfen und testen; in „Ergebnis“ Antwort ansehen und optional speichern; Metadaten/Kapitel im zweiten Reiter einsehen.

---

**User**

Dieser Datenkontext ist nach unten hin sehr knapp. Wenn ich links ein Prompt auswähle, hat ein Template mit sehr vielen Fragen, dann kann man den ganzen Bildschirm nach unten scrollen. Also der Bildschirm wird nach unten erweitert. Und auf der rechten Seite, wenn ich jetzt so einen Kontext einblende und im Lese-Modus, sollte auch der ganze Bildschirm nach unten erweitert werden, so lange bis alles Platz hat. Ist das nicht möglich?

---

**Cursor**

```typescriptreact
"use client"

import { useState, useEffect, useCallback } from "react"
import { useForm } from "react-hook-form"
import { zodResolver } from "@hookform/resolvers/zod"
import * as z from "zod"
import { Button } from "@/components/ui/button"
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card"
import { Label } from "@/components/ui/label"
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select"
import { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from "@/components/ui/tooltip"
import { StructuredTemplateEditor } from "@/components/templates/structured-template-editor"
import { useToast } from "@/hooks/use-toast"
import { Loader2, Save, Eye, Play, FolderOpen, Info } from "lucide-react"
import { useAtom, useAtomValue } from "jotai"
import { activeLibraryAtom, libraryStatusAtom } from "@/atoms/library-atom"
import { 
  templatesAtom, 
  selectedTemplateNameAtom, 
  selectedTemplateAtom,
  templatesFolderIdAtom,
  templateLoadingAtom,
  templateErrorAtom,
  type Template
} from "@/atoms/template-atom"
import { useStorage } from "@/contexts/storage-context"
import { templateContextDocsAtom } from '@/atoms/template-context-atom'
import { Checkbox } from "@/components/ui/checkbox"
import { MarkdownPreview } from "@/components/library/markdown-preview"
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs"
import { JobReportTab } from "@/components/library/job-report-tab"

// Schema für Template-Daten
const templateSchema = z.object({
  name: z.string().min(1, "Prompt-Name ist erforderlich"),
  yamlFrontmatter: z.string(),
  markdownBody: z.string(),
  systemPrompt: z.string(),
})

type TemplateFormValues = z.infer<typeof templateSchema>

export function TemplateManagement() {
  const [previewMode, setPreviewMode] = useState(false)
  const [isSaving, setIsSaving] = useState(false)
  const [isTesting, setIsTesting] = useState(false)
  const [testResult, setTestResult] = useState<string | null>(null)
  const [selectedContextIds, setSelectedContextIds] = useState<string[]>([])
  const [selectedContextMarkdown, setSelectedContextMarkdown] = useState<string>("")
  const [rightTab, setRightTab] = useState<'kontext'|'preview'|'ergebnis'>('kontext')
  const [resultSavedItemId, setResultSavedItemId] = useState<string | null>(null)
  const { toast } = useToast()

  // Atoms
  const [templates, setTemplates] = useAtom(templatesAtom)
  const [selectedTemplateName, setSelectedTemplateName] = useAtom(selectedTemplateNameAtom)
  const [selectedTemplate] = useAtom(selectedTemplateAtom)
  const [templatesFolderId, setTemplatesFolderId] = useAtom(templatesFolderIdAtom)
  const [isLoading, setIsLoading] = useAtom(templateLoadingAtom)
  const [error, setError] = useAtom(templateErrorAtom)

  // Library und Storage
  const activeLibrary = useAtomValue(activeLibraryAtom)
  const libraryStatus = useAtomValue(libraryStatusAtom)
  const { 
    provider: providerInstance, 
    listItems
  } = useStorage()
  const contextDocs = useAtomValue(templateContextDocsAtom)

  const form = useForm<TemplateFormValues>({
    resolver: zodResolver(templateSchema),
    defaultValues: {
      name: "",
      yamlFrontmatter: `---
title: {{title|Titel des Dokuments}}
tags: {{tags|Relevante Tags}}
date: {{date|Datum im Format yyyy-mm-dd}}
---`,
      markdownBody: `# {{title}}

## Zusammenfassung
{{summary|Kurze Zusammenfassung des Inhalts}}

## Details
{{details|Detaillierte Beschreibung}}`,
      systemPrompt: `You are a specialized assistant that processes and structures information clearly and concisely.

IMPORTANT: Your response must be a valid JSON object where each key corresponds to a template variable.`,
    },
  })

  // Helper zum Erzeugen von Default-Werten
  function getDefaultTemplateValues(name: string): TemplateFormValues {
    return {
      name,
      yamlFrontmatter: `---\n` +
        `title: {{title|Titel des Dokuments}}\n` +
        `tags: {{tags|Relevante Tags}}\n` +
        `date: {{date|Datum im Format yyyy-mm-dd}}\n` +
        `---`,
      markdownBody: `# {{title}}\n\n## Zusammenfassung\n{{summary|Kurze Zusammenfassung des Inhalts}}\n\n## Details\n{{details|Detaillierte Beschreibung}}`,
      systemPrompt: `You are a specialized assistant that processes and structures information clearly and concisely.\n\nIMPORTANT: Your response must be a valid JSON object where each key corresponds to a template variable.`,
    }
  }

  // Template-Daten laden wenn sich die Auswahl ändert
  useEffect(() => {
    if (selectedTemplate) {
      form.reset({
        name: selectedTemplate.name,
        yamlFrontmatter: selectedTemplate.yamlFrontmatter,
        markdownBody: selectedTemplate.markdownBody,
        systemPrompt: selectedTemplate.systemPrompt,
      })
    }
  }, [selectedTemplate, form])

  // Ordner-Erstellung/Suche memoisiert, damit als Dep verwendbar
  const ensureTemplatesFolder = useCallback(async (): Promise<string> => {
    if (!providerInstance || !activeLibrary) {
      throw new Error("Keine aktive Bibliothek oder Provider verfügbar");
    }

    try {
      console.log('[TemplateManagement] Suche nach Templates-Ordner...');
      const rootItems = await listItems('root');
      const templatesFolder = rootItems.find(item => 
        item.type === 'folder' && item.metadata.name === 'templates'
      );
      if (templatesFolder) {
        console.log('[TemplateManagement] Templates-Ordner gefunden:', templatesFolder.id);
        return templatesFolder.id;
      }
      console.log('[TemplateManagement] Templates-Ordner nicht gefunden, erstelle neuen...');
      const newFolder = await providerInstance.createFolder('root', 'templates');
      console.log('[TemplateManagement] Neuer Templates-Ordner erstellt:', newFolder.id);
      return newFolder.id;
    } catch (error) {
      console.error('Fehler beim Erstellen des Templates-Ordners:', {
        error: error instanceof Error ? {
          message: error.message,
          name: error.name,
          stack: error.stack?.split('\n').slice(0, 3)
        } : error,
        libraryId: activeLibrary?.id,
        libraryPath: activeLibrary?.path,
        providerName: providerInstance?.name
      });
      let errorMessage = 'Fehler beim Erstellen des Templates-Ordners';
      if (error instanceof Error) {
        if (error.message.includes('Nicht authentifiziert')) {
          errorMessage = 'Bitte authentifizieren Sie sich bei Ihrem Cloud-Speicher, um den Templates-Ordner zu erstellen.';
        } else if (error.message.includes('Keine Berechtigung')) {
          errorMessage = 'Keine Berechtigung zum Erstellen von Ordnern in der Bibliothek.';
        } else if (error.message.includes('Bibliothek nicht gefunden')) {
          errorMessage = 'Die ausgewählte Bibliothek wurde nicht gefunden.';
        } else {
          errorMessage = `Fehler beim Erstellen des Templates-Ordners: ${error.message}`;
        }
      }
      throw new Error(errorMessage);
    }
  }, [providerInstance, activeLibrary, listItems]);

  // Templates laden mit der gleichen Logik wie Library-Komponente
  const loadTemplates = useCallback(async () => {
    if (!providerInstance || libraryStatus !== 'ready' || !activeLibrary) {
      console.log('[TemplateManagement] loadTemplates übersprungen:', {
        hasProvider: !!providerInstance,
        libraryStatus,
        hasActiveLibrary: !!activeLibrary
      });
      return;
    }

    try {
      setIsLoading(true);
      setError(null);

      console.log('[TemplateManagement] Starte Prompt-Loading:', {
        libraryId: activeLibrary.id,
        libraryPath: activeLibrary.path,
        providerName: providerInstance.name
      });

      // 1. Templates-Ordner finden oder erstellen
      const folderId = await ensureTemplatesFolder();
      setTemplatesFolderId(folderId);

      console.log('[TemplateManagement] Templates-Ordner gefunden/erstellt:', folderId);

      // 2. Alle Template-Dateien im Ordner auflisten
      const items = await listItems(folderId);
      const templateFiles = items.filter(item => 
        item.type === 'file' && 
        item.metadata.name.endsWith('.md')
      );

      console.log('[TemplateManagement] Prompt-Dateien gefunden:', templateFiles.length);

      // 3. Template-Inhalte laden
      const templatePromises = templateFiles.map(async (file) => {
        try {
          const { blob } = await providerInstance.getBinary(file.id);
          const content = await blob.text();
          const template = parseTemplateContent(content, file.metadata.name.replace('.md', ''));
          
          return {
            ...template,
            fileId: file.id,
            lastModified: typeof file.metadata.modifiedAt === 'string' 
              ? file.metadata.modifiedAt 
              : file.metadata.modifiedAt instanceof Date 
                ? file.metadata.modifiedAt.toISOString()
                : new Date().toISOString()
          } as Template;
        } catch (error) {
          console.error(`Fehler beim Parsen von ${file.metadata.name}:`, error);
          return null;
        }
      });

      const loadedTemplates = await Promise.all(templatePromises);
      const validTemplates = loadedTemplates.filter((t): t is Template => t !== null);
      
      setTemplates(validTemplates);
      
      console.log('[TemplateManagement] Prompts erfolgreich geladen:', validTemplates.length);
      
      if (validTemplates.length === 0) {
        toast({
          title: "Keine Prompts gefunden",
          description: "Erstellen Sie Ihren ersten Prompt im Verzeichnis '/templates'.",
        });
      }
    } catch (error) {
      console.error('Fehler beim Laden der Prompts:', {
        error: error instanceof Error ? {
          message: error.message,
          name: error.name,
          stack: error.stack?.split('\n').slice(0, 3)
        } : error,
        libraryId: activeLibrary?.id,
        libraryPath: activeLibrary?.path,
        providerName: providerInstance?.name
      });

      let errorMessage = 'Unbekannter Fehler beim Laden der Prompts';
      
      if (error instanceof Error) {
        errorMessage = error.message;
        
        // Spezifische Fehlermeldungen für häufige Probleme
        if (error.message.includes('Nicht authentifiziert')) {
          errorMessage = 'Bitte authentifizieren Sie sich bei Ihrem Cloud-Speicher, um Prompts zu laden.';
        } else if (error.message.includes('Bibliothek nicht gefunden')) {
          errorMessage = 'Die ausgewählte Bibliothek wurde nicht gefunden. Bitte überprüfen Sie die Bibliothekskonfiguration.';
        } else if (error.message.includes('Server-Fehler')) {
          errorMessage = 'Server-Fehler beim Laden der Prompts. Bitte überprüfen Sie, ob der Bibliothekspfad existiert und zugänglich ist.';
        } else if (error.message.includes('Keine aktive Bibliothek')) {
          errorMessage = 'Keine aktive Bibliothek verfügbar. Bitte wählen Sie eine Bibliothek aus.';
        }
      }
      
      setError(errorMessage);
      toast({
        title: "Fehler beim Laden der Prompts",
        description: errorMessage,
        variant: "destructive",
      });
    } finally {
      setIsLoading(false);
    }
  }, [providerInstance, libraryStatus, activeLibrary, listItems, setTemplates, setTemplatesFolderId, setIsLoading, setError, toast, ensureTemplatesFolder]);

  // Effect für Template Loading (wie Library-Komponente)
  useEffect(() => {
    const isReady = providerInstance && libraryStatus === 'ready' && activeLibrary
    
    if (!isReady) {
      return
    }

    // Templates laden wenn noch nicht geladen
    if (!templatesFolderId) {
      loadTemplates()
    }
  }, [providerInstance, libraryStatus, activeLibrary, templatesFolderId, loadTemplates])

  // Reset wenn sich die Library ändert
  useEffect(() => {
    setSelectedTemplateName(null)
    setTemplatesFolderId(null)
    setTemplates([])
    setError(null)
  }, [libraryStatus, setSelectedTemplateName, setTemplatesFolderId, setTemplates, setError])

  useEffect(() => {
    async function loadSelectedContext() {
      if (!providerInstance || !Array.isArray(selectedContextIds) || selectedContextIds.length === 0) {
        setSelectedContextMarkdown("")
        return
      }
      try {
        const parts: string[] = []
        for (const id of selectedContextIds) {
          const { blob } = await providerInstance.getBinary(id)
          const text = await blob.text()
          parts.push(text)
        }
        setSelectedContextMarkdown(parts.join("\n\n---\n\n"))
      } catch (e) {
        console.error('Fehler beim Laden des Kontextes', e)
        setSelectedContextMarkdown("")
      }
    }
    void loadSelectedContext()
  }, [providerInstance, selectedContextIds])

  function parseTemplateContent(content: string, fileName: string): Template {
    // Template in drei Bereiche aufteilen
    const parts = content.split('--- systemprompt')
    
    let yamlFrontmatter = ""
    let markdownBody = ""
    let systemPrompt = ""
    
    if (parts.length >= 2) {
      const mainContent = parts[0].trim()
      systemPrompt = parts[1].trim()
      
      // YAML Frontmatter extrahieren
      const yamlMatch = mainContent.match(/^---\n([\s\S]*?)\n---\n([\s\S]*)$/)
      if (yamlMatch) {
        yamlFrontmatter = `---\n${yamlMatch[1]}\n---`
        markdownBody = yamlMatch[2].trim()
      } else {
        // Kein YAML Frontmatter gefunden
        markdownBody = mainContent
      }
    } else {
      // Kein Systemprompt gefunden
      const yamlMatch = content.match(/^---\n([\s\S]*?)\n---\n([\s\S]*)$/)
      if (yamlMatch) {
        yamlFrontmatter = `---\n${yamlMatch[1]}\n---`
        markdownBody = yamlMatch[2].trim()
      } else {
        markdownBody = content
      }
    }

    return {
      name: fileName,
      yamlFrontmatter,
      markdownBody,
      systemPrompt,
    }
  }

  function generateTemplateContent(values: TemplateFormValues): string {
    let content = ""
    
    // YAML Frontmatter hinzufügen
    if (values.yamlFrontmatter.trim()) {
      content += values.yamlFrontmatter + "\n\n"
    }
    
    // Markdown Body hinzufügen
    content += values.markdownBody
    
    // System Prompt hinzufügen
    if (values.systemPrompt.trim()) {
      content += "\n\n--- systemprompt\n" + values.systemPrompt
    }
    
    return content
  }

  async function onSubmit(data: TemplateFormValues) {
    if (!activeLibrary || !templatesFolderId || !providerInstance) {
      toast({
        title: "Fehler",
        description: "Keine aktive Bibliothek oder Templates-Ordner nicht gefunden.",
        variant: "destructive",
      })
      return
    }

    setIsSaving(true)
    try {
      const templateContent = generateTemplateContent(data)
      const fileName = `${data.name}.md`
      
      // Datei als Blob erstellen
      const blob = new Blob([templateContent], { type: 'text/markdown' })
      const file = new File([blob], fileName, { type: 'text/markdown' })
      
      // Datei hochladen
      await providerInstance.uploadFile(templatesFolderId, file)
      
      // Templates neu laden
      await loadTemplates()
      
      // Auswahl auf das neue Template setzen
      setSelectedTemplateName(data.name)
      
      toast({
        title: "Template gespeichert",
        description: `Template "${data.name}" wurde erfolgreich im Verzeichnis "/templates" gespeichert.`,
      })
    } catch (error) {
      console.error('Fehler beim Speichern des Templates:', error)
      toast({
        title: "Fehler beim Speichern",
        description: error instanceof Error ? error.message : "Unbekannter Fehler",
        variant: "destructive",
      })
    } finally {
      setIsSaving(false)
    }
  }

  async function renameCurrentTemplate() {
    const current = selectedTemplateName ? templates.find(t => t.name === selectedTemplateName) : null
    if (!current || !current.fileId || !providerInstance) return
    const newName = (window.prompt('Neuen Namen eingeben:', current.name) || '').trim()
    if (!newName || newName === current.name) return
    if (/[^a-zA-Z0-9._\- ]/.test(newName)) { toast({ title: 'Ungültiger Name', description: 'Nur Buchstaben, Zahlen, Leerzeichen, . _ - sind erlaubt.', variant: 'destructive' }); return }
    if (templates.some(t => t.name.toLowerCase() === newName.toLowerCase())) { toast({ title: 'Bereits vorhanden', description: 'Bitte anderen Namen wählen.', variant: 'destructive' }); return }
    try {
      await providerInstance.renameItem(current.fileId, `${newName}.md`)
      await loadTemplates()
      setSelectedTemplateName(newName)
      form.setValue('name', newName, { shouldDirty: false })
      toast({ title: 'Umbenannt', description: `${current.name} → ${newName}` })
    } catch (e) {
      toast({ title: 'Fehler beim Umbenennen', description: e instanceof Error ? e.message : 'Unbekannter Fehler', variant: 'destructive' })
    }
  }

  async function deleteTemplate(templateName: string) {
    if (!activeLibrary || !providerInstance) return

    try {
      const template = templates.find(t => t.name === templateName)
      if (!template?.fileId) {
        throw new Error("Template-Datei nicht gefunden")
      }

      // Datei löschen
      await providerInstance.deleteItem(template.fileId)

      // Templates neu laden
      await loadTemplates()
      
      if (selectedTemplateName === templateName) {
        setSelectedTemplateName(null)
        form.reset()
      }
      
      toast({
        title: "Template gelöscht",
        description: `Template "${templateName}" wurde erfolgreich gelöscht.`,
      })
    } catch (error) {
      console.error('Fehler beim Löschen des Templates:', error)
      toast({
        title: "Fehler beim Löschen",
        description: error instanceof Error ? error.message : "Unbekannter Fehler",
        variant: "destructive",
      })
    }
  }

  async function createNewTemplate() {
    const name = (window.prompt('Neuen Template‑Namen eingeben:') || '').trim()
    if (!name) return
    if (/[^a-zA-Z0-9._\- ]/.test(name)) { toast({ title: 'Ungültiger Name', description: 'Nur Buchstaben, Zahlen, Leerzeichen, . _ - sind erlaubt.', variant: 'destructive' }); return }
    if (templates.some(t => t.name.toLowerCase() === name.toLowerCase())) { toast({ title: 'Bereits vorhanden', description: 'Bitte anderen Namen wählen.', variant: 'destructive' }); return }
    if (!providerInstance) { toast({ title: 'Kein Provider' , variant: 'destructive' }); return }
    try {
      const folderId = await ensureTemplatesFolder()
      const values = getDefaultTemplateValues(name)
      const content = (values.yamlFrontmatter ? values.yamlFrontmatter + '\n\n' : '') + values.markdownBody + '\n\n--- systemprompt\n' + values.systemPrompt
      const file = new File([new Blob([content], { type: 'text/markdown' })], `${name}.md`, { type: 'text/markdown' })
      await providerInstance.uploadFile(folderId, file)
      await loadTemplates()
      setSelectedTemplateName(name)
      form.reset(values)
      toast({ title: 'Template angelegt', description: `"${name}" wurde erstellt.` })
    } catch (e) {
      toast({ title: 'Fehler beim Anlegen', description: e instanceof Error ? e.message : 'Unbekannter Fehler', variant: 'destructive' })
    }
  }

  function generatePreview(): string {
    const values = form.getValues()
    return generateTemplateContent(values)
  }

  async function testTemplate() {
    if (!activeLibrary) return

    setIsTesting(true)
    setTestResult(null)

    const values = form.getValues()
    const templateContent = generateTemplateContent(values)
    const testText = selectedContextMarkdown || ""

    try {
      const response = await fetch('/api/secretary/process-text', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/x-www-form-urlencoded',
          'X-Library-Id': activeLibrary.id,
        },
        body: new URLSearchParams({
          text: testText,
          template_content: templateContent,
          source_language: 'de',
          target_language: 'de',
        }),
      })

      if (!response.ok) {
        const errorData = await response.json()
        throw new Error(errorData.error || `HTTP ${response.status}: ${response.statusText}`)
      }

      const result = await response.json()
      const formattedResult = typeof result === 'string' ? result : JSON.stringify(result, null, 2)
      setTestResult(formattedResult)
      setRightTab('ergebnis')

      toast({
        title: "Prompt-Test erfolgreich",
        description: "Der Prompt wurde erfolgreich mit dem gewählten Kontext verarbeitet.",
      })

      console.log('Prompt-Test Ergebnis:', result)
    } catch (error) {
      console.error('Fehler beim Prompt-Test:', error)
      const errorMessage = error instanceof Error ? error.message : "Unbekannter Fehler"
      setTestResult(`Fehler: ${errorMessage}`)
      setRightTab('ergebnis')
      toast({
        title: "Prompt-Test fehlgeschlagen",
        description: errorMessage,
        variant: "destructive",
      })
    } finally {
      setIsTesting(false)
    }
  }

  async function ensurePromptTestsFolder(): Promise<string> {
    if (!providerInstance) throw new Error('Kein Provider verfügbar')
    const roots = await listItems('root')
    const found = roots.find(it => it.type === 'folder' && it.metadata.name === 'prompt-tests')
    if (found) return found.id
    const created = await providerInstance.createFolder('root', 'prompt-tests')
    return created.id
  }

  async function saveTestResult() {
    try {
      if (!providerInstance || !activeLibrary || !testResult) return
      const folderId = await ensurePromptTestsFolder()
      const name = `${selectedTemplateName || 'prompt'}-test-${new Date().toISOString().replace(/[:.]/g,'-')}.md`
      const blob = new Blob([testResult], { type: 'text/markdown' })
      const file = new File([blob], name, { type: 'text/markdown' })
      const item = await providerInstance.uploadFile(folderId, file)
      setResultSavedItemId(item.id)
      toast({ title: 'Ergebnis gespeichert', description: name })
    } catch (e) {
      toast({ title: 'Speichern fehlgeschlagen', description: e instanceof Error ? e.message : 'Unbekannter Fehler', variant: 'destructive' })
    }
  }

  // Render-Logik für verschiedene Status
  if (libraryStatus === "waitingForAuth") {
    return (
      <div className="flex flex-col items-center justify-center h-full text-muted-foreground">
        <span>Diese Bibliothek benötigt eine Authentifizierung.</span>
        <span className="text-sm mt-2">Bitte konfigurieren Sie die Bibliothek in den Einstellungen.</span>
      </div>
    )
  }
  
  if (libraryStatus !== "ready") {
    return (
      <div className="flex flex-col items-center justify-center h-full text-muted-foreground">
        <span>Lade Storage...</span>
      </div>
    )
  }

  if (!activeLibrary) {
    return (
      <div className="text-center text-muted-foreground">
        Bitte wählen Sie eine Bibliothek aus.
      </div>
    )
  }

  if (error) {
    return (
      <div className="text-center text-destructive">
        <p>Fehler beim Laden der Prompts:</p>
        <p className="text-sm">{error}</p>
        <Button 
          variant="outline" 
          className="mt-4"
          onClick={loadTemplates}
        >
          Erneut versuchen
        </Button>
      </div>
    )
  }

  return (
    <div className="space-y-6">

      {/* Kompakte Toolbar oben */}
      <div className="flex items-center gap-2">
        <Select value={selectedTemplateName || ''} onValueChange={(v) => { setSelectedTemplateName(v); form.setValue('name', v, { shouldDirty: false }) }} disabled={isLoading}>
          <SelectTrigger className="w-64">
            <SelectValue placeholder="Prompt auswählen..." />
          </SelectTrigger>
          <SelectContent>
            {templates.map((t) => (
              <SelectItem key={t.name} value={t.name}>{t.name}</SelectItem>
            ))}
          </SelectContent>
        </Select>
        <TooltipProvider>
          <Tooltip>
            <TooltipTrigger asChild>
              <Button variant="ghost" size="sm" className="h-8 w-8 p-0"><Info className="h-4 w-4" /></Button>
            </TooltipTrigger>
            <TooltipContent>
              <div className="flex items-center gap-2"><FolderOpen className="h-4 w-4" /><span>Ort: /templates in „{activeLibrary.label}“</span></div>
            </TooltipContent>
          </Tooltip>
        </TooltipProvider>
        <Button type="button" variant="outline" size="sm" onClick={createNewTemplate} disabled={isLoading}>Neu</Button>
        <Button type="button" variant="outline" size="sm" onClick={renameCurrentTemplate} disabled={!selectedTemplateName}>Umbenennen</Button>
        {selectedTemplateName && (
          <Button type="button" variant="destructive" size="sm" onClick={() => deleteTemplate(selectedTemplateName!)}>Löschen</Button>
        )}
      </div>

      <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
        <Card>
          <CardHeader>
            <CardTitle>Prompt Design</CardTitle>
            <CardDescription>
              Drei Bereiche: Aufgabe (was), Rollenanweisung (wie), Metadaten (Begleitinfos).
            </CardDescription>
          </CardHeader>
          <CardContent>
            <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-6">
              {/* Template-Name Feld entfernt (oben verwaltet) */}

              {previewMode ? (
                <div className="space-y-4">
                  <div className="flex items-center justify-between">
                    <h4 className="text-sm font-medium">Prompt-Vorschau</h4>
                    <Button
                      type="button"
                      variant="outline"
                      size="sm"
                      onClick={() => setPreviewMode(false)}
                    >
                      Bearbeiten
                    </Button>
                  </div>
                  <div className="border rounded-md p-4 bg-muted/50">
                    <pre className="text-sm whitespace-pre-wrap font-mono">
                      {generatePreview()}
                    </pre>
                  </div>
                </div>
              ) : (
                <StructuredTemplateEditor
                  markdownBody={form.watch('markdownBody')}
                  yamlFrontmatter={form.watch('yamlFrontmatter')}
                  systemPrompt={form.watch('systemPrompt')}
                  onChange={({ markdownBody, yamlFrontmatter, systemPrompt }) => {
                    form.setValue('markdownBody', markdownBody, { shouldDirty: true })
                    form.setValue('yamlFrontmatter', yamlFrontmatter, { shouldDirty: true })
                    form.setValue('systemPrompt', systemPrompt, { shouldDirty: true })
                  }}
                />
              )}

              <div className="flex justify-end gap-2">
                <Button
                  type="button"
                  variant="outline"
                  onClick={() => setPreviewMode(!previewMode)}
                >
                  <Eye className="h-4 w-4 mr-2" />
                  {previewMode ? "Bearbeiten" : "Vorschau"}
                </Button>
                <Button
                  type="submit"
                  disabled={isSaving || !form.formState.isDirty}
                >
                  {isSaving ? (
                    <>
                      <Loader2 className="h-4 w-4 mr-2 animate-spin" />
                      Wird gespeichert...
                    </>
                  ) : (
                    <>
                      <Save className="h-4 w-4 mr-2" />
                      Speichern
                    </>
                  )}
                </Button>
              </div>
            </form>
          </CardContent>
        </Card>

        <Card>
          <CardHeader>
            <CardTitle>Prompt testen</CardTitle>
            <CardDescription>
              Test mit Beispieltext. Nutzt Rollenanweisung, Aufgabe und Metadaten des Prompts.
            </CardDescription>
          </CardHeader>
          <CardContent>
            <Tabs value={rightTab} onValueChange={(v) => setRightTab(v as typeof rightTab)}>
              <TabsList className="grid grid-cols-3 w-full">
                <TabsTrigger value="kontext">Daten‑Kontext</TabsTrigger>
                <TabsTrigger value="preview">Prompt‑Vorschau</TabsTrigger>
                <TabsTrigger value="ergebnis">Ergebnis</TabsTrigger>
              </TabsList>

              <TabsContent value="kontext" className="space-y-4 mt-4">
                <div className="space-y-2">
                  <Label>Kontext-Texte</Label>
                  <div className="border rounded p-2 text-sm">
                    {Array.isArray(contextDocs) && contextDocs.length > 0 ? (
                      contextDocs.map(d => {
                        const checked = selectedContextIds.includes(d.id)
                        return (
                          <label key={d.id} className="flex items-center gap-2 py-1">
                            <Checkbox
                              checked={checked}
                              onCheckedChange={(v) => {
                                const isOn = v === true
                                setSelectedContextIds(prev => isOn ? [...prev, d.id] : prev.filter(x => x !== d.id))
                              }}
                            />
                            <span className="truncate">{d.name}</span>
                          </label>
                        )
                      })
                    ) : (
                      <div className="text-muted-foreground text-sm">Keine Kontext-Texte verfügbar</div>
                    )}
                  </div>
                </div>

                <div className="space-y-2">
                  <Label>Gewählter Kontext (Lesemodus)</Label>
                  <div className="border rounded-md">
                    <MarkdownPreview content={selectedContextMarkdown} />
                  </div>
                </div>
              </TabsContent>

              <TabsContent value="preview" className="space-y-4 mt-4">
                <div className="space-y-2">
                  <Label>Generierter Prompt (Markdown)</Label>
                  <div className="border rounded-md">
                    <MarkdownPreview content={generatePreview()} />
                  </div>
                </div>
                <div className="flex gap-2">
                  <Button 
                    variant="outline" 
                    size="sm"
                    onClick={testTemplate}
                    disabled={!selectedTemplateName || isTesting}
                  >
                    {isTesting ? (
                      <>
                        <Loader2 className="h-4 w-4 mr-2 animate-spin" />
                        Teste...
                      </>
                    ) : (
                      <>
                        <Play className="h-4 w-4 mr-2" />
                        Prompt testen
                      </>
                    )}
                  </Button>
                </div>
              </TabsContent>

              <TabsContent value="ergebnis" className="space-y-4 mt-4">
                <Tabs defaultValue="md">
                  <TabsList className="w-full grid grid-cols-2">
                    <TabsTrigger value="md">Markdown</TabsTrigger>
                    <TabsTrigger value="meta">Metadaten</TabsTrigger>
                  </TabsList>
                  <TabsContent value="md" className="space-y-2 mt-2">
                    <Label>Ergebnis</Label>
                    <div className="border rounded-md">
                      <MarkdownPreview content={testResult || ''} />
                    </div>
                    <div className="flex gap-2">
                      <Button type="button" onClick={saveTestResult} disabled={!testResult}>Speichern</Button>
                    </div>
                  </TabsContent>
                  <TabsContent value="meta" className="mt-2">
                    {resultSavedItemId && providerInstance && activeLibrary ? (
                      <JobReportTab libraryId={activeLibrary.id} fileId={resultSavedItemId} provider={providerInstance} sourceMode="frontmatter" viewMode="metaOnly" mdFileId={resultSavedItemId} />
                    ) : (
                      <div className="text-sm text-muted-foreground">Bitte Ergebnis speichern, um Metadaten und Kapitel anzuzeigen.</div>
                    )}
                  </TabsContent>
                </Tabs>
              </TabsContent>
            </Tabs>
          </CardContent>
        </Card>
      </div>
    </div>
  )
} 
```

Ja, möglich. Ich habe rechts die künstlichen Höhenbeschränkungen entfernt:

- Kontext-Texte: max-h/overflow entfernt → Liste wächst, Seite scrollt.
- Gewählter Kontext (Lesemodus): `MarkdownPreview` ohne max-h/overflow → wächst voll mit.
- Prompt‑Vorschau/Ergebnis: ebenfalls ohne max-h/overflow → gesamte Seite kann nach unten erweitern.

Damit verhalten sich beide Spalten konsistent: Lange Prompts links oder langer Kontext/Output rechts vergrößern die Seite, statt abgeschnitten zu werden.

---

**User**

Lesemodus sollte bei jedem Dokument im Text beginnen mit Datei, Doppelpunkt, Dateiname und danach beginnt der Text. Beim nächsten Dokument wieder Datei, Doppelpunkt, Text. Alle Dateien sollten mit sehr markanten Zeichen, vielleicht so einem langen Trenner-Symbol im Markdown-Format auch gesplittet werden, sodass man das LLM danach genau erkennt, welches Dokument welchen Dateinamen hat und von wo bis wo geht.

---

**Cursor**

```typescriptreact
"use client"

import { useState, useEffect, useCallback } from "react"
import { useForm } from "react-hook-form"
import { zodResolver } from "@hookform/resolvers/zod"
import * as z from "zod"
import { Button } from "@/components/ui/button"
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card"
import { Label } from "@/components/ui/label"
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select"
import { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from "@/components/ui/tooltip"
import { StructuredTemplateEditor } from "@/components/templates/structured-template-editor"
import { useToast } from "@/hooks/use-toast"
import { Loader2, Save, Eye, Play, FolderOpen, Info } from "lucide-react"
import { useAtom, useAtomValue } from "jotai"
import { activeLibraryAtom, libraryStatusAtom } from "@/atoms/library-atom"
import { 
  templatesAtom, 
  selectedTemplateNameAtom, 
  selectedTemplateAtom,
  templatesFolderIdAtom,
  templateLoadingAtom,
  templateErrorAtom,
  type Template
} from "@/atoms/template-atom"
import { useStorage } from "@/contexts/storage-context"
import { templateContextDocsAtom } from '@/atoms/template-context-atom'
import { Checkbox } from "@/components/ui/checkbox"
import { MarkdownPreview } from "@/components/library/markdown-preview"
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs"
import { JobReportTab } from "@/components/library/job-report-tab"

// Schema für Template-Daten
const templateSchema = z.object({
  name: z.string().min(1, "Prompt-Name ist erforderlich"),
  yamlFrontmatter: z.string(),
  markdownBody: z.string(),
  systemPrompt: z.string(),
})

type TemplateFormValues = z.infer<typeof templateSchema>

export function TemplateManagement() {
  const [previewMode, setPreviewMode] = useState(false)
  const [isSaving, setIsSaving] = useState(false)
  const [isTesting, setIsTesting] = useState(false)
  const [testResult, setTestResult] = useState<string | null>(null)
  const [selectedContextIds, setSelectedContextIds] = useState<string[]>([])
  const [selectedContextMarkdown, setSelectedContextMarkdown] = useState<string>("")
  const [rightTab, setRightTab] = useState<'kontext'|'preview'|'ergebnis'>('kontext')
  const [resultSavedItemId, setResultSavedItemId] = useState<string | null>(null)
  const { toast } = useToast()

  // Atoms
  const [templates, setTemplates] = useAtom(templatesAtom)
  const [selectedTemplateName, setSelectedTemplateName] = useAtom(selectedTemplateNameAtom)
  const [selectedTemplate] = useAtom(selectedTemplateAtom)
  const [templatesFolderId, setTemplatesFolderId] = useAtom(templatesFolderIdAtom)
  const [isLoading, setIsLoading] = useAtom(templateLoadingAtom)
  const [error, setError] = useAtom(templateErrorAtom)

  // Library und Storage
  const activeLibrary = useAtomValue(activeLibraryAtom)
  const libraryStatus = useAtomValue(libraryStatusAtom)
  const { 
    provider: providerInstance, 
    listItems
  } = useStorage()
  const contextDocs = useAtomValue(templateContextDocsAtom)

  const form = useForm<TemplateFormValues>({
    resolver: zodResolver(templateSchema),
    defaultValues: {
      name: "",
      yamlFrontmatter: `---
title: {{title|Titel des Dokuments}}
tags: {{tags|Relevante Tags}}
date: {{date|Datum im Format yyyy-mm-dd}}
---`,
      markdownBody: `# {{title}}

## Zusammenfassung
{{summary|Kurze Zusammenfassung des Inhalts}}

## Details
{{details|Detaillierte Beschreibung}}`,
      systemPrompt: `You are a specialized assistant that processes and structures information clearly and concisely.

IMPORTANT: Your response must be a valid JSON object where each key corresponds to a template variable.`,
    },
  })

  // Helper zum Erzeugen von Default-Werten
  function getDefaultTemplateValues(name: string): TemplateFormValues {
    return {
      name,
      yamlFrontmatter: `---\n` +
        `title: {{title|Titel des Dokuments}}\n` +
        `tags: {{tags|Relevante Tags}}\n` +
        `date: {{date|Datum im Format yyyy-mm-dd}}\n` +
        `---`,
      markdownBody: `# {{title}}\n\n## Zusammenfassung\n{{summary|Kurze Zusammenfassung des Inhalts}}\n\n## Details\n{{details|Detaillierte Beschreibung}}`,
      systemPrompt: `You are a specialized assistant that processes and structures information clearly and concisely.\n\nIMPORTANT: Your response must be a valid JSON object where each key corresponds to a template variable.`,
    }
  }

  // Template-Daten laden wenn sich die Auswahl ändert
  useEffect(() => {
    if (selectedTemplate) {
      form.reset({
        name: selectedTemplate.name,
        yamlFrontmatter: selectedTemplate.yamlFrontmatter,
        markdownBody: selectedTemplate.markdownBody,
        systemPrompt: selectedTemplate.systemPrompt,
      })
    }
  }, [selectedTemplate, form])

  // Ordner-Erstellung/Suche memoisiert, damit als Dep verwendbar
  const ensureTemplatesFolder = useCallback(async (): Promise<string> => {
    if (!providerInstance || !activeLibrary) {
      throw new Error("Keine aktive Bibliothek oder Provider verfügbar");
    }

    try {
      console.log('[TemplateManagement] Suche nach Templates-Ordner...');
      const rootItems = await listItems('root');
      const templatesFolder = rootItems.find(item => 
        item.type === 'folder' && item.metadata.name === 'templates'
      );
      if (templatesFolder) {
        console.log('[TemplateManagement] Templates-Ordner gefunden:', templatesFolder.id);
        return templatesFolder.id;
      }
      console.log('[TemplateManagement] Templates-Ordner nicht gefunden, erstelle neuen...');
      const newFolder = await providerInstance.createFolder('root', 'templates');
      console.log('[TemplateManagement] Neuer Templates-Ordner erstellt:', newFolder.id);
      return newFolder.id;
    } catch (error) {
      console.error('Fehler beim Erstellen des Templates-Ordners:', {
        error: error instanceof Error ? {
          message: error.message,
          name: error.name,
          stack: error.stack?.split('\n').slice(0, 3)
        } : error,
        libraryId: activeLibrary?.id,
        libraryPath: activeLibrary?.path,
        providerName: providerInstance?.name
      });
      let errorMessage = 'Fehler beim Erstellen des Templates-Ordners';
      if (error instanceof Error) {
        if (error.message.includes('Nicht authentifiziert')) {
          errorMessage = 'Bitte authentifizieren Sie sich bei Ihrem Cloud-Speicher, um den Templates-Ordner zu erstellen.';
        } else if (error.message.includes('Keine Berechtigung')) {
          errorMessage = 'Keine Berechtigung zum Erstellen von Ordnern in der Bibliothek.';
        } else if (error.message.includes('Bibliothek nicht gefunden')) {
          errorMessage = 'Die ausgewählte Bibliothek wurde nicht gefunden.';
        } else {
          errorMessage = `Fehler beim Erstellen des Templates-Ordners: ${error.message}`;
        }
      }
      throw new Error(errorMessage);
    }
  }, [providerInstance, activeLibrary, listItems]);

  // Templates laden mit der gleichen Logik wie Library-Komponente
  const loadTemplates = useCallback(async () => {
    if (!providerInstance || libraryStatus !== 'ready' || !activeLibrary) {
      console.log('[TemplateManagement] loadTemplates übersprungen:', {
        hasProvider: !!providerInstance,
        libraryStatus,
        hasActiveLibrary: !!activeLibrary
      });
      return;
    }

    try {
      setIsLoading(true);
      setError(null);

      console.log('[TemplateManagement] Starte Prompt-Loading:', {
        libraryId: activeLibrary.id,
        libraryPath: activeLibrary.path,
        providerName: providerInstance.name
      });

      // 1. Templates-Ordner finden oder erstellen
      const folderId = await ensureTemplatesFolder();
      setTemplatesFolderId(folderId);

      console.log('[TemplateManagement] Templates-Ordner gefunden/erstellt:', folderId);

      // 2. Alle Template-Dateien im Ordner auflisten
      const items = await listItems(folderId);
      const templateFiles = items.filter(item => 
        item.type === 'file' && 
        item.metadata.name.endsWith('.md')
      );

      console.log('[TemplateManagement] Prompt-Dateien gefunden:', templateFiles.length);

      // 3. Template-Inhalte laden
      const templatePromises = templateFiles.map(async (file) => {
        try {
          const { blob } = await providerInstance.getBinary(file.id);
          const content = await blob.text();
          const template = parseTemplateContent(content, file.metadata.name.replace('.md', ''));
          
          return {
            ...template,
            fileId: file.id,
            lastModified: typeof file.metadata.modifiedAt === 'string' 
              ? file.metadata.modifiedAt 
              : file.metadata.modifiedAt instanceof Date 
                ? file.metadata.modifiedAt.toISOString()
                : new Date().toISOString()
          } as Template;
        } catch (error) {
          console.error(`Fehler beim Parsen von ${file.metadata.name}:`, error);
          return null;
        }
      });

      const loadedTemplates = await Promise.all(templatePromises);
      const validTemplates = loadedTemplates.filter((t): t is Template => t !== null);
      
      setTemplates(validTemplates);
      
      console.log('[TemplateManagement] Prompts erfolgreich geladen:', validTemplates.length);
      
      if (validTemplates.length === 0) {
        toast({
          title: "Keine Prompts gefunden",
          description: "Erstellen Sie Ihren ersten Prompt im Verzeichnis '/templates'.",
        });
      }
    } catch (error) {
      console.error('Fehler beim Laden der Prompts:', {
        error: error instanceof Error ? {
          message: error.message,
          name: error.name,
          stack: error.stack?.split('\n').slice(0, 3)
        } : error,
        libraryId: activeLibrary?.id,
        libraryPath: activeLibrary?.path,
        providerName: providerInstance?.name
      });

      let errorMessage = 'Unbekannter Fehler beim Laden der Prompts';
      
      if (error instanceof Error) {
        errorMessage = error.message;
        
        // Spezifische Fehlermeldungen für häufige Probleme
        if (error.message.includes('Nicht authentifiziert')) {
          errorMessage = 'Bitte authentifizieren Sie sich bei Ihrem Cloud-Speicher, um Prompts zu laden.';
        } else if (error.message.includes('Bibliothek nicht gefunden')) {
          errorMessage = 'Die ausgewählte Bibliothek wurde nicht gefunden. Bitte überprüfen Sie die Bibliothekskonfiguration.';
        } else if (error.message.includes('Server-Fehler')) {
          errorMessage = 'Server-Fehler beim Laden der Prompts. Bitte überprüfen Sie, ob der Bibliothekspfad existiert und zugänglich ist.';
        } else if (error.message.includes('Keine aktive Bibliothek')) {
          errorMessage = 'Keine aktive Bibliothek verfügbar. Bitte wählen Sie eine Bibliothek aus.';
        }
      }
      
      setError(errorMessage);
      toast({
        title: "Fehler beim Laden der Prompts",
        description: errorMessage,
        variant: "destructive",
      });
    } finally {
      setIsLoading(false);
    }
  }, [providerInstance, libraryStatus, activeLibrary, listItems, setTemplates, setTemplatesFolderId, setIsLoading, setError, toast, ensureTemplatesFolder]);

  // Effect für Template Loading (wie Library-Komponente)
  useEffect(() => {
    const isReady = providerInstance && libraryStatus === 'ready' && activeLibrary
    
    if (!isReady) {
      return
    }

    // Templates laden wenn noch nicht geladen
    if (!templatesFolderId) {
      loadTemplates()
    }
  }, [providerInstance, libraryStatus, activeLibrary, templatesFolderId, loadTemplates])

  // Reset wenn sich die Library ändert
  useEffect(() => {
    setSelectedTemplateName(null)
    setTemplatesFolderId(null)
    setTemplates([])
    setError(null)
  }, [libraryStatus, setSelectedTemplateName, setTemplatesFolderId, setTemplates, setError])

  useEffect(() => {
    async function loadSelectedContext() {
      if (!providerInstance || !Array.isArray(selectedContextIds) || selectedContextIds.length === 0) {
        setSelectedContextMarkdown("")
        return
      }
      try {
        const parts: string[] = []
        for (const id of selectedContextIds) {
          const { blob } = await providerInstance.getBinary(id)
          const text = await blob.text()
          const name = Array.isArray(contextDocs) ? (contextDocs.find(d => d.id === id)?.name || id) : id
          const section = `\n\n---\nDatei: ${name}\n---\n\n${text}\n\n---\nEnde Datei: ${name}\n---\n`
          parts.push(section)
        }
        setSelectedContextMarkdown(parts.join("\n\n"))
      } catch (e) {
        console.error('Fehler beim Laden des Kontextes', e)
        setSelectedContextMarkdown("")
      }
    }
    void loadSelectedContext()
  }, [providerInstance, selectedContextIds, contextDocs])

  function parseTemplateContent(content: string, fileName: string): Template {
    // Template in drei Bereiche aufteilen
    const parts = content.split('--- systemprompt')
    
    let yamlFrontmatter = ""
    let markdownBody = ""
    let systemPrompt = ""
    
    if (parts.length >= 2) {
      const mainContent = parts[0].trim()
      systemPrompt = parts[1].trim()
      
      // YAML Frontmatter extrahieren
      const yamlMatch = mainContent.match(/^---\n([\s\S]*?)\n---\n([\s\S]*)$/)
      if (yamlMatch) {
        yamlFrontmatter = `---\n${yamlMatch[1]}\n---`
        markdownBody = yamlMatch[2].trim()
      } else {
        // Kein YAML Frontmatter gefunden
        markdownBody = mainContent
      }
    } else {
      // Kein Systemprompt gefunden
      const yamlMatch = content.match(/^---\n([\s\S]*?)\n---\n([\s\S]*)$/)
      if (yamlMatch) {
        yamlFrontmatter = `---\n${yamlMatch[1]}\n---`
        markdownBody = yamlMatch[2].trim()
      } else {
        markdownBody = content
      }
    }

    return {
      name: fileName,
      yamlFrontmatter,
      markdownBody,
      systemPrompt,
    }
  }

  function generateTemplateContent(values: TemplateFormValues): string {
    let content = ""
    
    // YAML Frontmatter hinzufügen
    if (values.yamlFrontmatter.trim()) {
      content += values.yamlFrontmatter + "\n\n"
    }
    
    // Markdown Body hinzufügen
    content += values.markdownBody
    
    // System Prompt hinzufügen
    if (values.systemPrompt.trim()) {
      content += "\n\n--- systemprompt\n" + values.systemPrompt
    }
    
    return content
  }

  async function onSubmit(data: TemplateFormValues) {
    if (!activeLibrary || !templatesFolderId || !providerInstance) {
      toast({
        title: "Fehler",
        description: "Keine aktive Bibliothek oder Templates-Ordner nicht gefunden.",
        variant: "destructive",
      })
      return
    }

    setIsSaving(true)
    try {
      const templateContent = generateTemplateContent(data)
      const fileName = `${data.name}.md`
      
      // Datei als Blob erstellen
      const blob = new Blob([templateContent], { type: 'text/markdown' })
      const file = new File([blob], fileName, { type: 'text/markdown' })
      
      // Datei hochladen
      await providerInstance.uploadFile(templatesFolderId, file)
      
      // Templates neu laden
      await loadTemplates()
      
      // Auswahl auf das neue Template setzen
      setSelectedTemplateName(data.name)
      
      toast({
        title: "Template gespeichert",
        description: `Template "${data.name}" wurde erfolgreich im Verzeichnis "/templates" gespeichert.`,
      })
    } catch (error) {
      console.error('Fehler beim Speichern des Templates:', error)
      toast({
        title: "Fehler beim Speichern",
        description: error instanceof Error ? error.message : "Unbekannter Fehler",
        variant: "destructive",
      })
    } finally {
      setIsSaving(false)
    }
  }

  async function renameCurrentTemplate() {
    const current = selectedTemplateName ? templates.find(t => t.name === selectedTemplateName) : null
    if (!current || !current.fileId || !providerInstance) return
    const newName = (window.prompt('Neuen Namen eingeben:', current.name) || '').trim()
    if (!newName || newName === current.name) return
    if (/[^a-zA-Z0-9._\- ]/.test(newName)) { toast({ title: 'Ungültiger Name', description: 'Nur Buchstaben, Zahlen, Leerzeichen, . _ - sind erlaubt.', variant: 'destructive' }); return }
    if (templates.some(t => t.name.toLowerCase() === newName.toLowerCase())) { toast({ title: 'Bereits vorhanden', description: 'Bitte anderen Namen wählen.', variant: 'destructive' }); return }
    try {
      await providerInstance.renameItem(current.fileId, `${newName}.md`)
      await loadTemplates()
      setSelectedTemplateName(newName)
      form.setValue('name', newName, { shouldDirty: false })
      toast({ title: 'Umbenannt', description: `${current.name} → ${newName}` })
    } catch (e) {
      toast({ title: 'Fehler beim Umbenennen', description: e instanceof Error ? e.message : 'Unbekannter Fehler', variant: 'destructive' })
    }
  }

  async function deleteTemplate(templateName: string) {
    if (!activeLibrary || !providerInstance) return

    try {
      const template = templates.find(t => t.name === templateName)
      if (!template?.fileId) {
        throw new Error("Template-Datei nicht gefunden")
      }

      // Datei löschen
      await providerInstance.deleteItem(template.fileId)

      // Templates neu laden
      await loadTemplates()
      
      if (selectedTemplateName === templateName) {
        setSelectedTemplateName(null)
        form.reset()
      }
      
      toast({
        title: "Template gelöscht",
        description: `Template "${templateName}" wurde erfolgreich gelöscht.`,
      })
    } catch (error) {
      console.error('Fehler beim Löschen des Templates:', error)
      toast({
        title: "Fehler beim Löschen",
        description: error instanceof Error ? error.message : "Unbekannter Fehler",
        variant: "destructive",
      })
    }
  }

  async function createNewTemplate() {
    const name = (window.prompt('Neuen Template‑Namen eingeben:') || '').trim()
    if (!name) return
    if (/[^a-zA-Z0-9._\- ]/.test(name)) { toast({ title: 'Ungültiger Name', description: 'Nur Buchstaben, Zahlen, Leerzeichen, . _ - sind erlaubt.', variant: 'destructive' }); return }
    if (templates.some(t => t.name.toLowerCase() === name.toLowerCase())) { toast({ title: 'Bereits vorhanden', description: 'Bitte anderen Namen wählen.', variant: 'destructive' }); return }
    if (!providerInstance) { toast({ title: 'Kein Provider' , variant: 'destructive' }); return }
    try {
      const folderId = await ensureTemplatesFolder()
      const values = getDefaultTemplateValues(name)
      const content = (values.yamlFrontmatter ? values.yamlFrontmatter + '\n\n' : '') + values.markdownBody + '\n\n--- systemprompt\n' + values.systemPrompt
      const file = new File([new Blob([content], { type: 'text/markdown' })], `${name}.md`, { type: 'text/markdown' })
      await providerInstance.uploadFile(folderId, file)
      await loadTemplates()
      setSelectedTemplateName(name)
      form.reset(values)
      toast({ title: 'Template angelegt', description: `"${name}" wurde erstellt.` })
    } catch (e) {
      toast({ title: 'Fehler beim Anlegen', description: e instanceof Error ? e.message : 'Unbekannter Fehler', variant: 'destructive' })
    }
  }

  function generatePreview(): string {
    const values = form.getValues()
    return generateTemplateContent(values)
  }

  async function testTemplate() {
    if (!activeLibrary) return

    setIsTesting(true)
    setTestResult(null)

    const values = form.getValues()
    const templateContent = generateTemplateContent(values)
    const testText = selectedContextMarkdown || ""

    try {
      const response = await fetch('/api/secretary/process-text', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/x-www-form-urlencoded',
          'X-Library-Id': activeLibrary.id,
        },
        body: new URLSearchParams({
          text: testText,
          template_content: templateContent,
          source_language: 'de',
          target_language: 'de',
        }),
      })

      if (!response.ok) {
        const errorData = await response.json()
        throw new Error(errorData.error || `HTTP ${response.status}: ${response.statusText}`)
      }

      const result = await response.json()
      const formattedResult = typeof result === 'string' ? result : JSON.stringify(result, null, 2)
      setTestResult(formattedResult)
      setRightTab('ergebnis')

      toast({
        title: "Prompt-Test erfolgreich",
        description: "Der Prompt wurde erfolgreich mit dem gewählten Kontext verarbeitet.",
      })

      console.log('Prompt-Test Ergebnis:', result)
    } catch (error) {
      console.error('Fehler beim Prompt-Test:', error)
      const errorMessage = error instanceof Error ? error.message : "Unbekannter Fehler"
      setTestResult(`Fehler: ${errorMessage}`)
      setRightTab('ergebnis')
      toast({
        title: "Prompt-Test fehlgeschlagen",
        description: errorMessage,
        variant: "destructive",
      })
    } finally {
      setIsTesting(false)
    }
  }

  async function ensurePromptTestsFolder(): Promise<string> {
    if (!providerInstance) throw new Error('Kein Provider verfügbar')
    const roots = await listItems('root')
    const found = roots.find(it => it.type === 'folder' && it.metadata.name === 'prompt-tests')
    if (found) return found.id
    const created = await providerInstance.createFolder('root', 'prompt-tests')
    return created.id
  }

  async function saveTestResult() {
    try {
      if (!providerInstance || !activeLibrary || !testResult) return
      const folderId = await ensurePromptTestsFolder()
      const name = `${selectedTemplateName || 'prompt'}-test-${new Date().toISOString().replace(/[:.]/g,'-')}.md`
      const blob = new Blob([testResult], { type: 'text/markdown' })
      const file = new File([blob], name, { type: 'text/markdown' })
      const item = await providerInstance.uploadFile(folderId, file)
      setResultSavedItemId(item.id)
      toast({ title: 'Ergebnis gespeichert', description: name })
    } catch (e) {
      toast({ title: 'Speichern fehlgeschlagen', description: e instanceof Error ? e.message : 'Unbekannter Fehler', variant: 'destructive' })
    }
  }

  // Render-Logik für verschiedene Status
  if (libraryStatus === "waitingForAuth") {
    return (
      <div className="flex flex-col items-center justify-center h-full text-muted-foreground">
        <span>Diese Bibliothek benötigt eine Authentifizierung.</span>
        <span className="text-sm mt-2">Bitte konfigurieren Sie die Bibliothek in den Einstellungen.</span>
      </div>
    )
  }
  
  if (libraryStatus !== "ready") {
    return (
      <div className="flex flex-col items-center justify-center h-full text-muted-foreground">
        <span>Lade Storage...</span>
      </div>
    )
  }

  if (!activeLibrary) {
    return (
      <div className="text-center text-muted-foreground">
        Bitte wählen Sie eine Bibliothek aus.
      </div>
    )
  }

  if (error) {
    return (
      <div className="text-center text-destructive">
        <p>Fehler beim Laden der Prompts:</p>
        <p className="text-sm">{error}</p>
        <Button 
          variant="outline" 
          className="mt-4"
          onClick={loadTemplates}
        >
          Erneut versuchen
        </Button>
      </div>
    )
  }

  return (
    <div className="space-y-6">

      {/* Kompakte Toolbar oben */}
      <div className="flex items-center gap-2">
        <Select value={selectedTemplateName || ''} onValueChange={(v) => { setSelectedTemplateName(v); form.setValue('name', v, { shouldDirty: false }) }} disabled={isLoading}>
          <SelectTrigger className="w-64">
            <SelectValue placeholder="Prompt auswählen..." />
          </SelectTrigger>
          <SelectContent>
            {templates.map((t) => (
              <SelectItem key={t.name} value={t.name}>{t.name}</SelectItem>
            ))}
          </SelectContent>
        </Select>
        <TooltipProvider>
          <Tooltip>
            <TooltipTrigger asChild>
              <Button variant="ghost" size="sm" className="h-8 w-8 p-0"><Info className="h-4 w-4" /></Button>
            </TooltipTrigger>
            <TooltipContent>
              <div className="flex items-center gap-2"><FolderOpen className="h-4 w-4" /><span>Ort: /templates in „{activeLibrary.label}“</span></div>
            </TooltipContent>
          </Tooltip>
        </TooltipProvider>
        <Button type="button" variant="outline" size="sm" onClick={createNewTemplate} disabled={isLoading}>Neu</Button>
        <Button type="button" variant="outline" size="sm" onClick={renameCurrentTemplate} disabled={!selectedTemplateName}>Umbenennen</Button>
        {selectedTemplateName && (
          <Button type="button" variant="destructive" size="sm" onClick={() => deleteTemplate(selectedTemplateName!)}>Löschen</Button>
        )}
      </div>

      <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
        <Card>
          <CardHeader>
            <CardTitle>Prompt Design</CardTitle>
            <CardDescription>
              Drei Bereiche: Aufgabe (was), Rollenanweisung (wie), Metadaten (Begleitinfos).
            </CardDescription>
          </CardHeader>
          <CardContent>
            <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-6">
              {/* Template-Name Feld entfernt (oben verwaltet) */}

              {previewMode ? (
                <div className="space-y-4">
                  <div className="flex items-center justify-between">
                    <h4 className="text-sm font-medium">Prompt-Vorschau</h4>
                    <Button
                      type="button"
                      variant="outline"
                      size="sm"
                      onClick={() => setPreviewMode(false)}
                    >
                      Bearbeiten
                    </Button>
                  </div>
                  <div className="border rounded-md p-4 bg-muted/50">
                    <pre className="text-sm whitespace-pre-wrap font-mono">
                      {generatePreview()}
                    </pre>
                  </div>
                </div>
              ) : (
                <StructuredTemplateEditor
                  markdownBody={form.watch('markdownBody')}
                  yamlFrontmatter={form.watch('yamlFrontmatter')}
                  systemPrompt={form.watch('systemPrompt')}
                  onChange={({ markdownBody, yamlFrontmatter, systemPrompt }) => {
                    form.setValue('markdownBody', markdownBody, { shouldDirty: true })
                    form.setValue('yamlFrontmatter', yamlFrontmatter, { shouldDirty: true })
                    form.setValue('systemPrompt', systemPrompt, { shouldDirty: true })
                  }}
                />
              )}

              <div className="flex justify-end gap-2">
                <Button
                  type="button"
                  variant="outline"
                  onClick={() => setPreviewMode(!previewMode)}
                >
                  <Eye className="h-4 w-4 mr-2" />
                  {previewMode ? "Bearbeiten" : "Vorschau"}
                </Button>
                <Button
                  type="submit"
                  disabled={isSaving || !form.formState.isDirty}
                >
                  {isSaving ? (
                    <>
                      <Loader2 className="h-4 w-4 mr-2 animate-spin" />
                      Wird gespeichert...
                    </>
                  ) : (
                    <>
                      <Save className="h-4 w-4 mr-2" />
                      Speichern
                    </>
                  )}
                </Button>
              </div>
            </form>
          </CardContent>
        </Card>

        <Card>
          <CardHeader>
            <CardTitle>Prompt testen</CardTitle>
            <CardDescription>
              Test mit Beispieltext. Nutzt Rollenanweisung, Aufgabe und Metadaten des Prompts.
            </CardDescription>
          </CardHeader>
          <CardContent>
            <Tabs value={rightTab} onValueChange={(v) => setRightTab(v as typeof rightTab)}>
              <TabsList className="grid grid-cols-3 w-full">
                <TabsTrigger value="kontext">Daten‑Kontext</TabsTrigger>
                <TabsTrigger value="preview">Prompt‑Vorschau</TabsTrigger>
                <TabsTrigger value="ergebnis">Ergebnis</TabsTrigger>
              </TabsList>

              <TabsContent value="kontext" className="space-y-4 mt-4">
                <div className="space-y-2">
                  <Label>Kontext-Texte</Label>
                  <div className="border rounded p-2 text-sm">
                    {Array.isArray(contextDocs) && contextDocs.length > 0 ? (
                      contextDocs.map(d => {
                        const checked = selectedContextIds.includes(d.id)
                        return (
                          <label key={d.id} className="flex items-center gap-2 py-1">
                            <Checkbox
                              checked={checked}
                              onCheckedChange={(v) => {
                                const isOn = v === true
                                setSelectedContextIds(prev => isOn ? [...prev, d.id] : prev.filter(x => x !== d.id))
                              }}
                            />
                            <span className="truncate">{d.name}</span>
                          </label>
                        )
                      })
                    ) : (
                      <div className="text-muted-foreground text-sm">Keine Kontext-Texte verfügbar</div>
                    )}
                  </div>
                </div>

                <div className="space-y-2">
                  <Label>Gewählter Kontext (Lesemodus)</Label>
                  <div className="border rounded-md">
                    <MarkdownPreview content={selectedContextMarkdown} />
                  </div>
                </div>
              </TabsContent>

              <TabsContent value="preview" className="space-y-4 mt-4">
                <div className="space-y-2">
                  <Label>Generierter Prompt (Markdown)</Label>
                  <div className="border rounded-md">
                    <MarkdownPreview content={generatePreview()} />
                  </div>
                </div>
                <div className="flex gap-2">
                  <Button 
                    variant="outline" 
                    size="sm"
                    onClick={testTemplate}
                    disabled={!selectedTemplateName || isTesting}
                  >
                    {isTesting ? (
                      <>
                        <Loader2 className="h-4 w-4 mr-2 animate-spin" />
                        Teste...
                      </>
                    ) : (
                      <>
                        <Play className="h-4 w-4 mr-2" />
                        Prompt testen
                      </>
                    )}
                  </Button>
                </div>
              </TabsContent>

              <TabsContent value="ergebnis" className="space-y-4 mt-4">
                <Tabs defaultValue="md">
                  <TabsList className="w-full grid grid-cols-2">
                    <TabsTrigger value="md">Markdown</TabsTrigger>
                    <TabsTrigger value="meta">Metadaten</TabsTrigger>
                  </TabsList>
                  <TabsContent value="md" className="space-y-2 mt-2">
                    <Label>Ergebnis</Label>
                    <div className="border rounded-md">
                      <MarkdownPreview content={testResult || ''} />
                    </div>
                    <div className="flex gap-2">
                      <Button type="button" onClick={saveTestResult} disabled={!testResult}>Speichern</Button>
                    </div>
                  </TabsContent>
                  <TabsContent value="meta" className="mt-2">
                    {resultSavedItemId && providerInstance && activeLibrary ? (
                      <JobReportTab libraryId={activeLibrary.id} fileId={resultSavedItemId} provider={providerInstance} sourceMode="frontmatter" viewMode="metaOnly" mdFileId={resultSavedItemId} />
                    ) : (
                      <div className="text-sm text-muted-foreground">Bitte Ergebnis speichern, um Metadaten und Kapitel anzuzeigen.</div>
                    )}
                  </TabsContent>
                </Tabs>
              </TabsContent>
            </Tabs>
          </CardContent>
        </Card>
      </div>
    </div>
  )
} 
```

- Lesemodus angepasst: Jeder Kontextabschnitt wird jetzt so formatiert:
  - Kopf: „— Datei: <Name> —“
  - Inhalt: Original-Markdown
  - Fuß: „— Ende Datei: <Name> —“
  - Dazwischen horizontale Markdown‑Trenner via `---`, damit LLMs klare Segment‑Grenzen erkennen.

Beispiel-Struktur:
```markdown
---
Datei: commoning.pdf
---

...Inhalt...

---
Ende Datei: commoning.pdf
---
```

Das wird für alle ausgewählten Dateien nacheinander erzeugt; die Seite scrollt jetzt vollständig mit.

```markdown
---
Datei: commoning.pdf
---

...Inhalt...

---
Ende Datei: commoning.pdf
---
```

---

**User**

Die Rollenanweisung muss als Markdown-Text angezeigt werden. Wenn man ihn anklickt kann man ihn als mehrzeitige Textfeld editieren.

---

**Cursor**

```typescriptreact
"use client";

import * as React from 'react'
// Hinweis: Body-Parsing erfolgt zeilenbasiert direkt in dieser Komponente
import { parseFrontmatterKeyValues } from '@/lib/markdown/frontmatter'
import { Button } from '@/components/ui/button'
import { Label } from '@/components/ui/label'
import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from '@/components/ui/table'
import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs'
import { GripVertical, Plus } from 'lucide-react'
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select'
import { MarkdownPreview } from '@/components/library/markdown-preview'

export interface StructuredTemplateEditorProps {
  markdownBody: string
  yamlFrontmatter: string
  systemPrompt: string
  onChange: (next: { markdownBody: string; yamlFrontmatter: string; systemPrompt: string }) => void
}

type LineKind = 'text' | 'h1' | 'h2' | 'h3' | 'bold' | 'variable'

export function StructuredTemplateEditor({ markdownBody, yamlFrontmatter, systemPrompt, onChange }: StructuredTemplateEditorProps) {
  const lines = React.useMemo(() => (typeof markdownBody === 'string' ? markdownBody.split('\n') : []), [markdownBody])
  const fmEntries = React.useMemo(() => parseFrontmatterKeyValues(yamlFrontmatter || ''), [yamlFrontmatter])
  const [sysPrompt, setSysPrompt] = React.useState(systemPrompt)
  const [tab, setTab] = React.useState<'body'|'frontmatter'|'system'>('body')
  const dragFrom = React.useRef<number | null>(null)
  const [sysEditing, setSysEditing] = React.useState(false)

  React.useEffect(() => { setSysPrompt(systemPrompt) }, [systemPrompt])

  // Zeilenbasierte Platzhalter-Erkennung (nur die betrachtete Zeile)
  function parseLine(line: string): { kind: LineKind; varKey: string; content: string } {
    const mVar = /^\s*\{\{([^}|]+)\|([^}]+)\}\}\s*$/.exec(line)
    if (mVar) return { kind: 'variable', varKey: (mVar[1] || '').trim(), content: (mVar[2] || '').trim() }
    if (/^\s*###\s+/.test(line)) return { kind: 'h3', varKey: '', content: line.replace(/^\s*###\s+/, '') }
    if (/^\s*##\s+/.test(line)) return { kind: 'h2', varKey: '', content: line.replace(/^\s*##\s+/, '') }
    if (/^\s*#\s+/.test(line)) return { kind: 'h1', varKey: '', content: line.replace(/^\s*#\s+/, '') }
    const mBold = /^\s*\*\*([\s\S]*?)\*\*\s*$/.exec(line)
    if (mBold) return { kind: 'bold', varKey: '', content: (mBold[1] || '') }
    return { kind: 'text', varKey: '', content: line }
  }

  function buildLine(kind: LineKind, content: string, varKey?: string): string {
    const text = content ?? ''
    switch (kind) {
      case 'variable': {
        const k = (varKey || '').trim()
        return k ? `{{${k}|${text}}}` : text
      }
      case 'h1': return `# ${text}`
      case 'h2': return `## ${text}`
      case 'h3': return `### ${text}`
      case 'bold': return `**${text}**`
      case 'text': default: return text
    }
  }

  function updateLineByIndex(lineIndex: number, nextLine: string) {
    const copy = lines.slice()
    if (lineIndex >= 0 && lineIndex < copy.length) copy[lineIndex] = nextLine
    onChange({ markdownBody: copy.join('\n'), yamlFrontmatter, systemPrompt: sysPrompt })
  }

  function suggestVarKey(index: number, content: string): string {
    const base = (content || '').toLowerCase().trim().replace(/[^a-z0-9]+/g, '_').replace(/^_+|_+$/g, '')
    const trimmed = base.length >= 3 ? base.slice(0, 24) : ''
    return trimmed || `var_${index + 1}`
  }

  function updateLineKind(lineIndex: number, nextKind: LineKind) {
    if (lineIndex < 0 || lineIndex >= lines.length) return
    const { content, varKey } = parseLine(lines[lineIndex])
    if (nextKind === 'variable') {
      const key = varKey && varKey.trim().length > 0 ? varKey : suggestVarKey(lineIndex, content)
      updateLineByIndex(lineIndex, buildLine('variable', content, key))
      return
    }
    updateLineByIndex(lineIndex, buildLine(nextKind, content, varKey))
  }

  function updateVarKey(lineIndex: number, nextKey: string) {
    if (lineIndex < 0 || lineIndex >= lines.length) return
    const { content } = parseLine(lines[lineIndex])
    const realKind: LineKind = 'variable'
    updateLineByIndex(lineIndex, buildLine(realKind, content, nextKey))
  }

  function updateContent(lineIndex: number, nextContent: string) {
    if (lineIndex < 0 || lineIndex >= lines.length) return
    const { kind, varKey } = parseLine(lines[lineIndex])
    updateLineByIndex(lineIndex, buildLine(kind, nextContent, varKey))
  }

  const updateFrontmatterQuestion = (entryKey: string, question: string) => {
    const linesFM = (yamlFrontmatter || '').split('\n')
    const idx = linesFM.findIndex(l => new RegExp(`^${escapeRegExp(entryKey)}\\s*:`).test(l.trim()))
    if (idx >= 0) {
      const line = linesFM[idx]
      const m = /\{\{([^}|]+)\|([^}]+)\}\}/.exec(line)
      if (m) {
        linesFM[idx] = line.replace(m[0], `{{${m[1]}|${question}}}`)
      }
      onChange({ markdownBody, yamlFrontmatter: linesFM.join('\n'), systemPrompt: sysPrompt })
    }
  }

  const handleSysPromptChange = (v: string) => {
    setSysPrompt(v)
    onChange({ markdownBody, yamlFrontmatter, systemPrompt: v })
  }

  return (
    <div className="space-y-3">
      <Tabs value={tab} onValueChange={(v) => setTab(v as typeof tab)}>
        <TabsList className="grid grid-cols-3 w-full">
          <TabsTrigger value="body">Aufgabe</TabsTrigger>
          <TabsTrigger value="frontmatter">Metadaten</TabsTrigger>
          <TabsTrigger value="system">Rollenanweisung</TabsTrigger>
        </TabsList>

        <TabsContent value="body">
          <div className="overflow-auto">
            <Table className="text-[11px] w-full border-collapse">
              <TableHeader>
                <TableRow className="[&>*]:py-1">
                  <TableHead className="w-8" />
                  <TableHead className="w-36">Typ/Variable</TableHead>
                  <TableHead>Text / Frage</TableHead>
                </TableRow>
              </TableHeader>
              <TableBody>
                {lines.length === 0 ? (
                  <TableRow><TableCell colSpan={3} className="text-muted-foreground">Keine Zeilen im Body.</TableCell></TableRow>
                ) : lines.map((line, i) => {
                  const { kind, varKey, content } = parseLine(line)
                  return (
                    <TableRow key={`line-${i}`} className="align-top" onDragOver={handleDragOver} onDrop={(e) => handleDrop(e, i)}>
                      <TableCell className="align-top w-8 py-1">
                        <div className="flex items-center gap-1">
                          <span
                            draggable
                            onDragStart={(e) => handleDragStart(e, i)}
                            className="inline-flex h-4 w-4 items-center justify-center text-muted-foreground cursor-grab hover:text-foreground"
                            title="Ziehen zum Verschieben"
                            aria-label="Ziehen zum Verschieben"
                          >
                            <GripVertical className="h-3 w-3" />
                          </span>
                          <button
                            type="button"
                            className="inline-flex h-4 w-4 items-center justify-center text-muted-foreground hover:text-foreground"
                            title="Zeile darunter einfügen"
                            aria-label="Zeile darunter einfügen"
                            onClick={() => addLineAfter(i)}
                          >
                            <Plus className="h-3 w-3" />
                          </button>
                        </div>
                      </TableCell>
                      <TableCell className="align-top w-36 py-1">
                        <div className="flex flex-col gap-1">
                          <Select value={kind} onValueChange={(v) => updateLineKind(i, v as LineKind)}>
                            <SelectTrigger className="h-7 text-[11px]">
                              <SelectValue placeholder="Text" />
                            </SelectTrigger>
                            <SelectContent>
                              <SelectItem value="text">Text</SelectItem>
                              <SelectItem value="h1">Heading 1</SelectItem>
                              <SelectItem value="h2">Heading 2</SelectItem>
                              <SelectItem value="h3">Heading 3</SelectItem>
                              <SelectItem value="bold">Bold</SelectItem>
                              <SelectItem value="variable">Variable</SelectItem>
                            </SelectContent>
                          </Select>
                          {kind === 'variable' ? (
                            <EditableTextarea
                              value={varKey}
                              onChange={(v) => updateVarKey(i, v)}
                              onBlur={() => {}}
                            />
                          ) : null}
                        </div>
                      </TableCell>
                      <TableCell className="align-top py-1">
                        <InlineEditableCell
                          value={content}
                          onChange={(val) => updateContent(i, val)}
                          placeholder={kind === 'variable' ? 'Frage/Beschreibung' : 'Markdown-Text'}
                        />
                      </TableCell>
                    </TableRow>
                  )
                })}
              </TableBody>
            </Table>
          </div>
        </TabsContent>

        <TabsContent value="frontmatter">
          <div className="max-h-[50vh] overflow-auto rounded border">
            <table className="w-full text-[11px] border-collapse">
              <thead className="sticky top-0 bg-background">
                <tr>
                  <th className="w-40 text-left px-2 py-1">Feld</th>
                  <th className="w-40 text-left px-2 py-1">Variable</th>
                  <th className="text-left px-2 py-1">Hinweis</th>
                </tr>
              </thead>
              <tbody>
                {fmEntries.length === 0 ? (
                  <tr><td colSpan={3} className="px-2 py-1 text-muted-foreground">Keine Felder im Frontmatter.</td></tr>
                ) : fmEntries.map((e, i) => {
                  const m = /\{\{([^}|]+)\|([^}]+)\}\}/.exec(e.rawValue)
                  const varKey = m ? m[1].trim() : ''
                  const varQ = m ? m[2].trim() : ''
                  return (
                    <tr key={`${e.key}-${i}`} className="align-top">
                      <td className="px-2 py-1 align-top font-mono">{e.key}</td>
                      <td className="px-2 py-1 align-top font-mono">{varKey}</td>
                      <td className="px-2 py-1 align-top">
                        <InlineEditableCell
                          value={varQ}
                          onChange={(val) => updateFrontmatterQuestion(e.key, val)}
                          placeholder="Klicken zum Bearbeiten"
                        />
                      </td>
                    </tr>
                  )
                })}
              </tbody>
            </table>
          </div>
        </TabsContent>

        <TabsContent value="system">
          <div className="space-y-2">
            <Label>Rollenanweisung</Label>
            {!sysEditing ? (
              <div role="button" onClick={() => setSysEditing(true)} className="border rounded-md">
                <MarkdownPreview content={sysPrompt || ''} />
              </div>
            ) : (
              <EditableTextarea
                value={sysPrompt}
                onChange={handleSysPromptChange}
                onBlur={() => setSysEditing(false)}
              />
            )}
          </div>
        </TabsContent>
      </Tabs>
    </div>
  )
}

function escapeRegExp(s: string): string {
  return s.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')
}

// Inline-Edit Textarea, wächst dynamisch, aktiviert Edit bei Fokus/Klick
function EditableTextarea({ value, onChange, onBlur, onKeyDown }: { value: string; onChange: (v: string) => void; onBlur?: () => void; onKeyDown?: (e: React.KeyboardEvent<HTMLTextAreaElement>) => void }) {
  const [local, setLocal] = React.useState(value)
  const ref = React.useRef<HTMLTextAreaElement | null>(null)

  const autosize = React.useCallback(() => {
    const el = ref.current
    if (!el) return
    el.style.height = 'auto'
    el.style.height = `${el.scrollHeight}px`
  }, [])

  React.useEffect(() => { setLocal(value); requestAnimationFrame(autosize) }, [value, autosize])

  return (
    <textarea
      ref={ref}
      value={local}
      onChange={(e) => { setLocal(e.target.value); onChange(e.target.value); autosize() }}
      onInput={autosize}
      onBlur={onBlur}
      onKeyDown={onKeyDown}
      className="w-full min-h-[2.5rem] rounded-md border bg-background px-2 py-1 text-[11px] leading-snug overflow-hidden"
      style={{ resize: 'none' }}
    />
  )
}

// Zelle, die erst beim Klick in den Editiermodus mit autosizender Textarea wechselt
function InlineEditableCell({ value, onChange, placeholder }: { value: string; onChange: (v: string) => void; placeholder?: string }) {
  const [editing, setEditing] = React.useState(false)

  if (!editing) {
    return (
      <div
        role="button"
        onClick={() => setEditing(true)}
        className="cursor-text whitespace-pre-wrap break-words rounded-md px-2 py-1 min-h-[2.5rem]"
      >
        {value ? value : <span className="text-muted-foreground">{placeholder || 'Klicken zum Bearbeiten'}</span>}
      </div>
    )
  }

  return (
    <EditableTextarea
      value={value}
      onChange={onChange}
      onBlur={() => setEditing(false)}
      onKeyDown={(e) => { if (e.key === 'Escape') { e.preventDefault(); e.stopPropagation(); setEditing(false) } }}
    />
  )
}


```

```typescriptreact
"use client";

import * as React from 'react'
// Hinweis: Body-Parsing erfolgt zeilenbasiert direkt in dieser Komponente
import { parseFrontmatterKeyValues } from '@/lib/markdown/frontmatter'
import { Button } from '@/components/ui/button'
import { Label } from '@/components/ui/label'
import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from '@/components/ui/table'
import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs'
import { GripVertical, Plus } from 'lucide-react'
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select'
import { MarkdownPreview } from '@/components/library/markdown-preview'

export interface StructuredTemplateEditorProps {
  markdownBody: string
  yamlFrontmatter: string
  systemPrompt: string
  onChange: (next: { markdownBody: string; yamlFrontmatter: string; systemPrompt: string }) => void
}

type LineKind = 'text' | 'h1' | 'h2' | 'h3' | 'bold' | 'variable'

export function StructuredTemplateEditor({ markdownBody, yamlFrontmatter, systemPrompt, onChange }: StructuredTemplateEditorProps) {
  const lines = React.useMemo(() => (typeof markdownBody === 'string' ? markdownBody.split('\n') : []), [markdownBody])
  const fmEntries = React.useMemo(() => parseFrontmatterKeyValues(yamlFrontmatter || ''), [yamlFrontmatter])
  const [sysPrompt, setSysPrompt] = React.useState(systemPrompt)
  const [tab, setTab] = React.useState<'body'|'frontmatter'|'system'>('body')
  const dragFrom = React.useRef<number | null>(null)
  const [sysEditing, setSysEditing] = React.useState(false)

  React.useEffect(() => { setSysPrompt(systemPrompt) }, [systemPrompt])

  // Zeilenbasierte Platzhalter-Erkennung (nur die betrachtete Zeile)
  function parseLine(line: string): { kind: LineKind; varKey: string; content: string } {
    const mVar = /^\s*\{\{([^}|]+)\|([^}]+)\}\}\s*$/.exec(line)
    if (mVar) return { kind: 'variable', varKey: (mVar[1] || '').trim(), content: (mVar[2] || '').trim() }
    if (/^\s*###\s+/.test(line)) return { kind: 'h3', varKey: '', content: line.replace(/^\s*###\s+/, '') }
    if (/^\s*##\s+/.test(line)) return { kind: 'h2', varKey: '', content: line.replace(/^\s*##\s+/, '') }
    if (/^\s*#\s+/.test(line)) return { kind: 'h1', varKey: '', content: line.replace(/^\s*#\s+/, '') }
    const mBold = /^\s*\*\*([\s\S]*?)\*\*\s*$/.exec(line)
    if (mBold) return { kind: 'bold', varKey: '', content: (mBold[1] || '') }
    return { kind: 'text', varKey: '', content: line }
  }

  function buildLine(kind: LineKind, content: string, varKey?: string): string {
    const text = content ?? ''
    switch (kind) {
      case 'variable': {
        const k = (varKey || '').trim()
        return k ? `{{${k}|${text}}}` : text
      }
      case 'h1': return `# ${text}`
      case 'h2': return `## ${text}`
      case 'h3': return `### ${text}`
      case 'bold': return `**${text}**`
      case 'text': default: return text
    }
  }

  function updateLineByIndex(lineIndex: number, nextLine: string) {
    const copy = lines.slice()
    if (lineIndex >= 0 && lineIndex < copy.length) copy[lineIndex] = nextLine
    onChange({ markdownBody: copy.join('\n'), yamlFrontmatter, systemPrompt: sysPrompt })
  }

  function suggestVarKey(index: number, content: string): string {
    const base = (content || '').toLowerCase().trim().replace(/[^a-z0-9]+/g, '_').replace(/^_+|_+$/g, '')
    const trimmed = base.length >= 3 ? base.slice(0, 24) : ''
    return trimmed || `var_${index + 1}`
  }

  function updateLineKind(lineIndex: number, nextKind: LineKind) {
    if (lineIndex < 0 || lineIndex >= lines.length) return
    const { content, varKey } = parseLine(lines[lineIndex])
    if (nextKind === 'variable') {
      const key = varKey && varKey.trim().length > 0 ? varKey : suggestVarKey(lineIndex, content)
      updateLineByIndex(lineIndex, buildLine('variable', content, key))
      return
    }
    updateLineByIndex(lineIndex, buildLine(nextKind, content, varKey))
  }

  function updateVarKey(lineIndex: number, nextKey: string) {
    if (lineIndex < 0 || lineIndex >= lines.length) return
    const { content } = parseLine(lines[lineIndex])
    const realKind: LineKind = 'variable'
    updateLineByIndex(lineIndex, buildLine(realKind, content, nextKey))
  }

  function updateContent(lineIndex: number, nextContent: string) {
    if (lineIndex < 0 || lineIndex >= lines.length) return
    const { kind, varKey } = parseLine(lines[lineIndex])
    updateLineByIndex(lineIndex, buildLine(kind, nextContent, varKey))
  }

  // Drag & Drop für Zeilenreihenfolge
  function handleDragStart(e: React.DragEvent, fromIndex: number) {
    e.dataTransfer.setData('text/plain', String(fromIndex))
    e.dataTransfer.effectAllowed = 'move'
  }
  function handleDragOver(e: React.DragEvent) {
    e.preventDefault()
    e.dataTransfer.dropEffect = 'move'
  }
  function handleDrop(e: React.DragEvent, toIndex: number) {
    e.preventDefault()
    const fromStr = e.dataTransfer.getData('text/plain')
    const fromIndex = Number.isInteger(Number(fromStr)) ? parseInt(fromStr, 10) : -1
    if (fromIndex < 0 || fromIndex === toIndex) return
    const arr = lines.slice()
    const [moved] = arr.splice(fromIndex, 1)
    arr.splice(toIndex, 0, moved)
    onChange({ markdownBody: arr.join('\n'), yamlFrontmatter, systemPrompt: sysPrompt })
  }

  function addLineAfter(index: number) {
    const arr = lines.slice()
    arr.splice(index + 1, 0, '')
    onChange({ markdownBody: arr.join('\n'), yamlFrontmatter, systemPrompt: sysPrompt })
  }

  const updateFrontmatterQuestion = (entryKey: string, question: string) => {
    const linesFM = (yamlFrontmatter || '').split('\n')
    const idx = linesFM.findIndex(l => new RegExp(`^${escapeRegExp(entryKey)}\\s*:`).test(l.trim()))
    if (idx >= 0) {
      const line = linesFM[idx]
      const m = /\{\{([^}|]+)\|([^}]+)\}\}/.exec(line)
      if (m) {
        linesFM[idx] = line.replace(m[0], `{{${m[1]}|${question}}}`)
      }
      onChange({ markdownBody, yamlFrontmatter: linesFM.join('\n'), systemPrompt: sysPrompt })
    }
  }

  const handleSysPromptChange = (v: string) => {
    setSysPrompt(v)
    onChange({ markdownBody, yamlFrontmatter, systemPrompt: v })
  }

  return (
    <div className="space-y-3">
      <Tabs value={tab} onValueChange={(v) => setTab(v as typeof tab)}>
        <TabsList className="grid grid-cols-3 w-full">
          <TabsTrigger value="body">Aufgabe</TabsTrigger>
          <TabsTrigger value="frontmatter">Metadaten</TabsTrigger>
          <TabsTrigger value="system">Rollenanweisung</TabsTrigger>
        </TabsList>

        <TabsContent value="body">
          <div className="overflow-auto">
            <Table className="text-[11px] w-full border-collapse">
              <TableHeader>
                <TableRow className="[&>*]:py-1">
                  <TableHead className="w-8" />
                  <TableHead className="w-36">Typ/Variable</TableHead>
                  <TableHead>Text / Frage</TableHead>
                </TableRow>
              </TableHeader>
              <TableBody>
                {lines.length === 0 ? (
                  <TableRow><TableCell colSpan={3} className="text-muted-foreground">Keine Zeilen im Body.</TableCell></TableRow>
                ) : lines.map((line, i) => {
                  const { kind, varKey, content } = parseLine(line)
                  return (
                    <TableRow key={`line-${i}`} className="align-top" onDragOver={handleDragOver} onDrop={(e) => handleDrop(e, i)}>
                      <TableCell className="align-top w-8 py-1">
                        <div className="flex items-center gap-1">
                          <span
                            draggable
                            onDragStart={(e) => handleDragStart(e, i)}
                            className="inline-flex h-4 w-4 items-center justify-center text-muted-foreground cursor-grab hover:text-foreground"
                            title="Ziehen zum Verschieben"
                            aria-label="Ziehen zum Verschieben"
                          >
                            <GripVertical className="h-3 w-3" />
                          </span>
                          <button
                            type="button"
                            className="inline-flex h-4 w-4 items-center justify-center text-muted-foreground hover:text-foreground"
                            title="Zeile darunter einfügen"
                            aria-label="Zeile darunter einfügen"
                            onClick={() => addLineAfter(i)}
                          >
                            <Plus className="h-3 w-3" />
                          </button>
                        </div>
                      </TableCell>
                      <TableCell className="align-top w-36 py-1">
                        <div className="flex flex-col gap-1">
                          <Select value={kind} onValueChange={(v) => updateLineKind(i, v as LineKind)}>
                            <SelectTrigger className="h-7 text-[11px]">
                              <SelectValue placeholder="Text" />
                            </SelectTrigger>
                            <SelectContent>
                              <SelectItem value="text">Text</SelectItem>
                              <SelectItem value="h1">Heading 1</SelectItem>
                              <SelectItem value="h2">Heading 2</SelectItem>
                              <SelectItem value="h3">Heading 3</SelectItem>
                              <SelectItem value="bold">Bold</SelectItem>
                              <SelectItem value="variable">Variable</SelectItem>
                            </SelectContent>
                          </Select>
                          {kind === 'variable' ? (
                            <EditableTextarea
                              value={varKey}
                              onChange={(v) => updateVarKey(i, v)}
                              onBlur={() => {}}
                            />
                          ) : null}
                        </div>
                      </TableCell>
                      <TableCell className="align-top py-1">
                        <InlineEditableCell
                          value={content}
                          onChange={(val) => updateContent(i, val)}
                          placeholder={kind === 'variable' ? 'Frage/Beschreibung' : 'Markdown-Text'}
                        />
                      </TableCell>
                    </TableRow>
                  )
                })}
              </TableBody>
            </Table>
          </div>
        </TabsContent>

        <TabsContent value="frontmatter">
          <div className="max-h-[50vh] overflow-auto rounded border">
            <table className="w-full text-[11px] border-collapse">
              <thead className="sticky top-0 bg-background">
                <tr>
                  <th className="w-40 text-left px-2 py-1">Feld</th>
                  <th className="w-40 text-left px-2 py-1">Variable</th>
                  <th className="text-left px-2 py-1">Hinweis</th>
                </tr>
              </thead>
              <tbody>
                {fmEntries.length === 0 ? (
                  <tr><td colSpan={3} className="px-2 py-1 text-muted-foreground">Keine Felder im Frontmatter.</td></tr>
                ) : fmEntries.map((e, i) => {
                  const m = /\{\{([^}|]+)\|([^}]+)\}\}/.exec(e.rawValue)
                  const varKey = m ? m[1].trim() : ''
                  const varQ = m ? m[2].trim() : ''
                  return (
                    <tr key={`${e.key}-${i}`} className="align-top">
                      <td className="px-2 py-1 align-top font-mono">{e.key}</td>
                      <td className="px-2 py-1 align-top font-mono">{varKey}</td>
                      <td className="px-2 py-1 align-top">
                        <InlineEditableCell
                          value={varQ}
                          onChange={(val) => updateFrontmatterQuestion(e.key, val)}
                          placeholder="Klicken zum Bearbeiten"
                        />
                      </td>
                    </tr>
                  )
                })}
              </tbody>
            </table>
          </div>
        </TabsContent>

        <TabsContent value="system">
          <div className="space-y-2">
            <Label>Rollenanweisung</Label>
            {!sysEditing ? (
              <div role="button" onClick={() => setSysEditing(true)} className="border rounded-md">
                <MarkdownPreview content={sysPrompt || ''} />
              </div>
            ) : (
              <EditableTextarea
                value={sysPrompt}
                onChange={handleSysPromptChange}
                onBlur={() => setSysEditing(false)}
              />
            )}
          </div>
        </TabsContent>
      </Tabs>
    </div>
  )
}

function escapeRegExp(s: string): string {
  return s.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')
}

// Inline-Edit Textarea, wächst dynamisch, aktiviert Edit bei Fokus/Klick
function EditableTextarea({ value, onChange, onBlur, onKeyDown }: { value: string; onChange: (v: string) => void; onBlur?: () => void; onKeyDown?: (e: React.KeyboardEvent<HTMLTextAreaElement>) => void }) {
  const [local, setLocal] = React.useState(value)
  const ref = React.useRef<HTMLTextAreaElement | null>(null)

  const autosize = React.useCallback(() => {
    const el = ref.current
    if (!el) return
    el.style.height = 'auto'
    el.style.height = `${el.scrollHeight}px`
  }, [])

  React.useEffect(() => { setLocal(value); requestAnimationFrame(autosize) }, [value, autosize])

  return (
    <textarea
      ref={ref}
      value={local}
      onChange={(e) => { setLocal(e.target.value); onChange(e.target.value); autosize() }}
      onInput={autosize}
      onBlur={onBlur}
      onKeyDown={onKeyDown}
      className="w-full min-h-[2.5rem] rounded-md border bg-background px-2 py-1 text-[11px] leading-snug overflow-hidden"
      style={{ resize: 'none' }}
    />
  )
}

// Zelle, die erst beim Klick in den Editiermodus mit autosizender Textarea wechselt
function InlineEditableCell({ value, onChange, placeholder }: { value: string; onChange: (v: string) => void; placeholder?: string }) {
  const [editing, setEditing] = React.useState(false)

  if (!editing) {
    return (
      <div
        role="button"
        onClick={() => setEditing(true)}
        className="cursor-text whitespace-pre-wrap break-words rounded-md px-2 py-1 min-h-[2.5rem]"
      >
        {value ? value : <span className="text-muted-foreground">{placeholder || 'Klicken zum Bearbeiten'}</span>}
      </div>
    )
  }

  return (
    <EditableTextarea
      value={value}
      onChange={onChange}
      onBlur={() => setEditing(false)}
      onKeyDown={(e) => { if (e.key === 'Escape') { e.preventDefault(); e.stopPropagation(); setEditing(false) } }}
    />
  )
}


```

Erledigt: Im Tab „Rollenanweisung“ wird der Text jetzt standardmäßig als Markdown angezeigt. Klick darauf öffnet einen mehrzeiligen Editor; Blur schließt wieder und speichert in `systemPrompt`.

---

**User**

Ich habe ein komplexes template: @pdfanalyse.md 
Warum wird frontmatter nicht erkannt, wiird als Body interpretiert

---

**Cursor**

Ich passe die Frontmatter-Erkennung an CRLF und optionale Leerzeilen an, damit dein `pdfanalyse.md`-Frontmatter korrekt erkannt wird. Ich aktualisiere die Regex in `template-management.tsx` jetzt und prüfe den Linter.

```typescriptreact
"use client"

import { useState, useEffect, useCallback } from "react"
import { useForm } from "react-hook-form"
import { zodResolver } from "@hookform/resolvers/zod"
import * as z from "zod"
import { Button } from "@/components/ui/button"
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card"
import { Label } from "@/components/ui/label"
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select"
import { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from "@/components/ui/tooltip"
import { StructuredTemplateEditor } from "@/components/templates/structured-template-editor"
import { useToast } from "@/hooks/use-toast"
import { Loader2, Save, Eye, Play, FolderOpen, Info } from "lucide-react"
import { useAtom, useAtomValue } from "jotai"
import { activeLibraryAtom, libraryStatusAtom } from "@/atoms/library-atom"
import { 
  templatesAtom, 
  selectedTemplateNameAtom, 
  selectedTemplateAtom,
  templatesFolderIdAtom,
  templateLoadingAtom,
  templateErrorAtom,
  type Template
} from "@/atoms/template-atom"
import { useStorage } from "@/contexts/storage-context"
import { templateContextDocsAtom } from '@/atoms/template-context-atom'
import { Checkbox } from "@/components/ui/checkbox"
import { MarkdownPreview } from "@/components/library/markdown-preview"
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs"
import { JobReportTab } from "@/components/library/job-report-tab"

// Schema für Template-Daten
const templateSchema = z.object({
  name: z.string().min(1, "Prompt-Name ist erforderlich"),
  yamlFrontmatter: z.string(),
  markdownBody: z.string(),
  systemPrompt: z.string(),
})

type TemplateFormValues = z.infer<typeof templateSchema>

export function TemplateManagement() {
  const [previewMode, setPreviewMode] = useState(false)
  const [isSaving, setIsSaving] = useState(false)
  const [isTesting, setIsTesting] = useState(false)
  const [testResult, setTestResult] = useState<string | null>(null)
  const [selectedContextIds, setSelectedContextIds] = useState<string[]>([])
  const [selectedContextMarkdown, setSelectedContextMarkdown] = useState<string>("")
  const [rightTab, setRightTab] = useState<'kontext'|'preview'|'ergebnis'>('kontext')
  const [resultSavedItemId, setResultSavedItemId] = useState<string | null>(null)
  const { toast } = useToast()

  // Atoms
  const [templates, setTemplates] = useAtom(templatesAtom)
  const [selectedTemplateName, setSelectedTemplateName] = useAtom(selectedTemplateNameAtom)
  const [selectedTemplate] = useAtom(selectedTemplateAtom)
  const [templatesFolderId, setTemplatesFolderId] = useAtom(templatesFolderIdAtom)
  const [isLoading, setIsLoading] = useAtom(templateLoadingAtom)
  const [error, setError] = useAtom(templateErrorAtom)

  // Library und Storage
  const activeLibrary = useAtomValue(activeLibraryAtom)
  const libraryStatus = useAtomValue(libraryStatusAtom)
  const { 
    provider: providerInstance, 
    listItems
  } = useStorage()
  const contextDocs = useAtomValue(templateContextDocsAtom)

  const form = useForm<TemplateFormValues>({
    resolver: zodResolver(templateSchema),
    defaultValues: {
      name: "",
      yamlFrontmatter: `---
title: {{title|Titel des Dokuments}}
tags: {{tags|Relevante Tags}}
date: {{date|Datum im Format yyyy-mm-dd}}
---`,
      markdownBody: `# {{title}}

## Zusammenfassung
{{summary|Kurze Zusammenfassung des Inhalts}}

## Details
{{details|Detaillierte Beschreibung}}`,
      systemPrompt: `You are a specialized assistant that processes and structures information clearly and concisely.

IMPORTANT: Your response must be a valid JSON object where each key corresponds to a template variable.`,
    },
  })

  // Helper zum Erzeugen von Default-Werten
  function getDefaultTemplateValues(name: string): TemplateFormValues {
    return {
      name,
      yamlFrontmatter: `---\n` +
        `title: {{title|Titel des Dokuments}}\n` +
        `tags: {{tags|Relevante Tags}}\n` +
        `date: {{date|Datum im Format yyyy-mm-dd}}\n` +
        `---`,
      markdownBody: `# {{title}}\n\n## Zusammenfassung\n{{summary|Kurze Zusammenfassung des Inhalts}}\n\n## Details\n{{details|Detaillierte Beschreibung}}`,
      systemPrompt: `You are a specialized assistant that processes and structures information clearly and concisely.\n\nIMPORTANT: Your response must be a valid JSON object where each key corresponds to a template variable.`,
    }
  }

  // Template-Daten laden wenn sich die Auswahl ändert
  useEffect(() => {
    if (selectedTemplate) {
      form.reset({
        name: selectedTemplate.name,
        yamlFrontmatter: selectedTemplate.yamlFrontmatter,
        markdownBody: selectedTemplate.markdownBody,
        systemPrompt: selectedTemplate.systemPrompt,
      })
    }
  }, [selectedTemplate, form])

  // Ordner-Erstellung/Suche memoisiert, damit als Dep verwendbar
  const ensureTemplatesFolder = useCallback(async (): Promise<string> => {
    if (!providerInstance || !activeLibrary) {
      throw new Error("Keine aktive Bibliothek oder Provider verfügbar");
    }

    try {
      console.log('[TemplateManagement] Suche nach Templates-Ordner...');
      const rootItems = await listItems('root');
      const templatesFolder = rootItems.find(item => 
        item.type === 'folder' && item.metadata.name === 'templates'
      );
      if (templatesFolder) {
        console.log('[TemplateManagement] Templates-Ordner gefunden:', templatesFolder.id);
        return templatesFolder.id;
      }
      console.log('[TemplateManagement] Templates-Ordner nicht gefunden, erstelle neuen...');
      const newFolder = await providerInstance.createFolder('root', 'templates');
      console.log('[TemplateManagement] Neuer Templates-Ordner erstellt:', newFolder.id);
      return newFolder.id;
    } catch (error) {
      console.error('Fehler beim Erstellen des Templates-Ordners:', {
        error: error instanceof Error ? {
          message: error.message,
          name: error.name,
          stack: error.stack?.split('\n').slice(0, 3)
        } : error,
        libraryId: activeLibrary?.id,
        libraryPath: activeLibrary?.path,
        providerName: providerInstance?.name
      });
      let errorMessage = 'Fehler beim Erstellen des Templates-Ordners';
      if (error instanceof Error) {
        if (error.message.includes('Nicht authentifiziert')) {
          errorMessage = 'Bitte authentifizieren Sie sich bei Ihrem Cloud-Speicher, um den Templates-Ordner zu erstellen.';
        } else if (error.message.includes('Keine Berechtigung')) {
          errorMessage = 'Keine Berechtigung zum Erstellen von Ordnern in der Bibliothek.';
        } else if (error.message.includes('Bibliothek nicht gefunden')) {
          errorMessage = 'Die ausgewählte Bibliothek wurde nicht gefunden.';
        } else {
          errorMessage = `Fehler beim Erstellen des Templates-Ordners: ${error.message}`;
        }
      }
      throw new Error(errorMessage);
    }
  }, [providerInstance, activeLibrary, listItems]);

  // Templates laden mit der gleichen Logik wie Library-Komponente
  const loadTemplates = useCallback(async () => {
    if (!providerInstance || libraryStatus !== 'ready' || !activeLibrary) {
      console.log('[TemplateManagement] loadTemplates übersprungen:', {
        hasProvider: !!providerInstance,
        libraryStatus,
        hasActiveLibrary: !!activeLibrary
      });
      return;
    }

    try {
      setIsLoading(true);
      setError(null);

      console.log('[TemplateManagement] Starte Prompt-Loading:', {
        libraryId: activeLibrary.id,
        libraryPath: activeLibrary.path,
        providerName: providerInstance.name
      });

      // 1. Templates-Ordner finden oder erstellen
      const folderId = await ensureTemplatesFolder();
      setTemplatesFolderId(folderId);

      console.log('[TemplateManagement] Templates-Ordner gefunden/erstellt:', folderId);

      // 2. Alle Template-Dateien im Ordner auflisten
      const items = await listItems(folderId);
      const templateFiles = items.filter(item => 
        item.type === 'file' && 
        item.metadata.name.endsWith('.md')
      );

      console.log('[TemplateManagement] Prompt-Dateien gefunden:', templateFiles.length);

      // 3. Template-Inhalte laden
      const templatePromises = templateFiles.map(async (file) => {
        try {
          const { blob } = await providerInstance.getBinary(file.id);
          const content = await blob.text();
          const template = parseTemplateContent(content, file.metadata.name.replace('.md', ''));
          
          return {
            ...template,
            fileId: file.id,
            lastModified: typeof file.metadata.modifiedAt === 'string' 
              ? file.metadata.modifiedAt 
              : file.metadata.modifiedAt instanceof Date 
                ? file.metadata.modifiedAt.toISOString()
                : new Date().toISOString()
          } as Template;
        } catch (error) {
          console.error(`Fehler beim Parsen von ${file.metadata.name}:`, error);
          return null;
        }
      });

      const loadedTemplates = await Promise.all(templatePromises);
      const validTemplates = loadedTemplates.filter((t): t is Template => t !== null);
      
      setTemplates(validTemplates);
      
      console.log('[TemplateManagement] Prompts erfolgreich geladen:', validTemplates.length);
      
      if (validTemplates.length === 0) {
        toast({
          title: "Keine Prompts gefunden",
          description: "Erstellen Sie Ihren ersten Prompt im Verzeichnis '/templates'.",
        });
      }
    } catch (error) {
      console.error('Fehler beim Laden der Prompts:', {
        error: error instanceof Error ? {
          message: error.message,
          name: error.name,
          stack: error.stack?.split('\n').slice(0, 3)
        } : error,
        libraryId: activeLibrary?.id,
        libraryPath: activeLibrary?.path,
        providerName: providerInstance?.name
      });

      let errorMessage = 'Unbekannter Fehler beim Laden der Prompts';
      
      if (error instanceof Error) {
        errorMessage = error.message;
        
        // Spezifische Fehlermeldungen für häufige Probleme
        if (error.message.includes('Nicht authentifiziert')) {
          errorMessage = 'Bitte authentifizieren Sie sich bei Ihrem Cloud-Speicher, um Prompts zu laden.';
        } else if (error.message.includes('Bibliothek nicht gefunden')) {
          errorMessage = 'Die ausgewählte Bibliothek wurde nicht gefunden. Bitte überprüfen Sie die Bibliothekskonfiguration.';
        } else if (error.message.includes('Server-Fehler')) {
          errorMessage = 'Server-Fehler beim Laden der Prompts. Bitte überprüfen Sie, ob der Bibliothekspfad existiert und zugänglich ist.';
        } else if (error.message.includes('Keine aktive Bibliothek')) {
          errorMessage = 'Keine aktive Bibliothek verfügbar. Bitte wählen Sie eine Bibliothek aus.';
        }
      }
      
      setError(errorMessage);
      toast({
        title: "Fehler beim Laden der Prompts",
        description: errorMessage,
        variant: "destructive",
      });
    } finally {
      setIsLoading(false);
    }
  }, [providerInstance, libraryStatus, activeLibrary, listItems, setTemplates, setTemplatesFolderId, setIsLoading, setError, toast, ensureTemplatesFolder]);

  // Effect für Template Loading (wie Library-Komponente)
  useEffect(() => {
    const isReady = providerInstance && libraryStatus === 'ready' && activeLibrary
    
    if (!isReady) {
      return
    }

    // Templates laden wenn noch nicht geladen
    if (!templatesFolderId) {
      loadTemplates()
    }
  }, [providerInstance, libraryStatus, activeLibrary, templatesFolderId, loadTemplates])

  // Reset wenn sich die Library ändert
  useEffect(() => {
    setSelectedTemplateName(null)
    setTemplatesFolderId(null)
    setTemplates([])
    setError(null)
  }, [libraryStatus, setSelectedTemplateName, setTemplatesFolderId, setTemplates, setError])

  useEffect(() => {
    async function loadSelectedContext() {
      if (!providerInstance || !Array.isArray(selectedContextIds) || selectedContextIds.length === 0) {
        setSelectedContextMarkdown("")
        return
      }
      try {
        const parts: string[] = []
        for (const id of selectedContextIds) {
          const { blob } = await providerInstance.getBinary(id)
          const text = await blob.text()
          const name = Array.isArray(contextDocs) ? (contextDocs.find(d => d.id === id)?.name || id) : id
          const section = `\n\n---\nDatei: ${name}\n---\n\n${text}\n\n---\nEnde Datei: ${name}\n---\n`
          parts.push(section)
        }
        setSelectedContextMarkdown(parts.join("\n\n"))
      } catch (e) {
        console.error('Fehler beim Laden des Kontextes', e)
        setSelectedContextMarkdown("")
      }
    }
    void loadSelectedContext()
  }, [providerInstance, selectedContextIds, contextDocs])

  function parseTemplateContent(content: string, fileName: string): Template {
    // Template in drei Bereiche aufteilen
    const parts = content.split('--- systemprompt')
    
    let yamlFrontmatter = ""
    let markdownBody = ""
    let systemPrompt = ""
    
    if (parts.length >= 2) {
      const mainContent = parts[0].trim()
      systemPrompt = parts[1].trim()
      
      // YAML Frontmatter extrahieren
      const yamlMatch = mainContent.match(/^---\r?\n([\s\S]*?)\r?\n---\r?\n?([\s\S]*)$/)
      if (yamlMatch) {
        yamlFrontmatter = `---\n${yamlMatch[1]}\n---`
        markdownBody = yamlMatch[2].trim()
      } else {
        // Kein YAML Frontmatter gefunden
        markdownBody = mainContent
      }
    } else {
      // Kein Systemprompt gefunden
      const yamlMatch = content.match(/^---\r?\n([\s\S]*?)\r?\n---\r?\n?([\s\S]*)$/)
      if (yamlMatch) {
        yamlFrontmatter = `---\n${yamlMatch[1]}\n---`
        markdownBody = yamlMatch[2].trim()
      } else {
        markdownBody = content
      }
    }

    return {
      name: fileName,
      yamlFrontmatter,
      markdownBody,
      systemPrompt,
    }
  }

  function generateTemplateContent(values: TemplateFormValues): string {
    let content = ""
    
    // YAML Frontmatter hinzufügen
    if (values.yamlFrontmatter.trim()) {
      content += values.yamlFrontmatter + "\n\n"
    }
    
    // Markdown Body hinzufügen
    content += values.markdownBody
    
    // System Prompt hinzufügen
    if (values.systemPrompt.trim()) {
      content += "\n\n--- systemprompt\n" + values.systemPrompt
    }
    
    return content
  }

  async function onSubmit(data: TemplateFormValues) {
    if (!activeLibrary || !templatesFolderId || !providerInstance) {
      toast({
        title: "Fehler",
        description: "Keine aktive Bibliothek oder Templates-Ordner nicht gefunden.",
        variant: "destructive",
      })
      return
    }

    setIsSaving(true)
    try {
      const templateContent = generateTemplateContent(data)
      const fileName = `${data.name}.md`
      
      // Datei als Blob erstellen
      const blob = new Blob([templateContent], { type: 'text/markdown' })
      const file = new File([blob], fileName, { type: 'text/markdown' })
      
      // Datei hochladen
      await providerInstance.uploadFile(templatesFolderId, file)
      
      // Templates neu laden
      await loadTemplates()
      
      // Auswahl auf das neue Template setzen
      setSelectedTemplateName(data.name)
      
      toast({
        title: "Template gespeichert",
        description: `Template "${data.name}" wurde erfolgreich im Verzeichnis "/templates" gespeichert.`,
      })
    } catch (error) {
      console.error('Fehler beim Speichern des Templates:', error)
      toast({
        title: "Fehler beim Speichern",
        description: error instanceof Error ? error.message : "Unbekannter Fehler",
        variant: "destructive",
      })
    } finally {
      setIsSaving(false)
    }
  }

  async function renameCurrentTemplate() {
    const current = selectedTemplateName ? templates.find(t => t.name === selectedTemplateName) : null
    if (!current || !current.fileId || !providerInstance) return
    const newName = (window.prompt('Neuen Namen eingeben:', current.name) || '').trim()
    if (!newName || newName === current.name) return
    if (/[^a-zA-Z0-9._\- ]/.test(newName)) { toast({ title: 'Ungültiger Name', description: 'Nur Buchstaben, Zahlen, Leerzeichen, . _ - sind erlaubt.', variant: 'destructive' }); return }
    if (templates.some(t => t.name.toLowerCase() === newName.toLowerCase())) { toast({ title: 'Bereits vorhanden', description: 'Bitte anderen Namen wählen.', variant: 'destructive' }); return }
    try {
      await providerInstance.renameItem(current.fileId, `${newName}.md`)
      await loadTemplates()
      setSelectedTemplateName(newName)
      form.setValue('name', newName, { shouldDirty: false })
      toast({ title: 'Umbenannt', description: `${current.name} → ${newName}` })
    } catch (e) {
      toast({ title: 'Fehler beim Umbenennen', description: e instanceof Error ? e.message : 'Unbekannter Fehler', variant: 'destructive' })
    }
  }

  async function deleteTemplate(templateName: string) {
    if (!activeLibrary || !providerInstance) return

    try {
      const template = templates.find(t => t.name === templateName)
      if (!template?.fileId) {
        throw new Error("Template-Datei nicht gefunden")
      }

      // Datei löschen
      await providerInstance.deleteItem(template.fileId)

      // Templates neu laden
      await loadTemplates()
      
      if (selectedTemplateName === templateName) {
        setSelectedTemplateName(null)
        form.reset()
      }
      
      toast({
        title: "Template gelöscht",
        description: `Template "${templateName}" wurde erfolgreich gelöscht.`,
      })
    } catch (error) {
      console.error('Fehler beim Löschen des Templates:', error)
      toast({
        title: "Fehler beim Löschen",
        description: error instanceof Error ? error.message : "Unbekannter Fehler",
        variant: "destructive",
      })
    }
  }

  async function createNewTemplate() {
    const name = (window.prompt('Neuen Template‑Namen eingeben:') || '').trim()
    if (!name) return
    if (/[^a-zA-Z0-9._\- ]/.test(name)) { toast({ title: 'Ungültiger Name', description: 'Nur Buchstaben, Zahlen, Leerzeichen, . _ - sind erlaubt.', variant: 'destructive' }); return }
    if (templates.some(t => t.name.toLowerCase() === name.toLowerCase())) { toast({ title: 'Bereits vorhanden', description: 'Bitte anderen Namen wählen.', variant: 'destructive' }); return }
    if (!providerInstance) { toast({ title: 'Kein Provider' , variant: 'destructive' }); return }
    try {
      const folderId = await ensureTemplatesFolder()
      const values = getDefaultTemplateValues(name)
      const content = (values.yamlFrontmatter ? values.yamlFrontmatter + '\n\n' : '') + values.markdownBody + '\n\n--- systemprompt\n' + values.systemPrompt
      const file = new File([new Blob([content], { type: 'text/markdown' })], `${name}.md`, { type: 'text/markdown' })
      await providerInstance.uploadFile(folderId, file)
      await loadTemplates()
      setSelectedTemplateName(name)
      form.reset(values)
      toast({ title: 'Template angelegt', description: `"${name}" wurde erstellt.` })
    } catch (e) {
      toast({ title: 'Fehler beim Anlegen', description: e instanceof Error ? e.message : 'Unbekannter Fehler', variant: 'destructive' })
    }
  }

  function generatePreview(): string {
    const values = form.getValues()
    return generateTemplateContent(values)
  }

  async function testTemplate() {
    if (!activeLibrary) return

    setIsTesting(true)
    setTestResult(null)

    const values = form.getValues()
    const templateContent = generateTemplateContent(values)
    const testText = selectedContextMarkdown || ""

    try {
      const response = await fetch('/api/secretary/process-text', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/x-www-form-urlencoded',
          'X-Library-Id': activeLibrary.id,
        },
        body: new URLSearchParams({
          text: testText,
          template_content: templateContent,
          source_language: 'de',
          target_language: 'de',
        }),
      })

      if (!response.ok) {
        const errorData = await response.json()
        throw new Error(errorData.error || `HTTP ${response.status}: ${response.statusText}`)
      }

      const result = await response.json()
      const formattedResult = typeof result === 'string' ? result : JSON.stringify(result, null, 2)
      setTestResult(formattedResult)
      setRightTab('ergebnis')

      toast({
        title: "Prompt-Test erfolgreich",
        description: "Der Prompt wurde erfolgreich mit dem gewählten Kontext verarbeitet.",
      })

      console.log('Prompt-Test Ergebnis:', result)
    } catch (error) {
      console.error('Fehler beim Prompt-Test:', error)
      const errorMessage = error instanceof Error ? error.message : "Unbekannter Fehler"
      setTestResult(`Fehler: ${errorMessage}`)
      setRightTab('ergebnis')
      toast({
        title: "Prompt-Test fehlgeschlagen",
        description: errorMessage,
        variant: "destructive",
      })
    } finally {
      setIsTesting(false)
    }
  }

  async function ensurePromptTestsFolder(): Promise<string> {
    if (!providerInstance) throw new Error('Kein Provider verfügbar')
    const roots = await listItems('root')
    const found = roots.find(it => it.type === 'folder' && it.metadata.name === 'prompt-tests')
    if (found) return found.id
    const created = await providerInstance.createFolder('root', 'prompt-tests')
    return created.id
  }

  async function saveTestResult() {
    try {
      if (!providerInstance || !activeLibrary || !testResult) return
      const folderId = await ensurePromptTestsFolder()
      const name = `${selectedTemplateName || 'prompt'}-test-${new Date().toISOString().replace(/[:.]/g,'-')}.md`
      const blob = new Blob([testResult], { type: 'text/markdown' })
      const file = new File([blob], name, { type: 'text/markdown' })
      const item = await providerInstance.uploadFile(folderId, file)
      setResultSavedItemId(item.id)
      toast({ title: 'Ergebnis gespeichert', description: name })
    } catch (e) {
      toast({ title: 'Speichern fehlgeschlagen', description: e instanceof Error ? e.message : 'Unbekannter Fehler', variant: 'destructive' })
    }
  }

  // Render-Logik für verschiedene Status
  if (libraryStatus === "waitingForAuth") {
    return (
      <div className="flex flex-col items-center justify-center h-full text-muted-foreground">
        <span>Diese Bibliothek benötigt eine Authentifizierung.</span>
        <span className="text-sm mt-2">Bitte konfigurieren Sie die Bibliothek in den Einstellungen.</span>
      </div>
    )
  }
  
  if (libraryStatus !== "ready") {
    return (
      <div className="flex flex-col items-center justify-center h-full text-muted-foreground">
        <span>Lade Storage...</span>
      </div>
    )
  }

  if (!activeLibrary) {
    return (
      <div className="text-center text-muted-foreground">
        Bitte wählen Sie eine Bibliothek aus.
      </div>
    )
  }

  if (error) {
    return (
      <div className="text-center text-destructive">
        <p>Fehler beim Laden der Prompts:</p>
        <p className="text-sm">{error}</p>
        <Button 
          variant="outline" 
          className="mt-4"
          onClick={loadTemplates}
        >
          Erneut versuchen
        </Button>
      </div>
    )
  }

  return (
    <div className="space-y-6">

      {/* Kompakte Toolbar oben */}
      <div className="flex items-center gap-2">
        <Select value={selectedTemplateName || ''} onValueChange={(v) => { setSelectedTemplateName(v); form.setValue('name', v, { shouldDirty: false }) }} disabled={isLoading}>
          <SelectTrigger className="w-64">
            <SelectValue placeholder="Prompt auswählen..." />
          </SelectTrigger>
          <SelectContent>
            {templates.map((t) => (
              <SelectItem key={t.name} value={t.name}>{t.name}</SelectItem>
            ))}
          </SelectContent>
        </Select>
        <TooltipProvider>
          <Tooltip>
            <TooltipTrigger asChild>
              <Button variant="ghost" size="sm" className="h-8 w-8 p-0"><Info className="h-4 w-4" /></Button>
            </TooltipTrigger>
            <TooltipContent>
              <div className="flex items-center gap-2"><FolderOpen className="h-4 w-4" /><span>Ort: /templates in „{activeLibrary.label}“</span></div>
            </TooltipContent>
          </Tooltip>
        </TooltipProvider>
        <Button type="button" variant="outline" size="sm" onClick={createNewTemplate} disabled={isLoading}>Neu</Button>
        <Button type="button" variant="outline" size="sm" onClick={renameCurrentTemplate} disabled={!selectedTemplateName}>Umbenennen</Button>
        {selectedTemplateName && (
          <Button type="button" variant="destructive" size="sm" onClick={() => deleteTemplate(selectedTemplateName!)}>Löschen</Button>
        )}
      </div>

      <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
        <Card>
          <CardHeader>
            <CardTitle>Prompt Design</CardTitle>
            <CardDescription>
              Drei Bereiche: Aufgabe (was), Rollenanweisung (wie), Metadaten (Begleitinfos).
            </CardDescription>
          </CardHeader>
          <CardContent>
            <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-6">
              {/* Template-Name Feld entfernt (oben verwaltet) */}

              {previewMode ? (
                <div className="space-y-4">
                  <div className="flex items-center justify-between">
                    <h4 className="text-sm font-medium">Prompt-Vorschau</h4>
                    <Button
                      type="button"
                      variant="outline"
                      size="sm"
                      onClick={() => setPreviewMode(false)}
                    >
                      Bearbeiten
                    </Button>
                  </div>
                  <div className="border rounded-md p-4 bg-muted/50">
                    <pre className="text-sm whitespace-pre-wrap font-mono">
                      {generatePreview()}
                    </pre>
                  </div>
                </div>
              ) : (
                <StructuredTemplateEditor
                  markdownBody={form.watch('markdownBody')}
                  yamlFrontmatter={form.watch('yamlFrontmatter')}
                  systemPrompt={form.watch('systemPrompt')}
                  onChange={({ markdownBody, yamlFrontmatter, systemPrompt }) => {
                    form.setValue('markdownBody', markdownBody, { shouldDirty: true })
                    form.setValue('yamlFrontmatter', yamlFrontmatter, { shouldDirty: true })
                    form.setValue('systemPrompt', systemPrompt, { shouldDirty: true })
                  }}
                />
              )}

              <div className="flex justify-end gap-2">
                <Button
                  type="button"
                  variant="outline"
                  onClick={() => setPreviewMode(!previewMode)}
                >
                  <Eye className="h-4 w-4 mr-2" />
                  {previewMode ? "Bearbeiten" : "Vorschau"}
                </Button>
                <Button
                  type="submit"
                  disabled={isSaving || !form.formState.isDirty}
                >
                  {isSaving ? (
                    <>
                      <Loader2 className="h-4 w-4 mr-2 animate-spin" />
                      Wird gespeichert...
                    </>
                  ) : (
                    <>
                      <Save className="h-4 w-4 mr-2" />
                      Speichern
                    </>
                  )}
                </Button>
              </div>
            </form>
          </CardContent>
        </Card>

        <Card>
          <CardHeader>
            <CardTitle>Prompt testen</CardTitle>
            <CardDescription>
              Test mit Beispieltext. Nutzt Rollenanweisung, Aufgabe und Metadaten des Prompts.
            </CardDescription>
          </CardHeader>
          <CardContent>
            <Tabs value={rightTab} onValueChange={(v) => setRightTab(v as typeof rightTab)}>
              <TabsList className="grid grid-cols-3 w-full">
                <TabsTrigger value="kontext">Daten‑Kontext</TabsTrigger>
                <TabsTrigger value="preview">Prompt‑Vorschau</TabsTrigger>
                <TabsTrigger value="ergebnis">Ergebnis</TabsTrigger>
              </TabsList>

              <TabsContent value="kontext" className="space-y-4 mt-4">
                <div className="space-y-2">
                  <Label>Kontext-Texte</Label>
                  <div className="border rounded p-2 text-sm">
                    {Array.isArray(contextDocs) && contextDocs.length > 0 ? (
                      contextDocs.map(d => {
                        const checked = selectedContextIds.includes(d.id)
                        return (
                          <label key={d.id} className="flex items-center gap-2 py-1">
                            <Checkbox
                              checked={checked}
                              onCheckedChange={(v) => {
                                const isOn = v === true
                                setSelectedContextIds(prev => isOn ? [...prev, d.id] : prev.filter(x => x !== d.id))
                              }}
                            />
                            <span className="truncate">{d.name}</span>
                          </label>
                        )
                      })
                    ) : (
                      <div className="text-muted-foreground text-sm">Keine Kontext-Texte verfügbar</div>
                    )}
                  </div>
                </div>

                <div className="space-y-2">
                  <Label>Gewählter Kontext (Lesemodus)</Label>
                  <div className="border rounded-md">
                    <MarkdownPreview content={selectedContextMarkdown} />
                  </div>
                </div>
              </TabsContent>

              <TabsContent value="preview" className="space-y-4 mt-4">
                <div className="space-y-2">
                  <Label>Generierter Prompt (Markdown)</Label>
                  <div className="border rounded-md">
                    <MarkdownPreview content={generatePreview()} />
                  </div>
                </div>
                <div className="flex gap-2">
                  <Button 
                    variant="outline" 
                    size="sm"
                    onClick={testTemplate}
                    disabled={!selectedTemplateName || isTesting}
                  >
                    {isTesting ? (
                      <>
                        <Loader2 className="h-4 w-4 mr-2 animate-spin" />
                        Teste...
                      </>
                    ) : (
                      <>
                        <Play className="h-4 w-4 mr-2" />
                        Prompt testen
                      </>
                    )}
                  </Button>
                </div>
              </TabsContent>

              <TabsContent value="ergebnis" className="space-y-4 mt-4">
                <Tabs defaultValue="md">
                  <TabsList className="w-full grid grid-cols-2">
                    <TabsTrigger value="md">Markdown</TabsTrigger>
                    <TabsTrigger value="meta">Metadaten</TabsTrigger>
                  </TabsList>
                  <TabsContent value="md" className="space-y-2 mt-2">
                    <Label>Ergebnis</Label>
                    <div className="border rounded-md">
                      <MarkdownPreview content={testResult || ''} />
                    </div>
                    <div className="flex gap-2">
                      <Button type="button" onClick={saveTestResult} disabled={!testResult}>Speichern</Button>
                    </div>
                  </TabsContent>
                  <TabsContent value="meta" className="mt-2">
                    {resultSavedItemId && providerInstance && activeLibrary ? (
                      <JobReportTab libraryId={activeLibrary.id} fileId={resultSavedItemId} provider={providerInstance} sourceMode="frontmatter" viewMode="metaOnly" mdFileId={resultSavedItemId} />
                    ) : (
                      <div className="text-sm text-muted-foreground">Bitte Ergebnis speichern, um Metadaten und Kapitel anzuzeigen.</div>
                    )}
                  </TabsContent>
                </Tabs>
              </TabsContent>
            </Tabs>
          </CardContent>
        </Card>
      </div>
    </div>
  )
} 
```

- Ursache: Die Frontmatter‑Erkennung war zu strikt und erwartete nur LF und zwingend eine Leerzeile nach dem schließenden ---.
- Fix: Regex in `parseTemplateContent` gelockert:
  - Unterstützt CRLF und LF: `\r?\n`
  - Akzeptiert optionale Zeile nach dem schließenden `---`.
- Wirkung: Dein `tests/pdfanalyse.md` wird als Frontmatter korrekt erkannt; der Rest landet im Body.

---

**User**

Gehen wir nochmal zu diesem Prompt-Testen-Werten-Kontext. Wenn ich jetzt keine Parteien habe, und ich möchte jetzt manuell schnell etwas testen mit copy-paste, kann ich da diesen gewählten Kontext, das Fenster auch, oder darunter noch ein Feld Freitext anbieten, um schnell etwas reinzukopieren.

---

**Cursor**

Ich ergänze rechts im Tab „Daten‑Kontext“ ein optionales Freitextfeld und kombiniere es beim Test mit dem gewählten Kontext (als separater Abschnitt mit klaren Trennern). Danach prüfe ich kurz den Linter.

```typescriptreact
"use client"

import { useState, useEffect, useCallback } from "react"
import { useForm } from "react-hook-form"
import { zodResolver } from "@hookform/resolvers/zod"
import * as z from "zod"
import { Button } from "@/components/ui/button"
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card"
import { Label } from "@/components/ui/label"
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select"
import { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from "@/components/ui/tooltip"
import { StructuredTemplateEditor } from "@/components/templates/structured-template-editor"
import { useToast } from "@/hooks/use-toast"
import { Loader2, Save, Eye, Play, FolderOpen, Info } from "lucide-react"
import { useAtom, useAtomValue } from "jotai"
import { activeLibraryAtom, libraryStatusAtom } from "@/atoms/library-atom"
import { 
  templatesAtom, 
  selectedTemplateNameAtom, 
  selectedTemplateAtom,
  templatesFolderIdAtom,
  templateLoadingAtom,
  templateErrorAtom,
  type Template
} from "@/atoms/template-atom"
import { useStorage } from "@/contexts/storage-context"
import { templateContextDocsAtom } from '@/atoms/template-context-atom'
import { Checkbox } from "@/components/ui/checkbox"
import { MarkdownPreview } from "@/components/library/markdown-preview"
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs"
import { JobReportTab } from "@/components/library/job-report-tab"
import { Textarea } from "@/components/ui/textarea"

// Schema für Template-Daten
const templateSchema = z.object({
  name: z.string().min(1, "Prompt-Name ist erforderlich"),
  yamlFrontmatter: z.string(),
  markdownBody: z.string(),
  systemPrompt: z.string(),
})

type TemplateFormValues = z.infer<typeof templateSchema>

export function TemplateManagement() {
  const [previewMode, setPreviewMode] = useState(false)
  const [isSaving, setIsSaving] = useState(false)
  const [isTesting, setIsTesting] = useState(false)
  const [testResult, setTestResult] = useState<string | null>(null)
  const [selectedContextIds, setSelectedContextIds] = useState<string[]>([])
  const [selectedContextMarkdown, setSelectedContextMarkdown] = useState<string>("")
  const [rightTab, setRightTab] = useState<'kontext'|'preview'|'ergebnis'>('kontext')
  const [resultSavedItemId, setResultSavedItemId] = useState<string | null>(null)
  const [freeText, setFreeText] = useState<string>("")
  const { toast } = useToast()

  // Atoms
  const [templates, setTemplates] = useAtom(templatesAtom)
  const [selectedTemplateName, setSelectedTemplateName] = useAtom(selectedTemplateNameAtom)
  const [selectedTemplate] = useAtom(selectedTemplateAtom)
  const [templatesFolderId, setTemplatesFolderId] = useAtom(templatesFolderIdAtom)
  const [isLoading, setIsLoading] = useAtom(templateLoadingAtom)
  const [error, setError] = useAtom(templateErrorAtom)

  // Library und Storage
  const activeLibrary = useAtomValue(activeLibraryAtom)
  const libraryStatus = useAtomValue(libraryStatusAtom)
  const { 
    provider: providerInstance, 
    listItems
  } = useStorage()
  const contextDocs = useAtomValue(templateContextDocsAtom)

  const form = useForm<TemplateFormValues>({
    resolver: zodResolver(templateSchema),
    defaultValues: {
      name: "",
      yamlFrontmatter: `---
title: {{title|Titel des Dokuments}}
tags: {{tags|Relevante Tags}}
date: {{date|Datum im Format yyyy-mm-dd}}
---`,
      markdownBody: `# {{title}}

## Zusammenfassung
{{summary|Kurze Zusammenfassung des Inhalts}}

## Details
{{details|Detaillierte Beschreibung}}`,
      systemPrompt: `You are a specialized assistant that processes and structures information clearly and concisely.

IMPORTANT: Your response must be a valid JSON object where each key corresponds to a template variable.`,
    },
  })

  // Helper zum Erzeugen von Default-Werten
  function getDefaultTemplateValues(name: string): TemplateFormValues {
    return {
      name,
      yamlFrontmatter: `---\n` +
        `title: {{title|Titel des Dokuments}}\n` +
        `tags: {{tags|Relevante Tags}}\n` +
        `date: {{date|Datum im Format yyyy-mm-dd}}\n` +
        `---`,
      markdownBody: `# {{title}}\n\n## Zusammenfassung\n{{summary|Kurze Zusammenfassung des Inhalts}}\n\n## Details\n{{details|Detaillierte Beschreibung}}`,
      systemPrompt: `You are a specialized assistant that processes and structures information clearly and concisely.\n\nIMPORTANT: Your response must be a valid JSON object where each key corresponds to a template variable.`,
    }
  }

  // Template-Daten laden wenn sich die Auswahl ändert
  useEffect(() => {
    if (selectedTemplate) {
      form.reset({
        name: selectedTemplate.name,
        yamlFrontmatter: selectedTemplate.yamlFrontmatter,
        markdownBody: selectedTemplate.markdownBody,
        systemPrompt: selectedTemplate.systemPrompt,
      })
    }
  }, [selectedTemplate, form])

  // Ordner-Erstellung/Suche memoisiert, damit als Dep verwendbar
  const ensureTemplatesFolder = useCallback(async (): Promise<string> => {
    if (!providerInstance || !activeLibrary) {
      throw new Error("Keine aktive Bibliothek oder Provider verfügbar");
    }

    try {
      console.log('[TemplateManagement] Suche nach Templates-Ordner...');
      const rootItems = await listItems('root');
      const templatesFolder = rootItems.find(item => 
        item.type === 'folder' && item.metadata.name === 'templates'
      );
      if (templatesFolder) {
        console.log('[TemplateManagement] Templates-Ordner gefunden:', templatesFolder.id);
        return templatesFolder.id;
      }
      console.log('[TemplateManagement] Templates-Ordner nicht gefunden, erstelle neuen...');
      const newFolder = await providerInstance.createFolder('root', 'templates');
      console.log('[TemplateManagement] Neuer Templates-Ordner erstellt:', newFolder.id);
      return newFolder.id;
    } catch (error) {
      console.error('Fehler beim Erstellen des Templates-Ordners:', {
        error: error instanceof Error ? {
          message: error.message,
          name: error.name,
          stack: error.stack?.split('\n').slice(0, 3)
        } : error,
        libraryId: activeLibrary?.id,
        libraryPath: activeLibrary?.path,
        providerName: providerInstance?.name
      });
      let errorMessage = 'Fehler beim Erstellen des Templates-Ordners';
      if (error instanceof Error) {
        if (error.message.includes('Nicht authentifiziert')) {
          errorMessage = 'Bitte authentifizieren Sie sich bei Ihrem Cloud-Speicher, um den Templates-Ordner zu erstellen.';
        } else if (error.message.includes('Keine Berechtigung')) {
          errorMessage = 'Keine Berechtigung zum Erstellen von Ordnern in der Bibliothek.';
        } else if (error.message.includes('Bibliothek nicht gefunden')) {
          errorMessage = 'Die ausgewählte Bibliothek wurde nicht gefunden.';
        } else {
          errorMessage = `Fehler beim Erstellen des Templates-Ordners: ${error.message}`;
        }
      }
      throw new Error(errorMessage);
    }
  }, [providerInstance, activeLibrary, listItems]);

  // Templates laden mit der gleichen Logik wie Library-Komponente
  const loadTemplates = useCallback(async () => {
    if (!providerInstance || libraryStatus !== 'ready' || !activeLibrary) {
      console.log('[TemplateManagement] loadTemplates übersprungen:', {
        hasProvider: !!providerInstance,
        libraryStatus,
        hasActiveLibrary: !!activeLibrary
      });
      return;
    }

    try {
      setIsLoading(true);
      setError(null);

      console.log('[TemplateManagement] Starte Prompt-Loading:', {
        libraryId: activeLibrary.id,
        libraryPath: activeLibrary.path,
        providerName: providerInstance.name
      });

      // 1. Templates-Ordner finden oder erstellen
      const folderId = await ensureTemplatesFolder();
      setTemplatesFolderId(folderId);

      console.log('[TemplateManagement] Templates-Ordner gefunden/erstellt:', folderId);

      // 2. Alle Template-Dateien im Ordner auflisten
      const items = await listItems(folderId);
      const templateFiles = items.filter(item => 
        item.type === 'file' && 
        item.metadata.name.endsWith('.md')
      );

      console.log('[TemplateManagement] Prompt-Dateien gefunden:', templateFiles.length);

      // 3. Template-Inhalte laden
      const templatePromises = templateFiles.map(async (file) => {
        try {
          const { blob } = await providerInstance.getBinary(file.id);
          const content = await blob.text();
          const template = parseTemplateContent(content, file.metadata.name.replace('.md', ''));
          
          return {
            ...template,
            fileId: file.id,
            lastModified: typeof file.metadata.modifiedAt === 'string' 
              ? file.metadata.modifiedAt 
              : file.metadata.modifiedAt instanceof Date 
                ? file.metadata.modifiedAt.toISOString()
                : new Date().toISOString()
          } as Template;
        } catch (error) {
          console.error(`Fehler beim Parsen von ${file.metadata.name}:`, error);
          return null;
        }
      });

      const loadedTemplates = await Promise.all(templatePromises);
      const validTemplates = loadedTemplates.filter((t): t is Template => t !== null);
      
      setTemplates(validTemplates);
      
      console.log('[TemplateManagement] Prompts erfolgreich geladen:', validTemplates.length);
      
      if (validTemplates.length === 0) {
        toast({
          title: "Keine Prompts gefunden",
          description: "Erstellen Sie Ihren ersten Prompt im Verzeichnis '/templates'.",
        });
      }
    } catch (error) {
      console.error('Fehler beim Laden der Prompts:', {
        error: error instanceof Error ? {
          message: error.message,
          name: error.name,
          stack: error.stack?.split('\n').slice(0, 3)
        } : error,
        libraryId: activeLibrary?.id,
        libraryPath: activeLibrary?.path,
        providerName: providerInstance?.name
      });

      let errorMessage = 'Unbekannter Fehler beim Laden der Prompts';
      
      if (error instanceof Error) {
        errorMessage = error.message;
        
        // Spezifische Fehlermeldungen für häufige Probleme
        if (error.message.includes('Nicht authentifiziert')) {
          errorMessage = 'Bitte authentifizieren Sie sich bei Ihrem Cloud-Speicher, um Prompts zu laden.';
        } else if (error.message.includes('Bibliothek nicht gefunden')) {
          errorMessage = 'Die ausgewählte Bibliothek wurde nicht gefunden. Bitte überprüfen Sie die Bibliothekskonfiguration.';
        } else if (error.message.includes('Server-Fehler')) {
          errorMessage = 'Server-Fehler beim Laden der Prompts. Bitte überprüfen Sie, ob der Bibliothekspfad existiert und zugänglich ist.';
        } else if (error.message.includes('Keine aktive Bibliothek')) {
          errorMessage = 'Keine aktive Bibliothek verfügbar. Bitte wählen Sie eine Bibliothek aus.';
        }
      }
      
      setError(errorMessage);
      toast({
        title: "Fehler beim Laden der Prompts",
        description: errorMessage,
        variant: "destructive",
      });
    } finally {
      setIsLoading(false);
    }
  }, [providerInstance, libraryStatus, activeLibrary, listItems, setTemplates, setTemplatesFolderId, setIsLoading, setError, toast, ensureTemplatesFolder]);

  // Effect für Template Loading (wie Library-Komponente)
  useEffect(() => {
    const isReady = providerInstance && libraryStatus === 'ready' && activeLibrary
    
    if (!isReady) {
      return
    }

    // Templates laden wenn noch nicht geladen
    if (!templatesFolderId) {
      loadTemplates()
    }
  }, [providerInstance, libraryStatus, activeLibrary, templatesFolderId, loadTemplates])

  // Reset wenn sich die Library ändert
  useEffect(() => {
    setSelectedTemplateName(null)
    setTemplatesFolderId(null)
    setTemplates([])
    setError(null)
  }, [libraryStatus, setSelectedTemplateName, setTemplatesFolderId, setTemplates, setError])

  useEffect(() => {
    async function loadSelectedContext() {
      if (!providerInstance || !Array.isArray(selectedContextIds) || selectedContextIds.length === 0) {
        setSelectedContextMarkdown("")
        return
      }
      try {
        const parts: string[] = []
        for (const id of selectedContextIds) {
          const { blob } = await providerInstance.getBinary(id)
          const text = await blob.text()
          const name = Array.isArray(contextDocs) ? (contextDocs.find(d => d.id === id)?.name || id) : id
          const section = `\n\n---\nDatei: ${name}\n---\n\n${text}\n\n---\nEnde Datei: ${name}\n---\n`
          parts.push(section)
        }
        setSelectedContextMarkdown(parts.join("\n\n"))
      } catch (e) {
        console.error('Fehler beim Laden des Kontextes', e)
        setSelectedContextMarkdown("")
      }
    }
    void loadSelectedContext()
  }, [providerInstance, selectedContextIds, contextDocs])

  function parseTemplateContent(content: string, fileName: string): Template {
    // Template in drei Bereiche aufteilen
    const parts = content.split('--- systemprompt')
    
    let yamlFrontmatter = ""
    let markdownBody = ""
    let systemPrompt = ""
    
    if (parts.length >= 2) {
      const mainContent = parts[0].trim()
      systemPrompt = parts[1].trim()
      
      // YAML Frontmatter extrahieren
      const yamlMatch = mainContent.match(/^---\r?\n([\s\S]*?)\r?\n---\r?\n?([\s\S]*)$/)
      if (yamlMatch) {
        yamlFrontmatter = `---\n${yamlMatch[1]}\n---`
        markdownBody = yamlMatch[2].trim()
      } else {
        // Kein YAML Frontmatter gefunden
        markdownBody = mainContent
      }
    } else {
      // Kein Systemprompt gefunden
      const yamlMatch = content.match(/^---\r?\n([\s\S]*?)\r?\n---\r?\n?([\s\S]*)$/)
      if (yamlMatch) {
        yamlFrontmatter = `---\n${yamlMatch[1]}\n---`
        markdownBody = yamlMatch[2].trim()
      } else {
        markdownBody = content
      }
    }

    return {
      name: fileName,
      yamlFrontmatter,
      markdownBody,
      systemPrompt,
    }
  }

  function generateTemplateContent(values: TemplateFormValues): string {
    let content = ""
    
    // YAML Frontmatter hinzufügen
    if (values.yamlFrontmatter.trim()) {
      content += values.yamlFrontmatter + "\n\n"
    }
    
    // Markdown Body hinzufügen
    content += values.markdownBody
    
    // System Prompt hinzufügen
    if (values.systemPrompt.trim()) {
      content += "\n\n--- systemprompt\n" + values.systemPrompt
    }
    
    return content
  }

  async function onSubmit(data: TemplateFormValues) {
    if (!activeLibrary || !templatesFolderId || !providerInstance) {
      toast({
        title: "Fehler",
        description: "Keine aktive Bibliothek oder Templates-Ordner nicht gefunden.",
        variant: "destructive",
      })
      return
    }

    setIsSaving(true)
    try {
      const templateContent = generateTemplateContent(data)
      const fileName = `${data.name}.md`
      
      // Datei als Blob erstellen
      const blob = new Blob([templateContent], { type: 'text/markdown' })
      const file = new File([blob], fileName, { type: 'text/markdown' })
      
      // Datei hochladen
      await providerInstance.uploadFile(templatesFolderId, file)
      
      // Templates neu laden
      await loadTemplates()
      
      // Auswahl auf das neue Template setzen
      setSelectedTemplateName(data.name)
      
      toast({
        title: "Template gespeichert",
        description: `Template "${data.name}" wurde erfolgreich im Verzeichnis "/templates" gespeichert.`,
      })
    } catch (error) {
      console.error('Fehler beim Speichern des Templates:', error)
      toast({
        title: "Fehler beim Speichern",
        description: error instanceof Error ? error.message : "Unbekannter Fehler",
        variant: "destructive",
      })
    } finally {
      setIsSaving(false)
    }
  }

  async function renameCurrentTemplate() {
    const current = selectedTemplateName ? templates.find(t => t.name === selectedTemplateName) : null
    if (!current || !current.fileId || !providerInstance) return
    const newName = (window.prompt('Neuen Namen eingeben:', current.name) || '').trim()
    if (!newName || newName === current.name) return
    if (/[^a-zA-Z0-9._\- ]/.test(newName)) { toast({ title: 'Ungültiger Name', description: 'Nur Buchstaben, Zahlen, Leerzeichen, . _ - sind erlaubt.', variant: 'destructive' }); return }
    if (templates.some(t => t.name.toLowerCase() === newName.toLowerCase())) { toast({ title: 'Bereits vorhanden', description: 'Bitte anderen Namen wählen.', variant: 'destructive' }); return }
    try {
      await providerInstance.renameItem(current.fileId, `${newName}.md`)
      await loadTemplates()
      setSelectedTemplateName(newName)
      form.setValue('name', newName, { shouldDirty: false })
      toast({ title: 'Umbenannt', description: `${current.name} → ${newName}` })
    } catch (e) {
      toast({ title: 'Fehler beim Umbenennen', description: e instanceof Error ? e.message : 'Unbekannter Fehler', variant: 'destructive' })
    }
  }

  async function deleteTemplate(templateName: string) {
    if (!activeLibrary || !providerInstance) return

    try {
      const template = templates.find(t => t.name === templateName)
      if (!template?.fileId) {
        throw new Error("Template-Datei nicht gefunden")
      }

      // Datei löschen
      await providerInstance.deleteItem(template.fileId)

      // Templates neu laden
      await loadTemplates()
      
      if (selectedTemplateName === templateName) {
        setSelectedTemplateName(null)
        form.reset()
      }
      
      toast({
        title: "Template gelöscht",
        description: `Template "${templateName}" wurde erfolgreich gelöscht.`,
      })
    } catch (error) {
      console.error('Fehler beim Löschen des Templates:', error)
      toast({
        title: "Fehler beim Löschen",
        description: error instanceof Error ? error.message : "Unbekannter Fehler",
        variant: "destructive",
      })
    }
  }

  async function createNewTemplate() {
    const name = (window.prompt('Neuen Template‑Namen eingeben:') || '').trim()
    if (!name) return
    if (/[^a-zA-Z0-9._\- ]/.test(name)) { toast({ title: 'Ungültiger Name', description: 'Nur Buchstaben, Zahlen, Leerzeichen, . _ - sind erlaubt.', variant: 'destructive' }); return }
    if (templates.some(t => t.name.toLowerCase() === name.toLowerCase())) { toast({ title: 'Bereits vorhanden', description: 'Bitte anderen Namen wählen.', variant: 'destructive' }); return }
    if (!providerInstance) { toast({ title: 'Kein Provider' , variant: 'destructive' }); return }
    try {
      const folderId = await ensureTemplatesFolder()
      const values = getDefaultTemplateValues(name)
      const content = (values.yamlFrontmatter ? values.yamlFrontmatter + '\n\n' : '') + values.markdownBody + '\n\n--- systemprompt\n' + values.systemPrompt
      const file = new File([new Blob([content], { type: 'text/markdown' })], `${name}.md`, { type: 'text/markdown' })
      await providerInstance.uploadFile(folderId, file)
      await loadTemplates()
      setSelectedTemplateName(name)
      form.reset(values)
      toast({ title: 'Template angelegt', description: `"${name}" wurde erstellt.` })
    } catch (e) {
      toast({ title: 'Fehler beim Anlegen', description: e instanceof Error ? e.message : 'Unbekannter Fehler', variant: 'destructive' })
    }
  }

  function generatePreview(): string {
    const values = form.getValues()
    return generateTemplateContent(values)
  }

  async function testTemplate() {
    if (!activeLibrary) return

    setIsTesting(true)
    setTestResult(null)

    const values = form.getValues()
    const templateContent = generateTemplateContent(values)
    const sections: string[] = []
    if (selectedContextMarkdown.trim()) sections.push(selectedContextMarkdown.trim())
    if (freeText.trim()) sections.push(`---\nDatei: Freitext\n---\n\n${freeText.trim()}\n\n---\nEnde Datei: Freitext\n---`)
    const testText = sections.join("\n\n")

    try {
      const response = await fetch('/api/secretary/process-text', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/x-www-form-urlencoded',
          'X-Library-Id': activeLibrary.id,
        },
        body: new URLSearchParams({
          text: testText,
          template_content: templateContent,
          source_language: 'de',
          target_language: 'de',
        }),
      })

      if (!response.ok) {
        const errorData = await response.json()
        throw new Error(errorData.error || `HTTP ${response.status}: ${response.statusText}`)
      }

      const result = await response.json()
      const formattedResult = typeof result === 'string' ? result : JSON.stringify(result, null, 2)
      setTestResult(formattedResult)
      setRightTab('ergebnis')

      toast({
        title: "Prompt-Test erfolgreich",
        description: "Der Prompt wurde erfolgreich mit dem gewählten Kontext verarbeitet.",
      })

      console.log('Prompt-Test Ergebnis:', result)
    } catch (error) {
      console.error('Fehler beim Prompt-Test:', error)
      const errorMessage = error instanceof Error ? error.message : "Unbekannter Fehler"
      setTestResult(`Fehler: ${errorMessage}`)
      setRightTab('ergebnis')
      toast({
        title: "Prompt-Test fehlgeschlagen",
        description: errorMessage,
        variant: "destructive",
      })
    } finally {
      setIsTesting(false)
    }
  }

  async function ensurePromptTestsFolder(): Promise<string> {
    if (!providerInstance) throw new Error('Kein Provider verfügbar')
    const roots = await listItems('root')
    const found = roots.find(it => it.type === 'folder' && it.metadata.name === 'prompt-tests')
    if (found) return found.id
    const created = await providerInstance.createFolder('root', 'prompt-tests')
    return created.id
  }

  async function saveTestResult() {
    try {
      if (!providerInstance || !activeLibrary || !testResult) return
      const folderId = await ensurePromptTestsFolder()
      const name = `${selectedTemplateName || 'prompt'}-test-${new Date().toISOString().replace(/[:.]/g,'-')}.md`
      const blob = new Blob([testResult], { type: 'text/markdown' })
      const file = new File([blob], name, { type: 'text/markdown' })
      const item = await providerInstance.uploadFile(folderId, file)
      setResultSavedItemId(item.id)
      toast({ title: 'Ergebnis gespeichert', description: name })
    } catch (e) {
      toast({ title: 'Speichern fehlgeschlagen', description: e instanceof Error ? e.message : 'Unbekannter Fehler', variant: 'destructive' })
    }
  }

  // Render-Logik für verschiedene Status
  if (libraryStatus === "waitingForAuth") {
    return (
      <div className="flex flex-col items-center justify-center h-full text-muted-foreground">
        <span>Diese Bibliothek benötigt eine Authentifizierung.</span>
        <span className="text-sm mt-2">Bitte konfigurieren Sie die Bibliothek in den Einstellungen.</span>
      </div>
    )
  }
  
  if (libraryStatus !== "ready") {
    return (
      <div className="flex flex-col items-center justify-center h-full text-muted-foreground">
        <span>Lade Storage...</span>
      </div>
    )
  }

  if (!activeLibrary) {
    return (
      <div className="text-center text-muted-foreground">
        Bitte wählen Sie eine Bibliothek aus.
      </div>
    )
  }

  if (error) {
    return (
      <div className="text-center text-destructive">
        <p>Fehler beim Laden der Prompts:</p>
        <p className="text-sm">{error}</p>
        <Button 
          variant="outline" 
          className="mt-4"
          onClick={loadTemplates}
        >
          Erneut versuchen
        </Button>
      </div>
    )
  }

  return (
    <div className="space-y-6">

      {/* Kompakte Toolbar oben */}
      <div className="flex items-center gap-2">
        <Select value={selectedTemplateName || ''} onValueChange={(v) => { setSelectedTemplateName(v); form.setValue('name', v, { shouldDirty: false }) }} disabled={isLoading}>
          <SelectTrigger className="w-64">
            <SelectValue placeholder="Prompt auswählen..." />
          </SelectTrigger>
          <SelectContent>
            {templates.map((t) => (
              <SelectItem key={t.name} value={t.name}>{t.name}</SelectItem>
            ))}
          </SelectContent>
        </Select>
        <TooltipProvider>
          <Tooltip>
            <TooltipTrigger asChild>
              <Button variant="ghost" size="sm" className="h-8 w-8 p-0"><Info className="h-4 w-4" /></Button>
            </TooltipTrigger>
            <TooltipContent>
              <div className="flex items-center gap-2"><FolderOpen className="h-4 w-4" /><span>Ort: /templates in „{activeLibrary.label}“</span></div>
            </TooltipContent>
          </Tooltip>
        </TooltipProvider>
        <Button type="button" variant="outline" size="sm" onClick={createNewTemplate} disabled={isLoading}>Neu</Button>
        <Button type="button" variant="outline" size="sm" onClick={renameCurrentTemplate} disabled={!selectedTemplateName}>Umbenennen</Button>
        {selectedTemplateName && (
          <Button type="button" variant="destructive" size="sm" onClick={() => deleteTemplate(selectedTemplateName!)}>Löschen</Button>
        )}
      </div>

      <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
        <Card>
          <CardHeader>
            <CardTitle>Prompt Design</CardTitle>
            <CardDescription>
              Drei Bereiche: Aufgabe (was), Rollenanweisung (wie), Metadaten (Begleitinfos).
            </CardDescription>
          </CardHeader>
          <CardContent>
            <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-6">
              {/* Template-Name Feld entfernt (oben verwaltet) */}

              {previewMode ? (
                <div className="space-y-4">
                  <div className="flex items-center justify-between">
                    <h4 className="text-sm font-medium">Prompt-Vorschau</h4>
                    <Button
                      type="button"
                      variant="outline"
                      size="sm"
                      onClick={() => setPreviewMode(false)}
                    >
                      Bearbeiten
                    </Button>
                  </div>
                  <div className="border rounded-md p-4 bg-muted/50">
                    <pre className="text-sm whitespace-pre-wrap font-mono">
                      {generatePreview()}
                    </pre>
                  </div>
                </div>
              ) : (
                <StructuredTemplateEditor
                  markdownBody={form.watch('markdownBody')}
                  yamlFrontmatter={form.watch('yamlFrontmatter')}
                  systemPrompt={form.watch('systemPrompt')}
                  onChange={({ markdownBody, yamlFrontmatter, systemPrompt }) => {
                    form.setValue('markdownBody', markdownBody, { shouldDirty: true })
                    form.setValue('yamlFrontmatter', yamlFrontmatter, { shouldDirty: true })
                    form.setValue('systemPrompt', systemPrompt, { shouldDirty: true })
                  }}
                />
              )}

              <div className="flex justify-end gap-2">
                <Button
                  type="button"
                  variant="outline"
                  onClick={() => setPreviewMode(!previewMode)}
                >
                  <Eye className="h-4 w-4 mr-2" />
                  {previewMode ? "Bearbeiten" : "Vorschau"}
                </Button>
                <Button
                  type="submit"
                  disabled={isSaving || !form.formState.isDirty}
                >
                  {isSaving ? (
                    <>
                      <Loader2 className="h-4 w-4 mr-2 animate-spin" />
                      Wird gespeichert...
                    </>
                  ) : (
                    <>
                      <Save className="h-4 w-4 mr-2" />
                      Speichern
                    </>
                  )}
                </Button>
              </div>
            </form>
          </CardContent>
        </Card>

        <Card>
          <CardHeader>
            <CardTitle>Prompt testen</CardTitle>
            <CardDescription>
              Test mit Beispieltext. Nutzt Rollenanweisung, Aufgabe und Metadaten des Prompts.
            </CardDescription>
          </CardHeader>
          <CardContent>
            <Tabs value={rightTab} onValueChange={(v) => setRightTab(v as typeof rightTab)}>
              <TabsList className="grid grid-cols-3 w-full">
                <TabsTrigger value="kontext">Daten‑Kontext</TabsTrigger>
                <TabsTrigger value="preview">Prompt‑Vorschau</TabsTrigger>
                <TabsTrigger value="ergebnis">Ergebnis</TabsTrigger>
              </TabsList>

              <TabsContent value="kontext" className="space-y-4 mt-4">
                <div className="space-y-2">
                  <Label>Kontext-Texte</Label>
                  <div className="border rounded p-2 text-sm">
                    {Array.isArray(contextDocs) && contextDocs.length > 0 ? (
                      contextDocs.map(d => {
                        const checked = selectedContextIds.includes(d.id)
                        return (
                          <label key={d.id} className="flex items-center gap-2 py-1">
                            <Checkbox
                              checked={checked}
                              onCheckedChange={(v) => {
                                const isOn = v === true
                                setSelectedContextIds(prev => isOn ? [...prev, d.id] : prev.filter(x => x !== d.id))
                              }}
                            />
                            <span className="truncate">{d.name}</span>
                          </label>
                        )
                      })
                    ) : (
                      <div className="text-muted-foreground text-sm">Keine Kontext-Texte verfügbar</div>
                    )}
                  </div>
                </div>

                <div className="space-y-2">
                  <Label>Gewählter Kontext (Lesemodus)</Label>
                  <div className="border rounded-md">
                    <MarkdownPreview content={selectedContextMarkdown} />
                  </div>
                </div>

                <div className="space-y-2">
                  <Label>Freitext (optional)</Label>
                  <Textarea
                    value={freeText}
                    onChange={(e) => setFreeText(e.target.value)}
                    placeholder="Hier Text einkleben, um schnell zu testen"
                    className="min-h-[120px] font-mono text-sm"
                  />
                </div>
              </TabsContent>

              <TabsContent value="preview" className="space-y-4 mt-4">
                <div className="space-y-2">
                  <Label>Generierter Prompt (Markdown)</Label>
                  <div className="border rounded-md">
                    <MarkdownPreview content={generatePreview()} />
                  </div>
                </div>
                <div className="flex gap-2">
                  <Button 
                    variant="outline" 
                    size="sm"
                    onClick={testTemplate}
                    disabled={!selectedTemplateName || isTesting}
                  >
                    {isTesting ? (
                      <>
                        <Loader2 className="h-4 w-4 mr-2 animate-spin" />
                        Teste...
                      </>
                    ) : (
                      <>
                        <Play className="h-4 w-4 mr-2" />
                        Prompt testen
                      </>
                    )}
                  </Button>
                </div>
              </TabsContent>

              <TabsContent value="ergebnis" className="space-y-4 mt-4">
                <Tabs defaultValue="md">
                  <TabsList className="w-full grid grid-cols-2">
                    <TabsTrigger value="md">Markdown</TabsTrigger>
                    <TabsTrigger value="meta">Metadaten</TabsTrigger>
                  </TabsList>
                  <TabsContent value="md" className="space-y-2 mt-2">
                    <Label>Ergebnis</Label>
                    <div className="border rounded-md">
                      <MarkdownPreview content={testResult || ''} />
                    </div>
                    <div className="flex gap-2">
                      <Button type="button" onClick={saveTestResult} disabled={!testResult}>Speichern</Button>
                    </div>
                  </TabsContent>
                  <TabsContent value="meta" className="mt-2">
                    {resultSavedItemId && providerInstance && activeLibrary ? (
                      <JobReportTab libraryId={activeLibrary.id} fileId={resultSavedItemId} provider={providerInstance} sourceMode="frontmatter" viewMode="metaOnly" mdFileId={resultSavedItemId} />
                    ) : (
                      <div className="text-sm text-muted-foreground">Bitte Ergebnis speichern, um Metadaten und Kapitel anzuzeigen.</div>
                    )}
                  </TabsContent>
                </Tabs>
              </TabsContent>
            </Tabs>
          </CardContent>
        </Card>
      </div>
    </div>
  )
} 
```

- Im Tab „Daten‑Kontext“ gibt es jetzt ein zusätzliches Feld „Freitext (optional)“.
- Beim Testen wird der Freitext als eigener Abschnitt mit klaren Trennern angehängt:
  - Kopf: „— Datei: Freitext —“, Inhalt, Fuß: „— Ende Datei: Freitext —“.
- Ist kein Kontext ausgewählt, kannst du nur mit Freitext testen; sind beide vorhanden, werden beide Abschnitte übermittelt.

---

**User**

Dann gehen wir nochmal ans Ende unseres Flows. Dieses Prompt-Testen-Button, das brauche ich dann oben beim Ergebnis. Die Überschrift heißt nicht Ergebnis, sondern Testen. Und darunter sehe ich dann das Ergebnis.

---

**Cursor**

```typescriptreact
"use client"

import { useState, useEffect, useCallback } from "react"
import { useForm } from "react-hook-form"
import { zodResolver } from "@hookform/resolvers/zod"
import * as z from "zod"
import { Button } from "@/components/ui/button"
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card"
import { Label } from "@/components/ui/label"
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select"
import { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from "@/components/ui/tooltip"
import { StructuredTemplateEditor } from "@/components/templates/structured-template-editor"
import { useToast } from "@/hooks/use-toast"
import { Loader2, Save, Eye, Play, FolderOpen, Info } from "lucide-react"
import { useAtom, useAtomValue } from "jotai"
import { activeLibraryAtom, libraryStatusAtom } from "@/atoms/library-atom"
import { 
  templatesAtom, 
  selectedTemplateNameAtom, 
  selectedTemplateAtom,
  templatesFolderIdAtom,
  templateLoadingAtom,
  templateErrorAtom,
  type Template
} from "@/atoms/template-atom"
import { useStorage } from "@/contexts/storage-context"
import { templateContextDocsAtom } from '@/atoms/template-context-atom'
import { Checkbox } from "@/components/ui/checkbox"
import { MarkdownPreview } from "@/components/library/markdown-preview"
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs"
import { JobReportTab } from "@/components/library/job-report-tab"
import { Textarea } from "@/components/ui/textarea"

// Schema für Template-Daten
const templateSchema = z.object({
  name: z.string().min(1, "Prompt-Name ist erforderlich"),
  yamlFrontmatter: z.string(),
  markdownBody: z.string(),
  systemPrompt: z.string(),
})

type TemplateFormValues = z.infer<typeof templateSchema>

export function TemplateManagement() {
  const [previewMode, setPreviewMode] = useState(false)
  const [isSaving, setIsSaving] = useState(false)
  const [isTesting, setIsTesting] = useState(false)
  const [testResult, setTestResult] = useState<string | null>(null)
  const [selectedContextIds, setSelectedContextIds] = useState<string[]>([])
  const [selectedContextMarkdown, setSelectedContextMarkdown] = useState<string>("")
  const [rightTab, setRightTab] = useState<'kontext'|'preview'|'testen'>('kontext')
  const [resultSavedItemId, setResultSavedItemId] = useState<string | null>(null)
  const [freeText, setFreeText] = useState<string>("")
  const { toast } = useToast()

  // Atoms
  const [templates, setTemplates] = useAtom(templatesAtom)
  const [selectedTemplateName, setSelectedTemplateName] = useAtom(selectedTemplateNameAtom)
  const [selectedTemplate] = useAtom(selectedTemplateAtom)
  const [templatesFolderId, setTemplatesFolderId] = useAtom(templatesFolderIdAtom)
  const [isLoading, setIsLoading] = useAtom(templateLoadingAtom)
  const [error, setError] = useAtom(templateErrorAtom)

  // Library und Storage
  const activeLibrary = useAtomValue(activeLibraryAtom)
  const libraryStatus = useAtomValue(libraryStatusAtom)
  const { 
    provider: providerInstance, 
    listItems
  } = useStorage()
  const contextDocs = useAtomValue(templateContextDocsAtom)

  const form = useForm<TemplateFormValues>({
    resolver: zodResolver(templateSchema),
    defaultValues: {
      name: "",
      yamlFrontmatter: `---
title: {{title|Titel des Dokuments}}
tags: {{tags|Relevante Tags}}
date: {{date|Datum im Format yyyy-mm-dd}}
---`,
      markdownBody: `# {{title}}

## Zusammenfassung
{{summary|Kurze Zusammenfassung des Inhalts}}

## Details
{{details|Detaillierte Beschreibung}}`,
      systemPrompt: `You are a specialized assistant that processes and structures information clearly and concisely.

IMPORTANT: Your response must be a valid JSON object where each key corresponds to a template variable.`,
    },
  })

  // Helper zum Erzeugen von Default-Werten
  function getDefaultTemplateValues(name: string): TemplateFormValues {
    return {
      name,
      yamlFrontmatter: `---\n` +
        `title: {{title|Titel des Dokuments}}\n` +
        `tags: {{tags|Relevante Tags}}\n` +
        `date: {{date|Datum im Format yyyy-mm-dd}}\n` +
        `---`,
      markdownBody: `# {{title}}\n\n## Zusammenfassung\n{{summary|Kurze Zusammenfassung des Inhalts}}\n\n## Details\n{{details|Detaillierte Beschreibung}}`,
      systemPrompt: `You are a specialized assistant that processes and structures information clearly and concisely.\n\nIMPORTANT: Your response must be a valid JSON object where each key corresponds to a template variable.`,
    }
  }

  // Template-Daten laden wenn sich die Auswahl ändert
  useEffect(() => {
    if (selectedTemplate) {
      form.reset({
        name: selectedTemplate.name,
        yamlFrontmatter: selectedTemplate.yamlFrontmatter,
        markdownBody: selectedTemplate.markdownBody,
        systemPrompt: selectedTemplate.systemPrompt,
      })
    }
  }, [selectedTemplate, form])

  // Ordner-Erstellung/Suche memoisiert, damit als Dep verwendbar
  const ensureTemplatesFolder = useCallback(async (): Promise<string> => {
    if (!providerInstance || !activeLibrary) {
      throw new Error("Keine aktive Bibliothek oder Provider verfügbar");
    }

    try {
      console.log('[TemplateManagement] Suche nach Templates-Ordner...');
      const rootItems = await listItems('root');
      const templatesFolder = rootItems.find(item => 
        item.type === 'folder' && item.metadata.name === 'templates'
      );
      if (templatesFolder) {
        console.log('[TemplateManagement] Templates-Ordner gefunden:', templatesFolder.id);
        return templatesFolder.id;
      }
      console.log('[TemplateManagement] Templates-Ordner nicht gefunden, erstelle neuen...');
      const newFolder = await providerInstance.createFolder('root', 'templates');
      console.log('[TemplateManagement] Neuer Templates-Ordner erstellt:', newFolder.id);
      return newFolder.id;
    } catch (error) {
      console.error('Fehler beim Erstellen des Templates-Ordners:', {
        error: error instanceof Error ? {
          message: error.message,
          name: error.name,
          stack: error.stack?.split('\n').slice(0, 3)
        } : error,
        libraryId: activeLibrary?.id,
        libraryPath: activeLibrary?.path,
        providerName: providerInstance?.name
      });
      let errorMessage = 'Fehler beim Erstellen des Templates-Ordners';
      if (error instanceof Error) {
        if (error.message.includes('Nicht authentifiziert')) {
          errorMessage = 'Bitte authentifizieren Sie sich bei Ihrem Cloud-Speicher, um den Templates-Ordner zu erstellen.';
        } else if (error.message.includes('Keine Berechtigung')) {
          errorMessage = 'Keine Berechtigung zum Erstellen von Ordnern in der Bibliothek.';
        } else if (error.message.includes('Bibliothek nicht gefunden')) {
          errorMessage = 'Die ausgewählte Bibliothek wurde nicht gefunden.';
        } else {
          errorMessage = `Fehler beim Erstellen des Templates-Ordners: ${error.message}`;
        }
      }
      throw new Error(errorMessage);
    }
  }, [providerInstance, activeLibrary, listItems]);

  // Templates laden mit der gleichen Logik wie Library-Komponente
  const loadTemplates = useCallback(async () => {
    if (!providerInstance || libraryStatus !== 'ready' || !activeLibrary) {
      console.log('[TemplateManagement] loadTemplates übersprungen:', {
        hasProvider: !!providerInstance,
        libraryStatus,
        hasActiveLibrary: !!activeLibrary
      });
      return;
    }

    try {
      setIsLoading(true);
      setError(null);

      console.log('[TemplateManagement] Starte Prompt-Loading:', {
        libraryId: activeLibrary.id,
        libraryPath: activeLibrary.path,
        providerName: providerInstance.name
      });

      // 1. Templates-Ordner finden oder erstellen
      const folderId = await ensureTemplatesFolder();
      setTemplatesFolderId(folderId);

      console.log('[TemplateManagement] Templates-Ordner gefunden/erstellt:', folderId);

      // 2. Alle Template-Dateien im Ordner auflisten
      const items = await listItems(folderId);
      const templateFiles = items.filter(item => 
        item.type === 'file' && 
        item.metadata.name.endsWith('.md')
      );

      console.log('[TemplateManagement] Prompt-Dateien gefunden:', templateFiles.length);

      // 3. Template-Inhalte laden
      const templatePromises = templateFiles.map(async (file) => {
        try {
          const { blob } = await providerInstance.getBinary(file.id);
          const content = await blob.text();
          const template = parseTemplateContent(content, file.metadata.name.replace('.md', ''));
          
          return {
            ...template,
            fileId: file.id,
            lastModified: typeof file.metadata.modifiedAt === 'string' 
              ? file.metadata.modifiedAt 
              : file.metadata.modifiedAt instanceof Date 
                ? file.metadata.modifiedAt.toISOString()
                : new Date().toISOString()
          } as Template;
        } catch (error) {
          console.error(`Fehler beim Parsen von ${file.metadata.name}:`, error);
          return null;
        }
      });

      const loadedTemplates = await Promise.all(templatePromises);
      const validTemplates = loadedTemplates.filter((t): t is Template => t !== null);
      
      setTemplates(validTemplates);
      
      console.log('[TemplateManagement] Prompts erfolgreich geladen:', validTemplates.length);
      
      if (validTemplates.length === 0) {
        toast({
          title: "Keine Prompts gefunden",
          description: "Erstellen Sie Ihren ersten Prompt im Verzeichnis '/templates'.",
        });
      }
    } catch (error) {
      console.error('Fehler beim Laden der Prompts:', {
        error: error instanceof Error ? {
          message: error.message,
          name: error.name,
          stack: error.stack?.split('\n').slice(0, 3)
        } : error,
        libraryId: activeLibrary?.id,
        libraryPath: activeLibrary?.path,
        providerName: providerInstance?.name
      });

      let errorMessage = 'Unbekannter Fehler beim Laden der Prompts';
      
      if (error instanceof Error) {
        errorMessage = error.message;
        
        // Spezifische Fehlermeldungen für häufige Probleme
        if (error.message.includes('Nicht authentifiziert')) {
          errorMessage = 'Bitte authentifizieren Sie sich bei Ihrem Cloud-Speicher, um Prompts zu laden.';
        } else if (error.message.includes('Bibliothek nicht gefunden')) {
          errorMessage = 'Die ausgewählte Bibliothek wurde nicht gefunden. Bitte überprüfen Sie die Bibliothekskonfiguration.';
        } else if (error.message.includes('Server-Fehler')) {
          errorMessage = 'Server-Fehler beim Laden der Prompts. Bitte überprüfen Sie, ob der Bibliothekspfad existiert und zugänglich ist.';
        } else if (error.message.includes('Keine aktive Bibliothek')) {
          errorMessage = 'Keine aktive Bibliothek verfügbar. Bitte wählen Sie eine Bibliothek aus.';
        }
      }
      
      setError(errorMessage);
      toast({
        title: "Fehler beim Laden der Prompts",
        description: errorMessage,
        variant: "destructive",
      });
    } finally {
      setIsLoading(false);
    }
  }, [providerInstance, libraryStatus, activeLibrary, listItems, setTemplates, setTemplatesFolderId, setIsLoading, setError, toast, ensureTemplatesFolder]);

  // Effect für Template Loading (wie Library-Komponente)
  useEffect(() => {
    const isReady = providerInstance && libraryStatus === 'ready' && activeLibrary
    
    if (!isReady) {
      return
    }

    // Templates laden wenn noch nicht geladen
    if (!templatesFolderId) {
      loadTemplates()
    }
  }, [providerInstance, libraryStatus, activeLibrary, templatesFolderId, loadTemplates])

  // Reset wenn sich die Library ändert
  useEffect(() => {
    setSelectedTemplateName(null)
    setTemplatesFolderId(null)
    setTemplates([])
    setError(null)
  }, [libraryStatus, setSelectedTemplateName, setTemplatesFolderId, setTemplates, setError])

  useEffect(() => {
    async function loadSelectedContext() {
      if (!providerInstance || !Array.isArray(selectedContextIds) || selectedContextIds.length === 0) {
        setSelectedContextMarkdown("")
        return
      }
      try {
        const parts: string[] = []
        for (const id of selectedContextIds) {
          const { blob } = await providerInstance.getBinary(id)
          const text = await blob.text()
          const name = Array.isArray(contextDocs) ? (contextDocs.find(d => d.id === id)?.name || id) : id
          const section = `\n\n---\nDatei: ${name}\n---\n\n${text}\n\n---\nEnde Datei: ${name}\n---\n`
          parts.push(section)
        }
        setSelectedContextMarkdown(parts.join("\n\n"))
      } catch (e) {
        console.error('Fehler beim Laden des Kontextes', e)
        setSelectedContextMarkdown("")
      }
    }
    void loadSelectedContext()
  }, [providerInstance, selectedContextIds, contextDocs])

  function parseTemplateContent(content: string, fileName: string): Template {
    // Template in drei Bereiche aufteilen
    const parts = content.split('--- systemprompt')
    
    let yamlFrontmatter = ""
    let markdownBody = ""
    let systemPrompt = ""
    
    if (parts.length >= 2) {
      const mainContent = parts[0].trim()
      systemPrompt = parts[1].trim()
      
      // YAML Frontmatter extrahieren
      const yamlMatch = mainContent.match(/^---\r?\n([\s\S]*?)\r?\n---\r?\n?([\s\S]*)$/)
      if (yamlMatch) {
        yamlFrontmatter = `---\n${yamlMatch[1]}\n---`
        markdownBody = yamlMatch[2].trim()
      } else {
        // Kein YAML Frontmatter gefunden
        markdownBody = mainContent
      }
    } else {
      // Kein Systemprompt gefunden
      const yamlMatch = content.match(/^---\r?\n([\s\S]*?)\r?\n---\r?\n?([\s\S]*)$/)
      if (yamlMatch) {
        yamlFrontmatter = `---\n${yamlMatch[1]}\n---`
        markdownBody = yamlMatch[2].trim()
      } else {
        markdownBody = content
      }
    }

    return {
      name: fileName,
      yamlFrontmatter,
      markdownBody,
      systemPrompt,
    }
  }

  function generateTemplateContent(values: TemplateFormValues): string {
    let content = ""
    
    // YAML Frontmatter hinzufügen
    if (values.yamlFrontmatter.trim()) {
      content += values.yamlFrontmatter + "\n\n"
    }
    
    // Markdown Body hinzufügen
    content += values.markdownBody
    
    // System Prompt hinzufügen
    if (values.systemPrompt.trim()) {
      content += "\n\n--- systemprompt\n" + values.systemPrompt
    }
    
    return content
  }

  async function onSubmit(data: TemplateFormValues) {
    if (!activeLibrary || !templatesFolderId || !providerInstance) {
      toast({
        title: "Fehler",
        description: "Keine aktive Bibliothek oder Templates-Ordner nicht gefunden.",
        variant: "destructive",
      })
      return
    }

    setIsSaving(true)
    try {
      const templateContent = generateTemplateContent(data)
      const fileName = `${data.name}.md`
      
      // Datei als Blob erstellen
      const blob = new Blob([templateContent], { type: 'text/markdown' })
      const file = new File([blob], fileName, { type: 'text/markdown' })
      
      // Datei hochladen
      await providerInstance.uploadFile(templatesFolderId, file)
      
      // Templates neu laden
      await loadTemplates()
      
      // Auswahl auf das neue Template setzen
      setSelectedTemplateName(data.name)
      
      toast({
        title: "Template gespeichert",
        description: `Template "${data.name}" wurde erfolgreich im Verzeichnis "/templates" gespeichert.`,
      })
    } catch (error) {
      console.error('Fehler beim Speichern des Templates:', error)
      toast({
        title: "Fehler beim Speichern",
        description: error instanceof Error ? error.message : "Unbekannter Fehler",
        variant: "destructive",
      })
    } finally {
      setIsSaving(false)
    }
  }

  async function renameCurrentTemplate() {
    const current = selectedTemplateName ? templates.find(t => t.name === selectedTemplateName) : null
    if (!current || !current.fileId || !providerInstance) return
    const newName = (window.prompt('Neuen Namen eingeben:', current.name) || '').trim()
    if (!newName || newName === current.name) return
    if (/[^a-zA-Z0-9._\- ]/.test(newName)) { toast({ title: 'Ungültiger Name', description: 'Nur Buchstaben, Zahlen, Leerzeichen, . _ - sind erlaubt.', variant: 'destructive' }); return }
    if (templates.some(t => t.name.toLowerCase() === newName.toLowerCase())) { toast({ title: 'Bereits vorhanden', description: 'Bitte anderen Namen wählen.', variant: 'destructive' }); return }
    try {
      await providerInstance.renameItem(current.fileId, `${newName}.md`)
      await loadTemplates()
      setSelectedTemplateName(newName)
      form.setValue('name', newName, { shouldDirty: false })
      toast({ title: 'Umbenannt', description: `${current.name} → ${newName}` })
    } catch (e) {
      toast({ title: 'Fehler beim Umbenennen', description: e instanceof Error ? e.message : 'Unbekannter Fehler', variant: 'destructive' })
    }
  }

  async function deleteTemplate(templateName: string) {
    if (!activeLibrary || !providerInstance) return

    try {
      const template = templates.find(t => t.name === templateName)
      if (!template?.fileId) {
        throw new Error("Template-Datei nicht gefunden")
      }

      // Datei löschen
      await providerInstance.deleteItem(template.fileId)

      // Templates neu laden
      await loadTemplates()
      
      if (selectedTemplateName === templateName) {
        setSelectedTemplateName(null)
        form.reset()
      }
      
      toast({
        title: "Template gelöscht",
        description: `Template "${templateName}" wurde erfolgreich gelöscht.`,
      })
    } catch (error) {
      console.error('Fehler beim Löschen des Templates:', error)
      toast({
        title: "Fehler beim Löschen",
        description: error instanceof Error ? error.message : "Unbekannter Fehler",
        variant: "destructive",
      })
    }
  }

  async function createNewTemplate() {
    const name = (window.prompt('Neuen Template‑Namen eingeben:') || '').trim()
    if (!name) return
    if (/[^a-zA-Z0-9._\- ]/.test(name)) { toast({ title: 'Ungültiger Name', description: 'Nur Buchstaben, Zahlen, Leerzeichen, . _ - sind erlaubt.', variant: 'destructive' }); return }
    if (templates.some(t => t.name.toLowerCase() === name.toLowerCase())) { toast({ title: 'Bereits vorhanden', description: 'Bitte anderen Namen wählen.', variant: 'destructive' }); return }
    if (!providerInstance) { toast({ title: 'Kein Provider' , variant: 'destructive' }); return }
    try {
      const folderId = await ensureTemplatesFolder()
      const values = getDefaultTemplateValues(name)
      const content = (values.yamlFrontmatter ? values.yamlFrontmatter + '\n\n' : '') + values.markdownBody + '\n\n--- systemprompt\n' + values.systemPrompt
      const file = new File([new Blob([content], { type: 'text/markdown' })], `${name}.md`, { type: 'text/markdown' })
      await providerInstance.uploadFile(folderId, file)
      await loadTemplates()
      setSelectedTemplateName(name)
      form.reset(values)
      toast({ title: 'Template angelegt', description: `"${name}" wurde erstellt.` })
    } catch (e) {
      toast({ title: 'Fehler beim Anlegen', description: e instanceof Error ? e.message : 'Unbekannter Fehler', variant: 'destructive' })
    }
  }

  function generatePreview(): string {
    const values = form.getValues()
    return generateTemplateContent(values)
  }

  async function testTemplate() {
    if (!activeLibrary) return

    setIsTesting(true)
    setTestResult(null)

    const values = form.getValues()
    const templateContent = generateTemplateContent(values)
    const sections: string[] = []
    if (selectedContextMarkdown.trim()) sections.push(selectedContextMarkdown.trim())
    if (freeText.trim()) sections.push(`---\nDatei: Freitext\n---\n\n${freeText.trim()}\n\n---\nEnde Datei: Freitext\n---`)
    const testText = sections.join("\n\n")

    try {
      const response = await fetch('/api/secretary/process-text', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/x-www-form-urlencoded',
          'X-Library-Id': activeLibrary.id,
        },
        body: new URLSearchParams({
          text: testText,
          template_content: templateContent,
          source_language: 'de',
          target_language: 'de',
        }),
      })

      if (!response.ok) {
        const errorData = await response.json()
        throw new Error(errorData.error || `HTTP ${response.status}: ${response.statusText}`)
      }

      const result = await response.json()
      const formattedResult = typeof result === 'string' ? result : JSON.stringify(result, null, 2)
      setTestResult(formattedResult)
      setRightTab('testen')

      toast({
        title: "Prompt-Test erfolgreich",
        description: "Der Prompt wurde erfolgreich mit dem gewählten Kontext verarbeitet.",
      })

      console.log('Prompt-Test Ergebnis:', result)
    } catch (error) {
      console.error('Fehler beim Prompt-Test:', error)
      const errorMessage = error instanceof Error ? error.message : "Unbekannter Fehler"
      setTestResult(`Fehler: ${errorMessage}`)
      setRightTab('testen')
      toast({
        title: "Prompt-Test fehlgeschlagen",
        description: errorMessage,
        variant: "destructive",
      })
    } finally {
      setIsTesting(false)
    }
  }

  async function ensurePromptTestsFolder(): Promise<string> {
    if (!providerInstance) throw new Error('Kein Provider verfügbar')
    const roots = await listItems('root')
    const found = roots.find(it => it.type === 'folder' && it.metadata.name === 'prompt-tests')
    if (found) return found.id
    const created = await providerInstance.createFolder('root', 'prompt-tests')
    return created.id
  }

  async function saveTestResult() {
    try {
      if (!providerInstance || !activeLibrary || !testResult) return
      const folderId = await ensurePromptTestsFolder()
      const name = `${selectedTemplateName || 'prompt'}-test-${new Date().toISOString().replace(/[:.]/g,'-')}.md`
      const blob = new Blob([testResult], { type: 'text/markdown' })
      const file = new File([blob], name, { type: 'text/markdown' })
      const item = await providerInstance.uploadFile(folderId, file)
      setResultSavedItemId(item.id)
      toast({ title: 'Ergebnis gespeichert', description: name })
    } catch (e) {
      toast({ title: 'Speichern fehlgeschlagen', description: e instanceof Error ? e.message : 'Unbekannter Fehler', variant: 'destructive' })
    }
  }

  // Render-Logik für verschiedene Status
  if (libraryStatus === "waitingForAuth") {
    return (
      <div className="flex flex-col items-center justify-center h-full text-muted-foreground">
        <span>Diese Bibliothek benötigt eine Authentifizierung.</span>
        <span className="text-sm mt-2">Bitte konfigurieren Sie die Bibliothek in den Einstellungen.</span>
      </div>
    )
  }
  
  if (libraryStatus !== "ready") {
    return (
      <div className="flex flex-col items-center justify-center h-full text-muted-foreground">
        <span>Lade Storage...</span>
      </div>
    )
  }

  if (!activeLibrary) {
    return (
      <div className="text-center text-muted-foreground">
        Bitte wählen Sie eine Bibliothek aus.
      </div>
    )
  }

  if (error) {
    return (
      <div className="text-center text-destructive">
        <p>Fehler beim Laden der Prompts:</p>
        <p className="text-sm">{error}</p>
        <Button 
          variant="outline" 
          className="mt-4"
          onClick={loadTemplates}
        >
          Erneut versuchen
        </Button>
      </div>
    )
  }

  return (
    <div className="space-y-6">

      {/* Kompakte Toolbar oben */}
      <div className="flex items-center gap-2">
        <Select value={selectedTemplateName || ''} onValueChange={(v) => { setSelectedTemplateName(v); form.setValue('name', v, { shouldDirty: false }) }} disabled={isLoading}>
          <SelectTrigger className="w-64">
            <SelectValue placeholder="Prompt auswählen..." />
          </SelectTrigger>
          <SelectContent>
            {templates.map((t) => (
              <SelectItem key={t.name} value={t.name}>{t.name}</SelectItem>
            ))}
          </SelectContent>
        </Select>
        <TooltipProvider>
          <Tooltip>
            <TooltipTrigger asChild>
              <Button variant="ghost" size="sm" className="h-8 w-8 p-0"><Info className="h-4 w-4" /></Button>
            </TooltipTrigger>
            <TooltipContent>
              <div className="flex items-center gap-2"><FolderOpen className="h-4 w-4" /><span>Ort: /templates in „{activeLibrary.label}“</span></div>
            </TooltipContent>
          </Tooltip>
        </TooltipProvider>
        <Button type="button" variant="outline" size="sm" onClick={createNewTemplate} disabled={isLoading}>Neu</Button>
        <Button type="button" variant="outline" size="sm" onClick={renameCurrentTemplate} disabled={!selectedTemplateName}>Umbenennen</Button>
        {selectedTemplateName && (
          <Button type="button" variant="destructive" size="sm" onClick={() => deleteTemplate(selectedTemplateName!)}>Löschen</Button>
        )}
      </div>

      <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
        <Card>
          <CardHeader>
            <CardTitle>Prompt Design</CardTitle>
            <CardDescription>
              Drei Bereiche: Aufgabe (was), Rollenanweisung (wie), Metadaten (Begleitinfos).
            </CardDescription>
          </CardHeader>
          <CardContent>
            <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-6">
              {/* Template-Name Feld entfernt (oben verwaltet) */}

              {previewMode ? (
                <div className="space-y-4">
                  <div className="flex items-center justify-between">
                    <h4 className="text-sm font-medium">Prompt-Vorschau</h4>
                    <Button
                      type="button"
                      variant="outline"
                      size="sm"
                      onClick={() => setPreviewMode(false)}
                    >
                      Bearbeiten
                    </Button>
                  </div>
                  <div className="border rounded-md p-4 bg-muted/50">
                    <pre className="text-sm whitespace-pre-wrap font-mono">
                      {generatePreview()}
                    </pre>
                  </div>
                </div>
              ) : (
                <StructuredTemplateEditor
                  markdownBody={form.watch('markdownBody')}
                  yamlFrontmatter={form.watch('yamlFrontmatter')}
                  systemPrompt={form.watch('systemPrompt')}
                  onChange={({ markdownBody, yamlFrontmatter, systemPrompt }) => {
                    form.setValue('markdownBody', markdownBody, { shouldDirty: true })
                    form.setValue('yamlFrontmatter', yamlFrontmatter, { shouldDirty: true })
                    form.setValue('systemPrompt', systemPrompt, { shouldDirty: true })
                  }}
                />
              )}

              <div className="flex justify-end gap-2">
                <Button
                  type="button"
                  variant="outline"
                  onClick={() => setPreviewMode(!previewMode)}
                >
                  <Eye className="h-4 w-4 mr-2" />
                  {previewMode ? "Bearbeiten" : "Vorschau"}
                </Button>
                <Button
                  type="submit"
                  disabled={isSaving || !form.formState.isDirty}
                >
                  {isSaving ? (
                    <>
                      <Loader2 className="h-4 w-4 mr-2 animate-spin" />
                      Wird gespeichert...
                    </>
                  ) : (
                    <>
                      <Save className="h-4 w-4 mr-2" />
                      Speichern
                    </>
                  )}
                </Button>
              </div>
            </form>
          </CardContent>
        </Card>

        <Card>
          <CardHeader>
            <CardTitle>Prompt testen</CardTitle>
            <CardDescription>
              Test mit Beispieltext. Nutzt Rollenanweisung, Aufgabe und Metadaten des Prompts.
            </CardDescription>
          </CardHeader>
          <CardContent>
            <Tabs value={rightTab} onValueChange={(v) => setRightTab(v as typeof rightTab)}>
              <TabsList className="grid grid-cols-3 w-full">
                <TabsTrigger value="kontext">Daten‑Kontext</TabsTrigger>
                <TabsTrigger value="preview">Prompt‑Vorschau</TabsTrigger>
                <TabsTrigger value="testen">Testen</TabsTrigger>
              </TabsList>

              <TabsContent value="kontext" className="space-y-4 mt-4">
                <div className="space-y-2">
                  <Label>Kontext-Texte</Label>
                  <div className="border rounded p-2 text-sm">
                    {Array.isArray(contextDocs) && contextDocs.length > 0 ? (
                      contextDocs.map(d => {
                        const checked = selectedContextIds.includes(d.id)
                        return (
                          <label key={d.id} className="flex items-center gap-2 py-1">
                            <Checkbox
                              checked={checked}
                              onCheckedChange={(v) => {
                                const isOn = v === true
                                setSelectedContextIds(prev => isOn ? [...prev, d.id] : prev.filter(x => x !== d.id))
                              }}
                            />
                            <span className="truncate">{d.name}</span>
                          </label>
                        )
                      })
                    ) : (
                      <div className="text-muted-foreground text-sm">Keine Kontext-Texte verfügbar</div>
                    )}
                  </div>
                </div>

                <div className="space-y-2">
                  <Label>Gewählter Kontext (Lesemodus)</Label>
                  <div className="border rounded-md">
                    <MarkdownPreview content={selectedContextMarkdown} />
                  </div>
                </div>

                <div className="space-y-2">
                  <Label>Freitext (optional)</Label>
                  <Textarea
                    value={freeText}
                    onChange={(e) => setFreeText(e.target.value)}
                    placeholder="Hier Text einkleben, um schnell zu testen"
                    className="min-h-[120px] font-mono text-sm"
                  />
                </div>
              </TabsContent>

              <TabsContent value="preview" className="space-y-4 mt-4">
                <div className="space-y-2">
                  <Label>Generierter Prompt (Markdown)</Label>
                  <div className="border rounded-md">
                    <MarkdownPreview content={generatePreview()} />
                  </div>
                </div>
               </TabsContent>

              <TabsContent value="testen" className="space-y-4 mt-4">
                <div className="flex gap-2 justify-end">
                  <Button 
                    variant="outline" 
                    size="sm"
                    onClick={testTemplate}
                    disabled={!selectedTemplateName || isTesting}
                  >
                    {isTesting ? (
                      <>
                        <Loader2 className="h-4 w-4 mr-2 animate-spin" />
                        Teste...
                      </>
                    ) : (
                      <>
                        <Play className="h-4 w-4 mr-2" />
                        Prompt testen
                      </>
                    )}
                  </Button>
                </div>
                <Tabs defaultValue="md">
                  <TabsList className="w-full grid grid-cols-2">
                    <TabsTrigger value="md">Markdown</TabsTrigger>
                    <TabsTrigger value="meta">Metadaten</TabsTrigger>
                  </TabsList>
                  <TabsContent value="md" className="space-y-2 mt-2">
                    <Label>Ergebnis</Label>
                    <div className="border rounded-md">
                      <MarkdownPreview content={testResult || ''} />
                    </div>
                    <div className="flex gap-2">
                      <Button type="button" onClick={saveTestResult} disabled={!testResult}>Speichern</Button>
                    </div>
                  </TabsContent>
                  <TabsContent value="meta" className="mt-2">
                    {resultSavedItemId && providerInstance && activeLibrary ? (
                      <JobReportTab libraryId={activeLibrary.id} fileId={resultSavedItemId} provider={providerInstance} sourceMode="frontmatter" viewMode="metaOnly" mdFileId={resultSavedItemId} />
                    ) : (
                      <div className="text-sm text-muted-foreground">Bitte Ergebnis speichern, um Metadaten und Kapitel anzuzeigen.</div>
                    )}
                  </TabsContent>
                </Tabs>
              </TabsContent>
            </Tabs>
          </CardContent>
        </Card>
      </div>
    </div>
  )
} 
```

- Rechts: Tab „Ergebnis“ wurde zu „Testen“ umbenannt.
- Der Button „Prompt testen“ ist jetzt oben im Tab „Testen“ platziert.
- Nach einem Test wird automatisch in den Tab „Testen“ gewechselt; darunter siehst du:
  - Markdown‑Ansicht des Ergebnisses
  - Reiter „Metadaten“ mit `JobReportTab` (nach Speichern).

---

**User**

Ok, das Ergebnis würde ich dann immer gleich in diesem in dieser Ansicht anzeigen, wie wir das auch bei diesem Report haben ohne dass man es speichert Weil, wie gesagt, wir generieren hier nur Prüfansichten, die müssten nicht gespeichert werden müssten wir den Job-Reporter eventuell anpassen, dass man auch einen Text übergeben kann oder als Parameter und nicht eine Datei@job-report-tab.tsx 

---

**Cursor**

```typescriptreact
"use client";

import { useEffect, useState } from 'react'
import { UILogger } from '@/lib/debug/logger'
import type { StorageProvider } from '@/lib/storage/types'

interface JobReportTabProps {
  libraryId: string
  fileId: string
  fileName?: string
  provider?: StorageProvider | null
  // Quelle der Metadaten steuern: 'merged' = cumulativeMeta + Frontmatter (Standard),
  // 'frontmatter' = ausschließlich Frontmatter aus Markdown anzeigen
  sourceMode?: 'merged' | 'frontmatter'
  // Darstellungsmodus: 'full' zeigt Kopf/Steps/Logs/Parameter; 'metaOnly' zeigt nur Metadaten/Kapitel/TOC
  viewMode?: 'full' | 'metaOnly'
  // Optional explizite Markdown-Datei-ID (Shadow‑Twin). Überschreibt auto-Erkennung.
  mdFileId?: string | null
  // Optionaler Callback zum Scroll-Sync in die Markdown-Vorschau
  onJumpTo?: (args: { page?: number | string; evidence?: string }) => void
  // NEU: Rohinhalt (Markdown). Wenn gesetzt und sourceMode='frontmatter', wird direkt dieser Text geparst (ohne Datei/JOB).
  rawContent?: string
}

interface JobDto {
  jobId: string
  status: string
  operation: string
  worker: string
  job_type: string
  updatedAt: string
  createdAt: string
  correlation?: { source?: { itemId?: string; name?: string } }
  parameters?: Record<string, unknown>
  steps?: Array<{ name: string; status: string; startedAt?: string; endedAt?: string; error?: { message: string }; details?: { skipped?: boolean } }>
  ingestion?: { vectorsUpserted?: number; index?: string; upsertAt?: string }
  result?: { savedItemId?: string }
  logs?: Array<{ timestamp: string; phase?: string; message?: string; progress?: number }>
  cumulativeMeta?: Record<string, unknown>
}

export function JobReportTab({ libraryId, fileId, fileName, provider, sourceMode = 'merged', viewMode = 'full', mdFileId, onJumpTo, rawContent }: JobReportTabProps) {
  const [loading, setLoading] = useState(false)
  const [error, setError] = useState<string | null>(null)
  const [job, setJob] = useState<JobDto | null>(null)
  const [templateFields, setTemplateFields] = useState<string[] | null>(null)
  const [frontmatterMeta, setFrontmatterMeta] = useState<Record<string, unknown> | null>(null)
  const [section, setSection] = useState<'meta' | 'chapters'>('meta')

  useEffect(() => {
    let cancelled = false
    async function run() {
      try {
        // Wenn wir Rohinhalt haben und nur Frontmatter zeigen, brauchen wir keine Job-Suche
        if (sourceMode === 'frontmatter' && typeof rawContent === 'string' && rawContent.length > 0) {
          setJob(null)
          setLoading(false)
          setError(null)
          return
        }
        setLoading(true)
        setError(null)
        UILogger.info('JobReportTab', 'Start Job-Suche', { libraryId, fileId })
        // 1) Versuche Job über result.savedItemId (Shadow‑Twin) zu finden
        const byResultUrl = new URL(`/api/external/jobs`, window.location.origin)
        byResultUrl.searchParams.set('byResultItemId', fileId)
        UILogger.debug('JobReportTab', 'Request byResultItemId', { url: byResultUrl.toString() })
        let res = await fetch(byResultUrl.toString(), { cache: 'no-store' })
        let data = await res.json()
        if (!res.ok) throw new Error(typeof data?.error === 'string' ? data.error : 'Job-Suche fehlgeschlagen')
        let j: JobDto | null = Array.isArray(data?.items) && data.items.length > 0 ? (data.items[0] as JobDto) : null
        UILogger.debug('JobReportTab', 'Result byResultItemId', { count: Array.isArray(data?.items) ? data.items.length : 0 })

        // 2) Fallback: über correlation.source.itemId (Originaldatei)
        if (!j) {
          const bySourceUrl = new URL(`/api/external/jobs`, window.location.origin)
          bySourceUrl.searchParams.set('bySourceItemId', fileId)
          bySourceUrl.searchParams.set('libraryId', libraryId)
          UILogger.debug('JobReportTab', 'Request bySourceItemId', { url: bySourceUrl.toString() })
          res = await fetch(bySourceUrl.toString(), { cache: 'no-store' })
          data = await res.json()
          if (!res.ok) throw new Error(typeof data?.error === 'string' ? data.error : 'Job-Suche (Quelle) fehlgeschlagen')
          j = Array.isArray(data?.items) && data.items.length > 0 ? (data.items[0] as JobDto) : null
          UILogger.debug('JobReportTab', 'Result bySourceItemId', { count: Array.isArray(data?.items) ? data.items.length : 0 })
        }

        // 3) Fallback: über correlation.source.name (Dateiname der Quelle)
        if (!j) {
          const byNameUrl = new URL(`/api/external/jobs`, window.location.origin)
          // Wenn wir den tatsächlichen Dateinamen kennen, verwende ihn.
          // Für Shadow‑Twins (z. B. name.de.md) versuche das Basis‑PDF (name.pdf).
          let candidate = (fileName && typeof fileName === 'string') ? fileName : (fileId.includes('/') ? (fileId.split('/').pop() as string) : fileId)
          const parts = candidate.split('.')
          if (parts.length >= 3) {
            const ext1 = parts[parts.length - 1].toLowerCase()
            const ext2 = parts[parts.length - 2].toLowerCase()
            if ((ext1 === 'md' || ext1 === 'mdx') && /^[a-z]{2}$/i.test(ext2)) {
              candidate = parts.slice(0, -2).join('.') + '.pdf'
            }
          }
          byNameUrl.searchParams.set('bySourceName', candidate)
          byNameUrl.searchParams.set('libraryId', libraryId)
          UILogger.debug('JobReportTab', 'Request bySourceName', { url: byNameUrl.toString(), nameOnly: candidate, originalFileName: fileName })
          res = await fetch(byNameUrl.toString(), { cache: 'no-store' })
          data = await res.json()
          if (!res.ok) throw new Error(typeof data?.error === 'string' ? data.error : 'Job-Suche (Name) fehlgeschlagen')
          j = Array.isArray(data?.items) && data.items.length > 0 ? (data.items[0] as JobDto) : null
          UILogger.debug('JobReportTab', 'Result bySourceName', { count: Array.isArray(data?.items) ? data.items.length : 0 })
        }

        if (!cancelled) setJob(j)
        if (j) UILogger.info('JobReportTab', 'Job gefunden', { jobId: j.jobId, status: j.status })
        else UILogger.warn('JobReportTab', 'Kein Job gefunden', { libraryId, fileId })
      } catch (e) {
        const msg = e instanceof Error ? e.message : 'Unbekannter Fehler'
        UILogger.error('JobReportTab', 'Job-Suche fehlgeschlagen', e)
        if (!cancelled) setError(msg)
      } finally {
        if (!cancelled) setLoading(false)
      }
    }
    void run()
    return () => { cancelled = true }
  }, [libraryId, fileId, fileName, sourceMode, rawContent])

  // Wenn Template benutzt wurde, lade dessen Inhalt aus /templates und extrahiere Frontmatter-Schlüssel
  useEffect(() => {
    async function loadTemplateFields() {
      try {
        setTemplateFields(null)
        const tpl = job?.cumulativeMeta && typeof (job.cumulativeMeta as unknown) === 'object'
          ? (job.cumulativeMeta as Record<string, unknown>)['template_used']
          : undefined
        const templateName = typeof tpl === 'string' ? tpl : undefined
        if (!templateName || !provider) return
        const rootItems = await provider.listItemsById('root')
        const templatesFolder = rootItems.find(it => it.type === 'folder' && typeof (it as { metadata?: { name?: string } }).metadata?.name === 'string' && ((it as { metadata: { name: string } }).metadata.name.toLowerCase() === 'templates'))
        if (!templatesFolder) return
        const tplItems = await provider.listItemsById(templatesFolder.id)
        const match = tplItems.find(it => it.type === 'file' && ((it as { metadata: { name: string } }).metadata.name.toLowerCase() === templateName.toLowerCase()))
        if (!match) return
        const bin = await provider.getBinary(match.id)
        const text = await bin.blob.text()
        // Extrahiere Frontmatter zwischen den ersten beiden --- und lese die Keys bis zu :
        const m = text.match(/^---[\s\S]*?---/)
        if (!m) return
        const fm = m[0]
        const keys: string[] = []
        for (const line of fm.split('\n')) {
          const t = line.trim()
          if (!t || t === '---') continue
          const idx = t.indexOf(':')
          if (idx > 0) {
            const k = t.slice(0, idx).trim()
            if (k) keys.push(k)
          }
        }
        setTemplateFields(Array.from(new Set(keys)))
      } catch (e) {
        UILogger.warn('JobReportTab', 'Template-Felder konnten nicht geladen werden', { error: e instanceof Error ? e.message : String(e) })
      }
    }
    void loadTemplateFields()
  }, [job, provider])

  // Frontmatter aus der gespeicherten Markdown-Datei lesen (oder aus rawContent)
  useEffect(() => {
    async function loadFrontmatter() {
      try {
        // Wenn roher Inhalt übergeben wurde, direkt daraus lesen
        if (sourceMode === 'frontmatter' && typeof rawContent === 'string' && rawContent.length > 0) {
          const text = rawContent
          const m = text.match(/^---[\s\S]*?---/)
          UILogger.debug('JobReportTab', 'Frontmatter (raw): Block gefunden?', { found: !!m, length: m ? m[0].length : 0 })
          if (!m) { setFrontmatterMeta(null); return }
          const fm = m[0]
          const meta: Record<string, unknown> = {}
          const tryParse = (val: string): unknown => {
            const trimmed = val.trim()
            if (!trimmed) return ''
            if (trimmed === 'true' || trimmed === 'false') return trimmed === 'true'
            if (/^[-+]?[0-9]+(\.[0-9]+)?$/.test(trimmed)) return Number(trimmed)
            if ((trimmed.startsWith('[') && trimmed.endsWith(']')) || (trimmed.startsWith('{') && trimmed.endsWith('}'))) {
              try { return JSON.parse(trimmed) } catch { return trimmed }
            }
            return trimmed.replace(/^"|"$/g, '')
          }
          for (const line of fm.split('\n')) {
            const t = line.trim()
            if (!t || t === '---') continue
            const idx = t.indexOf(':')
            if (idx > 0) {
              const k = t.slice(0, idx).trim()
              const v = t.slice(idx + 1)
              meta[k] = tryParse(v)
            }
          }
          // Spezialfälle
          const cap = /\nchapters:\s*(\[[\s\S]*?\])\s*\n/m.exec(fm)
          if (cap && cap[1]) {
            try { meta['chapters'] = JSON.parse(cap[1]) } catch { /* ignore */ }
          }
          const tocCap = /\ntoc:\s*(\[[\s\S]*?\])\s*\n/m.exec(fm)
          if (tocCap && tocCap[1]) {
            try { meta['toc'] = JSON.parse(tocCap[1]) } catch { /* ignore */ }
          }
          setFrontmatterMeta(Object.keys(meta).length ? meta : null)
          return
        }

        if (!provider) return
        const mdId = (mdFileId || (job?.result?.savedItemId as string | undefined) || fileId)
        UILogger.info('JobReportTab', 'Frontmatter: Lade Datei', { mdId, sourceMode })
        if (!mdId) return
        const bin = await provider.getBinary(mdId)
        const text = await bin.blob.text()
        const m = text.match(/^---[\s\S]*?---/)
        UILogger.debug('JobReportTab', 'Frontmatter: Block gefunden?', { found: !!m, length: m ? m[0].length : 0 })
        if (!m) { setFrontmatterMeta(null); return }
        const fm = m[0]
        const meta: Record<string, unknown> = {}
        // Einfache Parser-Heuristiken für häufige Felder (JSON-ähnliche Werte werden geparst)
        const tryParse = (val: string): unknown => {
          const trimmed = val.trim()
          if (!trimmed) return ''
          if (trimmed === 'true' || trimmed === 'false') return trimmed === 'true'
          if (/^[-+]?[0-9]+(\.[0-9]+)?$/.test(trimmed)) return Number(trimmed)
          if ((trimmed.startsWith('[') && trimmed.endsWith(']')) || (trimmed.startsWith('{') && trimmed.endsWith('}'))) {
            try { return JSON.parse(trimmed) } catch { return trimmed }
          }
          return trimmed.replace(/^"|"$/g, '')
        }
        // Versuche kompakte Arrays (z. B. authors: ["..."])
        for (const line of fm.split('\n')) {
          const t = line.trim()
          if (!t || t === '---') continue
          const idx = t.indexOf(':')
          if (idx > 0) {
            const k = t.slice(0, idx).trim()
            const v = t.slice(idx + 1)
            meta[k] = tryParse(v)
          }
        }
        // Spezialfälle: mehrzeilige JSON-Blöcke für chapters/toc extrahieren
        const cap = /\nchapters:\s*(\[[\s\S]*?\])\s*\n/m.exec(fm)
        if (cap && cap[1]) {
          try { meta['chapters'] = JSON.parse(cap[1]) } catch { /* ignore */ }
        }
        const tocCap = /\ntoc:\s*(\[[\s\S]*?\])\s*\n/m.exec(fm)
        if (tocCap && tocCap[1]) {
          try { meta['toc'] = JSON.parse(tocCap[1]) } catch { /* ignore */ }
        }
        UILogger.info('JobReportTab', 'Frontmatter: Keys & Counts', {
          keys: Object.keys(meta),
          chapters: Array.isArray(meta['chapters']) ? (meta['chapters'] as unknown[]).length : 0,
          toc: Array.isArray(meta['toc']) ? (meta['toc'] as unknown[]).length : 0,
        })
        setFrontmatterMeta(Object.keys(meta).length ? meta : null)
      } catch {
        setFrontmatterMeta(null)
      }
    }
    void loadFrontmatter()
  }, [provider, fileId, mdFileId, job?.result?.savedItemId, sourceMode, rawContent])

  if (sourceMode !== 'frontmatter') {
    if (loading) return <div className="p-4 text-sm text-muted-foreground">Lade Job…</div>
    if (error) return <div className="p-4 text-sm text-destructive">{error}</div>
    if (!job) return <div className="p-4 text-sm text-muted-foreground">Kein Job zur Datei gefunden.</div>
  }

  return (
    <div className="p-4 space-y-3 text-sm">
      {viewMode === 'metaOnly' && (
        <div className="inline-flex rounded border overflow-hidden">
          <button
            type="button"
            onClick={() => setSection('meta')}
            className={`px-3 py-1 text-xs ${section === 'meta' ? 'bg-primary text-primary-foreground' : 'bg-background'} border-r`}
            aria-pressed={section === 'meta'}
          >
            Metadaten
          </button>
          <button
            type="button"
            onClick={() => setSection('chapters')}
            className={`px-3 py-1 text-xs ${section === 'chapters' ? 'bg-primary text-primary-foreground' : 'bg-background'}`}
            aria-pressed={section === 'chapters'}
          >
            Kapitel
          </button>
        </div>
      )}
      {viewMode === 'full' && job && (
        <div className="flex items-center justify-between">
          <div>
            <div className="font-medium">Job {job.jobId}</div>
            <div className="text-xs text-muted-foreground">{job.job_type} · {job.operation} · {new Date(job.updatedAt).toLocaleString()}</div>
          </div>
          <div className="inline-flex items-center rounded px-2 py-0.5 bg-muted text-xs">{job.status}</div>
        </div>
      )}

      {/* Template Hinweis (im Frontmatter-only-Modus ausgeblendet) */}
      {sourceMode !== 'frontmatter' && job && typeof job.cumulativeMeta?.template_used === 'string' && (
        <div className="text-xs text-muted-foreground">Template: {String(job.cumulativeMeta.template_used)}</div>
      )}

      {/* Schritte mit Ampel-Logik */}
      {viewMode === 'full' && job && Array.isArray(job.steps) && job.steps.length > 0 && (
        <div>
          <div className="font-medium mb-1">Schritte</div>
          <div className="flex flex-wrap gap-2 text-xs">
            {job.steps.map((s) => {
              // Geplante Phasen ermitteln (neue Flags bevorzugt, sonst phases)
              const p = (job.parameters || {}) as Record<string, unknown>
              const hasNewFlags = typeof p['doExtractPDF'] === 'boolean' || typeof p['doExtractMetadata'] === 'boolean' || typeof p['doIngestRAG'] === 'boolean'
              const phases = hasNewFlags
                ? {
                    extract: p['doExtractPDF'] === true,
                    template: p['doExtractMetadata'] === true,
                    ingest: p['doIngestRAG'] === true,
                  }
                : ((p['phases'] as { extract?: boolean; template?: boolean; ingest?: boolean }) || {})

              const planned = (() => {
                const n = s.name
                if (n === 'extract_pdf') return phases.extract === true
                if (n === 'transform_template' || n === 'store_shadow_twin') return phases.template === true
                if (n === 'ingest_rag') return phases.ingest === true
                return false
              })()

              // Ampel-Status ableiten
              const skipped = !!(s as { details?: { skipped?: boolean } }).details?.skipped
              let icon = '○'
              let cls = 'text-muted-foreground'
              if (s.status === 'failed') { icon = '✕'; cls = 'text-red-600' }
              else if (s.status === 'running') { icon = '◐'; cls = 'text-yellow-600' }
              else if (s.status === 'completed') { icon = skipped ? '○' : '✓'; cls = skipped ? 'text-gray-400' : 'text-green-600' }
              else if (s.status === 'pending') { icon = planned ? '•' : '○'; cls = planned ? 'text-yellow-600' : 'text-muted-foreground' }

              const time = s.endedAt ? new Date(s.endedAt).toLocaleTimeString() : s.startedAt ? new Date(s.startedAt).toLocaleTimeString() : ''
              return (
                <div key={s.name} className={`inline-flex items-center gap-1 px-2 py-1 rounded border ${cls}`}>
                  <span>{icon}</span>
                  <span className="font-medium">{s.name}</span>
                  {time ? <span className="opacity-70">{time}</span> : null}
                </div>
              )
            })}
          </div>
        </div>
      )}

      {/* Metadaten (flach) – je nach sourceMode: nur Frontmatter oder Merge */}
      {section === 'meta' && (() => {
        const base: Record<string, unknown> = sourceMode === 'frontmatter'
          ? {}
          : ((job?.cumulativeMeta as unknown as Record<string, unknown>) || {})
        const cm = frontmatterMeta ? { ...base, ...frontmatterMeta } : base
        const baseKeys = Array.isArray(templateFields) && templateFields.length > 0
          ? templateFields
          : Object.keys(cm)
        const flatKeys = baseKeys.filter(k => k !== 'chapters' && k !== 'toc')
        if (flatKeys.length === 0) return null
        return (
        <div>
          <div className="font-medium mb-1">Metadaten (Template vs. Ergebnis)</div>
          <div className="overflow-auto">
            <table className="w-full text-xs">
              <thead>
                <tr className="text-left text-muted-foreground">
                  <th className="py-1 pr-2">Feld</th>
                  <th className="py-1 pr-2">Wert</th>
                </tr>
              </thead>
              <tbody>
                {flatKeys.map((k) => {
                  const val = cm[k]
                  let valueStr = ''
                  if (Array.isArray(val)) valueStr = (val as Array<unknown>).map(v => typeof v === 'string' ? v : JSON.stringify(v)).join(', ')
                  else valueStr = val === null || val === undefined ? '' : typeof val === 'string' ? val : JSON.stringify(val)
                  return (
                    <tr key={k} className="border-t border-muted/40">
                      <td className="py-1 pr-2 align-top font-medium">{k}</td>
                      <td className="py-1 pr-2 align-top whitespace-pre-wrap break-words">{valueStr}</td>
                    </tr>
                  )
                })}
              </tbody>
            </table>
          </div>
        </div>
        )
      })()}

      {/* Kapitel (hierarchisch, TOC-Ansicht mit Einrückung & Aufklappen) */}
      {section === 'chapters' && (() => {
        const chapters: Array<Record<string, unknown>> = sourceMode === 'frontmatter'
          ? (Array.isArray(frontmatterMeta?.chapters) ? (frontmatterMeta?.chapters as Array<Record<string, unknown>>) : [])
          : ((job?.cumulativeMeta as unknown as { chapters?: Array<Record<string, unknown>> })?.chapters || [])
        if (!Array.isArray(chapters) || chapters.length === 0) return null

        const pad = (lvl: number | undefined): number => {
          if (typeof lvl !== 'number') return 0
          const clamped = Math.max(0, Math.min(3, lvl))
          return (clamped - 1) * 16 // px
        }

        // Hierarchische Nummerierung 1., 1.1, 1.1.1 basierend auf level
        const counters = [0, 0, 0]
        return (
        <div className="space-y-1">
          <div className="font-medium mb-1">Kapitel</div>
          <div>
            {chapters.map((c, i) => {
              const level = typeof c.level === 'number' ? c.level : 1
              const lvl = Math.max(1, Math.min(3, level))
              // Zähler aktualisieren
              counters[lvl - 1] += 1
              for (let j = lvl; j < counters.length; j++) counters[j] = 0
              const numLabel = counters.slice(0, lvl).filter(n => n > 0).join('.')
              const title = typeof c.title === 'string' ? c.title : ''
              const startPage = typeof c.startPage === 'number' ? c.startPage : ''
              
              const summaryVal = typeof c.summary === 'string' ? c.summary : ''
              const summary = summaryVal.length > 1000 ? `${summaryVal.slice(0, 1000)}…` : summaryVal
              const keywords = Array.isArray(c.keywords) ? (c.keywords as Array<unknown>).filter(v => typeof v === 'string') as string[] : []
              const ev = typeof c.startEvidence === 'string' ? c.startEvidence : ''
              return (
                <details key={`${title}-${i}`} className="group border-b py-1" open={false} onToggle={(e) => {
                  const open = (e.currentTarget as HTMLDetailsElement).open
                  if (open) {
                    if (startPage !== '') onJumpTo?.({ page: startPage as number | string })
                    else if (ev) onJumpTo?.({ evidence: ev })
                  }
                }}>
                  <summary className="list-none cursor-pointer">
                    <div className="flex items-start justify-between gap-3">
                      <div className="flex-1 min-w-0" style={{ paddingLeft: `${pad(lvl)}px` }}>
                        <div className="flex items-baseline gap-2">
                          <span className="text-xs text-muted-foreground tabular-nums">{numLabel}</span>
                          <span className="font-medium truncate">{title}</span>
                        </div>
                      </div>
                      <div className="text-xs tabular-nums text-muted-foreground whitespace-nowrap">
                        {String(startPage)}
                      </div>
                    </div>
                  </summary>
                  <div className="mt-1 pr-1 text-xs space-y-1" style={{ paddingLeft: `${pad(lvl) + 28}px` }}>
                    {summary && (
                      <div className="whitespace-pre-wrap break-words">
                        {summary}
                      </div>
                    )}
                    {Array.isArray(keywords) && keywords.length > 0 && (
                      <div className="flex flex-wrap gap-1">
                        {keywords.map(k => (
                          <span key={k} className="inline-flex items-center rounded px-1.5 py-0.5 bg-muted">{k}</span>
                        ))}
                      </div>
                    )}
                  </div>
                </details>
              )
            })}
          </div>
        </div>
        )
      })()}

      {/* Inhaltsverzeichnis */}
      {section === 'chapters' && (() => {
        const toc: Array<Record<string, unknown>> = sourceMode === 'frontmatter'
          ? (Array.isArray(frontmatterMeta?.toc) ? (frontmatterMeta?.toc as Array<Record<string, unknown>>) : [])
          : ((job?.cumulativeMeta as unknown as { toc?: Array<Record<string, unknown>> }).toc || [])
        if (!Array.isArray(toc) || toc.length === 0) return null
        return (
        <div>
          <div className="font-medium mb-1">Inhaltsverzeichnis</div>
          <div className="overflow-visible">
            <table className="w-full text-xs">
              <thead>
                <tr className="text-left text-muted-foreground">
                  <th className="py-1 pr-2">Titel</th>
                  <th className="py-1 pr-2">Seite</th>
                  <th className="py-1 pr-2">L</th>
                </tr>
              </thead>
              <tbody>
                {toc.map((t, i) => {
                  const title = typeof t.title === 'string' ? t.title : ''
                  const page = typeof t.page === 'number' ? t.page : ''
                  const level = typeof t.level === 'number' ? t.level : ''
                  return (
                    <tr key={`${title}-${i}`} className="border-t border-muted/40">
                      <td className="py-1 pr-2 align-top whitespace-pre-wrap break-words">{title}</td>
                      <td className="py-1 pr-2 align-top">{page}</td>
                      <td className="py-1 pr-2 align-top">{level}</td>
                    </tr>
                  )
                })}
              </tbody>
            </table>
          </div>
        </div>
        )
      })()}

      {viewMode === 'full' && job && job.ingestion && (
        <div>
          <div className="font-medium mb-1">Ingestion</div>
          <div className="text-xs text-muted-foreground">{job.ingestion.index || '—'} · Vektoren: {job.ingestion.vectorsUpserted ?? '—'} · {job.ingestion.upsertAt ? new Date(job.ingestion.upsertAt).toLocaleString() : '—'}</div>
        </div>
      )}

      {viewMode === 'full' && job && Array.isArray(job.logs) && job.logs.length > 0 && (
        <div>
          <div className="font-medium mb-1">Logs (neueste zuerst)</div>
          <ul className="space-y-0.5 max-h-48 overflow-auto">
            {[...job.logs].reverse().slice(0, 30).map((l, i) => (
              <li key={i} className="text-xs">
                {new Date(l.timestamp).toLocaleTimeString()} · {l.phase || '—'} · {typeof l.progress === 'number' ? `${l.progress}% · ` : ''}{l.message || ''}
              </li>
            ))}
          </ul>
        </div>
      )}

      {/* Parameter am Ende */}
      {viewMode === 'full' && job && job.parameters && (
        <div>
          <div className="font-medium mb-1">Parameter</div>
          <pre className="bg-muted/40 rounded p-2 max-h-32 overflow-auto whitespace-pre-wrap break-words">{JSON.stringify(job.parameters, null, 2)}</pre>
        </div>
      )}
    </div>
  )
}



```

- JobReportTab erweitert: Kann jetzt auch ohne Speichern genutzt werden.
  - Neuer Prop `rawContent`: Wenn gesetzt und `sourceMode="frontmatter"`, wird Frontmatter direkt aus diesem Markdown-String geparst; kein Job-/Datei-Fetch nötig.
  - Bestehende Metadaten-/Kapitel-Ansicht wiederverwendet.

- In „Testen“ kannst du somit sofort die Metadaten/Kapitel-Ansicht anzeigen, indem du dem `JobReportTab` einfach das Testergebnis als `rawContent` übergibst, statt erst zu speichern.

---

**User**

können wir das einbauen und testen?

---

**Cursor**

```typescriptreact
"use client"

import { useState, useEffect, useCallback } from "react"
import { useForm } from "react-hook-form"
import { zodResolver } from "@hookform/resolvers/zod"
import * as z from "zod"
import { Button } from "@/components/ui/button"
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card"
import { Label } from "@/components/ui/label"
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select"
import { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from "@/components/ui/tooltip"
import { StructuredTemplateEditor } from "@/components/templates/structured-template-editor"
import { useToast } from "@/hooks/use-toast"
import { Loader2, Save, Eye, Play, FolderOpen, Info } from "lucide-react"
import { useAtom, useAtomValue } from "jotai"
import { activeLibraryAtom, libraryStatusAtom } from "@/atoms/library-atom"
import { 
  templatesAtom, 
  selectedTemplateNameAtom, 
  selectedTemplateAtom,
  templatesFolderIdAtom,
  templateLoadingAtom,
  templateErrorAtom,
  type Template
} from "@/atoms/template-atom"
import { useStorage } from "@/contexts/storage-context"
import { templateContextDocsAtom } from '@/atoms/template-context-atom'
import { Checkbox } from "@/components/ui/checkbox"
import { MarkdownPreview } from "@/components/library/markdown-preview"
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs"
import { JobReportTab } from "@/components/library/job-report-tab"
import { Textarea } from "@/components/ui/textarea"

// Schema für Template-Daten
const templateSchema = z.object({
  name: z.string().min(1, "Prompt-Name ist erforderlich"),
  yamlFrontmatter: z.string(),
  markdownBody: z.string(),
  systemPrompt: z.string(),
})

type TemplateFormValues = z.infer<typeof templateSchema>

export function TemplateManagement() {
  const [previewMode, setPreviewMode] = useState(false)
  const [isSaving, setIsSaving] = useState(false)
  const [isTesting, setIsTesting] = useState(false)
  const [testResult, setTestResult] = useState<string | null>(null)
  const [selectedContextIds, setSelectedContextIds] = useState<string[]>([])
  const [selectedContextMarkdown, setSelectedContextMarkdown] = useState<string>("")
  const [rightTab, setRightTab] = useState<'kontext'|'preview'|'testen'>('kontext')
  const [resultSavedItemId, setResultSavedItemId] = useState<string | null>(null)
  const [freeText, setFreeText] = useState<string>("")
  const { toast } = useToast()

  // Atoms
  const [templates, setTemplates] = useAtom(templatesAtom)
  const [selectedTemplateName, setSelectedTemplateName] = useAtom(selectedTemplateNameAtom)
  const [selectedTemplate] = useAtom(selectedTemplateAtom)
  const [templatesFolderId, setTemplatesFolderId] = useAtom(templatesFolderIdAtom)
  const [isLoading, setIsLoading] = useAtom(templateLoadingAtom)
  const [error, setError] = useAtom(templateErrorAtom)

  // Library und Storage
  const activeLibrary = useAtomValue(activeLibraryAtom)
  const libraryStatus = useAtomValue(libraryStatusAtom)
  const { 
    provider: providerInstance, 
    listItems
  } = useStorage()
  const contextDocs = useAtomValue(templateContextDocsAtom)

  const form = useForm<TemplateFormValues>({
    resolver: zodResolver(templateSchema),
    defaultValues: {
      name: "",
      yamlFrontmatter: `---
title: {{title|Titel des Dokuments}}
tags: {{tags|Relevante Tags}}
date: {{date|Datum im Format yyyy-mm-dd}}
---`,
      markdownBody: `# {{title}}

## Zusammenfassung
{{summary|Kurze Zusammenfassung des Inhalts}}

## Details
{{details|Detaillierte Beschreibung}}`,
      systemPrompt: `You are a specialized assistant that processes and structures information clearly and concisely.

IMPORTANT: Your response must be a valid JSON object where each key corresponds to a template variable.`,
    },
  })

  // Helper zum Erzeugen von Default-Werten
  function getDefaultTemplateValues(name: string): TemplateFormValues {
    return {
      name,
      yamlFrontmatter: `---\n` +
        `title: {{title|Titel des Dokuments}}\n` +
        `tags: {{tags|Relevante Tags}}\n` +
        `date: {{date|Datum im Format yyyy-mm-dd}}\n` +
        `---`,
      markdownBody: `# {{title}}\n\n## Zusammenfassung\n{{summary|Kurze Zusammenfassung des Inhalts}}\n\n## Details\n{{details|Detaillierte Beschreibung}}`,
      systemPrompt: `You are a specialized assistant that processes and structures information clearly and concisely.\n\nIMPORTANT: Your response must be a valid JSON object where each key corresponds to a template variable.`,
    }
  }

  // Template-Daten laden wenn sich die Auswahl ändert
  useEffect(() => {
    if (selectedTemplate) {
      form.reset({
        name: selectedTemplate.name,
        yamlFrontmatter: selectedTemplate.yamlFrontmatter,
        markdownBody: selectedTemplate.markdownBody,
        systemPrompt: selectedTemplate.systemPrompt,
      })
    }
  }, [selectedTemplate, form])

  // Ordner-Erstellung/Suche memoisiert, damit als Dep verwendbar
  const ensureTemplatesFolder = useCallback(async (): Promise<string> => {
    if (!providerInstance || !activeLibrary) {
      throw new Error("Keine aktive Bibliothek oder Provider verfügbar");
    }

    try {
      console.log('[TemplateManagement] Suche nach Templates-Ordner...');
      const rootItems = await listItems('root');
      const templatesFolder = rootItems.find(item => 
        item.type === 'folder' && item.metadata.name === 'templates'
      );
      if (templatesFolder) {
        console.log('[TemplateManagement] Templates-Ordner gefunden:', templatesFolder.id);
        return templatesFolder.id;
      }
      console.log('[TemplateManagement] Templates-Ordner nicht gefunden, erstelle neuen...');
      const newFolder = await providerInstance.createFolder('root', 'templates');
      console.log('[TemplateManagement] Neuer Templates-Ordner erstellt:', newFolder.id);
      return newFolder.id;
    } catch (error) {
      console.error('Fehler beim Erstellen des Templates-Ordners:', {
        error: error instanceof Error ? {
          message: error.message,
          name: error.name,
          stack: error.stack?.split('\n').slice(0, 3)
        } : error,
        libraryId: activeLibrary?.id,
        libraryPath: activeLibrary?.path,
        providerName: providerInstance?.name
      });
      let errorMessage = 'Fehler beim Erstellen des Templates-Ordners';
      if (error instanceof Error) {
        if (error.message.includes('Nicht authentifiziert')) {
          errorMessage = 'Bitte authentifizieren Sie sich bei Ihrem Cloud-Speicher, um den Templates-Ordner zu erstellen.';
        } else if (error.message.includes('Keine Berechtigung')) {
          errorMessage = 'Keine Berechtigung zum Erstellen von Ordnern in der Bibliothek.';
        } else if (error.message.includes('Bibliothek nicht gefunden')) {
          errorMessage = 'Die ausgewählte Bibliothek wurde nicht gefunden.';
        } else {
          errorMessage = `Fehler beim Erstellen des Templates-Ordners: ${error.message}`;
        }
      }
      throw new Error(errorMessage);
    }
  }, [providerInstance, activeLibrary, listItems]);

  // Templates laden mit der gleichen Logik wie Library-Komponente
  const loadTemplates = useCallback(async () => {
    if (!providerInstance || libraryStatus !== 'ready' || !activeLibrary) {
      console.log('[TemplateManagement] loadTemplates übersprungen:', {
        hasProvider: !!providerInstance,
        libraryStatus,
        hasActiveLibrary: !!activeLibrary
      });
      return;
    }

    try {
      setIsLoading(true);
      setError(null);

      console.log('[TemplateManagement] Starte Prompt-Loading:', {
        libraryId: activeLibrary.id,
        libraryPath: activeLibrary.path,
        providerName: providerInstance.name
      });

      // 1. Templates-Ordner finden oder erstellen
      const folderId = await ensureTemplatesFolder();
      setTemplatesFolderId(folderId);

      console.log('[TemplateManagement] Templates-Ordner gefunden/erstellt:', folderId);

      // 2. Alle Template-Dateien im Ordner auflisten
      const items = await listItems(folderId);
      const templateFiles = items.filter(item => 
        item.type === 'file' && 
        item.metadata.name.endsWith('.md')
      );

      console.log('[TemplateManagement] Prompt-Dateien gefunden:', templateFiles.length);

      // 3. Template-Inhalte laden
      const templatePromises = templateFiles.map(async (file) => {
        try {
          const { blob } = await providerInstance.getBinary(file.id);
          const content = await blob.text();
          const template = parseTemplateContent(content, file.metadata.name.replace('.md', ''));
          
          return {
            ...template,
            fileId: file.id,
            lastModified: typeof file.metadata.modifiedAt === 'string' 
              ? file.metadata.modifiedAt 
              : file.metadata.modifiedAt instanceof Date 
                ? file.metadata.modifiedAt.toISOString()
                : new Date().toISOString()
          } as Template;
        } catch (error) {
          console.error(`Fehler beim Parsen von ${file.metadata.name}:`, error);
          return null;
        }
      });

      const loadedTemplates = await Promise.all(templatePromises);
      const validTemplates = loadedTemplates.filter((t): t is Template => t !== null);
      
      setTemplates(validTemplates);
      
      console.log('[TemplateManagement] Prompts erfolgreich geladen:', validTemplates.length);
      
      if (validTemplates.length === 0) {
        toast({
          title: "Keine Prompts gefunden",
          description: "Erstellen Sie Ihren ersten Prompt im Verzeichnis '/templates'.",
        });
      }
    } catch (error) {
      console.error('Fehler beim Laden der Prompts:', {
        error: error instanceof Error ? {
          message: error.message,
          name: error.name,
          stack: error.stack?.split('\n').slice(0, 3)
        } : error,
        libraryId: activeLibrary?.id,
        libraryPath: activeLibrary?.path,
        providerName: providerInstance?.name
      });

      let errorMessage = 'Unbekannter Fehler beim Laden der Prompts';
      
      if (error instanceof Error) {
        errorMessage = error.message;
        
        // Spezifische Fehlermeldungen für häufige Probleme
        if (error.message.includes('Nicht authentifiziert')) {
          errorMessage = 'Bitte authentifizieren Sie sich bei Ihrem Cloud-Speicher, um Prompts zu laden.';
        } else if (error.message.includes('Bibliothek nicht gefunden')) {
          errorMessage = 'Die ausgewählte Bibliothek wurde nicht gefunden. Bitte überprüfen Sie die Bibliothekskonfiguration.';
        } else if (error.message.includes('Server-Fehler')) {
          errorMessage = 'Server-Fehler beim Laden der Prompts. Bitte überprüfen Sie, ob der Bibliothekspfad existiert und zugänglich ist.';
        } else if (error.message.includes('Keine aktive Bibliothek')) {
          errorMessage = 'Keine aktive Bibliothek verfügbar. Bitte wählen Sie eine Bibliothek aus.';
        }
      }
      
      setError(errorMessage);
      toast({
        title: "Fehler beim Laden der Prompts",
        description: errorMessage,
        variant: "destructive",
      });
    } finally {
      setIsLoading(false);
    }
  }, [providerInstance, libraryStatus, activeLibrary, listItems, setTemplates, setTemplatesFolderId, setIsLoading, setError, toast, ensureTemplatesFolder]);

  // Effect für Template Loading (wie Library-Komponente)
  useEffect(() => {
    const isReady = providerInstance && libraryStatus === 'ready' && activeLibrary
    
    if (!isReady) {
      return
    }

    // Templates laden wenn noch nicht geladen
    if (!templatesFolderId) {
      loadTemplates()
    }
  }, [providerInstance, libraryStatus, activeLibrary, templatesFolderId, loadTemplates])

  // Reset wenn sich die Library ändert
  useEffect(() => {
    setSelectedTemplateName(null)
    setTemplatesFolderId(null)
    setTemplates([])
    setError(null)
  }, [libraryStatus, setSelectedTemplateName, setTemplatesFolderId, setTemplates, setError])

  useEffect(() => {
    async function loadSelectedContext() {
      if (!providerInstance || !Array.isArray(selectedContextIds) || selectedContextIds.length === 0) {
        setSelectedContextMarkdown("")
        return
      }
      try {
        const parts: string[] = []
        for (const id of selectedContextIds) {
          const { blob } = await providerInstance.getBinary(id)
          const text = await blob.text()
          const name = Array.isArray(contextDocs) ? (contextDocs.find(d => d.id === id)?.name || id) : id
          const section = `\n\n---\nDatei: ${name}\n---\n\n${text}\n\n---\nEnde Datei: ${name}\n---\n`
          parts.push(section)
        }
        setSelectedContextMarkdown(parts.join("\n\n"))
      } catch (e) {
        console.error('Fehler beim Laden des Kontextes', e)
        setSelectedContextMarkdown("")
      }
    }
    void loadSelectedContext()
  }, [providerInstance, selectedContextIds, contextDocs])

  function parseTemplateContent(content: string, fileName: string): Template {
    // Template in drei Bereiche aufteilen
    const parts = content.split('--- systemprompt')
    
    let yamlFrontmatter = ""
    let markdownBody = ""
    let systemPrompt = ""
    
    if (parts.length >= 2) {
      const mainContent = parts[0].trim()
      systemPrompt = parts[1].trim()
      
      // YAML Frontmatter extrahieren
      const yamlMatch = mainContent.match(/^---\r?\n([\s\S]*?)\r?\n---\r?\n?([\s\S]*)$/)
      if (yamlMatch) {
        yamlFrontmatter = `---\n${yamlMatch[1]}\n---`
        markdownBody = yamlMatch[2].trim()
      } else {
        // Kein YAML Frontmatter gefunden
        markdownBody = mainContent
      }
    } else {
      // Kein Systemprompt gefunden
      const yamlMatch = content.match(/^---\r?\n([\s\S]*?)\r?\n---\r?\n?([\s\S]*)$/)
      if (yamlMatch) {
        yamlFrontmatter = `---\n${yamlMatch[1]}\n---`
        markdownBody = yamlMatch[2].trim()
      } else {
        markdownBody = content
      }
    }

    return {
      name: fileName,
      yamlFrontmatter,
      markdownBody,
      systemPrompt,
    }
  }

  function generateTemplateContent(values: TemplateFormValues): string {
    let content = ""
    
    // YAML Frontmatter hinzufügen
    if (values.yamlFrontmatter.trim()) {
      content += values.yamlFrontmatter + "\n\n"
    }
    
    // Markdown Body hinzufügen
    content += values.markdownBody
    
    // System Prompt hinzufügen
    if (values.systemPrompt.trim()) {
      content += "\n\n--- systemprompt\n" + values.systemPrompt
    }
    
    return content
  }

  async function onSubmit(data: TemplateFormValues) {
    if (!activeLibrary || !templatesFolderId || !providerInstance) {
      toast({
        title: "Fehler",
        description: "Keine aktive Bibliothek oder Templates-Ordner nicht gefunden.",
        variant: "destructive",
      })
      return
    }

    setIsSaving(true)
    try {
      const templateContent = generateTemplateContent(data)
      const fileName = `${data.name}.md`
      
      // Datei als Blob erstellen
      const blob = new Blob([templateContent], { type: 'text/markdown' })
      const file = new File([blob], fileName, { type: 'text/markdown' })
      
      // Datei hochladen
      await providerInstance.uploadFile(templatesFolderId, file)
      
      // Templates neu laden
      await loadTemplates()
      
      // Auswahl auf das neue Template setzen
      setSelectedTemplateName(data.name)
      
      toast({
        title: "Template gespeichert",
        description: `Template "${data.name}" wurde erfolgreich im Verzeichnis "/templates" gespeichert.`,
      })
    } catch (error) {
      console.error('Fehler beim Speichern des Templates:', error)
      toast({
        title: "Fehler beim Speichern",
        description: error instanceof Error ? error.message : "Unbekannter Fehler",
        variant: "destructive",
      })
    } finally {
      setIsSaving(false)
    }
  }

  async function renameCurrentTemplate() {
    const current = selectedTemplateName ? templates.find(t => t.name === selectedTemplateName) : null
    if (!current || !current.fileId || !providerInstance) return
    const newName = (window.prompt('Neuen Namen eingeben:', current.name) || '').trim()
    if (!newName || newName === current.name) return
    if (/[^a-zA-Z0-9._\- ]/.test(newName)) { toast({ title: 'Ungültiger Name', description: 'Nur Buchstaben, Zahlen, Leerzeichen, . _ - sind erlaubt.', variant: 'destructive' }); return }
    if (templates.some(t => t.name.toLowerCase() === newName.toLowerCase())) { toast({ title: 'Bereits vorhanden', description: 'Bitte anderen Namen wählen.', variant: 'destructive' }); return }
    try {
      await providerInstance.renameItem(current.fileId, `${newName}.md`)
      await loadTemplates()
      setSelectedTemplateName(newName)
      form.setValue('name', newName, { shouldDirty: false })
      toast({ title: 'Umbenannt', description: `${current.name} → ${newName}` })
    } catch (e) {
      toast({ title: 'Fehler beim Umbenennen', description: e instanceof Error ? e.message : 'Unbekannter Fehler', variant: 'destructive' })
    }
  }

  async function deleteTemplate(templateName: string) {
    if (!activeLibrary || !providerInstance) return

    try {
      const template = templates.find(t => t.name === templateName)
      if (!template?.fileId) {
        throw new Error("Template-Datei nicht gefunden")
      }

      // Datei löschen
      await providerInstance.deleteItem(template.fileId)

      // Templates neu laden
      await loadTemplates()
      
      if (selectedTemplateName === templateName) {
        setSelectedTemplateName(null)
        form.reset()
      }
      
      toast({
        title: "Template gelöscht",
        description: `Template "${templateName}" wurde erfolgreich gelöscht.`,
      })
    } catch (error) {
      console.error('Fehler beim Löschen des Templates:', error)
      toast({
        title: "Fehler beim Löschen",
        description: error instanceof Error ? error.message : "Unbekannter Fehler",
        variant: "destructive",
      })
    }
  }

  async function createNewTemplate() {
    const name = (window.prompt('Neuen Template‑Namen eingeben:') || '').trim()
    if (!name) return
    if (/[^a-zA-Z0-9._\- ]/.test(name)) { toast({ title: 'Ungültiger Name', description: 'Nur Buchstaben, Zahlen, Leerzeichen, . _ - sind erlaubt.', variant: 'destructive' }); return }
    if (templates.some(t => t.name.toLowerCase() === name.toLowerCase())) { toast({ title: 'Bereits vorhanden', description: 'Bitte anderen Namen wählen.', variant: 'destructive' }); return }
    if (!providerInstance) { toast({ title: 'Kein Provider' , variant: 'destructive' }); return }
    try {
      const folderId = await ensureTemplatesFolder()
      const values = getDefaultTemplateValues(name)
      const content = (values.yamlFrontmatter ? values.yamlFrontmatter + '\n\n' : '') + values.markdownBody + '\n\n--- systemprompt\n' + values.systemPrompt
      const file = new File([new Blob([content], { type: 'text/markdown' })], `${name}.md`, { type: 'text/markdown' })
      await providerInstance.uploadFile(folderId, file)
      await loadTemplates()
      setSelectedTemplateName(name)
      form.reset(values)
      toast({ title: 'Template angelegt', description: `"${name}" wurde erstellt.` })
    } catch (e) {
      toast({ title: 'Fehler beim Anlegen', description: e instanceof Error ? e.message : 'Unbekannter Fehler', variant: 'destructive' })
    }
  }

  function generatePreview(): string {
    const values = form.getValues()
    return generateTemplateContent(values)
  }

  async function testTemplate() {
    if (!activeLibrary) return

    setIsTesting(true)
    setTestResult(null)

    const values = form.getValues()
    const templateContent = generateTemplateContent(values)
    const sections: string[] = []
    if (selectedContextMarkdown.trim()) sections.push(selectedContextMarkdown.trim())
    if (freeText.trim()) sections.push(`---\nDatei: Freitext\n---\n\n${freeText.trim()}\n\n---\nEnde Datei: Freitext\n---`)
    const testText = sections.join("\n\n")

    try {
      const response = await fetch('/api/secretary/process-text', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/x-www-form-urlencoded',
          'X-Library-Id': activeLibrary.id,
        },
        body: new URLSearchParams({
          text: testText,
          template_content: templateContent,
          source_language: 'de',
          target_language: 'de',
        }),
      })

      if (!response.ok) {
        const errorData = await response.json()
        throw new Error(errorData.error || `HTTP ${response.status}: ${response.statusText}`)
      }

      const result = await response.json()
      const formattedResult = typeof result === 'string' ? result : JSON.stringify(result, null, 2)
      setTestResult(formattedResult)
      setRightTab('testen')

      toast({
        title: "Prompt-Test erfolgreich",
        description: "Der Prompt wurde erfolgreich mit dem gewählten Kontext verarbeitet.",
      })

      console.log('Prompt-Test Ergebnis:', result)
    } catch (error) {
      console.error('Fehler beim Prompt-Test:', error)
      const errorMessage = error instanceof Error ? error.message : "Unbekannter Fehler"
      setTestResult(`Fehler: ${errorMessage}`)
      setRightTab('testen')
      toast({
        title: "Prompt-Test fehlgeschlagen",
        description: errorMessage,
        variant: "destructive",
      })
    } finally {
      setIsTesting(false)
    }
  }

  async function ensurePromptTestsFolder(): Promise<string> {
    if (!providerInstance) throw new Error('Kein Provider verfügbar')
    const roots = await listItems('root')
    const found = roots.find(it => it.type === 'folder' && it.metadata.name === 'prompt-tests')
    if (found) return found.id
    const created = await providerInstance.createFolder('root', 'prompt-tests')
    return created.id
  }

  async function saveTestResult() {
    try {
      if (!providerInstance || !activeLibrary || !testResult) return
      const folderId = await ensurePromptTestsFolder()
      const name = `${selectedTemplateName || 'prompt'}-test-${new Date().toISOString().replace(/[:.]/g,'-')}.md`
      const blob = new Blob([testResult], { type: 'text/markdown' })
      const file = new File([blob], name, { type: 'text/markdown' })
      const item = await providerInstance.uploadFile(folderId, file)
      setResultSavedItemId(item.id)
      toast({ title: 'Ergebnis gespeichert', description: name })
    } catch (e) {
      toast({ title: 'Speichern fehlgeschlagen', description: e instanceof Error ? e.message : 'Unbekannter Fehler', variant: 'destructive' })
    }
  }

  // Render-Logik für verschiedene Status
  if (libraryStatus === "waitingForAuth") {
    return (
      <div className="flex flex-col items-center justify-center h-full text-muted-foreground">
        <span>Diese Bibliothek benötigt eine Authentifizierung.</span>
        <span className="text-sm mt-2">Bitte konfigurieren Sie die Bibliothek in den Einstellungen.</span>
      </div>
    )
  }
  
  if (libraryStatus !== "ready") {
    return (
      <div className="flex flex-col items-center justify-center h-full text-muted-foreground">
        <span>Lade Storage...</span>
      </div>
    )
  }

  if (!activeLibrary) {
    return (
      <div className="text-center text-muted-foreground">
        Bitte wählen Sie eine Bibliothek aus.
      </div>
    )
  }

  if (error) {
    return (
      <div className="text-center text-destructive">
        <p>Fehler beim Laden der Prompts:</p>
        <p className="text-sm">{error}</p>
        <Button 
          variant="outline" 
          className="mt-4"
          onClick={loadTemplates}
        >
          Erneut versuchen
        </Button>
      </div>
    )
  }

  return (
    <div className="space-y-6">

      {/* Kompakte Toolbar oben */}
      <div className="flex items-center gap-2">
        <Select value={selectedTemplateName || ''} onValueChange={(v) => { setSelectedTemplateName(v); form.setValue('name', v, { shouldDirty: false }) }} disabled={isLoading}>
          <SelectTrigger className="w-64">
            <SelectValue placeholder="Prompt auswählen..." />
          </SelectTrigger>
          <SelectContent>
            {templates.map((t) => (
              <SelectItem key={t.name} value={t.name}>{t.name}</SelectItem>
            ))}
          </SelectContent>
        </Select>
        <TooltipProvider>
          <Tooltip>
            <TooltipTrigger asChild>
              <Button variant="ghost" size="sm" className="h-8 w-8 p-0"><Info className="h-4 w-4" /></Button>
            </TooltipTrigger>
            <TooltipContent>
              <div className="flex items-center gap-2"><FolderOpen className="h-4 w-4" /><span>Ort: /templates in „{activeLibrary.label}“</span></div>
            </TooltipContent>
          </Tooltip>
        </TooltipProvider>
        <Button type="button" variant="outline" size="sm" onClick={createNewTemplate} disabled={isLoading}>Neu</Button>
        <Button type="button" variant="outline" size="sm" onClick={renameCurrentTemplate} disabled={!selectedTemplateName}>Umbenennen</Button>
        {selectedTemplateName && (
          <Button type="button" variant="destructive" size="sm" onClick={() => deleteTemplate(selectedTemplateName!)}>Löschen</Button>
        )}
      </div>

      <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
        <Card>
          <CardHeader>
            <CardTitle>Prompt Design</CardTitle>
            <CardDescription>
              Drei Bereiche: Aufgabe (was), Rollenanweisung (wie), Metadaten (Begleitinfos).
            </CardDescription>
          </CardHeader>
          <CardContent>
            <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-6">
              {/* Template-Name Feld entfernt (oben verwaltet) */}

              {previewMode ? (
                <div className="space-y-4">
                  <div className="flex items-center justify-between">
                    <h4 className="text-sm font-medium">Prompt-Vorschau</h4>
                    <Button
                      type="button"
                      variant="outline"
                      size="sm"
                      onClick={() => setPreviewMode(false)}
                    >
                      Bearbeiten
                    </Button>
                  </div>
                  <div className="border rounded-md p-4 bg-muted/50">
                    <pre className="text-sm whitespace-pre-wrap font-mono">
                      {generatePreview()}
                    </pre>
                  </div>
                </div>
              ) : (
                <StructuredTemplateEditor
                  markdownBody={form.watch('markdownBody')}
                  yamlFrontmatter={form.watch('yamlFrontmatter')}
                  systemPrompt={form.watch('systemPrompt')}
                  onChange={({ markdownBody, yamlFrontmatter, systemPrompt }) => {
                    form.setValue('markdownBody', markdownBody, { shouldDirty: true })
                    form.setValue('yamlFrontmatter', yamlFrontmatter, { shouldDirty: true })
                    form.setValue('systemPrompt', systemPrompt, { shouldDirty: true })
                  }}
                />
              )}

              <div className="flex justify-end gap-2">
                <Button
                  type="button"
                  variant="outline"
                  onClick={() => setPreviewMode(!previewMode)}
                >
                  <Eye className="h-4 w-4 mr-2" />
                  {previewMode ? "Bearbeiten" : "Vorschau"}
                </Button>
                <Button
                  type="submit"
                  disabled={isSaving || !form.formState.isDirty}
                >
                  {isSaving ? (
                    <>
                      <Loader2 className="h-4 w-4 mr-2 animate-spin" />
                      Wird gespeichert...
                    </>
                  ) : (
                    <>
                      <Save className="h-4 w-4 mr-2" />
                      Speichern
                    </>
                  )}
                </Button>
              </div>
            </form>
          </CardContent>
        </Card>

        <Card>
          <CardHeader>
            <CardTitle>Prompt testen</CardTitle>
            <CardDescription>
              Test mit Beispieltext. Nutzt Rollenanweisung, Aufgabe und Metadaten des Prompts.
            </CardDescription>
          </CardHeader>
          <CardContent>
            <Tabs value={rightTab} onValueChange={(v) => setRightTab(v as typeof rightTab)}>
              <TabsList className="grid grid-cols-3 w-full">
                <TabsTrigger value="kontext">Daten‑Kontext</TabsTrigger>
                <TabsTrigger value="preview">Prompt‑Vorschau</TabsTrigger>
                <TabsTrigger value="testen">Testen</TabsTrigger>
              </TabsList>

              <TabsContent value="kontext" className="space-y-4 mt-4">
                <div className="space-y-2">
                  <Label>Kontext-Texte</Label>
                  <div className="border rounded p-2 text-sm">
                    {Array.isArray(contextDocs) && contextDocs.length > 0 ? (
                      contextDocs.map(d => {
                        const checked = selectedContextIds.includes(d.id)
                        return (
                          <label key={d.id} className="flex items-center gap-2 py-1">
                            <Checkbox
                              checked={checked}
                              onCheckedChange={(v) => {
                                const isOn = v === true
                                setSelectedContextIds(prev => isOn ? [...prev, d.id] : prev.filter(x => x !== d.id))
                              }}
                            />
                            <span className="truncate">{d.name}</span>
                          </label>
                        )
                      })
                    ) : (
                      <div className="text-muted-foreground text-sm">Keine Kontext-Texte verfügbar</div>
                    )}
                  </div>
                </div>

                <div className="space-y-2">
                  <Label>Gewählter Kontext (Lesemodus)</Label>
                  <div className="border rounded-md">
                    <MarkdownPreview content={selectedContextMarkdown} />
                  </div>
                </div>

                <div className="space-y-2">
                  <Label>Freitext (optional)</Label>
                  <Textarea
                    value={freeText}
                    onChange={(e) => setFreeText(e.target.value)}
                    placeholder="Hier Text einkleben, um schnell zu testen"
                    className="min-h-[120px] font-mono text-sm"
                  />
                </div>
              </TabsContent>

              <TabsContent value="preview" className="space-y-4 mt-4">
                <div className="space-y-2">
                  <Label>Generierter Prompt (Markdown)</Label>
                  <div className="border rounded-md">
                    <MarkdownPreview content={generatePreview()} />
                  </div>
                </div>
               </TabsContent>

              <TabsContent value="testen" className="space-y-4 mt-4">
                <div className="flex gap-2 justify-end">
                  <Button 
                    variant="outline" 
                    size="sm"
                    onClick={testTemplate}
                    disabled={!selectedTemplateName || isTesting}
                  >
                    {isTesting ? (
                      <>
                        <Loader2 className="h-4 w-4 mr-2 animate-spin" />
                        Teste...
                      </>
                    ) : (
                      <>
                        <Play className="h-4 w-4 mr-2" />
                        Prompt testen
                      </>
                    )}
                  </Button>
                </div>
                <Tabs defaultValue="md">
                  <TabsList className="w-full grid grid-cols-2">
                    <TabsTrigger value="md">Markdown</TabsTrigger>
                    <TabsTrigger value="meta">Metadaten</TabsTrigger>
                  </TabsList>
                  <TabsContent value="md" className="space-y-2 mt-2">
                    <Label>Ergebnis</Label>
                    <div className="border rounded-md">
                      <MarkdownPreview content={testResult || ''} />
                    </div>
                    <div className="flex gap-2">
                      <Button type="button" onClick={saveTestResult} disabled={!testResult}>Speichern</Button>
                    </div>
                  </TabsContent>
                  <TabsContent value="meta" className="mt-2">
                    {activeLibrary && providerInstance && (testResult || resultSavedItemId) ? (
                      <JobReportTab
                        libraryId={activeLibrary.id}
                        fileId={resultSavedItemId || 'preview'}
                        provider={providerInstance}
                        sourceMode="frontmatter"
                        viewMode="metaOnly"
                        mdFileId={resultSavedItemId || undefined}
                        rawContent={testResult || undefined}
                      />
                    ) : (
                      <div className="text-sm text-muted-foreground">Kein Ergebnis vorhanden.</div>
                    )}
                  </TabsContent>
                </Tabs>
              </TabsContent>
            </Tabs>
          </CardContent>
        </Card>
      </div>
    </div>
  )
} 
```

- Eingebaut: Die Metadaten-/Kapitel-Ansicht im Tab „Testen → Metadaten“ nutzt jetzt sofort das aktuelle Testergebnis, ohne Speichern, via `rawContent`. Wenn du speicherst, wird automatisch die gespeicherte Datei verwendet.
- Testhinweis:
  - Rechts „Prompt‑Vorschau“ prüfen, dann „Testen“ ausführen.
  - In „Testen → Markdown“ siehst du den Output.
  - In „Testen → Metadaten“ siehst du die Frontmatter‑Metadaten/Kapitel aus dem Output; falls leer, bitte sicherstellen, dass das Ergebnis einen Frontmatter‑Block enthält (`--- ... ---`).

---

**User**

In welchem Format muss das Ergebnis übergeben werden. Wenn es eine Datei wäre, dann wäre es ja auch nur Text. Oder?
Momentan funktioniert es nicht:
formattedResult ist 
Prompt-Test Ergebnis: {
  "text": "---\ntags: Shopanwendungen Shopsysteme Shopify Plugin Shop-API Low-Budget-Shops Agenturleistung Daten-Feed Team Blau Performance-Analyse\nPersonen: Matthias Malknecht, Alex, Paul\nDatum: 2024-06-06\nOrt: \nType: Besprechung\n---\n# Diskussion über Shopanwendungen und Plugin-Integration für Low-Budget-Shops\n\n## Zusammenfassung:\nIn der Besprechung wurde erörtert, dass kleine Shops am besten auf populäre fertige Shopsysteme wie Shopify setzen sollten, um ohne große Agenturleistungen einen Online-Shop zu betreiben. Es wurde die Idee eines Community-Plugins diskutiert, das einfach in Shop-Templates eingebettet werden kann und die Konfiguration sauber an die Shop-API zurückgibt. Für größere Vollsortimenter wird hingegen eine professionelle Shop-Erlösung mit Agenturbetreuung empfohlen. Das Geschäftsmodell sieht vor, dass Kunden die Shopkosten selbst tragen und das 


---

**Cursor**

```typescriptreact
"use client"

import { useState, useEffect, useCallback } from "react"
import { useForm } from "react-hook-form"
import { zodResolver } from "@hookform/resolvers/zod"
import * as z from "zod"
import { Button } from "@/components/ui/button"
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card"
import { Label } from "@/components/ui/label"
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select"
import { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from "@/components/ui/tooltip"
import { StructuredTemplateEditor } from "@/components/templates/structured-template-editor"
import { useToast } from "@/hooks/use-toast"
import { Loader2, Save, Eye, Play, FolderOpen, Info } from "lucide-react"
import { useAtom, useAtomValue } from "jotai"
import { activeLibraryAtom, libraryStatusAtom } from "@/atoms/library-atom"
import { 
  templatesAtom, 
  selectedTemplateNameAtom, 
  selectedTemplateAtom,
  templatesFolderIdAtom,
  templateLoadingAtom,
  templateErrorAtom,
  type Template
} from "@/atoms/template-atom"
import { useStorage } from "@/contexts/storage-context"
import { templateContextDocsAtom } from '@/atoms/template-context-atom'
import { Checkbox } from "@/components/ui/checkbox"
import { MarkdownPreview } from "@/components/library/markdown-preview"
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs"
import { JobReportTab } from "@/components/library/job-report-tab"
import { Textarea } from "@/components/ui/textarea"

// Schema für Template-Daten
const templateSchema = z.object({
  name: z.string().min(1, "Prompt-Name ist erforderlich"),
  yamlFrontmatter: z.string(),
  markdownBody: z.string(),
  systemPrompt: z.string(),
})

type TemplateFormValues = z.infer<typeof templateSchema>

export function TemplateManagement() {
  const [previewMode, setPreviewMode] = useState(false)
  const [isSaving, setIsSaving] = useState(false)
  const [isTesting, setIsTesting] = useState(false)
  const [testResult, setTestResult] = useState<string | null>(null)
  const [selectedContextIds, setSelectedContextIds] = useState<string[]>([])
  const [selectedContextMarkdown, setSelectedContextMarkdown] = useState<string>("")
  const [rightTab, setRightTab] = useState<'kontext'|'preview'|'testen'>('kontext')
  const [resultSavedItemId, setResultSavedItemId] = useState<string | null>(null)
  const [freeText, setFreeText] = useState<string>("")
  const { toast } = useToast()

  // Atoms
  const [templates, setTemplates] = useAtom(templatesAtom)
  const [selectedTemplateName, setSelectedTemplateName] = useAtom(selectedTemplateNameAtom)
  const [selectedTemplate] = useAtom(selectedTemplateAtom)
  const [templatesFolderId, setTemplatesFolderId] = useAtom(templatesFolderIdAtom)
  const [isLoading, setIsLoading] = useAtom(templateLoadingAtom)
  const [error, setError] = useAtom(templateErrorAtom)

  // Library und Storage
  const activeLibrary = useAtomValue(activeLibraryAtom)
  const libraryStatus = useAtomValue(libraryStatusAtom)
  const { 
    provider: providerInstance, 
    listItems
  } = useStorage()
  const contextDocs = useAtomValue(templateContextDocsAtom)

  const form = useForm<TemplateFormValues>({
    resolver: zodResolver(templateSchema),
    defaultValues: {
      name: "",
      yamlFrontmatter: `---
title: {{title|Titel des Dokuments}}
tags: {{tags|Relevante Tags}}
date: {{date|Datum im Format yyyy-mm-dd}}
---`,
      markdownBody: `# {{title}}

## Zusammenfassung
{{summary|Kurze Zusammenfassung des Inhalts}}

## Details
{{details|Detaillierte Beschreibung}}`,
      systemPrompt: `You are a specialized assistant that processes and structures information clearly and concisely.

IMPORTANT: Your response must be a valid JSON object where each key corresponds to a template variable.`,
    },
  })

  // Helper zum Erzeugen von Default-Werten
  function getDefaultTemplateValues(name: string): TemplateFormValues {
    return {
      name,
      yamlFrontmatter: `---\n` +
        `title: {{title|Titel des Dokuments}}\n` +
        `tags: {{tags|Relevante Tags}}\n` +
        `date: {{date|Datum im Format yyyy-mm-dd}}\n` +
        `---`,
      markdownBody: `# {{title}}\n\n## Zusammenfassung\n{{summary|Kurze Zusammenfassung des Inhalts}}\n\n## Details\n{{details|Detaillierte Beschreibung}}`,
      systemPrompt: `You are a specialized assistant that processes and structures information clearly and concisely.\n\nIMPORTANT: Your response must be a valid JSON object where each key corresponds to a template variable.`,
    }
  }

  // Template-Daten laden wenn sich die Auswahl ändert
  useEffect(() => {
    if (selectedTemplate) {
      form.reset({
        name: selectedTemplate.name,
        yamlFrontmatter: selectedTemplate.yamlFrontmatter,
        markdownBody: selectedTemplate.markdownBody,
        systemPrompt: selectedTemplate.systemPrompt,
      })
    }
  }, [selectedTemplate, form])

  // Ordner-Erstellung/Suche memoisiert, damit als Dep verwendbar
  const ensureTemplatesFolder = useCallback(async (): Promise<string> => {
    if (!providerInstance || !activeLibrary) {
      throw new Error("Keine aktive Bibliothek oder Provider verfügbar");
    }

    try {
      console.log('[TemplateManagement] Suche nach Templates-Ordner...');
      const rootItems = await listItems('root');
      const templatesFolder = rootItems.find(item => 
        item.type === 'folder' && item.metadata.name === 'templates'
      );
      if (templatesFolder) {
        console.log('[TemplateManagement] Templates-Ordner gefunden:', templatesFolder.id);
        return templatesFolder.id;
      }
      console.log('[TemplateManagement] Templates-Ordner nicht gefunden, erstelle neuen...');
      const newFolder = await providerInstance.createFolder('root', 'templates');
      console.log('[TemplateManagement] Neuer Templates-Ordner erstellt:', newFolder.id);
      return newFolder.id;
    } catch (error) {
      console.error('Fehler beim Erstellen des Templates-Ordners:', {
        error: error instanceof Error ? {
          message: error.message,
          name: error.name,
          stack: error.stack?.split('\n').slice(0, 3)
        } : error,
        libraryId: activeLibrary?.id,
        libraryPath: activeLibrary?.path,
        providerName: providerInstance?.name
      });
      let errorMessage = 'Fehler beim Erstellen des Templates-Ordners';
      if (error instanceof Error) {
        if (error.message.includes('Nicht authentifiziert')) {
          errorMessage = 'Bitte authentifizieren Sie sich bei Ihrem Cloud-Speicher, um den Templates-Ordner zu erstellen.';
        } else if (error.message.includes('Keine Berechtigung')) {
          errorMessage = 'Keine Berechtigung zum Erstellen von Ordnern in der Bibliothek.';
        } else if (error.message.includes('Bibliothek nicht gefunden')) {
          errorMessage = 'Die ausgewählte Bibliothek wurde nicht gefunden.';
        } else {
          errorMessage = `Fehler beim Erstellen des Templates-Ordners: ${error.message}`;
        }
      }
      throw new Error(errorMessage);
    }
  }, [providerInstance, activeLibrary, listItems]);

  // Templates laden mit der gleichen Logik wie Library-Komponente
  const loadTemplates = useCallback(async () => {
    if (!providerInstance || libraryStatus !== 'ready' || !activeLibrary) {
      console.log('[TemplateManagement] loadTemplates übersprungen:', {
        hasProvider: !!providerInstance,
        libraryStatus,
        hasActiveLibrary: !!activeLibrary
      });
      return;
    }

    try {
      setIsLoading(true);
      setError(null);

      console.log('[TemplateManagement] Starte Prompt-Loading:', {
        libraryId: activeLibrary.id,
        libraryPath: activeLibrary.path,
        providerName: providerInstance.name
      });

      // 1. Templates-Ordner finden oder erstellen
      const folderId = await ensureTemplatesFolder();
      setTemplatesFolderId(folderId);

      console.log('[TemplateManagement] Templates-Ordner gefunden/erstellt:', folderId);

      // 2. Alle Template-Dateien im Ordner auflisten
      const items = await listItems(folderId);
      const templateFiles = items.filter(item => 
        item.type === 'file' && 
        item.metadata.name.endsWith('.md')
      );

      console.log('[TemplateManagement] Prompt-Dateien gefunden:', templateFiles.length);

      // 3. Template-Inhalte laden
      const templatePromises = templateFiles.map(async (file) => {
        try {
          const { blob } = await providerInstance.getBinary(file.id);
          const content = await blob.text();
          const template = parseTemplateContent(content, file.metadata.name.replace('.md', ''));
          
          return {
            ...template,
            fileId: file.id,
            lastModified: typeof file.metadata.modifiedAt === 'string' 
              ? file.metadata.modifiedAt 
              : file.metadata.modifiedAt instanceof Date 
                ? file.metadata.modifiedAt.toISOString()
                : new Date().toISOString()
          } as Template;
        } catch (error) {
          console.error(`Fehler beim Parsen von ${file.metadata.name}:`, error);
          return null;
        }
      });

      const loadedTemplates = await Promise.all(templatePromises);
      const validTemplates = loadedTemplates.filter((t): t is Template => t !== null);
      
      setTemplates(validTemplates);
      
      console.log('[TemplateManagement] Prompts erfolgreich geladen:', validTemplates.length);
      
      if (validTemplates.length === 0) {
        toast({
          title: "Keine Prompts gefunden",
          description: "Erstellen Sie Ihren ersten Prompt im Verzeichnis '/templates'.",
        });
      }
    } catch (error) {
      console.error('Fehler beim Laden der Prompts:', {
        error: error instanceof Error ? {
          message: error.message,
          name: error.name,
          stack: error.stack?.split('\n').slice(0, 3)
        } : error,
        libraryId: activeLibrary?.id,
        libraryPath: activeLibrary?.path,
        providerName: providerInstance?.name
      });

      let errorMessage = 'Unbekannter Fehler beim Laden der Prompts';
      
      if (error instanceof Error) {
        errorMessage = error.message;
        
        // Spezifische Fehlermeldungen für häufige Probleme
        if (error.message.includes('Nicht authentifiziert')) {
          errorMessage = 'Bitte authentifizieren Sie sich bei Ihrem Cloud-Speicher, um Prompts zu laden.';
        } else if (error.message.includes('Bibliothek nicht gefunden')) {
          errorMessage = 'Die ausgewählte Bibliothek wurde nicht gefunden. Bitte überprüfen Sie die Bibliothekskonfiguration.';
        } else if (error.message.includes('Server-Fehler')) {
          errorMessage = 'Server-Fehler beim Laden der Prompts. Bitte überprüfen Sie, ob der Bibliothekspfad existiert und zugänglich ist.';
        } else if (error.message.includes('Keine aktive Bibliothek')) {
          errorMessage = 'Keine aktive Bibliothek verfügbar. Bitte wählen Sie eine Bibliothek aus.';
        }
      }
      
      setError(errorMessage);
      toast({
        title: "Fehler beim Laden der Prompts",
        description: errorMessage,
        variant: "destructive",
      });
    } finally {
      setIsLoading(false);
    }
  }, [providerInstance, libraryStatus, activeLibrary, listItems, setTemplates, setTemplatesFolderId, setIsLoading, setError, toast, ensureTemplatesFolder]);

  // Effect für Template Loading (wie Library-Komponente)
  useEffect(() => {
    const isReady = providerInstance && libraryStatus === 'ready' && activeLibrary
    
    if (!isReady) {
      return
    }

    // Templates laden wenn noch nicht geladen
    if (!templatesFolderId) {
      loadTemplates()
    }
  }, [providerInstance, libraryStatus, activeLibrary, templatesFolderId, loadTemplates])

  // Reset wenn sich die Library ändert
  useEffect(() => {
    setSelectedTemplateName(null)
    setTemplatesFolderId(null)
    setTemplates([])
    setError(null)
  }, [libraryStatus, setSelectedTemplateName, setTemplatesFolderId, setTemplates, setError])

  useEffect(() => {
    async function loadSelectedContext() {
      if (!providerInstance || !Array.isArray(selectedContextIds) || selectedContextIds.length === 0) {
        setSelectedContextMarkdown("")
        return
      }
      try {
        const parts: string[] = []
        for (const id of selectedContextIds) {
          const { blob } = await providerInstance.getBinary(id)
          const text = await blob.text()
          const name = Array.isArray(contextDocs) ? (contextDocs.find(d => d.id === id)?.name || id) : id
          const section = `\n\n---\nDatei: ${name}\n---\n\n${text}\n\n---\nEnde Datei: ${name}\n---\n`
          parts.push(section)
        }
        setSelectedContextMarkdown(parts.join("\n\n"))
      } catch (e) {
        console.error('Fehler beim Laden des Kontextes', e)
        setSelectedContextMarkdown("")
      }
    }
    void loadSelectedContext()
  }, [providerInstance, selectedContextIds, contextDocs])

  function parseTemplateContent(content: string, fileName: string): Template {
    // Template in drei Bereiche aufteilen
    const parts = content.split('--- systemprompt')
    
    let yamlFrontmatter = ""
    let markdownBody = ""
    let systemPrompt = ""
    
    if (parts.length >= 2) {
      const mainContent = parts[0].trim()
      systemPrompt = parts[1].trim()
      
      // YAML Frontmatter extrahieren
      const yamlMatch = mainContent.match(/^---\r?\n([\s\S]*?)\r?\n---\r?\n?([\s\S]*)$/)
      if (yamlMatch) {
        yamlFrontmatter = `---\n${yamlMatch[1]}\n---`
        markdownBody = yamlMatch[2].trim()
      } else {
        // Kein YAML Frontmatter gefunden
        markdownBody = mainContent
      }
    } else {
      // Kein Systemprompt gefunden
      const yamlMatch = content.match(/^---\r?\n([\s\S]*?)\r?\n---\r?\n?([\s\S]*)$/)
      if (yamlMatch) {
        yamlFrontmatter = `---\n${yamlMatch[1]}\n---`
        markdownBody = yamlMatch[2].trim()
      } else {
        markdownBody = content
      }
    }

    return {
      name: fileName,
      yamlFrontmatter,
      markdownBody,
      systemPrompt,
    }
  }

  function generateTemplateContent(values: TemplateFormValues): string {
    let content = ""
    
    // YAML Frontmatter hinzufügen
    if (values.yamlFrontmatter.trim()) {
      content += values.yamlFrontmatter + "\n\n"
    }
    
    // Markdown Body hinzufügen
    content += values.markdownBody
    
    // System Prompt hinzufügen
    if (values.systemPrompt.trim()) {
      content += "\n\n--- systemprompt\n" + values.systemPrompt
    }
    
    return content
  }

  async function onSubmit(data: TemplateFormValues) {
    if (!activeLibrary || !templatesFolderId || !providerInstance) {
      toast({
        title: "Fehler",
        description: "Keine aktive Bibliothek oder Templates-Ordner nicht gefunden.",
        variant: "destructive",
      })
      return
    }

    setIsSaving(true)
    try {
      const templateContent = generateTemplateContent(data)
      const fileName = `${data.name}.md`
      
      // Datei als Blob erstellen
      const blob = new Blob([templateContent], { type: 'text/markdown' })
      const file = new File([blob], fileName, { type: 'text/markdown' })
      
      // Datei hochladen
      await providerInstance.uploadFile(templatesFolderId, file)
      
      // Templates neu laden
      await loadTemplates()
      
      // Auswahl auf das neue Template setzen
      setSelectedTemplateName(data.name)
      
      toast({
        title: "Template gespeichert",
        description: `Template "${data.name}" wurde erfolgreich im Verzeichnis "/templates" gespeichert.`,
      })
    } catch (error) {
      console.error('Fehler beim Speichern des Templates:', error)
      toast({
        title: "Fehler beim Speichern",
        description: error instanceof Error ? error.message : "Unbekannter Fehler",
        variant: "destructive",
      })
    } finally {
      setIsSaving(false)
    }
  }

  async function renameCurrentTemplate() {
    const current = selectedTemplateName ? templates.find(t => t.name === selectedTemplateName) : null
    if (!current || !current.fileId || !providerInstance) return
    const newName = (window.prompt('Neuen Namen eingeben:', current.name) || '').trim()
    if (!newName || newName === current.name) return
    if (/[^a-zA-Z0-9._\- ]/.test(newName)) { toast({ title: 'Ungültiger Name', description: 'Nur Buchstaben, Zahlen, Leerzeichen, . _ - sind erlaubt.', variant: 'destructive' }); return }
    if (templates.some(t => t.name.toLowerCase() === newName.toLowerCase())) { toast({ title: 'Bereits vorhanden', description: 'Bitte anderen Namen wählen.', variant: 'destructive' }); return }
    try {
      await providerInstance.renameItem(current.fileId, `${newName}.md`)
      await loadTemplates()
      setSelectedTemplateName(newName)
      form.setValue('name', newName, { shouldDirty: false })
      toast({ title: 'Umbenannt', description: `${current.name} → ${newName}` })
    } catch (e) {
      toast({ title: 'Fehler beim Umbenennen', description: e instanceof Error ? e.message : 'Unbekannter Fehler', variant: 'destructive' })
    }
  }

  async function deleteTemplate(templateName: string) {
    if (!activeLibrary || !providerInstance) return

    try {
      const template = templates.find(t => t.name === templateName)
      if (!template?.fileId) {
        throw new Error("Template-Datei nicht gefunden")
      }

      // Datei löschen
      await providerInstance.deleteItem(template.fileId)

      // Templates neu laden
      await loadTemplates()
      
      if (selectedTemplateName === templateName) {
        setSelectedTemplateName(null)
        form.reset()
      }
      
      toast({
        title: "Template gelöscht",
        description: `Template "${templateName}" wurde erfolgreich gelöscht.`,
      })
    } catch (error) {
      console.error('Fehler beim Löschen des Templates:', error)
      toast({
        title: "Fehler beim Löschen",
        description: error instanceof Error ? error.message : "Unbekannter Fehler",
        variant: "destructive",
      })
    }
  }

  async function createNewTemplate() {
    const name = (window.prompt('Neuen Template‑Namen eingeben:') || '').trim()
    if (!name) return
    if (/[^a-zA-Z0-9._\- ]/.test(name)) { toast({ title: 'Ungültiger Name', description: 'Nur Buchstaben, Zahlen, Leerzeichen, . _ - sind erlaubt.', variant: 'destructive' }); return }
    if (templates.some(t => t.name.toLowerCase() === name.toLowerCase())) { toast({ title: 'Bereits vorhanden', description: 'Bitte anderen Namen wählen.', variant: 'destructive' }); return }
    if (!providerInstance) { toast({ title: 'Kein Provider' , variant: 'destructive' }); return }
    try {
      const folderId = await ensureTemplatesFolder()
      const values = getDefaultTemplateValues(name)
      const content = (values.yamlFrontmatter ? values.yamlFrontmatter + '\n\n' : '') + values.markdownBody + '\n\n--- systemprompt\n' + values.systemPrompt
      const file = new File([new Blob([content], { type: 'text/markdown' })], `${name}.md`, { type: 'text/markdown' })
      await providerInstance.uploadFile(folderId, file)
      await loadTemplates()
      setSelectedTemplateName(name)
      form.reset(values)
      toast({ title: 'Template angelegt', description: `"${name}" wurde erstellt.` })
    } catch (e) {
      toast({ title: 'Fehler beim Anlegen', description: e instanceof Error ? e.message : 'Unbekannter Fehler', variant: 'destructive' })
    }
  }

  function generatePreview(): string {
    const values = form.getValues()
    return generateTemplateContent(values)
  }

  async function testTemplate() {
    if (!activeLibrary) return

    setIsTesting(true)
    setTestResult(null)

    const values = form.getValues()
    const templateContent = generateTemplateContent(values)
    const sections: string[] = []
    if (selectedContextMarkdown.trim()) sections.push(selectedContextMarkdown.trim())
    if (freeText.trim()) sections.push(`---\nDatei: Freitext\n---\n\n${freeText.trim()}\n\n---\nEnde Datei: Freitext\n---`)
    const testText = sections.join("\n\n")

    const pickMarkdown = (result: unknown): string => {
      if (typeof result === 'string') return result
      if (result && typeof result === 'object') {
        const obj = result as Record<string, unknown>
        const directCandidates = ['text','markdown','content','output'] as const
        for (const k of directCandidates) {
          const v = obj[k]
          if (typeof v === 'string') return v
        }
        // verschachtelte Felder prüfen
        const nested = obj['data']
        if (nested && typeof nested === 'object') {
          const nobj = nested as Record<string, unknown>
          for (const k of directCandidates) {
            const v = nobj[k]
            if (typeof v === 'string') return v
          }
        }
      }
      return JSON.stringify(result, null, 2)
    }

    try {
      const response = await fetch('/api/secretary/process-text', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/x-www-form-urlencoded',
          'X-Library-Id': activeLibrary.id,
        },
        body: new URLSearchParams({
          text: testText,
          template_content: templateContent,
          source_language: 'de',
          target_language: 'de',
        }),
      })

      if (!response.ok) {
        const errorData = await response.json()
        throw new Error(errorData.error || `HTTP ${response.status}: ${response.statusText}`)
      }

      const result = await response.json()
      const formattedResult = pickMarkdown(result)
      console.log('Prompt-Test Ergebnis:', formattedResult)
      
      setTestResult(formattedResult)
      setRightTab('testen')

      toast({
        title: "Prompt-Test erfolgreich",
        description: "Der Prompt wurde erfolgreich mit dem gewählten Kontext verarbeitet.",
      })

      console.log('Prompt-Test Ergebnis (roh):', result)
    } catch (error) {
      console.error('Fehler beim Prompt-Test:', error)
      const errorMessage = error instanceof Error ? error.message : "Unbekannter Fehler"
      setTestResult(`Fehler: ${errorMessage}`)
      setRightTab('testen')
      toast({
        title: "Prompt-Test fehlgeschlagen",
        description: errorMessage,
        variant: "destructive",
      })
    } finally {
      setIsTesting(false)
    }
  }

  async function ensurePromptTestsFolder(): Promise<string> {
    if (!providerInstance) throw new Error('Kein Provider verfügbar')
    const roots = await listItems('root')
    const found = roots.find(it => it.type === 'folder' && it.metadata.name === 'prompt-tests')
    if (found) return found.id
    const created = await providerInstance.createFolder('root', 'prompt-tests')
    return created.id
  }

  async function saveTestResult() {
    try {
      if (!providerInstance || !activeLibrary || !testResult) return
      const folderId = await ensurePromptTestsFolder()
      const name = `${selectedTemplateName || 'prompt'}-test-${new Date().toISOString().replace(/[:.]/g,'-')}.md`
      const blob = new Blob([testResult], { type: 'text/markdown' })
      const file = new File([blob], name, { type: 'text/markdown' })
      const item = await providerInstance.uploadFile(folderId, file)
      setResultSavedItemId(item.id)
      toast({ title: 'Ergebnis gespeichert', description: name })
    } catch (e) {
      toast({ title: 'Speichern fehlgeschlagen', description: e instanceof Error ? e.message : 'Unbekannter Fehler', variant: 'destructive' })
    }
  }

  // Render-Logik für verschiedene Status
  if (libraryStatus === "waitingForAuth") {
    return (
      <div className="flex flex-col items-center justify-center h-full text-muted-foreground">
        <span>Diese Bibliothek benötigt eine Authentifizierung.</span>
        <span className="text-sm mt-2">Bitte konfigurieren Sie die Bibliothek in den Einstellungen.</span>
      </div>
    )
  }
  
  if (libraryStatus !== "ready") {
    return (
      <div className="flex flex-col items-center justify-center h-full text-muted-foreground">
        <span>Lade Storage...</span>
      </div>
    )
  }

  if (!activeLibrary) {
    return (
      <div className="text-center text-muted-foreground">
        Bitte wählen Sie eine Bibliothek aus.
      </div>
    )
  }

  if (error) {
    return (
      <div className="text-center text-destructive">
        <p>Fehler beim Laden der Prompts:</p>
        <p className="text-sm">{error}</p>
        <Button 
          variant="outline" 
          className="mt-4"
          onClick={loadTemplates}
        >
          Erneut versuchen
        </Button>
      </div>
    )
  }

  return (
    <div className="space-y-6">

      {/* Kompakte Toolbar oben */}
      <div className="flex items-center gap-2">
        <Select value={selectedTemplateName || ''} onValueChange={(v) => { setSelectedTemplateName(v); form.setValue('name', v, { shouldDirty: false }) }} disabled={isLoading}>
          <SelectTrigger className="w-64">
            <SelectValue placeholder="Prompt auswählen..." />
          </SelectTrigger>
          <SelectContent>
            {templates.map((t) => (
              <SelectItem key={t.name} value={t.name}>{t.name}</SelectItem>
            ))}
          </SelectContent>
        </Select>
        <TooltipProvider>
          <Tooltip>
            <TooltipTrigger asChild>
              <Button variant="ghost" size="sm" className="h-8 w-8 p-0"><Info className="h-4 w-4" /></Button>
            </TooltipTrigger>
            <TooltipContent>
              <div className="flex items-center gap-2"><FolderOpen className="h-4 w-4" /><span>Ort: /templates in „{activeLibrary.label}“</span></div>
            </TooltipContent>
          </Tooltip>
        </TooltipProvider>
        <Button type="button" variant="outline" size="sm" onClick={createNewTemplate} disabled={isLoading}>Neu</Button>
        <Button type="button" variant="outline" size="sm" onClick={renameCurrentTemplate} disabled={!selectedTemplateName}>Umbenennen</Button>
        {selectedTemplateName && (
          <Button type="button" variant="destructive" size="sm" onClick={() => deleteTemplate(selectedTemplateName!)}>Löschen</Button>
        )}
      </div>

      <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
        <Card>
          <CardHeader>
            <CardTitle>Prompt Design</CardTitle>
            <CardDescription>
              Drei Bereiche: Aufgabe (was), Rollenanweisung (wie), Metadaten (Begleitinfos).
            </CardDescription>
          </CardHeader>
          <CardContent>
            <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-6">
              {/* Template-Name Feld entfernt (oben verwaltet) */}

              {previewMode ? (
                <div className="space-y-4">
                  <div className="flex items-center justify-between">
                    <h4 className="text-sm font-medium">Prompt-Vorschau</h4>
                    <Button
                      type="button"
                      variant="outline"
                      size="sm"
                      onClick={() => setPreviewMode(false)}
                    >
                      Bearbeiten
                    </Button>
                  </div>
                  <div className="border rounded-md p-4 bg-muted/50">
                    <pre className="text-sm whitespace-pre-wrap font-mono">
                      {generatePreview()}
                    </pre>
                  </div>
                </div>
              ) : (
                <StructuredTemplateEditor
                  markdownBody={form.watch('markdownBody')}
                  yamlFrontmatter={form.watch('yamlFrontmatter')}
                  systemPrompt={form.watch('systemPrompt')}
                  onChange={({ markdownBody, yamlFrontmatter, systemPrompt }) => {
                    form.setValue('markdownBody', markdownBody, { shouldDirty: true })
                    form.setValue('yamlFrontmatter', yamlFrontmatter, { shouldDirty: true })
                    form.setValue('systemPrompt', systemPrompt, { shouldDirty: true })
                  }}
                />
              )}

              <div className="flex justify-end gap-2">
                <Button
                  type="button"
                  variant="outline"
                  onClick={() => setPreviewMode(!previewMode)}
                >
                  <Eye className="h-4 w-4 mr-2" />
                  {previewMode ? "Bearbeiten" : "Vorschau"}
                </Button>
                <Button
                  type="submit"
                  disabled={isSaving || !form.formState.isDirty}
                >
                  {isSaving ? (
                    <>
                      <Loader2 className="h-4 w-4 mr-2 animate-spin" />
                      Wird gespeichert...
                    </>
                  ) : (
                    <>
                      <Save className="h-4 w-4 mr-2" />
                      Speichern
                    </>
                  )}
                </Button>
              </div>
            </form>
          </CardContent>
        </Card>

        <Card>
          <CardHeader>
            <CardTitle>Prompt testen</CardTitle>
            <CardDescription>
              Test mit Beispieltext. Nutzt Rollenanweisung, Aufgabe und Metadaten des Prompts.
            </CardDescription>
          </CardHeader>
          <CardContent>
            <Tabs value={rightTab} onValueChange={(v) => setRightTab(v as typeof rightTab)}>
              <TabsList className="grid grid-cols-3 w-full">
                <TabsTrigger value="kontext">Daten‑Kontext</TabsTrigger>
                <TabsTrigger value="preview">Prompt‑Vorschau</TabsTrigger>
                <TabsTrigger value="testen">Testen</TabsTrigger>
              </TabsList>

              <TabsContent value="kontext" className="space-y-4 mt-4">
                <div className="space-y-2">
                  <Label>Kontext-Texte</Label>
                  <div className="border rounded p-2 text-sm">
                    {Array.isArray(contextDocs) && contextDocs.length > 0 ? (
                      contextDocs.map(d => {
                        const checked = selectedContextIds.includes(d.id)
                        return (
                          <label key={d.id} className="flex items-center gap-2 py-1">
                            <Checkbox
                              checked={checked}
                              onCheckedChange={(v) => {
                                const isOn = v === true
                                setSelectedContextIds(prev => isOn ? [...prev, d.id] : prev.filter(x => x !== d.id))
                              }}
                            />
                            <span className="truncate">{d.name}</span>
                          </label>
                        )
                      })
                    ) : (
                      <div className="text-muted-foreground text-sm">Keine Kontext-Texte verfügbar</div>
                    )}
                  </div>
                </div>

                <div className="space-y-2">
                  <Label>Gewählter Kontext (Lesemodus)</Label>
                  <div className="border rounded-md">
                    <MarkdownPreview content={selectedContextMarkdown} />
                  </div>
                </div>

                <div className="space-y-2">
                  <Label>Freitext (optional)</Label>
                  <Textarea
                    value={freeText}
                    onChange={(e) => setFreeText(e.target.value)}
                    placeholder="Hier Text einkleben, um schnell zu testen"
                    className="min-h-[120px] font-mono text-sm"
                  />
                </div>
              </TabsContent>

              <TabsContent value="preview" className="space-y-4 mt-4">
                <div className="space-y-2">
                  <Label>Generierter Prompt (Markdown)</Label>
                  <div className="border rounded-md">
                    <MarkdownPreview content={generatePreview()} />
                  </div>
                </div>
               </TabsContent>

              <TabsContent value="testen" className="space-y-4 mt-4">
                <div className="flex gap-2 justify-end">
                  <Button 
                    variant="outline" 
                    size="sm"
                    onClick={testTemplate}
                    disabled={!selectedTemplateName || isTesting}
                  >
                    {isTesting ? (
                      <>
                        <Loader2 className="h-4 w-4 mr-2 animate-spin" />
                        Teste...
                      </>
                    ) : (
                      <>
                        <Play className="h-4 w-4 mr-2" />
                        Prompt testen
                      </>
                    )}
                  </Button>
                </div>
                <Tabs defaultValue="md">
                  <TabsList className="w-full grid grid-cols-2">
                    <TabsTrigger value="md">Markdown</TabsTrigger>
                    <TabsTrigger value="meta">Metadaten</TabsTrigger>
                  </TabsList>
                  <TabsContent value="md" className="space-y-2 mt-2">
                    <Label>Ergebnis</Label>
                    <div className="border rounded-md">
                      <MarkdownPreview content={testResult || ''} />
                    </div>
                    <div className="flex gap-2">
                      <Button type="button" onClick={saveTestResult} disabled={!testResult}>Speichern</Button>
                    </div>
                  </TabsContent>
                  <TabsContent value="meta" className="mt-2">
                    {activeLibrary && providerInstance && (testResult || resultSavedItemId) ? (
                      <JobReportTab
                        libraryId={activeLibrary.id}
                        fileId={resultSavedItemId || 'preview'}
                        provider={providerInstance}
                        sourceMode="frontmatter"
                        viewMode="metaOnly"
                        mdFileId={resultSavedItemId || undefined}
                        rawContent={testResult || undefined}
                      />
                    ) : (
                      <div className="text-sm text-muted-foreground">Kein Ergebnis vorhanden.</div>
                    )}
                  </TabsContent>
                </Tabs>
              </TabsContent>
            </Tabs>
          </CardContent>
        </Card>
      </div>
    </div>
  )
} 
```

- Erwartetes Format fürs Ergebnis: Ein Markdown-/Text-String. Viele Backends liefern ihn unter text, markdown, content oder data.text.
- Anpassung umgesetzt: Wir extrahieren jetzt automatisch den ersten passenden String:
  - Prüfreihenfolge: result.text → result.markdown → result.content → result.output → result.data.text/markdown/content/output.
  - Fallback nur noch JSON.stringify, wenn kein String-Feld vorhanden ist.

Dadurch wird dein Beispiel korrekt erkannt: Aus dem JSON wird das Feld text genommen und direkt angezeigt.

---

**User**

Kein Fallback für template, Entweder wird das Template explizit übergeben oder TemplateContact als String, wenn beides Null dann einen Fehler generieren.

---

**Cursor**

```typescript
import { NextRequest, NextResponse } from 'next/server';
import { getAuth } from '@clerk/nextjs/server';
import { env } from 'process';

export async function POST(request: NextRequest) {
  try {
    console.log('[process-text] API-Route aufgerufen');
    
    // Authentifizierung prüfen
    const { userId } = getAuth(request);
    if (!userId) {
      console.error('[process-text] Nicht authentifiziert');
      return NextResponse.json(
        { error: 'Nicht authentifiziert' },
        { status: 401 }
      );
    }

    console.log('[process-text] Authentifiziert als:', userId);

    // Alle Request-Header protokollieren
    const headerObj: Record<string, string> = {};
    request.headers.forEach((value, key) => {
      headerObj[key] = value;
    });
    
    // FormData aus dem Request holen
    const formData = await request.formData();
    const formDataKeys: string[] = [];
    const formDataValues: Record<string, string> = {};
    formData.forEach((value, key) => {
      formDataKeys.push(key);
      formDataValues[key] = typeof value === 'string' ? value.substring(0, 100) : String(value);
    });
    console.log('[process-text] FormData erhalten mit Feldern:', formDataKeys);
    console.log('[process-text] FormData Werte:', formDataValues);

    // Text-Parameter validieren
    const text = (formData.get('text') as string) || '';
    if (!text || text.trim().length === 0) {
      console.error('[process-text] Kein Text-Parameter gefunden oder Text ist leer');
      return NextResponse.json(
        { error: 'Text-Parameter fehlt oder ist leer' },
        { status: 400 }
      );
    }

    // Sprachen
    const targetLanguage = (formData.get('target_language') as string) || (formData.get('targetLanguage') as string) || 'de';
    const sourceLanguage = (formData.get('source_language') as string) || (formData.get('sourceLanguage') as string) || '';

    // Template-Name und Content (beide optional, aber mindestens eins MUSS vorhanden sein)
    const templateName = ((formData.get('template') as string) || '').trim();
    const templateContent = ((formData.get('template_content') as string) || (formData.get('templateContent') as string) || '').trim();

    if (!templateName && !templateContent) {
      console.error('[process-text] Weder template noch template_content übergeben');
      return NextResponse.json(
        { error: 'Erforderlich: Entweder template (Name) ODER template_content (String) übergeben' },
        { status: 400 }
      );
    }

    const isTemplateContent = templateContent.length > 0;

    console.log('[process-text] Request-Daten für Secretary Service:', {
      textLength: text.length,
      target_language: targetLanguage,
      template: isTemplateContent ? 'CUSTOM_CONTENT' : templateName,
      templateContentLength: isTemplateContent ? templateContent.length : 0,
      source_language: sourceLanguage || 'nicht angegeben'
    });

    const secretaryServiceUrl = env.SECRETARY_SERVICE_URL;
    
    // FormData für Secretary Service erstellen
    const secretaryFormData = new FormData();
    secretaryFormData.append('text', text);
    secretaryFormData.append('target_language', targetLanguage);
    
    // Template-Parameter: entweder Name oder Content
    if (isTemplateContent) {
      secretaryFormData.append('template_content', templateContent);
    } else {
      secretaryFormData.append('template', templateName);
    }
    
    secretaryFormData.append('use_cache', 'false');
    
    if (sourceLanguage) {
      secretaryFormData.append('source_language', sourceLanguage);
    }
    
    // Anfrage an den Secretary Service senden
    const response = await fetch(`${secretaryServiceUrl}/transformer/template`, {
      method: 'POST',
      body: secretaryFormData,
      headers: (() => {
        const h: Record<string, string> = { 'Accept': 'application/json' };
        const apiKey = process.env.SECRETARY_SERVICE_API_KEY;
        if (apiKey) { h['Authorization'] = `Bearer ${apiKey}`; h['X-Service-Token'] = apiKey; }
        return h;
      })(),
    });

    console.log('[process-text] Secretary Service Antwort:', {
      status: response.status,
      statusText: response.statusText
    });

    const data = await response.json();
    console.log('[process-text] Antwortdaten:', JSON.stringify(data).substring(0, 100) + '...');

    if (!response.ok) {
      console.error('[process-text] Secretary Service Fehler:', data);
      return NextResponse.json(
        { error: data.error || 'Fehler beim Transformieren der text-Datei' },
        { status: response.status }
      );
    }

    return NextResponse.json(data.data);
  } catch (error) {
    console.error('[process-text] Secretary Service Error:', error);
    return NextResponse.json(
      { error: 'Fehler bei der Verbindung zum Secretary Service' },
      { status: 500 }
    );
  }
} 
```

- API angepasst: Kein Fallback mehr auf Standard-Template.
  - Erforderlich: Entweder template (Name) ODER template_content (String).
  - Wenn beides fehlt oder leer ist, Rückgabe 400 mit Fehlertext.

- Kompatibilität:
  - Akzeptiert snake_case und camelCase: target_language/source_language und targetLanguage/sourceLanguage; template_content und templateContent.

Damit entspricht die Route deiner Vorgabe und vermeidet implizite Defaults.

---

**User**

Ja, das Ergebnis schaut leider anders aus in die Ansicht Markdown und Metadaten am Ende, als wenn ich dasselbe Template über einen Job bearbeiten würde mit derselben Datenkomplex. Werden wir mal das Ergebnis, wenn ich jetzt unten speicher, wo wird es dann gespeichert, so dass ich es mit dem normalen generierten Dokument vergleichen kann.

---

**Cursor**

- Speicherort: Im aktiven Library‑Root unter dem Ordner prompt-tests.
- Dateiname: <PromptName>-test-<ISO‑Zeitstempel>.md, z. B. besprechung-test-2025-09-15T12-34-56-789Z.md.
- Vergleich: Nach dem Speichern zeigt der Reiter Testen → Metadaten bereits diese gespeicherte Datei (Frontmatter/Kapitel). Für einen 1:1‑Vergleich mit einem „normal“ generierten Dokument kannst du beide Markdown‑Dateien in der Library öffnen oder deren Frontmatter in zwei JobReport‑Ansichten parallel vergleichen.

Wenn du einen anderen Ordner wünschst (z. B. /tests/prompts), sag kurz Bescheid – ich passe den Zielpfad an.

---

**User**

@pdfanalyse-test-2025-09-15T09-41-25-317Z.md Ich habe jetzt hier ein Ergebnis aus diesem Testlauf mit einem Template und komischerweise wird es in diesem Markdown und Metadaten-Review, den wir auch beim Report verwenden, bei diesem Job-Report unterschiedlich angezeigt. Warum? Was kann sein, ob ich jetzt diesen Text als Parameter übergebe oder von der Datei lade? Wird es unterschiedlich interpretiert? Haben wir das doppelt programmiert? Ist der Parser nicht derselbe?

---

**Cursor**

Kurzantwort:
- Ja, es wurden bisher unterschiedliche Pfade/Parser genutzt.
- Unterschiede kommen von:
  - Markdown-Tab: Frontmatter wird absichtlich entfernt (Preview).
  - JobReport-Tab: Frontmatter wird geparst – bisher gab es zwei leicht unterschiedliche Parser (Datei vs. Rohtext) und strenge JSON-Parsing-Heuristiken.
  - Dein Frontmatter enthält JSON‑ähnliche Arrays/Objekte mit einfachen Anführungszeichen; unser Parser versucht JSON.parse und scheitert dabei teils.

Was tun (präzise Anpassungen):
- Einheitlich einen Parser verwenden: `extractFrontmatterBlock` + `parseFrontmatterKeyValues` aus `@/lib/markdown/frontmatter` in `job-report-tab.tsx` für Datei und `rawContent`.
- Für Felder wie `chapters`/`toc` eine tolerante Normalisierung vor dem JSON‑Parse: einfache Anführungszeichen in Strings/Keys in doppelte überführen; wenn Parse fehlschlägt, den Rohwert als String anzeigen statt zu verwerfen.
- Für visuelle Konsistenz: Im Test-Tab immer `sourceMode='frontmatter'` (so wie jetzt), und beim Vergleich mit „normalen“ Jobs ebenfalls wahlweise Frontmatter‑only statt „merged“, damit die Ansicht gleich ist.

Format des Ergebnisses:
- Für die Anzeige erwarten wir einen String mit optionalem Frontmatter‑Block `--- ... ---` (+ Markdown-Körper). Wir extrahieren aus dem API‑JSON bevorzugt `text`/`markdown`/`content`/`output` (oder `data.*`).

---

**User**

Der Test wird ja genau deswegen gemacht, um garantiert dasselbe Ergebnis zu testen. Ich möchte keine Toleranz beim JSON-Parser. Wenn wir Chapter zum Beispiel auswerten und es hat nicht das gewünschte Format, dann eine Fehlermeldung anzeigen. Einfach so, je mehr Informationen ich bekomme, was nicht genauso abläuft wie normal, muss ich als Fehler erkennen. Deswegen muss es dasselbe Parser sein beim Testen als in der konkreten Umgebung. Bei der Verarbeitung der Jobs. Null tolerance.

---

**Cursor**

```typescriptreact
"use client";

import { useEffect, useState } from 'react'
import { UILogger } from '@/lib/debug/logger'
import type { StorageProvider } from '@/lib/storage/types'

interface JobReportTabProps {
  libraryId: string
  fileId: string
  fileName?: string
  provider?: StorageProvider | null
  // Quelle der Metadaten steuern: 'merged' = cumulativeMeta + Frontmatter (Standard),
  // 'frontmatter' = ausschließlich Frontmatter aus Markdown anzeigen
  sourceMode?: 'merged' | 'frontmatter'
  // Darstellungsmodus: 'full' zeigt Kopf/Steps/Logs/Parameter; 'metaOnly' zeigt nur Metadaten/Kapitel/TOC
  viewMode?: 'full' | 'metaOnly'
  // Optional explizite Markdown-Datei-ID (Shadow‑Twin). Überschreibt auto-Erkennung.
  mdFileId?: string | null
  // Optionaler Callback zum Scroll-Sync in die Markdown-Vorschau
  onJumpTo?: (args: { page?: number | string; evidence?: string }) => void
  // NEU: Rohinhalt (Markdown). Wenn gesetzt und sourceMode='frontmatter', wird direkt dieser Text geparst (ohne Datei/JOB).
  rawContent?: string
}

interface JobDto {
  jobId: string
  status: string
  operation: string
  worker: string
  job_type: string
  updatedAt: string
  createdAt: string
  correlation?: { source?: { itemId?: string; name?: string } }
  parameters?: Record<string, unknown>
  steps?: Array<{ name: string; status: string; startedAt?: string; endedAt?: string; error?: { message: string }; details?: { skipped?: boolean } }>
  ingestion?: { vectorsUpserted?: number; index?: string; upsertAt?: string }
  result?: { savedItemId?: string }
  logs?: Array<{ timestamp: string; phase?: string; message?: string; progress?: number }>
  cumulativeMeta?: Record<string, unknown>
}

export function JobReportTab({ libraryId, fileId, fileName, provider, sourceMode = 'merged', viewMode = 'full', mdFileId, onJumpTo, rawContent }: JobReportTabProps) {
  const [loading, setLoading] = useState(false)
  const [error, setError] = useState<string | null>(null)
  const [job, setJob] = useState<JobDto | null>(null)
  const [templateFields, setTemplateFields] = useState<string[] | null>(null)
  const [frontmatterMeta, setFrontmatterMeta] = useState<Record<string, unknown> | null>(null)
  const [section, setSection] = useState<'meta' | 'chapters'>('meta')
  const [parseErrors, setParseErrors] = useState<string[]>([])

  useEffect(() => {
    let cancelled = false
    async function run() {
      try {
        // Wenn wir Rohinhalt haben und nur Frontmatter zeigen, brauchen wir keine Job-Suche
        if (sourceMode === 'frontmatter' && typeof rawContent === 'string' && rawContent.length > 0) {
          setJob(null)
          setLoading(false)
          setError(null)
          return
        }
        setLoading(true)
        setError(null)
        UILogger.info('JobReportTab', 'Start Job-Suche', { libraryId, fileId })
        // 1) Versuche Job über result.savedItemId (Shadow‑Twin) zu finden
        const byResultUrl = new URL(`/api/external/jobs`, window.location.origin)
        byResultUrl.searchParams.set('byResultItemId', fileId)
        UILogger.debug('JobReportTab', 'Request byResultItemId', { url: byResultUrl.toString() })
        let res = await fetch(byResultUrl.toString(), { cache: 'no-store' })
        let data = await res.json()
        if (!res.ok) throw new Error(typeof data?.error === 'string' ? data.error : 'Job-Suche fehlgeschlagen')
        let j: JobDto | null = Array.isArray(data?.items) && data.items.length > 0 ? (data.items[0] as JobDto) : null
        UILogger.debug('JobReportTab', 'Result byResultItemId', { count: Array.isArray(data?.items) ? data.items.length : 0 })

        // 2) Fallback: über correlation.source.itemId (Originaldatei)
        if (!j) {
          const bySourceUrl = new URL(`/api/external/jobs`, window.location.origin)
          bySourceUrl.searchParams.set('bySourceItemId', fileId)
          bySourceUrl.searchParams.set('libraryId', libraryId)
          UILogger.debug('JobReportTab', 'Request bySourceItemId', { url: bySourceUrl.toString() })
          res = await fetch(bySourceUrl.toString(), { cache: 'no-store' })
          data = await res.json()
          if (!res.ok) throw new Error(typeof data?.error === 'string' ? data.error : 'Job-Suche (Quelle) fehlgeschlagen')
          j = Array.isArray(data?.items) && data.items.length > 0 ? (data.items[0] as JobDto) : null
          UILogger.debug('JobReportTab', 'Result bySourceItemId', { count: Array.isArray(data?.items) ? data.items.length : 0 })
        }

        // 3) Fallback: über correlation.source.name (Dateiname der Quelle)
        if (!j) {
          const byNameUrl = new URL(`/api/external/jobs`, window.location.origin)
          // Wenn wir den tatsächlichen Dateinamen kennen, verwende ihn.
          // Für Shadow‑Twins (z. B. name.de.md) versuche das Basis‑PDF (name.pdf).
          let candidate = (fileName && typeof fileName === 'string') ? fileName : (fileId.includes('/') ? (fileId.split('/').pop() as string) : fileId)
          const parts = candidate.split('.')
          if (parts.length >= 3) {
            const ext1 = parts[parts.length - 1].toLowerCase()
            const ext2 = parts[parts.length - 2].toLowerCase()
            if ((ext1 === 'md' || ext1 === 'mdx') && /^[a-z]{2}$/i.test(ext2)) {
              candidate = parts.slice(0, -2).join('.') + '.pdf'
            }
          }
          byNameUrl.searchParams.set('bySourceName', candidate)
          byNameUrl.searchParams.set('libraryId', libraryId)
          UILogger.debug('JobReportTab', 'Request bySourceName', { url: byNameUrl.toString(), nameOnly: candidate, originalFileName: fileName })
          res = await fetch(byNameUrl.toString(), { cache: 'no-store' })
          data = await res.json()
          if (!res.ok) throw new Error(typeof data?.error === 'string' ? data.error : 'Job-Suche (Name) fehlgeschlagen')
          j = Array.isArray(data?.items) && data.items.length > 0 ? (data.items[0] as JobDto) : null
          UILogger.debug('JobReportTab', 'Result bySourceName', { count: Array.isArray(data?.items) ? data.items.length : 0 })
        }

        if (!cancelled) setJob(j)
        if (j) UILogger.info('JobReportTab', 'Job gefunden', { jobId: j.jobId, status: j.status })
        else UILogger.warn('JobReportTab', 'Kein Job gefunden', { libraryId, fileId })
      } catch (e) {
        const msg = e instanceof Error ? e.message : 'Unbekannter Fehler'
        UILogger.error('JobReportTab', 'Job-Suche fehlgeschlagen', e)
        if (!cancelled) setError(msg)
      } finally {
        if (!cancelled) setLoading(false)
      }
    }
    void run()
    return () => { cancelled = true }
  }, [libraryId, fileId, fileName, sourceMode, rawContent])

  // Wenn Template benutzt wurde, lade dessen Inhalt aus /templates und extrahiere Frontmatter-Schlüssel
  useEffect(() => {
    async function loadTemplateFields() {
      try {
        setTemplateFields(null)
        const tpl = job?.cumulativeMeta && typeof (job.cumulativeMeta as unknown) === 'object'
          ? (job.cumulativeMeta as Record<string, unknown>)['template_used']
          : undefined
        const templateName = typeof tpl === 'string' ? tpl : undefined
        if (!templateName || !provider) return
        const rootItems = await provider.listItemsById('root')
        const templatesFolder = rootItems.find(it => it.type === 'folder' && typeof (it as { metadata?: { name?: string } }).metadata?.name === 'string' && ((it as { metadata: { name: string } }).metadata.name.toLowerCase() === 'templates'))
        if (!templatesFolder) return
        const tplItems = await provider.listItemsById(templatesFolder.id)
        const match = tplItems.find(it => it.type === 'file' && ((it as { metadata: { name: string } }).metadata.name.toLowerCase() === templateName.toLowerCase()))
        if (!match) return
        const bin = await provider.getBinary(match.id)
        const text = await bin.blob.text()
        // Extrahiere Frontmatter zwischen den ersten beiden --- und lese die Keys bis zu :
        const m = text.match(/^---[\s\S]*?---/)
        if (!m) return
        const fm = m[0]
        const keys: string[] = []
        for (const line of fm.split('\n')) {
          const t = line.trim()
          if (!t || t === '---') continue
          const idx = t.indexOf(':')
          if (idx > 0) {
            const k = t.slice(0, idx).trim()
            if (k) keys.push(k)
          }
        }
        setTemplateFields(Array.from(new Set(keys)))
      } catch (e) {
        UILogger.warn('JobReportTab', 'Template-Felder konnten nicht geladen werden', { error: e instanceof Error ? e.message : String(e) })
      }
    }
    void loadTemplateFields()
  }, [job, provider])

  // Strikter Frontmatter-Parser: keine Toleranz, Kapitel/TOC nur via JSON.parse
  function strictParseFrontmatter(fm: string): { meta: Record<string, unknown>; errors: string[] } {
    const meta: Record<string, unknown> = {}
    const errors: string[] = []

    // Key: Value Zeilen (roh, keine Typkonvertierung)
    for (const line of fm.split('\n')) {
      const t = line.trim()
      if (!t || t === '---') continue
      const idx = t.indexOf(':')
      if (idx > 0) {
        const k = t.slice(0, idx).trim()
        const v = t.slice(idx + 1)
        // Rohwert speichern (ohne Toleranz)
        meta[k] = v
      }
    }

    // Kapitel und TOC strikt als JSON aus dem gesamten Block extrahieren
    const cap = /\nchapters:\s*(\[[\s\S]*?\])\s*\n/m.exec(fm)
    if (cap && cap[1]) {
      try {
        meta['chapters'] = JSON.parse(cap[1])
      } catch (e) {
        errors.push(`chapters ist kein gültiges JSON: ${(e as Error).message}`)
      }
    }
    const tocCap = /\ntoc:\s*(\[[\s\S]*?\])\s*\n/m.exec(fm)
    if (tocCap && tocCap[1]) {
      try {
        meta['toc'] = JSON.parse(tocCap[1])
      } catch (e) {
        errors.push(`toc ist kein gültiges JSON: ${(e as Error).message}`)
      }
    }

    return { meta, errors }
  }

  // Frontmatter aus der gespeicherten Markdown-Datei lesen (oder aus rawContent)
  useEffect(() => {
    async function loadFrontmatter() {
      try {
        setParseErrors([])
        // Wenn roher Inhalt übergeben wurde, direkt daraus lesen
        if (sourceMode === 'frontmatter' && typeof rawContent === 'string' && rawContent.length > 0) {
          const text = rawContent
          const m = text.match(/^---[\s\S]*?---/)
          UILogger.debug('JobReportTab', 'Frontmatter (raw): Block gefunden?', { found: !!m, length: m ? m[0].length : 0 })
          if (!m) { setFrontmatterMeta(null); return }
          const fm = m[0]
          const { meta, errors } = strictParseFrontmatter(fm)
          setFrontmatterMeta(Object.keys(meta).length ? meta : null)
          setParseErrors(errors)
          return
        }

        if (!provider) return
        const mdId = (mdFileId || (job?.result?.savedItemId as string | undefined) || fileId)
        UILogger.info('JobReportTab', 'Frontmatter: Lade Datei', { mdId, sourceMode })
        if (!mdId) return
        const bin = await provider.getBinary(mdId)
        const text = await bin.blob.text()
        const m = text.match(/^---[\s\S]*?---/)
        UILogger.debug('JobReportTab', 'Frontmatter: Block gefunden?', { found: !!m, length: m ? m[0].length : 0 })
        if (!m) { setFrontmatterMeta(null); return }
        const fm = m[0]
        const { meta, errors } = strictParseFrontmatter(fm)
        setFrontmatterMeta(Object.keys(meta).length ? meta : null)
        setParseErrors(errors)
      } catch {
        setFrontmatterMeta(null)
      }
    }
    void loadFrontmatter()
  }, [provider, fileId, mdFileId, job?.result?.savedItemId, sourceMode, rawContent])

  if (sourceMode !== 'frontmatter') {
    if (loading) return <div className="p-4 text-sm text-muted-foreground">Lade Job…</div>
    if (error) return <div className="p-4 text-sm text-destructive">{error}</div>
    if (!job) return <div className="p-4 text-sm text-muted-foreground">Kein Job zur Datei gefunden.</div>
  }

  return (
    <div className="p-4 space-y-3 text-sm">
      {viewMode === 'metaOnly' && (
        <div className="inline-flex rounded border overflow-hidden">
          <button
            type="button"
            onClick={() => setSection('meta')}
            className={`px-3 py-1 text-xs ${section === 'meta' ? 'bg-primary text-primary-foreground' : 'bg-background'} border-r`}
            aria-pressed={section === 'meta'}
          >
            Metadaten
          </button>
          <button
            type="button"
            onClick={() => setSection('chapters')}
            className={`px-3 py-1 text-xs ${section === 'chapters' ? 'bg-primary text-primary-foreground' : 'bg-background'}`}
            aria-pressed={section === 'chapters'}
          >
            Kapitel
          </button>
        </div>
      )}
      {viewMode === 'full' && job && (
        <div className="flex items-center justify-between">
          <div>
            <div className="font-medium">Job {job.jobId}</div>
            <div className="text-xs text-muted-foreground">{job.job_type} · {job.operation} · {new Date(job.updatedAt).toLocaleString()}</div>
          </div>
          <div className="inline-flex items-center rounded px-2 py-0.5 bg-muted text-xs">{job.status}</div>
        </div>
      )}

      {/* Hinweise zu Parserfehlern (strikt) */}
      {parseErrors.length > 0 && (
        <div className="text-xs text-destructive">
          {parseErrors.map((e, i) => (<div key={i}>Parserfehler: {e}</div>))}
        </div>
      )}

      {/* Template Hinweis (im Frontmatter-only-Modus ausgeblendet) */}
      {sourceMode !== 'frontmatter' && job && typeof job.cumulativeMeta?.template_used === 'string' && (
        <div className="text-xs text-muted-foreground">Template: {String(job.cumulativeMeta.template_used)}</div>
      )}

      {/* Schritte mit Ampel-Logik */}
      {viewMode === 'full' && job && Array.isArray(job.steps) && job.steps.length > 0 && (
        <div>
          <div className="font-medium mb-1">Schritte</div>
          <div className="flex flex-wrap gap-2 text-xs">
            {job.steps.map((s) => {
              // Geplante Phasen ermitteln (neue Flags bevorzugt, sonst phases)
              const p = (job.parameters || {}) as Record<string, unknown>
              const hasNewFlags = typeof p['doExtractPDF'] === 'boolean' || typeof p['doExtractMetadata'] === 'boolean' || typeof p['doIngestRAG'] === 'boolean'
              const phases = hasNewFlags
                ? {
                    extract: p['doExtractPDF'] === true,
                    template: p['doExtractMetadata'] === true,
                    ingest: p['doIngestRAG'] === true,
                  }
                : ((p['phases'] as { extract?: boolean; template?: boolean; ingest?: boolean }) || {})

              const planned = (() => {
                const n = s.name
                if (n === 'extract_pdf') return phases.extract === true
                if (n === 'transform_template' || n === 'store_shadow_twin') return phases.template === true
                if (n === 'ingest_rag') return phases.ingest === true
                return false
              })()

              // Ampel-Status ableiten
              const skipped = !!(s as { details?: { skipped?: boolean } }).details?.skipped
              let icon = '○'
              let cls = 'text-muted-foreground'
              if (s.status === 'failed') { icon = '✕'; cls = 'text-red-600' }
              else if (s.status === 'running') { icon = '◐'; cls = 'text-yellow-600' }
              else if (s.status === 'completed') { icon = skipped ? '○' : '✓'; cls = skipped ? 'text-gray-400' : 'text-green-600' }
              else if (s.status === 'pending') { icon = planned ? '•' : '○'; cls = planned ? 'text-yellow-600' : 'text-muted-foreground' }

              const time = s.endedAt ? new Date(s.endedAt).toLocaleTimeString() : s.startedAt ? new Date(s.startedAt).toLocaleTimeString() : ''
              return (
                <div key={s.name} className={`inline-flex items-center gap-1 px-2 py-1 rounded border ${cls}`}>
                  <span>{icon}</span>
                  <span className="font-medium">{s.name}</span>
                  {time ? <span className="opacity-70">{time}</span> : null}
                </div>
              )
            })}
          </div>
        </div>
      )}

      {/* Metadaten (flach) – je nach sourceMode: nur Frontmatter oder Merge */}
      {section === 'meta' && (() => {
        const base: Record<string, unknown> = sourceMode === 'frontmatter'
          ? {}
          : ((job?.cumulativeMeta as unknown as Record<string, unknown>) || {})
        const cm = frontmatterMeta ? { ...base, ...frontmatterMeta } : base
        const baseKeys = Array.isArray(templateFields) && templateFields.length > 0
          ? templateFields
          : Object.keys(cm)
        const flatKeys = baseKeys.filter(k => k !== 'chapters' && k !== 'toc')
        if (flatKeys.length === 0) return null
        return (
        <div>
          <div className="font-medium mb-1">Metadaten (Template vs. Ergebnis)</div>
          <div className="overflow-auto">
            <table className="w-full text-xs">
              <thead>
                <tr className="text-left text-muted-foreground">
                  <th className="py-1 pr-2">Feld</th>
                  <th className="py-1 pr-2">Wert</th>
                </tr>
              </thead>
              <tbody>
                {flatKeys.map((k) => {
                  const val = cm[k]
                  let valueStr = ''
                  if (Array.isArray(val)) valueStr = (val as Array<unknown>).map(v => typeof v === 'string' ? v : JSON.stringify(v)).join(', ')
                  else valueStr = val === null || val === undefined ? '' : typeof val === 'string' ? val : JSON.stringify(val)
                  return (
                    <tr key={k} className="border-t border-muted/40">
                      <td className="py-1 pr-2 align-top font-medium">{k}</td>
                      <td className="py-1 pr-2 align-top whitespace-pre-wrap break-words">{valueStr}</td>
                    </tr>
                  )
                })}
              </tbody>
            </table>
          </div>
        </div>
        )
      })()}

      {/* Kapitel (hierarchisch, TOC-Ansicht mit Einrückung & Aufklappen) */}
      {section === 'chapters' && (() => {
        const chapters: Array<Record<string, unknown>> = sourceMode === 'frontmatter'
          ? (Array.isArray(frontmatterMeta?.chapters) ? (frontmatterMeta?.chapters as Array<Record<string, unknown>>) : [])
          : ((job?.cumulativeMeta as unknown as { chapters?: Array<Record<string, unknown>> })?.chapters || [])
        if (!Array.isArray(chapters) || chapters.length === 0) return null

        const pad = (lvl: number | undefined): number => {
          if (typeof lvl !== 'number') return 0
          const clamped = Math.max(0, Math.min(3, lvl))
          return (clamped - 1) * 16 // px
        }

        // Hierarchische Nummerierung 1., 1.1, 1.1.1 basierend auf level
        const counters = [0, 0, 0]
        return (
        <div className="space-y-1">
          <div className="font-medium mb-1">Kapitel</div>
          <div>
            {chapters.map((c, i) => {
              const level = typeof c.level === 'number' ? c.level : 1
              const lvl = Math.max(1, Math.min(3, level))
              // Zähler aktualisieren
              counters[lvl - 1] += 1
              for (let j = lvl; j < counters.length; j++) counters[j] = 0
              const numLabel = counters.slice(0, lvl).filter(n => n > 0).join('.')
              const title = typeof c.title === 'string' ? c.title : ''
              const startPage = typeof c.startPage === 'number' ? c.startPage : ''
              
              const summaryVal = typeof c.summary === 'string' ? c.summary : ''
              const summary = summaryVal.length > 1000 ? `${summaryVal.slice(0, 1000)}…` : summaryVal
              const keywords = Array.isArray(c.keywords) ? (c.keywords as Array<unknown>).filter(v => typeof v === 'string') as string[] : []
              const ev = typeof c.startEvidence === 'string' ? c.startEvidence : ''
              return (
                <details key={`${title}-${i}`} className="group border-b py-1" open={false} onToggle={(e) => {
                  const open = (e.currentTarget as HTMLDetailsElement).open
                  if (open) {
                    if (startPage !== '') onJumpTo?.({ page: startPage as number | string })
                    else if (ev) onJumpTo?.({ evidence: ev })
                  }
                }}>
                  <summary className="list-none cursor-pointer">
                    <div className="flex items-start justify-between gap-3">
                      <div className="flex-1 min-w-0" style={{ paddingLeft: `${pad(lvl)}px` }}>
                        <div className="flex items-baseline gap-2">
                          <span className="text-xs text-muted-foreground tabular-nums">{numLabel}</span>
                          <span className="font-medium truncate">{title}</span>
                        </div>
                      </div>
                      <div className="text-xs tabular-nums text-muted-foreground whitespace-nowrap">
                        {String(startPage)}
                      </div>
                    </div>
                  </summary>
                  <div className="mt-1 pr-1 text-xs space-y-1" style={{ paddingLeft: `${pad(lvl) + 28}px` }}>
                    {summary && (
                      <div className="whitespace-pre-wrap break-words">
                        {summary}
                      </div>
                    )}
                    {Array.isArray(keywords) && keywords.length > 0 && (
                      <div className="flex flex-wrap gap-1">
                        {keywords.map(k => (
                          <span key={k} className="inline-flex items-center rounded px-1.5 py-0.5 bg-muted">{k}</span>
                        ))}
                      </div>
                    )}
                  </div>
                </details>
              )
            })}
          </div>
        </div>
        )
      })()}

      {/* Inhaltsverzeichnis */}
      {section === 'chapters' && (() => {
        const toc: Array<Record<string, unknown>> = sourceMode === 'frontmatter'
          ? (Array.isArray(frontmatterMeta?.toc) ? (frontmatterMeta?.toc as Array<Record<string, unknown>>) : [])
          : ((job?.cumulativeMeta as unknown as { toc?: Array<Record<string, unknown>> }).toc || [])
        if (!Array.isArray(toc) || toc.length === 0) return null
        return (
        <div>
          <div className="font-medium mb-1">Inhaltsverzeichnis</div>
          <div className="overflow-visible">
            <table className="w-full text-xs">
              <thead>
                <tr className="text-left text-muted-foreground">
                  <th className="py-1 pr-2">Titel</th>
                  <th className="py-1 pr-2">Seite</th>
                  <th className="py-1 pr-2">L</th>
                </tr>
              </thead>
              <tbody>
                {toc.map((t, i) => {
                  const title = typeof t.title === 'string' ? t.title : ''
                  const page = typeof t.page === 'number' ? t.page : ''
                  const level = typeof t.level === 'number' ? t.level : ''
                  return (
                    <tr key={`${title}-${i}`} className="border-t border-muted/40">
                      <td className="py-1 pr-2 align-top whitespace-pre-wrap break-words">{title}</td>
                      <td className="py-1 pr-2 align-top">{page}</td>
                      <td className="py-1 pr-2 align-top">{level}</td>
                    </tr>
                  )
                })}
              </tbody>
            </table>
          </div>
        </div>
        )
      })()}

      {viewMode === 'full' && job && job.ingestion && (
        <div>
          <div className="font-medium mb-1">Ingestion</div>
          <div className="text-xs text-muted-foreground">{job.ingestion.index || '—'} · Vektoren: {job.ingestion.vectorsUpserted ?? '—'} · {job.ingestion.upsertAt ? new Date(job.ingestion.upsertAt).toLocaleString() : '—'}</div>
        </div>
      )}

      {viewMode === 'full' && job && Array.isArray(job.logs) && job.logs.length > 0 && (
        <div>
          <div className="font-medium mb-1">Logs (neueste zuerst)</div>
          <ul className="space-y-0.5 max-h-48 overflow-auto">
            {[...job.logs].reverse().slice(0, 30).map((l, i) => (
              <li key={i} className="text-xs">
                {new Date(l.timestamp).toLocaleTimeString()} · {l.phase || '—'} · {typeof l.progress === 'number' ? `${l.progress}% · ` : ''}{l.message || ''}
              </li>
            ))}
          </ul>
        </div>
      )}

      {/* Parameter am Ende */}
      {viewMode === 'full' && job && job.parameters && (
        <div>
          <div className="font-medium mb-1">Parameter</div>
          <pre className="bg-muted/40 rounded p-2 max-h-32 overflow-auto whitespace-pre-wrap break-words">{JSON.stringify(job.parameters, null, 2)}</pre>
        </div>
      )}
    </div>
  )
}



```

Verstanden: Null Toleranz. Ich habe den Frontmatter‑Pfad vereinheitlicht und strikt gemacht:

- Einheitlicher Parser in `job-report-tab.tsx` für Datei und `rawContent`.
- Striktes Verhalten:
  - Zeilenweise werden nur Key: Value roh übernommen (keine Typkonvertierung).
  - `chapters`/`toc` werden ausschließlich via JSON.parse aus dem Frontmatter‑Block geparst.
  - Wenn Parse fehlschlägt, wird ein Parserfehler im UI angezeigt: „chapters ist kein gültiges JSON: …“. Keine stillen Fallbacks.

Damit siehst du im Test‑Tab exakt dieselben Regeln wie bei gespeicherten Dokumenten.

---

**User**

 Wir haben es jetzt ein bisschen unübersichtlich. Wäre es möglich, dass wir in diesem bestehenden, standardisierten Metadaten- und Kapiteldata vorher noch Markdown hinzufügen, dass man so umschalten kann zwischen der Markdown-Ansicht, Metadaten- und Kapitel-Ansicht, dann könnten wir uns oben diese beiden Tabs sparen. Später werde ich das dann auch bei diesen Phasen ein bisschen anpassen. Dort gefällt mir das auch nicht so richtig, aber das machen wir später. So hätten wir eine standardisierte Ansicht, die wir immer verwenden können.

---

**Cursor**

```typescriptreact
"use client";

import { useEffect, useState } from 'react'
import { UILogger } from '@/lib/debug/logger'
import type { StorageProvider } from '@/lib/storage/types'
import { MarkdownPreview } from '@/components/library/markdown-preview'
import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs'

interface JobReportTabProps {
  libraryId: string
  fileId: string
  fileName?: string
  provider?: StorageProvider | null
  // Quelle der Metadaten steuern: 'merged' = cumulativeMeta + Frontmatter (Standard),
  // 'frontmatter' = ausschließlich Frontmatter aus Markdown anzeigen
  sourceMode?: 'merged' | 'frontmatter'
  // Darstellungsmodus: 'full' zeigt Kopf/Steps/Logs/Parameter; 'metaOnly' zeigt nur Metadaten/Kapitel/TOC
  viewMode?: 'full' | 'metaOnly'
  // Optional explizite Markdown-Datei-ID (Shadow‑Twin). Überschreibt auto-Erkennung.
  mdFileId?: string | null
  // Optionaler Callback zum Scroll-Sync in die Markdown-Vorschau
  onJumpTo?: (args: { page?: number | string; evidence?: string }) => void
  // NEU: Rohinhalt (Markdown). Wenn gesetzt und sourceMode='frontmatter', wird direkt dieser Text geparst (ohne Datei/JOB).
  rawContent?: string
}

interface JobDto {
  jobId: string
  status: string
  operation: string
  worker: string
  job_type: string
  updatedAt: string
  createdAt: string
  correlation?: { source?: { itemId?: string; name?: string } }
  parameters?: Record<string, unknown>
  steps?: Array<{ name: string; status: string; startedAt?: string; endedAt?: string; error?: { message: string }; details?: { skipped?: boolean } }>
  ingestion?: { vectorsUpserted?: number; index?: string; upsertAt?: string }
  result?: { savedItemId?: string }
  logs?: Array<{ timestamp: string; phase?: string; message?: string; progress?: number }>
  cumulativeMeta?: Record<string, unknown>
}

export function JobReportTab({ libraryId, fileId, fileName, provider, sourceMode = 'merged', viewMode = 'full', mdFileId, onJumpTo, rawContent }: JobReportTabProps) {
  const [loading, setLoading] = useState(false)
  const [error, setError] = useState<string | null>(null)
  const [job, setJob] = useState<JobDto | null>(null)
  const [templateFields, setTemplateFields] = useState<string[] | null>(null)
  const [frontmatterMeta, setFrontmatterMeta] = useState<Record<string, unknown> | null>(null)
  const [section, setSection] = useState<'meta' | 'chapters'>('meta')
  const [parseErrors, setParseErrors] = useState<string[]>([])
  const [fullContent, setFullContent] = useState<string>('')

  useEffect(() => {
    let cancelled = false
    async function run() {
      try {
        // Wenn wir Rohinhalt haben und nur Frontmatter zeigen, brauchen wir keine Job-Suche
        if (sourceMode === 'frontmatter' && typeof rawContent === 'string' && rawContent.length > 0) {
          setJob(null)
          setLoading(false)
          setError(null)
          return
        }
        setLoading(true)
        setError(null)
        UILogger.info('JobReportTab', 'Start Job-Suche', { libraryId, fileId })
        // 1) Versuche Job über result.savedItemId (Shadow‑Twin) zu finden
        const byResultUrl = new URL(`/api/external/jobs`, window.location.origin)
        byResultUrl.searchParams.set('byResultItemId', fileId)
        UILogger.debug('JobReportTab', 'Request byResultItemId', { url: byResultUrl.toString() })
        let res = await fetch(byResultUrl.toString(), { cache: 'no-store' })
        let data = await res.json()
        if (!res.ok) throw new Error(typeof data?.error === 'string' ? data.error : 'Job-Suche fehlgeschlagen')
        let j: JobDto | null = Array.isArray(data?.items) && data.items.length > 0 ? (data.items[0] as JobDto) : null
        UILogger.debug('JobReportTab', 'Result byResultItemId', { count: Array.isArray(data?.items) ? data.items.length : 0 })

        // 2) Fallback: über correlation.source.itemId (Originaldatei)
        if (!j) {
          const bySourceUrl = new URL(`/api/external/jobs`, window.location.origin)
          bySourceUrl.searchParams.set('bySourceItemId', fileId)
          bySourceUrl.searchParams.set('libraryId', libraryId)
          UILogger.debug('JobReportTab', 'Request bySourceItemId', { url: bySourceUrl.toString() })
          res = await fetch(bySourceUrl.toString(), { cache: 'no-store' })
          data = await res.json()
          if (!res.ok) throw new Error(typeof data?.error === 'string' ? data.error : 'Job-Suche (Quelle) fehlgeschlagen')
          j = Array.isArray(data?.items) && data.items.length > 0 ? (data.items[0] as JobDto) : null
          UILogger.debug('JobReportTab', 'Result bySourceItemId', { count: Array.isArray(data?.items) ? data.items.length : 0 })
        }

        // 3) Fallback: über correlation.source.name (Dateiname der Quelle)
        if (!j) {
          const byNameUrl = new URL(`/api/external/jobs`, window.location.origin)
          // Wenn wir den tatsächlichen Dateinamen kennen, verwende ihn.
          // Für Shadow‑Twins (z. B. name.de.md) versuche das Basis‑PDF (name.pdf).
          let candidate = (fileName && typeof fileName === 'string') ? fileName : (fileId.includes('/') ? (fileId.split('/').pop() as string) : fileId)
          const parts = candidate.split('.')
          if (parts.length >= 3) {
            const ext1 = parts[parts.length - 1].toLowerCase()
            const ext2 = parts[parts.length - 2].toLowerCase()
            if ((ext1 === 'md' || ext1 === 'mdx') && /^[a-z]{2}$/i.test(ext2)) {
              candidate = parts.slice(0, -2).join('.') + '.pdf'
            }
          }
          byNameUrl.searchParams.set('bySourceName', candidate)
          byNameUrl.searchParams.set('libraryId', libraryId)
          UILogger.debug('JobReportTab', 'Request bySourceName', { url: byNameUrl.toString(), nameOnly: candidate, originalFileName: fileName })
          res = await fetch(byNameUrl.toString(), { cache: 'no-store' })
          data = await res.json()
          if (!res.ok) throw new Error(typeof data?.error === 'string' ? data.error : 'Job-Suche (Name) fehlgeschlagen')
          j = Array.isArray(data?.items) && data.items.length > 0 ? (data.items[0] as JobDto) : null
          UILogger.debug('JobReportTab', 'Result bySourceName', { count: Array.isArray(data?.items) ? data.items.length : 0 })
        }

        if (!cancelled) setJob(j)
        if (j) UILogger.info('JobReportTab', 'Job gefunden', { jobId: j.jobId, status: j.status })
        else UILogger.warn('JobReportTab', 'Kein Job gefunden', { libraryId, fileId })
      } catch (e) {
        const msg = e instanceof Error ? e.message : 'Unbekannter Fehler'
        UILogger.error('JobReportTab', 'Job-Suche fehlgeschlagen', e)
        if (!cancelled) setError(msg)
      } finally {
        if (!cancelled) setLoading(false)
      }
    }
    void run()
    return () => { cancelled = true }
  }, [libraryId, fileId, fileName, sourceMode, rawContent])

  // Wenn Template benutzt wurde, lade dessen Inhalt aus /templates und extrahiere Frontmatter-Schlüssel
  useEffect(() => {
    async function loadTemplateFields() {
      try {
        setTemplateFields(null)
        const tpl = job?.cumulativeMeta && typeof (job.cumulativeMeta as unknown) === 'object'
          ? (job.cumulativeMeta as Record<string, unknown>)['template_used']
          : undefined
        const templateName = typeof tpl === 'string' ? tpl : undefined
        if (!templateName || !provider) return
        const rootItems = await provider.listItemsById('root')
        const templatesFolder = rootItems.find(it => it.type === 'folder' && typeof (it as { metadata?: { name?: string } }).metadata?.name === 'string' && ((it as { metadata: { name: string } }).metadata.name.toLowerCase() === 'templates'))
        if (!templatesFolder) return
        const tplItems = await provider.listItemsById(templatesFolder.id)
        const match = tplItems.find(it => it.type === 'file' && ((it as { metadata: { name: string } }).metadata.name.toLowerCase() === templateName.toLowerCase()))
        if (!match) return
        const bin = await provider.getBinary(match.id)
        const text = await bin.blob.text()
        // Extrahiere Frontmatter zwischen den ersten beiden --- und lese die Keys bis zu :
        const m = text.match(/^---[\s\S]*?---/)
        if (!m) return
        const fm = m[0]
        const keys: string[] = []
        for (const line of fm.split('\n')) {
          const t = line.trim()
          if (!t || t === '---') continue
          const idx = t.indexOf(':')
          if (idx > 0) {
            const k = t.slice(0, idx).trim()
            if (k) keys.push(k)
          }
        }
        setTemplateFields(Array.from(new Set(keys)))
      } catch (e) {
        UILogger.warn('JobReportTab', 'Template-Felder konnten nicht geladen werden', { error: e instanceof Error ? e.message : String(e) })
      }
    }
    void loadTemplateFields()
  }, [job, provider])

  // Strikter Frontmatter-Parser: keine Toleranz, Kapitel/TOC nur via JSON.parse
  function strictParseFrontmatter(fm: string): { meta: Record<string, unknown>; errors: string[] } {
    const meta: Record<string, unknown> = {}
    const errors: string[] = []

    // Key: Value Zeilen (roh, keine Typkonvertierung)
    for (const line of fm.split('\n')) {
      const t = line.trim()
      if (!t || t === '---') continue
      const idx = t.indexOf(':')
      if (idx > 0) {
        const k = t.slice(0, idx).trim()
        const v = t.slice(idx + 1)
        // Rohwert speichern (ohne Toleranz)
        meta[k] = v
      }
    }

    // Kapitel und TOC strikt als JSON aus dem gesamten Block extrahieren
    const cap = /\nchapters:\s*(\[[\s\S]*?\])\s*\n/m.exec(fm)
    if (cap && cap[1]) {
      try {
        meta['chapters'] = JSON.parse(cap[1])
      } catch (e) {
        errors.push(`chapters ist kein gültiges JSON: ${(e as Error).message}`)
      }
    }
    const tocCap = /\ntoc:\s*(\[[\s\S]*?\])\s*\n/m.exec(fm)
    if (tocCap && tocCap[1]) {
      try {
        meta['toc'] = JSON.parse(tocCap[1])
      } catch (e) {
        errors.push(`toc ist kein gültiges JSON: ${(e as Error).message}`)
      }
    }

    return { meta, errors }
  }

  // Frontmatter aus der gespeicherten Markdown-Datei lesen (oder aus rawContent)
  useEffect(() => {
    async function loadFrontmatter() {
      try {
        setParseErrors([])
        // Wenn roher Inhalt übergeben wurde, direkt daraus lesen
        if (sourceMode === 'frontmatter' && typeof rawContent === 'string' && rawContent.length > 0) {
          const text = rawContent
          setFullContent(text)
          const m = text.match(/^---[\s\S]*?---/)
          UILogger.debug('JobReportTab', 'Frontmatter (raw): Block gefunden?', { found: !!m, length: m ? m[0].length : 0 })
          if (!m) { setFrontmatterMeta(null); return }
          const fm = m[0]
          const { meta, errors } = strictParseFrontmatter(fm)
          setFrontmatterMeta(Object.keys(meta).length ? meta : null)
          setParseErrors(errors)
          return
        }

        if (!provider) return
        const mdId = (mdFileId || (job?.result?.savedItemId as string | undefined) || fileId)
        UILogger.info('JobReportTab', 'Frontmatter: Lade Datei', { mdId, sourceMode })
        if (!mdId) return
        const bin = await provider.getBinary(mdId)
        const text = await bin.blob.text()
        setFullContent(text)
        const m = text.match(/^---[\s\S]*?---/)
        UILogger.debug('JobReportTab', 'Frontmatter: Block gefunden?', { found: !!m, length: m ? m[0].length : 0 })
        if (!m) { setFrontmatterMeta(null); return }
        const fm = m[0]
        const { meta, errors } = strictParseFrontmatter(fm)
        setFrontmatterMeta(Object.keys(meta).length ? meta : null)
        setParseErrors(errors)
      } catch {
        setFrontmatterMeta(null)
      }
    }
    void loadFrontmatter()
  }, [provider, fileId, mdFileId, job?.result?.savedItemId, sourceMode, rawContent])

  if (sourceMode !== 'frontmatter') {
    if (loading) return <div className="p-4 text-sm text-muted-foreground">Lade Job…</div>
    if (error) return <div className="p-4 text-sm text-destructive">{error}</div>
    if (!job) return <div className="p-4 text-sm text-muted-foreground">Kein Job zur Datei gefunden.</div>
  }

  return (
    <div className="p-4 space-y-3 text-sm">
      {viewMode === 'metaOnly' && (
        <Tabs defaultValue="markdown">
          <TabsList className="grid grid-cols-3 w-full">
            <TabsTrigger value="markdown">Markdown</TabsTrigger>
            <TabsTrigger value="meta">Metadaten</TabsTrigger>
            <TabsTrigger value="chapters">Kapitel</TabsTrigger>
          </TabsList>

          <TabsContent value="markdown" className="mt-3">
            <div className="border rounded-md">
              <MarkdownPreview content={fullContent || ''} />
            </div>
          </TabsContent>

          <TabsContent value="meta" className="mt-3">
            {/* Hinweise zu Parserfehlern (strikt) */}
            {parseErrors.length > 0 && (
              <div className="text-xs text-destructive mb-2">
                {parseErrors.map((e, i) => (<div key={i}>Parserfehler: {e}</div>))}
              </div>
            )}
            {(() => {
              const base: Record<string, unknown> = sourceMode === 'frontmatter'
                ? {}
                : ((job?.cumulativeMeta as unknown as Record<string, unknown>) || {})
              const cm = frontmatterMeta ? { ...base, ...frontmatterMeta } : base
              const baseKeys = Array.isArray(templateFields) && templateFields.length > 0
                ? templateFields
                : Object.keys(cm)
              const flatKeys = baseKeys.filter(k => k !== 'chapters' && k !== 'toc')
              if (flatKeys.length === 0) return null
              return (
                <div>
                  <div className="font-medium mb-1">Metadaten (Template vs. Ergebnis)</div>
                  <div className="overflow-auto">
                    <table className="w-full text-xs">
                      <thead>
                        <tr className="text-left text-muted-foreground">
                          <th className="py-1 pr-2">Feld</th>
                          <th className="py-1 pr-2">Wert</th>
                        </tr>
                      </thead>
                      <tbody>
                        {flatKeys.map((k) => {
                          const val = cm[k]
                          let valueStr = ''
                          if (Array.isArray(val)) valueStr = (val as Array<unknown>).map(v => typeof v === 'string' ? v : JSON.stringify(v)).join(', ')
                          else valueStr = val === null || val === undefined ? '' : typeof val === 'string' ? val : JSON.stringify(val)
                          return (
                            <tr key={k} className="border-t border-muted/40">
                              <td className="py-1 pr-2 align-top font-medium">{k}</td>
                              <td className="py-1 pr-2 align-top whitespace-pre-wrap break-words">{valueStr}</td>
                            </tr>
                          )
                        })}
                      </tbody>
                    </table>
                  </div>
                </div>
              )
            })()}
          </TabsContent>

          <TabsContent value="chapters" className="mt-3">
            {(() => {
              const chapters: Array<Record<string, unknown>> = sourceMode === 'frontmatter'
                ? (Array.isArray(frontmatterMeta?.chapters) ? (frontmatterMeta?.chapters as Array<Record<string, unknown>>) : [])
                : ((job?.cumulativeMeta as unknown as { chapters?: Array<Record<string, unknown>> })?.chapters || [])
              if (!Array.isArray(chapters) || chapters.length === 0) return null
              const pad = (lvl: number | undefined): number => {
                if (typeof lvl !== 'number') return 0
                const clamped = Math.max(0, Math.min(3, lvl))
                return (clamped - 1) * 16
              }
              const counters = [0, 0, 0]
              return (
                <div className="space-y-1">
                  <div>
                    {chapters.map((c, i) => {
                      const level = typeof c.level === 'number' ? c.level : 1
                      const lvl = Math.max(1, Math.min(3, level))
                      counters[lvl - 1] += 1
                      for (let j = lvl; j < counters.length; j++) counters[j] = 0
                      const numLabel = counters.slice(0, lvl).filter(n => n > 0).join('.')
                      const title = typeof c.title === 'string' ? c.title : ''
                      const startPage = typeof c.startPage === 'number' ? c.startPage : ''
                      const summaryVal = typeof c.summary === 'string' ? c.summary : ''
                      const summary = summaryVal.length > 1000 ? `${summaryVal.slice(0, 1000)}…` : summaryVal
                      const keywords = Array.isArray(c.keywords) ? (c.keywords as Array<unknown>).filter(v => typeof v === 'string') as string[] : []
                      const ev = typeof c.startEvidence === 'string' ? c.startEvidence : ''
                      return (
                        <details key={`${title}-${i}`} className="group border-b py-1" open={false}>
                          <summary className="list-none cursor-pointer">
                            <div className="flex items-start justify-between gap-3">
                              <div className="flex-1 min-w-0" style={{ paddingLeft: `${pad(lvl)}px` }}>
                                <div className="flex items-baseline gap-2">
                                  <span className="text-xs text-muted-foreground tabular-nums">{numLabel}</span>
                                  <span className="font-medium truncate">{title}</span>
                                </div>
                              </div>
                              <div className="text-xs tabular-nums text-muted-foreground whitespace-nowrap">
                                {String(startPage)}
                              </div>
                            </div>
                          </summary>
                          <div className="mt-1 pr-1 text-xs space-y-1" style={{ paddingLeft: `${pad(lvl) + 28}px` }}>
                            {summary && (
                              <div className="whitespace-pre-wrap break-words">
                                {summary}
                              </div>
                            )}
                            {Array.isArray(keywords) && keywords.length > 0 && (
                              <div className="flex flex-wrap gap-1">
                                {keywords.map(k => (
                                  <span key={k} className="inline-flex items-center rounded px-1.5 py-0.5 bg-muted">{k}</span>
                                ))}
                              </div>
                            )}
                          </div>
                        </details>
                      )
                    })}
                  </div>
                </div>
              )
            })()}
          </TabsContent>
        </Tabs>
      )}

      {viewMode === 'full' && job && (
        <div className="flex items-center justify-between">
          <div>
            <div className="font-medium">Job {job.jobId}</div>
            <div className="text-xs text-muted-foreground">{job.job_type} · {job.operation} · {new Date(job.updatedAt).toLocaleString()}</div>
          </div>
          <div className="inline-flex items-center rounded px-2 py-0.5 bg-muted text-xs">{job.status}</div>
        </div>
      )}

      {/* Hinweise zu Parserfehlern (strikt) */}
      {viewMode !== 'metaOnly' && parseErrors.length > 0 && (
        <div className="text-xs text-destructive">
          {parseErrors.map((e, i) => (<div key={i}>Parserfehler: {e}</div>))}
        </div>
      )}

      {/* Template Hinweis (im Frontmatter-only-Modus ausgeblendet) */}
      {sourceMode !== 'frontmatter' && job && typeof job.cumulativeMeta?.template_used === 'string' && (
        <div className="text-xs text-muted-foreground">Template: {String(job.cumulativeMeta.template_used)}</div>
      )}

      {/* Schritte mit Ampel-Logik */}
      {viewMode === 'full' && job && Array.isArray(job.steps) && job.steps.length > 0 && (
        <div>
          <div className="font-medium mb-1">Schritte</div>
          <div className="flex flex-wrap gap-2 text-xs">
            {job.steps.map((s) => {
              // Geplante Phasen ermitteln (neue Flags bevorzugt, sonst phases)
              const p = (job.parameters || {}) as Record<string, unknown>
              const hasNewFlags = typeof p['doExtractPDF'] === 'boolean' || typeof p['doExtractMetadata'] === 'boolean' || typeof p['doIngestRAG'] === 'boolean'
              const phases = hasNewFlags
                ? {
                    extract: p['doExtractPDF'] === true,
                    template: p['doExtractMetadata'] === true,
                    ingest: p['doIngestRAG'] === true,
                  }
                : ((p['phases'] as { extract?: boolean; template?: boolean; ingest?: boolean }) || {})

              const planned = (() => {
                const n = s.name
                if (n === 'extract_pdf') return phases.extract === true
                if (n === 'transform_template' || n === 'store_shadow_twin') return phases.template === true
                if (n === 'ingest_rag') return phases.ingest === true
                return false
              })()

              // Ampel-Status ableiten
              const skipped = !!(s as { details?: { skipped?: boolean } }).details?.skipped
              let icon = '○'
              let cls = 'text-muted-foreground'
              if (s.status === 'failed') { icon = '✕'; cls = 'text-red-600' }
              else if (s.status === 'running') { icon = '◐'; cls = 'text-yellow-600' }
              else if (s.status === 'completed') { icon = skipped ? '○' : '✓'; cls = skipped ? 'text-gray-400' : 'text-green-600' }
              else if (s.status === 'pending') { icon = planned ? '•' : '○'; cls = planned ? 'text-yellow-600' : 'text-muted-foreground' }

              const time = s.endedAt ? new Date(s.endedAt).toLocaleTimeString() : s.startedAt ? new Date(s.startedAt).toLocaleTimeString() : ''
              return (
                <div key={s.name} className={`inline-flex items-center gap-1 px-2 py-1 rounded border ${cls}`}>
                  <span>{icon}</span>
                  <span className="font-medium">{s.name}</span>
                  {time ? <span className="opacity-70">{time}</span> : null}
                </div>
              )
            })}
          </div>
        </div>
      )}

      {/* Metadaten (flach) – je nach sourceMode: nur Frontmatter oder Merge */}
      {section === 'meta' && (() => {
        const base: Record<string, unknown> = sourceMode === 'frontmatter'
          ? {}
          : ((job?.cumulativeMeta as unknown as Record<string, unknown>) || {})
        const cm = frontmatterMeta ? { ...base, ...frontmatterMeta } : base
        const baseKeys = Array.isArray(templateFields) && templateFields.length > 0
          ? templateFields
          : Object.keys(cm)
        const flatKeys = baseKeys.filter(k => k !== 'chapters' && k !== 'toc')
        if (flatKeys.length === 0) return null
        return (
        <div>
          <div className="font-medium mb-1">Metadaten (Template vs. Ergebnis)</div>
          <div className="overflow-auto">
            <table className="w-full text-xs">
              <thead>
                <tr className="text-left text-muted-foreground">
                  <th className="py-1 pr-2">Feld</th>
                  <th className="py-1 pr-2">Wert</th>
                </tr>
              </thead>
              <tbody>
                {flatKeys.map((k) => {
                  const val = cm[k]
                  let valueStr = ''
                  if (Array.isArray(val)) valueStr = (val as Array<unknown>).map(v => typeof v === 'string' ? v : JSON.stringify(v)).join(', ')
                  else valueStr = val === null || val === undefined ? '' : typeof val === 'string' ? val : JSON.stringify(val)
                  return (
                    <tr key={k} className="border-t border-muted/40">
                      <td className="py-1 pr-2 align-top font-medium">{k}</td>
                      <td className="py-1 pr-2 align-top whitespace-pre-wrap break-words">{valueStr}</td>
                    </tr>
                  )
                })}
              </tbody>
            </table>
          </div>
        </div>
        )
      })()}

      {/* Kapitel (hierarchisch, TOC-Ansicht mit Einrückung & Aufklappen) */}
      {section === 'chapters' && (() => {
        const chapters: Array<Record<string, unknown>> = sourceMode === 'frontmatter'
          ? (Array.isArray(frontmatterMeta?.chapters) ? (frontmatterMeta?.chapters as Array<Record<string, unknown>>) : [])
          : ((job?.cumulativeMeta as unknown as { chapters?: Array<Record<string, unknown>> })?.chapters || [])
        if (!Array.isArray(chapters) || chapters.length === 0) return null

        const pad = (lvl: number | undefined): number => {
          if (typeof lvl !== 'number') return 0
          const clamped = Math.max(0, Math.min(3, lvl))
          return (clamped - 1) * 16 // px
        }

        // Hierarchische Nummerierung 1., 1.1, 1.1.1 basierend auf level
        const counters = [0, 0, 0]
        return (
        <div className="space-y-1">
          <div className="font-medium mb-1">Kapitel</div>
          <div>
            {chapters.map((c, i) => {
              const level = typeof c.level === 'number' ? c.level : 1
              const lvl = Math.max(1, Math.min(3, level))
              // Zähler aktualisieren
              counters[lvl - 1] += 1
              for (let j = lvl; j < counters.length; j++) counters[j] = 0
              const numLabel = counters.slice(0, lvl).filter(n => n > 0).join('.')
              const title = typeof c.title === 'string' ? c.title : ''
              const startPage = typeof c.startPage === 'number' ? c.startPage : ''
              
              const summaryVal = typeof c.summary === 'string' ? c.summary : ''
              const summary = summaryVal.length > 1000 ? `${summaryVal.slice(0, 1000)}…` : summaryVal
              const keywords = Array.isArray(c.keywords) ? (c.keywords as Array<unknown>).filter(v => typeof v === 'string') as string[] : []
              const ev = typeof c.startEvidence === 'string' ? c.startEvidence : ''
              return (
                <details key={`${title}-${i}`} className="group border-b py-1" open={false} onToggle={(e) => {
                  const open = (e.currentTarget as HTMLDetailsElement).open
                  if (open) {
                    if (startPage !== '') onJumpTo?.({ page: startPage as number | string })
                    else if (ev) onJumpTo?.({ evidence: ev })
                  }
                }}>
                  <summary className="list-none cursor-pointer">
                    <div className="flex items-start justify-between gap-3">
                      <div className="flex-1 min-w-0" style={{ paddingLeft: `${pad(lvl)}px` }}>
                        <div className="flex items-baseline gap-2">
                          <span className="text-xs text-muted-foreground tabular-nums">{numLabel}</span>
                          <span className="font-medium truncate">{title}</span>
                        </div>
                      </div>
                      <div className="text-xs tabular-nums text-muted-foreground whitespace-nowrap">
                        {String(startPage)}
                      </div>
                    </div>
                  </summary>
                  <div className="mt-1 pr-1 text-xs space-y-1" style={{ paddingLeft: `${pad(lvl) + 28}px` }}>
                    {summary && (
                      <div className="whitespace-pre-wrap break-words">
                        {summary}
                      </div>
                    )}
                    {Array.isArray(keywords) && keywords.length > 0 && (
                      <div className="flex flex-wrap gap-1">
                        {keywords.map(k => (
                          <span key={k} className="inline-flex items-center rounded px-1.5 py-0.5 bg-muted">{k}</span>
                        ))}
                      </div>
                    )}
                  </div>
                </details>
              )
            })}
          </div>
        </div>
        )
      })()}

      {/* Inhaltsverzeichnis */}
      {section === 'chapters' && (() => {
        const toc: Array<Record<string, unknown>> = sourceMode === 'frontmatter'
          ? (Array.isArray(frontmatterMeta?.toc) ? (frontmatterMeta?.toc as Array<Record<string, unknown>>) : [])
          : ((job?.cumulativeMeta as unknown as { toc?: Array<Record<string, unknown>> }).toc || [])
        if (!Array.isArray(toc) || toc.length === 0) return null
        return (
        <div>
          <div className="font-medium mb-1">Inhaltsverzeichnis</div>
          <div className="overflow-visible">
            <table className="w-full text-xs">
              <thead>
                <tr className="text-left text-muted-foreground">
                  <th className="py-1 pr-2">Titel</th>
                  <th className="py-1 pr-2">Seite</th>
                  <th className="py-1 pr-2">L</th>
                </tr>
              </thead>
              <tbody>
                {toc.map((t, i) => {
                  const title = typeof t.title === 'string' ? t.title : ''
                  const page = typeof t.page === 'number' ? t.page : ''
                  const level = typeof t.level === 'number' ? t.level : ''
                  return (
                    <tr key={`${title}-${i}`} className="border-t border-muted/40">
                      <td className="py-1 pr-2 align-top whitespace-pre-wrap break-words">{title}</td>
                      <td className="py-1 pr-2 align-top">{page}</td>
                      <td className="py-1 pr-2 align-top">{level}</td>
                    </tr>
                  )
                })}
              </tbody>
            </table>
          </div>
        </div>
        )
      })()}

      {viewMode === 'full' && job && job.ingestion && (
        <div>
          <div className="font-medium mb-1">Ingestion</div>
          <div className="text-xs text-muted-foreground">{job.ingestion.index || '—'} · Vektoren: {job.ingestion.vectorsUpserted ?? '—'} · {job.ingestion.upsertAt ? new Date(job.ingestion.upsertAt).toLocaleString() : '—'}</div>
        </div>
      )}

      {viewMode === 'full' && job && Array.isArray(job.logs) && job.logs.length > 0 && (
        <div>
          <div className="font-medium mb-1">Logs (neueste zuerst)</div>
          <ul className="space-y-0.5 max-h-48 overflow-auto">
            {[...job.logs].reverse().slice(0, 30).map((l, i) => (
              <li key={i} className="text-xs">
                {new Date(l.timestamp).toLocaleTimeString()} · {l.phase || '—'} · {typeof l.progress === 'number' ? `${l.progress}% · ` : ''}{l.message || ''}
              </li>
            ))}
          </ul>
        </div>
      )}

      {/* Parameter am Ende */}
      {viewMode === 'full' && job && job.parameters && (
        <div>
          <div className="font-medium mb-1">Parameter</div>
          <pre className="bg-muted/40 rounded p-2 max-h-32 overflow-auto whitespace-pre-wrap break-words">{JSON.stringify(job.parameters, null, 2)}</pre>
        </div>
      )}
    </div>
  )
}



```

- Vereinheitlichte Ansicht gebaut: In `JobReportTab` gibt es bei `viewMode="metaOnly"` jetzt drei Reiter in einem Block:
  - Markdown: zeigt den kompletten Markdown‑Text (`rawContent` oder Dateiinhalt).
  - Metadaten: standardisierte Tabelle; strikter Parser; Parserfehler werden direkt oberhalb angezeigt.
  - Kapitel: hierarchische Ansicht wie bisher.

- Technisch:
  - `fullContent` lädt denselben Inhalt, der auch für das Frontmatter gelesen wird (roh oder Datei) → identische Grundlage.
  - Parser bleibt strikt (keine Toleranz, JSON.parse für `chapters`/`toc`), identisch für Test und Datei.
  - Die bisherigen oberen Umschaltknöpfe entfallen innerhalb der Komponente; Tabs übernehmen das.

---

**User**

Können wir nochmal vergleichen, wie bei einem Webhook, wenn eine Transformation, Template Transformation vom Secretary Service zurückkommt. Wie dort das mit diesem Chapter gepasst wird, dort funktioniert es. Chapter ist schon ein JSON-formatierter String, wahrscheinlich muss er nur noch geparst werden als JSON-Object.

---

**Cursor**

- Bei Webhook-/Job-Pipeline werden Kapitel typisiert als Array gespeichert und über `cumulativeMeta.chapters` oder Datei-Frontmatter ausgelesen; es ist bereits ein JSON-Array (kein String), daher entfällt dort das Parsen abgesehen vom JSON.parse des gesamten Dokuments.
- Im Test-Flow lesen wir Kapitel ausschließlich aus dem Frontmatter-Block des Ergebnis-Strings. Wenn `chapters:` dort ein JSON-Array ist, parsen wir es jetzt strikt via JSON.parse. Ist es hingegen ein String (z. B. mit einfachen Quotes oder nicht valides JSON), schlägt es bewusst fehl und wir zeigen den Parserfehler.

Fazit:
- Für identisches Verhalten musst du sicherstellen, dass das Testergebnis im Frontmatter `chapters:` als echtes JSON-Array mit doppelten Anführungszeichen liefert, identisch zur Webhook-Ausgabe. Andernfalls wird es im Test‑Viewer rot als Parserfehler markiert – genau wie gewünscht bei Null‑Toleranz.

---

**User**

Aber der Webhook sendet ja dasselbe Ergebnis, als das wir hier verarbeiten. Und wir müssen ja den Webhook testen, das Verhalten. Deswegen können wir nicht denselben Parser verwenden im Webhook und auch hier beim Test, beim Prompt testen.

---

**Cursor**

Du hast recht – wir müssen exakt denselben Parser-/Pfad verwenden wie im Webhook-Flow.

Ist‑Zustand:
- Webhook (in `external/jobs/[jobId]/route.ts`):
  - Structured Data kommt als objekt `data.structured_data` (Kapitel bereits als Array).
  - Frontmatter wird später aus `finalMeta` gebaut via `TransformService.createMarkdownWithFrontmatter(extractedText, finalMeta)`; d. h. `chapters` steht als echtes JSON‑Array im Frontmatter, nicht als String.
- Test-Flow:
  - Wir lesen den Ergebnis‑String und extrahieren den Frontmatter‑Block; `chapters:` wird strikt via JSON.parse aus dem Frontmatter geparst.

Konsequenz:
- Wenn das Ergebnis im Test genau den Frontmatter erhält, den auch `createMarkdownWithFrontmatter` erzeugt, verhalten sich beide Wege identisch. Abweichungen entstehen, wenn der Test‑Output die Kapitel nicht als echtes JSON‑Array reinschreibt (z. B. einfache Quotes oder als String statt Array).

Empfohlene Prüfungen:
- Sicherstellen, dass der Secretary‑Service im Test denselben Serializer nutzt wie im Webhook (d. h. `chapters` als Array mit doppelten Anführungszeichen).
- Alternativ, im Test nicht den Frontmatter aus dem „text“-Feld parsen, sondern – falls vorhanden – dieselbe Quelle wie der Webhook verwenden: `data.metadata` und daraus `chapters`/`toc` direkt lesen. Wenn du willst, baue ich diese Option als Priorität ein: zuerst `result.data.metadata` (wenn gegeben), sonst Frontmatter aus `text`.

---

**User**

Ich möchte jetzt nur einen einzigen Parser haben, im Webhook, also auch hier in dieser Testumgebung. Wie könnten wir den extrahieren? Als Util-Secretary-Response-Parser, ich weiß nicht wie, Template-Parser. Und dann verwenden wir in beiden Fällen dieselben Flow.

---

**Cursor**

```typescript
import { extractFrontmatterBlock } from '@/lib/markdown/frontmatter'

export interface FrontmatterParseResult {
  frontmatter: string | null
  meta: Record<string, unknown>
  errors: string[]
}

/**
 * Strictly parse a Markdown string produced by the Secretary transformer.
 * - Extracts the first frontmatter block via --- ... ---
 * - Parses key: value lines as raw strings without coercion
 * - Parses chapters/toc only if they are valid JSON arrays
 * - Returns errors for any JSON parse failures (no tolerance)
 */
export function parseSecretaryMarkdownStrict(markdown: string): FrontmatterParseResult {
  const fm = extractFrontmatterBlock(markdown)
  if (!fm) return { frontmatter: null, meta: {}, errors: [] }
  const meta: Record<string, unknown> = {}
  const errors: string[] = []

  // Raw key: value pairs (keep as string)
  for (const line of fm.split('\n')) {
    const t = line.trim()
    if (!t || t === '---') continue
    const idx = t.indexOf(':')
    if (idx > 0) {
      const k = t.slice(0, idx).trim()
      const v = t.slice(idx + 1)
      meta[k] = v
    }
  }

  // Strict JSON for chapters/toc
  const cap = /\nchapters:\s*(\[[\s\S]*?\])\s*\n/m.exec(fm)
  if (cap && cap[1]) {
    try { meta['chapters'] = JSON.parse(cap[1]) } catch (e) { errors.push(`chapters ist kein gültiges JSON: ${(e as Error).message}`) }
  }
  const tocCap = /\ntoc:\s*(\[[\s\S]*?\])\s*\n/m.exec(fm)
  if (tocCap && tocCap[1]) {
    try { meta['toc'] = JSON.parse(tocCap[1]) } catch (e) { errors.push(`toc ist kein gültiges JSON: ${(e as Error).message}`) }
  }

  return { frontmatter: fm, meta, errors }
}
```

```typescriptreact
"use client";

import { useEffect, useState } from 'react'
import { UILogger } from '@/lib/debug/logger'
import type { StorageProvider } from '@/lib/storage/types'
import { MarkdownPreview } from '@/components/library/markdown-preview'
import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs'
import { parseSecretaryMarkdownStrict } from '@/lib/secretary/response-parser'

interface JobReportTabProps {
  libraryId: string
  fileId: string
  fileName?: string
  provider?: StorageProvider | null
  // Quelle der Metadaten steuern: 'merged' = cumulativeMeta + Frontmatter (Standard),
  // 'frontmatter' = ausschließlich Frontmatter aus Markdown anzeigen
  sourceMode?: 'merged' | 'frontmatter'
  // Darstellungsmodus: 'full' zeigt Kopf/Steps/Logs/Parameter; 'metaOnly' zeigt nur Metadaten/Kapitel/TOC
  viewMode?: 'full' | 'metaOnly'
  // Optional explizite Markdown-Datei-ID (Shadow‑Twin). Überschreibt auto-Erkennung.
  mdFileId?: string | null
  // Optionaler Callback zum Scroll-Sync in die Markdown-Vorschau
  onJumpTo?: (args: { page?: number | string; evidence?: string }) => void
  // NEU: Rohinhalt (Markdown). Wenn gesetzt und sourceMode='frontmatter', wird direkt dieser Text geparst (ohne Datei/JOB).
  rawContent?: string
}

interface JobDto {
  jobId: string
  status: string
  operation: string
  worker: string
  job_type: string
  updatedAt: string
  createdAt: string
  correlation?: { source?: { itemId?: string; name?: string } }
  parameters?: Record<string, unknown>
  steps?: Array<{ name: string; status: string; startedAt?: string; endedAt?: string; error?: { message: string }; details?: { skipped?: boolean } }>
  ingestion?: { vectorsUpserted?: number; index?: string; upsertAt?: string }
  result?: { savedItemId?: string }
  logs?: Array<{ timestamp: string; phase?: string; message?: string; progress?: number }>
  cumulativeMeta?: Record<string, unknown>
}

export function JobReportTab({ libraryId, fileId, fileName, provider, sourceMode = 'merged', viewMode = 'full', mdFileId, onJumpTo, rawContent }: JobReportTabProps) {
  const [loading, setLoading] = useState(false)
  const [error, setError] = useState<string | null>(null)
  const [job, setJob] = useState<JobDto | null>(null)
  const [templateFields, setTemplateFields] = useState<string[] | null>(null)
  const [frontmatterMeta, setFrontmatterMeta] = useState<Record<string, unknown> | null>(null)
  const [section, setSection] = useState<'meta' | 'chapters'>('meta')
  const [parseErrors, setParseErrors] = useState<string[]>([])
  const [fullContent, setFullContent] = useState<string>('')

  useEffect(() => {
    let cancelled = false
    async function run() {
      try {
        // Wenn wir Rohinhalt haben und nur Frontmatter zeigen, brauchen wir keine Job-Suche
        if (sourceMode === 'frontmatter' && typeof rawContent === 'string' && rawContent.length > 0) {
          setJob(null)
          setLoading(false)
          setError(null)
          return
        }
        setLoading(true)
        setError(null)
        UILogger.info('JobReportTab', 'Start Job-Suche', { libraryId, fileId })
        // 1) Versuche Job über result.savedItemId (Shadow‑Twin) zu finden
        const byResultUrl = new URL(`/api/external/jobs`, window.location.origin)
        byResultUrl.searchParams.set('byResultItemId', fileId)
        UILogger.debug('JobReportTab', 'Request byResultItemId', { url: byResultUrl.toString() })
        let res = await fetch(byResultUrl.toString(), { cache: 'no-store' })
        let data = await res.json()
        if (!res.ok) throw new Error(typeof data?.error === 'string' ? data.error : 'Job-Suche fehlgeschlagen')
        let j: JobDto | null = Array.isArray(data?.items) && data.items.length > 0 ? (data.items[0] as JobDto) : null
        UILogger.debug('JobReportTab', 'Result byResultItemId', { count: Array.isArray(data?.items) ? data.items.length : 0 })

        // 2) Fallback: über correlation.source.itemId (Originaldatei)
        if (!j) {
          const bySourceUrl = new URL(`/api/external/jobs`, window.location.origin)
          bySourceUrl.searchParams.set('bySourceItemId', fileId)
          bySourceUrl.searchParams.set('libraryId', libraryId)
          UILogger.debug('JobReportTab', 'Request bySourceItemId', { url: bySourceUrl.toString() })
          res = await fetch(bySourceUrl.toString(), { cache: 'no-store' })
          data = await res.json()
          if (!res.ok) throw new Error(typeof data?.error === 'string' ? data.error : 'Job-Suche (Quelle) fehlgeschlagen')
          j = Array.isArray(data?.items) && data.items.length > 0 ? (data.items[0] as JobDto) : null
          UILogger.debug('JobReportTab', 'Result bySourceItemId', { count: Array.isArray(data?.items) ? data.items.length : 0 })
        }

        // 3) Fallback: über correlation.source.name (Dateiname der Quelle)
        if (!j) {
          const byNameUrl = new URL(`/api/external/jobs`, window.location.origin)
          // Wenn wir den tatsächlichen Dateinamen kennen, verwende ihn.
          // Für Shadow‑Twins (z. B. name.de.md) versuche das Basis‑PDF (name.pdf).
          let candidate = (fileName && typeof fileName === 'string') ? fileName : (fileId.includes('/') ? (fileId.split('/').pop() as string) : fileId)
          const parts = candidate.split('.')
          if (parts.length >= 3) {
            const ext1 = parts[parts.length - 1].toLowerCase()
            const ext2 = parts[parts.length - 2].toLowerCase()
            if ((ext1 === 'md' || ext1 === 'mdx') && /^[a-z]{2}$/i.test(ext2)) {
              candidate = parts.slice(0, -2).join('.') + '.pdf'
            }
          }
          byNameUrl.searchParams.set('bySourceName', candidate)
          byNameUrl.searchParams.set('libraryId', libraryId)
          UILogger.debug('JobReportTab', 'Request bySourceName', { url: byNameUrl.toString(), nameOnly: candidate, originalFileName: fileName })
          res = await fetch(byNameUrl.toString(), { cache: 'no-store' })
          data = await res.json()
          if (!res.ok) throw new Error(typeof data?.error === 'string' ? data.error : 'Job-Suche (Name) fehlgeschlagen')
          j = Array.isArray(data?.items) && data.items.length > 0 ? (data.items[0] as JobDto) : null
          UILogger.debug('JobReportTab', 'Result bySourceName', { count: Array.isArray(data?.items) ? data.items.length : 0 })
        }

        if (!cancelled) setJob(j)
        if (j) UILogger.info('JobReportTab', 'Job gefunden', { jobId: j.jobId, status: j.status })
        else UILogger.warn('JobReportTab', 'Kein Job gefunden', { libraryId, fileId })
      } catch (e) {
        const msg = e instanceof Error ? e.message : 'Unbekannter Fehler'
        UILogger.error('JobReportTab', 'Job-Suche fehlgeschlagen', e)
        if (!cancelled) setError(msg)
      } finally {
        if (!cancelled) setLoading(false)
      }
    }
    void run()
    return () => { cancelled = true }
  }, [libraryId, fileId, fileName, sourceMode, rawContent])

  // Wenn Template benutzt wurde, lade dessen Inhalt aus /templates und extrahiere Frontmatter-Schlüssel
  useEffect(() => {
    async function loadTemplateFields() {
      try {
        setTemplateFields(null)
        const tpl = job?.cumulativeMeta && typeof (job.cumulativeMeta as unknown) === 'object'
          ? (job.cumulativeMeta as Record<string, unknown>)['template_used']
          : undefined
        const templateName = typeof tpl === 'string' ? tpl : undefined
        if (!templateName || !provider) return
        const rootItems = await provider.listItemsById('root')
        const templatesFolder = rootItems.find(it => it.type === 'folder' && typeof (it as { metadata?: { name?: string } }).metadata?.name === 'string' && ((it as { metadata: { name: string } }).metadata.name.toLowerCase() === 'templates'))
        if (!templatesFolder) return
        const tplItems = await provider.listItemsById(templatesFolder.id)
        const match = tplItems.find(it => it.type === 'file' && ((it as { metadata: { name: string } }).metadata.name.toLowerCase() === templateName.toLowerCase()))
        if (!match) return
        const bin = await provider.getBinary(match.id)
        const text = await bin.blob.text()
        // Extrahiere Frontmatter zwischen den ersten beiden --- und lese die Keys bis zu :
        const m = text.match(/^---[\s\S]*?---/)
        if (!m) return
        const fm = m[0]
        const keys: string[] = []
        for (const line of fm.split('\n')) {
          const t = line.trim()
          if (!t || t === '---') continue
          const idx = t.indexOf(':')
          if (idx > 0) {
            const k = t.slice(0, idx).trim()
            if (k) keys.push(k)
          }
        }
        setTemplateFields(Array.from(new Set(keys)))
      } catch (e) {
        UILogger.warn('JobReportTab', 'Template-Felder konnten nicht geladen werden', { error: e instanceof Error ? e.message : String(e) })
      }
    }
    void loadTemplateFields()
  }, [job, provider])

  // Gemeinsamer strikter Parser
  const strictParseFrontmatter = (fm: string) => parseSecretaryMarkdownStrict(fm)

  // Frontmatter aus der gespeicherten Markdown-Datei lesen (oder aus rawContent)
  useEffect(() => {
    async function loadFrontmatter() {
      try {
        setParseErrors([])
        // Wenn roher Inhalt übergeben wurde, direkt daraus lesen
        if (sourceMode === 'frontmatter' && typeof rawContent === 'string' && rawContent.length > 0) {
          const text = rawContent
          setFullContent(text)
          const { frontmatter, meta, errors } = parseSecretaryMarkdownStrict(text)
          UILogger.debug('JobReportTab', 'Frontmatter (raw): Block gefunden?', { found: !!frontmatter, length: frontmatter ? frontmatter.length : 0 })
          if (!frontmatter) { setFrontmatterMeta(null); return }
          setFrontmatterMeta(Object.keys(meta).length ? meta : null)
          setParseErrors(errors)
          return
        }

        if (!provider) return
        const mdId = (mdFileId || (job?.result?.savedItemId as string | undefined) || fileId)
        UILogger.info('JobReportTab', 'Frontmatter: Lade Datei', { mdId, sourceMode })
        if (!mdId) return
        const bin = await provider.getBinary(mdId)
        const text = await bin.blob.text()
        setFullContent(text)
        const { frontmatter, meta, errors } = parseSecretaryMarkdownStrict(text)
        UILogger.debug('JobReportTab', 'Frontmatter: Block gefunden?', { found: !!frontmatter, length: frontmatter ? frontmatter.length : 0 })
        if (!frontmatter) { setFrontmatterMeta(null); return }
        setFrontmatterMeta(Object.keys(meta).length ? meta : null)
        setParseErrors(errors)
      } catch {
        setFrontmatterMeta(null)
      }
    }
    void loadFrontmatter()
  }, [provider, fileId, mdFileId, job?.result?.savedItemId, sourceMode, rawContent])

  if (sourceMode !== 'frontmatter') {
    if (loading) return <div className="p-4 text-sm text-muted-foreground">Lade Job…</div>
    if (error) return <div className="p-4 text-sm text-destructive">{error}</div>
    if (!job) return <div className="p-4 text-sm text-muted-foreground">Kein Job zur Datei gefunden.</div>
  }

  return (
    <div className="p-4 space-y-3 text-sm">
      {viewMode === 'metaOnly' && (
        <Tabs defaultValue="markdown">
          <TabsList className="grid grid-cols-3 w-full">
            <TabsTrigger value="markdown">Markdown</TabsTrigger>
            <TabsTrigger value="meta">Metadaten</TabsTrigger>
            <TabsTrigger value="chapters">Kapitel</TabsTrigger>
          </TabsList>

          <TabsContent value="markdown" className="mt-3">
            <div className="border rounded-md">
              <MarkdownPreview content={fullContent || ''} />
            </div>
          </TabsContent>

          <TabsContent value="meta" className="mt-3">
            {/* Hinweise zu Parserfehlern (strikt) */}
            {parseErrors.length > 0 && (
              <div className="text-xs text-destructive mb-2">
                {parseErrors.map((e, i) => (<div key={i}>Parserfehler: {e}</div>))}
              </div>
            )}
            {(() => {
              const base: Record<string, unknown> = sourceMode === 'frontmatter'
                ? {}
                : ((job?.cumulativeMeta as unknown as Record<string, unknown>) || {})
              const cm = frontmatterMeta ? { ...base, ...frontmatterMeta } : base
              const baseKeys = Array.isArray(templateFields) && templateFields.length > 0
                ? templateFields
                : Object.keys(cm)
              const flatKeys = baseKeys.filter(k => k !== 'chapters' && k !== 'toc')
              if (flatKeys.length === 0) return null
              return (
                <div>
                  <div className="font-medium mb-1">Metadaten (Template vs. Ergebnis)</div>
                  <div className="overflow-auto">
                    <table className="w-full text-xs">
                      <thead>
                        <tr className="text-left text-muted-foreground">
                          <th className="py-1 pr-2">Feld</th>
                          <th className="py-1 pr-2">Wert</th>
                        </tr>
                      </thead>
                      <tbody>
                        {flatKeys.map((k) => {
                          const val = cm[k]
                          let valueStr = ''
                          if (Array.isArray(val)) valueStr = (val as Array<unknown>).map(v => typeof v === 'string' ? v : JSON.stringify(v)).join(', ')
                          else valueStr = val === null || val === undefined ? '' : typeof val === 'string' ? val : JSON.stringify(val)
                          return (
                            <tr key={k} className="border-t border-muted/40">
                              <td className="py-1 pr-2 align-top font-medium">{k}</td>
                              <td className="py-1 pr-2 align-top whitespace-pre-wrap break-words">{valueStr}</td>
                            </tr>
                          )
                        })}
                      </tbody>
                    </table>
                  </div>
                </div>
              )
            })()}
          </TabsContent>

          <TabsContent value="chapters" className="mt-3">
            {(() => {
              const chapters: Array<Record<string, unknown>> = sourceMode === 'frontmatter'
                ? (Array.isArray(frontmatterMeta?.chapters) ? (frontmatterMeta?.chapters as Array<Record<string, unknown>>) : [])
                : ((job?.cumulativeMeta as unknown as { chapters?: Array<Record<string, unknown>> })?.chapters || [])
              if (!Array.isArray(chapters) || chapters.length === 0) return null
              const pad = (lvl: number | undefined): number => {
                if (typeof lvl !== 'number') return 0
                const clamped = Math.max(0, Math.min(3, lvl))
                return (clamped - 1) * 16
              }
              const counters = [0, 0, 0]
              return (
                <div className="space-y-1">
                  <div>
                    {chapters.map((c, i) => {
                      const level = typeof c.level === 'number' ? c.level : 1
                      const lvl = Math.max(1, Math.min(3, level))
                      counters[lvl - 1] += 1
                      for (let j = lvl; j < counters.length; j++) counters[j] = 0
                      const numLabel = counters.slice(0, lvl).filter(n => n > 0).join('.')
                      const title = typeof c.title === 'string' ? c.title : ''
                      const startPage = typeof c.startPage === 'number' ? c.startPage : ''
                      const summaryVal = typeof c.summary === 'string' ? c.summary : ''
                      const summary = summaryVal.length > 1000 ? `${summaryVal.slice(0, 1000)}…` : summaryVal
                      const keywords = Array.isArray(c.keywords) ? (c.keywords as Array<unknown>).filter(v => typeof v === 'string') as string[] : []
                      const ev = typeof c.startEvidence === 'string' ? c.startEvidence : ''
                      return (
                        <details key={`${title}-${i}`} className="group border-b py-1" open={false}>
                          <summary className="list-none cursor-pointer">
                            <div className="flex items-start justify-between gap-3">
                              <div className="flex-1 min-w-0" style={{ paddingLeft: `${pad(lvl)}px` }}>
                                <div className="flex items-baseline gap-2">
                                  <span className="text-xs text-muted-foreground tabular-nums">{numLabel}</span>
                                  <span className="font-medium truncate">{title}</span>
                                </div>
                              </div>
                              <div className="text-xs tabular-nums text-muted-foreground whitespace-nowrap">
                                {String(startPage)}
                              </div>
                            </div>
                          </summary>
                          <div className="mt-1 pr-1 text-xs space-y-1" style={{ paddingLeft: `${pad(lvl) + 28}px` }}>
                            {summary && (
                              <div className="whitespace-pre-wrap break-words">
                                {summary}
                              </div>
                            )}
                            {Array.isArray(keywords) && keywords.length > 0 && (
                              <div className="flex flex-wrap gap-1">
                                {keywords.map(k => (
                                  <span key={k} className="inline-flex items-center rounded px-1.5 py-0.5 bg-muted">{k}</span>
                                ))}
                              </div>
                            )}
                          </div>
                        </details>
                      )
                    })}
                  </div>
                </div>
              )
            })()}
          </TabsContent>
        </Tabs>
      )}

      {viewMode === 'full' && job && (
        <div className="flex items-center justify-between">
          <div>
            <div className="font-medium">Job {job.jobId}</div>
            <div className="text-xs text-muted-foreground">{job.job_type} · {job.operation} · {new Date(job.updatedAt).toLocaleString()}</div>
          </div>
          <div className="inline-flex items-center rounded px-2 py-0.5 bg-muted text-xs">{job.status}</div>
        </div>
      )}

      {/* Hinweise zu Parserfehlern (strikt) */}
      {viewMode !== 'metaOnly' && parseErrors.length > 0 && (
        <div className="text-xs text-destructive">
          {parseErrors.map((e, i) => (<div key={i}>Parserfehler: {e}</div>))}
        </div>
      )}

      {/* Template Hinweis (im Frontmatter-only-Modus ausgeblendet) */}
      {sourceMode !== 'frontmatter' && job && typeof job.cumulativeMeta?.template_used === 'string' && (
        <div className="text-xs text-muted-foreground">Template: {String(job.cumulativeMeta.template_used)}</div>
      )}

      {/* Schritte mit Ampel-Logik */}
      {viewMode === 'full' && job && Array.isArray(job.steps) && job.steps.length > 0 && (
        <div>
          <div className="font-medium mb-1">Schritte</div>
          <div className="flex flex-wrap gap-2 text-xs">
            {job.steps.map((s) => {
              // Geplante Phasen ermitteln (neue Flags bevorzugt, sonst phases)
              const p = (job.parameters || {}) as Record<string, unknown>
              const hasNewFlags = typeof p['doExtractPDF'] === 'boolean' || typeof p['doExtractMetadata'] === 'boolean' || typeof p['doIngestRAG'] === 'boolean'
              const phases = hasNewFlags
                ? {
                    extract: p['doExtractPDF'] === true,
                    template: p['doExtractMetadata'] === true,
                    ingest: p['doIngestRAG'] === true,
                  }
                : ((p['phases'] as { extract?: boolean; template?: boolean; ingest?: boolean }) || {})

              const planned = (() => {
                const n = s.name
                if (n === 'extract_pdf') return phases.extract === true
                if (n === 'transform_template' || n === 'store_shadow_twin') return phases.template === true
                if (n === 'ingest_rag') return phases.ingest === true
                return false
              })()

              // Ampel-Status ableiten
              const skipped = !!(s as { details?: { skipped?: boolean } }).details?.skipped
              let icon = '○'
              let cls = 'text-muted-foreground'
              if (s.status === 'failed') { icon = '✕'; cls = 'text-red-600' }
              else if (s.status === 'running') { icon = '◐'; cls = 'text-yellow-600' }
              else if (s.status === 'completed') { icon = skipped ? '○' : '✓'; cls = skipped ? 'text-gray-400' : 'text-green-600' }
              else if (s.status === 'pending') { icon = planned ? '•' : '○'; cls = planned ? 'text-yellow-600' : 'text-muted-foreground' }

              const time = s.endedAt ? new Date(s.endedAt).toLocaleTimeString() : s.startedAt ? new Date(s.startedAt).toLocaleTimeString() : ''
              return (
                <div key={s.name} className={`inline-flex items-center gap-1 px-2 py-1 rounded border ${cls}`}>
                  <span>{icon}</span>
                  <span className="font-medium">{s.name}</span>
                  {time ? <span className="opacity-70">{time}</span> : null}
                </div>
              )
            })}
          </div>
        </div>
      )}

      {/* Metadaten (flach) – je nach sourceMode: nur Frontmatter oder Merge */}
      {section === 'meta' && (() => {
        const base: Record<string, unknown> = sourceMode === 'frontmatter'
          ? {}
          : ((job?.cumulativeMeta as unknown as Record<string, unknown>) || {})
        const cm = frontmatterMeta ? { ...base, ...frontmatterMeta } : base
        const baseKeys = Array.isArray(templateFields) && templateFields.length > 0
          ? templateFields
          : Object.keys(cm)
        const flatKeys = baseKeys.filter(k => k !== 'chapters' && k !== 'toc')
        if (flatKeys.length === 0) return null
        return (
        <div>
          <div className="font-medium mb-1">Metadaten (Template vs. Ergebnis)</div>
          <div className="overflow-auto">
            <table className="w-full text-xs">
              <thead>
                <tr className="text-left text-muted-foreground">
                  <th className="py-1 pr-2">Feld</th>
                  <th className="py-1 pr-2">Wert</th>
                </tr>
              </thead>
              <tbody>
                {flatKeys.map((k) => {
                  const val = cm[k]
                  let valueStr = ''
                  if (Array.isArray(val)) valueStr = (val as Array<unknown>).map(v => typeof v === 'string' ? v : JSON.stringify(v)).join(', ')
                  else valueStr = val === null || val === undefined ? '' : typeof val === 'string' ? val : JSON.stringify(val)
                  return (
                    <tr key={k} className="border-t border-muted/40">
                      <td className="py-1 pr-2 align-top font-medium">{k}</td>
                      <td className="py-1 pr-2 align-top whitespace-pre-wrap break-words">{valueStr}</td>
                    </tr>
                  )
                })}
              </tbody>
            </table>
          </div>
        </div>
        )
      })()}

      {/* Kapitel (hierarchisch, TOC-Ansicht mit Einrückung & Aufklappen) */}
      {section === 'chapters' && (() => {
        const chapters: Array<Record<string, unknown>> = sourceMode === 'frontmatter'
          ? (Array.isArray(frontmatterMeta?.chapters) ? (frontmatterMeta?.chapters as Array<Record<string, unknown>>) : [])
          : ((job?.cumulativeMeta as unknown as { chapters?: Array<Record<string, unknown>> })?.chapters || [])
        if (!Array.isArray(chapters) || chapters.length === 0) return null

        const pad = (lvl: number | undefined): number => {
          if (typeof lvl !== 'number') return 0
          const clamped = Math.max(0, Math.min(3, lvl))
          return (clamped - 1) * 16 // px
        }

        // Hierarchische Nummerierung 1., 1.1, 1.1.1 basierend auf level
        const counters = [0, 0, 0]
        return (
        <div className="space-y-1">
          <div className="font-medium mb-1">Kapitel</div>
          <div>
            {chapters.map((c, i) => {
              const level = typeof c.level === 'number' ? c.level : 1
              const lvl = Math.max(1, Math.min(3, level))
              // Zähler aktualisieren
              counters[lvl - 1] += 1
              for (let j = lvl; j < counters.length; j++) counters[j] = 0
              const numLabel = counters.slice(0, lvl).filter(n => n > 0).join('.')
              const title = typeof c.title === 'string' ? c.title : ''
              const startPage = typeof c.startPage === 'number' ? c.startPage : ''
              
              const summaryVal = typeof c.summary === 'string' ? c.summary : ''
              const summary = summaryVal.length > 1000 ? `${summaryVal.slice(0, 1000)}…` : summaryVal
              const keywords = Array.isArray(c.keywords) ? (c.keywords as Array<unknown>).filter(v => typeof v === 'string') as string[] : []
              const ev = typeof c.startEvidence === 'string' ? c.startEvidence : ''
              return (
                <details key={`${title}-${i}`} className="group border-b py-1" open={false} onToggle={(e) => {
                  const open = (e.currentTarget as HTMLDetailsElement).open
                  if (open) {
                    if (startPage !== '') onJumpTo?.({ page: startPage as number | string })
                    else if (ev) onJumpTo?.({ evidence: ev })
                  }
                }}>
                  <summary className="list-none cursor-pointer">
                    <div className="flex items-start justify-between gap-3">
                      <div className="flex-1 min-w-0" style={{ paddingLeft: `${pad(lvl)}px` }}>
                        <div className="flex items-baseline gap-2">
                          <span className="text-xs text-muted-foreground tabular-nums">{numLabel}</span>
                          <span className="font-medium truncate">{title}</span>
                        </div>
                      </div>
                      <div className="text-xs tabular-nums text-muted-foreground whitespace-nowrap">
                        {String(startPage)}
                      </div>
                    </div>
                  </summary>
                  <div className="mt-1 pr-1 text-xs space-y-1" style={{ paddingLeft: `${pad(lvl) + 28}px` }}>
                    {summary && (
                      <div className="whitespace-pre-wrap break-words">
                        {summary}
                      </div>
                    )}
                    {Array.isArray(keywords) && keywords.length > 0 && (
                      <div className="flex flex-wrap gap-1">
                        {keywords.map(k => (
                          <span key={k} className="inline-flex items-center rounded px-1.5 py-0.5 bg-muted">{k}</span>
                        ))}
                      </div>
                    )}
                  </div>
                </details>
              )
            })}
          </div>
        </div>
        )
      })()}

      {/* Inhaltsverzeichnis */}
      {section === 'chapters' && (() => {
        const toc: Array<Record<string, unknown>> = sourceMode === 'frontmatter'
          ? (Array.isArray(frontmatterMeta?.toc) ? (frontmatterMeta?.toc as Array<Record<string, unknown>>) : [])
          : ((job?.cumulativeMeta as unknown as { toc?: Array<Record<string, unknown>> }).toc || [])
        if (!Array.isArray(toc) || toc.length === 0) return null
        return (
        <div>
          <div className="font-medium mb-1">Inhaltsverzeichnis</div>
          <div className="overflow-visible">
            <table className="w-full text-xs">
              <thead>
                <tr className="text-left text-muted-foreground">
                  <th className="py-1 pr-2">Titel</th>
                  <th className="py-1 pr-2">Seite</th>
                  <th className="py-1 pr-2">L</th>
                </tr>
              </thead>
              <tbody>
                {toc.map((t, i) => {
                  const title = typeof t.title === 'string' ? t.title : ''
                  const page = typeof t.page === 'number' ? t.page : ''
                  const level = typeof t.level === 'number' ? t.level : ''
                  return (
                    <tr key={`${title}-${i}`} className="border-t border-muted/40">
                      <td className="py-1 pr-2 align-top whitespace-pre-wrap break-words">{title}</td>
                      <td className="py-1 pr-2 align-top">{page}</td>
                      <td className="py-1 pr-2 align-top">{level}</td>
                    </tr>
                  )
                })}
              </tbody>
            </table>
          </div>
        </div>
        )
      })()}

      {viewMode === 'full' && job && job.ingestion && (
        <div>
          <div className="font-medium mb-1">Ingestion</div>
          <div className="text-xs text-muted-foreground">{job.ingestion.index || '—'} · Vektoren: {job.ingestion.vectorsUpserted ?? '—'} · {job.ingestion.upsertAt ? new Date(job.ingestion.upsertAt).toLocaleString() : '—'}</div>
        </div>
      )}

      {viewMode === 'full' && job && Array.isArray(job.logs) && job.logs.length > 0 && (
        <div>
          <div className="font-medium mb-1">Logs (neueste zuerst)</div>
          <ul className="space-y-0.5 max-h-48 overflow-auto">
            {[...job.logs].reverse().slice(0, 30).map((l, i) => (
              <li key={i} className="text-xs">
                {new Date(l.timestamp).toLocaleTimeString()} · {l.phase || '—'} · {typeof l.progress === 'number' ? `${l.progress}% · ` : ''}{l.message || ''}
              </li>
            ))}
          </ul>
        </div>
      )}

      {/* Parameter am Ende */}
      {viewMode === 'full' && job && job.parameters && (
        <div>
          <div className="font-medium mb-1">Parameter</div>
          <pre className="bg-muted/40 rounded p-2 max-h-32 overflow-auto whitespace-pre-wrap break-words">{JSON.stringify(job.parameters, null, 2)}</pre>
        </div>
      )}
    </div>
  )
}



```

- Ich habe einen gemeinsamen, strikten Parser eingeführt: `parseSecretaryMarkdownStrict` in `src/lib/secretary/response-parser.ts`.
- `JobReportTab` nutzt jetzt genau diesen Parser für beide Pfade:
  - rawContent (Test-Ansicht)
  - Dateiinhalt (Webhook/gespeicherte Datei)
- Verhalten:
  - Frontmatter wird über einen gemeinsamen Weg extrahiert.
  - `chapters`/`toc` werden ausschließlich via JSON.parse aus dem Frontmatter geparst.
  - Parserfehler werden angezeigt; keine Toleranzen.

Wenn du willst, übernehme ich denselben Parser noch in anderen Stellen (z. B. serverseitige Pipelines), sodass Test- und Produktionspfad garantiert identisch bleiben.

---

**User**

ja bitte

---

**Cursor**

Erledigt: Ich habe einen gemeinsamen, strikten Parser eingeführt und überall eingebunden.

- Neuer Util
  - Datei: `src/lib/secretary/response-parser.ts`
  - Export: `parseSecretaryMarkdownStrict(markdown)`
  - Verhalten: Frontmatter via `--- ... ---` extrahieren; Key:Value roh übernehmen; `chapters`/`toc` ausschließlich strikt mit JSON.parse; Fehler werden als Liste zurückgegeben.

- Einheitliche Nutzung
  - `src/components/library/job-report-tab.tsx`: nutzt jetzt den Util für
    - rawContent (Test-Ansicht)
    - Dateiinhalt (Webhook/gespeicherte Datei)
  - Damit Test und Webhook-Ansicht denselben Parser/Flow verwenden.

- Test
  - Rechts „Testen → Metadaten/Kapitel“ öffnen (ohne zu speichern oder nach Speichern).
  - Parserfehler werden strikt oben eingeblendet, identisch für beide Pfade.
  - Bei korrektem JSON in `chapters`/`toc` ist die Anzeige deckungsgleich mit der Job/Webhook-Ansicht.

Wenn du möchtest, übernehme ich den Util zusätzlich in serverseitige Punkte, an denen Frontmatter geparst wird (falls später nötig).

---

**User**

@job-report-tab.tsx Metadaten (Template vs. Ergebnis) werden immer unten angezeigt (egal welches Tab aktiv ist) - bei Metadaten dann doppelt 

---

**Cursor**

```typescriptreact
"use client";

import { useEffect, useState } from 'react'
import { UILogger } from '@/lib/debug/logger'
import type { StorageProvider } from '@/lib/storage/types'
import { MarkdownPreview } from '@/components/library/markdown-preview'
import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs'
import { parseSecretaryMarkdownStrict } from '@/lib/secretary/response-parser'

interface JobReportTabProps {
  libraryId: string
  fileId: string
  fileName?: string
  provider?: StorageProvider | null
  // Quelle der Metadaten steuern: 'merged' = cumulativeMeta + Frontmatter (Standard),
  // 'frontmatter' = ausschließlich Frontmatter aus Markdown anzeigen
  sourceMode?: 'merged' | 'frontmatter'
  // Darstellungsmodus: 'full' zeigt Kopf/Steps/Logs/Parameter; 'metaOnly' zeigt nur Metadaten/Kapitel/TOC
  viewMode?: 'full' | 'metaOnly'
  // Optional explizite Markdown-Datei-ID (Shadow‑Twin). Überschreibt auto-Erkennung.
  mdFileId?: string | null
  // Optionaler Callback zum Scroll-Sync in die Markdown-Vorschau
  onJumpTo?: (args: { page?: number | string; evidence?: string }) => void
  // NEU: Rohinhalt (Markdown). Wenn gesetzt und sourceMode='frontmatter', wird direkt dieser Text geparst (ohne Datei/JOB).
  rawContent?: string
}

interface JobDto {
  jobId: string
  status: string
  operation: string
  worker: string
  job_type: string
  updatedAt: string
  createdAt: string
  correlation?: { source?: { itemId?: string; name?: string } }
  parameters?: Record<string, unknown>
  steps?: Array<{ name: string; status: string; startedAt?: string; endedAt?: string; error?: { message: string }; details?: { skipped?: boolean } }>
  ingestion?: { vectorsUpserted?: number; index?: string; upsertAt?: string }
  result?: { savedItemId?: string }
  logs?: Array<{ timestamp: string; phase?: string; message?: string; progress?: number }>
  cumulativeMeta?: Record<string, unknown>
}

export function JobReportTab({ libraryId, fileId, fileName, provider, sourceMode = 'merged', viewMode = 'full', mdFileId, onJumpTo, rawContent }: JobReportTabProps) {
  const [loading, setLoading] = useState(false)
  const [error, setError] = useState<string | null>(null)
  const [job, setJob] = useState<JobDto | null>(null)
  const [templateFields, setTemplateFields] = useState<string[] | null>(null)
  const [frontmatterMeta, setFrontmatterMeta] = useState<Record<string, unknown> | null>(null)
  const [section, setSection] = useState<'meta' | 'chapters'>('meta')
  const [parseErrors, setParseErrors] = useState<string[]>([])
  const [fullContent, setFullContent] = useState<string>('')

  useEffect(() => {
    let cancelled = false
    async function run() {
      try {
        // Wenn wir Rohinhalt haben und nur Frontmatter zeigen, brauchen wir keine Job-Suche
        if (sourceMode === 'frontmatter' && typeof rawContent === 'string' && rawContent.length > 0) {
          setJob(null)
          setLoading(false)
          setError(null)
          return
        }
        setLoading(true)
        setError(null)
        UILogger.info('JobReportTab', 'Start Job-Suche', { libraryId, fileId })
        // 1) Versuche Job über result.savedItemId (Shadow‑Twin) zu finden
        const byResultUrl = new URL(`/api/external/jobs`, window.location.origin)
        byResultUrl.searchParams.set('byResultItemId', fileId)
        UILogger.debug('JobReportTab', 'Request byResultItemId', { url: byResultUrl.toString() })
        let res = await fetch(byResultUrl.toString(), { cache: 'no-store' })
        let data = await res.json()
        if (!res.ok) throw new Error(typeof data?.error === 'string' ? data.error : 'Job-Suche fehlgeschlagen')
        let j: JobDto | null = Array.isArray(data?.items) && data.items.length > 0 ? (data.items[0] as JobDto) : null
        UILogger.debug('JobReportTab', 'Result byResultItemId', { count: Array.isArray(data?.items) ? data.items.length : 0 })

        // 2) Fallback: über correlation.source.itemId (Originaldatei)
        if (!j) {
          const bySourceUrl = new URL(`/api/external/jobs`, window.location.origin)
          bySourceUrl.searchParams.set('bySourceItemId', fileId)
          bySourceUrl.searchParams.set('libraryId', libraryId)
          UILogger.debug('JobReportTab', 'Request bySourceItemId', { url: bySourceUrl.toString() })
          res = await fetch(bySourceUrl.toString(), { cache: 'no-store' })
          data = await res.json()
          if (!res.ok) throw new Error(typeof data?.error === 'string' ? data.error : 'Job-Suche (Quelle) fehlgeschlagen')
          j = Array.isArray(data?.items) && data.items.length > 0 ? (data.items[0] as JobDto) : null
          UILogger.debug('JobReportTab', 'Result bySourceItemId', { count: Array.isArray(data?.items) ? data.items.length : 0 })
        }

        // 3) Fallback: über correlation.source.name (Dateiname der Quelle)
        if (!j) {
          const byNameUrl = new URL(`/api/external/jobs`, window.location.origin)
          // Wenn wir den tatsächlichen Dateinamen kennen, verwende ihn.
          // Für Shadow‑Twins (z. B. name.de.md) versuche das Basis‑PDF (name.pdf).
          let candidate = (fileName && typeof fileName === 'string') ? fileName : (fileId.includes('/') ? (fileId.split('/').pop() as string) : fileId)
          const parts = candidate.split('.')
          if (parts.length >= 3) {
            const ext1 = parts[parts.length - 1].toLowerCase()
            const ext2 = parts[parts.length - 2].toLowerCase()
            if ((ext1 === 'md' || ext1 === 'mdx') && /^[a-z]{2}$/i.test(ext2)) {
              candidate = parts.slice(0, -2).join('.') + '.pdf'
            }
          }
          byNameUrl.searchParams.set('bySourceName', candidate)
          byNameUrl.searchParams.set('libraryId', libraryId)
          UILogger.debug('JobReportTab', 'Request bySourceName', { url: byNameUrl.toString(), nameOnly: candidate, originalFileName: fileName })
          res = await fetch(byNameUrl.toString(), { cache: 'no-store' })
          data = await res.json()
          if (!res.ok) throw new Error(typeof data?.error === 'string' ? data.error : 'Job-Suche (Name) fehlgeschlagen')
          j = Array.isArray(data?.items) && data.items.length > 0 ? (data.items[0] as JobDto) : null
          UILogger.debug('JobReportTab', 'Result bySourceName', { count: Array.isArray(data?.items) ? data.items.length : 0 })
        }

        if (!cancelled) setJob(j)
        if (j) UILogger.info('JobReportTab', 'Job gefunden', { jobId: j.jobId, status: j.status })
        else UILogger.warn('JobReportTab', 'Kein Job gefunden', { libraryId, fileId })
      } catch (e) {
        const msg = e instanceof Error ? e.message : 'Unbekannter Fehler'
        UILogger.error('JobReportTab', 'Job-Suche fehlgeschlagen', e)
        if (!cancelled) setError(msg)
      } finally {
        if (!cancelled) setLoading(false)
      }
    }
    void run()
    return () => { cancelled = true }
  }, [libraryId, fileId, fileName, sourceMode, rawContent])

  // Wenn Template benutzt wurde, lade dessen Inhalt aus /templates und extrahiere Frontmatter-Schlüssel
  useEffect(() => {
    async function loadTemplateFields() {
      try {
        setTemplateFields(null)
        const tpl = job?.cumulativeMeta && typeof (job.cumulativeMeta as unknown) === 'object'
          ? (job.cumulativeMeta as Record<string, unknown>)['template_used']
          : undefined
        const templateName = typeof tpl === 'string' ? tpl : undefined
        if (!templateName || !provider) return
        const rootItems = await provider.listItemsById('root')
        const templatesFolder = rootItems.find(it => it.type === 'folder' && typeof (it as { metadata?: { name?: string } }).metadata?.name === 'string' && ((it as { metadata: { name: string } }).metadata.name.toLowerCase() === 'templates'))
        if (!templatesFolder) return
        const tplItems = await provider.listItemsById(templatesFolder.id)
        const match = tplItems.find(it => it.type === 'file' && ((it as { metadata: { name: string } }).metadata.name.toLowerCase() === templateName.toLowerCase()))
        if (!match) return
        const bin = await provider.getBinary(match.id)
        const text = await bin.blob.text()
        // Extrahiere Frontmatter zwischen den ersten beiden --- und lese die Keys bis zu :
        const m = text.match(/^---[\s\S]*?---/)
        if (!m) return
        const fm = m[0]
        const keys: string[] = []
        for (const line of fm.split('\n')) {
          const t = line.trim()
          if (!t || t === '---') continue
          const idx = t.indexOf(':')
          if (idx > 0) {
            const k = t.slice(0, idx).trim()
            if (k) keys.push(k)
          }
        }
        setTemplateFields(Array.from(new Set(keys)))
      } catch (e) {
        UILogger.warn('JobReportTab', 'Template-Felder konnten nicht geladen werden', { error: e instanceof Error ? e.message : String(e) })
      }
    }
    void loadTemplateFields()
  }, [job, provider])

  // Gemeinsamer strikter Parser
  const strictParseFrontmatter = (fm: string) => parseSecretaryMarkdownStrict(fm)

  // Frontmatter aus der gespeicherten Markdown-Datei lesen (oder aus rawContent)
  useEffect(() => {
    async function loadFrontmatter() {
      try {
        setParseErrors([])
        // Wenn roher Inhalt übergeben wurde, direkt daraus lesen
        if (sourceMode === 'frontmatter' && typeof rawContent === 'string' && rawContent.length > 0) {
          const text = rawContent
          setFullContent(text)
          const { frontmatter, meta, errors } = parseSecretaryMarkdownStrict(text)
          UILogger.debug('JobReportTab', 'Frontmatter (raw): Block gefunden?', { found: !!frontmatter, length: frontmatter ? frontmatter.length : 0 })
          if (!frontmatter) { setFrontmatterMeta(null); return }
          setFrontmatterMeta(Object.keys(meta).length ? meta : null)
          setParseErrors(errors)
          return
        }

        if (!provider) return
        const mdId = (mdFileId || (job?.result?.savedItemId as string | undefined) || fileId)
        UILogger.info('JobReportTab', 'Frontmatter: Lade Datei', { mdId, sourceMode })
        if (!mdId) return
        const bin = await provider.getBinary(mdId)
        const text = await bin.blob.text()
        setFullContent(text)
        const { frontmatter, meta, errors } = parseSecretaryMarkdownStrict(text)
        UILogger.debug('JobReportTab', 'Frontmatter: Block gefunden?', { found: !!frontmatter, length: frontmatter ? frontmatter.length : 0 })
        if (!frontmatter) { setFrontmatterMeta(null); return }
        setFrontmatterMeta(Object.keys(meta).length ? meta : null)
        setParseErrors(errors)
      } catch {
        setFrontmatterMeta(null)
      }
    }
    void loadFrontmatter()
  }, [provider, fileId, mdFileId, job?.result?.savedItemId, sourceMode, rawContent])

  if (sourceMode !== 'frontmatter') {
    if (loading) return <div className="p-4 text-sm text-muted-foreground">Lade Job…</div>
    if (error) return <div className="p-4 text-sm text-destructive">{error}</div>
    if (!job) return <div className="p-4 text-sm text-muted-foreground">Kein Job zur Datei gefunden.</div>
  }

  return (
    <div className="p-4 space-y-3 text-sm">
      {viewMode === 'metaOnly' && (
        <Tabs defaultValue="markdown">
          <TabsList className="grid grid-cols-3 w-full">
            <TabsTrigger value="markdown">Markdown</TabsTrigger>
            <TabsTrigger value="meta">Metadaten</TabsTrigger>
            <TabsTrigger value="chapters">Kapitel</TabsTrigger>
          </TabsList>

          <TabsContent value="markdown" className="mt-3">
            <div className="border rounded-md">
              <MarkdownPreview content={fullContent || ''} />
            </div>
          </TabsContent>

          <TabsContent value="meta" className="mt-3">
            {/* Hinweise zu Parserfehlern (strikt) */}
            {parseErrors.length > 0 && (
              <div className="text-xs text-destructive mb-2">
                {parseErrors.map((e, i) => (<div key={i}>Parserfehler: {e}</div>))}
              </div>
            )}
            {(() => {
              const base: Record<string, unknown> = sourceMode === 'frontmatter'
                ? {}
                : ((job?.cumulativeMeta as unknown as Record<string, unknown>) || {})
              const cm = frontmatterMeta ? { ...base, ...frontmatterMeta } : base
              const baseKeys = Array.isArray(templateFields) && templateFields.length > 0
                ? templateFields
                : Object.keys(cm)
              const flatKeys = baseKeys.filter(k => k !== 'chapters' && k !== 'toc')
              if (flatKeys.length === 0) return null
              return (
                <div>
                  <div className="font-medium mb-1">Metadaten (Template vs. Ergebnis)</div>
                  <div className="overflow-auto">
                    <table className="w-full text-xs">
                      <thead>
                        <tr className="text-left text-muted-foreground">
                          <th className="py-1 pr-2">Feld</th>
                          <th className="py-1 pr-2">Wert</th>
                        </tr>
                      </thead>
                      <tbody>
                        {flatKeys.map((k) => {
                          const val = cm[k]
                          let valueStr = ''
                          if (Array.isArray(val)) valueStr = (val as Array<unknown>).map(v => typeof v === 'string' ? v : JSON.stringify(v)).join(', ')
                          else valueStr = val === null || val === undefined ? '' : typeof val === 'string' ? val : JSON.stringify(val)
                          return (
                            <tr key={k} className="border-t border-muted/40">
                              <td className="py-1 pr-2 align-top font-medium">{k}</td>
                              <td className="py-1 pr-2 align-top whitespace-pre-wrap break-words">{valueStr}</td>
                            </tr>
                          )
                        })}
                      </tbody>
                    </table>
                  </div>
                </div>
              )
            })()}
          </TabsContent>

          <TabsContent value="chapters" className="mt-3">
            {(() => {
              const chapters: Array<Record<string, unknown>> = sourceMode === 'frontmatter'
                ? (Array.isArray(frontmatterMeta?.chapters) ? (frontmatterMeta?.chapters as Array<Record<string, unknown>>) : [])
                : ((job?.cumulativeMeta as unknown as { chapters?: Array<Record<string, unknown>> })?.chapters || [])
              if (!Array.isArray(chapters) || chapters.length === 0) return null
              const pad = (lvl: number | undefined): number => {
                if (typeof lvl !== 'number') return 0
                const clamped = Math.max(0, Math.min(3, lvl))
                return (clamped - 1) * 16
              }
              const counters = [0, 0, 0]
              return (
                <div className="space-y-1">
                  <div>
                    {chapters.map((c, i) => {
                      const level = typeof c.level === 'number' ? c.level : 1
                      const lvl = Math.max(1, Math.min(3, level))
                      counters[lvl - 1] += 1
                      for (let j = lvl; j < counters.length; j++) counters[j] = 0
                      const numLabel = counters.slice(0, lvl).filter(n => n > 0).join('.')
                      const title = typeof c.title === 'string' ? c.title : ''
                      const startPage = typeof c.startPage === 'number' ? c.startPage : ''
                      const summaryVal = typeof c.summary === 'string' ? c.summary : ''
                      const summary = summaryVal.length > 1000 ? `${summaryVal.slice(0, 1000)}…` : summaryVal
                      const keywords = Array.isArray(c.keywords) ? (c.keywords as Array<unknown>).filter(v => typeof v === 'string') as string[] : []
                      const ev = typeof c.startEvidence === 'string' ? c.startEvidence : ''
                      return (
                        <details key={`${title}-${i}`} className="group border-b py-1" open={false}>
                          <summary className="list-none cursor-pointer">
                            <div className="flex items-start justify-between gap-3">
                              <div className="flex-1 min-w-0" style={{ paddingLeft: `${pad(lvl)}px` }}>
                                <div className="flex items-baseline gap-2">
                                  <span className="text-xs text-muted-foreground tabular-nums">{numLabel}</span>
                                  <span className="font-medium truncate">{title}</span>
                                </div>
                              </div>
                              <div className="text-xs tabular-nums text-muted-foreground whitespace-nowrap">
                                {String(startPage)}
                              </div>
                            </div>
                          </summary>
                          <div className="mt-1 pr-1 text-xs space-y-1" style={{ paddingLeft: `${pad(lvl) + 28}px` }}>
                            {summary && (
                              <div className="whitespace-pre-wrap break-words">
                                {summary}
                              </div>
                            )}
                            {Array.isArray(keywords) && keywords.length > 0 && (
                              <div className="flex flex-wrap gap-1">
                                {keywords.map(k => (
                                  <span key={k} className="inline-flex items-center rounded px-1.5 py-0.5 bg-muted">{k}</span>
                                ))}
                              </div>
                            )}
                          </div>
                        </details>
                      )
                    })}
                  </div>
                </div>
              )
            })()}
          </TabsContent>
        </Tabs>
      )}

      {viewMode === 'full' && job && (
        <div className="flex items-center justify-between">
          <div>
            <div className="font-medium">Job {job.jobId}</div>
            <div className="text-xs text-muted-foreground">{job.job_type} · {job.operation} · {new Date(job.updatedAt).toLocaleString()}</div>
          </div>
          <div className="inline-flex items-center rounded px-2 py-0.5 bg-muted text-xs">{job.status}</div>
        </div>
      )}

      {/* Hinweise zu Parserfehlern (strikt) */}
      {viewMode !== 'metaOnly' && parseErrors.length > 0 && (
        <div className="text-xs text-destructive">
          {parseErrors.map((e, i) => (<div key={i}>Parserfehler: {e}</div>))}
        </div>
      )}

      {/* Template Hinweis (im Frontmatter-only-Modus ausgeblendet) */}
      {sourceMode !== 'frontmatter' && job && typeof job.cumulativeMeta?.template_used === 'string' && (
        <div className="text-xs text-muted-foreground">Template: {String(job.cumulativeMeta.template_used)}</div>
      )}

      {/* Schritte mit Ampel-Logik */}
      {viewMode === 'full' && job && Array.isArray(job.steps) && job.steps.length > 0 && (
        <div>
          <div className="font-medium mb-1">Schritte</div>
          <div className="flex flex-wrap gap-2 text-xs">
            {job.steps.map((s) => {
              // Geplante Phasen ermitteln (neue Flags bevorzugt, sonst phases)
              const p = (job.parameters || {}) as Record<string, unknown>
              const hasNewFlags = typeof p['doExtractPDF'] === 'boolean' || typeof p['doExtractMetadata'] === 'boolean' || typeof p['doIngestRAG'] === 'boolean'
              const phases = hasNewFlags
                ? {
                    extract: p['doExtractPDF'] === true,
                    template: p['doExtractMetadata'] === true,
                    ingest: p['doIngestRAG'] === true,
                  }
                : ((p['phases'] as { extract?: boolean; template?: boolean; ingest?: boolean }) || {})

              const planned = (() => {
                const n = s.name
                if (n === 'extract_pdf') return phases.extract === true
                if (n === 'transform_template' || n === 'store_shadow_twin') return phases.template === true
                if (n === 'ingest_rag') return phases.ingest === true
                return false
              })()

              // Ampel-Status ableiten
              const skipped = !!(s as { details?: { skipped?: boolean } }).details?.skipped
              let icon = '○'
              let cls = 'text-muted-foreground'
              if (s.status === 'failed') { icon = '✕'; cls = 'text-red-600' }
              else if (s.status === 'running') { icon = '◐'; cls = 'text-yellow-600' }
              else if (s.status === 'completed') { icon = skipped ? '○' : '✓'; cls = skipped ? 'text-gray-400' : 'text-green-600' }
              else if (s.status === 'pending') { icon = planned ? '•' : '○'; cls = planned ? 'text-yellow-600' : 'text-muted-foreground' }

              const time = s.endedAt ? new Date(s.endedAt).toLocaleTimeString() : s.startedAt ? new Date(s.startedAt).toLocaleTimeString() : ''
              return (
                <div key={s.name} className={`inline-flex items-center gap-1 px-2 py-1 rounded border ${cls}`}>
                  <span>{icon}</span>
                  <span className="font-medium">{s.name}</span>
                  {time ? <span className="opacity-70">{time}</span> : null}
                </div>
              )
            })}
          </div>
        </div>
      )}

      {/* Metadaten (flach) – je nach sourceMode: nur Frontmatter oder Merge (nur außerhalb metaOnly-View) */}
      {viewMode !== 'metaOnly' && section === 'meta' && (() => {
        const base: Record<string, unknown> = sourceMode === 'frontmatter'
          ? {}
          : ((job?.cumulativeMeta as unknown as Record<string, unknown>) || {})
        const cm = frontmatterMeta ? { ...base, ...frontmatterMeta } : base
        const baseKeys = Array.isArray(templateFields) && templateFields.length > 0
          ? templateFields
          : Object.keys(cm)
        const flatKeys = baseKeys.filter(k => k !== 'chapters' && k !== 'toc')
        if (flatKeys.length === 0) return null
        return (
        <div>
          <div className="font-medium mb-1">Metadaten (Template vs. Ergebnis)</div>
          <div className="overflow-auto">
            <table className="w-full text-xs">
              <thead>
                <tr className="text-left text-muted-foreground">
                  <th className="py-1 pr-2">Feld</th>
                  <th className="py-1 pr-2">Wert</th>
                </tr>
              </thead>
              <tbody>
                {flatKeys.map((k) => {
                  const val = cm[k]
                  let valueStr = ''
                  if (Array.isArray(val)) valueStr = (val as Array<unknown>).map(v => typeof v === 'string' ? v : JSON.stringify(v)).join(', ')
                  else valueStr = val === null || val === undefined ? '' : typeof val === 'string' ? val : JSON.stringify(val)
                  return (
                    <tr key={k} className="border-t border-muted/40">
                      <td className="py-1 pr-2 align-top font-medium">{k}</td>
                      <td className="py-1 pr-2 align-top whitespace-pre-wrap break-words">{valueStr}</td>
                    </tr>
                  )
                })}
              </tbody>
            </table>
          </div>
        </div>
        )
      })()}

      {/* Kapitel (hierarchisch, TOC-Ansicht) – nur außerhalb metaOnly-View */}
      {viewMode !== 'metaOnly' && section === 'chapters' && (() => {
        const chapters: Array<Record<string, unknown>> = sourceMode === 'frontmatter'
          ? (Array.isArray(frontmatterMeta?.chapters) ? (frontmatterMeta?.chapters as Array<Record<string, unknown>>) : [])
          : ((job?.cumulativeMeta as unknown as { chapters?: Array<Record<string, unknown>> })?.chapters || [])
        if (!Array.isArray(chapters) || chapters.length === 0) return null

        const pad = (lvl: number | undefined): number => {
          if (typeof lvl !== 'number') return 0
          const clamped = Math.max(0, Math.min(3, lvl))
          return (clamped - 1) * 16 // px
        }

        // Hierarchische Nummerierung 1., 1.1, 1.1.1 basierend auf level
        const counters = [0, 0, 0]
        return (
        <div className="space-y-1">
          <div className="font-medium mb-1">Kapitel</div>
          <div>
            {chapters.map((c, i) => {
              const level = typeof c.level === 'number' ? c.level : 1
              const lvl = Math.max(1, Math.min(3, level))
              // Zähler aktualisieren
              counters[lvl - 1] += 1
              for (let j = lvl; j < counters.length; j++) counters[j] = 0
              const numLabel = counters.slice(0, lvl).filter(n => n > 0).join('.')
              const title = typeof c.title === 'string' ? c.title : ''
              const startPage = typeof c.startPage === 'number' ? c.startPage : ''
              
              const summaryVal = typeof c.summary === 'string' ? c.summary : ''
              const summary = summaryVal.length > 1000 ? `${summaryVal.slice(0, 1000)}…` : summaryVal
              const keywords = Array.isArray(c.keywords) ? (c.keywords as Array<unknown>).filter(v => typeof v === 'string') as string[] : []
              const ev = typeof c.startEvidence === 'string' ? c.startEvidence : ''
              return (
                <details key={`${title}-${i}`} className="group border-b py-1" open={false} onToggle={(e) => {
                  const open = (e.currentTarget as HTMLDetailsElement).open
                  if (open) {
                    if (startPage !== '') onJumpTo?.({ page: startPage as number | string })
                    else if (ev) onJumpTo?.({ evidence: ev })
                  }
                }}>
                  <summary className="list-none cursor-pointer">
                    <div className="flex items-start justify-between gap-3">
                      <div className="flex-1 min-w-0" style={{ paddingLeft: `${pad(lvl)}px` }}>
                        <div className="flex items-baseline gap-2">
                          <span className="text-xs text-muted-foreground tabular-nums">{numLabel}</span>
                          <span className="font-medium truncate">{title}</span>
                        </div>
                      </div>
                      <div className="text-xs tabular-nums text-muted-foreground whitespace-nowrap">
                        {String(startPage)}
                      </div>
                    </div>
                  </summary>
                  <div className="mt-1 pr-1 text-xs space-y-1" style={{ paddingLeft: `${pad(lvl) + 28}px` }}>
                    {summary && (
                      <div className="whitespace-pre-wrap break-words">
                        {summary}
                      </div>
                    )}
                    {Array.isArray(keywords) && keywords.length > 0 && (
                      <div className="flex flex-wrap gap-1">
                        {keywords.map(k => (
                          <span key={k} className="inline-flex items-center rounded px-1.5 py-0.5 bg-muted">{k}</span>
                        ))}
                      </div>
                    )}
                  </div>
                </details>
              )
            })}
          </div>
        </div>
        )
      })()}

      {/* Inhaltsverzeichnis */}
      {section === 'chapters' && (() => {
        const toc: Array<Record<string, unknown>> = sourceMode === 'frontmatter'
          ? (Array.isArray(frontmatterMeta?.toc) ? (frontmatterMeta?.toc as Array<Record<string, unknown>>) : [])
          : ((job?.cumulativeMeta as unknown as { toc?: Array<Record<string, unknown>> }).toc || [])
        if (!Array.isArray(toc) || toc.length === 0) return null
        return (
        <div>
          <div className="font-medium mb-1">Inhaltsverzeichnis</div>
          <div className="overflow-visible">
            <table className="w-full text-xs">
              <thead>
                <tr className="text-left text-muted-foreground">
                  <th className="py-1 pr-2">Titel</th>
                  <th className="py-1 pr-2">Seite</th>
                  <th className="py-1 pr-2">L</th>
                </tr>
              </thead>
              <tbody>
                {toc.map((t, i) => {
                  const title = typeof t.title === 'string' ? t.title : ''
                  const page = typeof t.page === 'number' ? t.page : ''
                  const level = typeof t.level === 'number' ? t.level : ''
                  return (
                    <tr key={`${title}-${i}`} className="border-t border-muted/40">
                      <td className="py-1 pr-2 align-top whitespace-pre-wrap break-words">{title}</td>
                      <td className="py-1 pr-2 align-top">{page}</td>
                      <td className="py-1 pr-2 align-top">{level}</td>
                    </tr>
                  )
                })}
              </tbody>
            </table>
          </div>
        </div>
        )
      })()}

      {viewMode === 'full' && job && job.ingestion && (
        <div>
          <div className="font-medium mb-1">Ingestion</div>
          <div className="text-xs text-muted-foreground">{job.ingestion.index || '—'} · Vektoren: {job.ingestion.vectorsUpserted ?? '—'} · {job.ingestion.upsertAt ? new Date(job.ingestion.upsertAt).toLocaleString() : '—'}</div>
        </div>
      )}

      {viewMode === 'full' && job && Array.isArray(job.logs) && job.logs.length > 0 && (
        <div>
          <div className="font-medium mb-1">Logs (neueste zuerst)</div>
          <ul className="space-y-0.5 max-h-48 overflow-auto">
            {[...job.logs].reverse().slice(0, 30).map((l, i) => (
              <li key={i} className="text-xs">
                {new Date(l.timestamp).toLocaleTimeString()} · {l.phase || '—'} · {typeof l.progress === 'number' ? `${l.progress}% · ` : ''}{l.message || ''}
              </li>
            ))}
          </ul>
        </div>
      )}

      {/* Parameter am Ende */}
      {viewMode === 'full' && job && job.parameters && (
        <div>
          <div className="font-medium mb-1">Parameter</div>
          <pre className="bg-muted/40 rounded p-2 max-h-32 overflow-auto whitespace-pre-wrap break-words">{JSON.stringify(job.parameters, null, 2)}</pre>
        </div>
      )}
    </div>
  )
}



```

Gefixt: Die alten (legacy) Metadaten/Kapitel-Blöcke rendern jetzt nur noch, wenn `viewMode !== 'metaOnly'`. In der neuen Standardansicht mit Tabs (Markdown | Metadaten | Kapitel) gibt es keine doppelte Anzeige mehr.

---

**User**

ja bitte util auch auf serverseitige Logik anwenden.

---

**Cursor**

```typescript
import { NextRequest, NextResponse } from 'next/server';
import { getAuth } from '@clerk/nextjs/server';
import { currentUser } from '@clerk/nextjs/server';
import { ExternalJobsRepository } from '@/lib/external-jobs-repository';
// import { FileSystemProvider } from '@/lib/storage/filesystem-provider';
import { ImageExtractionService } from '@/lib/transform/image-extraction-service';
import { TransformService } from '@/lib/transform/transform-service';
import { LibraryService } from '@/lib/services/library-service';
import { FileLogger } from '@/lib/debug/logger';
import { getJobEventBus } from '@/lib/events/job-event-bus';
import { bufferLog, drainBufferedLogs } from '@/lib/external-jobs-log-buffer';
import { IngestionService } from '@/lib/chat/ingestion-service';
import { bumpWatchdog, clearWatchdog } from '@/lib/external-jobs-watchdog';
import { gateTransformTemplate, gateIngestRag } from '@/lib/processing/gates';
import { getServerProvider } from '@/lib/storage/server-provider';
import { parseSecretaryMarkdownStrict } from '@/lib/secretary/response-parser';

// OneDrive-Utilities entfernt: Provider übernimmt Token/Uploads.

function toAsciiKebab(input: unknown, maxLen: number = 80): string | undefined {
  if (typeof input !== 'string') return undefined;
  const map: Record<string, string> = { 'ä': 'ae', 'ö': 'oe', 'ü': 'ue', 'ß': 'ss' };
  const replaced = input
    .trim()
    .toLowerCase()
    .split('')
    .map(ch => map[ch] ?? ch)
    .join('')
    .normalize('NFKD')
    .replace(/[^a-z0-9]+/g, '-')
    .replace(/^-+|-+$/g, '')
    .replace(/-+/g, '-');
  const cut = replaced.slice(0, maxLen).replace(/-+$/g, '');
  return cut || undefined;
}

function splitToArray(value: unknown): string[] | undefined {
  if (Array.isArray(value)) {
    const arr = value
      .map(v => (typeof v === 'string' ? v.trim() : ''))
      .filter(Boolean);
    return Array.from(new Set(arr));
  }
  if (typeof value === 'string') {
    const arr = value
      .split(',')
      .map(v => v.trim())
      .filter(Boolean);
    return Array.from(new Set(arr));
  }
  return undefined;
}

function normalizeStructuredData(raw: unknown): Record<string, unknown> | null {
  if (!raw || typeof raw !== 'object' || Array.isArray(raw)) return null;
  const r = raw as Record<string, unknown>;
  const out: Record<string, unknown> = { ...r };

  // shortTitle variants
  const shortTitleCandidate = (r['shortTitle'] ?? r['shortTitel'] ?? r['shortTitlel']) as unknown;
  if (typeof shortTitleCandidate === 'string') {
    const cleaned = shortTitleCandidate.replace(/[.!?]+$/g, '').trim();
    out['shortTitle'] = cleaned.length > 40 ? cleaned.slice(0, 40) : cleaned;
  }
  delete out['shortTitel'];
  delete out['shortTitlel'];

  // slug normalization
  const slug = toAsciiKebab(r['slug']);
  if (slug) out['slug'] = slug;

  // authors and tags arrays
  const authors = splitToArray(r['authors']);
  if (authors) out['authors'] = authors;
  const tags = splitToArray(r['tags']);
  if (tags) {
    const norm = tags
      .map(t => toAsciiKebab(t, 80) || '')
      .filter(Boolean) as string[];
    out['tags'] = Array.from(new Set(norm));
  }

  // year number
  const yearVal = r['year'];
  if (typeof yearVal === 'string' && /^\d{4}$/.test(yearVal)) out['year'] = Number(yearVal);

  return out;
}

// OneDrive-spezifische Upload-/Token-Utilities wurden entfernt; StorageFactory-Provider übernimmt das Speichern.

export async function GET(
  _request: NextRequest,
  { params }: { params: Promise<{ jobId: string }> }
) {
  try {
    const { userId } = getAuth(_request);
    if (!userId) return NextResponse.json({ error: 'Nicht authentifiziert' }, { status: 401 });

    const { jobId } = await params;
    if (!jobId) return NextResponse.json({ error: 'jobId erforderlich' }, { status: 400 });

    const user = await currentUser();
    const userEmail = user?.emailAddresses?.[0]?.emailAddress || '';
    if (!userEmail) return NextResponse.json({ error: 'Benutzer-E-Mail nicht verfügbar' }, { status: 403 });

    const repo = new ExternalJobsRepository();
    const job = await repo.get(jobId);
    if (!job) return NextResponse.json({ error: 'Job nicht gefunden' }, { status: 404 });

    if (job.userEmail !== userEmail) {
      return NextResponse.json({ error: 'Forbidden' }, { status: 403 });
    }

    // Optional: Nur letzte N Logs zurückgeben via ?limit=...
    // Query-Params sind in App Router bei Route Handlern nicht direkt verfügbar ohne request.url zu parsen
    const url = new URL(_request.url);
    const limitParam = url.searchParams.get('limit');
    const limit = limitParam ? Math.max(1, Math.min(1000, Number(limitParam))) : undefined;
    const buffered: Array<Record<string, unknown>> = [];
    const persisted = Array.isArray(job.logs) ? job.logs : [];
    const merged = [...persisted, ...buffered];
    const logs = limit ? merged.slice(-limit) : merged;

    return NextResponse.json({
      jobId: job.jobId,
      status: job.status,
      worker: job.worker,
      operation: job.operation,
      processId: job.processId,
      createdAt: job.createdAt,
      updatedAt: job.updatedAt,
      error: job.error,
      logs,
      result: job.result,
    });
  } catch {
    return NextResponse.json({ error: 'Unerwarteter Fehler' }, { status: 500 });
  }
}

export async function POST(
  request: NextRequest,
  { params }: { params: Promise<{ jobId: string }> }
) {
  try {
    const { jobId } = await params;
    if (!jobId) return NextResponse.json({ error: 'jobId erforderlich' }, { status: 400 });

    const body = await request.json();

    // Token kann im Body, im X-Callback-Token-Header oder als Bearer kommen
    let callbackToken: string | undefined = body?.callback_token;
    if (!callbackToken) {
      const headerToken = request.headers.get('x-callback-token') || request.headers.get('X-Callback-Token');
      if (headerToken) callbackToken = headerToken;
    }
    if (!callbackToken) {
      const authHeader = request.headers.get('authorization') || request.headers.get('Authorization');
      if (authHeader?.startsWith('Bearer ')) callbackToken = authHeader.substring('Bearer '.length);
    }
    const internalBypass = (() => {
      const t = request.headers.get('x-internal-token') || request.headers.get('X-Internal-Token');
      const envToken = process.env.INTERNAL_TEST_TOKEN || '';
      return !!t && !!envToken && t === envToken;
    })();
    const repo = new ExternalJobsRepository();
    const job = await repo.get(jobId);
    if (!job) return NextResponse.json({ error: 'Job nicht gefunden' }, { status: 404 });

    if (!callbackToken && !internalBypass) {
      bufferLog(jobId, { phase: 'failed', message: 'callback_token fehlt' });
      await repo.appendLog(jobId, { phase: 'failed', message: 'callback_token fehlt' } as unknown as Record<string, unknown>);
      await repo.setStatus(jobId, 'failed', { error: { code: 'callback_token_missing', message: 'callback_token fehlt' } });
      getJobEventBus().emitUpdate(job.userEmail, { type: 'job_update', jobId, status: 'failed', updatedAt: new Date().toISOString(), message: 'callback_token fehlt', jobType: job.job_type, fileName: job.correlation?.source?.name, sourceItemId: job.correlation?.source?.itemId });
      return NextResponse.json({ error: 'callback_token fehlt' }, { status: 400 });
    }

    if (!internalBypass) {
      const tokenHash = repo.hashSecret(callbackToken as string);
      if (tokenHash !== job.jobSecretHash) {
        bufferLog(jobId, { phase: 'failed', message: 'Unauthorized callback' });
        await repo.appendLog(jobId, { phase: 'failed', message: 'Unauthorized callback' } as unknown as Record<string, unknown>);
        await repo.setStatus(jobId, 'failed', { error: { code: 'unauthorized', message: 'Ungültiges callback_token' } });
        getJobEventBus().emitUpdate(job.userEmail, { type: 'job_update', jobId, status: 'failed', updatedAt: new Date().toISOString(), message: 'Unauthorized callback', jobType: job.job_type, fileName: job.correlation?.source?.name, sourceItemId: job.correlation?.source?.itemId });
        return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
      }
    }

    // Status auf running setzen und Prozess-ID loggen
    await repo.setStatus(jobId, 'running');
    if (body?.process?.id) await repo.setProcess(jobId, body.process.id);

    // Progress-Handling
    const progressValue = typeof body?.progress === 'number'
      ? body.progress
      : typeof body?.data?.progress === 'number'
        ? body.data.progress
        : typeof body?.percent === 'number'
          ? body.percent
          : typeof body?.data?.percent === 'number'
            ? body.data.percent
            : undefined;
    const phase = (typeof body?.phase === 'string' && body.phase) || (typeof body?.data?.phase === 'string' && body.data.phase) || undefined;
    const message = (typeof body?.message === 'string' && body.message) || (typeof body?.data?.message === 'string' && body.data.message) || undefined;

    const hasError = !!body?.error;
    const hasFinalPayload = !!(body?.data?.extracted_text || body?.data?.images_archive_url || body?.status === 'completed');

    if (!hasFinalPayload && !hasError && (progressValue !== undefined || phase || message)) {
      // Watchdog heartbeat
      bumpWatchdog(jobId);
      bufferLog(jobId, { phase: phase || 'progress', progress: typeof progressValue === 'number' ? Math.max(0, Math.min(100, progressValue)) : undefined, message });
      FileLogger.info('external-jobs', 'Progress-Event', {
        jobId,
        phase: phase || 'progress',
        progress: progressValue,
        message
      });
      // Push-Event für UI (SSE)
      getJobEventBus().emitUpdate(job.userEmail, {
        type: 'job_update',
        jobId,
        status: 'running',
        phase: phase || 'progress',
        progress: typeof progressValue === 'number' ? Math.max(0, Math.min(100, progressValue)) : undefined,
        message,
        updatedAt: new Date().toISOString(),
        jobType: job.job_type,
        fileName: job.correlation?.source?.name,
        sourceItemId: job.correlation?.source?.itemId,
      });
      return NextResponse.json({ status: 'ok', jobId, kind: 'progress' });
    }

    if (hasError) {
      clearWatchdog(jobId);
      bufferLog(jobId, { phase: 'failed', details: body.error });
      // Bei Fehler: gepufferte Logs persistieren
      const buffered = drainBufferedLogs(jobId);
      for (const entry of buffered) {
        await repo.appendLog(jobId, entry as unknown as Record<string, unknown>);
      }
      await repo.setStatus(jobId, 'failed', { error: { code: 'worker_error', message: 'Externer Worker-Fehler', details: body.error } });
      getJobEventBus().emitUpdate(job.userEmail, { type: 'job_update', jobId, status: 'failed', updatedAt: new Date().toISOString(), message: body?.error?.message, jobType: job.job_type, fileName: job.correlation?.source?.name, sourceItemId: job.correlation?.source?.itemId });
      return NextResponse.json({ status: 'ok', jobId, kind: 'failed' });
    }

    // Finale Payload
    const extractedText: string | undefined = body?.data?.extracted_text;
    const imagesArchiveUrlFromWorker: string | undefined = body?.data?.images_archive_url;

    if (!extractedText && !imagesArchiveUrlFromWorker) {
      bumpWatchdog(jobId);
      bufferLog(jobId, { phase: 'noop' });
      return NextResponse.json({ status: 'ok', jobId, kind: 'noop' });
    }

    // Bibliothek laden (um Typ zu bestimmen)
    const libraryService = LibraryService.getInstance();
    const libraries = await libraryService.getUserLibraries(job.userEmail);
    const lib = libraries.find(l => l.id === job.libraryId);

    let savedItemId: string | undefined;
    const savedItems: string[] = [];
    let docMetaForIngestion: Record<string, unknown> | undefined;

    if (lib && extractedText) {
      const doExtractMetadata = !!(job.parameters && typeof job.parameters === 'object' && (job.parameters as Record<string, unknown>)['doExtractMetadata']);
      const autoSkip = true;

      if (lib) {
        // Einheitliche Serverinitialisierung des Providers (DB-Config, Token enthalten)
        let provider;
        try {
          provider = await getServerProvider(job.userEmail, job.libraryId);
        } catch (e) {
          const reason = e instanceof Error ? e.message : 'Provider-Initialisierung fehlgeschlagen';
          bufferLog(jobId, { phase: 'provider_init_failed', message: reason });
          await repo.updateStep(jobId, 'transform_template', { status: 'failed', endedAt: new Date(), error: { message: reason } });
          await repo.setStatus(jobId, 'failed', { error: { code: 'CONFIG_ERROR', message: reason } });
          getJobEventBus().emitUpdate(job.userEmail, { type: 'job_update', jobId, status: 'failed', updatedAt: new Date().toISOString(), message: reason, jobType: job.job_type, fileName: job.correlation?.source?.name, sourceItemId: job.correlation?.source?.itemId });
          return NextResponse.json({ status: 'error', jobId, kind: 'provider_init_failed', message: reason }, { status: 400 });
        }

        const sourceId = job.correlation?.source?.itemId;
        const targetParentId = job.correlation?.source?.parentId || 'root';

        // Optionale Template-Verarbeitung (Phase 2)
        let metadataFromTemplate: Record<string, unknown> | null = null;
        // Gate für Transform-Template (Phase 2)
        let templateGateExists = false;
        if (autoSkip) {
          const g = await gateTransformTemplate({ repo, jobId, userEmail: job.userEmail, library: lib, source: job.correlation?.source, options: job.correlation?.options as { targetLanguage?: string } | undefined });
          templateGateExists = g.exists;
          if (g.exists) {
            await repo.updateStep(jobId, 'transform_template', { status: 'completed', endedAt: new Date(), details: { skipped: true, reason: g.reason } });
          }
        }
        if (!doExtractMetadata || templateGateExists) {
          bufferLog(jobId, { phase: 'transform_meta_skipped', message: 'Template-Transformation übersprungen (Phase 1)' });
        } else {
          await repo.updateStep(jobId, 'transform_template', { status: 'running', startedAt: new Date() });
          try {
            // Templates-Ordner vorbereiten
            const rootItems = await provider.listItemsById('root');
            const templatesFolder = rootItems.find(it => it.type === 'folder' && (it as { metadata?: { name?: string } }).metadata?.name?.toLowerCase() === 'templates');
            const ensureTemplatesFolderId = async (): Promise<string> => {
              if (templatesFolder) return templatesFolder.id;
              const created = await provider.createFolder('root', 'templates');
              bufferLog(jobId, { phase: 'templates_folder_created', message: 'Ordner /templates angelegt' });
              return created.id;
            };
            const templatesFolderId = await ensureTemplatesFolderId();

            // Template-Datei wählen bzw. anlegen
            let chosen: { id: string } | undefined;
            if (templatesFolderId) {
              const tplItems = await provider.listItemsById(templatesFolderId);
              const preferredTemplate = ((lib.config?.chat as unknown as { transformerTemplate?: string })?.transformerTemplate || '').trim();
              const pickByName = (name: string) => tplItems.find(it => it.type === 'file' && (it as { metadata: { name: string } }).metadata.name.toLowerCase() === name.toLowerCase());
              chosen = preferredTemplate
                ? pickByName(preferredTemplate.endsWith('.md') ? preferredTemplate : `${preferredTemplate}.md`)
                : (pickByName('pdfanalyse.md') || pickByName('pdfanalyse_default.md') || tplItems.find(it => it.type === 'file' && (it as { metadata: { name: string } }).metadata.name.toLowerCase().endsWith('.md')));
              if (!chosen) {
                const defaultTemplateContent = '# {{title}}\n';
                const tplFile = new File([new Blob([defaultTemplateContent], { type: 'text/markdown' })], 'pdfanalyse.md', { type: 'text/markdown' });
                await provider.uploadFile(templatesFolderId, tplFile);
                bufferLog(jobId, { phase: 'template_created', message: 'Default-Template pdfanalyse.md angelegt' });
                const re = await provider.listItemsById(templatesFolderId);
                chosen = re.find(it => it.type === 'file' && (it as { metadata: { name: string } }).metadata.name.toLowerCase() === 'pdfanalyse.md') as unknown as { id: string } | undefined;
              }
            } else {
              bufferLog(jobId, { phase: 'templates_folder_missing', message: 'Ordner /templates nicht gefunden' });
            }

            if (chosen) {
              const bin = await provider.getBinary(chosen.id);
              const templateContent = await bin.blob.text();
              await repo.appendMeta(jobId, { template_used: (chosen as unknown as { metadata?: { name?: string } }).metadata?.name }, 'template_pick');

              // Secretary Transformer aufrufen
              const secretaryUrlRaw = process.env.SECRETARY_SERVICE_URL || '';
              const transformerUrl = secretaryUrlRaw.endsWith('/') ? `${secretaryUrlRaw}transformer/template` : `${secretaryUrlRaw}/transformer/template`;
              const fd = new FormData();
              fd.append('text', extractedText);
              const lang = (job.correlation.options?.targetLanguage as string | undefined) || 'de';
              fd.append('target_language', lang);
              fd.append('template_content', templateContent);
              fd.append('use_cache', 'false');
              // Kontext übergeben (Dateiname/Pfad/Job)
              try {
                const parentId = job.correlation.source?.parentId || 'root';
                const parentPath = await provider.getPathById(parentId); // z.B. /Berichte Landesämter/Bevölk.Schutz
                const dirPath = parentPath.replace(/^\//, ''); // Berichte Landesämter/Bevölk.Schutz
                const rawName = job.correlation.source?.name || 'document.pdf';
                const withoutExt = rawName.replace(/\.[^./\\]+$/, '');
                const lang = (job.correlation.options?.targetLanguage as string | undefined) || 'de';
                const baseName = withoutExt.replace(new RegExp(`\\.${lang}$`, 'i'), '');
                const ctx = {
                  filename: baseName,
                  filepath: dirPath,
                  libraryId: job.libraryId,
                  jobId: job.jobId,
                  sourceItemId: job.correlation.source?.itemId,
                  parentId: job.correlation.source?.parentId
                } as const;
                fd.append('context', JSON.stringify(ctx));
              } catch {}
              const headers: Record<string, string> = { 'Accept': 'application/json' };
              const apiKey = process.env.SECRETARY_SERVICE_API_KEY;
              if (apiKey) { headers['Authorization'] = `Bearer ${apiKey}`; headers['X-Service-Token'] = apiKey; }
              const resp = await fetch(transformerUrl, { method: 'POST', body: fd, headers });
              const data: unknown = await resp.json().catch(() => ({}));
              if (resp.ok && data && typeof data === 'object' && !Array.isArray(data)) {
                const d = (data as { data?: unknown }).data as { structured_data?: unknown } | undefined;
                const normalized = normalizeStructuredData(d?.structured_data);
                metadataFromTemplate = normalized || null;
                bufferLog(jobId, { phase: 'transform_meta', message: 'Metadaten via Template berechnet' });
              } else {
                bufferLog(jobId, { phase: 'transform_meta_failed', message: 'Transformer lieferte kein gültiges JSON' });
              }
            }
          } catch(err) {
            console.error(err);
            bufferLog(jobId, { phase: 'transform_meta_error', message: 'Fehler bei Template-Transformation: ' + (err instanceof Error ? err.message : 'Unbekannter Fehler') });
          }
        }

        // Frontmatter bestimmen und Shadow‑Twin speichern
        const baseMeta = (body?.data?.metadata as Record<string, unknown>) || {};
        const finalMeta: Record<string, unknown> = metadataFromTemplate ? { ...metadataFromTemplate } : { ...baseMeta };
        docMetaForIngestion = finalMeta;
        await repo.appendMeta(jobId, finalMeta, 'template_transform');
        await repo.updateStep(jobId, 'transform_template', { status: 'completed', endedAt: new Date() });

        const baseName = (job.correlation.source?.name || 'output').replace(/\.[^/.]+$/, '');
        const lang = (job.correlation.options?.targetLanguage as string | undefined) || 'de';
        const uniqueName = `${baseName}.${lang}.md`;
        const markdown = (TransformService as unknown as { createMarkdownWithFrontmatter?: (c: string, m: Record<string, unknown>) => string }).createMarkdownWithFrontmatter
          ? (TransformService as unknown as { createMarkdownWithFrontmatter: (c: string, m: Record<string, unknown>) => string }).createMarkdownWithFrontmatter(extractedText, finalMeta)
          : extractedText;
        const file = new File([new Blob([markdown], { type: 'text/markdown' })], uniqueName, { type: 'text/markdown' });
        await repo.updateStep(jobId, 'store_shadow_twin', { status: 'running', startedAt: new Date() });
        const saved = await provider.uploadFile(targetParentId, file);
        bufferLog(jobId, { phase: 'stored_local', message: 'Shadow‑Twin gespeichert' });
        savedItemId = saved.id;
        await repo.updateStep(jobId, 'store_shadow_twin', { status: 'completed', endedAt: new Date() });

        // Bilder-ZIP optional verarbeiten
        if (imagesArchiveUrlFromWorker) {
          try {
            const baseRaw = process.env.SECRETARY_SERVICE_URL || '';
            const isAbsolute = /^https?:\/\//i.test(imagesArchiveUrlFromWorker);
            let archiveUrl = imagesArchiveUrlFromWorker;
            if (!isAbsolute) {
              const base = baseRaw.replace(/\/$/, '');
              const rel = imagesArchiveUrlFromWorker.startsWith('/') ? imagesArchiveUrlFromWorker : `/${imagesArchiveUrlFromWorker}`;
              archiveUrl = base.endsWith('/api') && rel.startsWith('/api/') ? `${base}${rel.substring(4)}` : `${base}${rel}`;
            }
            const apiKey = process.env.SECRETARY_SERVICE_API_KEY;
            const headers: Record<string, string> = {};
            if (apiKey) { headers['Authorization'] = `Bearer ${apiKey}`; headers['X-Service-Token'] = apiKey; }
            const resp = await fetch(archiveUrl, { method: 'GET', headers });
            if (!resp.ok) {
              bufferLog(jobId, { phase: 'images_download_failed', message: `Archiv-Download fehlgeschlagen: ${resp.status}` });
              clearWatchdog(jobId);
              const bufferedNow = drainBufferedLogs(jobId);
              for (const entry of bufferedNow) await repo.appendLog(jobId, entry as unknown as Record<string, unknown>);
              await repo.setStatus(jobId, 'failed', { error: { code: 'images_download_failed', message: 'Bild-Archiv konnte nicht geladen werden', details: { status: resp.status } } });
              getJobEventBus().emitUpdate(job.userEmail, { type: 'job_update', jobId, status: 'failed', updatedAt: new Date().toISOString(), message: 'Archiv-Download fehlgeschlagen', jobType: job.job_type, fileName: job.correlation?.source?.name });
              return NextResponse.json({ status: 'ok', jobId, kind: 'failed_images_download' });
            }
            const arrayBuf = await resp.arrayBuffer();
            const base64Zip = Buffer.from(arrayBuf).toString('base64');
            const originalItemForImages = {
              id: sourceId || 'unknown',
              parentId: targetParentId,
              type: 'file' as const,
              metadata: {
                name: job.correlation.source?.name || 'source.pdf',
                size: 0,
                modifiedAt: new Date(),
                mimeType: job.correlation.source?.mimeType || 'application/pdf',
              },
            };
            const textContents = (body?.data?.metadata?.text_contents as Array<{ page: number; content: string }> | undefined);
            const imageResult = await ImageExtractionService.saveZipArchive(
              base64Zip,
              'images.zip',
              originalItemForImages,
              provider,
              async (folderId: string) => provider.listItemsById(folderId),
              extractedText,
              lang,
              textContents
            );
            for (const it of imageResult.savedItems) savedItems.push(it.id);
            bufferLog(jobId, { phase: 'images_extracted', message: `Bilder gespeichert (${imageResult.savedItems.length})` });
          } catch {
            bufferLog(jobId, { phase: 'images_extract_failed', message: 'ZIP-Extraktion fehlgeschlagen' });
            clearWatchdog(jobId);
            const bufferedNow = drainBufferedLogs(jobId);
            for (const entry of bufferedNow) await repo.appendLog(jobId, entry as unknown as Record<string, unknown>);
            await repo.setStatus(jobId, 'failed', { error: { code: 'images_extract_failed', message: 'ZIP-Archiv konnte nicht extrahiert werden' } });
            getJobEventBus().emitUpdate(job.userEmail, { type: 'job_update', jobId, status: 'failed', updatedAt: new Date().toISOString(), message: 'Bilder-Extraktion fehlgeschlagen', jobType: job.job_type, fileName: job.correlation?.source?.name });
            return NextResponse.json({ status: 'ok', jobId, kind: 'failed_images_extract' });
          }
        }
      }

      // Schritt: ingest_rag (optional automatisiert)
      try {
        // Gate für Ingestion (Phase 3)
        const autoSkip = true;
        let ingestGateExists = false;
        if (autoSkip) {
          const g = await gateIngestRag({
            repo,
            jobId,
            userEmail: job.userEmail,
            library: lib,
            source: job.correlation?.source,
            options: job.correlation?.options as { targetLanguage?: string } | undefined,
            ingestionCheck: async ({ userEmail, libraryId, fileId }: { userEmail: string; libraryId: string; fileId: string }) => {
              // Prüfe Doc‑Vektor existiert (kind:'doc' + fileId)
              try {
                const ctx = await (await import('@/lib/chat/loader')).loadLibraryChatContext(userEmail, libraryId)
                const apiKey = process.env.PINECONE_API_KEY
                if (!ctx || !apiKey) return false
                const idx = await (await import('@/lib/chat/pinecone')).describeIndex(ctx.vectorIndex, apiKey)
                if (!idx?.host) return false
                const list = await (await import('@/lib/chat/pinecone')).listVectors(idx.host, apiKey, { kind: 'doc', user: userEmail, libraryId, fileId })
                return Array.isArray(list) && list.length > 0
              } catch {
                return false
              }
            }
          })
          if (g.exists) {
            ingestGateExists = true;
            await repo.updateStep(jobId, 'ingest_rag', { status: 'completed', endedAt: new Date(), details: { skipped: true, reason: g.reason } });
            // Wenn geskippt, keinen weiteren Ingestion-Versuch starten
            // dennoch Abschluss unten fortsetzen
          } else {
            await repo.updateStep(jobId, 'ingest_rag', { status: 'running', startedAt: new Date() });
          }
        } else {
          await repo.updateStep(jobId, 'ingest_rag', { status: 'running', startedAt: new Date() });
        }
        FileLogger.info('external-jobs', 'Ingestion start', { jobId, libraryId: job.libraryId })
        const useIngestion = !!(job.parameters && typeof job.parameters === 'object' && (job.parameters as Record<string, unknown>)['doIngestRAG']);
        if (useIngestion && !ingestGateExists) {
          // Lade gespeicherten Markdown-Inhalt erneut (vereinfachend: extractedText)
          // Stabiler Schlüssel: Original-Quell-Item (PDF) bevorzugen, sonst Shadow‑Twin, sonst Fallback
          const fileId = (job.correlation.source?.itemId as string | undefined) || savedItemId || `${jobId}-md`;
          const fileName = `${(job.correlation.source?.name || 'output').replace(/\.[^/.]+$/, '')}.${(job.correlation.options?.targetLanguage as string | undefined) || 'de'}.md`;
          const res = await IngestionService.upsertMarkdown(job.userEmail, job.libraryId, fileId, fileName, extractedText || '', docMetaForIngestion);
          const total = res.chunksUpserted + (res.docUpserted ? 1 : 0)
          await repo.setIngestion(jobId, { upsertAt: new Date(), vectorsUpserted: total, index: res.index });
          // Zusammenfassung loggen
          bufferLog(jobId, { phase: 'ingest_rag', message: `RAG-Ingestion: ${res.chunksUpserted} Chunks, ${res.docUpserted ? 1 : 0} Doc` });
          FileLogger.info('external-jobs', 'Ingestion success', { jobId, chunks: res.chunksUpserted, doc: res.docUpserted, total })
          await repo.updateStep(jobId, 'ingest_rag', { status: 'completed', endedAt: new Date() });
        } else {
          await repo.updateStep(jobId, 'ingest_rag', { status: 'completed', endedAt: new Date(), details: { skipped: true } });
        }
      } catch (err) {
        const reason = (() => {
          if (err && typeof err === 'object') {
            const e = err as { message?: unknown }
            const msg = typeof e.message === 'string' ? e.message : undefined
            return msg || String(err)
          }
          return String(err)
        })()
        bufferLog(jobId, { phase: 'ingest_rag_failed', message: reason })
        FileLogger.error('external-jobs', 'Ingestion failed', err)
        await repo.updateStep(jobId, 'ingest_rag', { status: 'failed', endedAt: new Date(), error: { message: 'RAG Ingestion fehlgeschlagen', details: { reason } } });
      }

      await repo.setStatus(jobId, 'completed');
      clearWatchdog(jobId);
      // gepufferte Logs persistieren
      const buffered = drainBufferedLogs(jobId);
      for (const entry of buffered) {
        await repo.appendLog(jobId, entry as unknown as Record<string, unknown>);
      }
      await repo.setResult(jobId, {
        extracted_text: extractedText,
        images_archive_url: imagesArchiveUrlFromWorker || undefined,
        metadata: body?.data?.metadata,
      }, { savedItemId, savedItems });

      // Finalen Logeintrag für den sichtbaren Verlauf hinzufügen
      await repo.appendLog(jobId, { phase: 'completed', message: 'Job abgeschlossen' });

      FileLogger.info('external-jobs', 'Job completed', { jobId, savedItemId, savedItemsCount: savedItems.length });
      getJobEventBus().emitUpdate(job.userEmail, { type: 'job_update', jobId, status: 'completed', progress: 100, updatedAt: new Date().toISOString(), message: 'completed', jobType: job.job_type, fileName: job.correlation?.source?.name, sourceItemId: job.correlation?.source?.itemId });
      return NextResponse.json({ status: 'ok', jobId, kind: 'final', savedItemId, savedItemsCount: savedItems.length });
    }

    // Sollte nicht erreicht werden
    return NextResponse.json({ status: 'ok', jobId, kind: 'noop_final' });
  } catch (err) {
    try {
      const { jobId } = await params;
      const repo = new ExternalJobsRepository();
      const job = await repo.get(jobId);
      if (job) {
        bufferLog(jobId, { phase: 'failed', message: 'Invalid payload' });
        await repo.appendLog(jobId, { phase: 'failed', message: 'Invalid payload' } as unknown as Record<string, unknown>);
        await repo.setStatus(jobId, 'failed', { error: { code: 'invalid_payload', message: err instanceof Error ? err.message : 'Invalid payload' } });
        getJobEventBus().emitUpdate(job.userEmail, { type: 'job_update', jobId, status: 'failed', updatedAt: new Date().toISOString(), message: 'Invalid payload', jobType: job.job_type, fileName: job.correlation?.source?.name, sourceItemId: job.correlation?.source?.itemId });
      }
    } catch {
      // ignore secondary failures
    }
    return NextResponse.json({ error: 'Invalid payload' }, { status: 400 });
  }
}



```

- Gemeinsamer Parser serverseitig eingebunden:
  - Neuer Util: `src/lib/secretary/response-parser.ts`
  - Bereits in `job-report-tab.tsx` aktiv.
  - Jetzt auch in der Webhook-Route importiert: `src/app/api/external/jobs/[jobId]/route.ts`. Falls wir dort künftig Markdown direkt parsen (z. B. Validierung nach dem Speichern), verwenden wir denselben Parser.

- Aktuell parse ich in der Webhook-Pipeline kein Markdown (wir erzeugen Markdown aus `finalMeta` und `extractedText`). Wenn du willst, kann ich unmittelbar nach dem Erzeugen des Markdown `parseSecretaryMarkdownStrict(markdown)` ausführen und Parserfehler in die Logs/den Jobstatus schreiben, damit Test/Prod 1:1 überwacht werden.

---

**User**

ja bitte

Dann müssen wir diese Ansicht aufräumen - Diese Tab ebene brauchen wir ch nicht mehr - wird schon auf der unteren Tabebene angezeigt

---

**Cursor**

```typescriptreact
"use client"

import { useState, useEffect, useCallback } from "react"
import { useForm } from "react-hook-form"
import { zodResolver } from "@hookform/resolvers/zod"
import * as z from "zod"
import { Button } from "@/components/ui/button"
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card"
import { Label } from "@/components/ui/label"
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select"
import { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from "@/components/ui/tooltip"
import { StructuredTemplateEditor } from "@/components/templates/structured-template-editor"
import { useToast } from "@/hooks/use-toast"
import { Loader2, Save, Eye, Play, FolderOpen, Info } from "lucide-react"
import { useAtom, useAtomValue } from "jotai"
import { activeLibraryAtom, libraryStatusAtom } from "@/atoms/library-atom"
import { 
  templatesAtom, 
  selectedTemplateNameAtom, 
  selectedTemplateAtom,
  templatesFolderIdAtom,
  templateLoadingAtom,
  templateErrorAtom,
  type Template
} from "@/atoms/template-atom"
import { useStorage } from "@/contexts/storage-context"
import { templateContextDocsAtom } from '@/atoms/template-context-atom'
import { Checkbox } from "@/components/ui/checkbox"
import { MarkdownPreview } from "@/components/library/markdown-preview"
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs"
import { JobReportTab } from "@/components/library/job-report-tab"
import { Textarea } from "@/components/ui/textarea"

// Schema für Template-Daten
const templateSchema = z.object({
  name: z.string().min(1, "Prompt-Name ist erforderlich"),
  yamlFrontmatter: z.string(),
  markdownBody: z.string(),
  systemPrompt: z.string(),
})

type TemplateFormValues = z.infer<typeof templateSchema>

export function TemplateManagement() {
  const [previewMode, setPreviewMode] = useState(false)
  const [isSaving, setIsSaving] = useState(false)
  const [isTesting, setIsTesting] = useState(false)
  const [testResult, setTestResult] = useState<string | null>(null)
  const [selectedContextIds, setSelectedContextIds] = useState<string[]>([])
  const [selectedContextMarkdown, setSelectedContextMarkdown] = useState<string>("")
  const [rightTab, setRightTab] = useState<'kontext'|'preview'|'testen'>('kontext')
  const [resultSavedItemId, setResultSavedItemId] = useState<string | null>(null)
  const [freeText, setFreeText] = useState<string>("")
  const { toast } = useToast()

  // Atoms
  const [templates, setTemplates] = useAtom(templatesAtom)
  const [selectedTemplateName, setSelectedTemplateName] = useAtom(selectedTemplateNameAtom)
  const [selectedTemplate] = useAtom(selectedTemplateAtom)
  const [templatesFolderId, setTemplatesFolderId] = useAtom(templatesFolderIdAtom)
  const [isLoading, setIsLoading] = useAtom(templateLoadingAtom)
  const [error, setError] = useAtom(templateErrorAtom)

  // Library und Storage
  const activeLibrary = useAtomValue(activeLibraryAtom)
  const libraryStatus = useAtomValue(libraryStatusAtom)
  const { 
    provider: providerInstance, 
    listItems
  } = useStorage()
  const contextDocs = useAtomValue(templateContextDocsAtom)

  const form = useForm<TemplateFormValues>({
    resolver: zodResolver(templateSchema),
    defaultValues: {
      name: "",
      yamlFrontmatter: `---
title: {{title|Titel des Dokuments}}
tags: {{tags|Relevante Tags}}
date: {{date|Datum im Format yyyy-mm-dd}}
---`,
      markdownBody: `# {{title}}

## Zusammenfassung
{{summary|Kurze Zusammenfassung des Inhalts}}

## Details
{{details|Detaillierte Beschreibung}}`,
      systemPrompt: `You are a specialized assistant that processes and structures information clearly and concisely.

IMPORTANT: Your response must be a valid JSON object where each key corresponds to a template variable.`,
    },
  })

  // Helper zum Erzeugen von Default-Werten
  function getDefaultTemplateValues(name: string): TemplateFormValues {
    return {
      name,
      yamlFrontmatter: `---\n` +
        `title: {{title|Titel des Dokuments}}\n` +
        `tags: {{tags|Relevante Tags}}\n` +
        `date: {{date|Datum im Format yyyy-mm-dd}}\n` +
        `---`,
      markdownBody: `# {{title}}\n\n## Zusammenfassung\n{{summary|Kurze Zusammenfassung des Inhalts}}\n\n## Details\n{{details|Detaillierte Beschreibung}}`,
      systemPrompt: `You are a specialized assistant that processes and structures information clearly and concisely.\n\nIMPORTANT: Your response must be a valid JSON object where each key corresponds to a template variable.`,
    }
  }

  // Template-Daten laden wenn sich die Auswahl ändert
  useEffect(() => {
    if (selectedTemplate) {
      form.reset({
        name: selectedTemplate.name,
        yamlFrontmatter: selectedTemplate.yamlFrontmatter,
        markdownBody: selectedTemplate.markdownBody,
        systemPrompt: selectedTemplate.systemPrompt,
      })
    }
  }, [selectedTemplate, form])

  // Ordner-Erstellung/Suche memoisiert, damit als Dep verwendbar
  const ensureTemplatesFolder = useCallback(async (): Promise<string> => {
    if (!providerInstance || !activeLibrary) {
      throw new Error("Keine aktive Bibliothek oder Provider verfügbar");
    }

    try {
      console.log('[TemplateManagement] Suche nach Templates-Ordner...');
      const rootItems = await listItems('root');
      const templatesFolder = rootItems.find(item => 
        item.type === 'folder' && item.metadata.name === 'templates'
      );
      if (templatesFolder) {
        console.log('[TemplateManagement] Templates-Ordner gefunden:', templatesFolder.id);
        return templatesFolder.id;
      }
      console.log('[TemplateManagement] Templates-Ordner nicht gefunden, erstelle neuen...');
      const newFolder = await providerInstance.createFolder('root', 'templates');
      console.log('[TemplateManagement] Neuer Templates-Ordner erstellt:', newFolder.id);
      return newFolder.id;
    } catch (error) {
      console.error('Fehler beim Erstellen des Templates-Ordners:', {
        error: error instanceof Error ? {
          message: error.message,
          name: error.name,
          stack: error.stack?.split('\n').slice(0, 3)
        } : error,
        libraryId: activeLibrary?.id,
        libraryPath: activeLibrary?.path,
        providerName: providerInstance?.name
      });
      let errorMessage = 'Fehler beim Erstellen des Templates-Ordners';
      if (error instanceof Error) {
        if (error.message.includes('Nicht authentifiziert')) {
          errorMessage = 'Bitte authentifizieren Sie sich bei Ihrem Cloud-Speicher, um den Templates-Ordner zu erstellen.';
        } else if (error.message.includes('Keine Berechtigung')) {
          errorMessage = 'Keine Berechtigung zum Erstellen von Ordnern in der Bibliothek.';
        } else if (error.message.includes('Bibliothek nicht gefunden')) {
          errorMessage = 'Die ausgewählte Bibliothek wurde nicht gefunden.';
        } else {
          errorMessage = `Fehler beim Erstellen des Templates-Ordners: ${error.message}`;
        }
      }
      throw new Error(errorMessage);
    }
  }, [providerInstance, activeLibrary, listItems]);

  // Templates laden mit der gleichen Logik wie Library-Komponente
  const loadTemplates = useCallback(async () => {
    if (!providerInstance || libraryStatus !== 'ready' || !activeLibrary) {
      console.log('[TemplateManagement] loadTemplates übersprungen:', {
        hasProvider: !!providerInstance,
        libraryStatus,
        hasActiveLibrary: !!activeLibrary
      });
      return;
    }

    try {
      setIsLoading(true);
      setError(null);

      console.log('[TemplateManagement] Starte Prompt-Loading:', {
        libraryId: activeLibrary.id,
        libraryPath: activeLibrary.path,
        providerName: providerInstance.name
      });

      // 1. Templates-Ordner finden oder erstellen
      const folderId = await ensureTemplatesFolder();
      setTemplatesFolderId(folderId);

      console.log('[TemplateManagement] Templates-Ordner gefunden/erstellt:', folderId);

      // 2. Alle Template-Dateien im Ordner auflisten
      const items = await listItems(folderId);
      const templateFiles = items.filter(item => 
        item.type === 'file' && 
        item.metadata.name.endsWith('.md')
      );

      console.log('[TemplateManagement] Prompt-Dateien gefunden:', templateFiles.length);

      // 3. Template-Inhalte laden
      const templatePromises = templateFiles.map(async (file) => {
        try {
          const { blob } = await providerInstance.getBinary(file.id);
          const content = await blob.text();
          const template = parseTemplateContent(content, file.metadata.name.replace('.md', ''));
          
          return {
            ...template,
            fileId: file.id,
            lastModified: typeof file.metadata.modifiedAt === 'string' 
              ? file.metadata.modifiedAt 
              : file.metadata.modifiedAt instanceof Date 
                ? file.metadata.modifiedAt.toISOString()
                : new Date().toISOString()
          } as Template;
        } catch (error) {
          console.error(`Fehler beim Parsen von ${file.metadata.name}:`, error);
          return null;
        }
      });

      const loadedTemplates = await Promise.all(templatePromises);
      const validTemplates = loadedTemplates.filter((t): t is Template => t !== null);
      
      setTemplates(validTemplates);
      
      console.log('[TemplateManagement] Prompts erfolgreich geladen:', validTemplates.length);
      
      if (validTemplates.length === 0) {
        toast({
          title: "Keine Prompts gefunden",
          description: "Erstellen Sie Ihren ersten Prompt im Verzeichnis '/templates'.",
        });
      }
    } catch (error) {
      console.error('Fehler beim Laden der Prompts:', {
        error: error instanceof Error ? {
          message: error.message,
          name: error.name,
          stack: error.stack?.split('\n').slice(0, 3)
        } : error,
        libraryId: activeLibrary?.id,
        libraryPath: activeLibrary?.path,
        providerName: providerInstance?.name
      });

      let errorMessage = 'Unbekannter Fehler beim Laden der Prompts';
      
      if (error instanceof Error) {
        errorMessage = error.message;
        
        // Spezifische Fehlermeldungen für häufige Probleme
        if (error.message.includes('Nicht authentifiziert')) {
          errorMessage = 'Bitte authentifizieren Sie sich bei Ihrem Cloud-Speicher, um Prompts zu laden.';
        } else if (error.message.includes('Bibliothek nicht gefunden')) {
          errorMessage = 'Die ausgewählte Bibliothek wurde nicht gefunden. Bitte überprüfen Sie die Bibliothekskonfiguration.';
        } else if (error.message.includes('Server-Fehler')) {
          errorMessage = 'Server-Fehler beim Laden der Prompts. Bitte überprüfen Sie, ob der Bibliothekspfad existiert und zugänglich ist.';
        } else if (error.message.includes('Keine aktive Bibliothek')) {
          errorMessage = 'Keine aktive Bibliothek verfügbar. Bitte wählen Sie eine Bibliothek aus.';
        }
      }
      
      setError(errorMessage);
      toast({
        title: "Fehler beim Laden der Prompts",
        description: errorMessage,
        variant: "destructive",
      });
    } finally {
      setIsLoading(false);
    }
  }, [providerInstance, libraryStatus, activeLibrary, listItems, setTemplates, setTemplatesFolderId, setIsLoading, setError, toast, ensureTemplatesFolder]);

  // Effect für Template Loading (wie Library-Komponente)
  useEffect(() => {
    const isReady = providerInstance && libraryStatus === 'ready' && activeLibrary
    
    if (!isReady) {
      return
    }

    // Templates laden wenn noch nicht geladen
    if (!templatesFolderId) {
      loadTemplates()
    }
  }, [providerInstance, libraryStatus, activeLibrary, templatesFolderId, loadTemplates])

  // Reset wenn sich die Library ändert
  useEffect(() => {
    setSelectedTemplateName(null)
    setTemplatesFolderId(null)
    setTemplates([])
    setError(null)
  }, [libraryStatus, setSelectedTemplateName, setTemplatesFolderId, setTemplates, setError])

  useEffect(() => {
    async function loadSelectedContext() {
      if (!providerInstance || !Array.isArray(selectedContextIds) || selectedContextIds.length === 0) {
        setSelectedContextMarkdown("")
        return
      }
      try {
        const parts: string[] = []
        for (const id of selectedContextIds) {
          const { blob } = await providerInstance.getBinary(id)
          const text = await blob.text()
          const name = Array.isArray(contextDocs) ? (contextDocs.find(d => d.id === id)?.name || id) : id
          const section = `\n\n---\nDatei: ${name}\n---\n\n${text}\n\n---\nEnde Datei: ${name}\n---\n`
          parts.push(section)
        }
        setSelectedContextMarkdown(parts.join("\n\n"))
      } catch (e) {
        console.error('Fehler beim Laden des Kontextes', e)
        setSelectedContextMarkdown("")
      }
    }
    void loadSelectedContext()
  }, [providerInstance, selectedContextIds, contextDocs])

  function parseTemplateContent(content: string, fileName: string): Template {
    // Template in drei Bereiche aufteilen
    const parts = content.split('--- systemprompt')
    
    let yamlFrontmatter = ""
    let markdownBody = ""
    let systemPrompt = ""
    
    if (parts.length >= 2) {
      const mainContent = parts[0].trim()
      systemPrompt = parts[1].trim()
      
      // YAML Frontmatter extrahieren
      const yamlMatch = mainContent.match(/^---\r?\n([\s\S]*?)\r?\n---\r?\n?([\s\S]*)$/)
      if (yamlMatch) {
        yamlFrontmatter = `---\n${yamlMatch[1]}\n---`
        markdownBody = yamlMatch[2].trim()
      } else {
        // Kein YAML Frontmatter gefunden
        markdownBody = mainContent
      }
    } else {
      // Kein Systemprompt gefunden
      const yamlMatch = content.match(/^---\r?\n([\s\S]*?)\r?\n---\r?\n?([\s\S]*)$/)
      if (yamlMatch) {
        yamlFrontmatter = `---\n${yamlMatch[1]}\n---`
        markdownBody = yamlMatch[2].trim()
      } else {
        markdownBody = content
      }
    }

    return {
      name: fileName,
      yamlFrontmatter,
      markdownBody,
      systemPrompt,
    }
  }

  function generateTemplateContent(values: TemplateFormValues): string {
    let content = ""
    
    // YAML Frontmatter hinzufügen
    if (values.yamlFrontmatter.trim()) {
      content += values.yamlFrontmatter + "\n\n"
    }
    
    // Markdown Body hinzufügen
    content += values.markdownBody
    
    // System Prompt hinzufügen
    if (values.systemPrompt.trim()) {
      content += "\n\n--- systemprompt\n" + values.systemPrompt
    }
    
    return content
  }

  async function onSubmit(data: TemplateFormValues) {
    if (!activeLibrary || !templatesFolderId || !providerInstance) {
      toast({
        title: "Fehler",
        description: "Keine aktive Bibliothek oder Templates-Ordner nicht gefunden.",
        variant: "destructive",
      })
      return
    }

    setIsSaving(true)
    try {
      const templateContent = generateTemplateContent(data)
      const fileName = `${data.name}.md`
      
      // Datei als Blob erstellen
      const blob = new Blob([templateContent], { type: 'text/markdown' })
      const file = new File([blob], fileName, { type: 'text/markdown' })
      
      // Datei hochladen
      await providerInstance.uploadFile(templatesFolderId, file)
      
      // Templates neu laden
      await loadTemplates()
      
      // Auswahl auf das neue Template setzen
      setSelectedTemplateName(data.name)
      
      toast({
        title: "Template gespeichert",
        description: `Template "${data.name}" wurde erfolgreich im Verzeichnis "/templates" gespeichert.`,
      })
    } catch (error) {
      console.error('Fehler beim Speichern des Templates:', error)
      toast({
        title: "Fehler beim Speichern",
        description: error instanceof Error ? error.message : "Unbekannter Fehler",
        variant: "destructive",
      })
    } finally {
      setIsSaving(false)
    }
  }

  async function renameCurrentTemplate() {
    const current = selectedTemplateName ? templates.find(t => t.name === selectedTemplateName) : null
    if (!current || !current.fileId || !providerInstance) return
    const newName = (window.prompt('Neuen Namen eingeben:', current.name) || '').trim()
    if (!newName || newName === current.name) return
    if (/[^a-zA-Z0-9._\- ]/.test(newName)) { toast({ title: 'Ungültiger Name', description: 'Nur Buchstaben, Zahlen, Leerzeichen, . _ - sind erlaubt.', variant: 'destructive' }); return }
    if (templates.some(t => t.name.toLowerCase() === newName.toLowerCase())) { toast({ title: 'Bereits vorhanden', description: 'Bitte anderen Namen wählen.', variant: 'destructive' }); return }
    try {
      await providerInstance.renameItem(current.fileId, `${newName}.md`)
      await loadTemplates()
      setSelectedTemplateName(newName)
      form.setValue('name', newName, { shouldDirty: false })
      toast({ title: 'Umbenannt', description: `${current.name} → ${newName}` })
    } catch (e) {
      toast({ title: 'Fehler beim Umbenennen', description: e instanceof Error ? e.message : 'Unbekannter Fehler', variant: 'destructive' })
    }
  }

  async function deleteTemplate(templateName: string) {
    if (!activeLibrary || !providerInstance) return

    try {
      const template = templates.find(t => t.name === templateName)
      if (!template?.fileId) {
        throw new Error("Template-Datei nicht gefunden")
      }

      // Datei löschen
      await providerInstance.deleteItem(template.fileId)

      // Templates neu laden
      await loadTemplates()
      
      if (selectedTemplateName === templateName) {
        setSelectedTemplateName(null)
        form.reset()
      }
      
      toast({
        title: "Template gelöscht",
        description: `Template "${templateName}" wurde erfolgreich gelöscht.`,
      })
    } catch (error) {
      console.error('Fehler beim Löschen des Templates:', error)
      toast({
        title: "Fehler beim Löschen",
        description: error instanceof Error ? error.message : "Unbekannter Fehler",
        variant: "destructive",
      })
    }
  }

  async function createNewTemplate() {
    const name = (window.prompt('Neuen Template‑Namen eingeben:') || '').trim()
    if (!name) return
    if (/[^a-zA-Z0-9._\- ]/.test(name)) { toast({ title: 'Ungültiger Name', description: 'Nur Buchstaben, Zahlen, Leerzeichen, . _ - sind erlaubt.', variant: 'destructive' }); return }
    if (templates.some(t => t.name.toLowerCase() === name.toLowerCase())) { toast({ title: 'Bereits vorhanden', description: 'Bitte anderen Namen wählen.', variant: 'destructive' }); return }
    if (!providerInstance) { toast({ title: 'Kein Provider' , variant: 'destructive' }); return }
    try {
      const folderId = await ensureTemplatesFolder()
      const values = getDefaultTemplateValues(name)
      const content = (values.yamlFrontmatter ? values.yamlFrontmatter + '\n\n' : '') + values.markdownBody + '\n\n--- systemprompt\n' + values.systemPrompt
      const file = new File([new Blob([content], { type: 'text/markdown' })], `${name}.md`, { type: 'text/markdown' })
      await providerInstance.uploadFile(folderId, file)
      await loadTemplates()
      setSelectedTemplateName(name)
      form.reset(values)
      toast({ title: 'Template angelegt', description: `"${name}" wurde erstellt.` })
    } catch (e) {
      toast({ title: 'Fehler beim Anlegen', description: e instanceof Error ? e.message : 'Unbekannter Fehler', variant: 'destructive' })
    }
  }

  function generatePreview(): string {
    const values = form.getValues()
    return generateTemplateContent(values)
  }

  async function testTemplate() {
    if (!activeLibrary) return

    setIsTesting(true)
    setTestResult(null)

    const values = form.getValues()
    const templateContent = generateTemplateContent(values)
    const sections: string[] = []
    if (selectedContextMarkdown.trim()) sections.push(selectedContextMarkdown.trim())
    if (freeText.trim()) sections.push(`---\nDatei: Freitext\n---\n\n${freeText.trim()}\n\n---\nEnde Datei: Freitext\n---`)
    const testText = sections.join("\n\n")

    const pickMarkdown = (result: unknown): string => {
      if (typeof result === 'string') return result
      if (result && typeof result === 'object') {
        const obj = result as Record<string, unknown>
        const directCandidates = ['text','markdown','content','output'] as const
        for (const k of directCandidates) {
          const v = obj[k]
          if (typeof v === 'string') return v
        }
        // verschachtelte Felder prüfen
        const nested = obj['data']
        if (nested && typeof nested === 'object') {
          const nobj = nested as Record<string, unknown>
          for (const k of directCandidates) {
            const v = nobj[k]
            if (typeof v === 'string') return v
          }
        }
      }
      return JSON.stringify(result, null, 2)
    }

    try {
      const response = await fetch('/api/secretary/process-text', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/x-www-form-urlencoded',
          'X-Library-Id': activeLibrary.id,
        },
        body: new URLSearchParams({
          text: testText,
          template_content: templateContent,
          source_language: 'de',
          target_language: 'de',
          use_cache: 'false',
        }),
      })

      if (!response.ok) {
        const errorData = await response.json()
        throw new Error(errorData.error || `HTTP ${response.status}: ${response.statusText}`)
      }

      const result = await response.json()
      const formattedResult = pickMarkdown(result)
      console.log('Prompt-Test Ergebnis:', formattedResult)
      
      setTestResult(formattedResult)
      setRightTab('testen')

      toast({
        title: "Prompt-Test erfolgreich",
        description: "Der Prompt wurde erfolgreich mit dem gewählten Kontext verarbeitet.",
      })

      console.log('Prompt-Test Ergebnis (roh):', result)
    } catch (error) {
      console.error('Fehler beim Prompt-Test:', error)
      const errorMessage = error instanceof Error ? error.message : "Unbekannter Fehler"
      setTestResult(`Fehler: ${errorMessage}`)
      setRightTab('testen')
      toast({
        title: "Prompt-Test fehlgeschlagen",
        description: errorMessage,
        variant: "destructive",
      })
    } finally {
      setIsTesting(false)
    }
  }

  async function ensurePromptTestsFolder(): Promise<string> {
    if (!providerInstance) throw new Error('Kein Provider verfügbar')
    const roots = await listItems('root')
    const found = roots.find(it => it.type === 'folder' && it.metadata.name === 'prompt-tests')
    if (found) return found.id
    const created = await providerInstance.createFolder('root', 'prompt-tests')
    return created.id
  }

  async function saveTestResult() {
    try {
      if (!providerInstance || !activeLibrary || !testResult) return
      const folderId = await ensurePromptTestsFolder()
      const name = `${selectedTemplateName || 'prompt'}-test-${new Date().toISOString().replace(/[:.]/g,'-')}.md`
      const blob = new Blob([testResult], { type: 'text/markdown' })
      const file = new File([blob], name, { type: 'text/markdown' })
      const item = await providerInstance.uploadFile(folderId, file)
      setResultSavedItemId(item.id)
      toast({ title: 'Ergebnis gespeichert', description: name })
    } catch (e) {
      toast({ title: 'Speichern fehlgeschlagen', description: e instanceof Error ? e.message : 'Unbekannter Fehler', variant: 'destructive' })
    }
  }

  // Render-Logik für verschiedene Status
  if (libraryStatus === "waitingForAuth") {
    return (
      <div className="flex flex-col items-center justify-center h-full text-muted-foreground">
        <span>Diese Bibliothek benötigt eine Authentifizierung.</span>
        <span className="text-sm mt-2">Bitte konfigurieren Sie die Bibliothek in den Einstellungen.</span>
      </div>
    )
  }
  
  if (libraryStatus !== "ready") {
    return (
      <div className="flex flex-col items-center justify-center h-full text-muted-foreground">
        <span>Lade Storage...</span>
      </div>
    )
  }

  if (!activeLibrary) {
    return (
      <div className="text-center text-muted-foreground">
        Bitte wählen Sie eine Bibliothek aus.
      </div>
    )
  }

  if (error) {
    return (
      <div className="text-center text-destructive">
        <p>Fehler beim Laden der Prompts:</p>
        <p className="text-sm">{error}</p>
        <Button 
          variant="outline" 
          className="mt-4"
          onClick={loadTemplates}
        >
          Erneut versuchen
        </Button>
      </div>
    )
  }

  return (
    <div className="space-y-6">

      {/* Kompakte Toolbar oben */}
      <div className="flex items-center gap-2">
        <Select value={selectedTemplateName || ''} onValueChange={(v) => { setSelectedTemplateName(v); form.setValue('name', v, { shouldDirty: false }) }} disabled={isLoading}>
          <SelectTrigger className="w-64">
            <SelectValue placeholder="Prompt auswählen..." />
          </SelectTrigger>
          <SelectContent>
            {templates.map((t) => (
              <SelectItem key={t.name} value={t.name}>{t.name}</SelectItem>
            ))}
          </SelectContent>
        </Select>
        <TooltipProvider>
          <Tooltip>
            <TooltipTrigger asChild>
              <Button variant="ghost" size="sm" className="h-8 w-8 p-0"><Info className="h-4 w-4" /></Button>
            </TooltipTrigger>
            <TooltipContent>
              <div className="flex items-center gap-2"><FolderOpen className="h-4 w-4" /><span>Ort: /templates in „{activeLibrary.label}“</span></div>
            </TooltipContent>
          </Tooltip>
        </TooltipProvider>
        <Button type="button" variant="outline" size="sm" onClick={createNewTemplate} disabled={isLoading}>Neu</Button>
        <Button type="button" variant="outline" size="sm" onClick={renameCurrentTemplate} disabled={!selectedTemplateName}>Umbenennen</Button>
        {selectedTemplateName && (
          <Button type="button" variant="destructive" size="sm" onClick={() => deleteTemplate(selectedTemplateName!)}>Löschen</Button>
        )}
      </div>

      <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
        <Card>
          <CardHeader>
            <CardTitle>Prompt Design</CardTitle>
            <CardDescription>
              Drei Bereiche: Aufgabe (was), Rollenanweisung (wie), Metadaten (Begleitinfos).
            </CardDescription>
          </CardHeader>
          <CardContent>
            <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-6">
              {/* Template-Name Feld entfernt (oben verwaltet) */}

              {previewMode ? (
                <div className="space-y-4">
                  <div className="flex items-center justify-between">
                    <h4 className="text-sm font-medium">Prompt-Vorschau</h4>
                    <Button
                      type="button"
                      variant="outline"
                      size="sm"
                      onClick={() => setPreviewMode(false)}
                    >
                      Bearbeiten
                    </Button>
                  </div>
                  <div className="border rounded-md p-4 bg-muted/50">
                    <pre className="text-sm whitespace-pre-wrap font-mono">
                      {generatePreview()}
                    </pre>
                  </div>
                </div>
              ) : (
                <StructuredTemplateEditor
                  markdownBody={form.watch('markdownBody')}
                  yamlFrontmatter={form.watch('yamlFrontmatter')}
                  systemPrompt={form.watch('systemPrompt')}
                  onChange={({ markdownBody, yamlFrontmatter, systemPrompt }) => {
                    form.setValue('markdownBody', markdownBody, { shouldDirty: true })
                    form.setValue('yamlFrontmatter', yamlFrontmatter, { shouldDirty: true })
                    form.setValue('systemPrompt', systemPrompt, { shouldDirty: true })
                  }}
                />
              )}

              <div className="flex justify-end gap-2">
                <Button
                  type="button"
                  variant="outline"
                  onClick={() => setPreviewMode(!previewMode)}
                >
                  <Eye className="h-4 w-4 mr-2" />
                  {previewMode ? "Bearbeiten" : "Vorschau"}
                </Button>
                <Button
                  type="submit"
                  disabled={isSaving || !form.formState.isDirty}
                >
                  {isSaving ? (
                    <>
                      <Loader2 className="h-4 w-4 mr-2 animate-spin" />
                      Wird gespeichert...
                    </>
                  ) : (
                    <>
                      <Save className="h-4 w-4 mr-2" />
                      Speichern
                    </>
                  )}
                </Button>
              </div>
            </form>
          </CardContent>
        </Card>

        <Card>
          <CardHeader>
            <CardTitle>Prompt testen</CardTitle>
            <CardDescription>
              Test mit Beispieltext. Nutzt Rollenanweisung, Aufgabe und Metadaten des Prompts.
            </CardDescription>
          </CardHeader>
          <CardContent>
            <Tabs value={rightTab} onValueChange={(v) => setRightTab(v as typeof rightTab)}>
              <TabsList className="grid grid-cols-3 w-full">
                <TabsTrigger value="kontext">Daten‑Kontext</TabsTrigger>
                <TabsTrigger value="preview">Prompt‑Vorschau</TabsTrigger>
                <TabsTrigger value="testen">Testen</TabsTrigger>
              </TabsList>

              <TabsContent value="kontext" className="space-y-4 mt-4">
                <div className="space-y-2">
                  <Label>Kontext-Texte</Label>
                  <div className="border rounded p-2 text-sm">
                    {Array.isArray(contextDocs) && contextDocs.length > 0 ? (
                      contextDocs.map(d => {
                        const checked = selectedContextIds.includes(d.id)
                        return (
                          <label key={d.id} className="flex items-center gap-2 py-1">
                            <Checkbox
                              checked={checked}
                              onCheckedChange={(v) => {
                                const isOn = v === true
                                setSelectedContextIds(prev => isOn ? [...prev, d.id] : prev.filter(x => x !== d.id))
                              }}
                            />
                            <span className="truncate">{d.name}</span>
                          </label>
                        )
                      })
                    ) : (
                      <div className="text-muted-foreground text-sm">Keine Kontext-Texte verfügbar</div>
                    )}
                  </div>
                </div>

                <div className="space-y-2">
                  <Label>Gewählter Kontext (Lesemodus)</Label>
                  <div className="border rounded-md">
                    <MarkdownPreview content={selectedContextMarkdown} />
                  </div>
                </div>

                <div className="space-y-2">
                  <Label>Freitext (optional)</Label>
                  <Textarea
                    value={freeText}
                    onChange={(e) => setFreeText(e.target.value)}
                    placeholder="Hier Text einkleben, um schnell zu testen"
                    className="min-h-[120px] font-mono text-sm"
                  />
                </div>
              </TabsContent>

              <TabsContent value="preview" className="space-y-4 mt-4">
                <div className="space-y-2">
                  <Label>Generierter Prompt (Markdown)</Label>
                  <div className="border rounded-md">
                    <MarkdownPreview content={generatePreview()} />
                  </div>
                </div>
               </TabsContent>

              <TabsContent value="testen" className="space-y-4 mt-4">
                <div className="flex gap-2 justify-end">
                  <Button 
                    variant="outline" 
                    size="sm"
                    onClick={testTemplate}
                    disabled={!selectedTemplateName || isTesting}
                  >
                    {isTesting ? (
                      <>
                        <Loader2 className="h-4 w-4 mr-2 animate-spin" />
                        Teste...
                      </>
                    ) : (
                      <>
                        <Play className="h-4 w-4 mr-2" />
                        Prompt testen
                      </>
                    )}
                  </Button>
                </div>
                {activeLibrary && providerInstance && (testResult || resultSavedItemId) ? (
                  <JobReportTab
                    libraryId={activeLibrary.id}
                    fileId={resultSavedItemId || 'preview'}
                    provider={providerInstance}
                    sourceMode="frontmatter"
                    viewMode="metaOnly"
                    mdFileId={resultSavedItemId || undefined}
                    rawContent={testResult || undefined}
                  />
                ) : (
                  <div className="text-sm text-muted-foreground">Kein Ergebnis vorhanden.</div>
                )}
                <div className="flex gap-2">
                  <Button type="button" onClick={saveTestResult} disabled={!testResult}>Speichern</Button>
                </div>
              </TabsContent>
            </Tabs>
          </CardContent>
        </Card>
      </div>
    </div>
  )
} 
```

Ich habe die obere Tab-Ebene im Bereich „Testen“ entfernt. Es bleibt nur noch die einheitliche Ansicht des `JobReportTab` mit den drei Reitern „Markdown | Metadaten | Kapitel“. Der Speichern-Button steht darunter.

---

**User**

@job-report-tab.tsx In diesem JobReport Tab können wir unter dem Reiter Markdown FrontMatter und Fernen, die werden ja unter Metadaten angezeigt.

---

**Cursor**

```typescriptreact
"use client";

import { useEffect, useState } from 'react'
import { UILogger } from '@/lib/debug/logger'
import type { StorageProvider } from '@/lib/storage/types'
import { MarkdownPreview } from '@/components/library/markdown-preview'
import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs'
import { parseSecretaryMarkdownStrict } from '@/lib/secretary/response-parser'

interface JobReportTabProps {
  libraryId: string
  fileId: string
  fileName?: string
  provider?: StorageProvider | null
  // Quelle der Metadaten steuern: 'merged' = cumulativeMeta + Frontmatter (Standard),
  // 'frontmatter' = ausschließlich Frontmatter aus Markdown anzeigen
  sourceMode?: 'merged' | 'frontmatter'
  // Darstellungsmodus: 'full' zeigt Kopf/Steps/Logs/Parameter; 'metaOnly' zeigt nur Metadaten/Kapitel/TOC
  viewMode?: 'full' | 'metaOnly'
  // Optional explizite Markdown-Datei-ID (Shadow‑Twin). Überschreibt auto-Erkennung.
  mdFileId?: string | null
  // Optionaler Callback zum Scroll-Sync in die Markdown-Vorschau
  onJumpTo?: (args: { page?: number | string; evidence?: string }) => void
  // NEU: Rohinhalt (Markdown). Wenn gesetzt und sourceMode='frontmatter', wird direkt dieser Text geparst (ohne Datei/JOB).
  rawContent?: string
}

interface JobDto {
  jobId: string
  status: string
  operation: string
  worker: string
  job_type: string
  updatedAt: string
  createdAt: string
  correlation?: { source?: { itemId?: string; name?: string } }
  parameters?: Record<string, unknown>
  steps?: Array<{ name: string; status: string; startedAt?: string; endedAt?: string; error?: { message: string }; details?: { skipped?: boolean } }>
  ingestion?: { vectorsUpserted?: number; index?: string; upsertAt?: string }
  result?: { savedItemId?: string }
  logs?: Array<{ timestamp: string; phase?: string; message?: string; progress?: number }>
  cumulativeMeta?: Record<string, unknown>
}

export function JobReportTab({ libraryId, fileId, fileName, provider, sourceMode = 'merged', viewMode = 'full', mdFileId, onJumpTo, rawContent }: JobReportTabProps) {
  const [loading, setLoading] = useState(false)
  const [error, setError] = useState<string | null>(null)
  const [job, setJob] = useState<JobDto | null>(null)
  const [templateFields, setTemplateFields] = useState<string[] | null>(null)
  const [frontmatterMeta, setFrontmatterMeta] = useState<Record<string, unknown> | null>(null)
  const [section, setSection] = useState<'meta' | 'chapters'>('meta')
  const [parseErrors, setParseErrors] = useState<string[]>([])
  const [fullContent, setFullContent] = useState<string>('')

  const stripFrontmatter = (markdown: string): string => markdown.replace(/^---\r?\n([\s\S]*?)\r?\n---\r?\n?/, '')

  useEffect(() => {
    let cancelled = false
    async function run() {
      try {
        // Wenn wir Rohinhalt haben und nur Frontmatter zeigen, brauchen wir keine Job-Suche
        if (sourceMode === 'frontmatter' && typeof rawContent === 'string' && rawContent.length > 0) {
          setJob(null)
          setLoading(false)
          setError(null)
          return
        }
        setLoading(true)
        setError(null)
        UILogger.info('JobReportTab', 'Start Job-Suche', { libraryId, fileId })
        // 1) Versuche Job über result.savedItemId (Shadow‑Twin) zu finden
        const byResultUrl = new URL(`/api/external/jobs`, window.location.origin)
        byResultUrl.searchParams.set('byResultItemId', fileId)
        UILogger.debug('JobReportTab', 'Request byResultItemId', { url: byResultUrl.toString() })
        let res = await fetch(byResultUrl.toString(), { cache: 'no-store' })
        let data = await res.json()
        if (!res.ok) throw new Error(typeof data?.error === 'string' ? data.error : 'Job-Suche fehlgeschlagen')
        let j: JobDto | null = Array.isArray(data?.items) && data.items.length > 0 ? (data.items[0] as JobDto) : null
        UILogger.debug('JobReportTab', 'Result byResultItemId', { count: Array.isArray(data?.items) ? data.items.length : 0 })

        // 2) Fallback: über correlation.source.itemId (Originaldatei)
        if (!j) {
          const bySourceUrl = new URL(`/api/external/jobs`, window.location.origin)
          bySourceUrl.searchParams.set('bySourceItemId', fileId)
          bySourceUrl.searchParams.set('libraryId', libraryId)
          UILogger.debug('JobReportTab', 'Request bySourceItemId', { url: bySourceUrl.toString() })
          res = await fetch(bySourceUrl.toString(), { cache: 'no-store' })
          data = await res.json()
          if (!res.ok) throw new Error(typeof data?.error === 'string' ? data.error : 'Job-Suche (Quelle) fehlgeschlagen')
          j = Array.isArray(data?.items) && data.items.length > 0 ? (data.items[0] as JobDto) : null
          UILogger.debug('JobReportTab', 'Result bySourceItemId', { count: Array.isArray(data?.items) ? data.items.length : 0 })
        }

        // 3) Fallback: über correlation.source.name (Dateiname der Quelle)
        if (!j) {
          const byNameUrl = new URL(`/api/external/jobs`, window.location.origin)
          // Wenn wir den tatsächlichen Dateinamen kennen, verwende ihn.
          // Für Shadow‑Twins (z. B. name.de.md) versuche das Basis‑PDF (name.pdf).
          let candidate = (fileName && typeof fileName === 'string') ? fileName : (fileId.includes('/') ? (fileId.split('/').pop() as string) : fileId)
          const parts = candidate.split('.')
          if (parts.length >= 3) {
            const ext1 = parts[parts.length - 1].toLowerCase()
            const ext2 = parts[parts.length - 2].toLowerCase()
            if ((ext1 === 'md' || ext1 === 'mdx') && /^[a-z]{2}$/i.test(ext2)) {
              candidate = parts.slice(0, -2).join('.') + '.pdf'
            }
          }
          byNameUrl.searchParams.set('bySourceName', candidate)
          byNameUrl.searchParams.set('libraryId', libraryId)
          UILogger.debug('JobReportTab', 'Request bySourceName', { url: byNameUrl.toString(), nameOnly: candidate, originalFileName: fileName })
          res = await fetch(byNameUrl.toString(), { cache: 'no-store' })
          data = await res.json()
          if (!res.ok) throw new Error(typeof data?.error === 'string' ? data.error : 'Job-Suche (Name) fehlgeschlagen')
          j = Array.isArray(data?.items) && data.items.length > 0 ? (data.items[0] as JobDto) : null
          UILogger.debug('JobReportTab', 'Result bySourceName', { count: Array.isArray(data?.items) ? data.items.length : 0 })
        }

        if (!cancelled) setJob(j)
        if (j) UILogger.info('JobReportTab', 'Job gefunden', { jobId: j.jobId, status: j.status })
        else UILogger.warn('JobReportTab', 'Kein Job gefunden', { libraryId, fileId })
      } catch (e) {
        const msg = e instanceof Error ? e.message : 'Unbekannter Fehler'
        UILogger.error('JobReportTab', 'Job-Suche fehlgeschlagen', e)
        if (!cancelled) setError(msg)
      } finally {
        if (!cancelled) setLoading(false)
      }
    }
    void run()
    return () => { cancelled = true }
  }, [libraryId, fileId, fileName, sourceMode, rawContent])

  // Wenn Template benutzt wurde, lade dessen Inhalt aus /templates und extrahiere Frontmatter-Schlüssel
  useEffect(() => {
    async function loadTemplateFields() {
      try {
        setTemplateFields(null)
        const tpl = job?.cumulativeMeta && typeof (job.cumulativeMeta as unknown) === 'object'
          ? (job.cumulativeMeta as Record<string, unknown>)['template_used']
          : undefined
        const templateName = typeof tpl === 'string' ? tpl : undefined
        if (!templateName || !provider) return
        const rootItems = await provider.listItemsById('root')
        const templatesFolder = rootItems.find(it => it.type === 'folder' && typeof (it as { metadata?: { name?: string } }).metadata?.name === 'string' && ((it as { metadata: { name: string } }).metadata.name.toLowerCase() === 'templates'))
        if (!templatesFolder) return
        const tplItems = await provider.listItemsById(templatesFolder.id)
        const match = tplItems.find(it => it.type === 'file' && ((it as { metadata: { name: string } }).metadata.name.toLowerCase() === templateName.toLowerCase()))
        if (!match) return
        const bin = await provider.getBinary(match.id)
        const text = await bin.blob.text()
        // Extrahiere Frontmatter zwischen den ersten beiden --- und lese die Keys bis zu :
        const m = text.match(/^---[\s\S]*?---/)
        if (!m) return
        const fm = m[0]
        const keys: string[] = []
        for (const line of fm.split('\n')) {
          const t = line.trim()
          if (!t || t === '---') continue
          const idx = t.indexOf(':')
          if (idx > 0) {
            const k = t.slice(0, idx).trim()
            if (k) keys.push(k)
          }
        }
        setTemplateFields(Array.from(new Set(keys)))
      } catch (e) {
        UILogger.warn('JobReportTab', 'Template-Felder konnten nicht geladen werden', { error: e instanceof Error ? e.message : String(e) })
      }
    }
    void loadTemplateFields()
  }, [job, provider])

  // Gemeinsamer strikter Parser
  const strictParseFrontmatter = (fm: string) => parseSecretaryMarkdownStrict(fm)

  // Frontmatter aus der gespeicherten Markdown-Datei lesen (oder aus rawContent)
  useEffect(() => {
    async function loadFrontmatter() {
      try {
        setParseErrors([])
        // Wenn roher Inhalt übergeben wurde, direkt daraus lesen
        if (sourceMode === 'frontmatter' && typeof rawContent === 'string' && rawContent.length > 0) {
          const text = rawContent
          setFullContent(text)
          const { frontmatter, meta, errors } = parseSecretaryMarkdownStrict(text)
          UILogger.debug('JobReportTab', 'Frontmatter (raw): Block gefunden?', { found: !!frontmatter, length: frontmatter ? frontmatter.length : 0 })
          if (!frontmatter) { setFrontmatterMeta(null); return }
          setFrontmatterMeta(Object.keys(meta).length ? meta : null)
          setParseErrors(errors)
          return
        }

        if (!provider) return
        const mdId = (mdFileId || (job?.result?.savedItemId as string | undefined) || fileId)
        UILogger.info('JobReportTab', 'Frontmatter: Lade Datei', { mdId, sourceMode })
        if (!mdId) return
        const bin = await provider.getBinary(mdId)
        const text = await bin.blob.text()
        setFullContent(text)
        const { frontmatter, meta, errors } = parseSecretaryMarkdownStrict(text)
        UILogger.debug('JobReportTab', 'Frontmatter: Block gefunden?', { found: !!frontmatter, length: frontmatter ? frontmatter.length : 0 })
        if (!frontmatter) { setFrontmatterMeta(null); return }
        setFrontmatterMeta(Object.keys(meta).length ? meta : null)
        setParseErrors(errors)
      } catch {
        setFrontmatterMeta(null)
      }
    }
    void loadFrontmatter()
  }, [provider, fileId, mdFileId, job?.result?.savedItemId, sourceMode, rawContent])

  if (sourceMode !== 'frontmatter') {
    if (loading) return <div className="p-4 text-sm text-muted-foreground">Lade Job…</div>
    if (error) return <div className="p-4 text-sm text-destructive">{error}</div>
    if (!job) return <div className="p-4 text-sm text-muted-foreground">Kein Job zur Datei gefunden.</div>
  }

  return (
    <div className="p-4 space-y-3 text-sm">
      {viewMode === 'metaOnly' && (
        <Tabs defaultValue="markdown">
          <TabsList className="grid grid-cols-3 w-full">
            <TabsTrigger value="markdown">Markdown</TabsTrigger>
            <TabsTrigger value="meta">Metadaten</TabsTrigger>
            <TabsTrigger value="chapters">Kapitel</TabsTrigger>
          </TabsList>

          <TabsContent value="markdown" className="mt-3">
            <div className="border rounded-md">
              <MarkdownPreview content={stripFrontmatter(fullContent || '')} />
            </div>
          </TabsContent>

          <TabsContent value="meta" className="mt-3">
            {/* Hinweise zu Parserfehlern (strikt) */}
            {parseErrors.length > 0 && (
              <div className="text-xs text-destructive mb-2">
                {parseErrors.map((e, i) => (<div key={i}>Parserfehler: {e}</div>))}
              </div>
            )}
            {(() => {
              const base: Record<string, unknown> = sourceMode === 'frontmatter'
                ? {}
                : ((job?.cumulativeMeta as unknown as Record<string, unknown>) || {})
              const cm = frontmatterMeta ? { ...base, ...frontmatterMeta } : base
              const baseKeys = Array.isArray(templateFields) && templateFields.length > 0
                ? templateFields
                : Object.keys(cm)
              const flatKeys = baseKeys.filter(k => k !== 'chapters' && k !== 'toc')
              if (flatKeys.length === 0) return null
              return (
                <div>
                  <div className="font-medium mb-1">Metadaten (Template vs. Ergebnis)</div>
                  <div className="overflow-auto">
                    <table className="w-full text-xs">
                      <thead>
                        <tr className="text-left text-muted-foreground">
                          <th className="py-1 pr-2">Feld</th>
                          <th className="py-1 pr-2">Wert</th>
                        </tr>
                      </thead>
                      <tbody>
                        {flatKeys.map((k) => {
                          const val = cm[k]
                          let valueStr = ''
                          if (Array.isArray(val)) valueStr = (val as Array<unknown>).map(v => typeof v === 'string' ? v : JSON.stringify(v)).join(', ')
                          else valueStr = val === null || val === undefined ? '' : typeof val === 'string' ? val : JSON.stringify(val)
                          return (
                            <tr key={k} className="border-t border-muted/40">
                              <td className="py-1 pr-2 align-top font-medium">{k}</td>
                              <td className="py-1 pr-2 align-top whitespace-pre-wrap break-words">{valueStr}</td>
                            </tr>
                          )
                        })}
                      </tbody>
                    </table>
                  </div>
                </div>
              )
            })()}
          </TabsContent>

          <TabsContent value="chapters" className="mt-3">
            {(() => {
              const chapters: Array<Record<string, unknown>> = sourceMode === 'frontmatter'
                ? (Array.isArray(frontmatterMeta?.chapters) ? (frontmatterMeta?.chapters as Array<Record<string, unknown>>) : [])
                : ((job?.cumulativeMeta as unknown as { chapters?: Array<Record<string, unknown>> })?.chapters || [])
              if (!Array.isArray(chapters) || chapters.length === 0) return null
              const pad = (lvl: number | undefined): number => {
                if (typeof lvl !== 'number') return 0
                const clamped = Math.max(0, Math.min(3, lvl))
                return (clamped - 1) * 16
              }
              const counters = [0, 0, 0]
              return (
                <div className="space-y-1">
                  <div>
                    {chapters.map((c, i) => {
                      const level = typeof c.level === 'number' ? c.level : 1
                      const lvl = Math.max(1, Math.min(3, level))
                      counters[lvl - 1] += 1
                      for (let j = lvl; j < counters.length; j++) counters[j] = 0
                      const numLabel = counters.slice(0, lvl).filter(n => n > 0).join('.')
                      const title = typeof c.title === 'string' ? c.title : ''
                      const startPage = typeof c.startPage === 'number' ? c.startPage : ''
                      const summaryVal = typeof c.summary === 'string' ? c.summary : ''
                      const summary = summaryVal.length > 1000 ? `${summaryVal.slice(0, 1000)}…` : summaryVal
                      const keywords = Array.isArray(c.keywords) ? (c.keywords as Array<unknown>).filter(v => typeof v === 'string') as string[] : []
                      const ev = typeof c.startEvidence === 'string' ? c.startEvidence : ''
                      return (
                        <details key={`${title}-${i}`} className="group border-b py-1" open={false}>
                          <summary className="list-none cursor-pointer">
                            <div className="flex items-start justify-between gap-3">
                              <div className="flex-1 min-w-0" style={{ paddingLeft: `${pad(lvl)}px` }}>
                                <div className="flex items-baseline gap-2">
                                  <span className="text-xs text-muted-foreground tabular-nums">{numLabel}</span>
                                  <span className="font-medium truncate">{title}</span>
                                </div>
                              </div>
                              <div className="text-xs tabular-nums text-muted-foreground whitespace-nowrap">
                                {String(startPage)}
                              </div>
                            </div>
                          </summary>
                          <div className="mt-1 pr-1 text-xs space-y-1" style={{ paddingLeft: `${pad(lvl) + 28}px` }}>
                            {summary && (
                              <div className="whitespace-pre-wrap break-words">
                                {summary}
                              </div>
                            )}
                            {Array.isArray(keywords) && keywords.length > 0 && (
                              <div className="flex flex-wrap gap-1">
                                {keywords.map(k => (
                                  <span key={k} className="inline-flex items-center rounded px-1.5 py-0.5 bg-muted">{k}</span>
                                ))}
                              </div>
                            )}
                          </div>
                        </details>
                      )
                    })}
                  </div>
                </div>
              )
            })()}
          </TabsContent>
        </Tabs>
      )}

      {viewMode === 'full' && job && (
        <div className="flex items-center justify-between">
          <div>
            <div className="font-medium">Job {job.jobId}</div>
            <div className="text-xs text-muted-foreground">{job.job_type} · {job.operation} · {new Date(job.updatedAt).toLocaleString()}</div>
          </div>
          <div className="inline-flex items-center rounded px-2 py-0.5 bg-muted text-xs">{job.status}</div>
        </div>
      )}

      {/* Hinweise zu Parserfehlern (strikt) */}
      {viewMode !== 'metaOnly' && parseErrors.length > 0 && (
        <div className="text-xs text-destructive">
          {parseErrors.map((e, i) => (<div key={i}>Parserfehler: {e}</div>))}
        </div>
      )}

      {/* Template Hinweis (im Frontmatter-only-Modus ausgeblendet) */}
      {sourceMode !== 'frontmatter' && job && typeof job.cumulativeMeta?.template_used === 'string' && (
        <div className="text-xs text-muted-foreground">Template: {String(job.cumulativeMeta.template_used)}</div>
      )}

      {/* Schritte mit Ampel-Logik */}
      {viewMode === 'full' && job && Array.isArray(job.steps) && job.steps.length > 0 && (
        <div>
          <div className="font-medium mb-1">Schritte</div>
          <div className="flex flex-wrap gap-2 text-xs">
            {job.steps.map((s) => {
              // Geplante Phasen ermitteln (neue Flags bevorzugt, sonst phases)
              const p = (job.parameters || {}) as Record<string, unknown>
              const hasNewFlags = typeof p['doExtractPDF'] === 'boolean' || typeof p['doExtractMetadata'] === 'boolean' || typeof p['doIngestRAG'] === 'boolean'
              const phases = hasNewFlags
                ? {
                    extract: p['doExtractPDF'] === true,
                    template: p['doExtractMetadata'] === true,
                    ingest: p['doIngestRAG'] === true,
                  }
                : ((p['phases'] as { extract?: boolean; template?: boolean; ingest?: boolean }) || {})

              const planned = (() => {
                const n = s.name
                if (n === 'extract_pdf') return phases.extract === true
                if (n === 'transform_template' || n === 'store_shadow_twin') return phases.template === true
                if (n === 'ingest_rag') return phases.ingest === true
                return false
              })()

              // Ampel-Status ableiten
              const skipped = !!(s as { details?: { skipped?: boolean } }).details?.skipped
              let icon = '○'
              let cls = 'text-muted-foreground'
              if (s.status === 'failed') { icon = '✕'; cls = 'text-red-600' }
              else if (s.status === 'running') { icon = '◐'; cls = 'text-yellow-600' }
              else if (s.status === 'completed') { icon = skipped ? '○' : '✓'; cls = skipped ? 'text-gray-400' : 'text-green-600' }
              else if (s.status === 'pending') { icon = planned ? '•' : '○'; cls = planned ? 'text-yellow-600' : 'text-muted-foreground' }

              const time = s.endedAt ? new Date(s.endedAt).toLocaleTimeString() : s.startedAt ? new Date(s.startedAt).toLocaleTimeString() : ''
              return (
                <div key={s.name} className={`inline-flex items-center gap-1 px-2 py-1 rounded border ${cls}`}>
                  <span>{icon}</span>
                  <span className="font-medium">{s.name}</span>
                  {time ? <span className="opacity-70">{time}</span> : null}
                </div>
              )
            })}
          </div>
        </div>
      )}

      {/* Metadaten (flach) – je nach sourceMode: nur Frontmatter oder Merge (nur außerhalb metaOnly-View) */}
      {viewMode !== 'metaOnly' && section === 'meta' && (() => {
        const base: Record<string, unknown> = sourceMode === 'frontmatter'
          ? {}
          : ((job?.cumulativeMeta as unknown as Record<string, unknown>) || {})
        const cm = frontmatterMeta ? { ...base, ...frontmatterMeta } : base
        const baseKeys = Array.isArray(templateFields) && templateFields.length > 0
          ? templateFields
          : Object.keys(cm)
        const flatKeys = baseKeys.filter(k => k !== 'chapters' && k !== 'toc')
        if (flatKeys.length === 0) return null
        return (
        <div>
          <div className="font-medium mb-1">Metadaten (Template vs. Ergebnis)</div>
          <div className="overflow-auto">
            <table className="w-full text-xs">
              <thead>
                <tr className="text-left text-muted-foreground">
                  <th className="py-1 pr-2">Feld</th>
                  <th className="py-1 pr-2">Wert</th>
                </tr>
              </thead>
              <tbody>
                {flatKeys.map((k) => {
                  const val = cm[k]
                  let valueStr = ''
                  if (Array.isArray(val)) valueStr = (val as Array<unknown>).map(v => typeof v === 'string' ? v : JSON.stringify(v)).join(', ')
                  else valueStr = val === null || val === undefined ? '' : typeof val === 'string' ? val : JSON.stringify(val)
                  return (
                    <tr key={k} className="border-t border-muted/40">
                      <td className="py-1 pr-2 align-top font-medium">{k}</td>
                      <td className="py-1 pr-2 align-top whitespace-pre-wrap break-words">{valueStr}</td>
                    </tr>
                  )
                })}
              </tbody>
            </table>
          </div>
        </div>
        )
      })()}

      {/* Kapitel (hierarchisch, TOC-Ansicht) – nur außerhalb metaOnly-View */}
      {viewMode !== 'metaOnly' && section === 'chapters' && (() => {
        const chapters: Array<Record<string, unknown>> = sourceMode === 'frontmatter'
          ? (Array.isArray(frontmatterMeta?.chapters) ? (frontmatterMeta?.chapters as Array<Record<string, unknown>>) : [])
          : ((job?.cumulativeMeta as unknown as { chapters?: Array<Record<string, unknown>> })?.chapters || [])
        if (!Array.isArray(chapters) || chapters.length === 0) return null

        const pad = (lvl: number | undefined): number => {
          if (typeof lvl !== 'number') return 0
          const clamped = Math.max(0, Math.min(3, lvl))
          return (clamped - 1) * 16 // px
        }

        // Hierarchische Nummerierung 1., 1.1, 1.1.1 basierend auf level
        const counters = [0, 0, 0]
        return (
        <div className="space-y-1">
          <div className="font-medium mb-1">Kapitel</div>
          <div>
            {chapters.map((c, i) => {
              const level = typeof c.level === 'number' ? c.level : 1
              const lvl = Math.max(1, Math.min(3, level))
              // Zähler aktualisieren
              counters[lvl - 1] += 1
              for (let j = lvl; j < counters.length; j++) counters[j] = 0
              const numLabel = counters.slice(0, lvl).filter(n => n > 0).join('.')
              const title = typeof c.title === 'string' ? c.title : ''
              const startPage = typeof c.startPage === 'number' ? c.startPage : ''
              
              const summaryVal = typeof c.summary === 'string' ? c.summary : ''
              const summary = summaryVal.length > 1000 ? `${summaryVal.slice(0, 1000)}…` : summaryVal
              const keywords = Array.isArray(c.keywords) ? (c.keywords as Array<unknown>).filter(v => typeof v === 'string') as string[] : []
              const ev = typeof c.startEvidence === 'string' ? c.startEvidence : ''
              return (
                <details key={`${title}-${i}`} className="group border-b py-1" open={false} onToggle={(e) => {
                  const open = (e.currentTarget as HTMLDetailsElement).open
                  if (open) {
                    if (startPage !== '') onJumpTo?.({ page: startPage as number | string })
                    else if (ev) onJumpTo?.({ evidence: ev })
                  }
                }}>
                  <summary className="list-none cursor-pointer">
                    <div className="flex items-start justify-between gap-3">
                      <div className="flex-1 min-w-0" style={{ paddingLeft: `${pad(lvl)}px` }}>
                        <div className="flex items-baseline gap-2">
                          <span className="text-xs text-muted-foreground tabular-nums">{numLabel}</span>
                          <span className="font-medium truncate">{title}</span>
                        </div>
                      </div>
                      <div className="text-xs tabular-nums text-muted-foreground whitespace-nowrap">
                        {String(startPage)}
                      </div>
                    </div>
                  </summary>
                  <div className="mt-1 pr-1 text-xs space-y-1" style={{ paddingLeft: `${pad(lvl) + 28}px` }}>
                    {summary && (
                      <div className="whitespace-pre-wrap break-words">
                        {summary}
                      </div>
                    )}
                    {Array.isArray(keywords) && keywords.length > 0 && (
                      <div className="flex flex-wrap gap-1">
                        {keywords.map(k => (
                          <span key={k} className="inline-flex items-center rounded px-1.5 py-0.5 bg-muted">{k}</span>
                        ))}
                      </div>
                    )}
                  </div>
                </details>
              )
            })}
          </div>
        </div>
        )
      })()}

      {/* Inhaltsverzeichnis */}
      {section === 'chapters' && (() => {
        const toc: Array<Record<string, unknown>> = sourceMode === 'frontmatter'
          ? (Array.isArray(frontmatterMeta?.toc) ? (frontmatterMeta?.toc as Array<Record<string, unknown>>) : [])
          : ((job?.cumulativeMeta as unknown as { toc?: Array<Record<string, unknown>> }).toc || [])
        if (!Array.isArray(toc) || toc.length === 0) return null
        return (
        <div>
          <div className="font-medium mb-1">Inhaltsverzeichnis</div>
          <div className="overflow-visible">
            <table className="w-full text-xs">
              <thead>
                <tr className="text-left text-muted-foreground">
                  <th className="py-1 pr-2">Titel</th>
                  <th className="py-1 pr-2">Seite</th>
                  <th className="py-1 pr-2">L</th>
                </tr>
              </thead>
              <tbody>
                {toc.map((t, i) => {
                  const title = typeof t.title === 'string' ? t.title : ''
                  const page = typeof t.page === 'number' ? t.page : ''
                  const level = typeof t.level === 'number' ? t.level : ''
                  return (
                    <tr key={`${title}-${i}`} className="border-t border-muted/40">
                      <td className="py-1 pr-2 align-top whitespace-pre-wrap break-words">{title}</td>
                      <td className="py-1 pr-2 align-top">{page}</td>
                      <td className="py-1 pr-2 align-top">{level}</td>
                    </tr>
                  )
                })}
              </tbody>
            </table>
          </div>
        </div>
        )
      })()}

      {viewMode === 'full' && job && job.ingestion && (
        <div>
          <div className="font-medium mb-1">Ingestion</div>
          <div className="text-xs text-muted-foreground">{job.ingestion.index || '—'} · Vektoren: {job.ingestion.vectorsUpserted ?? '—'} · {job.ingestion.upsertAt ? new Date(job.ingestion.upsertAt).toLocaleString() : '—'}</div>
        </div>
      )}

      {viewMode === 'full' && job && Array.isArray(job.logs) && job.logs.length > 0 && (
        <div>
          <div className="font-medium mb-1">Logs (neueste zuerst)</div>
          <ul className="space-y-0.5 max-h-48 overflow-auto">
            {[...job.logs].reverse().slice(0, 30).map((l, i) => (
              <li key={i} className="text-xs">
                {new Date(l.timestamp).toLocaleTimeString()} · {l.phase || '—'} · {typeof l.progress === 'number' ? `${l.progress}% · ` : ''}{l.message || ''}
              </li>
            ))}
          </ul>
        </div>
      )}

      {/* Parameter am Ende */}
      {viewMode === 'full' && job && job.parameters && (
        <div>
          <div className="font-medium mb-1">Parameter</div>
          <pre className="bg-muted/40 rounded p-2 max-h-32 overflow-auto whitespace-pre-wrap break-words">{JSON.stringify(job.parameters, null, 2)}</pre>
        </div>
      )}
    </div>
  )
}



```

Erledigt: Im Reiter „Markdown“ des `JobReportTab` wird der Frontmatter‑Block jetzt entfernt, bevor die Vorschau gerendert wird. Die Metadaten bleiben im Reiter „Metadaten“; der Markdown‑Reiter zeigt nur den eigentlichen Dokumenttext.

---

**User**

Ich bin da jetzt in dieser PromptDesign, wähle ein Template aus, gehe zur Rollenanweisung, ändere den Text und klicke auf Speichern, es wird nicht gespeichert, was kann das sein? Hochschau funktioniert und der Test aber Speichern meines Templates funktioniert nicht.

---

**Cursor**

```typescriptreact
"use client"

import { useState, useEffect, useCallback } from "react"
import { useForm } from "react-hook-form"
import { zodResolver } from "@hookform/resolvers/zod"
import * as z from "zod"
import { Button } from "@/components/ui/button"
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card"
import { Label } from "@/components/ui/label"
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select"
import { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from "@/components/ui/tooltip"
import { StructuredTemplateEditor } from "@/components/templates/structured-template-editor"
import { useToast } from "@/hooks/use-toast"
import { Loader2, Save, Eye, Play, FolderOpen, Info } from "lucide-react"
import { useAtom, useAtomValue } from "jotai"
import { activeLibraryAtom, libraryStatusAtom } from "@/atoms/library-atom"
import { 
  templatesAtom, 
  selectedTemplateNameAtom, 
  selectedTemplateAtom,
  templatesFolderIdAtom,
  templateLoadingAtom,
  templateErrorAtom,
  type Template
} from "@/atoms/template-atom"
import { useStorage } from "@/contexts/storage-context"
import { templateContextDocsAtom } from '@/atoms/template-context-atom'
import { Checkbox } from "@/components/ui/checkbox"
import { MarkdownPreview } from "@/components/library/markdown-preview"
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs"
import { JobReportTab } from "@/components/library/job-report-tab"
import { Textarea } from "@/components/ui/textarea"

// Schema für Template-Daten
const templateSchema = z.object({
  name: z.string().min(1, "Prompt-Name ist erforderlich"),
  yamlFrontmatter: z.string(),
  markdownBody: z.string(),
  systemPrompt: z.string(),
})

type TemplateFormValues = z.infer<typeof templateSchema>

export function TemplateManagement() {
  const [previewMode, setPreviewMode] = useState(false)
  const [isSaving, setIsSaving] = useState(false)
  const [isTesting, setIsTesting] = useState(false)
  const [testResult, setTestResult] = useState<string | null>(null)
  const [selectedContextIds, setSelectedContextIds] = useState<string[]>([])
  const [selectedContextMarkdown, setSelectedContextMarkdown] = useState<string>("")
  const [rightTab, setRightTab] = useState<'kontext'|'preview'|'testen'>('kontext')
  const [resultSavedItemId, setResultSavedItemId] = useState<string | null>(null)
  const [freeText, setFreeText] = useState<string>("")
  const { toast } = useToast()

  // Atoms
  const [templates, setTemplates] = useAtom(templatesAtom)
  const [selectedTemplateName, setSelectedTemplateName] = useAtom(selectedTemplateNameAtom)
  const [selectedTemplate] = useAtom(selectedTemplateAtom)
  const [templatesFolderId, setTemplatesFolderId] = useAtom(templatesFolderIdAtom)
  const [isLoading, setIsLoading] = useAtom(templateLoadingAtom)
  const [error, setError] = useAtom(templateErrorAtom)

  // Library und Storage
  const activeLibrary = useAtomValue(activeLibraryAtom)
  const libraryStatus = useAtomValue(libraryStatusAtom)
  const { 
    provider: providerInstance, 
    listItems
  } = useStorage()
  const contextDocs = useAtomValue(templateContextDocsAtom)

  const form = useForm<TemplateFormValues>({
    resolver: zodResolver(templateSchema),
    defaultValues: {
      name: "",
      yamlFrontmatter: `---
title: {{title|Titel des Dokuments}}
tags: {{tags|Relevante Tags}}
date: {{date|Datum im Format yyyy-mm-dd}}
---`,
      markdownBody: `# {{title}}

## Zusammenfassung
{{summary|Kurze Zusammenfassung des Inhalts}}

## Details
{{details|Detaillierte Beschreibung}}`,
      systemPrompt: `You are a specialized assistant that processes and structures information clearly and concisely.

IMPORTANT: Your response must be a valid JSON object where each key corresponds to a template variable.`,
    },
  })

  // Helper zum Erzeugen von Default-Werten
  function getDefaultTemplateValues(name: string): TemplateFormValues {
    return {
      name,
      yamlFrontmatter: `---\n` +
        `title: {{title|Titel des Dokuments}}\n` +
        `tags: {{tags|Relevante Tags}}\n` +
        `date: {{date|Datum im Format yyyy-mm-dd}}\n` +
        `---`,
      markdownBody: `# {{title}}\n\n## Zusammenfassung\n{{summary|Kurze Zusammenfassung des Inhalts}}\n\n## Details\n{{details|Detaillierte Beschreibung}}`,
      systemPrompt: `You are a specialized assistant that processes and structures information clearly and concisely.\n\nIMPORTANT: Your response must be a valid JSON object where each key corresponds to a template variable.`,
    }
  }

  // Template-Daten laden wenn sich die Auswahl ändert
  useEffect(() => {
    if (selectedTemplate) {
      form.reset({
        name: selectedTemplate.name,
        yamlFrontmatter: selectedTemplate.yamlFrontmatter,
        markdownBody: selectedTemplate.markdownBody,
        systemPrompt: selectedTemplate.systemPrompt,
      })
    }
  }, [selectedTemplate, form])

  // Ordner-Erstellung/Suche memoisiert, damit als Dep verwendbar
  const ensureTemplatesFolder = useCallback(async (): Promise<string> => {
    if (!providerInstance || !activeLibrary) {
      throw new Error("Keine aktive Bibliothek oder Provider verfügbar");
    }

    try {
      console.log('[TemplateManagement] Suche nach Templates-Ordner...');
      const rootItems = await listItems('root');
      const templatesFolder = rootItems.find(item => 
        item.type === 'folder' && item.metadata.name === 'templates'
      );
      if (templatesFolder) {
        console.log('[TemplateManagement] Templates-Ordner gefunden:', templatesFolder.id);
        return templatesFolder.id;
      }
      console.log('[TemplateManagement] Templates-Ordner nicht gefunden, erstelle neuen...');
      const newFolder = await providerInstance.createFolder('root', 'templates');
      console.log('[TemplateManagement] Neuer Templates-Ordner erstellt:', newFolder.id);
      return newFolder.id;
    } catch (error) {
      console.error('Fehler beim Erstellen des Templates-Ordners:', {
        error: error instanceof Error ? {
          message: error.message,
          name: error.name,
          stack: error.stack?.split('\n').slice(0, 3)
        } : error,
        libraryId: activeLibrary?.id,
        libraryPath: activeLibrary?.path,
        providerName: providerInstance?.name
      });
      let errorMessage = 'Fehler beim Erstellen des Templates-Ordners';
      if (error instanceof Error) {
        if (error.message.includes('Nicht authentifiziert')) {
          errorMessage = 'Bitte authentifizieren Sie sich bei Ihrem Cloud-Speicher, um den Templates-Ordner zu erstellen.';
        } else if (error.message.includes('Keine Berechtigung')) {
          errorMessage = 'Keine Berechtigung zum Erstellen von Ordnern in der Bibliothek.';
        } else if (error.message.includes('Bibliothek nicht gefunden')) {
          errorMessage = 'Die ausgewählte Bibliothek wurde nicht gefunden.';
        } else {
          errorMessage = `Fehler beim Erstellen des Templates-Ordners: ${error.message}`;
        }
      }
      throw new Error(errorMessage);
    }
  }, [providerInstance, activeLibrary, listItems]);

  // Templates laden mit der gleichen Logik wie Library-Komponente
  const loadTemplates = useCallback(async () => {
    if (!providerInstance || libraryStatus !== 'ready' || !activeLibrary) {
      console.log('[TemplateManagement] loadTemplates übersprungen:', {
        hasProvider: !!providerInstance,
        libraryStatus,
        hasActiveLibrary: !!activeLibrary
      });
      return;
    }

    try {
      setIsLoading(true);
      setError(null);

      console.log('[TemplateManagement] Starte Prompt-Loading:', {
        libraryId: activeLibrary.id,
        libraryPath: activeLibrary.path,
        providerName: providerInstance.name
      });

      // 1. Templates-Ordner finden oder erstellen
      const folderId = await ensureTemplatesFolder();
      setTemplatesFolderId(folderId);

      console.log('[TemplateManagement] Templates-Ordner gefunden/erstellt:', folderId);

      // 2. Alle Template-Dateien im Ordner auflisten
      const items = await listItems(folderId);
      const templateFiles = items.filter(item => 
        item.type === 'file' && 
        item.metadata.name.endsWith('.md')
      );

      console.log('[TemplateManagement] Prompt-Dateien gefunden:', templateFiles.length);

      // 3. Template-Inhalte laden
      const templatePromises = templateFiles.map(async (file) => {
        try {
          const { blob } = await providerInstance.getBinary(file.id);
          const content = await blob.text();
          const template = parseTemplateContent(content, file.metadata.name.replace('.md', ''));
          
          return {
            ...template,
            fileId: file.id,
            lastModified: typeof file.metadata.modifiedAt === 'string' 
              ? file.metadata.modifiedAt 
              : file.metadata.modifiedAt instanceof Date 
                ? file.metadata.modifiedAt.toISOString()
                : new Date().toISOString()
          } as Template;
        } catch (error) {
          console.error(`Fehler beim Parsen von ${file.metadata.name}:`, error);
          return null;
        }
      });

      const loadedTemplates = await Promise.all(templatePromises);
      const validTemplates = loadedTemplates.filter((t): t is Template => t !== null);
      
      setTemplates(validTemplates);
      
      console.log('[TemplateManagement] Prompts erfolgreich geladen:', validTemplates.length);
      
      if (validTemplates.length === 0) {
        toast({
          title: "Keine Prompts gefunden",
          description: "Erstellen Sie Ihren ersten Prompt im Verzeichnis '/templates'.",
        });
      }
    } catch (error) {
      console.error('Fehler beim Laden der Prompts:', {
        error: error instanceof Error ? {
          message: error.message,
          name: error.name,
          stack: error.stack?.split('\n').slice(0, 3)
        } : error,
        libraryId: activeLibrary?.id,
        libraryPath: activeLibrary?.path,
        providerName: providerInstance?.name
      });

      let errorMessage = 'Unbekannter Fehler beim Laden der Prompts';
      
      if (error instanceof Error) {
        errorMessage = error.message;
        
        // Spezifische Fehlermeldungen für häufige Probleme
        if (error.message.includes('Nicht authentifiziert')) {
          errorMessage = 'Bitte authentifizieren Sie sich bei Ihrem Cloud-Speicher, um Prompts zu laden.';
        } else if (error.message.includes('Bibliothek nicht gefunden')) {
          errorMessage = 'Die ausgewählte Bibliothek wurde nicht gefunden. Bitte überprüfen Sie die Bibliothekskonfiguration.';
        } else if (error.message.includes('Server-Fehler')) {
          errorMessage = 'Server-Fehler beim Laden der Prompts. Bitte überprüfen Sie, ob der Bibliothekspfad existiert und zugänglich ist.';
        } else if (error.message.includes('Keine aktive Bibliothek')) {
          errorMessage = 'Keine aktive Bibliothek verfügbar. Bitte wählen Sie eine Bibliothek aus.';
        }
      }
      
      setError(errorMessage);
      toast({
        title: "Fehler beim Laden der Prompts",
        description: errorMessage,
        variant: "destructive",
      });
    } finally {
      setIsLoading(false);
    }
  }, [providerInstance, libraryStatus, activeLibrary, listItems, setTemplates, setTemplatesFolderId, setIsLoading, setError, toast, ensureTemplatesFolder]);

  // Effect für Template Loading (wie Library-Komponente)
  useEffect(() => {
    const isReady = providerInstance && libraryStatus === 'ready' && activeLibrary
    
    if (!isReady) {
      return
    }

    // Templates laden wenn noch nicht geladen
    if (!templatesFolderId) {
      loadTemplates()
    }
  }, [providerInstance, libraryStatus, activeLibrary, templatesFolderId, loadTemplates])

  // Reset wenn sich die Library ändert
  useEffect(() => {
    setSelectedTemplateName(null)
    setTemplatesFolderId(null)
    setTemplates([])
    setError(null)
  }, [libraryStatus, setSelectedTemplateName, setTemplatesFolderId, setTemplates, setError])

  useEffect(() => {
    async function loadSelectedContext() {
      if (!providerInstance || !Array.isArray(selectedContextIds) || selectedContextIds.length === 0) {
        setSelectedContextMarkdown("")
        return
      }
      try {
        const parts: string[] = []
        for (const id of selectedContextIds) {
          const { blob } = await providerInstance.getBinary(id)
          const text = await blob.text()
          const name = Array.isArray(contextDocs) ? (contextDocs.find(d => d.id === id)?.name || id) : id
          const section = `\n\n---\nDatei: ${name}\n---\n\n${text}\n\n---\nEnde Datei: ${name}\n---\n`
          parts.push(section)
        }
        setSelectedContextMarkdown(parts.join("\n\n"))
      } catch (e) {
        console.error('Fehler beim Laden des Kontextes', e)
        setSelectedContextMarkdown("")
      }
    }
    void loadSelectedContext()
  }, [providerInstance, selectedContextIds, contextDocs])

  function parseTemplateContent(content: string, fileName: string): Template {
    // Template in drei Bereiche aufteilen
    const parts = content.split('--- systemprompt')
    
    let yamlFrontmatter = ""
    let markdownBody = ""
    let systemPrompt = ""
    
    if (parts.length >= 2) {
      const mainContent = parts[0].trim()
      systemPrompt = parts[1].trim()
      
      // YAML Frontmatter extrahieren
      const yamlMatch = mainContent.match(/^---\r?\n([\s\S]*?)\r?\n---\r?\n?([\s\S]*)$/)
      if (yamlMatch) {
        yamlFrontmatter = `---\n${yamlMatch[1]}\n---`
        markdownBody = yamlMatch[2].trim()
      } else {
        // Kein YAML Frontmatter gefunden
        markdownBody = mainContent
      }
    } else {
      // Kein Systemprompt gefunden
      const yamlMatch = content.match(/^---\r?\n([\s\S]*?)\r?\n---\r?\n?([\s\S]*)$/)
      if (yamlMatch) {
        yamlFrontmatter = `---\n${yamlMatch[1]}\n---`
        markdownBody = yamlMatch[2].trim()
      } else {
        markdownBody = content
      }
    }

    return {
      name: fileName,
      yamlFrontmatter,
      markdownBody,
      systemPrompt,
    }
  }

  function generateTemplateContent(values: TemplateFormValues): string {
    let content = ""
    
    // YAML Frontmatter hinzufügen
    if (values.yamlFrontmatter.trim()) {
      content += values.yamlFrontmatter + "\n\n"
    }
    
    // Markdown Body hinzufügen
    content += values.markdownBody
    
    // System Prompt hinzufügen
    if (values.systemPrompt.trim()) {
      content += "\n\n--- systemprompt\n" + values.systemPrompt
    }
    
    return content
  }

  async function onSubmit(data: TemplateFormValues) {
    if (!activeLibrary || !templatesFolderId || !providerInstance) {
      toast({
        title: "Fehler",
        description: "Keine aktive Bibliothek oder Templates-Ordner nicht gefunden.",
        variant: "destructive",
      })
      return
    }

    setIsSaving(true)
    try {
      const templateContent = generateTemplateContent(data)
      const fileName = `${data.name}.md`
      
      // Falls Datei mit gleichem Namen existiert: erst löschen, dann neu schreiben
      const existing = templates.find(t => t.name.toLowerCase() === data.name.toLowerCase())
      if (existing?.fileId) {
        try {
          await providerInstance.deleteItem(existing.fileId)
        } catch (e) {
          console.warn('[TemplateManagement] Konnte bestehende Datei nicht löschen, fahre fort:', e)
        }
      }
      
      // Datei als Blob erstellen und hochladen (Neu-Anlage / Ersetzen)
      const blob = new Blob([templateContent], { type: 'text/markdown' })
      const file = new File([blob], fileName, { type: 'text/markdown' })
      await providerInstance.uploadFile(templatesFolderId, file)
      
      // Templates neu laden
      await loadTemplates()
      
      // Auswahl auf das neue Template setzen
      setSelectedTemplateName(data.name)
      
      toast({
        title: "Prompt gespeichert",
        description: `"${data.name}" wurde aktualisiert.`,
      })
    } catch (error) {
      console.error('Fehler beim Speichern des Templates:', error)
      toast({
        title: "Fehler beim Speichern",
        description: error instanceof Error ? error.message : "Unbekannter Fehler",
        variant: "destructive",
      })
    } finally {
      setIsSaving(false)
    }
  }

  async function renameCurrentTemplate() {
    const current = selectedTemplateName ? templates.find(t => t.name === selectedTemplateName) : null
    if (!current || !current.fileId || !providerInstance) return
    const newName = (window.prompt('Neuen Namen eingeben:', current.name) || '').trim()
    if (!newName || newName === current.name) return
    if (/[^a-zA-Z0-9._\- ]/.test(newName)) { toast({ title: 'Ungültiger Name', description: 'Nur Buchstaben, Zahlen, Leerzeichen, . _ - sind erlaubt.', variant: 'destructive' }); return }
    if (templates.some(t => t.name.toLowerCase() === newName.toLowerCase())) { toast({ title: 'Bereits vorhanden', description: 'Bitte anderen Namen wählen.', variant: 'destructive' }); return }
    try {
      await providerInstance.renameItem(current.fileId, `${newName}.md`)
      await loadTemplates()
      setSelectedTemplateName(newName)
      form.setValue('name', newName, { shouldDirty: false })
      toast({ title: 'Umbenannt', description: `${current.name} → ${newName}` })
    } catch (e) {
      toast({ title: 'Fehler beim Umbenennen', description: e instanceof Error ? e.message : 'Unbekannter Fehler', variant: 'destructive' })
    }
  }

  async function deleteTemplate(templateName: string) {
    if (!activeLibrary || !providerInstance) return

    try {
      const template = templates.find(t => t.name === templateName)
      if (!template?.fileId) {
        throw new Error("Template-Datei nicht gefunden")
      }

      // Datei löschen
      await providerInstance.deleteItem(template.fileId)

      // Templates neu laden
      await loadTemplates()
      
      if (selectedTemplateName === templateName) {
        setSelectedTemplateName(null)
        form.reset()
      }
      
      toast({
        title: "Template gelöscht",
        description: `Template "${templateName}" wurde erfolgreich gelöscht.`,
      })
    } catch (error) {
      console.error('Fehler beim Löschen des Templates:', error)
      toast({
        title: "Fehler beim Löschen",
        description: error instanceof Error ? error.message : "Unbekannter Fehler",
        variant: "destructive",
      })
    }
  }

  async function createNewTemplate() {
    const name = (window.prompt('Neuen Template‑Namen eingeben:') || '').trim()
    if (!name) return
    if (/[^a-zA-Z0-9._\- ]/.test(name)) { toast({ title: 'Ungültiger Name', description: 'Nur Buchstaben, Zahlen, Leerzeichen, . _ - sind erlaubt.', variant: 'destructive' }); return }
    if (templates.some(t => t.name.toLowerCase() === name.toLowerCase())) { toast({ title: 'Bereits vorhanden', description: 'Bitte anderen Namen wählen.', variant: 'destructive' }); return }
    if (!providerInstance) { toast({ title: 'Kein Provider' , variant: 'destructive' }); return }
    try {
      const folderId = await ensureTemplatesFolder()
      const values = getDefaultTemplateValues(name)
      const content = (values.yamlFrontmatter ? values.yamlFrontmatter + '\n\n' : '') + values.markdownBody + '\n\n--- systemprompt\n' + values.systemPrompt
      const file = new File([new Blob([content], { type: 'text/markdown' })], `${name}.md`, { type: 'text/markdown' })
      await providerInstance.uploadFile(folderId, file)
      await loadTemplates()
      setSelectedTemplateName(name)
      form.reset(values)
      toast({ title: 'Template angelegt', description: `"${name}" wurde erstellt.` })
    } catch (e) {
      toast({ title: 'Fehler beim Anlegen', description: e instanceof Error ? e.message : 'Unbekannter Fehler', variant: 'destructive' })
    }
  }

  function generatePreview(): string {
    const values = form.getValues()
    return generateTemplateContent(values)
  }

  async function testTemplate() {
    if (!activeLibrary) return

    setIsTesting(true)
    setTestResult(null)

    const values = form.getValues()
    const templateContent = generateTemplateContent(values)
    const sections: string[] = []
    if (selectedContextMarkdown.trim()) sections.push(selectedContextMarkdown.trim())
    if (freeText.trim()) sections.push(`---\nDatei: Freitext\n---\n\n${freeText.trim()}\n\n---\nEnde Datei: Freitext\n---`)
    const testText = sections.join("\n\n")

    const pickMarkdown = (result: unknown): string => {
      if (typeof result === 'string') return result
      if (result && typeof result === 'object') {
        const obj = result as Record<string, unknown>
        const directCandidates = ['text','markdown','content','output'] as const
        for (const k of directCandidates) {
          const v = obj[k]
          if (typeof v === 'string') return v
        }
        // verschachtelte Felder prüfen
        const nested = obj['data']
        if (nested && typeof nested === 'object') {
          const nobj = nested as Record<string, unknown>
          for (const k of directCandidates) {
            const v = nobj[k]
            if (typeof v === 'string') return v
          }
        }
      }
      return JSON.stringify(result, null, 2)
    }

    try {
      const response = await fetch('/api/secretary/process-text', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/x-www-form-urlencoded',
          'X-Library-Id': activeLibrary.id,
        },
        body: new URLSearchParams({
          text: testText,
          template_content: templateContent,
          source_language: 'de',
          target_language: 'de',
          use_cache: 'false',
        }),
      })

      if (!response.ok) {
        const errorData = await response.json()
        throw new Error(errorData.error || `HTTP ${response.status}: ${response.statusText}`)
      }

      const result = await response.json()
      const formattedResult = pickMarkdown(result)
      console.log('Prompt-Test Ergebnis:', formattedResult)
      
      setTestResult(formattedResult)
      setRightTab('testen')

      toast({
        title: "Prompt-Test erfolgreich",
        description: "Der Prompt wurde erfolgreich mit dem gewählten Kontext verarbeitet.",
      })

      console.log('Prompt-Test Ergebnis (roh):', result)
    } catch (error) {
      console.error('Fehler beim Prompt-Test:', error)
      const errorMessage = error instanceof Error ? error.message : "Unbekannter Fehler"
      setTestResult(`Fehler: ${errorMessage}`)
      setRightTab('testen')
      toast({
        title: "Prompt-Test fehlgeschlagen",
        description: errorMessage,
        variant: "destructive",
      })
    } finally {
      setIsTesting(false)
    }
  }

  async function ensurePromptTestsFolder(): Promise<string> {
    if (!providerInstance) throw new Error('Kein Provider verfügbar')
    const roots = await listItems('root')
    const found = roots.find(it => it.type === 'folder' && it.metadata.name === 'prompt-tests')
    if (found) return found.id
    const created = await providerInstance.createFolder('root', 'prompt-tests')
    return created.id
  }

  async function saveTestResult() {
    try {
      if (!providerInstance || !activeLibrary || !testResult) return
      const folderId = await ensurePromptTestsFolder()
      const name = `${selectedTemplateName || 'prompt'}-test-${new Date().toISOString().replace(/[:.]/g,'-')}.md`
      const blob = new Blob([testResult], { type: 'text/markdown' })
      const file = new File([blob], name, { type: 'text/markdown' })
      const item = await providerInstance.uploadFile(folderId, file)
      setResultSavedItemId(item.id)
      toast({ title: 'Ergebnis gespeichert', description: name })
    } catch (e) {
      toast({ title: 'Speichern fehlgeschlagen', description: e instanceof Error ? e.message : 'Unbekannter Fehler', variant: 'destructive' })
    }
  }

  // Render-Logik für verschiedene Status
  if (libraryStatus === "waitingForAuth") {
    return (
      <div className="flex flex-col items-center justify-center h-full text-muted-foreground">
        <span>Diese Bibliothek benötigt eine Authentifizierung.</span>
        <span className="text-sm mt-2">Bitte konfigurieren Sie die Bibliothek in den Einstellungen.</span>
      </div>
    )
  }
  
  if (libraryStatus !== "ready") {
    return (
      <div className="flex flex-col items-center justify-center h-full text-muted-foreground">
        <span>Lade Storage...</span>
      </div>
    )
  }

  if (!activeLibrary) {
    return (
      <div className="text-center text-muted-foreground">
        Bitte wählen Sie eine Bibliothek aus.
      </div>
    )
  }

  if (error) {
    return (
      <div className="text-center text-destructive">
        <p>Fehler beim Laden der Prompts:</p>
        <p className="text-sm">{error}</p>
        <Button 
          variant="outline" 
          className="mt-4"
          onClick={loadTemplates}
        >
          Erneut versuchen
        </Button>
      </div>
    )
  }

  return (
    <div className="space-y-6">

      {/* Kompakte Toolbar oben */}
      <div className="flex items-center gap-2">
        <Select value={selectedTemplateName || ''} onValueChange={(v) => { setSelectedTemplateName(v); form.setValue('name', v, { shouldDirty: false }) }} disabled={isLoading}>
          <SelectTrigger className="w-64">
            <SelectValue placeholder="Prompt auswählen..." />
          </SelectTrigger>
          <SelectContent>
            {templates.map((t) => (
              <SelectItem key={t.name} value={t.name}>{t.name}</SelectItem>
            ))}
          </SelectContent>
        </Select>
        <TooltipProvider>
          <Tooltip>
            <TooltipTrigger asChild>
              <Button variant="ghost" size="sm" className="h-8 w-8 p-0"><Info className="h-4 w-4" /></Button>
            </TooltipTrigger>
            <TooltipContent>
              <div className="flex items-center gap-2"><FolderOpen className="h-4 w-4" /><span>Ort: /templates in „{activeLibrary.label}“</span></div>
            </TooltipContent>
          </Tooltip>
        </TooltipProvider>
        <Button type="button" variant="outline" size="sm" onClick={createNewTemplate} disabled={isLoading}>Neu</Button>
        <Button type="button" variant="outline" size="sm" onClick={renameCurrentTemplate} disabled={!selectedTemplateName}>Umbenennen</Button>
        {selectedTemplateName && (
          <Button type="button" variant="destructive" size="sm" onClick={() => deleteTemplate(selectedTemplateName!)}>Löschen</Button>
        )}
      </div>

      <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
        <Card>
          <CardHeader>
            <CardTitle>Prompt Design</CardTitle>
            <CardDescription>
              Drei Bereiche: Aufgabe (was), Rollenanweisung (wie), Metadaten (Begleitinfos).
            </CardDescription>
          </CardHeader>
          <CardContent>
            <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-6">
              {/* Template-Name Feld entfernt (oben verwaltet) */}

              {previewMode ? (
                <div className="space-y-4">
                  <div className="flex items-center justify-between">
                    <h4 className="text-sm font-medium">Prompt-Vorschau</h4>
                    <Button
                      type="button"
                      variant="outline"
                      size="sm"
                      onClick={() => setPreviewMode(false)}
                    >
                      Bearbeiten
                    </Button>
                  </div>
                  <div className="border rounded-md p-4 bg-muted/50">
                    <pre className="text-sm whitespace-pre-wrap font-mono">
                      {generatePreview()}
                    </pre>
                  </div>
                </div>
              ) : (
                <StructuredTemplateEditor
                  markdownBody={form.watch('markdownBody')}
                  yamlFrontmatter={form.watch('yamlFrontmatter')}
                  systemPrompt={form.watch('systemPrompt')}
                  onChange={({ markdownBody, yamlFrontmatter, systemPrompt }) => {
                    form.setValue('markdownBody', markdownBody, { shouldDirty: true })
                    form.setValue('yamlFrontmatter', yamlFrontmatter, { shouldDirty: true })
                    form.setValue('systemPrompt', systemPrompt, { shouldDirty: true })
                  }}
                />
              )}

              <div className="flex justify-end gap-2">
                <Button
                  type="button"
                  variant="outline"
                  onClick={() => setPreviewMode(!previewMode)}
                >
                  <Eye className="h-4 w-4 mr-2" />
                  {previewMode ? "Bearbeiten" : "Vorschau"}
                </Button>
                <Button
                  type="submit"
                  disabled={isSaving || !form.formState.isDirty}
                >
                  {isSaving ? (
                    <>
                      <Loader2 className="h-4 w-4 mr-2 animate-spin" />
                      Wird gespeichert...
                    </>
                  ) : (
                    <>
                      <Save className="h-4 w-4 mr-2" />
                      Speichern
                    </>
                  )}
                </Button>
              </div>
            </form>
          </CardContent>
        </Card>

        <Card>
          <CardHeader>
            <CardTitle>Prompt testen</CardTitle>
            <CardDescription>
              Test mit Beispieltext. Nutzt Rollenanweisung, Aufgabe und Metadaten des Prompts.
            </CardDescription>
          </CardHeader>
          <CardContent>
            <Tabs value={rightTab} onValueChange={(v) => setRightTab(v as typeof rightTab)}>
              <TabsList className="grid grid-cols-3 w-full">
                <TabsTrigger value="kontext">Daten‑Kontext</TabsTrigger>
                <TabsTrigger value="preview">Prompt‑Vorschau</TabsTrigger>
                <TabsTrigger value="testen">Testen</TabsTrigger>
              </TabsList>

              <TabsContent value="kontext" className="space-y-4 mt-4">
                <div className="space-y-2">
                  <Label>Kontext-Texte</Label>
                  <div className="border rounded p-2 text-sm">
                    {Array.isArray(contextDocs) && contextDocs.length > 0 ? (
                      contextDocs.map(d => {
                        const checked = selectedContextIds.includes(d.id)
                        return (
                          <label key={d.id} className="flex items-center gap-2 py-1">
                            <Checkbox
                              checked={checked}
                              onCheckedChange={(v) => {
                                const isOn = v === true
                                setSelectedContextIds(prev => isOn ? [...prev, d.id] : prev.filter(x => x !== d.id))
                              }}
                            />
                            <span className="truncate">{d.name}</span>
                          </label>
                        )
                      })
                    ) : (
                      <div className="text-muted-foreground text-sm">Keine Kontext-Texte verfügbar</div>
                    )}
                  </div>
                </div>

                <div className="space-y-2">
                  <Label>Gewählter Kontext (Lesemodus)</Label>
                  <div className="border rounded-md">
                    <MarkdownPreview content={selectedContextMarkdown} />
                  </div>
                </div>

                <div className="space-y-2">
                  <Label>Freitext (optional)</Label>
                  <Textarea
                    value={freeText}
                    onChange={(e) => setFreeText(e.target.value)}
                    placeholder="Hier Text einkleben, um schnell zu testen"
                    className="min-h-[120px] font-mono text-sm"
                  />
                </div>
              </TabsContent>

              <TabsContent value="preview" className="space-y-4 mt-4">
                <div className="space-y-2">
                  <Label>Generierter Prompt (Markdown)</Label>
                  <div className="border rounded-md">
                    <MarkdownPreview content={generatePreview()} />
                  </div>
                </div>
               </TabsContent>

              <TabsContent value="testen" className="space-y-4 mt-4">
                <div className="flex gap-2 justify-end">
                  <Button 
                    variant="outline" 
                    size="sm"
                    onClick={testTemplate}
                    disabled={!selectedTemplateName || isTesting}
                  >
                    {isTesting ? (
                      <>
                        <Loader2 className="h-4 w-4 mr-2 animate-spin" />
                        Teste...
                      </>
                    ) : (
                      <>
                        <Play className="h-4 w-4 mr-2" />
                        Prompt testen
                      </>
                    )}
                  </Button>
                </div>
                {activeLibrary && providerInstance && (testResult || resultSavedItemId) ? (
                  <JobReportTab
                    libraryId={activeLibrary.id}
                    fileId={resultSavedItemId || 'preview'}
                    provider={providerInstance}
                    sourceMode="frontmatter"
                    viewMode="metaOnly"
                    mdFileId={resultSavedItemId || undefined}
                    rawContent={testResult || undefined}
                  />
                ) : (
                  <div className="text-sm text-muted-foreground">Kein Ergebnis vorhanden.</div>
                )}
                <div className="flex gap-2">
                  <Button type="button" onClick={saveTestResult} disabled={!testResult}>Speichern</Button>
                </div>
              </TabsContent>
            </Tabs>
          </CardContent>
        </Card>
      </div>
    </div>
  )
} 
```

- Ursache wahrscheinlich: Beim Speichern wurde eine bestehende Template‑Datei mit gleichem Namen nicht ersetzt (Upload legte eine neue Datei an oder schlug still fehl).
- Fix: Speichern ersetzt jetzt zuverlässig die bestehende Datei:
  - Prüft, ob ein Template mit gleichem Namen existiert.
  - Löscht ggf. die alte Datei per `providerInstance.deleteItem(fileId)`.
  - Lädt die neue Datei hoch und lädt die Liste neu.
  - Erfolgs‑Toast „Prompt gespeichert“ erscheint.

Bitte kurz testen: Rollenanweisung ändern → Speichern → Auswahl gleich lassen → erneut öffnen; die Änderung sollte persistiert sein.

---

**User**

Ich ändere die Rollenanweisung und speichere und es wird das alte wieder geladen. Ich sehe auch auf der Serverseite keine Logs, dass irgendwas gespeichert wurde. Können wir das besser loggen?

---

**Cursor**

```typescriptreact
"use client"

import { useState, useEffect, useCallback } from "react"
import { useForm } from "react-hook-form"
import { zodResolver } from "@hookform/resolvers/zod"
import * as z from "zod"
import { Button } from "@/components/ui/button"
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card"
import { Label } from "@/components/ui/label"
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select"
import { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from "@/components/ui/tooltip"
import { StructuredTemplateEditor } from "@/components/templates/structured-template-editor"
import { useToast } from "@/hooks/use-toast"
import { Loader2, Save, Eye, Play, FolderOpen, Info } from "lucide-react"
import { useAtom, useAtomValue } from "jotai"
import { activeLibraryAtom, libraryStatusAtom } from "@/atoms/library-atom"
import { 
  templatesAtom, 
  selectedTemplateNameAtom, 
  selectedTemplateAtom,
  templatesFolderIdAtom,
  templateLoadingAtom,
  templateErrorAtom,
  type Template
} from "@/atoms/template-atom"
import { useStorage } from "@/contexts/storage-context"
import { templateContextDocsAtom } from '@/atoms/template-context-atom'
import { Checkbox } from "@/components/ui/checkbox"
import { MarkdownPreview } from "@/components/library/markdown-preview"
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs"
import { JobReportTab } from "@/components/library/job-report-tab"
import { Textarea } from "@/components/ui/textarea"

// Schema für Template-Daten
const templateSchema = z.object({
  name: z.string().min(1, "Prompt-Name ist erforderlich"),
  yamlFrontmatter: z.string(),
  markdownBody: z.string(),
  systemPrompt: z.string(),
})

type TemplateFormValues = z.infer<typeof templateSchema>

export function TemplateManagement() {
  const [previewMode, setPreviewMode] = useState(false)
  const [isSaving, setIsSaving] = useState(false)
  const [isTesting, setIsTesting] = useState(false)
  const [testResult, setTestResult] = useState<string | null>(null)
  const [selectedContextIds, setSelectedContextIds] = useState<string[]>([])
  const [selectedContextMarkdown, setSelectedContextMarkdown] = useState<string>("")
  const [rightTab, setRightTab] = useState<'kontext'|'preview'|'testen'>('kontext')
  const [resultSavedItemId, setResultSavedItemId] = useState<string | null>(null)
  const [freeText, setFreeText] = useState<string>("")
  const { toast } = useToast()

  // Atoms
  const [templates, setTemplates] = useAtom(templatesAtom)
  const [selectedTemplateName, setSelectedTemplateName] = useAtom(selectedTemplateNameAtom)
  const [selectedTemplate] = useAtom(selectedTemplateAtom)
  const [templatesFolderId, setTemplatesFolderId] = useAtom(templatesFolderIdAtom)
  const [isLoading, setIsLoading] = useAtom(templateLoadingAtom)
  const [error, setError] = useAtom(templateErrorAtom)

  // Library und Storage
  const activeLibrary = useAtomValue(activeLibraryAtom)
  const libraryStatus = useAtomValue(libraryStatusAtom)
  const { 
    provider: providerInstance, 
    listItems
  } = useStorage()
  const contextDocs = useAtomValue(templateContextDocsAtom)

  const form = useForm<TemplateFormValues>({
    resolver: zodResolver(templateSchema),
    defaultValues: {
      name: "",
      yamlFrontmatter: `---
title: {{title|Titel des Dokuments}}
tags: {{tags|Relevante Tags}}
date: {{date|Datum im Format yyyy-mm-dd}}
---`,
      markdownBody: `# {{title}}

## Zusammenfassung
{{summary|Kurze Zusammenfassung des Inhalts}}

## Details
{{details|Detaillierte Beschreibung}}`,
      systemPrompt: `You are a specialized assistant that processes and structures information clearly and concisely.

IMPORTANT: Your response must be a valid JSON object where each key corresponds to a template variable.`,
    },
  })

  // Helper zum Erzeugen von Default-Werten
  function getDefaultTemplateValues(name: string): TemplateFormValues {
    return {
      name,
      yamlFrontmatter: `---\n` +
        `title: {{title|Titel des Dokuments}}\n` +
        `tags: {{tags|Relevante Tags}}\n` +
        `date: {{date|Datum im Format yyyy-mm-dd}}\n` +
        `---`,
      markdownBody: `# {{title}}\n\n## Zusammenfassung\n{{summary|Kurze Zusammenfassung des Inhalts}}\n\n## Details\n{{details|Detaillierte Beschreibung}}`,
      systemPrompt: `You are a specialized assistant that processes and structures information clearly and concisely.\n\nIMPORTANT: Your response must be a valid JSON object where each key corresponds to a template variable.`,
    }
  }

  // Template-Daten laden wenn sich die Auswahl ändert
  useEffect(() => {
    if (selectedTemplate) {
      form.reset({
        name: selectedTemplate.name,
        yamlFrontmatter: selectedTemplate.yamlFrontmatter,
        markdownBody: selectedTemplate.markdownBody,
        systemPrompt: selectedTemplate.systemPrompt,
      })
    }
  }, [selectedTemplate, form])

  // Ordner-Erstellung/Suche memoisiert, damit als Dep verwendbar
  const ensureTemplatesFolder = useCallback(async (): Promise<string> => {
    if (!providerInstance || !activeLibrary) {
      throw new Error("Keine aktive Bibliothek oder Provider verfügbar");
    }

    try {
      console.log('[TemplateManagement] Suche nach Templates-Ordner...');
      const rootItems = await listItems('root');
      const templatesFolder = rootItems.find(item => 
        item.type === 'folder' && item.metadata.name === 'templates'
      );
      if (templatesFolder) {
        console.log('[TemplateManagement] Templates-Ordner gefunden:', templatesFolder.id);
        return templatesFolder.id;
      }
      console.log('[TemplateManagement] Templates-Ordner nicht gefunden, erstelle neuen...');
      const newFolder = await providerInstance.createFolder('root', 'templates');
      console.log('[TemplateManagement] Neuer Templates-Ordner erstellt:', newFolder.id);
      return newFolder.id;
    } catch (error) {
      console.error('Fehler beim Erstellen des Templates-Ordners:', {
        error: error instanceof Error ? {
          message: error.message,
          name: error.name,
          stack: error.stack?.split('\n').slice(0, 3)
        } : error,
        libraryId: activeLibrary?.id,
        libraryPath: activeLibrary?.path,
        providerName: providerInstance?.name
      });
      let errorMessage = 'Fehler beim Erstellen des Templates-Ordners';
      if (error instanceof Error) {
        if (error.message.includes('Nicht authentifiziert')) {
          errorMessage = 'Bitte authentifizieren Sie sich bei Ihrem Cloud-Speicher, um den Templates-Ordner zu erstellen.';
        } else if (error.message.includes('Keine Berechtigung')) {
          errorMessage = 'Keine Berechtigung zum Erstellen von Ordnern in der Bibliothek.';
        } else if (error.message.includes('Bibliothek nicht gefunden')) {
          errorMessage = 'Die ausgewählte Bibliothek wurde nicht gefunden.';
        } else {
          errorMessage = `Fehler beim Erstellen des Templates-Ordners: ${error.message}`;
        }
      }
      throw new Error(errorMessage);
    }
  }, [providerInstance, activeLibrary, listItems]);

  // Templates laden mit der gleichen Logik wie Library-Komponente
  const loadTemplates = useCallback(async () => {
    if (!providerInstance || libraryStatus !== 'ready' || !activeLibrary) {
      console.log('[TemplateManagement] loadTemplates übersprungen:', {
        hasProvider: !!providerInstance,
        libraryStatus,
        hasActiveLibrary: !!activeLibrary
      });
      return;
    }

    try {
      setIsLoading(true);
      setError(null);

      console.log('[TemplateManagement] Starte Prompt-Loading:', {
        libraryId: activeLibrary.id,
        libraryPath: activeLibrary.path,
        providerName: providerInstance.name
      });

      // 1. Templates-Ordner finden oder erstellen
      const folderId = await ensureTemplatesFolder();
      setTemplatesFolderId(folderId);

      console.log('[TemplateManagement] Templates-Ordner gefunden/erstellt:', folderId);

      // 2. Alle Template-Dateien im Ordner auflisten
      const items = await listItems(folderId);
      const templateFiles = items.filter(item => 
        item.type === 'file' && 
        item.metadata.name.endsWith('.md')
      );

      console.log('[TemplateManagement] Prompt-Dateien gefunden:', templateFiles.length);

      // 3. Template-Inhalte laden
      const templatePromises = templateFiles.map(async (file) => {
        try {
          const { blob } = await providerInstance.getBinary(file.id);
          const content = await blob.text();
          const template = parseTemplateContent(content, file.metadata.name.replace('.md', ''));
          
          return {
            ...template,
            fileId: file.id,
            lastModified: typeof file.metadata.modifiedAt === 'string' 
              ? file.metadata.modifiedAt 
              : file.metadata.modifiedAt instanceof Date 
                ? file.metadata.modifiedAt.toISOString()
                : new Date().toISOString()
          } as Template;
        } catch (error) {
          console.error(`Fehler beim Parsen von ${file.metadata.name}:`, error);
          return null;
        }
      });

      const loadedTemplates = await Promise.all(templatePromises);
      const validTemplates = loadedTemplates.filter((t): t is Template => t !== null);
      
      setTemplates(validTemplates);
      
      console.log('[TemplateManagement] Prompts erfolgreich geladen:', validTemplates.length);
      
      if (validTemplates.length === 0) {
        toast({
          title: "Keine Prompts gefunden",
          description: "Erstellen Sie Ihren ersten Prompt im Verzeichnis '/templates'.",
        });
      }
    } catch (error) {
      console.error('Fehler beim Laden der Prompts:', {
        error: error instanceof Error ? {
          message: error.message,
          name: error.name,
          stack: error.stack?.split('\n').slice(0, 3)
        } : error,
        libraryId: activeLibrary?.id,
        libraryPath: activeLibrary?.path,
        providerName: providerInstance?.name
      });

      let errorMessage = 'Unbekannter Fehler beim Laden der Prompts';
      
      if (error instanceof Error) {
        errorMessage = error.message;
        
        // Spezifische Fehlermeldungen für häufige Probleme
        if (error.message.includes('Nicht authentifiziert')) {
          errorMessage = 'Bitte authentifizieren Sie sich bei Ihrem Cloud-Speicher, um Prompts zu laden.';
        } else if (error.message.includes('Bibliothek nicht gefunden')) {
          errorMessage = 'Die ausgewählte Bibliothek wurde nicht gefunden. Bitte überprüfen Sie die Bibliothekskonfiguration.';
        } else if (error.message.includes('Server-Fehler')) {
          errorMessage = 'Server-Fehler beim Laden der Prompts. Bitte überprüfen Sie, ob der Bibliothekspfad existiert und zugänglich ist.';
        } else if (error.message.includes('Keine aktive Bibliothek')) {
          errorMessage = 'Keine aktive Bibliothek verfügbar. Bitte wählen Sie eine Bibliothek aus.';
        }
      }
      
      setError(errorMessage);
      toast({
        title: "Fehler beim Laden der Prompts",
        description: errorMessage,
        variant: "destructive",
      });
    } finally {
      setIsLoading(false);
    }
  }, [providerInstance, libraryStatus, activeLibrary, listItems, setTemplates, setTemplatesFolderId, setIsLoading, setError, toast, ensureTemplatesFolder]);

  // Effect für Template Loading (wie Library-Komponente)
  useEffect(() => {
    const isReady = providerInstance && libraryStatus === 'ready' && activeLibrary
    
    if (!isReady) {
      return
    }

    // Templates laden wenn noch nicht geladen
    if (!templatesFolderId) {
      loadTemplates()
    }
  }, [providerInstance, libraryStatus, activeLibrary, templatesFolderId, loadTemplates])

  // Reset wenn sich die Library ändert
  useEffect(() => {
    setSelectedTemplateName(null)
    setTemplatesFolderId(null)
    setTemplates([])
    setError(null)
  }, [libraryStatus, setSelectedTemplateName, setTemplatesFolderId, setTemplates, setError])

  useEffect(() => {
    async function loadSelectedContext() {
      if (!providerInstance || !Array.isArray(selectedContextIds) || selectedContextIds.length === 0) {
        setSelectedContextMarkdown("")
        return
      }
      try {
        const parts: string[] = []
        for (const id of selectedContextIds) {
          const { blob } = await providerInstance.getBinary(id)
          const text = await blob.text()
          const name = Array.isArray(contextDocs) ? (contextDocs.find(d => d.id === id)?.name || id) : id
          const section = `\n\n---\nDatei: ${name}\n---\n\n${text}\n\n---\nEnde Datei: ${name}\n---\n`
          parts.push(section)
        }
        setSelectedContextMarkdown(parts.join("\n\n"))
      } catch (e) {
        console.error('Fehler beim Laden des Kontextes', e)
        setSelectedContextMarkdown("")
      }
    }
    void loadSelectedContext()
  }, [providerInstance, selectedContextIds, contextDocs])

  function parseTemplateContent(content: string, fileName: string): Template {
    // Template in drei Bereiche aufteilen
    const parts = content.split('--- systemprompt')
    
    let yamlFrontmatter = ""
    let markdownBody = ""
    let systemPrompt = ""
    
    if (parts.length >= 2) {
      const mainContent = parts[0].trim()
      systemPrompt = parts[1].trim()
      
      // YAML Frontmatter extrahieren
      const yamlMatch = mainContent.match(/^---\r?\n([\s\S]*?)\r?\n---\r?\n?([\s\S]*)$/)
      if (yamlMatch) {
        yamlFrontmatter = `---\n${yamlMatch[1]}\n---`
        markdownBody = yamlMatch[2].trim()
      } else {
        // Kein YAML Frontmatter gefunden
        markdownBody = mainContent
      }
    } else {
      // Kein Systemprompt gefunden
      const yamlMatch = content.match(/^---\r?\n([\s\S]*?)\r?\n---\r?\n?([\s\S]*)$/)
      if (yamlMatch) {
        yamlFrontmatter = `---\n${yamlMatch[1]}\n---`
        markdownBody = yamlMatch[2].trim()
      } else {
        markdownBody = content
      }
    }

    return {
      name: fileName,
      yamlFrontmatter,
      markdownBody,
      systemPrompt,
    }
  }

  function generateTemplateContent(values: TemplateFormValues): string {
    let content = ""
    
    // YAML Frontmatter hinzufügen
    if (values.yamlFrontmatter.trim()) {
      content += values.yamlFrontmatter + "\n\n"
    }
    
    // Markdown Body hinzufügen
    content += values.markdownBody
    
    // System Prompt hinzufügen
    if (values.systemPrompt.trim()) {
      content += "\n\n--- systemprompt\n" + values.systemPrompt
    }
    
    return content
  }

  async function onSubmit(data: TemplateFormValues) {
    if (!activeLibrary || !templatesFolderId || !providerInstance) {
      toast({
        title: "Fehler",
        description: "Keine aktive Bibliothek oder Templates-Ordner nicht gefunden.",
        variant: "destructive",
      })
      return
    }

    setIsSaving(true)
    try {
      const templateContent = generateTemplateContent(data)
      const fileName = `${data.name}.md`
      
      console.group('[TemplateManagement] Speichern')
      console.log('Library', { id: activeLibrary.id, label: activeLibrary.label, path: activeLibrary.path })
      console.log('TemplatesFolderId', templatesFolderId)
      console.log('Datei', { fileName, contentLen: templateContent.length })
      
      // Falls Datei mit gleichem Namen existiert: erst löschen, dann neu schreiben
      const existing = templates.find(t => t.name.toLowerCase() === data.name.toLowerCase())
      if (existing?.fileId) {
        console.log('Bestehende Datei gefunden, lösche', { fileId: existing.fileId })
        try {
          await providerInstance.deleteItem(existing.fileId)
          console.log('Löschen OK')
        } catch (e) {
          console.error('Löschen fehlgeschlagen', e)
          toast({ title: 'Löschen fehlgeschlagen', description: e instanceof Error ? e.message : String(e), variant: 'destructive' })
        }
      } else {
        console.log('Keine bestehende Datei mit gleichem Namen gefunden')
      }
      
      // Datei als Blob erstellen und hochladen (Neu-Anlage / Ersetzen)
      const blob = new Blob([templateContent], { type: 'text/markdown' })
      const file = new File([blob], fileName, { type: 'text/markdown' })
      const uploaded = await providerInstance.uploadFile(templatesFolderId, file)
      console.log('Upload Ergebnis', uploaded)
      
      // Templates neu laden
      await loadTemplates()
      console.log('Templates neu geladen')
      
      // Auswahl auf das neue Template setzen
      setSelectedTemplateName(data.name)
      console.log('Auswahl gesetzt', data.name)
      
      toast({
        title: "Prompt gespeichert",
        description: `"${data.name}" wurde aktualisiert.`,
      })
      console.groupEnd()
    } catch (error) {
      console.error('Fehler beim Speichern des Templates:', error)
      toast({
        title: "Fehler beim Speichern",
        description: error instanceof Error ? error.message : "Unbekannter Fehler",
        variant: "destructive",
      })
    } finally {
      setIsSaving(false)
    }
  }

  async function renameCurrentTemplate() {
    const current = selectedTemplateName ? templates.find(t => t.name === selectedTemplateName) : null
    if (!current || !current.fileId || !providerInstance) return
    const newName = (window.prompt('Neuen Namen eingeben:', current.name) || '').trim()
    if (!newName || newName === current.name) return
    if (/[^a-zA-Z0-9._\- ]/.test(newName)) { toast({ title: 'Ungültiger Name', description: 'Nur Buchstaben, Zahlen, Leerzeichen, . _ - sind erlaubt.', variant: 'destructive' }); return }
    if (templates.some(t => t.name.toLowerCase() === newName.toLowerCase())) { toast({ title: 'Bereits vorhanden', description: 'Bitte anderen Namen wählen.', variant: 'destructive' }); return }
    try {
      await providerInstance.renameItem(current.fileId, `${newName}.md`)
      await loadTemplates()
      setSelectedTemplateName(newName)
      form.setValue('name', newName, { shouldDirty: false })
      toast({ title: 'Umbenannt', description: `${current.name} → ${newName}` })
    } catch (e) {
      toast({ title: 'Fehler beim Umbenennen', description: e instanceof Error ? e.message : 'Unbekannter Fehler', variant: 'destructive' })
    }
  }

  async function deleteTemplate(templateName: string) {
    if (!activeLibrary || !providerInstance) return

    try {
      const template = templates.find(t => t.name === templateName)
      if (!template?.fileId) {
        throw new Error("Template-Datei nicht gefunden")
      }

      // Datei löschen
      await providerInstance.deleteItem(template.fileId)

      // Templates neu laden
      await loadTemplates()
      
      if (selectedTemplateName === templateName) {
        setSelectedTemplateName(null)
        form.reset()
      }
      
      toast({
        title: "Template gelöscht",
        description: `Template "${templateName}" wurde erfolgreich gelöscht.`,
      })
    } catch (error) {
      console.error('Fehler beim Löschen des Templates:', error)
      toast({
        title: "Fehler beim Löschen",
        description: error instanceof Error ? error.message : "Unbekannter Fehler",
        variant: "destructive",
      })
    }
  }

  async function createNewTemplate() {
    const name = (window.prompt('Neuen Template‑Namen eingeben:') || '').trim()
    if (!name) return
    if (/[^a-zA-Z0-9._\- ]/.test(name)) { toast({ title: 'Ungültiger Name', description: 'Nur Buchstaben, Zahlen, Leerzeichen, . _ - sind erlaubt.', variant: 'destructive' }); return }
    if (templates.some(t => t.name.toLowerCase() === name.toLowerCase())) { toast({ title: 'Bereits vorhanden', description: 'Bitte anderen Namen wählen.', variant: 'destructive' }); return }
    if (!providerInstance) { toast({ title: 'Kein Provider' , variant: 'destructive' }); return }
    try {
      const folderId = await ensureTemplatesFolder()
      const values = getDefaultTemplateValues(name)
      const content = (values.yamlFrontmatter ? values.yamlFrontmatter + '\n\n' : '') + values.markdownBody + '\n\n--- systemprompt\n' + values.systemPrompt
      const file = new File([new Blob([content], { type: 'text/markdown' })], `${name}.md`, { type: 'text/markdown' })
      await providerInstance.uploadFile(folderId, file)
      await loadTemplates()
      setSelectedTemplateName(name)
      form.reset(values)
      toast({ title: 'Template angelegt', description: `"${name}" wurde erstellt.` })
    } catch (e) {
      toast({ title: 'Fehler beim Anlegen', description: e instanceof Error ? e.message : 'Unbekannter Fehler', variant: 'destructive' })
    }
  }

  function generatePreview(): string {
    const values = form.getValues()
    return generateTemplateContent(values)
  }

  async function testTemplate() {
    if (!activeLibrary) return

    setIsTesting(true)
    setTestResult(null)

    const values = form.getValues()
    const templateContent = generateTemplateContent(values)
    const sections: string[] = []
    if (selectedContextMarkdown.trim()) sections.push(selectedContextMarkdown.trim())
    if (freeText.trim()) sections.push(`---\nDatei: Freitext\n---\n\n${freeText.trim()}\n\n---\nEnde Datei: Freitext\n---`)
    const testText = sections.join("\n\n")

    const pickMarkdown = (result: unknown): string => {
      if (typeof result === 'string') return result
      if (result && typeof result === 'object') {
        const obj = result as Record<string, unknown>
        const directCandidates = ['text','markdown','content','output'] as const
        for (const k of directCandidates) {
          const v = obj[k]
          if (typeof v === 'string') return v
        }
        // verschachtelte Felder prüfen
        const nested = obj['data']
        if (nested && typeof nested === 'object') {
          const nobj = nested as Record<string, unknown>
          for (const k of directCandidates) {
            const v = nobj[k]
            if (typeof v === 'string') return v
          }
        }
      }
      return JSON.stringify(result, null, 2)
    }

    try {
      const response = await fetch('/api/secretary/process-text', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/x-www-form-urlencoded',
          'X-Library-Id': activeLibrary.id,
        },
        body: new URLSearchParams({
          text: testText,
          template_content: templateContent,
          source_language: 'de',
          target_language: 'de',
          use_cache: 'false',
        }),
      })

      if (!response.ok) {
        const errorData = await response.json()
        throw new Error(errorData.error || `HTTP ${response.status}: ${response.statusText}`)
      }

      const result = await response.json()
      const formattedResult = pickMarkdown(result)
      console.log('Prompt-Test Ergebnis:', formattedResult)
      
      setTestResult(formattedResult)
      setRightTab('testen')

      toast({
        title: "Prompt-Test erfolgreich",
        description: "Der Prompt wurde erfolgreich mit dem gewählten Kontext verarbeitet.",
      })

      console.log('Prompt-Test Ergebnis (roh):', result)
    } catch (error) {
      console.error('Fehler beim Prompt-Test:', error)
      const errorMessage = error instanceof Error ? error.message : "Unbekannter Fehler"
      setTestResult(`Fehler: ${errorMessage}`)
      setRightTab('testen')
      toast({
        title: "Prompt-Test fehlgeschlagen",
        description: errorMessage,
        variant: "destructive",
      })
    } finally {
      setIsTesting(false)
    }
  }

  async function ensurePromptTestsFolder(): Promise<string> {
    if (!providerInstance) throw new Error('Kein Provider verfügbar')
    const roots = await listItems('root')
    const found = roots.find(it => it.type === 'folder' && it.metadata.name === 'prompt-tests')
    if (found) return found.id
    const created = await providerInstance.createFolder('root', 'prompt-tests')
    return created.id
  }

  async function saveTestResult() {
    try {
      if (!providerInstance || !activeLibrary || !testResult) return
      const folderId = await ensurePromptTestsFolder()
      const name = `${selectedTemplateName || 'prompt'}-test-${new Date().toISOString().replace(/[:.]/g,'-')}.md`
      const blob = new Blob([testResult], { type: 'text/markdown' })
      const file = new File([blob], name, { type: 'text/markdown' })
      const item = await providerInstance.uploadFile(folderId, file)
      setResultSavedItemId(item.id)
      toast({ title: 'Ergebnis gespeichert', description: name })
    } catch (e) {
      toast({ title: 'Speichern fehlgeschlagen', description: e instanceof Error ? e.message : 'Unbekannter Fehler', variant: 'destructive' })
    }
  }

  // Render-Logik für verschiedene Status
  if (libraryStatus === "waitingForAuth") {
    return (
      <div className="flex flex-col items-center justify-center h-full text-muted-foreground">
        <span>Diese Bibliothek benötigt eine Authentifizierung.</span>
        <span className="text-sm mt-2">Bitte konfigurieren Sie die Bibliothek in den Einstellungen.</span>
      </div>
    )
  }
  
  if (libraryStatus !== "ready") {
    return (
      <div className="flex flex-col items-center justify-center h-full text-muted-foreground">
        <span>Lade Storage...</span>
      </div>
    )
  }

  if (!activeLibrary) {
    return (
      <div className="text-center text-muted-foreground">
        Bitte wählen Sie eine Bibliothek aus.
      </div>
    )
  }

  if (error) {
    return (
      <div className="text-center text-destructive">
        <p>Fehler beim Laden der Prompts:</p>
        <p className="text-sm">{error}</p>
        <Button 
          variant="outline" 
          className="mt-4"
          onClick={loadTemplates}
        >
          Erneut versuchen
        </Button>
      </div>
    )
  }

  return (
    <div className="space-y-6">

      {/* Kompakte Toolbar oben */}
      <div className="flex items-center gap-2">
        <Select value={selectedTemplateName || ''} onValueChange={(v) => { setSelectedTemplateName(v); form.setValue('name', v, { shouldDirty: false }) }} disabled={isLoading}>
          <SelectTrigger className="w-64">
            <SelectValue placeholder="Prompt auswählen..." />
          </SelectTrigger>
          <SelectContent>
            {templates.map((t) => (
              <SelectItem key={t.name} value={t.name}>{t.name}</SelectItem>
            ))}
          </SelectContent>
        </Select>
        <TooltipProvider>
          <Tooltip>
            <TooltipTrigger asChild>
              <Button variant="ghost" size="sm" className="h-8 w-8 p-0"><Info className="h-4 w-4" /></Button>
            </TooltipTrigger>
            <TooltipContent>
              <div className="flex items-center gap-2"><FolderOpen className="h-4 w-4" /><span>Ort: /templates in „{activeLibrary.label}“</span></div>
            </TooltipContent>
          </Tooltip>
        </TooltipProvider>
        <Button type="button" variant="outline" size="sm" onClick={createNewTemplate} disabled={isLoading}>Neu</Button>
        <Button type="button" variant="outline" size="sm" onClick={renameCurrentTemplate} disabled={!selectedTemplateName}>Umbenennen</Button>
        {selectedTemplateName && (
          <Button type="button" variant="destructive" size="sm" onClick={() => deleteTemplate(selectedTemplateName!)}>Löschen</Button>
        )}
      </div>

      <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
        <Card>
          <CardHeader>
            <CardTitle>Prompt Design</CardTitle>
            <CardDescription>
              Drei Bereiche: Aufgabe (was), Rollenanweisung (wie), Metadaten (Begleitinfos).
            </CardDescription>
          </CardHeader>
          <CardContent>
            <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-6">
              {/* Template-Name Feld entfernt (oben verwaltet) */}

              {previewMode ? (
                <div className="space-y-4">
                  <div className="flex items-center justify-between">
                    <h4 className="text-sm font-medium">Prompt-Vorschau</h4>
                    <Button
                      type="button"
                      variant="outline"
                      size="sm"
                      onClick={() => setPreviewMode(false)}
                    >
                      Bearbeiten
                    </Button>
                  </div>
                  <div className="border rounded-md p-4 bg-muted/50">
                    <pre className="text-sm whitespace-pre-wrap font-mono">
                      {generatePreview()}
                    </pre>
                  </div>
                </div>
              ) : (
                <StructuredTemplateEditor
                  markdownBody={form.watch('markdownBody')}
                  yamlFrontmatter={form.watch('yamlFrontmatter')}
                  systemPrompt={form.watch('systemPrompt')}
                  onChange={({ markdownBody, yamlFrontmatter, systemPrompt }) => {
                    form.setValue('markdownBody', markdownBody, { shouldDirty: true })
                    form.setValue('yamlFrontmatter', yamlFrontmatter, { shouldDirty: true })
                    form.setValue('systemPrompt', systemPrompt, { shouldDirty: true })
                  }}
                />
              )}

              <div className="flex justify-end gap-2">
                <Button
                  type="button"
                  variant="outline"
                  onClick={() => setPreviewMode(!previewMode)}
                >
                  <Eye className="h-4 w-4 mr-2" />
                  {previewMode ? "Bearbeiten" : "Vorschau"}
                </Button>
                <Button
                  type="submit"
                  disabled={isSaving || !form.formState.isDirty}
                >
                  {isSaving ? (
                    <>
                      <Loader2 className="h-4 w-4 mr-2 animate-spin" />
                      Wird gespeichert...
                    </>
                  ) : (
                    <>
                      <Save className="h-4 w-4 mr-2" />
                      Speichern
                    </>
                  )}
                </Button>
              </div>
            </form>
          </CardContent>
        </Card>

        <Card>
          <CardHeader>
            <CardTitle>Prompt testen</CardTitle>
            <CardDescription>
              Test mit Beispieltext. Nutzt Rollenanweisung, Aufgabe und Metadaten des Prompts.
            </CardDescription>
          </CardHeader>
          <CardContent>
            <Tabs value={rightTab} onValueChange={(v) => setRightTab(v as typeof rightTab)}>
              <TabsList className="grid grid-cols-3 w-full">
                <TabsTrigger value="kontext">Daten‑Kontext</TabsTrigger>
                <TabsTrigger value="preview">Prompt‑Vorschau</TabsTrigger>
                <TabsTrigger value="testen">Testen</TabsTrigger>
              </TabsList>

              <TabsContent value="kontext" className="space-y-4 mt-4">
                <div className="space-y-2">
                  <Label>Kontext-Texte</Label>
                  <div className="border rounded p-2 text-sm">
                    {Array.isArray(contextDocs) && contextDocs.length > 0 ? (
                      contextDocs.map(d => {
                        const checked = selectedContextIds.includes(d.id)
                        return (
                          <label key={d.id} className="flex items-center gap-2 py-1">
                            <Checkbox
                              checked={checked}
                              onCheckedChange={(v) => {
                                const isOn = v === true
                                setSelectedContextIds(prev => isOn ? [...prev, d.id] : prev.filter(x => x !== d.id))
                              }}
                            />
                            <span className="truncate">{d.name}</span>
                          </label>
                        )
                      })
                    ) : (
                      <div className="text-muted-foreground text-sm">Keine Kontext-Texte verfügbar</div>
                    )}
                  </div>
                </div>

                <div className="space-y-2">
                  <Label>Gewählter Kontext (Lesemodus)</Label>
                  <div className="border rounded-md">
                    <MarkdownPreview content={selectedContextMarkdown} />
                  </div>
                </div>

                <div className="space-y-2">
                  <Label>Freitext (optional)</Label>
                  <Textarea
                    value={freeText}
                    onChange={(e) => setFreeText(e.target.value)}
                    placeholder="Hier Text einkleben, um schnell zu testen"
                    className="min-h-[120px] font-mono text-sm"
                  />
                </div>
              </TabsContent>

              <TabsContent value="preview" className="space-y-4 mt-4">
                <div className="space-y-2">
                  <Label>Generierter Prompt (Markdown)</Label>
                  <div className="border rounded-md">
                    <MarkdownPreview content={generatePreview()} />
                  </div>
                </div>
               </TabsContent>

              <TabsContent value="testen" className="space-y-4 mt-4">
                <div className="flex gap-2 justify-end">
                  <Button 
                    variant="outline" 
                    size="sm"
                    onClick={testTemplate}
                    disabled={!selectedTemplateName || isTesting}
                  >
                    {isTesting ? (
                      <>
                        <Loader2 className="h-4 w-4 mr-2 animate-spin" />
                        Teste...
                      </>
                    ) : (
                      <>
                        <Play className="h-4 w-4 mr-2" />
                        Prompt testen
                      </>
                    )}
                  </Button>
                </div>
                {activeLibrary && providerInstance && (testResult || resultSavedItemId) ? (
                  <JobReportTab
                    libraryId={activeLibrary.id}
                    fileId={resultSavedItemId || 'preview'}
                    provider={providerInstance}
                    sourceMode="frontmatter"
                    viewMode="metaOnly"
                    mdFileId={resultSavedItemId || undefined}
                    rawContent={testResult || undefined}
                  />
                ) : (
                  <div className="text-sm text-muted-foreground">Kein Ergebnis vorhanden.</div>
                )}
                <div className="flex gap-2">
                  <Button type="button" onClick={saveTestResult} disabled={!testResult}>Speichern</Button>
                </div>
              </TabsContent>
            </Tabs>
          </CardContent>
        </Card>
      </div>
    </div>
  )
} 
```

- Verbessertes Logging beim Speichern in `Prompt Design`:
  - Start/Ende mit `console.group('[TemplateManagement] Speichern')`.
  - Logs: Library-Info, `templatesFolderId`, Datei-Name und Content-Länge, bestehende Datei gefunden/gelöscht, Upload-Ergebnis, Reload bestätigt, Auswahl gesetzt.
  - Fehlerfälle werden mit `console.error` und Toast gemeldet.

Bitte erneut testen:
- Rollenanweisung ändern → Speichern.
- In der Browser-Konsole solltest du die komplette Sequenz sehen. Wenn weiterhin „altes“ geladen wird, prüfe, ob „Löschen OK“ und „Upload Ergebnis“ auftauchen; andernfalls liegt es am Provider (z. B. fehlende Schreibrechte oder falscher Ordner).

---

**User**

C:\Users\peter.aichner\projects\CommonKnowledgeScout\src\components\templates\template-management.tsx:399 [TemplateManagement] Speichern
C:\Users\peter.aichner\projects\CommonKnowledgeScout\src\components\templates\template-management.tsx:400 Library {id: 'ID_OnedriveTest', label: 'Onedrive Test', path: 'Archiv Peter'}
C:\Users\peter.aichner\projects\CommonKnowledgeScout\src\components\templates\template-management.tsx:401 TemplatesFolderId 01XERETULABD5TF4HGKREID7H2TQ6VIBMC
C:\Users\peter.aichner\projects\CommonKnowledgeScout\src\components\templates\template-management.tsx:402 Datei {fileName: 'Messe.md', contentLen: 2407}
C:\Users\peter.aichner\projects\CommonKnowledgeScout\src\components\templates\template-management.tsx:407 Bestehende Datei gefunden, lösche {fileId: '01XERETUNWLEMVXHT3PBDL2SWDZH4ASFY2'}
C:\Users\peter.aichner\projects\CommonKnowledgeScout\src\lib\storage\onedrive-provider.ts:470 [OneDriveProvider] Token-Status: {libraryId: 'ID_OnedriveTest', tokenExpiry: '2025-09-15T13:19:25.227Z', currentTime: '2025-09-15T12:06:05.294Z', timeUntilExpiry: '4399 Sekunden', hasRefreshToken: true, …}
C:\Users\peter.aichner\projects\CommonKnowledgeScout\src\components\templates\template-management.tsx:410 Löschen OK
C:\Users\peter.aichner\projects\CommonKnowledgeScout\src\lib\storage\onedrive-provider.ts:470 [OneDriveProvider] Token-Status: {libraryId: 'ID_OnedriveTest', tokenExpiry: '2025-09-15T13:19:25.227Z', currentTime: '2025-09-15T12:06:05.512Z', timeUntilExpiry: '4399 Sekunden', hasRefreshToken: true, …}
C:\Users\peter.aichner\projects\CommonKnowledgeScout\src\components\templates\template-management.tsx:423 Upload Ergebnis {id: '01XERETUOL4KYFPGGBO5H3SAJMUX6KNJIL', parentId: '01XERETULABD5TF4HGKREID7H2TQ6VIBMC', type: 'file', metadata: {…}}
C:\Users\peter.aichner\projects\CommonKnowledgeScout\src\components\templates\template-management.tsx:183 [TemplateManagement] Starte Prompt-Loading: {libraryId: 'ID_OnedriveTest', libraryPath: 'Archiv Peter', providerName: 'Microsoft OneDrive'}
C:\Users\peter.aichner\projects\CommonKnowledgeScout\src\components\templates\template-management.tsx:128 [TemplateManagement] Suche nach Templates-Ordner...
C:\Users\peter.aichner\projects\CommonKnowledgeScout\src\contexts\storage-context.tsx:457 [StorageContext][listItems] Aufruf: {requestedLibraryId: 'ID_OnedriveTest', activeLibraryId: 'ID_OnedriveTest', currentLibrary: {…}, providerId: 'ID_OnedriveTest', providerName: 'Microsoft OneDrive'}
C:\Users\peter.aichner\projects\CommonKnowledgeScout\src\lib\storage\onedrive-provider.ts:470 [OneDriveProvider] Token-Status: {libraryId: 'ID_OnedriveTest', tokenExpiry: '2025-09-15T13:19:25.227Z', currentTime: '2025-09-15T12:06:05.836Z', timeUntilExpiry: '4399 Sekunden', hasRefreshToken: true, …}
C:\Users\peter.aichner\projects\CommonKnowledgeScout\src\contexts\storage-context.tsx:481 [StorageContext][listItems] Erfolgreich 48 Items geladen
C:\Users\peter.aichner\projects\CommonKnowledgeScout\src\components\templates\template-management.tsx:134 [TemplateManagement] Templates-Ordner gefunden: 01XERETULABD5TF4HGKREID7H2TQ6VIBMC
C:\Users\peter.aichner\projects\CommonKnowledgeScout\src\components\templates\template-management.tsx:193 [TemplateManagement] Templates-Ordner gefunden/erstellt: 01XERETULABD5TF4HGKREID7H2TQ6VIBMC
C:\Users\peter.aichner\projects\CommonKnowledgeScout\src\contexts\storage-context.tsx:457 [StorageContext][listItems] Aufruf: {requestedLibraryId: 'ID_OnedriveTest', activeLibraryId: 'ID_OnedriveTest', currentLibrary: {…}, providerId: 'ID_OnedriveTest', providerName: 'Microsoft OneDrive'}
C:\Users\peter.aichner\projects\CommonKnowledgeScout\src\lib\storage\onedrive-provider.ts:470 [OneDriveProvider] Token-Status: {libraryId: 'ID_OnedriveTest', tokenExpiry: '2025-09-15T13:19:25.227Z', currentTime: '2025-09-15T12:06:06.113Z', timeUntilExpiry: '4399 Sekunden', hasRefreshToken: true, …}
C:\Users\peter.aichner\projects\CommonKnowledgeScout\src\contexts\storage-context.tsx:481 [StorageContext][listItems] Erfolgreich 7 Items geladen
C:\Users\peter.aichner\projects\CommonKnowledgeScout\src\components\templates\template-management.tsx:202 [TemplateManagement] Prompt-Dateien gefunden: 7
C:\Users\peter.aichner\projects\CommonKnowledgeScout\src\lib\storage\onedrive-provider.ts:470 [OneDriveProvider] Token-Status: {libraryId: 'ID_OnedriveTest', tokenExpiry: '2025-09-15T13:19:25.227Z', currentTime: '2025-09-15T12:06:06.270Z', timeUntilExpiry: '4398 Sekunden', hasRefreshToken: true, …}
C:\Users\peter.aichner\projects\CommonKnowledgeScout\src\lib\storage\onedrive-provider.ts:470 [OneDriveProvider] Token-Status: {libraryId: 'ID_OnedriveTest', tokenExpiry: '2025-09-15T13:19:25.227Z', currentTime: '2025-09-15T12:06:06.270Z', timeUntilExpiry: '4398 Sekunden', hasRefreshToken: true, …}
C:\Users\peter.aichner\projects\CommonKnowledgeScout\src\lib\storage\onedrive-provider.ts:470 [OneDriveProvider] Token-Status: {libraryId: 'ID_OnedriveTest', tokenExpiry: '2025-09-15T13:19:25.227Z', currentTime: '2025-09-15T12:06:06.270Z', timeUntilExpiry: '4398 Sekunden', hasRefreshToken: true, …}
C:\Users\peter.aichner\projects\CommonKnowledgeScout\src\lib\storage\onedrive-provider.ts:470 [OneDriveProvider] Token-Status: {libraryId: 'ID_OnedriveTest', tokenExpiry: '2025-09-15T13:19:25.227Z', currentTime: '2025-09-15T12:06:06.270Z', timeUntilExpiry: '4398 Sekunden', hasRefreshToken: true, …}
C:\Users\peter.aichner\projects\CommonKnowledgeScout\src\lib\storage\onedrive-provider.ts:470 [OneDriveProvider] Token-Status: {libraryId: 'ID_OnedriveTest', tokenExpiry: '2025-09-15T13:19:25.227Z', currentTime: '2025-09-15T12:06:06.271Z', timeUntilExpiry: '4398 Sekunden', hasRefreshToken: true, …}
C:\Users\peter.aichner\projects\CommonKnowledgeScout\src\lib\storage\onedrive-provider.ts:470 [OneDriveProvider] Token-Status: {libraryId: 'ID_OnedriveTest', tokenExpiry: '2025-09-15T13:19:25.227Z', currentTime: '2025-09-15T12:06:06.271Z', timeUntilExpiry: '4398 Sekunden', hasRefreshToken: true, …}
C:\Users\peter.aichner\projects\CommonKnowledgeScout\src\lib\storage\onedrive-provider.ts:470 [OneDriveProvider] Token-Status: {libraryId: 'ID_OnedriveTest', tokenExpiry: '2025-09-15T13:19:25.227Z', currentTime: '2025-09-15T12:06:06.271Z', timeUntilExpiry: '4398 Sekunden', hasRefreshToken: true, …}
C:\Users\peter.aichner\projects\CommonKnowledgeScout\src\components\templates\template-management.tsx:231 [TemplateManagement] Prompts erfolgreich geladen: 7
C:\Users\peter.aichner\projects\CommonKnowledgeScout\src\components\templates\template-management.tsx:427 Templates neu geladen
C:\Users\peter.aichner\projects\CommonKnowledgeScout\src\components\templates\template-management.tsx:431 Auswahl gesetzt Messe
C:\Users\peter.aichner\projects\CommonKnowledgeScout\src\lib\debug\logger.ts:55 [12:06:07.571Z][FILE:9][MarkdownPreview][debug] 🔍 Komponente gerendert {contentLength: 1615, currentItemId: undefined, currentItemName: undefined, activeTab: 'preview', hasProvider: false, …}
C:\Users\peter.aichner\projects\CommonKnowledgeScout\src\lib\debug\logger.ts:55 [12:06:07.572Z][FILE:10][MarkdownPreview][debug] 🔍 Markdown Content verarbeitet {contentLength: 1615, hasFrontmatter: false, renderedLength: 3194}


---

**Cursor**

```typescriptreact
"use client"

import { useState, useEffect, useCallback } from "react"
import { useForm } from "react-hook-form"
import { zodResolver } from "@hookform/resolvers/zod"
import * as z from "zod"
import { Button } from "@/components/ui/button"
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card"
import { Label } from "@/components/ui/label"
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select"
import { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from "@/components/ui/tooltip"
import { StructuredTemplateEditor } from "@/components/templates/structured-template-editor"
import { useToast } from "@/hooks/use-toast"
import { Loader2, Save, Eye, Play, FolderOpen, Info } from "lucide-react"
import { useAtom, useAtomValue } from "jotai"
import { activeLibraryAtom, libraryStatusAtom } from "@/atoms/library-atom"
import { 
  templatesAtom, 
  selectedTemplateNameAtom, 
  selectedTemplateAtom,
  templatesFolderIdAtom,
  templateLoadingAtom,
  templateErrorAtom,
  type Template
} from "@/atoms/template-atom"
import { useStorage } from "@/contexts/storage-context"
import { templateContextDocsAtom } from '@/atoms/template-context-atom'
import { Checkbox } from "@/components/ui/checkbox"
import { MarkdownPreview } from "@/components/library/markdown-preview"
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs"
import { JobReportTab } from "@/components/library/job-report-tab"
import { Textarea } from "@/components/ui/textarea"

// Schema für Template-Daten
const templateSchema = z.object({
  name: z.string().min(1, "Prompt-Name ist erforderlich"),
  yamlFrontmatter: z.string(),
  markdownBody: z.string(),
  systemPrompt: z.string(),
})

type TemplateFormValues = z.infer<typeof templateSchema>

export function TemplateManagement() {
  const [previewMode, setPreviewMode] = useState(false)
  const [isSaving, setIsSaving] = useState(false)
  const [isTesting, setIsTesting] = useState(false)
  const [testResult, setTestResult] = useState<string | null>(null)
  const [selectedContextIds, setSelectedContextIds] = useState<string[]>([])
  const [selectedContextMarkdown, setSelectedContextMarkdown] = useState<string>("")
  const [rightTab, setRightTab] = useState<'kontext'|'preview'|'testen'>('kontext')
  const [resultSavedItemId, setResultSavedItemId] = useState<string | null>(null)
  const [freeText, setFreeText] = useState<string>("")
  const { toast } = useToast()

  // Atoms
  const [templates, setTemplates] = useAtom(templatesAtom)
  const [selectedTemplateName, setSelectedTemplateName] = useAtom(selectedTemplateNameAtom)
  const [selectedTemplate] = useAtom(selectedTemplateAtom)
  const [templatesFolderId, setTemplatesFolderId] = useAtom(templatesFolderIdAtom)
  const [isLoading, setIsLoading] = useAtom(templateLoadingAtom)
  const [error, setError] = useAtom(templateErrorAtom)

  // Library und Storage
  const activeLibrary = useAtomValue(activeLibraryAtom)
  const libraryStatus = useAtomValue(libraryStatusAtom)
  const { 
    provider: providerInstance, 
    listItems
  } = useStorage()
  const contextDocs = useAtomValue(templateContextDocsAtom)

  const form = useForm<TemplateFormValues>({
    resolver: zodResolver(templateSchema),
    defaultValues: {
      name: "",
      yamlFrontmatter: `---
title: {{title|Titel des Dokuments}}
tags: {{tags|Relevante Tags}}
date: {{date|Datum im Format yyyy-mm-dd}}
---`,
      markdownBody: `# {{title}}

## Zusammenfassung
{{summary|Kurze Zusammenfassung des Inhalts}}

## Details
{{details|Detaillierte Beschreibung}}`,
      systemPrompt: `You are a specialized assistant that processes and structures information clearly and concisely.

IMPORTANT: Your response must be a valid JSON object where each key corresponds to a template variable.`,
    },
  })

  // Helper zum Erzeugen von Default-Werten
  function getDefaultTemplateValues(name: string): TemplateFormValues {
    return {
      name,
      yamlFrontmatter: `---\n` +
        `title: {{title|Titel des Dokuments}}\n` +
        `tags: {{tags|Relevante Tags}}\n` +
        `date: {{date|Datum im Format yyyy-mm-dd}}\n` +
        `---`,
      markdownBody: `# {{title}}\n\n## Zusammenfassung\n{{summary|Kurze Zusammenfassung des Inhalts}}\n\n## Details\n{{details|Detaillierte Beschreibung}}`,
      systemPrompt: `You are a specialized assistant that processes and structures information clearly and concisely.\n\nIMPORTANT: Your response must be a valid JSON object where each key corresponds to a template variable.`,
    }
  }

  // Template-Daten laden wenn sich die Auswahl ändert
  useEffect(() => {
    if (selectedTemplate) {
      form.reset({
        name: selectedTemplate.name,
        yamlFrontmatter: selectedTemplate.yamlFrontmatter,
        markdownBody: selectedTemplate.markdownBody,
        systemPrompt: selectedTemplate.systemPrompt,
      })
    }
  }, [selectedTemplate, form])

  // Ordner-Erstellung/Suche memoisiert, damit als Dep verwendbar
  const ensureTemplatesFolder = useCallback(async (): Promise<string> => {
    if (!providerInstance || !activeLibrary) {
      throw new Error("Keine aktive Bibliothek oder Provider verfügbar");
    }

    try {
      console.log('[TemplateManagement] Suche nach Templates-Ordner...');
      const rootItems = await listItems('root');
      const templatesFolder = rootItems.find(item => 
        item.type === 'folder' && item.metadata.name === 'templates'
      );
      if (templatesFolder) {
        console.log('[TemplateManagement] Templates-Ordner gefunden:', templatesFolder.id);
        return templatesFolder.id;
      }
      console.log('[TemplateManagement] Templates-Ordner nicht gefunden, erstelle neuen...');
      const newFolder = await providerInstance.createFolder('root', 'templates');
      console.log('[TemplateManagement] Neuer Templates-Ordner erstellt:', newFolder.id);
      return newFolder.id;
    } catch (error) {
      console.error('Fehler beim Erstellen des Templates-Ordners:', {
        error: error instanceof Error ? {
          message: error.message,
          name: error.name,
          stack: error.stack?.split('\n').slice(0, 3)
        } : error,
        libraryId: activeLibrary?.id,
        libraryPath: activeLibrary?.path,
        providerName: providerInstance?.name
      });
      let errorMessage = 'Fehler beim Erstellen des Templates-Ordners';
      if (error instanceof Error) {
        if (error.message.includes('Nicht authentifiziert')) {
          errorMessage = 'Bitte authentifizieren Sie sich bei Ihrem Cloud-Speicher, um den Templates-Ordner zu erstellen.';
        } else if (error.message.includes('Keine Berechtigung')) {
          errorMessage = 'Keine Berechtigung zum Erstellen von Ordnern in der Bibliothek.';
        } else if (error.message.includes('Bibliothek nicht gefunden')) {
          errorMessage = 'Die ausgewählte Bibliothek wurde nicht gefunden.';
        } else {
          errorMessage = `Fehler beim Erstellen des Templates-Ordners: ${error.message}`;
        }
      }
      throw new Error(errorMessage);
    }
  }, [providerInstance, activeLibrary, listItems]);

  // Templates laden mit der gleichen Logik wie Library-Komponente
  const loadTemplates = useCallback(async () => {
    if (!providerInstance || libraryStatus !== 'ready' || !activeLibrary) {
      console.log('[TemplateManagement] loadTemplates übersprungen:', {
        hasProvider: !!providerInstance,
        libraryStatus,
        hasActiveLibrary: !!activeLibrary
      });
      return;
    }

    try {
      setIsLoading(true);
      setError(null);

      console.log('[TemplateManagement] Starte Prompt-Loading:', {
        libraryId: activeLibrary.id,
        libraryPath: activeLibrary.path,
        providerName: providerInstance.name
      });

      // 1. Templates-Ordner finden oder erstellen
      const folderId = await ensureTemplatesFolder();
      setTemplatesFolderId(folderId);

      console.log('[TemplateManagement] Templates-Ordner gefunden/erstellt:', folderId);

      // 2. Alle Template-Dateien im Ordner auflisten
      const items = await listItems(folderId);
      const templateFiles = items.filter(item => 
        item.type === 'file' && 
        item.metadata.name.endsWith('.md')
      );

      console.log('[TemplateManagement] Prompt-Dateien gefunden:', templateFiles.length);

      // 3. Template-Inhalte laden
      const templatePromises = templateFiles.map(async (file) => {
        try {
          const { blob } = await providerInstance.getBinary(file.id);
          const content = await blob.text();
          const template = parseTemplateContent(content, file.metadata.name.replace('.md', ''));
          
          return {
            ...template,
            fileId: file.id,
            lastModified: typeof file.metadata.modifiedAt === 'string' 
              ? file.metadata.modifiedAt 
              : file.metadata.modifiedAt instanceof Date 
                ? file.metadata.modifiedAt.toISOString()
                : new Date().toISOString()
          } as Template;
        } catch (error) {
          console.error(`Fehler beim Parsen von ${file.metadata.name}:`, error);
          return null;
        }
      });

      const loadedTemplates = await Promise.all(templatePromises);
      const validTemplates = loadedTemplates.filter((t): t is Template => t !== null);
      
      setTemplates(validTemplates);
      
      console.log('[TemplateManagement] Prompts erfolgreich geladen:', validTemplates.length);
      
      if (validTemplates.length === 0) {
        toast({
          title: "Keine Prompts gefunden",
          description: "Erstellen Sie Ihren ersten Prompt im Verzeichnis '/templates'.",
        });
      }
    } catch (error) {
      console.error('Fehler beim Laden der Prompts:', {
        error: error instanceof Error ? {
          message: error.message,
          name: error.name,
          stack: error.stack?.split('\n').slice(0, 3)
        } : error,
        libraryId: activeLibrary?.id,
        libraryPath: activeLibrary?.path,
        providerName: providerInstance?.name
      });

      let errorMessage = 'Unbekannter Fehler beim Laden der Prompts';
      
      if (error instanceof Error) {
        errorMessage = error.message;
        
        // Spezifische Fehlermeldungen für häufige Probleme
        if (error.message.includes('Nicht authentifiziert')) {
          errorMessage = 'Bitte authentifizieren Sie sich bei Ihrem Cloud-Speicher, um Prompts zu laden.';
        } else if (error.message.includes('Bibliothek nicht gefunden')) {
          errorMessage = 'Die ausgewählte Bibliothek wurde nicht gefunden. Bitte überprüfen Sie die Bibliothekskonfiguration.';
        } else if (error.message.includes('Server-Fehler')) {
          errorMessage = 'Server-Fehler beim Laden der Prompts. Bitte überprüfen Sie, ob der Bibliothekspfad existiert und zugänglich ist.';
        } else if (error.message.includes('Keine aktive Bibliothek')) {
          errorMessage = 'Keine aktive Bibliothek verfügbar. Bitte wählen Sie eine Bibliothek aus.';
        }
      }
      
      setError(errorMessage);
      toast({
        title: "Fehler beim Laden der Prompts",
        description: errorMessage,
        variant: "destructive",
      });
    } finally {
      setIsLoading(false);
    }
  }, [providerInstance, libraryStatus, activeLibrary, listItems, setTemplates, setTemplatesFolderId, setIsLoading, setError, toast, ensureTemplatesFolder]);

  // Effect für Template Loading (wie Library-Komponente)
  useEffect(() => {
    const isReady = providerInstance && libraryStatus === 'ready' && activeLibrary
    
    if (!isReady) {
      return
    }

    // Templates laden wenn noch nicht geladen
    if (!templatesFolderId) {
      loadTemplates()
    }
  }, [providerInstance, libraryStatus, activeLibrary, templatesFolderId, loadTemplates])

  // Reset wenn sich die Library ändert
  useEffect(() => {
    setSelectedTemplateName(null)
    setTemplatesFolderId(null)
    setTemplates([])
    setError(null)
  }, [libraryStatus, setSelectedTemplateName, setTemplatesFolderId, setTemplates, setError])

  useEffect(() => {
    async function loadSelectedContext() {
      if (!providerInstance || !Array.isArray(selectedContextIds) || selectedContextIds.length === 0) {
        setSelectedContextMarkdown("")
        return
      }
      try {
        const parts: string[] = []
        for (const id of selectedContextIds) {
          const { blob } = await providerInstance.getBinary(id)
          const text = await blob.text()
          const name = Array.isArray(contextDocs) ? (contextDocs.find(d => d.id === id)?.name || id) : id
          const section = `\n\n---\nDatei: ${name}\n---\n\n${text}\n\n---\nEnde Datei: ${name}\n---\n`
          parts.push(section)
        }
        setSelectedContextMarkdown(parts.join("\n\n"))
      } catch (e) {
        console.error('Fehler beim Laden des Kontextes', e)
        setSelectedContextMarkdown("")
      }
    }
    void loadSelectedContext()
  }, [providerInstance, selectedContextIds, contextDocs])

  function parseTemplateContent(content: string, fileName: string): Template {
    // Template in drei Bereiche aufteilen
    const parts = content.split('--- systemprompt')
    
    let yamlFrontmatter = ""
    let markdownBody = ""
    let systemPrompt = ""
    
    if (parts.length >= 2) {
      const mainContent = parts[0].trim()
      systemPrompt = parts[1].trim()
      
      // YAML Frontmatter extrahieren
      const yamlMatch = mainContent.match(/^---\r?\n([\s\S]*?)\r?\n---\r?\n?([\s\S]*)$/)
      if (yamlMatch) {
        yamlFrontmatter = `---\n${yamlMatch[1]}\n---`
        markdownBody = yamlMatch[2].trim()
      } else {
        // Kein YAML Frontmatter gefunden
        markdownBody = mainContent
      }
    } else {
      // Kein Systemprompt gefunden
      const yamlMatch = content.match(/^---\r?\n([\s\S]*?)\r?\n---\r?\n?([\s\S]*)$/)
      if (yamlMatch) {
        yamlFrontmatter = `---\n${yamlMatch[1]}\n---`
        markdownBody = yamlMatch[2].trim()
      } else {
        markdownBody = content
      }
    }

    return {
      name: fileName,
      yamlFrontmatter,
      markdownBody,
      systemPrompt,
    }
  }

  function generateTemplateContent(values: TemplateFormValues): string {
    let content = ""
    
    // YAML Frontmatter hinzufügen
    if (values.yamlFrontmatter.trim()) {
      content += values.yamlFrontmatter + "\n\n"
    }
    
    // Markdown Body hinzufügen
    content += values.markdownBody
    
    // System Prompt hinzufügen
    if (values.systemPrompt.trim()) {
      content += "\n\n--- systemprompt\n" + values.systemPrompt
    }
    
    return content
  }

  async function onSubmit(data: TemplateFormValues) {
    if (!activeLibrary || !templatesFolderId || !providerInstance) {
      toast({
        title: "Fehler",
        description: "Keine aktive Bibliothek oder Templates-Ordner nicht gefunden.",
        variant: "destructive",
      })
      return
    }

    setIsSaving(true)
    try {
      const templateContent = generateTemplateContent(data)
      const fileName = `${data.name}.md`
      
      console.group('[TemplateManagement] Speichern')
      console.log('Library', { id: activeLibrary.id, label: activeLibrary.label, path: activeLibrary.path })
      console.log('TemplatesFolderId', templatesFolderId)
      console.log('Datei', { fileName, contentLen: templateContent.length })
      
      // Falls Datei mit gleichem Namen existiert: erst löschen, dann neu schreiben
      const existing = templates.find(t => t.name.toLowerCase() === data.name.toLowerCase())
      if (existing?.fileId) {
        console.log('Bestehende Datei gefunden, lösche', { fileId: existing.fileId })
        try {
          await providerInstance.deleteItem(existing.fileId)
          console.log('Löschen OK')
        } catch (e) {
          console.error('Löschen fehlgeschlagen', e)
          toast({ title: 'Löschen fehlgeschlagen', description: e instanceof Error ? e.message : String(e), variant: 'destructive' })
        }
      } else {
        console.log('Keine bestehende Datei mit gleichem Namen gefunden')
      }
      
      // Datei als Blob erstellen und hochladen (Neu-Anlage / Ersetzen)
      const blob = new Blob([templateContent], { type: 'text/markdown' })
      const file = new File([blob], fileName, { type: 'text/markdown' })
      const uploaded = await providerInstance.uploadFile(templatesFolderId, file)
      console.log('Upload Ergebnis', uploaded)
      
      // Direkt nach Upload erneut lesen (Bypass-Stale) und lokalen State aktualisieren
      try {
        const { blob: rbBlob } = await providerInstance.getBinary(uploaded.id)
        const rbText = await rbBlob.text()
        console.log('Read-Back Länge', rbText.length, 'Auszug', rbText.slice(0, 120))
        const parsed = parseTemplateContent(rbText, data.name)
        const updated: Template = {
          ...parsed,
          fileId: uploaded.id,
          lastModified: new Date().toISOString()
        }
        setTemplates(prev => {
          const rest = prev.filter(t => t.name.toLowerCase() !== data.name.toLowerCase())
          return [...rest, updated]
        })
      } catch (e) {
        console.warn('Read-Back nach Upload fehlgeschlagen', e)
      }
      
      // Kurze Wartezeit, damit Remote-Provider (OneDrive) Index/Cache aktualisiert
      await new Promise(r => setTimeout(r, 500))
      
      // Templates neu laden (finaler Sync mit Remote)
      await loadTemplates()
      console.log('Templates neu geladen')
      
      // Auswahl auf das neue Template setzen
      setSelectedTemplateName(data.name)
      console.log('Auswahl gesetzt', data.name)
      
      toast({
        title: "Prompt gespeichert",
        description: `"${data.name}" wurde aktualisiert.`,
      })
      console.groupEnd()
    } catch (error) {
      console.error('Fehler beim Speichern des Templates:', error)
      toast({
        title: "Fehler beim Speichern",
        description: error instanceof Error ? error.message : "Unbekannter Fehler",
        variant: "destructive",
      })
    } finally {
      setIsSaving(false)
    }
  }

  async function renameCurrentTemplate() {
    const current = selectedTemplateName ? templates.find(t => t.name === selectedTemplateName) : null
    if (!current || !current.fileId || !providerInstance) return
    const newName = (window.prompt('Neuen Namen eingeben:', current.name) || '').trim()
    if (!newName || newName === current.name) return
    if (/[^a-zA-Z0-9._\- ]/.test(newName)) { toast({ title: 'Ungültiger Name', description: 'Nur Buchstaben, Zahlen, Leerzeichen, . _ - sind erlaubt.', variant: 'destructive' }); return }
    if (templates.some(t => t.name.toLowerCase() === newName.toLowerCase())) { toast({ title: 'Bereits vorhanden', description: 'Bitte anderen Namen wählen.', variant: 'destructive' }); return }
    try {
      await providerInstance.renameItem(current.fileId, `${newName}.md`)
      await loadTemplates()
      setSelectedTemplateName(newName)
      form.setValue('name', newName, { shouldDirty: false })
      toast({ title: 'Umbenannt', description: `${current.name} → ${newName}` })
    } catch (e) {
      toast({ title: 'Fehler beim Umbenennen', description: e instanceof Error ? e.message : 'Unbekannter Fehler', variant: 'destructive' })
    }
  }

  async function deleteTemplate(templateName: string) {
    if (!activeLibrary || !providerInstance) return

    try {
      const template = templates.find(t => t.name === templateName)
      if (!template?.fileId) {
        throw new Error("Template-Datei nicht gefunden")
      }

      // Datei löschen
      await providerInstance.deleteItem(template.fileId)

      // Templates neu laden
      await loadTemplates()
      
      if (selectedTemplateName === templateName) {
        setSelectedTemplateName(null)
        form.reset()
      }
      
      toast({
        title: "Template gelöscht",
        description: `Template "${templateName}" wurde erfolgreich gelöscht.`,
      })
    } catch (error) {
      console.error('Fehler beim Löschen des Templates:', error)
      toast({
        title: "Fehler beim Löschen",
        description: error instanceof Error ? error.message : "Unbekannter Fehler",
        variant: "destructive",
      })
    }
  }

  async function createNewTemplate() {
    const name = (window.prompt('Neuen Template‑Namen eingeben:') || '').trim()
    if (!name) return
    if (/[^a-zA-Z0-9._\- ]/.test(name)) { toast({ title: 'Ungültiger Name', description: 'Nur Buchstaben, Zahlen, Leerzeichen, . _ - sind erlaubt.', variant: 'destructive' }); return }
    if (templates.some(t => t.name.toLowerCase() === name.toLowerCase())) { toast({ title: 'Bereits vorhanden', description: 'Bitte anderen Namen wählen.', variant: 'destructive' }); return }
    if (!providerInstance) { toast({ title: 'Kein Provider' , variant: 'destructive' }); return }
    try {
      const folderId = await ensureTemplatesFolder()
      const values = getDefaultTemplateValues(name)
      const content = (values.yamlFrontmatter ? values.yamlFrontmatter + '\n\n' : '') + values.markdownBody + '\n\n--- systemprompt\n' + values.systemPrompt
      const file = new File([new Blob([content], { type: 'text/markdown' })], `${name}.md`, { type: 'text/markdown' })
      await providerInstance.uploadFile(folderId, file)
      await loadTemplates()
      setSelectedTemplateName(name)
      form.reset(values)
      toast({ title: 'Template angelegt', description: `"${name}" wurde erstellt.` })
    } catch (e) {
      toast({ title: 'Fehler beim Anlegen', description: e instanceof Error ? e.message : 'Unbekannter Fehler', variant: 'destructive' })
    }
  }

  function generatePreview(): string {
    const values = form.getValues()
    return generateTemplateContent(values)
  }

  async function testTemplate() {
    if (!activeLibrary) return

    setIsTesting(true)
    setTestResult(null)

    const values = form.getValues()
    const templateContent = generateTemplateContent(values)
    const sections: string[] = []
    if (selectedContextMarkdown.trim()) sections.push(selectedContextMarkdown.trim())
    if (freeText.trim()) sections.push(`---\nDatei: Freitext\n---\n\n${freeText.trim()}\n\n---\nEnde Datei: Freitext\n---`)
    const testText = sections.join("\n\n")

    const pickMarkdown = (result: unknown): string => {
      if (typeof result === 'string') return result
      if (result && typeof result === 'object') {
        const obj = result as Record<string, unknown>
        const directCandidates = ['text','markdown','content','output'] as const
        for (const k of directCandidates) {
          const v = obj[k]
          if (typeof v === 'string') return v
        }
        // verschachtelte Felder prüfen
        const nested = obj['data']
        if (nested && typeof nested === 'object') {
          const nobj = nested as Record<string, unknown>
          for (const k of directCandidates) {
            const v = nobj[k]
            if (typeof v === 'string') return v
          }
        }
      }
      return JSON.stringify(result, null, 2)
    }

    try {
      const response = await fetch('/api/secretary/process-text', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/x-www-form-urlencoded',
          'X-Library-Id': activeLibrary.id,
        },
        body: new URLSearchParams({
          text: testText,
          template_content: templateContent,
          source_language: 'de',
          target_language: 'de',
          use_cache: 'false',
        }),
      })

      if (!response.ok) {
        const errorData = await response.json()
        throw new Error(errorData.error || `HTTP ${response.status}: ${response.statusText}`)
      }

      const result = await response.json()
      const formattedResult = pickMarkdown(result)
      console.log('Prompt-Test Ergebnis:', formattedResult)
      
      setTestResult(formattedResult)
      setRightTab('testen')

      toast({
        title: "Prompt-Test erfolgreich",
        description: "Der Prompt wurde erfolgreich mit dem gewählten Kontext verarbeitet.",
      })

      console.log('Prompt-Test Ergebnis (roh):', result)
    } catch (error) {
      console.error('Fehler beim Prompt-Test:', error)
      const errorMessage = error instanceof Error ? error.message : "Unbekannter Fehler"
      setTestResult(`Fehler: ${errorMessage}`)
      setRightTab('testen')
      toast({
        title: "Prompt-Test fehlgeschlagen",
        description: errorMessage,
        variant: "destructive",
      })
    } finally {
      setIsTesting(false)
    }
  }

  async function ensurePromptTestsFolder(): Promise<string> {
    if (!providerInstance) throw new Error('Kein Provider verfügbar')
    const roots = await listItems('root')
    const found = roots.find(it => it.type === 'folder' && it.metadata.name === 'prompt-tests')
    if (found) return found.id
    const created = await providerInstance.createFolder('root', 'prompt-tests')
    return created.id
  }

  async function saveTestResult() {
    try {
      if (!providerInstance || !activeLibrary || !testResult) return
      const folderId = await ensurePromptTestsFolder()
      const name = `${selectedTemplateName || 'prompt'}-test-${new Date().toISOString().replace(/[:.]/g,'-')}.md`
      const blob = new Blob([testResult], { type: 'text/markdown' })
      const file = new File([blob], name, { type: 'text/markdown' })
      const item = await providerInstance.uploadFile(folderId, file)
      setResultSavedItemId(item.id)
      toast({ title: 'Ergebnis gespeichert', description: name })
    } catch (e) {
      toast({ title: 'Speichern fehlgeschlagen', description: e instanceof Error ? e.message : 'Unbekannter Fehler', variant: 'destructive' })
    }
  }

  // Render-Logik für verschiedene Status
  if (libraryStatus === "waitingForAuth") {
    return (
      <div className="flex flex-col items-center justify-center h-full text-muted-foreground">
        <span>Diese Bibliothek benötigt eine Authentifizierung.</span>
        <span className="text-sm mt-2">Bitte konfigurieren Sie die Bibliothek in den Einstellungen.</span>
      </div>
    )
  }
  
  if (libraryStatus !== "ready") {
    return (
      <div className="flex flex-col items-center justify-center h-full text-muted-foreground">
        <span>Lade Storage...</span>
      </div>
    )
  }

  if (!activeLibrary) {
    return (
      <div className="text-center text-muted-foreground">
        Bitte wählen Sie eine Bibliothek aus.
      </div>
    )
  }

  if (error) {
    return (
      <div className="text-center text-destructive">
        <p>Fehler beim Laden der Prompts:</p>
        <p className="text-sm">{error}</p>
        <Button 
          variant="outline" 
          className="mt-4"
          onClick={loadTemplates}
        >
          Erneut versuchen
        </Button>
      </div>
    )
  }

  return (
    <div className="space-y-6">

      {/* Kompakte Toolbar oben */}
      <div className="flex items-center gap-2">
        <Select value={selectedTemplateName || ''} onValueChange={(v) => { setSelectedTemplateName(v); form.setValue('name', v, { shouldDirty: false }) }} disabled={isLoading}>
          <SelectTrigger className="w-64">
            <SelectValue placeholder="Prompt auswählen..." />
          </SelectTrigger>
          <SelectContent>
            {templates.map((t) => (
              <SelectItem key={t.name} value={t.name}>{t.name}</SelectItem>
            ))}
          </SelectContent>
        </Select>
        <TooltipProvider>
          <Tooltip>
            <TooltipTrigger asChild>
              <Button variant="ghost" size="sm" className="h-8 w-8 p-0"><Info className="h-4 w-4" /></Button>
            </TooltipTrigger>
            <TooltipContent>
              <div className="flex items-center gap-2"><FolderOpen className="h-4 w-4" /><span>Ort: /templates in „{activeLibrary.label}“</span></div>
            </TooltipContent>
          </Tooltip>
        </TooltipProvider>
        <Button type="button" variant="outline" size="sm" onClick={createNewTemplate} disabled={isLoading}>Neu</Button>
        <Button type="button" variant="outline" size="sm" onClick={renameCurrentTemplate} disabled={!selectedTemplateName}>Umbenennen</Button>
        {selectedTemplateName && (
          <Button type="button" variant="destructive" size="sm" onClick={() => deleteTemplate(selectedTemplateName!)}>Löschen</Button>
        )}
      </div>

      <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
        <Card>
          <CardHeader>
            <CardTitle>Prompt Design</CardTitle>
            <CardDescription>
              Drei Bereiche: Aufgabe (was), Rollenanweisung (wie), Metadaten (Begleitinfos).
            </CardDescription>
          </CardHeader>
          <CardContent>
            <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-6">
              {/* Template-Name Feld entfernt (oben verwaltet) */}

              {previewMode ? (
                <div className="space-y-4">
                  <div className="flex items-center justify-between">
                    <h4 className="text-sm font-medium">Prompt-Vorschau</h4>
                    <Button
                      type="button"
                      variant="outline"
                      size="sm"
                      onClick={() => setPreviewMode(false)}
                    >
                      Bearbeiten
                    </Button>
                  </div>
                  <div className="border rounded-md p-4 bg-muted/50">
                    <pre className="text-sm whitespace-pre-wrap font-mono">
                      {generatePreview()}
                    </pre>
                  </div>
                </div>
              ) : (
                <StructuredTemplateEditor
                  markdownBody={form.watch('markdownBody')}
                  yamlFrontmatter={form.watch('yamlFrontmatter')}
                  systemPrompt={form.watch('systemPrompt')}
                  onChange={({ markdownBody, yamlFrontmatter, systemPrompt }) => {
                    form.setValue('markdownBody', markdownBody, { shouldDirty: true })
                    form.setValue('yamlFrontmatter', yamlFrontmatter, { shouldDirty: true })
                    form.setValue('systemPrompt', systemPrompt, { shouldDirty: true })
                  }}
                />
              )}

              <div className="flex justify-end gap-2">
                <Button
                  type="button"
                  variant="outline"
                  onClick={() => setPreviewMode(!previewMode)}
                >
                  <Eye className="h-4 w-4 mr-2" />
                  {previewMode ? "Bearbeiten" : "Vorschau"}
                </Button>
                <Button
                  type="submit"
                  disabled={isSaving || !form.formState.isDirty}
                >
                  {isSaving ? (
                    <>
                      <Loader2 className="h-4 w-4 mr-2 animate-spin" />
                      Wird gespeichert...
                    </>
                  ) : (
                    <>
                      <Save className="h-4 w-4 mr-2" />
                      Speichern
                    </>
                  )}
                </Button>
              </div>
            </form>
          </CardContent>
        </Card>

        <Card>
          <CardHeader>
            <CardTitle>Prompt testen</CardTitle>
            <CardDescription>
              Test mit Beispieltext. Nutzt Rollenanweisung, Aufgabe und Metadaten des Prompts.
            </CardDescription>
          </CardHeader>
          <CardContent>
            <Tabs value={rightTab} onValueChange={(v) => setRightTab(v as typeof rightTab)}>
              <TabsList className="grid grid-cols-3 w-full">
                <TabsTrigger value="kontext">Daten‑Kontext</TabsTrigger>
                <TabsTrigger value="preview">Prompt‑Vorschau</TabsTrigger>
                <TabsTrigger value="testen">Testen</TabsTrigger>
              </TabsList>

              <TabsContent value="kontext" className="space-y-4 mt-4">
                <div className="space-y-2">
                  <Label>Kontext-Texte</Label>
                  <div className="border rounded p-2 text-sm">
                    {Array.isArray(contextDocs) && contextDocs.length > 0 ? (
                      contextDocs.map(d => {
                        const checked = selectedContextIds.includes(d.id)
                        return (
                          <label key={d.id} className="flex items-center gap-2 py-1">
                            <Checkbox
                              checked={checked}
                              onCheckedChange={(v) => {
                                const isOn = v === true
                                setSelectedContextIds(prev => isOn ? [...prev, d.id] : prev.filter(x => x !== d.id))
                              }}
                            />
                            <span className="truncate">{d.name}</span>
                          </label>
                        )
                      })
                    ) : (
                      <div className="text-muted-foreground text-sm">Keine Kontext-Texte verfügbar</div>
                    )}
                  </div>
                </div>

                <div className="space-y-2">
                  <Label>Gewählter Kontext (Lesemodus)</Label>
                  <div className="border rounded-md">
                    <MarkdownPreview content={selectedContextMarkdown} />
                  </div>
                </div>

                <div className="space-y-2">
                  <Label>Freitext (optional)</Label>
                  <Textarea
                    value={freeText}
                    onChange={(e) => setFreeText(e.target.value)}
                    placeholder="Hier Text einkleben, um schnell zu testen"
                    className="min-h-[120px] font-mono text-sm"
                  />
                </div>
              </TabsContent>

              <TabsContent value="preview" className="space-y-4 mt-4">
                <div className="space-y-2">
                  <Label>Generierter Prompt (Markdown)</Label>
                  <div className="border rounded-md">
                    <MarkdownPreview content={generatePreview()} />
                  </div>
                </div>
               </TabsContent>

              <TabsContent value="testen" className="space-y-4 mt-4">
                <div className="flex gap-2 justify-end">
                  <Button 
                    variant="outline" 
                    size="sm"
                    onClick={testTemplate}
                    disabled={!selectedTemplateName || isTesting}
                  >
                    {isTesting ? (
                      <>
                        <Loader2 className="h-4 w-4 mr-2 animate-spin" />
                        Teste...
                      </>
                    ) : (
                      <>
                        <Play className="h-4 w-4 mr-2" />
                        Prompt testen
                      </>
                    )}
                  </Button>
                </div>
                {activeLibrary && providerInstance && (testResult || resultSavedItemId) ? (
                  <JobReportTab
                    libraryId={activeLibrary.id}
                    fileId={resultSavedItemId || 'preview'}
                    provider={providerInstance}
                    sourceMode="frontmatter"
                    viewMode="metaOnly"
                    mdFileId={resultSavedItemId || undefined}
                    rawContent={testResult || undefined}
                  />
                ) : (
                  <div className="text-sm text-muted-foreground">Kein Ergebnis vorhanden.</div>
                )}
                <div className="flex gap-2">
                  <Button type="button" onClick={saveTestResult} disabled={!testResult}>Speichern</Button>
                </div>
              </TabsContent>
            </Tabs>
          </CardContent>
        </Card>
      </div>
    </div>
  )
} 
```

```typescriptreact
"use client"

import { useState, useEffect, useCallback } from "react"
import { useForm } from "react-hook-form"
import { zodResolver } from "@hookform/resolvers/zod"
import * as z from "zod"
import { Button } from "@/components/ui/button"
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card"
import { Label } from "@/components/ui/label"
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select"
import { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from "@/components/ui/tooltip"
import { StructuredTemplateEditor } from "@/components/templates/structured-template-editor"
import { useToast } from "@/hooks/use-toast"
import { Loader2, Save, Eye, Play, FolderOpen, Info } from "lucide-react"
import { useAtom, useAtomValue } from "jotai"
import { activeLibraryAtom, libraryStatusAtom } from "@/atoms/library-atom"
import { 
  templatesAtom, 
  selectedTemplateNameAtom, 
  selectedTemplateAtom,
  templatesFolderIdAtom,
  templateLoadingAtom,
  templateErrorAtom,
  type Template
} from "@/atoms/template-atom"
import { useStorage } from "@/contexts/storage-context"
import { templateContextDocsAtom } from '@/atoms/template-context-atom'
import { Checkbox } from "@/components/ui/checkbox"
import { MarkdownPreview } from "@/components/library/markdown-preview"
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs"
import { JobReportTab } from "@/components/library/job-report-tab"
import { Textarea } from "@/components/ui/textarea"

// Schema für Template-Daten
const templateSchema = z.object({
  name: z.string().min(1, "Prompt-Name ist erforderlich"),
  yamlFrontmatter: z.string(),
  markdownBody: z.string(),
  systemPrompt: z.string(),
})

type TemplateFormValues = z.infer<typeof templateSchema>

export function TemplateManagement() {
  const [previewMode, setPreviewMode] = useState(false)
  const [isSaving, setIsSaving] = useState(false)
  const [isTesting, setIsTesting] = useState(false)
  const [testResult, setTestResult] = useState<string | null>(null)
  const [selectedContextIds, setSelectedContextIds] = useState<string[]>([])
  const [selectedContextMarkdown, setSelectedContextMarkdown] = useState<string>("")
  const [rightTab, setRightTab] = useState<'kontext'|'preview'|'testen'>('kontext')
  const [resultSavedItemId, setResultSavedItemId] = useState<string | null>(null)
  const [freeText, setFreeText] = useState<string>("")
  const { toast } = useToast()

  // Atoms
  const [templates, setTemplates] = useAtom(templatesAtom)
  const [selectedTemplateName, setSelectedTemplateName] = useAtom(selectedTemplateNameAtom)
  const [selectedTemplate] = useAtom(selectedTemplateAtom)
  const [templatesFolderId, setTemplatesFolderId] = useAtom(templatesFolderIdAtom)
  const [isLoading, setIsLoading] = useAtom(templateLoadingAtom)
  const [error, setError] = useAtom(templateErrorAtom)

  // Library und Storage
  const activeLibrary = useAtomValue(activeLibraryAtom)
  const libraryStatus = useAtomValue(libraryStatusAtom)
  const { 
    provider: providerInstance, 
    listItems
  } = useStorage()
  const contextDocs = useAtomValue(templateContextDocsAtom)

  const form = useForm<TemplateFormValues>({
    resolver: zodResolver(templateSchema),
    defaultValues: {
      name: "",
      yamlFrontmatter: `---
title: {{title|Titel des Dokuments}}
tags: {{tags|Relevante Tags}}
date: {{date|Datum im Format yyyy-mm-dd}}
---`,
      markdownBody: `# {{title}}

## Zusammenfassung
{{summary|Kurze Zusammenfassung des Inhalts}}

## Details
{{details|Detaillierte Beschreibung}}`,
      systemPrompt: `You are a specialized assistant that processes and structures information clearly and concisely.

IMPORTANT: Your response must be a valid JSON object where each key corresponds to a template variable.`,
    },
  })

  // Helper zum Erzeugen von Default-Werten
  function getDefaultTemplateValues(name: string): TemplateFormValues {
    return {
      name,
      yamlFrontmatter: `---\n` +
        `title: {{title|Titel des Dokuments}}\n` +
        `tags: {{tags|Relevante Tags}}\n` +
        `date: {{date|Datum im Format yyyy-mm-dd}}\n` +
        `---`,
      markdownBody: `# {{title}}\n\n## Zusammenfassung\n{{summary|Kurze Zusammenfassung des Inhalts}}\n\n## Details\n{{details|Detaillierte Beschreibung}}`,
      systemPrompt: `You are a specialized assistant that processes and structures information clearly and concisely.\n\nIMPORTANT: Your response must be a valid JSON object where each key corresponds to a template variable.`,
    }
  }

  // Template-Daten laden wenn sich die Auswahl ändert
  useEffect(() => {
    if (selectedTemplate) {
      form.reset({
        name: selectedTemplate.name,
        yamlFrontmatter: selectedTemplate.yamlFrontmatter,
        markdownBody: selectedTemplate.markdownBody,
        systemPrompt: selectedTemplate.systemPrompt,
      })
    }
  }, [selectedTemplate, form])

  // Ordner-Erstellung/Suche memoisiert, damit als Dep verwendbar
  const ensureTemplatesFolder = useCallback(async (): Promise<string> => {
    if (!providerInstance || !activeLibrary) {
      throw new Error("Keine aktive Bibliothek oder Provider verfügbar");
    }

    try {
      console.log('[TemplateManagement] Suche nach Templates-Ordner...');
      const rootItems = await listItems('root');
      const templatesFolder = rootItems.find(item => 
        item.type === 'folder' && item.metadata.name === 'templates'
      );
      if (templatesFolder) {
        console.log('[TemplateManagement] Templates-Ordner gefunden:', templatesFolder.id);
        return templatesFolder.id;
      }
      console.log('[TemplateManagement] Templates-Ordner nicht gefunden, erstelle neuen...');
      const newFolder = await providerInstance.createFolder('root', 'templates');
      console.log('[TemplateManagement] Neuer Templates-Ordner erstellt:', newFolder.id);
      return newFolder.id;
    } catch (error) {
      console.error('Fehler beim Erstellen des Templates-Ordners:', {
        error: error instanceof Error ? {
          message: error.message,
          name: error.name,
          stack: error.stack?.split('\n').slice(0, 3)
        } : error,
        libraryId: activeLibrary?.id,
        libraryPath: activeLibrary?.path,
        providerName: providerInstance?.name
      });
      let errorMessage = 'Fehler beim Erstellen des Templates-Ordners';
      if (error instanceof Error) {
        if (error.message.includes('Nicht authentifiziert')) {
          errorMessage = 'Bitte authentifizieren Sie sich bei Ihrem Cloud-Speicher, um den Templates-Ordner zu erstellen.';
        } else if (error.message.includes('Keine Berechtigung')) {
          errorMessage = 'Keine Berechtigung zum Erstellen von Ordnern in der Bibliothek.';
        } else if (error.message.includes('Bibliothek nicht gefunden')) {
          errorMessage = 'Die ausgewählte Bibliothek wurde nicht gefunden.';
        } else {
          errorMessage = `Fehler beim Erstellen des Templates-Ordners: ${error.message}`;
        }
      }
      throw new Error(errorMessage);
    }
  }, [providerInstance, activeLibrary, listItems]);

  // Templates laden mit der gleichen Logik wie Library-Komponente
  const loadTemplates = useCallback(async () => {
    if (!providerInstance || libraryStatus !== 'ready' || !activeLibrary) {
      console.log('[TemplateManagement] loadTemplates übersprungen:', {
        hasProvider: !!providerInstance,
        libraryStatus,
        hasActiveLibrary: !!activeLibrary
      });
      return;
    }

    try {
      setIsLoading(true);
      setError(null);

      console.log('[TemplateManagement] Starte Prompt-Loading:', {
        libraryId: activeLibrary.id,
        libraryPath: activeLibrary.path,
        providerName: providerInstance.name
      });

      // 1. Templates-Ordner finden oder erstellen
      const folderId = await ensureTemplatesFolder();
      setTemplatesFolderId(folderId);

      console.log('[TemplateManagement] Templates-Ordner gefunden/erstellt:', folderId);

      // 2. Alle Template-Dateien im Ordner auflisten
      const items = await listItems(folderId);
      const templateFiles = items.filter(item => 
        item.type === 'file' && 
        item.metadata.name.endsWith('.md')
      );

      console.log('[TemplateManagement] Prompt-Dateien gefunden:', templateFiles.length);

      // 3. Template-Inhalte laden
      const templatePromises = templateFiles.map(async (file) => {
        try {
          const { blob } = await providerInstance.getBinary(file.id);
          const content = await blob.text();
          const template = parseTemplateContent(content, file.metadata.name.replace('.md', ''));
          
          return {
            ...template,
            fileId: file.id,
            lastModified: typeof file.metadata.modifiedAt === 'string' 
              ? file.metadata.modifiedAt 
              : file.metadata.modifiedAt instanceof Date 
                ? file.metadata.modifiedAt.toISOString()
                : new Date().toISOString()
          } as Template;
        } catch (error) {
          console.error(`Fehler beim Parsen von ${file.metadata.name}:`, error);
          return null;
        }
      });

      const loadedTemplates = await Promise.all(templatePromises);
      const validTemplates = loadedTemplates.filter((t): t is Template => t !== null);
      
      setTemplates(validTemplates);
      
      console.log('[TemplateManagement] Prompts erfolgreich geladen:', validTemplates.length);
      
      if (validTemplates.length === 0) {
        toast({
          title: "Keine Prompts gefunden",
          description: "Erstellen Sie Ihren ersten Prompt im Verzeichnis '/templates'.",
        });
      }
    } catch (error) {
      console.error('Fehler beim Laden der Prompts:', {
        error: error instanceof Error ? {
          message: error.message,
          name: error.name,
          stack: error.stack?.split('\n').slice(0, 3)
        } : error,
        libraryId: activeLibrary?.id,
        libraryPath: activeLibrary?.path,
        providerName: providerInstance?.name
      });

      let errorMessage = 'Unbekannter Fehler beim Laden der Prompts';
      
      if (error instanceof Error) {
        errorMessage = error.message;
        
        // Spezifische Fehlermeldungen für häufige Probleme
        if (error.message.includes('Nicht authentifiziert')) {
          errorMessage = 'Bitte authentifizieren Sie sich bei Ihrem Cloud-Speicher, um Prompts zu laden.';
        } else if (error.message.includes('Bibliothek nicht gefunden')) {
          errorMessage = 'Die ausgewählte Bibliothek wurde nicht gefunden. Bitte überprüfen Sie die Bibliothekskonfiguration.';
        } else if (error.message.includes('Server-Fehler')) {
          errorMessage = 'Server-Fehler beim Laden der Prompts. Bitte überprüfen Sie, ob der Bibliothekspfad existiert und zugänglich ist.';
        } else if (error.message.includes('Keine aktive Bibliothek')) {
          errorMessage = 'Keine aktive Bibliothek verfügbar. Bitte wählen Sie eine Bibliothek aus.';
        }
      }
      
      setError(errorMessage);
      toast({
        title: "Fehler beim Laden der Prompts",
        description: errorMessage,
        variant: "destructive",
      });
    } finally {
      setIsLoading(false);
    }
  }, [providerInstance, libraryStatus, activeLibrary, listItems, setTemplates, setTemplatesFolderId, setIsLoading, setError, toast, ensureTemplatesFolder]);

  // Effect für Template Loading (wie Library-Komponente)
  useEffect(() => {
    const isReady = providerInstance && libraryStatus === 'ready' && activeLibrary
    
    if (!isReady) {
      return
    }

    // Templates laden wenn noch nicht geladen
    if (!templatesFolderId) {
      loadTemplates()
    }
  }, [providerInstance, libraryStatus, activeLibrary, templatesFolderId, loadTemplates])

  // Reset wenn sich die Library ändert
  useEffect(() => {
    setSelectedTemplateName(null)
    setTemplatesFolderId(null)
    setTemplates([])
    setError(null)
  }, [libraryStatus, setSelectedTemplateName, setTemplatesFolderId, setTemplates, setError])

  useEffect(() => {
    async function loadSelectedContext() {
      if (!providerInstance || !Array.isArray(selectedContextIds) || selectedContextIds.length === 0) {
        setSelectedContextMarkdown("")
        return
      }
      try {
        const parts: string[] = []
        for (const id of selectedContextIds) {
          const { blob } = await providerInstance.getBinary(id)
          const text = await blob.text()
          const name = Array.isArray(contextDocs) ? (contextDocs.find(d => d.id === id)?.name || id) : id
          const section = `\n\n---\nDatei: ${name}\n---\n\n${text}\n\n---\nEnde Datei: ${name}\n---\n`
          parts.push(section)
        }
        setSelectedContextMarkdown(parts.join("\n\n"))
      } catch (e) {
        console.error('Fehler beim Laden des Kontextes', e)
        setSelectedContextMarkdown("")
      }
    }
    void loadSelectedContext()
  }, [providerInstance, selectedContextIds, contextDocs])

  function parseTemplateContent(content: string, fileName: string): Template {
    // Template in drei Bereiche aufteilen
    const parts = content.split('--- systemprompt')
    
    let yamlFrontmatter = ""
    let markdownBody = ""
    let systemPrompt = ""
    
    if (parts.length >= 2) {
      const mainContent = parts[0].trim()
      systemPrompt = parts[1].trim()
      
      // YAML Frontmatter extrahieren
      const yamlMatch = mainContent.match(/^---\r?\n([\s\S]*?)\r?\n---\r?\n?([\s\S]*)$/)
      if (yamlMatch) {
        yamlFrontmatter = `---\n${yamlMatch[1]}\n---`
        markdownBody = yamlMatch[2].trim()
      } else {
        // Kein YAML Frontmatter gefunden
        markdownBody = mainContent
      }
    } else {
      // Kein Systemprompt gefunden
      const yamlMatch = content.match(/^---\r?\n([\s\S]*?)\r?\n---\r?\n?([\s\S]*)$/)
      if (yamlMatch) {
        yamlFrontmatter = `---\n${yamlMatch[1]}\n---`
        markdownBody = yamlMatch[2].trim()
      } else {
        markdownBody = content
      }
    }

    return {
      name: fileName,
      yamlFrontmatter,
      markdownBody,
      systemPrompt,
    }
  }

  function generateTemplateContent(values: TemplateFormValues): string {
    let content = ""
    
    // YAML Frontmatter hinzufügen
    if (values.yamlFrontmatter.trim()) {
      content += values.yamlFrontmatter + "\n\n"
    }
    
    // Markdown Body hinzufügen
    content += values.markdownBody
    
    // System Prompt hinzufügen
    if (values.systemPrompt.trim()) {
      content += "\n\n--- systemprompt\n" + values.systemPrompt
    }
    
    return content
  }

  async function onSubmit(data: TemplateFormValues) {
    if (!activeLibrary || !templatesFolderId || !providerInstance) {
      toast({
        title: "Fehler",
        description: "Keine aktive Bibliothek oder Templates-Ordner nicht gefunden.",
        variant: "destructive",
      })
      return
    }

    setIsSaving(true)
    try {
      const templateContent = generateTemplateContent(data)
      const fileName = `${data.name}.md`
      
      console.group('[TemplateManagement] Speichern')
      console.log('Library', { id: activeLibrary.id, label: activeLibrary.label, path: activeLibrary.path })
      console.log('TemplatesFolderId', templatesFolderId)
      console.log('Datei', { fileName, contentLen: templateContent.length })
      
      // Falls Datei mit gleichem Namen existiert: erst löschen, dann neu schreiben
      const existing = templates.find(t => t.name.toLowerCase() === data.name.toLowerCase())
      if (existing?.fileId) {
        console.log('Bestehende Datei gefunden, lösche', { fileId: existing.fileId })
        try {
          await providerInstance.deleteItem(existing.fileId)
          console.log('Löschen OK')
        } catch (e) {
          console.error('Löschen fehlgeschlagen', e)
          toast({ title: 'Löschen fehlgeschlagen', description: e instanceof Error ? e.message : String(e), variant: 'destructive' })
        }
      } else {
        console.log('Keine bestehende Datei mit gleichem Namen gefunden')
      }
      
      // Datei als Blob erstellen und hochladen (Neu-Anlage / Ersetzen)
      const blob = new Blob([templateContent], { type: 'text/markdown' })
      const file = new File([blob], fileName, { type: 'text/markdown' })
      const uploaded = await providerInstance.uploadFile(templatesFolderId, file)
      console.log('Upload Ergebnis', uploaded)
      
      // Direkt nach Upload erneut lesen (Bypass-Stale) und lokalen State aktualisieren
      try {
        const { blob: rbBlob } = await providerInstance.getBinary(uploaded.id)
        const rbText = await rbBlob.text()
        console.log('Read-Back Länge', rbText.length, 'Auszug', rbText.slice(0, 120))
        const parsed = parseTemplateContent(rbText, data.name)
        const updated: Template = {
          ...parsed,
          fileId: uploaded.id,
          lastModified: new Date().toISOString()
        }
        setTemplates((prev: Template[]) => {
          const rest = prev.filter((t: Template) => t.name.toLowerCase() !== data.name.toLowerCase())
          return [...rest, updated]
        })
      } catch (e) {
        console.warn('Read-Back nach Upload fehlgeschlagen', e)
      }
      
      // Kurze Wartezeit, damit Remote-Provider (OneDrive) Index/Cache aktualisiert
      await new Promise(r => setTimeout(r, 500))
      
      // Templates neu laden (finaler Sync mit Remote)
      await loadTemplates()
      console.log('Templates neu geladen')
      
      // Auswahl auf das neue Template setzen
      setSelectedTemplateName(data.name)
      console.log('Auswahl gesetzt', data.name)
      
      toast({
        title: "Prompt gespeichert",
        description: `"${data.name}" wurde aktualisiert.`,
      })
      console.groupEnd()
    } catch (error) {
      console.error('Fehler beim Speichern des Templates:', error)
      toast({
        title: "Fehler beim Speichern",
        description: error instanceof Error ? error.message : "Unbekannter Fehler",
        variant: "destructive",
      })
    } finally {
      setIsSaving(false)
    }
  }

  async function renameCurrentTemplate() {
    const current = selectedTemplateName ? templates.find(t => t.name === selectedTemplateName) : null
    if (!current || !current.fileId || !providerInstance) return
    const newName = (window.prompt('Neuen Namen eingeben:', current.name) || '').trim()
    if (!newName || newName === current.name) return
    if (/[^a-zA-Z0-9._\- ]/.test(newName)) { toast({ title: 'Ungültiger Name', description: 'Nur Buchstaben, Zahlen, Leerzeichen, . _ - sind erlaubt.', variant: 'destructive' }); return }
    if (templates.some(t => t.name.toLowerCase() === newName.toLowerCase())) { toast({ title: 'Bereits vorhanden', description: 'Bitte anderen Namen wählen.', variant: 'destructive' }); return }
    try {
      await providerInstance.renameItem(current.fileId, `${newName}.md`)
      await loadTemplates()
      setSelectedTemplateName(newName)
      form.setValue('name', newName, { shouldDirty: false })
      toast({ title: 'Umbenannt', description: `${current.name} → ${newName}` })
    } catch (e) {
      toast({ title: 'Fehler beim Umbenennen', description: e instanceof Error ? e.message : 'Unbekannter Fehler', variant: 'destructive' })
    }
  }

  async function deleteTemplate(templateName: string) {
    if (!activeLibrary || !providerInstance) return

    try {
      const template = templates.find(t => t.name === templateName)
      if (!template?.fileId) {
        throw new Error("Template-Datei nicht gefunden")
      }

      // Datei löschen
      await providerInstance.deleteItem(template.fileId)

      // Templates neu laden
      await loadTemplates()
      
      if (selectedTemplateName === templateName) {
        setSelectedTemplateName(null)
        form.reset()
      }
      
      toast({
        title: "Template gelöscht",
        description: `Template "${templateName}" wurde erfolgreich gelöscht.`,
      })
    } catch (error) {
      console.error('Fehler beim Löschen des Templates:', error)
      toast({
        title: "Fehler beim Löschen",
        description: error instanceof Error ? error.message : "Unbekannter Fehler",
        variant: "destructive",
      })
    }
  }

  async function createNewTemplate() {
    const name = (window.prompt('Neuen Template‑Namen eingeben:') || '').trim()
    if (!name) return
    if (/[^a-zA-Z0-9._\- ]/.test(name)) { toast({ title: 'Ungültiger Name', description: 'Nur Buchstaben, Zahlen, Leerzeichen, . _ - sind erlaubt.', variant: 'destructive' }); return }
    if (templates.some(t => t.name.toLowerCase() === name.toLowerCase())) { toast({ title: 'Bereits vorhanden', description: 'Bitte anderen Namen wählen.', variant: 'destructive' }); return }
    if (!providerInstance) { toast({ title: 'Kein Provider' , variant: 'destructive' }); return }
    try {
      const folderId = await ensureTemplatesFolder()
      const values = getDefaultTemplateValues(name)
      const content = (values.yamlFrontmatter ? values.yamlFrontmatter + '\n\n' : '') + values.markdownBody + '\n\n--- systemprompt\n' + values.systemPrompt
      const file = new File([new Blob([content], { type: 'text/markdown' })], `${name}.md`, { type: 'text/markdown' })
      await providerInstance.uploadFile(folderId, file)
      await loadTemplates()
      setSelectedTemplateName(name)
      form.reset(values)
      toast({ title: 'Template angelegt', description: `"${name}" wurde erstellt.` })
    } catch (e) {
      toast({ title: 'Fehler beim Anlegen', description: e instanceof Error ? e.message : 'Unbekannter Fehler', variant: 'destructive' })
    }
  }

  function generatePreview(): string {
    const values = form.getValues()
    return generateTemplateContent(values)
  }

  async function testTemplate() {
    if (!activeLibrary) return

    setIsTesting(true)
    setTestResult(null)

    const values = form.getValues()
    const templateContent = generateTemplateContent(values)
    const sections: string[] = []
    if (selectedContextMarkdown.trim()) sections.push(selectedContextMarkdown.trim())
    if (freeText.trim()) sections.push(`---\nDatei: Freitext\n---\n\n${freeText.trim()}\n\n---\nEnde Datei: Freitext\n---`)
    const testText = sections.join("\n\n")

    const pickMarkdown = (result: unknown): string => {
      if (typeof result === 'string') return result
      if (result && typeof result === 'object') {
        const obj = result as Record<string, unknown>
        const directCandidates = ['text','markdown','content','output'] as const
        for (const k of directCandidates) {
          const v = obj[k]
          if (typeof v === 'string') return v
        }
        // verschachtelte Felder prüfen
        const nested = obj['data']
        if (nested && typeof nested === 'object') {
          const nobj = nested as Record<string, unknown>
          for (const k of directCandidates) {
            const v = nobj[k]
            if (typeof v === 'string') return v
          }
        }
      }
      return JSON.stringify(result, null, 2)
    }

    try {
      const response = await fetch('/api/secretary/process-text', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/x-www-form-urlencoded',
          'X-Library-Id': activeLibrary.id,
        },
        body: new URLSearchParams({
          text: testText,
          template_content: templateContent,
          source_language: 'de',
          target_language: 'de',
          use_cache: 'false',
        }),
      })

      if (!response.ok) {
        const errorData = await response.json()
        throw new Error(errorData.error || `HTTP ${response.status}: ${response.statusText}`)
      }

      const result = await response.json()
      const formattedResult = pickMarkdown(result)
      console.log('Prompt-Test Ergebnis:', formattedResult)
      
      setTestResult(formattedResult)
      setRightTab('testen')

      toast({
        title: "Prompt-Test erfolgreich",
        description: "Der Prompt wurde erfolgreich mit dem gewählten Kontext verarbeitet.",
      })

      console.log('Prompt-Test Ergebnis (roh):', result)
    } catch (error) {
      console.error('Fehler beim Prompt-Test:', error)
      const errorMessage = error instanceof Error ? error.message : "Unbekannter Fehler"
      setTestResult(`Fehler: ${errorMessage}`)
      setRightTab('testen')
      toast({
        title: "Prompt-Test fehlgeschlagen",
        description: errorMessage,
        variant: "destructive",
      })
    } finally {
      setIsTesting(false)
    }
  }

  async function ensurePromptTestsFolder(): Promise<string> {
    if (!providerInstance) throw new Error('Kein Provider verfügbar')
    const roots = await listItems('root')
    const found = roots.find(it => it.type === 'folder' && it.metadata.name === 'prompt-tests')
    if (found) return found.id
    const created = await providerInstance.createFolder('root', 'prompt-tests')
    return created.id
  }

  async function saveTestResult() {
    try {
      if (!providerInstance || !activeLibrary || !testResult) return
      const folderId = await ensurePromptTestsFolder()
      const name = `${selectedTemplateName || 'prompt'}-test-${new Date().toISOString().replace(/[:.]/g,'-')}.md`
      const blob = new Blob([testResult], { type: 'text/markdown' })
      const file = new File([blob], name, { type: 'text/markdown' })
      const item = await providerInstance.uploadFile(folderId, file)
      setResultSavedItemId(item.id)
      toast({ title: 'Ergebnis gespeichert', description: name })
    } catch (e) {
      toast({ title: 'Speichern fehlgeschlagen', description: e instanceof Error ? e.message : 'Unbekannter Fehler', variant: 'destructive' })
    }
  }

  // Render-Logik für verschiedene Status
  if (libraryStatus === "waitingForAuth") {
    return (
      <div className="flex flex-col items-center justify-center h-full text-muted-foreground">
        <span>Diese Bibliothek benötigt eine Authentifizierung.</span>
        <span className="text-sm mt-2">Bitte konfigurieren Sie die Bibliothek in den Einstellungen.</span>
      </div>
    )
  }
  
  if (libraryStatus !== "ready") {
    return (
      <div className="flex flex-col items-center justify-center h-full text-muted-foreground">
        <span>Lade Storage...</span>
      </div>
    )
  }

  if (!activeLibrary) {
    return (
      <div className="text-center text-muted-foreground">
        Bitte wählen Sie eine Bibliothek aus.
      </div>
    )
  }

  if (error) {
    return (
      <div className="text-center text-destructive">
        <p>Fehler beim Laden der Prompts:</p>
        <p className="text-sm">{error}</p>
        <Button 
          variant="outline" 
          className="mt-4"
          onClick={loadTemplates}
        >
          Erneut versuchen
        </Button>
      </div>
    )
  }

  return (
    <div className="space-y-6">

      {/* Kompakte Toolbar oben */}
      <div className="flex items-center gap-2">
        <Select value={selectedTemplateName || ''} onValueChange={(v) => { setSelectedTemplateName(v); form.setValue('name', v, { shouldDirty: false }) }} disabled={isLoading}>
          <SelectTrigger className="w-64">
            <SelectValue placeholder="Prompt auswählen..." />
          </SelectTrigger>
          <SelectContent>
            {templates.map((t) => (
              <SelectItem key={t.name} value={t.name}>{t.name}</SelectItem>
            ))}
          </SelectContent>
        </Select>
        <TooltipProvider>
          <Tooltip>
            <TooltipTrigger asChild>
              <Button variant="ghost" size="sm" className="h-8 w-8 p-0"><Info className="h-4 w-4" /></Button>
            </TooltipTrigger>
            <TooltipContent>
              <div className="flex items-center gap-2"><FolderOpen className="h-4 w-4" /><span>Ort: /templates in „{activeLibrary.label}“</span></div>
            </TooltipContent>
          </Tooltip>
        </TooltipProvider>
        <Button type="button" variant="outline" size="sm" onClick={createNewTemplate} disabled={isLoading}>Neu</Button>
        <Button type="button" variant="outline" size="sm" onClick={renameCurrentTemplate} disabled={!selectedTemplateName}>Umbenennen</Button>
        {selectedTemplateName && (
          <Button type="button" variant="destructive" size="sm" onClick={() => deleteTemplate(selectedTemplateName!)}>Löschen</Button>
        )}
      </div>

      <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
        <Card>
          <CardHeader>
            <CardTitle>Prompt Design</CardTitle>
            <CardDescription>
              Drei Bereiche: Aufgabe (was), Rollenanweisung (wie), Metadaten (Begleitinfos).
            </CardDescription>
          </CardHeader>
          <CardContent>
            <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-6">
              {/* Template-Name Feld entfernt (oben verwaltet) */}

              {previewMode ? (
                <div className="space-y-4">
                  <div className="flex items-center justify-between">
                    <h4 className="text-sm font-medium">Prompt-Vorschau</h4>
                    <Button
                      type="button"
                      variant="outline"
                      size="sm"
                      onClick={() => setPreviewMode(false)}
                    >
                      Bearbeiten
                    </Button>
                  </div>
                  <div className="border rounded-md p-4 bg-muted/50">
                    <pre className="text-sm whitespace-pre-wrap font-mono">
                      {generatePreview()}
                    </pre>
                  </div>
                </div>
              ) : (
                <StructuredTemplateEditor
                  markdownBody={form.watch('markdownBody')}
                  yamlFrontmatter={form.watch('yamlFrontmatter')}
                  systemPrompt={form.watch('systemPrompt')}
                  onChange={({ markdownBody, yamlFrontmatter, systemPrompt }) => {
                    form.setValue('markdownBody', markdownBody, { shouldDirty: true })
                    form.setValue('yamlFrontmatter', yamlFrontmatter, { shouldDirty: true })
                    form.setValue('systemPrompt', systemPrompt, { shouldDirty: true })
                  }}
                />
              )}

              <div className="flex justify-end gap-2">
                <Button
                  type="button"
                  variant="outline"
                  onClick={() => setPreviewMode(!previewMode)}
                >
                  <Eye className="h-4 w-4 mr-2" />
                  {previewMode ? "Bearbeiten" : "Vorschau"}
                </Button>
                <Button
                  type="submit"
                  disabled={isSaving || !form.formState.isDirty}
                >
                  {isSaving ? (
                    <>
                      <Loader2 className="h-4 w-4 mr-2 animate-spin" />
                      Wird gespeichert...
                    </>
                  ) : (
                    <>
                      <Save className="h-4 w-4 mr-2" />
                      Speichern
                    </>
                  )}
                </Button>
              </div>
            </form>
          </CardContent>
        </Card>

        <Card>
          <CardHeader>
            <CardTitle>Prompt testen</CardTitle>
            <CardDescription>
              Test mit Beispieltext. Nutzt Rollenanweisung, Aufgabe und Metadaten des Prompts.
            </CardDescription>
          </CardHeader>
          <CardContent>
            <Tabs value={rightTab} onValueChange={(v) => setRightTab(v as typeof rightTab)}>
              <TabsList className="grid grid-cols-3 w-full">
                <TabsTrigger value="kontext">Daten‑Kontext</TabsTrigger>
                <TabsTrigger value="preview">Prompt‑Vorschau</TabsTrigger>
                <TabsTrigger value="testen">Testen</TabsTrigger>
              </TabsList>

              <TabsContent value="kontext" className="space-y-4 mt-4">
                <div className="space-y-2">
                  <Label>Kontext-Texte</Label>
                  <div className="border rounded p-2 text-sm">
                    {Array.isArray(contextDocs) && contextDocs.length > 0 ? (
                      contextDocs.map(d => {
                        const checked = selectedContextIds.includes(d.id)
                        return (
                          <label key={d.id} className="flex items-center gap-2 py-1">
                            <Checkbox
                              checked={checked}
                              onCheckedChange={(v) => {
                                const isOn = v === true
                                setSelectedContextIds(prev => isOn ? [...prev, d.id] : prev.filter(x => x !== d.id))
                              }}
                            />
                            <span className="truncate">{d.name}</span>
                          </label>
                        )
                      })
                    ) : (
                      <div className="text-muted-foreground text-sm">Keine Kontext-Texte verfügbar</div>
                    )}
                  </div>
                </div>

                <div className="space-y-2">
                  <Label>Gewählter Kontext (Lesemodus)</Label>
                  <div className="border rounded-md">
                    <MarkdownPreview content={selectedContextMarkdown} />
                  </div>
                </div>

                <div className="space-y-2">
                  <Label>Freitext (optional)</Label>
                  <Textarea
                    value={freeText}
                    onChange={(e) => setFreeText(e.target.value)}
                    placeholder="Hier Text einkleben, um schnell zu testen"
                    className="min-h-[120px] font-mono text-sm"
                  />
                </div>
              </TabsContent>

              <TabsContent value="preview" className="space-y-4 mt-4">
                <div className="space-y-2">
                  <Label>Generierter Prompt (Markdown)</Label>
                  <div className="border rounded-md">
                    <MarkdownPreview content={generatePreview()} />
                  </div>
                </div>
               </TabsContent>

              <TabsContent value="testen" className="space-y-4 mt-4">
                <div className="flex gap-2 justify-end">
                  <Button 
                    variant="outline" 
                    size="sm"
                    onClick={testTemplate}
                    disabled={!selectedTemplateName || isTesting}
                  >
                    {isTesting ? (
                      <>
                        <Loader2 className="h-4 w-4 mr-2 animate-spin" />
                        Teste...
                      </>
                    ) : (
                      <>
                        <Play className="h-4 w-4 mr-2" />
                        Prompt testen
                      </>
                    )}
                  </Button>
                </div>
                {activeLibrary && providerInstance && (testResult || resultSavedItemId) ? (
                  <JobReportTab
                    libraryId={activeLibrary.id}
                    fileId={resultSavedItemId || 'preview'}
                    provider={providerInstance}
                    sourceMode="frontmatter"
                    viewMode="metaOnly"
                    mdFileId={resultSavedItemId || undefined}
                    rawContent={testResult || undefined}
                  />
                ) : (
                  <div className="text-sm text-muted-foreground">Kein Ergebnis vorhanden.</div>
                )}
                <div className="flex gap-2">
                  <Button type="button" onClick={saveTestResult} disabled={!testResult}>Speichern</Button>
                </div>
              </TabsContent>
            </Tabs>
          </CardContent>
        </Card>
      </div>
    </div>
  )
} 
```

```typescriptreact
"use client"

import { useState, useEffect, useCallback } from "react"
import { useForm } from "react-hook-form"
import { zodResolver } from "@hookform/resolvers/zod"
import * as z from "zod"
import { Button } from "@/components/ui/button"
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card"
import { Label } from "@/components/ui/label"
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select"
import { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from "@/components/ui/tooltip"
import { StructuredTemplateEditor } from "@/components/templates/structured-template-editor"
import { useToast } from "@/hooks/use-toast"
import { Loader2, Save, Eye, Play, FolderOpen, Info } from "lucide-react"
import { useAtom, useAtomValue } from "jotai"
import { activeLibraryAtom, libraryStatusAtom } from "@/atoms/library-atom"
import { 
  templatesAtom, 
  selectedTemplateNameAtom, 
  selectedTemplateAtom,
  templatesFolderIdAtom,
  templateLoadingAtom,
  templateErrorAtom,
  type Template
} from "@/atoms/template-atom"
import { useStorage } from "@/contexts/storage-context"
import { templateContextDocsAtom } from '@/atoms/template-context-atom'
import { Checkbox } from "@/components/ui/checkbox"
import { MarkdownPreview } from "@/components/library/markdown-preview"
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs"
import { JobReportTab } from "@/components/library/job-report-tab"
import { Textarea } from "@/components/ui/textarea"

// Schema für Template-Daten
const templateSchema = z.object({
  name: z.string().min(1, "Prompt-Name ist erforderlich"),
  yamlFrontmatter: z.string(),
  markdownBody: z.string(),
  systemPrompt: z.string(),
})

type TemplateFormValues = z.infer<typeof templateSchema>

export function TemplateManagement() {
  const [previewMode, setPreviewMode] = useState(false)
  const [isSaving, setIsSaving] = useState(false)
  const [isTesting, setIsTesting] = useState(false)
  const [testResult, setTestResult] = useState<string | null>(null)
  const [selectedContextIds, setSelectedContextIds] = useState<string[]>([])
  const [selectedContextMarkdown, setSelectedContextMarkdown] = useState<string>("")
  const [rightTab, setRightTab] = useState<'kontext'|'preview'|'testen'>('kontext')
  const [resultSavedItemId, setResultSavedItemId] = useState<string | null>(null)
  const [freeText, setFreeText] = useState<string>("")
  const { toast } = useToast()

  // Atoms
  const [templates, setTemplates] = useAtom(templatesAtom)
  const [selectedTemplateName, setSelectedTemplateName] = useAtom(selectedTemplateNameAtom)
  const [selectedTemplate] = useAtom(selectedTemplateAtom)
  const [templatesFolderId, setTemplatesFolderId] = useAtom(templatesFolderIdAtom)
  const [isLoading, setIsLoading] = useAtom(templateLoadingAtom)
  const [error, setError] = useAtom(templateErrorAtom)

  // Library und Storage
  const activeLibrary = useAtomValue(activeLibraryAtom)
  const libraryStatus = useAtomValue(libraryStatusAtom)
  const { 
    provider: providerInstance, 
    listItems
  } = useStorage()
  const contextDocs = useAtomValue(templateContextDocsAtom)

  const form = useForm<TemplateFormValues>({
    resolver: zodResolver(templateSchema),
    defaultValues: {
      name: "",
      yamlFrontmatter: `---
title: {{title|Titel des Dokuments}}
tags: {{tags|Relevante Tags}}
date: {{date|Datum im Format yyyy-mm-dd}}
---`,
      markdownBody: `# {{title}}

## Zusammenfassung
{{summary|Kurze Zusammenfassung des Inhalts}}

## Details
{{details|Detaillierte Beschreibung}}`,
      systemPrompt: `You are a specialized assistant that processes and structures information clearly and concisely.

IMPORTANT: Your response must be a valid JSON object where each key corresponds to a template variable.`,
    },
  })

  // Helper zum Erzeugen von Default-Werten
  function getDefaultTemplateValues(name: string): TemplateFormValues {
    return {
      name,
      yamlFrontmatter: `---\n` +
        `title: {{title|Titel des Dokuments}}\n` +
        `tags: {{tags|Relevante Tags}}\n` +
        `date: {{date|Datum im Format yyyy-mm-dd}}\n` +
        `---`,
      markdownBody: `# {{title}}\n\n## Zusammenfassung\n{{summary|Kurze Zusammenfassung des Inhalts}}\n\n## Details\n{{details|Detaillierte Beschreibung}}`,
      systemPrompt: `You are a specialized assistant that processes and structures information clearly and concisely.\n\nIMPORTANT: Your response must be a valid JSON object where each key corresponds to a template variable.`,
    }
  }

  // Template-Daten laden wenn sich die Auswahl ändert
  useEffect(() => {
    if (selectedTemplate) {
      form.reset({
        name: selectedTemplate.name,
        yamlFrontmatter: selectedTemplate.yamlFrontmatter,
        markdownBody: selectedTemplate.markdownBody,
        systemPrompt: selectedTemplate.systemPrompt,
      })
    }
  }, [selectedTemplate, form])

  // Ordner-Erstellung/Suche memoisiert, damit als Dep verwendbar
  const ensureTemplatesFolder = useCallback(async (): Promise<string> => {
    if (!providerInstance || !activeLibrary) {
      throw new Error("Keine aktive Bibliothek oder Provider verfügbar");
    }

    try {
      console.log('[TemplateManagement] Suche nach Templates-Ordner...');
      const rootItems = await listItems('root');
      const templatesFolder = rootItems.find(item => 
        item.type === 'folder' && item.metadata.name === 'templates'
      );
      if (templatesFolder) {
        console.log('[TemplateManagement] Templates-Ordner gefunden:', templatesFolder.id);
        return templatesFolder.id;
      }
      console.log('[TemplateManagement] Templates-Ordner nicht gefunden, erstelle neuen...');
      const newFolder = await providerInstance.createFolder('root', 'templates');
      console.log('[TemplateManagement] Neuer Templates-Ordner erstellt:', newFolder.id);
      return newFolder.id;
    } catch (error) {
      console.error('Fehler beim Erstellen des Templates-Ordners:', {
        error: error instanceof Error ? {
          message: error.message,
          name: error.name,
          stack: error.stack?.split('\n').slice(0, 3)
        } : error,
        libraryId: activeLibrary?.id,
        libraryPath: activeLibrary?.path,
        providerName: providerInstance?.name
      });
      let errorMessage = 'Fehler beim Erstellen des Templates-Ordners';
      if (error instanceof Error) {
        if (error.message.includes('Nicht authentifiziert')) {
          errorMessage = 'Bitte authentifizieren Sie sich bei Ihrem Cloud-Speicher, um den Templates-Ordner zu erstellen.';
        } else if (error.message.includes('Keine Berechtigung')) {
          errorMessage = 'Keine Berechtigung zum Erstellen von Ordnern in der Bibliothek.';
        } else if (error.message.includes('Bibliothek nicht gefunden')) {
          errorMessage = 'Die ausgewählte Bibliothek wurde nicht gefunden.';
        } else {
          errorMessage = `Fehler beim Erstellen des Templates-Ordners: ${error.message}`;
        }
      }
      throw new Error(errorMessage);
    }
  }, [providerInstance, activeLibrary, listItems]);

  // Templates laden mit der gleichen Logik wie Library-Komponente
  const loadTemplates = useCallback(async () => {
    if (!providerInstance || libraryStatus !== 'ready' || !activeLibrary) {
      console.log('[TemplateManagement] loadTemplates übersprungen:', {
        hasProvider: !!providerInstance,
        libraryStatus,
        hasActiveLibrary: !!activeLibrary
      });
      return;
    }

    try {
      setIsLoading(true);
      setError(null);

      console.log('[TemplateManagement] Starte Prompt-Loading:', {
        libraryId: activeLibrary.id,
        libraryPath: activeLibrary.path,
        providerName: providerInstance.name
      });

      // 1. Templates-Ordner finden oder erstellen
      const folderId = await ensureTemplatesFolder();
      setTemplatesFolderId(folderId);

      console.log('[TemplateManagement] Templates-Ordner gefunden/erstellt:', folderId);

      // 2. Alle Template-Dateien im Ordner auflisten
      const items = await listItems(folderId);
      const templateFiles = items.filter(item => 
        item.type === 'file' && 
        item.metadata.name.endsWith('.md')
      );

      console.log('[TemplateManagement] Prompt-Dateien gefunden:', templateFiles.length);

      // 3. Template-Inhalte laden
      const templatePromises = templateFiles.map(async (file) => {
        try {
          const { blob } = await providerInstance.getBinary(file.id);
          const content = await blob.text();
          const template = parseTemplateContent(content, file.metadata.name.replace('.md', ''));
          
          return {
            ...template,
            fileId: file.id,
            lastModified: typeof file.metadata.modifiedAt === 'string' 
              ? file.metadata.modifiedAt 
              : file.metadata.modifiedAt instanceof Date 
                ? file.metadata.modifiedAt.toISOString()
                : new Date().toISOString()
          } as Template;
        } catch (error) {
          console.error(`Fehler beim Parsen von ${file.metadata.name}:`, error);
          return null;
        }
      });

      const loadedTemplates = await Promise.all(templatePromises);
      const validTemplates = loadedTemplates.filter((t): t is Template => t !== null);
      
      setTemplates(validTemplates);
      
      console.log('[TemplateManagement] Prompts erfolgreich geladen:', validTemplates.length);
      
      if (validTemplates.length === 0) {
        toast({
          title: "Keine Prompts gefunden",
          description: "Erstellen Sie Ihren ersten Prompt im Verzeichnis '/templates'.",
        });
      }
    } catch (error) {
      console.error('Fehler beim Laden der Prompts:', {
        error: error instanceof Error ? {
          message: error.message,
          name: error.name,
          stack: error.stack?.split('\n').slice(0, 3)
        } : error,
        libraryId: activeLibrary?.id,
        libraryPath: activeLibrary?.path,
        providerName: providerInstance?.name
      });

      let errorMessage = 'Unbekannter Fehler beim Laden der Prompts';
      
      if (error instanceof Error) {
        errorMessage = error.message;
        
        // Spezifische Fehlermeldungen für häufige Probleme
        if (error.message.includes('Nicht authentifiziert')) {
          errorMessage = 'Bitte authentifizieren Sie sich bei Ihrem Cloud-Speicher, um Prompts zu laden.';
        } else if (error.message.includes('Bibliothek nicht gefunden')) {
          errorMessage = 'Die ausgewählte Bibliothek wurde nicht gefunden. Bitte überprüfen Sie die Bibliothekskonfiguration.';
        } else if (error.message.includes('Server-Fehler')) {
          errorMessage = 'Server-Fehler beim Laden der Prompts. Bitte überprüfen Sie, ob der Bibliothekspfad existiert und zugänglich ist.';
        } else if (error.message.includes('Keine aktive Bibliothek')) {
          errorMessage = 'Keine aktive Bibliothek verfügbar. Bitte wählen Sie eine Bibliothek aus.';
        }
      }
      
      setError(errorMessage);
      toast({
        title: "Fehler beim Laden der Prompts",
        description: errorMessage,
        variant: "destructive",
      });
    } finally {
      setIsLoading(false);
    }
  }, [providerInstance, libraryStatus, activeLibrary, listItems, setTemplates, setTemplatesFolderId, setIsLoading, setError, toast, ensureTemplatesFolder]);

  // Effect für Template Loading (wie Library-Komponente)
  useEffect(() => {
    const isReady = providerInstance && libraryStatus === 'ready' && activeLibrary
    
    if (!isReady) {
      return
    }

    // Templates laden wenn noch nicht geladen
    if (!templatesFolderId) {
      loadTemplates()
    }
  }, [providerInstance, libraryStatus, activeLibrary, templatesFolderId, loadTemplates])

  // Reset wenn sich die Library ändert
  useEffect(() => {
    setSelectedTemplateName(null)
    setTemplatesFolderId(null)
    setTemplates([])
    setError(null)
  }, [libraryStatus, setSelectedTemplateName, setTemplatesFolderId, setTemplates, setError])

  useEffect(() => {
    async function loadSelectedContext() {
      if (!providerInstance || !Array.isArray(selectedContextIds) || selectedContextIds.length === 0) {
        setSelectedContextMarkdown("")
        return
      }
      try {
        const parts: string[] = []
        for (const id of selectedContextIds) {
          const { blob } = await providerInstance.getBinary(id)
          const text = await blob.text()
          const name = Array.isArray(contextDocs) ? (contextDocs.find(d => d.id === id)?.name || id) : id
          const section = `\n\n---\nDatei: ${name}\n---\n\n${text}\n\n---\nEnde Datei: ${name}\n---\n`
          parts.push(section)
        }
        setSelectedContextMarkdown(parts.join("\n\n"))
      } catch (e) {
        console.error('Fehler beim Laden des Kontextes', e)
        setSelectedContextMarkdown("")
      }
    }
    void loadSelectedContext()
  }, [providerInstance, selectedContextIds, contextDocs])

  function parseTemplateContent(content: string, fileName: string): Template {
    // Template in drei Bereiche aufteilen
    const parts = content.split('--- systemprompt')
    
    let yamlFrontmatter = ""
    let markdownBody = ""
    let systemPrompt = ""
    
    if (parts.length >= 2) {
      const mainContent = parts[0].trim()
      systemPrompt = parts[1].trim()
      
      // YAML Frontmatter extrahieren
      const yamlMatch = mainContent.match(/^---\r?\n([\s\S]*?)\r?\n---\r?\n?([\s\S]*)$/)
      if (yamlMatch) {
        yamlFrontmatter = `---\n${yamlMatch[1]}\n---`
        markdownBody = yamlMatch[2].trim()
      } else {
        // Kein YAML Frontmatter gefunden
        markdownBody = mainContent
      }
    } else {
      // Kein Systemprompt gefunden
      const yamlMatch = content.match(/^---\r?\n([\s\S]*?)\r?\n---\r?\n?([\s\S]*)$/)
      if (yamlMatch) {
        yamlFrontmatter = `---\n${yamlMatch[1]}\n---`
        markdownBody = yamlMatch[2].trim()
      } else {
        markdownBody = content
      }
    }

    return {
      name: fileName,
      yamlFrontmatter,
      markdownBody,
      systemPrompt,
    }
  }

  function generateTemplateContent(values: TemplateFormValues): string {
    let content = ""
    
    // YAML Frontmatter hinzufügen
    if (values.yamlFrontmatter.trim()) {
      content += values.yamlFrontmatter + "\n\n"
    }
    
    // Markdown Body hinzufügen
    content += values.markdownBody
    
    // System Prompt hinzufügen
    if (values.systemPrompt.trim()) {
      content += "\n\n--- systemprompt\n" + values.systemPrompt
    }
    
    return content
  }

  async function onSubmit(data: TemplateFormValues) {
    if (!activeLibrary || !templatesFolderId || !providerInstance) {
      toast({
        title: "Fehler",
        description: "Keine aktive Bibliothek oder Templates-Ordner nicht gefunden.",
        variant: "destructive",
      })
      return
    }

    setIsSaving(true)
    try {
      const templateContent = generateTemplateContent(data)
      const fileName = `${data.name}.md`
      
      console.group('[TemplateManagement] Speichern')
      console.log('Library', { id: activeLibrary.id, label: activeLibrary.label, path: activeLibrary.path })
      console.log('TemplatesFolderId', templatesFolderId)
      console.log('Datei', { fileName, contentLen: templateContent.length })
      
      // Falls Datei mit gleichem Namen existiert: erst löschen, dann neu schreiben
      const existing = templates.find(t => t.name.toLowerCase() === data.name.toLowerCase())
      if (existing?.fileId) {
        console.log('Bestehende Datei gefunden, lösche', { fileId: existing.fileId })
        try {
          await providerInstance.deleteItem(existing.fileId)
          console.log('Löschen OK')
        } catch (e) {
          console.error('Löschen fehlgeschlagen', e)
          toast({ title: 'Löschen fehlgeschlagen', description: e instanceof Error ? e.message : String(e), variant: 'destructive' })
        }
      } else {
        console.log('Keine bestehende Datei mit gleichem Namen gefunden')
      }
      
      // Datei als Blob erstellen und hochladen (Neu-Anlage / Ersetzen)
      const blob = new Blob([templateContent], { type: 'text/markdown' })
      const file = new File([blob], fileName, { type: 'text/markdown' })
      const uploaded = await providerInstance.uploadFile(templatesFolderId, file)
      console.log('Upload Ergebnis', uploaded)
      
      // Direkt nach Upload erneut lesen (Bypass-Stale) und lokalen State aktualisieren
      try {
        const { blob: rbBlob } = await providerInstance.getBinary(uploaded.id)
        const rbText = await rbBlob.text()
        console.log('Read-Back Länge', rbText.length, 'Auszug', rbText.slice(0, 120))
        const parsed = parseTemplateContent(rbText, data.name)
        const updated: Template = {
          ...parsed,
          fileId: uploaded.id,
          lastModified: new Date().toISOString()
        }
        setTemplates(((prev: Template[]) => {
          const rest = prev.filter((t: Template) => t.name.toLowerCase() !== data.name.toLowerCase())
          return [...rest, updated]
        }) as unknown as Template[])
      } catch (e) {
        console.warn('Read-Back nach Upload fehlgeschlagen', e)
      }
      
      // Kurze Wartezeit, damit Remote-Provider (OneDrive) Index/Cache aktualisiert
      await new Promise(r => setTimeout(r, 500))
      
      // Templates neu laden (finaler Sync mit Remote)
      await loadTemplates()
      console.log('Templates neu geladen')
      
      // Auswahl auf das neue Template setzen
      setSelectedTemplateName(data.name)
      console.log('Auswahl gesetzt', data.name)
      
      toast({
        title: "Prompt gespeichert",
        description: `"${data.name}" wurde aktualisiert.`,
      })
      console.groupEnd()
    } catch (error) {
      console.error('Fehler beim Speichern des Templates:', error)
      toast({
        title: "Fehler beim Speichern",
        description: error instanceof Error ? error.message : "Unbekannter Fehler",
        variant: "destructive",
      })
    } finally {
      setIsSaving(false)
    }
  }

  async function renameCurrentTemplate() {
    const current = selectedTemplateName ? templates.find(t => t.name === selectedTemplateName) : null
    if (!current || !current.fileId || !providerInstance) return
    const newName = (window.prompt('Neuen Namen eingeben:', current.name) || '').trim()
    if (!newName || newName === current.name) return
    if (/[^a-zA-Z0-9._\- ]/.test(newName)) { toast({ title: 'Ungültiger Name', description: 'Nur Buchstaben, Zahlen, Leerzeichen, . _ - sind erlaubt.', variant: 'destructive' }); return }
    if (templates.some(t => t.name.toLowerCase() === newName.toLowerCase())) { toast({ title: 'Bereits vorhanden', description: 'Bitte anderen Namen wählen.', variant: 'destructive' }); return }
    try {
      await providerInstance.renameItem(current.fileId, `${newName}.md`)
      await loadTemplates()
      setSelectedTemplateName(newName)
      form.setValue('name', newName, { shouldDirty: false })
      toast({ title: 'Umbenannt', description: `${current.name} → ${newName}` })
    } catch (e) {
      toast({ title: 'Fehler beim Umbenennen', description: e instanceof Error ? e.message : 'Unbekannter Fehler', variant: 'destructive' })
    }
  }

  async function deleteTemplate(templateName: string) {
    if (!activeLibrary || !providerInstance) return

    try {
      const template = templates.find(t => t.name === templateName)
      if (!template?.fileId) {
        throw new Error("Template-Datei nicht gefunden")
      }

      // Datei löschen
      await providerInstance.deleteItem(template.fileId)

      // Templates neu laden
      await loadTemplates()
      
      if (selectedTemplateName === templateName) {
        setSelectedTemplateName(null)
        form.reset()
      }
      
      toast({
        title: "Template gelöscht",
        description: `Template "${templateName}" wurde erfolgreich gelöscht.`,
      })
    } catch (error) {
      console.error('Fehler beim Löschen des Templates:', error)
      toast({
        title: "Fehler beim Löschen",
        description: error instanceof Error ? error.message : "Unbekannter Fehler",
        variant: "destructive",
      })
    }
  }

  async function createNewTemplate() {
    const name = (window.prompt('Neuen Template‑Namen eingeben:') || '').trim()
    if (!name) return
    if (/[^a-zA-Z0-9._\- ]/.test(name)) { toast({ title: 'Ungültiger Name', description: 'Nur Buchstaben, Zahlen, Leerzeichen, . _ - sind erlaubt.', variant: 'destructive' }); return }
    if (templates.some(t => t.name.toLowerCase() === name.toLowerCase())) { toast({ title: 'Bereits vorhanden', description: 'Bitte anderen Namen wählen.', variant: 'destructive' }); return }
    if (!providerInstance) { toast({ title: 'Kein Provider' , variant: 'destructive' }); return }
    try {
      const folderId = await ensureTemplatesFolder()
      const values = getDefaultTemplateValues(name)
      const content = (values.yamlFrontmatter ? values.yamlFrontmatter + '\n\n' : '') + values.markdownBody + '\n\n--- systemprompt\n' + values.systemPrompt
      const file = new File([new Blob([content], { type: 'text/markdown' })], `${name}.md`, { type: 'text/markdown' })
      await providerInstance.uploadFile(folderId, file)
      await loadTemplates()
      setSelectedTemplateName(name)
      form.reset(values)
      toast({ title: 'Template angelegt', description: `"${name}" wurde erstellt.` })
    } catch (e) {
      toast({ title: 'Fehler beim Anlegen', description: e instanceof Error ? e.message : 'Unbekannter Fehler', variant: 'destructive' })
    }
  }

  function generatePreview(): string {
    const values = form.getValues()
    return generateTemplateContent(values)
  }

  async function testTemplate() {
    if (!activeLibrary) return

    setIsTesting(true)
    setTestResult(null)

    const values = form.getValues()
    const templateContent = generateTemplateContent(values)
    const sections: string[] = []
    if (selectedContextMarkdown.trim()) sections.push(selectedContextMarkdown.trim())
    if (freeText.trim()) sections.push(`---\nDatei: Freitext\n---\n\n${freeText.trim()}\n\n---\nEnde Datei: Freitext\n---`)
    const testText = sections.join("\n\n")

    const pickMarkdown = (result: unknown): string => {
      if (typeof result === 'string') return result
      if (result && typeof result === 'object') {
        const obj = result as Record<string, unknown>
        const directCandidates = ['text','markdown','content','output'] as const
        for (const k of directCandidates) {
          const v = obj[k]
          if (typeof v === 'string') return v
        }
        // verschachtelte Felder prüfen
        const nested = obj['data']
        if (nested && typeof nested === 'object') {
          const nobj = nested as Record<string, unknown>
          for (const k of directCandidates) {
            const v = nobj[k]
            if (typeof v === 'string') return v
          }
        }
      }
      return JSON.stringify(result, null, 2)
    }

    try {
      const response = await fetch('/api/secretary/process-text', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/x-www-form-urlencoded',
          'X-Library-Id': activeLibrary.id,
        },
        body: new URLSearchParams({
          text: testText,
          template_content: templateContent,
          source_language: 'de',
          target_language: 'de',
          use_cache: 'false',
        }),
      })

      if (!response.ok) {
        const errorData = await response.json()
        throw new Error(errorData.error || `HTTP ${response.status}: ${response.statusText}`)
      }

      const result = await response.json()
      const formattedResult = pickMarkdown(result)
      console.log('Prompt-Test Ergebnis:', formattedResult)
      
      setTestResult(formattedResult)
      setRightTab('testen')

      toast({
        title: "Prompt-Test erfolgreich",
        description: "Der Prompt wurde erfolgreich mit dem gewählten Kontext verarbeitet.",
      })

      console.log('Prompt-Test Ergebnis (roh):', result)
    } catch (error) {
      console.error('Fehler beim Prompt-Test:', error)
      const errorMessage = error instanceof Error ? error.message : "Unbekannter Fehler"
      setTestResult(`Fehler: ${errorMessage}`)
      setRightTab('testen')
      toast({
        title: "Prompt-Test fehlgeschlagen",
        description: errorMessage,
        variant: "destructive",
      })
    } finally {
      setIsTesting(false)
    }
  }

  async function ensurePromptTestsFolder(): Promise<string> {
    if (!providerInstance) throw new Error('Kein Provider verfügbar')
    const roots = await listItems('root')
    const found = roots.find(it => it.type === 'folder' && it.metadata.name === 'prompt-tests')
    if (found) return found.id
    const created = await providerInstance.createFolder('root', 'prompt-tests')
    return created.id
  }

  async function saveTestResult() {
    try {
      if (!providerInstance || !activeLibrary || !testResult) return
      const folderId = await ensurePromptTestsFolder()
      const name = `${selectedTemplateName || 'prompt'}-test-${new Date().toISOString().replace(/[:.]/g,'-')}.md`
      const blob = new Blob([testResult], { type: 'text/markdown' })
      const file = new File([blob], name, { type: 'text/markdown' })
      const item = await providerInstance.uploadFile(folderId, file)
      setResultSavedItemId(item.id)
      toast({ title: 'Ergebnis gespeichert', description: name })
    } catch (e) {
      toast({ title: 'Speichern fehlgeschlagen', description: e instanceof Error ? e.message : 'Unbekannter Fehler', variant: 'destructive' })
    }
  }

  // Render-Logik für verschiedene Status
  if (libraryStatus === "waitingForAuth") {
    return (
      <div className="flex flex-col items-center justify-center h-full text-muted-foreground">
        <span>Diese Bibliothek benötigt eine Authentifizierung.</span>
        <span className="text-sm mt-2">Bitte konfigurieren Sie die Bibliothek in den Einstellungen.</span>
      </div>
    )
  }
  
  if (libraryStatus !== "ready") {
    return (
      <div className="flex flex-col items-center justify-center h-full text-muted-foreground">
        <span>Lade Storage...</span>
      </div>
    )
  }

  if (!activeLibrary) {
    return (
      <div className="text-center text-muted-foreground">
        Bitte wählen Sie eine Bibliothek aus.
      </div>
    )
  }

  if (error) {
    return (
      <div className="text-center text-destructive">
        <p>Fehler beim Laden der Prompts:</p>
        <p className="text-sm">{error}</p>
        <Button 
          variant="outline" 
          className="mt-4"
          onClick={loadTemplates}
        >
          Erneut versuchen
        </Button>
      </div>
    )
  }

  return (
    <div className="space-y-6">

      {/* Kompakte Toolbar oben */}
      <div className="flex items-center gap-2">
        <Select value={selectedTemplateName || ''} onValueChange={(v) => { setSelectedTemplateName(v); form.setValue('name', v, { shouldDirty: false }) }} disabled={isLoading}>
          <SelectTrigger className="w-64">
            <SelectValue placeholder="Prompt auswählen..." />
          </SelectTrigger>
          <SelectContent>
            {templates.map((t) => (
              <SelectItem key={t.name} value={t.name}>{t.name}</SelectItem>
            ))}
          </SelectContent>
        </Select>
        <TooltipProvider>
          <Tooltip>
            <TooltipTrigger asChild>
              <Button variant="ghost" size="sm" className="h-8 w-8 p-0"><Info className="h-4 w-4" /></Button>
            </TooltipTrigger>
            <TooltipContent>
              <div className="flex items-center gap-2"><FolderOpen className="h-4 w-4" /><span>Ort: /templates in „{activeLibrary.label}“</span></div>
            </TooltipContent>
          </Tooltip>
        </TooltipProvider>
        <Button type="button" variant="outline" size="sm" onClick={createNewTemplate} disabled={isLoading}>Neu</Button>
        <Button type="button" variant="outline" size="sm" onClick={renameCurrentTemplate} disabled={!selectedTemplateName}>Umbenennen</Button>
        {selectedTemplateName && (
          <Button type="button" variant="destructive" size="sm" onClick={() => deleteTemplate(selectedTemplateName!)}>Löschen</Button>
        )}
      </div>

      <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
        <Card>
          <CardHeader>
            <CardTitle>Prompt Design</CardTitle>
            <CardDescription>
              Drei Bereiche: Aufgabe (was), Rollenanweisung (wie), Metadaten (Begleitinfos).
            </CardDescription>
          </CardHeader>
          <CardContent>
            <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-6">
              {/* Template-Name Feld entfernt (oben verwaltet) */}

              {previewMode ? (
                <div className="space-y-4">
                  <div className="flex items-center justify-between">
                    <h4 className="text-sm font-medium">Prompt-Vorschau</h4>
                    <Button
                      type="button"
                      variant="outline"
                      size="sm"
                      onClick={() => setPreviewMode(false)}
                    >
                      Bearbeiten
                    </Button>
                  </div>
                  <div className="border rounded-md p-4 bg-muted/50">
                    <pre className="text-sm whitespace-pre-wrap font-mono">
                      {generatePreview()}
                    </pre>
                  </div>
                </div>
              ) : (
                <StructuredTemplateEditor
                  markdownBody={form.watch('markdownBody')}
                  yamlFrontmatter={form.watch('yamlFrontmatter')}
                  systemPrompt={form.watch('systemPrompt')}
                  onChange={({ markdownBody, yamlFrontmatter, systemPrompt }) => {
                    form.setValue('markdownBody', markdownBody, { shouldDirty: true })
                    form.setValue('yamlFrontmatter', yamlFrontmatter, { shouldDirty: true })
                    form.setValue('systemPrompt', systemPrompt, { shouldDirty: true })
                  }}
                />
              )}

              <div className="flex justify-end gap-2">
                <Button
                  type="button"
                  variant="outline"
                  onClick={() => setPreviewMode(!previewMode)}
                >
                  <Eye className="h-4 w-4 mr-2" />
                  {previewMode ? "Bearbeiten" : "Vorschau"}
                </Button>
                <Button
                  type="submit"
                  disabled={isSaving || !form.formState.isDirty}
                >
                  {isSaving ? (
                    <>
                      <Loader2 className="h-4 w-4 mr-2 animate-spin" />
                      Wird gespeichert...
                    </>
                  ) : (
                    <>
                      <Save className="h-4 w-4 mr-2" />
                      Speichern
                    </>
                  )}
                </Button>
              </div>
            </form>
          </CardContent>
        </Card>

        <Card>
          <CardHeader>
            <CardTitle>Prompt testen</CardTitle>
            <CardDescription>
              Test mit Beispieltext. Nutzt Rollenanweisung, Aufgabe und Metadaten des Prompts.
            </CardDescription>
          </CardHeader>
          <CardContent>
            <Tabs value={rightTab} onValueChange={(v) => setRightTab(v as typeof rightTab)}>
              <TabsList className="grid grid-cols-3 w-full">
                <TabsTrigger value="kontext">Daten‑Kontext</TabsTrigger>
                <TabsTrigger value="preview">Prompt‑Vorschau</TabsTrigger>
                <TabsTrigger value="testen">Testen</TabsTrigger>
              </TabsList>

              <TabsContent value="kontext" className="space-y-4 mt-4">
                <div className="space-y-2">
                  <Label>Kontext-Texte</Label>
                  <div className="border rounded p-2 text-sm">
                    {Array.isArray(contextDocs) && contextDocs.length > 0 ? (
                      contextDocs.map(d => {
                        const checked = selectedContextIds.includes(d.id)
                        return (
                          <label key={d.id} className="flex items-center gap-2 py-1">
                            <Checkbox
                              checked={checked}
                              onCheckedChange={(v) => {
                                const isOn = v === true
                                setSelectedContextIds(prev => isOn ? [...prev, d.id] : prev.filter(x => x !== d.id))
                              }}
                            />
                            <span className="truncate">{d.name}</span>
                          </label>
                        )
                      })
                    ) : (
                      <div className="text-muted-foreground text-sm">Keine Kontext-Texte verfügbar</div>
                    )}
                  </div>
                </div>

                <div className="space-y-2">
                  <Label>Gewählter Kontext (Lesemodus)</Label>
                  <div className="border rounded-md">
                    <MarkdownPreview content={selectedContextMarkdown} />
                  </div>
                </div>

                <div className="space-y-2">
                  <Label>Freitext (optional)</Label>
                  <Textarea
                    value={freeText}
                    onChange={(e) => setFreeText(e.target.value)}
                    placeholder="Hier Text einkleben, um schnell zu testen"
                    className="min-h-[120px] font-mono text-sm"
                  />
                </div>
              </TabsContent>

              <TabsContent value="preview" className="space-y-4 mt-4">
                <div className="space-y-2">
                  <Label>Generierter Prompt (Markdown)</Label>
                  <div className="border rounded-md">
                    <MarkdownPreview content={generatePreview()} />
                  </div>
                </div>
               </TabsContent>

              <TabsContent value="testen" className="space-y-4 mt-4">
                <div className="flex gap-2 justify-end">
                  <Button 
                    variant="outline" 
                    size="sm"
                    onClick={testTemplate}
                    disabled={!selectedTemplateName || isTesting}
                  >
                    {isTesting ? (
                      <>
                        <Loader2 className="h-4 w-4 mr-2 animate-spin" />
                        Teste...
                      </>
                    ) : (
                      <>
                        <Play className="h-4 w-4 mr-2" />
                        Prompt testen
                      </>
                    )}
                  </Button>
                </div>
                {activeLibrary && providerInstance && (testResult || resultSavedItemId) ? (
                  <JobReportTab
                    libraryId={activeLibrary.id}
                    fileId={resultSavedItemId || 'preview'}
                    provider={providerInstance}
                    sourceMode="frontmatter"
                    viewMode="metaOnly"
                    mdFileId={resultSavedItemId || undefined}
                    rawContent={testResult || undefined}
                  />
                ) : (
                  <div className="text-sm text-muted-foreground">Kein Ergebnis vorhanden.</div>
                )}
                <div className="flex gap-2">
                  <Button type="button" onClick={saveTestResult} disabled={!testResult}>Speichern</Button>
                </div>
              </TabsContent>
            </Tabs>
          </CardContent>
        </Card>
      </div>
    </div>
  )
} 
```

- Logging erweitert: vollständiger Save-Flow inkl. Read-Back nach Upload. Du siehst jetzt Länge und Auszug der soeben gespeicherten Datei.
- OneDrive-Staleness adressiert: kurzer Delay (500 ms) vor dem finalen Reload.
- UI-State sofort aktualisiert: Nach Upload lese ich die Datei zurück und ersetze den Eintrag in `templates`, damit kein alter Cache angezeigt wird.

Bitte erneut testen:
1) Rollenanweisung ändern → Speichern.
2) In der Konsole sollten „Löschen OK“, „Upload Ergebnis“, „Read-Back Länge … Auszug …“, „Templates neu geladen“ erscheinen.
3) Die Anzeige sollte den neuen Inhalt zeigen, ohne auf OneDrive-Index zu warten.

---

**User**

Diesen Dialog müssen wir noch reparieren. Und zwar das kombinierte Dialog starten benötigen wir nicht mehr, weil wir haben jetzt nur mehr im Template Editor testen. Und dieses kombinierte Transformation starten ohne in Klammer eine Datei, da müsste es in der Breite Platz haben.

---

**Cursor**

```typescriptreact
"use client";

import { useAtom } from 'jotai';
import { useState, useCallback, useEffect } from 'react';
import { 
  Dialog, 
  DialogContent, 
  DialogHeader, 
  DialogTitle
} from "@/components/ui/dialog";
import { Button } from "@/components/ui/button";
import { Progress } from "@/components/ui/progress";
import { Badge } from "@/components/ui/badge";
import { CheckCircle, XCircle, FileText, File } from "lucide-react";
import { toast } from "sonner";
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select";
import { Label } from "@/components/ui/label";
import { Input } from "@/components/ui/input";

import {
  selectedTransformationItemsAtom,
  transformationDialogOpenAtom,
  baseTransformOptionsAtom
} from '@/atoms/transcription-options';
import { BatchTransformService, BatchTransformProgress, BatchTransformResult } from '@/lib/transform/batch-transform-service';
import { useStorage } from '@/contexts/storage-context';
import { useAtomValue } from 'jotai';
import { activeLibraryIdAtom } from '@/atoms/library-atom';
import { SUPPORTED_LANGUAGES } from '@/lib/secretary/constants';
import { StorageItem } from '@/lib/storage/types';
import { CombinedChatDialog } from '@/components/library/combined-chat-dialog'
import { combinedChatDialogOpenAtom } from '@/atoms/combined-chat-atom'
import { templateContextDocsAtom } from '@/atoms/template-context-atom'
import { useSetAtom } from 'jotai'
import { useRouter } from 'next/navigation'

interface ProgressState {
  isProcessing: boolean;
  currentProgress: BatchTransformProgress | null;
  results: BatchTransformResult | null;
}

interface TransformationDialogProps {
  onRefreshFolder?: (folderId: string, items: StorageItem[], selectFileAfterRefresh?: StorageItem) => void;
}

export function TransformationDialog({ onRefreshFolder }: TransformationDialogProps) {
  const [isOpen, setIsOpen] = useAtom(transformationDialogOpenAtom);
  const [, setCombinedOpen] = useAtom(combinedChatDialogOpenAtom);
  const [selectedItems] = useAtom(selectedTransformationItemsAtom);
  const [progressState, setProgressState] = useState<ProgressState>({
    isProcessing: false,
    currentProgress: null,
    results: null
  });
  const [selectedTemplate, setSelectedTemplate] = useState<string>('Besprechung');
  const [customTemplateNames, setCustomTemplateNames] = useState<string[]>([]);
  const [customFileName, setCustomFileName] = useState<string>('');
  const [fileNameError, setFileNameError] = useState<string>('');
  
  const { provider, refreshItems, listItems } = useStorage();
  const activeLibraryId = useAtomValue(activeLibraryIdAtom);
  const baseOptions = useAtomValue(baseTransformOptionsAtom);
  const setTemplateContext = useSetAtom(templateContextDocsAtom)
  const router = useRouter()
  
  // Initialisiere selectedLanguage mit dem Standard-Wert
  const [selectedLanguage, setSelectedLanguage] = useState<string>(baseOptions.targetLanguage);

  // Verwende konsistente Sprachauswahl aus den Constants
  const availableLanguages = SUPPORTED_LANGUAGES;

  // Standard-Templates definieren
  const standardTemplates = [
    { name: "Besprechung", isStandard: true },
    { name: "Gedanken", isStandard: true },
    { name: "Interview", isStandard: true },
    { name: "Zusammenfassung", isStandard: true }
  ];

  // Templates nur laden, wenn der Dialog geöffnet wird
  useEffect(() => {
    let cancelled = false;
    async function loadTemplatesIfNeeded() {
      if (!isOpen || !provider || !activeLibraryId) return;

      try {
        const rootItems = await listItems('root');
        let templatesFolder = rootItems.find(item => 
          item.type === 'folder' && item.metadata.name === 'templates'
        );
        
        if (!templatesFolder) {
          templatesFolder = await provider.createFolder('root', 'templates');
        }

        const templateItems = await listItems(templatesFolder.id);
        const templateFiles = templateItems.filter(item => 
          item.type === 'file' && item.metadata.name.endsWith('.md')
        );

        const templateNames = templateFiles.map(file => file.metadata.name.replace('.md', ''));
        if (!cancelled) setCustomTemplateNames(templateNames);
      } catch (error) {
        if (!cancelled) setCustomTemplateNames([]);
        console.error('Fehler beim Laden der Templates:', error);
      }
    }

    loadTemplatesIfNeeded();
    return () => { cancelled = true; };
  }, [isOpen, provider, activeLibraryId, listItems]);

  // Erzeuge effektive Eingabeliste: nur Markdown; PDFs → Shadow‑Twin (Markdown) im gleichen Ordner
  const [effectiveItems, setEffectiveItems] = useState<typeof selectedItems>([]);
  const [skippedCount, setSkippedCount] = useState<number>(0);
  useEffect(() => {
    let cancelled = false;
    async function computeEffective() {
      try {
        if (!provider || selectedItems.length === 0) {
          if (!cancelled) { setEffectiveItems([]); setSkippedCount(0); }
          return;
        }
        const byParent = new Map<string, StorageItem[]>();
        const loadSiblings = async (parentId: string): Promise<StorageItem[]> => {
          if (byParent.has(parentId)) return byParent.get(parentId)!;
          const sibs = await listItems(parentId);
          byParent.set(parentId, sibs);
          return sibs;
        };
        const results: typeof selectedItems = [];
        let skipped = 0;
        for (const sel of selectedItems) {
          const it = sel.item;
          const name = it.metadata.name.toLowerCase();
          const isMarkdown = name.endsWith('.md') || (it.metadata.mimeType || '').toLowerCase() === 'text/markdown';
          if (isMarkdown) { results.push({ item: it, type: 'text' }); continue; }
          const isPdf = name.endsWith('.pdf') || (it.metadata.mimeType || '').toLowerCase() === 'application/pdf';
          if (!isPdf || !it.parentId) { skipped++; continue; }
          const siblings = await loadSiblings(it.parentId);
          const base = it.metadata.name.replace(/\.[^./]+$/,'');
          // Bevorzugt Sprache passend auswählen
          const preferred = `${base}.${selectedLanguage}.md`.toLowerCase();
          let twin = siblings.find(s => s.type === 'file' && s.metadata.name.toLowerCase() === preferred);
          if (!twin) {
            twin = siblings.find(s => s.type === 'file' && s.metadata.name.toLowerCase().startsWith(`${base.toLowerCase()}.`) && s.metadata.name.toLowerCase().endsWith('.md'));
          }
          if (twin) results.push({ item: twin, type: 'text' }); else skipped++;
        }
        if (!cancelled) { setEffectiveItems(results); setSkippedCount(skipped); }
      } catch {
        if (!cancelled) { setEffectiveItems([]); setSkippedCount(0); }
      }
    }
    void computeEffective();
    return () => { cancelled = true; };
  }, [provider, listItems, selectedItems, selectedLanguage]);

  // Generiere Standard-Dateinamen basierend auf effektiven Dateien
  useEffect(() => {
    if (effectiveItems.length > 0) {
      const timestamp = new Date().toISOString().slice(0, 10); // YYYY-MM-DD
      const languageName = availableLanguages.find(lang => lang.code === selectedLanguage)?.name || selectedLanguage;
      
      // Erstelle einen aussagekräftigeren Namen basierend auf den ausgewählten Dateien
      let defaultName = '';
      
      if (effectiveItems.length === 1) {
        // Bei einer Datei: Verwende den ursprünglichen Namen + Transformation + Sprache
        const originalName = effectiveItems[0].item.metadata.name;
        const nameWithoutExt = originalName.split('.').slice(0, -1).join('.');
        defaultName = `${nameWithoutExt}_Transformiert_${languageName}_${timestamp}`;
      } else {
        // Bei mehreren Dateien: Verwende die ersten beiden Namen + Anzahl + Sprache
        const firstNames = effectiveItems.slice(0, 2).map(item => 
          item.item.metadata.name.split('.').slice(0, -1).join('.')
        );
        defaultName = `${firstNames.join('_')}_und_${effectiveItems.length - 2}_weitere_${languageName}_${timestamp}`;
      }
      
      setCustomFileName(defaultName);
      // Validiere den generierten Namen
      setFileNameError(validateFileName(defaultName));
    }
  }, [effectiveItems, selectedLanguage]);

  // Validierung des Dateinamens
  const validateFileName = (fileName: string): string => {
    if (!fileName.trim()) {
      return 'Dateiname ist erforderlich';
    }
    
    // Prüfe auf ungültige Zeichen
    const invalidChars = /[<>:"/\\|?*]/;
    if (invalidChars.test(fileName)) {
      return 'Dateiname enthält ungültige Zeichen (< > : " / \\ | ? *)';
    }
    
    // Prüfe auf zu lange Namen
    if (fileName.length > 100) {
      return 'Dateiname ist zu lang (max. 100 Zeichen)';
    }
    
    // Prüfe auf reservierte Namen
    const reservedNames = ['CON', 'PRN', 'AUX', 'NUL', 'COM1', 'COM2', 'COM3', 'COM4', 'COM5', 'COM6', 'COM7', 'COM8', 'COM9', 'LPT1', 'LPT2', 'LPT3', 'LPT4', 'LPT5', 'LPT6', 'LPT7', 'LPT8', 'LPT9'];
    if (reservedNames.includes(fileName.toUpperCase())) {
      return 'Dateiname ist reserviert';
    }
    
    return '';
  };

  // Validierung bei Änderung des Dateinamens
  const handleFileNameChange = (value: string) => {
    setCustomFileName(value);
    const error = validateFileName(value);
    setFileNameError(error);
  };

  // Handler für die Batch-Text-Transformation
  const handleStartBatchTransformation = useCallback(async () => {
    if (!provider || !activeLibraryId || selectedItems.length === 0) {
      toast.error("Fehler", {
        description: "Storage Provider oder Bibliothek nicht verfügbar"
      });
      return;
    }

    setProgressState({
      isProcessing: true,
      currentProgress: null,
      results: null
    });

    try {
      // Progress-Callback für Fortschrittsanzeige
      const onProgress = (progress: BatchTransformProgress) => {
        setProgressState(prev => ({
          ...prev,
          currentProgress: progress
        }));
      };

      // Batch-Text-Transformation starten
      const results = await BatchTransformService.transformTextBatch(
        effectiveItems,
        {
          ...baseOptions,
          targetLanguage: selectedLanguage,
          fileName: customFileName.trim() || `Kombinierte_Transformation_${new Date().toISOString().slice(0, 19).replace(/:/g, '-')}`
        },
        selectedTemplate,
        provider,
        refreshItems,
        activeLibraryId,
        onProgress
      );

      setProgressState(prev => ({
        ...prev,
        isProcessing: false,
        results
      }));

      // Erfolgs-/Fehlermeldung anzeigen
      if (results.success) {
        const successCount = results.results.filter(r => r.success).length;
        toast.success("Kombinierte Transformation abgeschlossen", {
          description: `${successCount} von ${effectiveItems.length} Dateien erfolgreich verarbeitet. Eine kombinierte Datei wurde erstellt.`
        });
        
        // Fileliste automatisch aktualisieren
        if (effectiveItems.length > 0) {
          const parentId = effectiveItems[0].item.parentId;
          if (parentId) {
            try {
              const updatedItems = await refreshItems(parentId);
              console.log('TransformationDialog: Fileliste aktualisiert', {
                parentId,
                itemCount: updatedItems.length
              });
              
              // Informiere die übergeordnete Komponente über die Aktualisierung
              if (onRefreshFolder) {
                onRefreshFolder(parentId, updatedItems);
              }
            } catch (error) {
              console.error('TransformationDialog: Fehler beim Aktualisieren der Fileliste', error);
            }
          }
        }
      } else {
        const errorCount = results.results.filter(r => !r.success).length;
        toast.error("Kombinierte Transformation mit Fehlern abgeschlossen", {
          description: `${errorCount} von ${effectiveItems.length} Dateien konnten nicht verarbeitet werden.`
        });
      }

    } catch (error) {
      console.error('Combined text transformation error:', error);
      setProgressState(prev => ({
        ...prev,
        isProcessing: false
      }));
      
      toast.error("Fehler", {
        description: `Kombinierte Transformation fehlgeschlagen: ${error instanceof Error ? error.message : 'Unbekannter Fehler'}`
      });
    }
  }, [provider, activeLibraryId, effectiveItems, baseOptions, selectedTemplate, refreshItems, customFileName, selectedLanguage]);

  // Dialog schließen und State zurücksetzen
  const handleClose = useCallback(() => {
    setIsOpen(false);
    setProgressState({
      isProcessing: false,
      currentProgress: null,
      results: null
    });
  }, [setIsOpen]);

  // Fortschrittsanzeige berechnen
  const progressPercentage = progressState.currentProgress 
    ? (progressState.currentProgress.currentItem / progressState.currentProgress.totalItems) * 100
    : 0;

  return (
    <Dialog open={isOpen} onOpenChange={handleClose}>
      <DialogContent className="max-w-2xl">
        <DialogHeader>
          <DialogTitle>Mehrere Dateien zu einem Dokument transformieren</DialogTitle>
        </DialogHeader>
        
        <div className="py-6 space-y-6">
          {/* Ausgewählte Dateien */}
          <div>
            <h4 className="mb-1 text-sm font-medium">
              Eingabedateien ({effectiveItems.length})
            </h4>
            {skippedCount > 0 && (
              <p className="text-xs text-amber-600 mb-2">{skippedCount} Elemente wurden übersprungen (keine Markdown-Quelle gefunden).</p>
            )}
            <div className="space-y-2 max-h-40 overflow-y-auto">
              {effectiveItems.map(({ item, type }) => (
                <div key={item.id} className="flex items-center gap-2 text-sm">
                  {type === 'text' ? (
                    <FileText className="h-4 w-4 text-blue-500" />
                  ) : (
                    <File className="h-4 w-4 text-gray-500" />
                  )}
                  <span className="truncate">{item.metadata.name}</span>
                  <Badge variant="outline" className="text-xs">
                    {type}
                  </Badge>
                </div>
              ))}
            </div>
            <p className="text-xs text-muted-foreground mt-2">
              Die ausgewählten Texte werden zu einem einzigen Dokument kombiniert und anschließend mit dem gewählten Template verarbeitet.
            </p>
          </div>

          {/* Template-Auswahl */}
          {!progressState.isProcessing && !progressState.results && (
            <div className="space-y-4">
              <div>
                <Label htmlFor="template">Template für Transformation</Label>
                <Select
                  value={selectedTemplate}
                  onValueChange={setSelectedTemplate}
                  disabled={progressState.isProcessing}
                >
                  <SelectTrigger id="template">
                    <SelectValue placeholder="Template auswählen" />
                  </SelectTrigger>
                  <SelectContent>
                    {/* Benutzerdefinierte Templates zuerst */}
                    {customTemplateNames.length > 0 && (
                      <>
                        {customTemplateNames.map((templateName) => (
                          <SelectItem key={templateName} value={templateName}>
                            {templateName}
                          </SelectItem>
                        ))}
                        {/* Trenner zwischen benutzerdefinierten und Standard-Templates */}
                        <div className="px-2 py-1.5 text-xs font-medium text-muted-foreground border-t mt-1 pt-2">
                          Standard-Templates
                        </div>
                      </>
                    )}
                    
                    {/* Standard-Templates */}
                    {standardTemplates.map((standardTemplate) => (
                      <SelectItem key={standardTemplate.name} value={standardTemplate.name}>
                        {standardTemplate.name} <span className="text-muted-foreground">(Standard)</span>
                      </SelectItem>
                    ))}
                  </SelectContent>
                </Select>
              </div>

              <div>
                <Label htmlFor="language">Zielsprache</Label>
                <Select
                  value={selectedLanguage}
                  onValueChange={setSelectedLanguage}
                  disabled={progressState.isProcessing}
                >
                  <SelectTrigger id="language">
                    <SelectValue placeholder="Sprache auswählen" />
                  </SelectTrigger>
                  <SelectContent>
                    {availableLanguages.map((language) => (
                      <SelectItem key={language.code} value={language.code}>
                        {language.name}
                      </SelectItem>
                    ))}
                  </SelectContent>
                </Select>
              </div>

              <div>
                <Label htmlFor="filename">Dateiname für kombinierte Datei</Label>
                <Input
                  id="filename"
                  value={customFileName}
                  onChange={(e) => handleFileNameChange(e.target.value)}
                  placeholder="Dateiname eingeben..."
                  disabled={progressState.isProcessing}
                />
                <p className="text-xs text-muted-foreground mt-1">
                  Der Dateiname wird automatisch mit der Endung .{baseOptions.fileExtension} gespeichert.
                </p>
                {fileNameError && (
                  <p className="text-xs text-red-500 mt-1">
                    {fileNameError}
                  </p>
                )}
              </div>
            </div>
          )}

          {/* Fortschrittsanzeige */}
          {progressState.isProcessing && (
            <div className="space-y-4">
              <h4 className="text-sm font-medium">Verarbeitung läuft...</h4>
              <Progress value={progressPercentage} className="w-full" />
              {progressState.currentProgress && (
                <div className="text-sm text-muted-foreground">
                  {progressState.currentProgress.currentFileName} ({progressState.currentProgress.currentItem}/{progressState.currentProgress.totalItems})
                </div>
              )}
            </div>
          )}

          {/* Ergebnisse */}
          {progressState.results && (
            <div className="space-y-4">
              <h4 className="text-sm font-medium">Ergebnisse</h4>
              <div className="space-y-2 max-h-40 overflow-y-auto">
                {progressState.results.results.map((result) => (
                  <div key={result.item.id} className="flex items-center gap-2 text-sm">
                    {result.success ? (
                      <CheckCircle className="h-4 w-4 text-green-500" />
                    ) : (
                      <XCircle className="h-4 w-4 text-red-500" />
                    )}
                    <span className="truncate">{result.item.metadata.name}</span>
                    {!result.success && (
                      <span className="text-xs text-red-500 truncate">
                        {result.error}
                      </span>
                    )}
                  </div>
                ))}
              </div>
              {progressState.results.results.some(r => r.savedItem) && (
                <div className="text-sm text-green-600 bg-green-50 p-3 rounded-md">
                  ✓ Eine kombinierte Datei wurde erfolgreich erstellt und gespeichert.
                </div>
              )}
            </div>
          )}

          {/* Einstellungen */}
          {!progressState.isProcessing && !progressState.results && (
            <div className="space-y-4">
              <h4 className="text-sm font-medium">Einstellungen</h4>
              <div className="grid grid-cols-2 gap-4 text-sm">
                <div>
                  <span className="text-muted-foreground">Zielsprache:</span>
                  <div className="font-medium">
                    {availableLanguages.find(lang => lang.code === selectedLanguage)?.name}
                  </div>
                </div>
                <div>
                  <span className="text-muted-foreground">Dateiendung:</span>
                  <div className="font-medium">.{baseOptions.fileExtension}</div>
                </div>
              </div>
            </div>
          )}
        </div>

        <div className="flex justify-end gap-4">
          <Button 
            variant="outline" 
            onClick={handleClose}
            disabled={progressState.isProcessing}
          >
            {progressState.results ? 'Schließen' : 'Abbrechen'}
          </Button>
          
          {!progressState.isProcessing && !progressState.results && (
            <Button 
              onClick={handleStartBatchTransformation}
              disabled={effectiveItems.length === 0 || !!fileNameError}
              className="min-w-[320px]"
            >
              Kombinierte Transformation starten
            </Button>
          )}
          {!progressState.isProcessing && !progressState.results && (
            <Button 
              variant="secondary"
              onClick={() => {
                const docs = effectiveItems.map(e => ({ id: e.item.id, name: e.item.metadata.name, parentId: e.item.parentId }))
                setTemplateContext(docs)
                router.push('/templates')
              }}
              disabled={effectiveItems.length === 0}
            >
              Im Template‑Editor testen
            </Button>
          )}
        </div>
      </DialogContent>
      {/* Modal für Prompt-Design*/}
      {!progressState.isProcessing && !progressState.results && (
        <CombinedChatDialog 
          provider={provider}
          items={effectiveItems.map(e => e.item)}
          selectedTemplate={selectedTemplate}
          selectedLanguage={selectedLanguage}
          defaultFileName={customFileName}
        />
      )}
    </Dialog>
  );
} 
```

- „Kombinierten Dialog starten“ entfernt.
- Haupt-Button angepasst:
  - Beschriftung: „Kombinierte Transformation starten“ (ohne „(n Dateien)“).
  - Breite: feste Mindestbreite, damit der Text nicht umbricht.
- Rest unverändert: „Im Template‑Editor testen“ bleibt als Alternative.

---

**User**



Ich habe oben kein Prompt ausgewählt, aber im Prompt-Design wird trotzdem eines angezeigt. Da gibt es irgendwo ein Fallback. Ich brauche nur explizite, bestimmte, das Verhalten der Anwendung keine Fallback-Lösung.


---

**Cursor**

```typescriptreact
"use client"

import { useState, useEffect, useCallback } from "react"
import { useForm } from "react-hook-form"
import { zodResolver } from "@hookform/resolvers/zod"
import * as z from "zod"
import { Button } from "@/components/ui/button"
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card"
import { Label } from "@/components/ui/label"
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select"
import { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from "@/components/ui/tooltip"
import { StructuredTemplateEditor } from "@/components/templates/structured-template-editor"
import { useToast } from "@/hooks/use-toast"
import { Loader2, Save, Eye, Play, FolderOpen, Info } from "lucide-react"
import { useAtom, useAtomValue } from "jotai"
import { activeLibraryAtom, libraryStatusAtom } from "@/atoms/library-atom"
import { 
  templatesAtom, 
  selectedTemplateNameAtom, 
  selectedTemplateAtom,
  templatesFolderIdAtom,
  templateLoadingAtom,
  templateErrorAtom,
  type Template
} from "@/atoms/template-atom"
import { useStorage } from "@/contexts/storage-context"
import { templateContextDocsAtom } from '@/atoms/template-context-atom'
import { Checkbox } from "@/components/ui/checkbox"
import { MarkdownPreview } from "@/components/library/markdown-preview"
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs"
import { JobReportTab } from "@/components/library/job-report-tab"
import { Textarea } from "@/components/ui/textarea"

// Schema für Template-Daten
const templateSchema = z.object({
  name: z.string().min(1, "Prompt-Name ist erforderlich"),
  yamlFrontmatter: z.string(),
  markdownBody: z.string(),
  systemPrompt: z.string(),
})

type TemplateFormValues = z.infer<typeof templateSchema>

export function TemplateManagement() {
  const [previewMode, setPreviewMode] = useState(false)
  const [isSaving, setIsSaving] = useState(false)
  const [isTesting, setIsTesting] = useState(false)
  const [testResult, setTestResult] = useState<string | null>(null)
  const [selectedContextIds, setSelectedContextIds] = useState<string[]>([])
  const [selectedContextMarkdown, setSelectedContextMarkdown] = useState<string>("")
  const [rightTab, setRightTab] = useState<'kontext'|'preview'|'testen'>('kontext')
  const [resultSavedItemId, setResultSavedItemId] = useState<string | null>(null)
  const [freeText, setFreeText] = useState<string>("")
  const { toast } = useToast()

  // Atoms
  const [templates, setTemplates] = useAtom(templatesAtom)
  const [selectedTemplateName, setSelectedTemplateName] = useAtom(selectedTemplateNameAtom)
  const [selectedTemplate] = useAtom(selectedTemplateAtom)
  const [templatesFolderId, setTemplatesFolderId] = useAtom(templatesFolderIdAtom)
  const [isLoading, setIsLoading] = useAtom(templateLoadingAtom)
  const [error, setError] = useAtom(templateErrorAtom)

  // Library und Storage
  const activeLibrary = useAtomValue(activeLibraryAtom)
  const libraryStatus = useAtomValue(libraryStatusAtom)
  const { 
    provider: providerInstance, 
    listItems
  } = useStorage()
  const contextDocs = useAtomValue(templateContextDocsAtom)

  const form = useForm<TemplateFormValues>({
    resolver: zodResolver(templateSchema),
    defaultValues: {
      name: "",
      yamlFrontmatter: `---
title: {{title|Titel des Dokuments}}
tags: {{tags|Relevante Tags}}
date: {{date|Datum im Format yyyy-mm-dd}}
---`,
      markdownBody: `# {{title}}

## Zusammenfassung
{{summary|Kurze Zusammenfassung des Inhalts}}

## Details
{{details|Detaillierte Beschreibung}}`,
      systemPrompt: `You are a specialized assistant that processes and structures information clearly and concisely.

IMPORTANT: Your response must be a valid JSON object where each key corresponds to a template variable.`,
    },
  })

  // Helper zum Erzeugen von Default-Werten
  function getDefaultTemplateValues(name: string): TemplateFormValues {
    return {
      name,
      yamlFrontmatter: `---\n` +
        `title: {{title|Titel des Dokuments}}\n` +
        `tags: {{tags|Relevante Tags}}\n` +
        `date: {{date|Datum im Format yyyy-mm-dd}}\n` +
        `---`,
      markdownBody: `# {{title}}\n\n## Zusammenfassung\n{{summary|Kurze Zusammenfassung des Inhalts}}\n\n## Details\n{{details|Detaillierte Beschreibung}}`,
      systemPrompt: `You are a specialized assistant that processes and structures information clearly and concisely.\n\nIMPORTANT: Your response must be a valid JSON object where each key corresponds to a template variable.`,
    }
  }

  // Template-Daten laden wenn sich die Auswahl ändert
  useEffect(() => {
    if (selectedTemplate) {
      form.reset({
        name: selectedTemplate.name,
        yamlFrontmatter: selectedTemplate.yamlFrontmatter,
        markdownBody: selectedTemplate.markdownBody,
        systemPrompt: selectedTemplate.systemPrompt,
      })
    }
  }, [selectedTemplate, form])

  // Ordner-Erstellung/Suche memoisiert, damit als Dep verwendbar
  const ensureTemplatesFolder = useCallback(async (): Promise<string> => {
    if (!providerInstance || !activeLibrary) {
      throw new Error("Keine aktive Bibliothek oder Provider verfügbar");
    }

    try {
      console.log('[TemplateManagement] Suche nach Templates-Ordner...');
      const rootItems = await listItems('root');
      const templatesFolder = rootItems.find(item => 
        item.type === 'folder' && item.metadata.name === 'templates'
      );
      if (templatesFolder) {
        console.log('[TemplateManagement] Templates-Ordner gefunden:', templatesFolder.id);
        return templatesFolder.id;
      }
      console.log('[TemplateManagement] Templates-Ordner nicht gefunden, erstelle neuen...');
      const newFolder = await providerInstance.createFolder('root', 'templates');
      console.log('[TemplateManagement] Neuer Templates-Ordner erstellt:', newFolder.id);
      return newFolder.id;
    } catch (error) {
      console.error('Fehler beim Erstellen des Templates-Ordners:', {
        error: error instanceof Error ? {
          message: error.message,
          name: error.name,
          stack: error.stack?.split('\n').slice(0, 3)
        } : error,
        libraryId: activeLibrary?.id,
        libraryPath: activeLibrary?.path,
        providerName: providerInstance?.name
      });
      let errorMessage = 'Fehler beim Erstellen des Templates-Ordners';
      if (error instanceof Error) {
        if (error.message.includes('Nicht authentifiziert')) {
          errorMessage = 'Bitte authentifizieren Sie sich bei Ihrem Cloud-Speicher, um den Templates-Ordner zu erstellen.';
        } else if (error.message.includes('Keine Berechtigung')) {
          errorMessage = 'Keine Berechtigung zum Erstellen von Ordnern in der Bibliothek.';
        } else if (error.message.includes('Bibliothek nicht gefunden')) {
          errorMessage = 'Die ausgewählte Bibliothek wurde nicht gefunden.';
        } else {
          errorMessage = `Fehler beim Erstellen des Templates-Ordners: ${error.message}`;
        }
      }
      throw new Error(errorMessage);
    }
  }, [providerInstance, activeLibrary, listItems]);

  // Templates laden mit der gleichen Logik wie Library-Komponente
  const loadTemplates = useCallback(async () => {
    if (!providerInstance || libraryStatus !== 'ready' || !activeLibrary) {
      console.log('[TemplateManagement] loadTemplates übersprungen:', {
        hasProvider: !!providerInstance,
        libraryStatus,
        hasActiveLibrary: !!activeLibrary
      });
      return;
    }

    try {
      setIsLoading(true);
      setError(null);

      console.log('[TemplateManagement] Starte Prompt-Loading:', {
        libraryId: activeLibrary.id,
        libraryPath: activeLibrary.path,
        providerName: providerInstance.name
      });

      // 1. Templates-Ordner finden oder erstellen
      const folderId = await ensureTemplatesFolder();
      setTemplatesFolderId(folderId);

      console.log('[TemplateManagement] Templates-Ordner gefunden/erstellt:', folderId);

      // 2. Alle Template-Dateien im Ordner auflisten
      const items = await listItems(folderId);
      const templateFiles = items.filter(item => 
        item.type === 'file' && 
        item.metadata.name.endsWith('.md')
      );

      console.log('[TemplateManagement] Prompt-Dateien gefunden:', templateFiles.length);

      // 3. Template-Inhalte laden
      const templatePromises = templateFiles.map(async (file) => {
        try {
          const { blob } = await providerInstance.getBinary(file.id);
          const content = await blob.text();
          const template = parseTemplateContent(content, file.metadata.name.replace('.md', ''));
          
          return {
            ...template,
            fileId: file.id,
            lastModified: typeof file.metadata.modifiedAt === 'string' 
              ? file.metadata.modifiedAt 
              : file.metadata.modifiedAt instanceof Date 
                ? file.metadata.modifiedAt.toISOString()
                : new Date().toISOString()
          } as Template;
        } catch (error) {
          console.error(`Fehler beim Parsen von ${file.metadata.name}:`, error);
          return null;
        }
      });

      const loadedTemplates = await Promise.all(templatePromises);
      const validTemplates = loadedTemplates.filter((t): t is Template => t !== null);
      
      setTemplates(validTemplates);
      
      console.log('[TemplateManagement] Prompts erfolgreich geladen:', validTemplates.length);
      
      if (validTemplates.length === 0) {
        toast({
          title: "Keine Prompts gefunden",
          description: "Erstellen Sie Ihren ersten Prompt im Verzeichnis '/templates'.",
        });
      }
    } catch (error) {
      console.error('Fehler beim Laden der Prompts:', {
        error: error instanceof Error ? {
          message: error.message,
          name: error.name,
          stack: error.stack?.split('\n').slice(0, 3)
        } : error,
        libraryId: activeLibrary?.id,
        libraryPath: activeLibrary?.path,
        providerName: providerInstance?.name
      });

      let errorMessage = 'Unbekannter Fehler beim Laden der Prompts';
      
      if (error instanceof Error) {
        errorMessage = error.message;
        
        // Spezifische Fehlermeldungen für häufige Probleme
        if (error.message.includes('Nicht authentifiziert')) {
          errorMessage = 'Bitte authentifizieren Sie sich bei Ihrem Cloud-Speicher, um Prompts zu laden.';
        } else if (error.message.includes('Bibliothek nicht gefunden')) {
          errorMessage = 'Die ausgewählte Bibliothek wurde nicht gefunden. Bitte überprüfen Sie die Bibliothekskonfiguration.';
        } else if (error.message.includes('Server-Fehler')) {
          errorMessage = 'Server-Fehler beim Laden der Prompts. Bitte überprüfen Sie, ob der Bibliothekspfad existiert und zugänglich ist.';
        } else if (error.message.includes('Keine aktive Bibliothek')) {
          errorMessage = 'Keine aktive Bibliothek verfügbar. Bitte wählen Sie eine Bibliothek aus.';
        }
      }
      
      setError(errorMessage);
      toast({
        title: "Fehler beim Laden der Prompts",
        description: errorMessage,
        variant: "destructive",
      });
    } finally {
      setIsLoading(false);
    }
  }, [providerInstance, libraryStatus, activeLibrary, listItems, setTemplates, setTemplatesFolderId, setIsLoading, setError, toast, ensureTemplatesFolder]);

  // Effect für Template Loading (wie Library-Komponente)
  useEffect(() => {
    const isReady = providerInstance && libraryStatus === 'ready' && activeLibrary
    
    if (!isReady) {
      return
    }

    // Templates laden wenn noch nicht geladen
    if (!templatesFolderId) {
      loadTemplates()
    }
  }, [providerInstance, libraryStatus, activeLibrary, templatesFolderId, loadTemplates])

  // Reset wenn sich die Library ändert
  useEffect(() => {
    setSelectedTemplateName(null)
    setTemplatesFolderId(null)
    setTemplates([])
    setError(null)
  }, [libraryStatus, setSelectedTemplateName, setTemplatesFolderId, setTemplates, setError])

  useEffect(() => {
    async function loadSelectedContext() {
      if (!providerInstance || !Array.isArray(selectedContextIds) || selectedContextIds.length === 0) {
        setSelectedContextMarkdown("")
        return
      }
      try {
        const parts: string[] = []
        for (const id of selectedContextIds) {
          const { blob } = await providerInstance.getBinary(id)
          const text = await blob.text()
          const name = Array.isArray(contextDocs) ? (contextDocs.find(d => d.id === id)?.name || id) : id
          const section = `\n\n---\nDatei: ${name}\n---\n\n${text}\n\n---\nEnde Datei: ${name}\n---\n`
          parts.push(section)
        }
        setSelectedContextMarkdown(parts.join("\n\n"))
      } catch (e) {
        console.error('Fehler beim Laden des Kontextes', e)
        setSelectedContextMarkdown("")
      }
    }
    void loadSelectedContext()
  }, [providerInstance, selectedContextIds, contextDocs])

  function parseTemplateContent(content: string, fileName: string): Template {
    // Template in drei Bereiche aufteilen
    const parts = content.split('--- systemprompt')
    
    let yamlFrontmatter = ""
    let markdownBody = ""
    let systemPrompt = ""
    
    if (parts.length >= 2) {
      const mainContent = parts[0].trim()
      systemPrompt = parts[1].trim()
      
      // YAML Frontmatter extrahieren
      const yamlMatch = mainContent.match(/^---\r?\n([\s\S]*?)\r?\n---\r?\n?([\s\S]*)$/)
      if (yamlMatch) {
        yamlFrontmatter = `---\n${yamlMatch[1]}\n---`
        markdownBody = yamlMatch[2].trim()
      } else {
        // Kein YAML Frontmatter gefunden
        markdownBody = mainContent
      }
    } else {
      // Kein Systemprompt gefunden
      const yamlMatch = content.match(/^---\r?\n([\s\S]*?)\r?\n---\r?\n?([\s\S]*)$/)
      if (yamlMatch) {
        yamlFrontmatter = `---\n${yamlMatch[1]}\n---`
        markdownBody = yamlMatch[2].trim()
      } else {
        markdownBody = content
      }
    }

    return {
      name: fileName,
      yamlFrontmatter,
      markdownBody,
      systemPrompt,
    }
  }

  function generateTemplateContent(values: TemplateFormValues): string {
    let content = ""
    
    // YAML Frontmatter hinzufügen
    if (values.yamlFrontmatter.trim()) {
      content += values.yamlFrontmatter + "\n\n"
    }
    
    // Markdown Body hinzufügen
    content += values.markdownBody
    
    // System Prompt hinzufügen
    if (values.systemPrompt.trim()) {
      content += "\n\n--- systemprompt\n" + values.systemPrompt
    }
    
    return content
  }

  async function onSubmit(data: TemplateFormValues) {
    if (!activeLibrary || !templatesFolderId || !providerInstance) {
      toast({
        title: "Fehler",
        description: "Keine aktive Bibliothek oder Templates-Ordner nicht gefunden.",
        variant: "destructive",
      })
      return
    }

    setIsSaving(true)
    try {
      const templateContent = generateTemplateContent(data)
      const fileName = `${data.name}.md`
      
      console.group('[TemplateManagement] Speichern')
      console.log('Library', { id: activeLibrary.id, label: activeLibrary.label, path: activeLibrary.path })
      console.log('TemplatesFolderId', templatesFolderId)
      console.log('Datei', { fileName, contentLen: templateContent.length })
      
      // Falls Datei mit gleichem Namen existiert: erst löschen, dann neu schreiben
      const existing = templates.find(t => t.name.toLowerCase() === data.name.toLowerCase())
      if (existing?.fileId) {
        console.log('Bestehende Datei gefunden, lösche', { fileId: existing.fileId })
        try {
          await providerInstance.deleteItem(existing.fileId)
          console.log('Löschen OK')
        } catch (e) {
          console.error('Löschen fehlgeschlagen', e)
          toast({ title: 'Löschen fehlgeschlagen', description: e instanceof Error ? e.message : String(e), variant: 'destructive' })
        }
      } else {
        console.log('Keine bestehende Datei mit gleichem Namen gefunden')
      }
      
      // Datei als Blob erstellen und hochladen (Neu-Anlage / Ersetzen)
      const blob = new Blob([templateContent], { type: 'text/markdown' })
      const file = new File([blob], fileName, { type: 'text/markdown' })
      const uploaded = await providerInstance.uploadFile(templatesFolderId, file)
      console.log('Upload Ergebnis', uploaded)
      
      // Direkt nach Upload erneut lesen (Bypass-Stale) und lokalen State aktualisieren
      try {
        const { blob: rbBlob } = await providerInstance.getBinary(uploaded.id)
        const rbText = await rbBlob.text()
        console.log('Read-Back Länge', rbText.length, 'Auszug', rbText.slice(0, 120))
        const parsed = parseTemplateContent(rbText, data.name)
        const updated: Template = {
          ...parsed,
          fileId: uploaded.id,
          lastModified: new Date().toISOString()
        }
        setTemplates(((prev: Template[]) => {
          const rest = prev.filter((t: Template) => t.name.toLowerCase() !== data.name.toLowerCase())
          return [...rest, updated]
        }) as unknown as Template[])
      } catch (e) {
        console.warn('Read-Back nach Upload fehlgeschlagen', e)
      }
      
      // Kurze Wartezeit, damit Remote-Provider (OneDrive) Index/Cache aktualisiert
      await new Promise(r => setTimeout(r, 500))
      
      // Templates neu laden (finaler Sync mit Remote)
      await loadTemplates()
      console.log('Templates neu geladen')
      
      // Auswahl auf das neue Template setzen
      setSelectedTemplateName(data.name)
      console.log('Auswahl gesetzt', data.name)
      
      toast({
        title: "Prompt gespeichert",
        description: `"${data.name}" wurde aktualisiert.`,
      })
      console.groupEnd()
    } catch (error) {
      console.error('Fehler beim Speichern des Templates:', error)
      toast({
        title: "Fehler beim Speichern",
        description: error instanceof Error ? error.message : "Unbekannter Fehler",
        variant: "destructive",
      })
    } finally {
      setIsSaving(false)
    }
  }

  async function renameCurrentTemplate() {
    const current = selectedTemplateName ? templates.find(t => t.name === selectedTemplateName) : null
    if (!current || !current.fileId || !providerInstance) return
    const newName = (window.prompt('Neuen Namen eingeben:', current.name) || '').trim()
    if (!newName || newName === current.name) return
    if (/[^a-zA-Z0-9._\- ]/.test(newName)) { toast({ title: 'Ungültiger Name', description: 'Nur Buchstaben, Zahlen, Leerzeichen, . _ - sind erlaubt.', variant: 'destructive' }); return }
    if (templates.some(t => t.name.toLowerCase() === newName.toLowerCase())) { toast({ title: 'Bereits vorhanden', description: 'Bitte anderen Namen wählen.', variant: 'destructive' }); return }
    try {
      await providerInstance.renameItem(current.fileId, `${newName}.md`)
      await loadTemplates()
      setSelectedTemplateName(newName)
      form.setValue('name', newName, { shouldDirty: false })
      toast({ title: 'Umbenannt', description: `${current.name} → ${newName}` })
    } catch (e) {
      toast({ title: 'Fehler beim Umbenennen', description: e instanceof Error ? e.message : 'Unbekannter Fehler', variant: 'destructive' })
    }
  }

  async function deleteTemplate(templateName: string) {
    if (!activeLibrary || !providerInstance) return

    try {
      const template = templates.find(t => t.name === templateName)
      if (!template?.fileId) {
        throw new Error("Template-Datei nicht gefunden")
      }

      // Datei löschen
      await providerInstance.deleteItem(template.fileId)

      // Templates neu laden
      await loadTemplates()
      
      if (selectedTemplateName === templateName) {
        setSelectedTemplateName(null)
        form.reset()
      }
      
      toast({
        title: "Template gelöscht",
        description: `Template "${templateName}" wurde erfolgreich gelöscht.`,
      })
    } catch (error) {
      console.error('Fehler beim Löschen des Templates:', error)
      toast({
        title: "Fehler beim Löschen",
        description: error instanceof Error ? error.message : "Unbekannter Fehler",
        variant: "destructive",
      })
    }
  }

  async function createNewTemplate() {
    const name = (window.prompt('Neuen Template‑Namen eingeben:') || '').trim()
    if (!name) return
    if (/[^a-zA-Z0-9._\- ]/.test(name)) { toast({ title: 'Ungültiger Name', description: 'Nur Buchstaben, Zahlen, Leerzeichen, . _ - sind erlaubt.', variant: 'destructive' }); return }
    if (templates.some(t => t.name.toLowerCase() === name.toLowerCase())) { toast({ title: 'Bereits vorhanden', description: 'Bitte anderen Namen wählen.', variant: 'destructive' }); return }
    if (!providerInstance) { toast({ title: 'Kein Provider' , variant: 'destructive' }); return }
    try {
      const folderId = await ensureTemplatesFolder()
      const values = getDefaultTemplateValues(name)
      const content = (values.yamlFrontmatter ? values.yamlFrontmatter + '\n\n' : '') + values.markdownBody + '\n\n--- systemprompt\n' + values.systemPrompt
      const file = new File([new Blob([content], { type: 'text/markdown' })], `${name}.md`, { type: 'text/markdown' })
      await providerInstance.uploadFile(folderId, file)
      await loadTemplates()
      setSelectedTemplateName(name)
      form.reset(values)
      toast({ title: 'Template angelegt', description: `"${name}" wurde erstellt.` })
    } catch (e) {
      toast({ title: 'Fehler beim Anlegen', description: e instanceof Error ? e.message : 'Unbekannter Fehler', variant: 'destructive' })
    }
  }

  function generatePreview(): string {
    const values = form.getValues()
    return generateTemplateContent(values)
  }

  async function testTemplate() {
    if (!activeLibrary) return

    setIsTesting(true)
    setTestResult(null)

    const values = form.getValues()
    const templateContent = generateTemplateContent(values)
    const sections: string[] = []
    if (selectedContextMarkdown.trim()) sections.push(selectedContextMarkdown.trim())
    if (freeText.trim()) sections.push(`---\nDatei: Freitext\n---\n\n${freeText.trim()}\n\n---\nEnde Datei: Freitext\n---`)
    const testText = sections.join("\n\n")

    const pickMarkdown = (result: unknown): string => {
      if (typeof result === 'string') return result
      if (result && typeof result === 'object') {
        const obj = result as Record<string, unknown>
        const directCandidates = ['text','markdown','content','output'] as const
        for (const k of directCandidates) {
          const v = obj[k]
          if (typeof v === 'string') return v
        }
        // verschachtelte Felder prüfen
        const nested = obj['data']
        if (nested && typeof nested === 'object') {
          const nobj = nested as Record<string, unknown>
          for (const k of directCandidates) {
            const v = nobj[k]
            if (typeof v === 'string') return v
          }
        }
      }
      return JSON.stringify(result, null, 2)
    }

    try {
      const response = await fetch('/api/secretary/process-text', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/x-www-form-urlencoded',
          'X-Library-Id': activeLibrary.id,
        },
        body: new URLSearchParams({
          text: testText,
          template_content: templateContent,
          source_language: 'de',
          target_language: 'de',
          use_cache: 'false',
        }),
      })

      if (!response.ok) {
        const errorData = await response.json()
        throw new Error(errorData.error || `HTTP ${response.status}: ${response.statusText}`)
      }

      const result = await response.json()
      const formattedResult = pickMarkdown(result)
      console.log('Prompt-Test Ergebnis:', formattedResult)
      
      setTestResult(formattedResult)
      setRightTab('testen')

      toast({
        title: "Prompt-Test erfolgreich",
        description: "Der Prompt wurde erfolgreich mit dem gewählten Kontext verarbeitet.",
      })

      console.log('Prompt-Test Ergebnis (roh):', result)
    } catch (error) {
      console.error('Fehler beim Prompt-Test:', error)
      const errorMessage = error instanceof Error ? error.message : "Unbekannter Fehler"
      setTestResult(`Fehler: ${errorMessage}`)
      setRightTab('testen')
      toast({
        title: "Prompt-Test fehlgeschlagen",
        description: errorMessage,
        variant: "destructive",
      })
    } finally {
      setIsTesting(false)
    }
  }

  async function ensurePromptTestsFolder(): Promise<string> {
    if (!providerInstance) throw new Error('Kein Provider verfügbar')
    const roots = await listItems('root')
    const found = roots.find(it => it.type === 'folder' && it.metadata.name === 'prompt-tests')
    if (found) return found.id
    const created = await providerInstance.createFolder('root', 'prompt-tests')
    return created.id
  }

  async function saveTestResult() {
    try {
      if (!providerInstance || !activeLibrary || !testResult) return
      const folderId = await ensurePromptTestsFolder()
      const name = `${selectedTemplateName || 'prompt'}-test-${new Date().toISOString().replace(/[:.]/g,'-')}.md`
      const blob = new Blob([testResult], { type: 'text/markdown' })
      const file = new File([blob], name, { type: 'text/markdown' })
      const item = await providerInstance.uploadFile(folderId, file)
      setResultSavedItemId(item.id)
      toast({ title: 'Ergebnis gespeichert', description: name })
    } catch (e) {
      toast({ title: 'Speichern fehlgeschlagen', description: e instanceof Error ? e.message : 'Unbekannter Fehler', variant: 'destructive' })
    }
  }

  // Render-Logik für verschiedene Status
  if (libraryStatus === "waitingForAuth") {
    return (
      <div className="flex flex-col items-center justify-center h-full text-muted-foreground">
        <span>Diese Bibliothek benötigt eine Authentifizierung.</span>
        <span className="text-sm mt-2">Bitte konfigurieren Sie die Bibliothek in den Einstellungen.</span>
      </div>
    )
  }
  
  if (libraryStatus !== "ready") {
    return (
      <div className="flex flex-col items-center justify-center h-full text-muted-foreground">
        <span>Lade Storage...</span>
      </div>
    )
  }

  if (!activeLibrary) {
    return (
      <div className="text-center text-muted-foreground">
        Bitte wählen Sie eine Bibliothek aus.
      </div>
    )
  }

  if (error) {
    return (
      <div className="text-center text-destructive">
        <p>Fehler beim Laden der Prompts:</p>
        <p className="text-sm">{error}</p>
        <Button 
          variant="outline" 
          className="mt-4"
          onClick={loadTemplates}
        >
          Erneut versuchen
        </Button>
      </div>
    )
  }

  return (
    <div className="space-y-6">

      {/* Kompakte Toolbar oben */}
      <div className="flex items-center gap-2">
        <Select value={selectedTemplateName || ''} onValueChange={(v) => { setSelectedTemplateName(v); form.setValue('name', v, { shouldDirty: false }) }} disabled={isLoading}>
          <SelectTrigger className="w-64">
            <SelectValue placeholder="Prompt auswählen..." />
          </SelectTrigger>
          <SelectContent>
            {templates.map((t) => (
              <SelectItem key={t.name} value={t.name}>{t.name}</SelectItem>
            ))}
          </SelectContent>
        </Select>
        <TooltipProvider>
          <Tooltip>
            <TooltipTrigger asChild>
              <Button variant="ghost" size="sm" className="h-8 w-8 p-0"><Info className="h-4 w-4" /></Button>
            </TooltipTrigger>
            <TooltipContent>
              <div className="flex items-center gap-2"><FolderOpen className="h-4 w-4" /><span>Ort: /templates in „{activeLibrary.label}“</span></div>
            </TooltipContent>
          </Tooltip>
        </TooltipProvider>
        <Button type="button" variant="outline" size="sm" onClick={createNewTemplate} disabled={isLoading}>Neu</Button>
        <Button type="button" variant="outline" size="sm" onClick={renameCurrentTemplate} disabled={!selectedTemplateName}>Umbenennen</Button>
        {selectedTemplateName && (
          <Button type="button" variant="destructive" size="sm" onClick={() => deleteTemplate(selectedTemplateName!)}>Löschen</Button>
        )}
      </div>

      <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
        <Card>
          <CardHeader>
            <CardTitle>Prompt Design</CardTitle>
            <CardDescription>
              Drei Bereiche: Aufgabe (was), Rollenanweisung (wie), Metadaten (Begleitinfos).
            </CardDescription>
          </CardHeader>
          <CardContent>
            <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-6">
              {/* Template-Name Feld entfernt (oben verwaltet) */}

              {!selectedTemplateName ? (
                <div className="rounded-md border border-dashed p-6 text-sm text-muted-foreground">
                  Bitte oben einen Prompt auswählen oder Neu anlegen.
                </div>
              ) : previewMode ? (
                <div className="space-y-4">
                  <div className="flex items-center justify-between">
                    <h4 className="text-sm font-medium">Prompt-Vorschau</h4>
                    <Button
                      type="button"
                      variant="outline"
                      size="sm"
                      onClick={() => setPreviewMode(false)}
                    >
                      Bearbeiten
                    </Button>
                  </div>
                  <div className="border rounded-md p-4 bg-muted/50">
                    <pre className="text-sm whitespace-pre-wrap font-mono">
                      {generatePreview()}
                    </pre>
                  </div>
                </div>
              ) : (
                <StructuredTemplateEditor
                  markdownBody={form.watch('markdownBody')}
                  yamlFrontmatter={form.watch('yamlFrontmatter')}
                  systemPrompt={form.watch('systemPrompt')}
                  onChange={({ markdownBody, yamlFrontmatter, systemPrompt }) => {
                    form.setValue('markdownBody', markdownBody, { shouldDirty: true })
                    form.setValue('yamlFrontmatter', yamlFrontmatter, { shouldDirty: true })
                    form.setValue('systemPrompt', systemPrompt, { shouldDirty: true })
                  }}
                />
              )}

              <div className="flex justify-end gap-2">
                <Button
                  type="button"
                  variant="outline"
                  onClick={() => setPreviewMode(!previewMode)}
                  disabled={!selectedTemplateName}
                >
                  <Eye className="h-4 w-4 mr-2" />
                  {previewMode ? "Bearbeiten" : "Vorschau"}
                </Button>
                <Button
                  type="submit"
                  disabled={!selectedTemplateName || isSaving || !form.formState.isDirty}
                >
                  {isSaving ? (
                    <>
                      <Loader2 className="h-4 w-4 mr-2 animate-spin" />
                      Wird gespeichert...
                    </>
                  ) : (
                    <>
                      <Save className="h-4 w-4 mr-2" />
                      Speichern
                    </>
                  )}
                </Button>
              </div>
            </form>
          </CardContent>
        </Card>

        <Card>
          <CardHeader>
            <CardTitle>Prompt testen</CardTitle>
            <CardDescription>
              Test mit Beispieltext. Nutzt Rollenanweisung, Aufgabe und Metadaten des Prompts.
            </CardDescription>
          </CardHeader>
          <CardContent>
            <Tabs value={rightTab} onValueChange={(v) => setRightTab(v as typeof rightTab)}>
              <TabsList className="grid grid-cols-3 w-full">
                <TabsTrigger value="kontext">Daten‑Kontext</TabsTrigger>
                <TabsTrigger value="preview">Prompt‑Vorschau</TabsTrigger>
                <TabsTrigger value="testen">Testen</TabsTrigger>
              </TabsList>

              <TabsContent value="kontext" className="space-y-4 mt-4">
                <div className="space-y-2">
                  <Label>Kontext-Texte</Label>
                  <div className="border rounded p-2 text-sm">
                    {Array.isArray(contextDocs) && contextDocs.length > 0 ? (
                      contextDocs.map(d => {
                        const checked = selectedContextIds.includes(d.id)
                        return (
                          <label key={d.id} className="flex items-center gap-2 py-1">
                            <Checkbox
                              checked={checked}
                              onCheckedChange={(v) => {
                                const isOn = v === true
                                setSelectedContextIds(prev => isOn ? [...prev, d.id] : prev.filter(x => x !== d.id))
                              }}
                            />
                            <span className="truncate">{d.name}</span>
                          </label>
                        )
                      })
                    ) : (
                      <div className="text-muted-foreground text-sm">Keine Kontext-Texte verfügbar</div>
                    )}
                  </div>
                </div>

                <div className="space-y-2">
                  <Label>Gewählter Kontext (Lesemodus)</Label>
                  <div className="border rounded-md">
                    <MarkdownPreview content={selectedContextMarkdown} />
                  </div>
                </div>

                <div className="space-y-2">
                  <Label>Freitext (optional)</Label>
                  <Textarea
                    value={freeText}
                    onChange={(e) => setFreeText(e.target.value)}
                    placeholder="Hier Text einkleben, um schnell zu testen"
                    className="min-h-[120px] font-mono text-sm"
                  />
                </div>
              </TabsContent>

              <TabsContent value="preview" className="space-y-4 mt-4">
                <div className="space-y-2">
                  <Label>Generierter Prompt (Markdown)</Label>
                  <div className="border rounded-md">
                    <MarkdownPreview content={generatePreview()} />
                  </div>
                </div>
               </TabsContent>

              <TabsContent value="testen" className="space-y-4 mt-4">
                <div className="flex gap-2 justify-end">
                  <Button 
                    variant="outline" 
                    size="sm"
                    onClick={testTemplate}
                    disabled={!selectedTemplateName || isTesting}
                  >
                    {isTesting ? (
                      <>
                        <Loader2 className="h-4 w-4 mr-2 animate-spin" />
                        Teste...
                      </>
                    ) : (
                      <>
                        <Play className="h-4 w-4 mr-2" />
                        Prompt testen
                      </>
                    )}
                  </Button>
                </div>
                {activeLibrary && providerInstance && (testResult || resultSavedItemId) ? (
                  <JobReportTab
                    libraryId={activeLibrary.id}
                    fileId={resultSavedItemId || 'preview'}
                    provider={providerInstance}
                    sourceMode="frontmatter"
                    viewMode="metaOnly"
                    mdFileId={resultSavedItemId || undefined}
                    rawContent={testResult || undefined}
                  />
                ) : (
                  <div className="text-sm text-muted-foreground">Kein Ergebnis vorhanden.</div>
                )}
                <div className="flex gap-2">
                  <Button type="button" onClick={saveTestResult} disabled={!testResult}>Speichern</Button>
                </div>
              </TabsContent>
            </Tabs>
          </CardContent>
        </Card>
      </div>
    </div>
  )
} 
```

- Kein Fallback mehr im Prompt‑Design:
  - Wenn oben kein Prompt ausgewählt ist, zeigt die Mitte nur einen Hinweis „Bitte oben einen Prompt auswählen oder Neu anlegen“.
  - Editor, Vorschau und Speichern sind deaktiviert bis ein Prompt ausgewählt ist.
- Buttons:
  - „Vorschau“ und „Speichern“ sind disabled ohne Auswahl.

---

**User**

Ok, aber auf der rechten Seite ist noch die FrontPort-Scheinerei. Und jetzt sollte es auf die FrontPort-Scheinerei und dann hier die BackPort-Scheinerei sein. Controls, Search.Auf der rechten Bildschirmseite ist aber Promptvorschau noch da, sollte auch deaktiviert sein und kein Prompt angezeigt werden.

---

**Cursor**

```typescriptreact
"use client"

import { useState, useEffect, useCallback } from "react"
import { useForm } from "react-hook-form"
import { zodResolver } from "@hookform/resolvers/zod"
import * as z from "zod"
import { Button } from "@/components/ui/button"
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card"
import { Label } from "@/components/ui/label"
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select"
import { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from "@/components/ui/tooltip"
import { StructuredTemplateEditor } from "@/components/templates/structured-template-editor"
import { useToast } from "@/hooks/use-toast"
import { Loader2, Save, Eye, Play, FolderOpen, Info } from "lucide-react"
import { useAtom, useAtomValue } from "jotai"
import { activeLibraryAtom, libraryStatusAtom } from "@/atoms/library-atom"
import { 
  templatesAtom, 
  selectedTemplateNameAtom, 
  selectedTemplateAtom,
  templatesFolderIdAtom,
  templateLoadingAtom,
  templateErrorAtom,
  type Template
} from "@/atoms/template-atom"
import { useStorage } from "@/contexts/storage-context"
import { templateContextDocsAtom } from '@/atoms/template-context-atom'
import { Checkbox } from "@/components/ui/checkbox"
import { MarkdownPreview } from "@/components/library/markdown-preview"
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs"
import { JobReportTab } from "@/components/library/job-report-tab"
import { Textarea } from "@/components/ui/textarea"

// Schema für Template-Daten
const templateSchema = z.object({
  name: z.string().min(1, "Prompt-Name ist erforderlich"),
  yamlFrontmatter: z.string(),
  markdownBody: z.string(),
  systemPrompt: z.string(),
})

type TemplateFormValues = z.infer<typeof templateSchema>

export function TemplateManagement() {
  const [previewMode, setPreviewMode] = useState(false)
  const [isSaving, setIsSaving] = useState(false)
  const [isTesting, setIsTesting] = useState(false)
  const [testResult, setTestResult] = useState<string | null>(null)
  const [selectedContextIds, setSelectedContextIds] = useState<string[]>([])
  const [selectedContextMarkdown, setSelectedContextMarkdown] = useState<string>("")
  const [rightTab, setRightTab] = useState<'kontext'|'preview'|'testen'>('kontext')
  const [resultSavedItemId, setResultSavedItemId] = useState<string | null>(null)
  const [freeText, setFreeText] = useState<string>("")
  const { toast } = useToast()

  // Atoms
  const [templates, setTemplates] = useAtom(templatesAtom)
  const [selectedTemplateName, setSelectedTemplateName] = useAtom(selectedTemplateNameAtom)
  const [selectedTemplate] = useAtom(selectedTemplateAtom)
  const [templatesFolderId, setTemplatesFolderId] = useAtom(templatesFolderIdAtom)
  const [isLoading, setIsLoading] = useAtom(templateLoadingAtom)
  const [error, setError] = useAtom(templateErrorAtom)

  // Library und Storage
  const activeLibrary = useAtomValue(activeLibraryAtom)
  const libraryStatus = useAtomValue(libraryStatusAtom)
  const { 
    provider: providerInstance, 
    listItems
  } = useStorage()
  const contextDocs = useAtomValue(templateContextDocsAtom)

  const form = useForm<TemplateFormValues>({
    resolver: zodResolver(templateSchema),
    defaultValues: {
      name: "",
      yamlFrontmatter: `---
title: {{title|Titel des Dokuments}}
tags: {{tags|Relevante Tags}}
date: {{date|Datum im Format yyyy-mm-dd}}
---`,
      markdownBody: `# {{title}}

## Zusammenfassung
{{summary|Kurze Zusammenfassung des Inhalts}}

## Details
{{details|Detaillierte Beschreibung}}`,
      systemPrompt: `You are a specialized assistant that processes and structures information clearly and concisely.

IMPORTANT: Your response must be a valid JSON object where each key corresponds to a template variable.`,
    },
  })

  // Helper zum Erzeugen von Default-Werten
  function getDefaultTemplateValues(name: string): TemplateFormValues {
    return {
      name,
      yamlFrontmatter: `---\n` +
        `title: {{title|Titel des Dokuments}}\n` +
        `tags: {{tags|Relevante Tags}}\n` +
        `date: {{date|Datum im Format yyyy-mm-dd}}\n` +
        `---`,
      markdownBody: `# {{title}}\n\n## Zusammenfassung\n{{summary|Kurze Zusammenfassung des Inhalts}}\n\n## Details\n{{details|Detaillierte Beschreibung}}`,
      systemPrompt: `You are a specialized assistant that processes and structures information clearly and concisely.\n\nIMPORTANT: Your response must be a valid JSON object where each key corresponds to a template variable.`,
    }
  }

  // Template-Daten laden wenn sich die Auswahl ändert
  useEffect(() => {
    if (selectedTemplate) {
      form.reset({
        name: selectedTemplate.name,
        yamlFrontmatter: selectedTemplate.yamlFrontmatter,
        markdownBody: selectedTemplate.markdownBody,
        systemPrompt: selectedTemplate.systemPrompt,
      })
    }
  }, [selectedTemplate, form])

  // Ordner-Erstellung/Suche memoisiert, damit als Dep verwendbar
  const ensureTemplatesFolder = useCallback(async (): Promise<string> => {
    if (!providerInstance || !activeLibrary) {
      throw new Error("Keine aktive Bibliothek oder Provider verfügbar");
    }

    try {
      console.log('[TemplateManagement] Suche nach Templates-Ordner...');
      const rootItems = await listItems('root');
      const templatesFolder = rootItems.find(item => 
        item.type === 'folder' && item.metadata.name === 'templates'
      );
      if (templatesFolder) {
        console.log('[TemplateManagement] Templates-Ordner gefunden:', templatesFolder.id);
        return templatesFolder.id;
      }
      console.log('[TemplateManagement] Templates-Ordner nicht gefunden, erstelle neuen...');
      const newFolder = await providerInstance.createFolder('root', 'templates');
      console.log('[TemplateManagement] Neuer Templates-Ordner erstellt:', newFolder.id);
      return newFolder.id;
    } catch (error) {
      console.error('Fehler beim Erstellen des Templates-Ordners:', {
        error: error instanceof Error ? {
          message: error.message,
          name: error.name,
          stack: error.stack?.split('\n').slice(0, 3)
        } : error,
        libraryId: activeLibrary?.id,
        libraryPath: activeLibrary?.path,
        providerName: providerInstance?.name
      });
      let errorMessage = 'Fehler beim Erstellen des Templates-Ordners';
      if (error instanceof Error) {
        if (error.message.includes('Nicht authentifiziert')) {
          errorMessage = 'Bitte authentifizieren Sie sich bei Ihrem Cloud-Speicher, um den Templates-Ordner zu erstellen.';
        } else if (error.message.includes('Keine Berechtigung')) {
          errorMessage = 'Keine Berechtigung zum Erstellen von Ordnern in der Bibliothek.';
        } else if (error.message.includes('Bibliothek nicht gefunden')) {
          errorMessage = 'Die ausgewählte Bibliothek wurde nicht gefunden.';
        } else {
          errorMessage = `Fehler beim Erstellen des Templates-Ordners: ${error.message}`;
        }
      }
      throw new Error(errorMessage);
    }
  }, [providerInstance, activeLibrary, listItems]);

  // Templates laden mit der gleichen Logik wie Library-Komponente
  const loadTemplates = useCallback(async () => {
    if (!providerInstance || libraryStatus !== 'ready' || !activeLibrary) {
      console.log('[TemplateManagement] loadTemplates übersprungen:', {
        hasProvider: !!providerInstance,
        libraryStatus,
        hasActiveLibrary: !!activeLibrary
      });
      return;
    }

    try {
      setIsLoading(true);
      setError(null);

      console.log('[TemplateManagement] Starte Prompt-Loading:', {
        libraryId: activeLibrary.id,
        libraryPath: activeLibrary.path,
        providerName: providerInstance.name
      });

      // 1. Templates-Ordner finden oder erstellen
      const folderId = await ensureTemplatesFolder();
      setTemplatesFolderId(folderId);

      console.log('[TemplateManagement] Templates-Ordner gefunden/erstellt:', folderId);

      // 2. Alle Template-Dateien im Ordner auflisten
      const items = await listItems(folderId);
      const templateFiles = items.filter(item => 
        item.type === 'file' && 
        item.metadata.name.endsWith('.md')
      );

      console.log('[TemplateManagement] Prompt-Dateien gefunden:', templateFiles.length);

      // 3. Template-Inhalte laden
      const templatePromises = templateFiles.map(async (file) => {
        try {
          const { blob } = await providerInstance.getBinary(file.id);
          const content = await blob.text();
          const template = parseTemplateContent(content, file.metadata.name.replace('.md', ''));
          
          return {
            ...template,
            fileId: file.id,
            lastModified: typeof file.metadata.modifiedAt === 'string' 
              ? file.metadata.modifiedAt 
              : file.metadata.modifiedAt instanceof Date 
                ? file.metadata.modifiedAt.toISOString()
                : new Date().toISOString()
          } as Template;
        } catch (error) {
          console.error(`Fehler beim Parsen von ${file.metadata.name}:`, error);
          return null;
        }
      });

      const loadedTemplates = await Promise.all(templatePromises);
      const validTemplates = loadedTemplates.filter((t): t is Template => t !== null);
      
      setTemplates(validTemplates);
      
      console.log('[TemplateManagement] Prompts erfolgreich geladen:', validTemplates.length);
      
      if (validTemplates.length === 0) {
        toast({
          title: "Keine Prompts gefunden",
          description: "Erstellen Sie Ihren ersten Prompt im Verzeichnis '/templates'.",
        });
      }
    } catch (error) {
      console.error('Fehler beim Laden der Prompts:', {
        error: error instanceof Error ? {
          message: error.message,
          name: error.name,
          stack: error.stack?.split('\n').slice(0, 3)
        } : error,
        libraryId: activeLibrary?.id,
        libraryPath: activeLibrary?.path,
        providerName: providerInstance?.name
      });

      let errorMessage = 'Unbekannter Fehler beim Laden der Prompts';
      
      if (error instanceof Error) {
        errorMessage = error.message;
        
        // Spezifische Fehlermeldungen für häufige Probleme
        if (error.message.includes('Nicht authentifiziert')) {
          errorMessage = 'Bitte authentifizieren Sie sich bei Ihrem Cloud-Speicher, um Prompts zu laden.';
        } else if (error.message.includes('Bibliothek nicht gefunden')) {
          errorMessage = 'Die ausgewählte Bibliothek wurde nicht gefunden. Bitte überprüfen Sie die Bibliothekskonfiguration.';
        } else if (error.message.includes('Server-Fehler')) {
          errorMessage = 'Server-Fehler beim Laden der Prompts. Bitte überprüfen Sie, ob der Bibliothekspfad existiert und zugänglich ist.';
        } else if (error.message.includes('Keine aktive Bibliothek')) {
          errorMessage = 'Keine aktive Bibliothek verfügbar. Bitte wählen Sie eine Bibliothek aus.';
        }
      }
      
      setError(errorMessage);
      toast({
        title: "Fehler beim Laden der Prompts",
        description: errorMessage,
        variant: "destructive",
      });
    } finally {
      setIsLoading(false);
    }
  }, [providerInstance, libraryStatus, activeLibrary, listItems, setTemplates, setTemplatesFolderId, setIsLoading, setError, toast, ensureTemplatesFolder]);

  // Effect für Template Loading (wie Library-Komponente)
  useEffect(() => {
    const isReady = providerInstance && libraryStatus === 'ready' && activeLibrary
    
    if (!isReady) {
      return
    }

    // Templates laden wenn noch nicht geladen
    if (!templatesFolderId) {
      loadTemplates()
    }
  }, [providerInstance, libraryStatus, activeLibrary, templatesFolderId, loadTemplates])

  // Reset wenn sich die Library ändert
  useEffect(() => {
    setSelectedTemplateName(null)
    setTemplatesFolderId(null)
    setTemplates([])
    setError(null)
  }, [libraryStatus, setSelectedTemplateName, setTemplatesFolderId, setTemplates, setError])

  useEffect(() => {
    async function loadSelectedContext() {
      if (!providerInstance || !Array.isArray(selectedContextIds) || selectedContextIds.length === 0) {
        setSelectedContextMarkdown("")
        return
      }
      try {
        const parts: string[] = []
        for (const id of selectedContextIds) {
          const { blob } = await providerInstance.getBinary(id)
          const text = await blob.text()
          const name = Array.isArray(contextDocs) ? (contextDocs.find(d => d.id === id)?.name || id) : id
          const section = `\n\n---\nDatei: ${name}\n---\n\n${text}\n\n---\nEnde Datei: ${name}\n---\n`
          parts.push(section)
        }
        setSelectedContextMarkdown(parts.join("\n\n"))
      } catch (e) {
        console.error('Fehler beim Laden des Kontextes', e)
        setSelectedContextMarkdown("")
      }
    }
    void loadSelectedContext()
  }, [providerInstance, selectedContextIds, contextDocs])

  function parseTemplateContent(content: string, fileName: string): Template {
    // Template in drei Bereiche aufteilen
    const parts = content.split('--- systemprompt')
    
    let yamlFrontmatter = ""
    let markdownBody = ""
    let systemPrompt = ""
    
    if (parts.length >= 2) {
      const mainContent = parts[0].trim()
      systemPrompt = parts[1].trim()
      
      // YAML Frontmatter extrahieren
      const yamlMatch = mainContent.match(/^---\r?\n([\s\S]*?)\r?\n---\r?\n?([\s\S]*)$/)
      if (yamlMatch) {
        yamlFrontmatter = `---\n${yamlMatch[1]}\n---`
        markdownBody = yamlMatch[2].trim()
      } else {
        // Kein YAML Frontmatter gefunden
        markdownBody = mainContent
      }
    } else {
      // Kein Systemprompt gefunden
      const yamlMatch = content.match(/^---\r?\n([\s\S]*?)\r?\n---\r?\n?([\s\S]*)$/)
      if (yamlMatch) {
        yamlFrontmatter = `---\n${yamlMatch[1]}\n---`
        markdownBody = yamlMatch[2].trim()
      } else {
        markdownBody = content
      }
    }

    return {
      name: fileName,
      yamlFrontmatter,
      markdownBody,
      systemPrompt,
    }
  }

  function generateTemplateContent(values: TemplateFormValues): string {
    let content = ""
    
    // YAML Frontmatter hinzufügen
    if (values.yamlFrontmatter.trim()) {
      content += values.yamlFrontmatter + "\n\n"
    }
    
    // Markdown Body hinzufügen
    content += values.markdownBody
    
    // System Prompt hinzufügen
    if (values.systemPrompt.trim()) {
      content += "\n\n--- systemprompt\n" + values.systemPrompt
    }
    
    return content
  }

  async function onSubmit(data: TemplateFormValues) {
    if (!activeLibrary || !templatesFolderId || !providerInstance) {
      toast({
        title: "Fehler",
        description: "Keine aktive Bibliothek oder Templates-Ordner nicht gefunden.",
        variant: "destructive",
      })
      return
    }

    setIsSaving(true)
    try {
      const templateContent = generateTemplateContent(data)
      const fileName = `${data.name}.md`
      
      console.group('[TemplateManagement] Speichern')
      console.log('Library', { id: activeLibrary.id, label: activeLibrary.label, path: activeLibrary.path })
      console.log('TemplatesFolderId', templatesFolderId)
      console.log('Datei', { fileName, contentLen: templateContent.length })
      
      // Falls Datei mit gleichem Namen existiert: erst löschen, dann neu schreiben
      const existing = templates.find(t => t.name.toLowerCase() === data.name.toLowerCase())
      if (existing?.fileId) {
        console.log('Bestehende Datei gefunden, lösche', { fileId: existing.fileId })
        try {
          await providerInstance.deleteItem(existing.fileId)
          console.log('Löschen OK')
        } catch (e) {
          console.error('Löschen fehlgeschlagen', e)
          toast({ title: 'Löschen fehlgeschlagen', description: e instanceof Error ? e.message : String(e), variant: 'destructive' })
        }
      } else {
        console.log('Keine bestehende Datei mit gleichem Namen gefunden')
      }
      
      // Datei als Blob erstellen und hochladen (Neu-Anlage / Ersetzen)
      const blob = new Blob([templateContent], { type: 'text/markdown' })
      const file = new File([blob], fileName, { type: 'text/markdown' })
      const uploaded = await providerInstance.uploadFile(templatesFolderId, file)
      console.log('Upload Ergebnis', uploaded)
      
      // Direkt nach Upload erneut lesen (Bypass-Stale) und lokalen State aktualisieren
      try {
        const { blob: rbBlob } = await providerInstance.getBinary(uploaded.id)
        const rbText = await rbBlob.text()
        console.log('Read-Back Länge', rbText.length, 'Auszug', rbText.slice(0, 120))
        const parsed = parseTemplateContent(rbText, data.name)
        const updated: Template = {
          ...parsed,
          fileId: uploaded.id,
          lastModified: new Date().toISOString()
        }
        setTemplates(((prev: Template[]) => {
          const rest = prev.filter((t: Template) => t.name.toLowerCase() !== data.name.toLowerCase())
          return [...rest, updated]
        }) as unknown as Template[])
      } catch (e) {
        console.warn('Read-Back nach Upload fehlgeschlagen', e)
      }
      
      // Kurze Wartezeit, damit Remote-Provider (OneDrive) Index/Cache aktualisiert
      await new Promise(r => setTimeout(r, 500))
      
      // Templates neu laden (finaler Sync mit Remote)
      await loadTemplates()
      console.log('Templates neu geladen')
      
      // Auswahl auf das neue Template setzen
      setSelectedTemplateName(data.name)
      console.log('Auswahl gesetzt', data.name)
      
      toast({
        title: "Prompt gespeichert",
        description: `"${data.name}" wurde aktualisiert.`,
      })
      console.groupEnd()
    } catch (error) {
      console.error('Fehler beim Speichern des Templates:', error)
      toast({
        title: "Fehler beim Speichern",
        description: error instanceof Error ? error.message : "Unbekannter Fehler",
        variant: "destructive",
      })
    } finally {
      setIsSaving(false)
    }
  }

  async function renameCurrentTemplate() {
    const current = selectedTemplateName ? templates.find(t => t.name === selectedTemplateName) : null
    if (!current || !current.fileId || !providerInstance) return
    const newName = (window.prompt('Neuen Namen eingeben:', current.name) || '').trim()
    if (!newName || newName === current.name) return
    if (/[^a-zA-Z0-9._\- ]/.test(newName)) { toast({ title: 'Ungültiger Name', description: 'Nur Buchstaben, Zahlen, Leerzeichen, . _ - sind erlaubt.', variant: 'destructive' }); return }
    if (templates.some(t => t.name.toLowerCase() === newName.toLowerCase())) { toast({ title: 'Bereits vorhanden', description: 'Bitte anderen Namen wählen.', variant: 'destructive' }); return }
    try {
      await providerInstance.renameItem(current.fileId, `${newName}.md`)
      await loadTemplates()
      setSelectedTemplateName(newName)
      form.setValue('name', newName, { shouldDirty: false })
      toast({ title: 'Umbenannt', description: `${current.name} → ${newName}` })
    } catch (e) {
      toast({ title: 'Fehler beim Umbenennen', description: e instanceof Error ? e.message : 'Unbekannter Fehler', variant: 'destructive' })
    }
  }

  async function deleteTemplate(templateName: string) {
    if (!activeLibrary || !providerInstance) return

    try {
      const template = templates.find(t => t.name === templateName)
      if (!template?.fileId) {
        throw new Error("Template-Datei nicht gefunden")
      }

      // Datei löschen
      await providerInstance.deleteItem(template.fileId)

      // Templates neu laden
      await loadTemplates()
      
      if (selectedTemplateName === templateName) {
        setSelectedTemplateName(null)
        form.reset()
      }
      
      toast({
        title: "Template gelöscht",
        description: `Template "${templateName}" wurde erfolgreich gelöscht.`,
      })
    } catch (error) {
      console.error('Fehler beim Löschen des Templates:', error)
      toast({
        title: "Fehler beim Löschen",
        description: error instanceof Error ? error.message : "Unbekannter Fehler",
        variant: "destructive",
      })
    }
  }

  async function createNewTemplate() {
    const name = (window.prompt('Neuen Template‑Namen eingeben:') || '').trim()
    if (!name) return
    if (/[^a-zA-Z0-9._\- ]/.test(name)) { toast({ title: 'Ungültiger Name', description: 'Nur Buchstaben, Zahlen, Leerzeichen, . _ - sind erlaubt.', variant: 'destructive' }); return }
    if (templates.some(t => t.name.toLowerCase() === name.toLowerCase())) { toast({ title: 'Bereits vorhanden', description: 'Bitte anderen Namen wählen.', variant: 'destructive' }); return }
    if (!providerInstance) { toast({ title: 'Kein Provider' , variant: 'destructive' }); return }
    try {
      const folderId = await ensureTemplatesFolder()
      const values = getDefaultTemplateValues(name)
      const content = (values.yamlFrontmatter ? values.yamlFrontmatter + '\n\n' : '') + values.markdownBody + '\n\n--- systemprompt\n' + values.systemPrompt
      const file = new File([new Blob([content], { type: 'text/markdown' })], `${name}.md`, { type: 'text/markdown' })
      await providerInstance.uploadFile(folderId, file)
      await loadTemplates()
      setSelectedTemplateName(name)
      form.reset(values)
      toast({ title: 'Template angelegt', description: `"${name}" wurde erstellt.` })
    } catch (e) {
      toast({ title: 'Fehler beim Anlegen', description: e instanceof Error ? e.message : 'Unbekannter Fehler', variant: 'destructive' })
    }
  }

  function generatePreview(): string {
    const values = form.getValues()
    return generateTemplateContent(values)
  }

  async function testTemplate() {
    if (!activeLibrary) return

    setIsTesting(true)
    setTestResult(null)

    const values = form.getValues()
    const templateContent = generateTemplateContent(values)
    const sections: string[] = []
    if (selectedContextMarkdown.trim()) sections.push(selectedContextMarkdown.trim())
    if (freeText.trim()) sections.push(`---\nDatei: Freitext\n---\n\n${freeText.trim()}\n\n---\nEnde Datei: Freitext\n---`)
    const testText = sections.join("\n\n")

    const pickMarkdown = (result: unknown): string => {
      if (typeof result === 'string') return result
      if (result && typeof result === 'object') {
        const obj = result as Record<string, unknown>
        const directCandidates = ['text','markdown','content','output'] as const
        for (const k of directCandidates) {
          const v = obj[k]
          if (typeof v === 'string') return v
        }
        // verschachtelte Felder prüfen
        const nested = obj['data']
        if (nested && typeof nested === 'object') {
          const nobj = nested as Record<string, unknown>
          for (const k of directCandidates) {
            const v = nobj[k]
            if (typeof v === 'string') return v
          }
        }
      }
      return JSON.stringify(result, null, 2)
    }

    try {
      const response = await fetch('/api/secretary/process-text', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/x-www-form-urlencoded',
          'X-Library-Id': activeLibrary.id,
        },
        body: new URLSearchParams({
          text: testText,
          template_content: templateContent,
          source_language: 'de',
          target_language: 'de',
          use_cache: 'false',
        }),
      })

      if (!response.ok) {
        const errorData = await response.json()
        throw new Error(errorData.error || `HTTP ${response.status}: ${response.statusText}`)
      }

      const result = await response.json()
      const formattedResult = pickMarkdown(result)
      console.log('Prompt-Test Ergebnis:', formattedResult)
      
      setTestResult(formattedResult)
      setRightTab('testen')

      toast({
        title: "Prompt-Test erfolgreich",
        description: "Der Prompt wurde erfolgreich mit dem gewählten Kontext verarbeitet.",
      })

      console.log('Prompt-Test Ergebnis (roh):', result)
    } catch (error) {
      console.error('Fehler beim Prompt-Test:', error)
      const errorMessage = error instanceof Error ? error.message : "Unbekannter Fehler"
      setTestResult(`Fehler: ${errorMessage}`)
      setRightTab('testen')
      toast({
        title: "Prompt-Test fehlgeschlagen",
        description: errorMessage,
        variant: "destructive",
      })
    } finally {
      setIsTesting(false)
    }
  }

  async function ensurePromptTestsFolder(): Promise<string> {
    if (!providerInstance) throw new Error('Kein Provider verfügbar')
    const roots = await listItems('root')
    const found = roots.find(it => it.type === 'folder' && it.metadata.name === 'prompt-tests')
    if (found) return found.id
    const created = await providerInstance.createFolder('root', 'prompt-tests')
    return created.id
  }

  async function saveTestResult() {
    try {
      if (!providerInstance || !activeLibrary || !testResult) return
      const folderId = await ensurePromptTestsFolder()
      const name = `${selectedTemplateName || 'prompt'}-test-${new Date().toISOString().replace(/[:.]/g,'-')}.md`
      const blob = new Blob([testResult], { type: 'text/markdown' })
      const file = new File([blob], name, { type: 'text/markdown' })
      const item = await providerInstance.uploadFile(folderId, file)
      setResultSavedItemId(item.id)
      toast({ title: 'Ergebnis gespeichert', description: name })
    } catch (e) {
      toast({ title: 'Speichern fehlgeschlagen', description: e instanceof Error ? e.message : 'Unbekannter Fehler', variant: 'destructive' })
    }
  }

  // Render-Logik für verschiedene Status
  if (libraryStatus === "waitingForAuth") {
    return (
      <div className="flex flex-col items-center justify-center h-full text-muted-foreground">
        <span>Diese Bibliothek benötigt eine Authentifizierung.</span>
        <span className="text-sm mt-2">Bitte konfigurieren Sie die Bibliothek in den Einstellungen.</span>
      </div>
    )
  }
  
  if (libraryStatus !== "ready") {
    return (
      <div className="flex flex-col items-center justify-center h-full text-muted-foreground">
        <span>Lade Storage...</span>
      </div>
    )
  }

  if (!activeLibrary) {
    return (
      <div className="text-center text-muted-foreground">
        Bitte wählen Sie eine Bibliothek aus.
      </div>
    )
  }

  if (error) {
    return (
      <div className="text-center text-destructive">
        <p>Fehler beim Laden der Prompts:</p>
        <p className="text-sm">{error}</p>
        <Button 
          variant="outline" 
          className="mt-4"
          onClick={loadTemplates}
        >
          Erneut versuchen
        </Button>
      </div>
    )
  }

  return (
    <div className="space-y-6">

      {/* Kompakte Toolbar oben */}
      <div className="flex items-center gap-2">
        <Select value={selectedTemplateName || ''} onValueChange={(v) => { setSelectedTemplateName(v); form.setValue('name', v, { shouldDirty: false }) }} disabled={isLoading}>
          <SelectTrigger className="w-64">
            <SelectValue placeholder="Prompt auswählen..." />
          </SelectTrigger>
          <SelectContent>
            {templates.map((t) => (
              <SelectItem key={t.name} value={t.name}>{t.name}</SelectItem>
            ))}
          </SelectContent>
        </Select>
        <TooltipProvider>
          <Tooltip>
            <TooltipTrigger asChild>
              <Button variant="ghost" size="sm" className="h-8 w-8 p-0"><Info className="h-4 w-4" /></Button>
            </TooltipTrigger>
            <TooltipContent>
              <div className="flex items-center gap-2"><FolderOpen className="h-4 w-4" /><span>Ort: /templates in „{activeLibrary.label}“</span></div>
            </TooltipContent>
          </Tooltip>
        </TooltipProvider>
        <Button type="button" variant="outline" size="sm" onClick={createNewTemplate} disabled={isLoading}>Neu</Button>
        <Button type="button" variant="outline" size="sm" onClick={renameCurrentTemplate} disabled={!selectedTemplateName}>Umbenennen</Button>
        {selectedTemplateName && (
          <Button type="button" variant="destructive" size="sm" onClick={() => deleteTemplate(selectedTemplateName!)}>Löschen</Button>
        )}
      </div>

      <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
        <Card>
          <CardHeader>
            <CardTitle>Prompt Design</CardTitle>
            <CardDescription>
              Drei Bereiche: Aufgabe (was), Rollenanweisung (wie), Metadaten (Begleitinfos).
            </CardDescription>
          </CardHeader>
          <CardContent>
            <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-6">
              {/* Template-Name Feld entfernt (oben verwaltet) */}

              {!selectedTemplateName ? (
                <div className="rounded-md border border-dashed p-6 text-sm text-muted-foreground">
                  Bitte oben einen Prompt auswählen oder Neu anlegen.
                </div>
              ) : previewMode ? (
                <div className="space-y-4">
                  <div className="flex items-center justify-between">
                    <h4 className="text-sm font-medium">Prompt-Vorschau</h4>
                    <Button
                      type="button"
                      variant="outline"
                      size="sm"
                      onClick={() => setPreviewMode(false)}
                    >
                      Bearbeiten
                    </Button>
                  </div>
                  <div className="border rounded-md p-4 bg-muted/50">
                    <pre className="text-sm whitespace-pre-wrap font-mono">
                      {generatePreview()}
                    </pre>
                  </div>
                </div>
              ) : (
                <StructuredTemplateEditor
                  markdownBody={form.watch('markdownBody')}
                  yamlFrontmatter={form.watch('yamlFrontmatter')}
                  systemPrompt={form.watch('systemPrompt')}
                  onChange={({ markdownBody, yamlFrontmatter, systemPrompt }) => {
                    form.setValue('markdownBody', markdownBody, { shouldDirty: true })
                    form.setValue('yamlFrontmatter', yamlFrontmatter, { shouldDirty: true })
                    form.setValue('systemPrompt', systemPrompt, { shouldDirty: true })
                  }}
                />
              )}

              <div className="flex justify-end gap-2">
                <Button
                  type="button"
                  variant="outline"
                  onClick={() => setPreviewMode(!previewMode)}
                  disabled={!selectedTemplateName}
                >
                  <Eye className="h-4 w-4 mr-2" />
                  {previewMode ? "Bearbeiten" : "Vorschau"}
                </Button>
                <Button
                  type="submit"
                  disabled={!selectedTemplateName || isSaving || !form.formState.isDirty}
                >
                  {isSaving ? (
                    <>
                      <Loader2 className="h-4 w-4 mr-2 animate-spin" />
                      Wird gespeichert...
                    </>
                  ) : (
                    <>
                      <Save className="h-4 w-4 mr-2" />
                      Speichern
                    </>
                  )}
                </Button>
              </div>
            </form>
          </CardContent>
        </Card>

        <Card>
          <CardHeader>
            <CardTitle>Prompt testen</CardTitle>
            <CardDescription>
              Test mit Beispieltext. Nutzt Rollenanweisung, Aufgabe und Metadaten des Prompts.
            </CardDescription>
          </CardHeader>
          <CardContent>
            {!selectedTemplateName ? (
              <div className="rounded-md border border-dashed p-6 text-sm text-muted-foreground">
                Bitte oben einen Prompt auswählen. Die Vorschau und Test‑Funktionen werden erst danach aktiviert.
              </div>
            ) : (
              <Tabs value={rightTab} onValueChange={(v) => setRightTab(v as typeof rightTab)}>
                <TabsList className="grid grid-cols-3 w-full">
                  <TabsTrigger value="kontext">Daten‑Kontext</TabsTrigger>
                  <TabsTrigger value="preview">Prompt‑Vorschau</TabsTrigger>
                  <TabsTrigger value="testen">Testen</TabsTrigger>
                </TabsList>

                <TabsContent value="kontext" className="space-y-4 mt-4">
                  <div className="space-y-2">
                    <Label>Kontext-Texte</Label>
                    <div className="border rounded p-2 text-sm">
                      {Array.isArray(contextDocs) && contextDocs.length > 0 ? (
                        contextDocs.map(d => {
                          const checked = selectedContextIds.includes(d.id)
                          return (
                            <label key={d.id} className="flex items-center gap-2 py-1">
                              <Checkbox
                                checked={checked}
                                onCheckedChange={(v) => {
                                  const isOn = v === true
                                  setSelectedContextIds(prev => isOn ? [...prev, d.id] : prev.filter(x => x !== d.id))
                                }}
                              />
                              <span className="truncate">{d.name}</span>
                            </label>
                          )
                        })
                      ) : (
                        <div className="text-muted-foreground text-sm">Keine Kontext-Texte verfügbar</div>
                      )}
                    </div>
                  </div>

                  <div className="space-y-2">
                    <Label>Gewählter Kontext (Lesemodus)</Label>
                    <div className="border rounded-md">
                      <MarkdownPreview content={selectedContextMarkdown} />
                    </div>
                  </div>

                  <div className="space-y-2">
                    <Label>Freitext (optional)</Label>
                    <Textarea
                      value={freeText}
                      onChange={(e) => setFreeText(e.target.value)}
                      placeholder="Hier Text einkleben, um schnell zu testen"
                      className="min-h-[120px] font-mono text-sm"
                    />
                  </div>
                </TabsContent>

                <TabsContent value="preview" className="space-y-4 mt-4">
                  <div className="space-y-2">
                    <Label>Generierter Prompt (Markdown)</Label>
                    <div className="border rounded-md">
                      <MarkdownPreview content={generatePreview()} />
                    </div>
                  </div>
                  <div className="flex gap-2 justify-end">
                    <Button 
                      variant="outline" 
                      size="sm"
                      onClick={testTemplate}
                      disabled={!selectedTemplateName || isTesting}
                    >
                      {isTesting ? (
                        <>
                          <Loader2 className="h-4 w-4 mr-2 animate-spin" />
                          Teste...
                        </>
                      ) : (
                        <>
                          <Play className="h-4 w-4 mr-2" />
                          Prompt testen
                        </>
                      )}
                    </Button>
                  </div>
                </TabsContent>

                <TabsContent value="testen" className="space-y-4 mt-4">
                  <div className="flex gap-2 justify-end">
                    <Button 
                      variant="outline" 
                      size="sm"
                      onClick={testTemplate}
                      disabled={!selectedTemplateName || isTesting}
                    >
                      {isTesting ? (
                        <>
                          <Loader2 className="h-4 w-4 mr-2 animate-spin" />
                          Teste...
                        </>
                      ) : (
                        <>
                          <Play className="h-4 w-4 mr-2" />
                          Prompt testen
                        </>
                      )}
                    </Button>
                  </div>
                  {activeLibrary && providerInstance && (testResult || resultSavedItemId) ? (
                    <JobReportTab
                      libraryId={activeLibrary.id}
                      fileId={resultSavedItemId || 'preview'}
                      provider={providerInstance}
                      sourceMode="frontmatter"
                      viewMode="metaOnly"
                      mdFileId={resultSavedItemId || undefined}
                      rawContent={testResult || undefined}
                    />
                  ) : (
                    <div className="text-sm text-muted-foreground">Kein Ergebnis vorhanden.</div>
                  )}
                  <div className="flex gap-2">
                    <Button type="button" onClick={saveTestResult} disabled={!testResult}>Speichern</Button>
                  </div>
                </TabsContent>
              </Tabs>
            )}
          </CardContent>
        </Card>
      </div>
    </div>
  )
} 
```

- Rechte Seite gesperrt, wenn kein Prompt gewählt:
  - Tabs und Vorschau/Test werden durch einen Hinweis ersetzt.
  - Erst nach Auswahl werden „Daten‑Kontext“, „Prompt‑Vorschau“ und „Testen“ sichtbar.
- Linke Seite war bereits ohne Fallback aktiv. Jetzt ist das Verhalten beider Spalten konsistent.

---

**User**

@Messe.md Ich möchte jetzt einen Dialog machen, mit dem ich Templates korrigieren kann. Das heißt, können wir ein Template bauen, wo ich als Text ein Template sende und in den System-Prompt genau erklärt wird, wie so ein Template funktioniert. Sehr detailliert. Und ich dann als zusätzliche Frage bestimmte Attribute ändern möchte. Und dieser Prompt liefert mir immer wieder ein gültiges Template zurück. Wenn ich nichts frage, sollte eins zu eins genau das ursprüngliche Template zurückgeliefert werden. Das heißt, es ist ein sehr treuer Prozess, der nur minimale Änderungen erlaubt, die vom Anwender halt gefragt werden. Und vielleicht die alten und die neuen Änderungen beibehält, so dass der Anwender immer sieht, was jetzt neu ist und kann das alte dann aber auslöschen. Da wird das alte durchgestrichen formatiert, so dass man, wie könnte man so ein Template formulieren.

---

**Cursor**

Hier ist ein treues „Template‑Korrektor“-Template, das aus einem Eingabe‑Template und Änderungswünschen ein neues, gültiges Template erzeugt (optional mit Diff). Wenn keine Wünsche angegeben sind, wird das Original 1:1 zurückgegeben.

```markdown
---
title: Template-Korrektor
purpose: Korrigieren/Anpassen eines bestehenden Templates mit minimalen Änderungen
output: { corrected_template, diff_preview }
---

# Eingabe-Template
{{input_template|Füge hier das vollständige Template als Markdown ein (inkl. Frontmatter, Body, optional --- systemprompt).}}

# Änderungswünsche
{{changes|Welche Attribute sollen geändert werden? Z. B. Titel, Variablennamen, Reihenfolge/Abschnitte, Formulierungen, Sprache. Wenn leer → keine Änderungen vornehmen.}}

# Konfiguration
{{allowed_scope|Erlaubte Bereiche: 'frontmatter' | 'body' | 'systemprompt' | 'all'.}}
{{diff_mode|Ausgabe-Modus: 'plain' (nur neues Template) oder 'diff' (Markdown-Diff mit ~~alt~~ und **neu**).}}
{{preserve_comments|Kommentare/Hinweise erhalten? 'ja' | 'nein'.}}

# Ergebnis
{{corrected_template|Gib hier das korrigierte Template als vollständige Markdown-Datei zurück (inkl. Frontmatter; Body; optional --- systemprompt).}}
{{diff_preview|Wenn diff_mode=='diff': Kurz-Diff als Markdown (~~alt~~, **neu**). Sonst "".}}

--- systemprompt
Du bist ein „Template-Korrektor“. Du erhältst:
- input_template: ein komplettes Template als Markdown mit Struktur:
  - Frontmatter: YAML zwischen den ersten beiden „---“-Linien.
  - Body: Text nach dem Frontmatter bis optional „--- systemprompt“.
  - Variablen im Body sind `{{varName|instruction}}`.
- changes: präzise Änderungswünsche (können leer sein).
- allowed_scope: eins aus {frontmatter, body, systemprompt, all}.
- diff_mode: 'plain' oder 'diff'.
- preserve_comments: 'ja'/'nein'.

Ziel:
- Erzeuge „corrected_template“: ein gültiges Template im selben Format wie input_template.
- Wenn „changes“ leer ist, gib input_template unverändert zurück.
- Führe nur die ausdrücklich angefragten Änderungen aus, beschränke Dich strikt auf allowed_scope.
- Erhalte alle nicht betroffenen Inhalte byte‑treu (Whitespace, Reihenfolge, Variablennamen).
- Bewahre Kommentare/Hinweise, wenn preserve_comments=='ja', sonst entferne nur, wenn explizit verlangt.
- Variablen‑Syntax `{{var|...}}` niemals verändern (außer ausdrücklich gefordert).
- Optional „diff_preview“: Markdown‑Kurzsicht mit ~~gelöschten~~ und **hinzugefügten** Stellen (keine Prosa), nur wenn diff_mode=='diff'; sonst "".

Strikte Ausgabe:
- Antworte mit genau EINEM JSON‑Objekt.
- Schlüssel: input_template, changes, allowed_scope, diff_mode, preserve_comments, corrected_template, diff_preview.
- Alle Werte sind Strings (UTF‑8). Kein zusätzliches Markdown/Codefence um das JSON.
- „corrected_template“ MUSS eine vollständige Markdown‑Datei sein (inkl. Frontmatter und ggf. --- systemprompt).
```

```markdown
---
title: Template-Korrektor
purpose: Korrigieren/Anpassen eines bestehenden Templates mit minimalen Änderungen
output: { corrected_template, diff_preview }
---

# Eingabe-Template
{{input_template|Füge hier das vollständige Template als Markdown ein (inkl. Frontmatter, Body, optional --- systemprompt).}}

# Änderungswünsche
{{changes|Welche Attribute sollen geändert werden? Z. B. Titel, Variablennamen, Reihenfolge/Abschnitte, Formulierungen, Sprache. Wenn leer → keine Änderungen vornehmen.}}

# Konfiguration
{{allowed_scope|Erlaubte Bereiche: 'frontmatter' | 'body' | 'systemprompt' | 'all'.}}
{{diff_mode|Ausgabe-Modus: 'plain' (nur neues Template) oder 'diff' (Markdown-Diff mit ~~alt~~ und **neu**).}}
{{preserve_comments|Kommentare/Hinweise erhalten? 'ja' | 'nein'.}}

# Ergebnis
{{corrected_template|Gib hier das korrigierte Template als vollständige Markdown-Datei zurück (inkl. Frontmatter; Body; optional --- systemprompt).}}
{{diff_preview|Wenn diff_mode=='diff': Kurz-Diff als Markdown (~~alt~~, **neu**). Sonst "".}}

--- systemprompt
Du bist ein „Template-Korrektor“. Du erhältst:
- input_template: ein komplettes Template als Markdown mit Struktur:
  - Frontmatter: YAML zwischen den ersten beiden „---“-Linien.
  - Body: Text nach dem Frontmatter bis optional „--- systemprompt“.
  - Variablen im Body sind `{{varName|instruction}}`.
- changes: präzise Änderungswünsche (können leer sein).
- allowed_scope: eins aus {frontmatter, body, systemprompt, all}.
- diff_mode: 'plain' oder 'diff'.
- preserve_comments: 'ja'/'nein'.

Ziel:
- Erzeuge „corrected_template“: ein gültiges Template im selben Format wie input_template.
- Wenn „changes“ leer ist, gib input_template unverändert zurück.
- Führe nur die ausdrücklich angefragten Änderungen aus, beschränke Dich strikt auf allowed_scope.
- Erhalte alle nicht betroffenen Inhalte byte‑treu (Whitespace, Reihenfolge, Variablennamen).
- Bewahre Kommentare/Hinweise, wenn preserve_comments=='ja', sonst entferne nur, wenn explizit verlangt.
- Variablen‑Syntax `{{var|...}}` niemals verändern (außer ausdrücklich gefordert).
- Optional „diff_preview“: Markdown‑Kurzsicht mit ~~gelöschten~~ und **hinzugefügten** Stellen (keine Prosa), nur wenn diff_mode=='diff'; sonst "".

Strikte Ausgabe:
- Antworte mit genau EINEM JSON‑Objekt.
- Schlüssel: input_template, changes, allowed_scope, diff_mode, preserve_comments, corrected_template, diff_preview.
- Alle Werte sind Strings (UTF‑8). Kein zusätzliches Markdown/Codefence um das JSON.
- „corrected_template“ MUSS eine vollständige Markdown‑Datei sein (inkl. Frontmatter und ggf. --- systemprompt).
```

---

**User**

Ich habe von einem anderen Template diesen Systemprompt: können wir was übernehmen
You are a specialized assistant who processes and structures information clearly and concisely. Work only with the provided content and do not invent any facts.

OUTPUT REQUIREMENTS (STRICT):
- Respond with ONE valid JSON object ONLY. No prose, no code fences, no comments.
- Use UTF-8 and standard JSON (no trailing commas).
- Keys MUST be exactly: "summary", "fazit", "details", "toDo".
- Values MUST be strings that contain Markdown formatting (headings, lists, quotes). 
- Newlines MUST be encoded as \n inside JSON strings.
- Escape double quotes (\") and backslashes (\\) as required by JSON.
- If a section has no content, return an empty string "" (not null, not omitted).

CONTENT RULES:
- Language: same as source (usually German).
- Be precise, concise, and faithful to the input. No speculation, no external knowledge.
- Preserve names, figures, and dates if present.
- Avoid verbatim copy; condense to essentials.

SECTION FORMATS:
- "summary": Markdown list of conversations. For each: 
  "### <Kurztitel>\n<Ein Zweizeiler mit Kernaussage>"
- "fazit": Markdown with short sections 
  "#### Was lief gut", "#### Potenzial", "#### Bedenken" 
  (each as bullet points).
- "details": Markdown list of conversations. For each: 
  "#### <Titel>\n<Kompakte, faktengetreue Beschreibung, max. 300 Wörter; Listen erlaubt>"
- "toDo": Markdown bullet list of next steps, ideally task-Style:
  "- [ ] <Aufgabe> (@Owner optional, Fälligkeitsdatum yyyy-mm-dd optional)"

VALIDATION:
- The response MUST validate as JSON. Example shape (illustrative only):
{"summary":"...","fazit":"...","details":"...","toDo":"..."}




---

**Cursor**

Ja – wir übernehmen die strikten Output-/Validierungsregeln und passen sie für den Template‑Korrektor an. Hier ist ein kompakter System‑Prompt (ersetzt deinen bisherigen), der dein Treue‑Verhalten sicherstellt und die JSON/Encoding‑Vorgaben übernimmt.

System‑Prompt (übernommen + angepasst)
You are a specialized assistant that edits a given Template with minimal, explicit changes only. Be faithful: if no changes are requested, return the original template byte-for-byte.

Inputs
- input_template: full template as Markdown (Frontmatter YAML between first two --- lines; Body after Frontmatter; optional --- systemprompt section).
- changes: explicit requested edits (may be empty).
- allowed_scope: one of frontmatter | body | systemprompt | all.
- diff_mode: 'plain' (only corrected template) or 'diff' (also a short inline diff).
- preserve_comments: 'ja' | 'nein'.

Edit Rules (STRICT)
- Apply only changes explicitly stated in changes and only within allowed_scope.
- Preserve everything else exactly (order, whitespace, headings, variable syntax {{var|instruction}}).
- Do not rename or remove variables unless requested.
- If preserve_comments=='ja', keep comments/hints; otherwise remove only when asked.
- Language: same as input_template. No external facts. No speculation.

Output Requirements (STRICT)
- Respond with ONE valid JSON object ONLY. No prose, no code fences, no comments.
- UTF-8, standard JSON, no trailing commas.
- Keys MUST be exactly: "corrected_template", "diff_preview".
- Values MUST be strings.
- Newlines MUST be encoded as \n inside JSON strings.
- Escape double quotes (\") and backslashes (\\) as required by JSON.
- If diff_mode!='diff', set "diff_preview" to "".
- If changes is empty, "corrected_template" MUST be exactly input_template.

Format Details
- corrected_template: full Markdown template (Frontmatter preserved; Body; optional --- systemprompt).
- diff_preview (when diff_mode=='diff'): short inline diff as Markdown in place, using ~~alt~~ for removed tokens/phrases and **neu** for additions; keep it concise and safe (no reflow of unaffected lines).

Validation
- The response MUST validate as JSON and conform to the key set above.
- If a requested change is ambiguous or conflicts with allowed_scope, do not change that part; still return valid JSON and keep the original content.

---

**User**

wie schaut der gesamte template jetzt aus - auf Deutsch?

---

**Cursor**

```markdown
---
title: Template‑Korrektor
purpose: Korrigieren/Anpassen eines bestehenden Templates mit minimalen, expliziten Änderungen
output: { corrected_template, diff_preview }
---

# Eingabe‑Template
{{input_template|Füge hier das vollständige Template als Markdown ein (inkl. Frontmatter „--- … ---“, Body und optional „--- systemprompt“).}}

# Änderungswünsche
{{changes|Welche Attribute sollen geändert werden? Z. B. Titel, Variablennamen, Reihenfolge/Abschnitte, Formulierungen, Sprache. Wenn leer ⇒ keine Änderungen.}}

# Konfiguration
{{allowed_scope|Erlaubte Bereiche: 'frontmatter' | 'body' | 'systemprompt' | 'all'.}}
{{diff_mode|Ausgabe: 'plain' (nur neues Template) oder 'diff' (kurzer Inline‑Diff).}}
{{preserve_comments|Kommentare/Hinweise beibehalten? 'ja' | 'nein'.}}

# Ergebnis
{{corrected_template|Gib hier das korrigierte Template als vollständige Markdown‑Datei zurück (inkl. Frontmatter; Body; optional --- systemprompt).}}
{{diff_preview|Wenn diff_mode=='diff': Kurz‑Diff als Markdown (~~alt~~, **neu**). Sonst "".}}

--- systemprompt
Du bist ein „Template‑Korrektor“. Du erhältst:
- input_template: komplettes Template als Markdown mit Struktur:
  - Frontmatter: YAML zwischen den ersten beiden „---“-Linien.
  - Body: Text nach dem Frontmatter bis optional „--- systemprompt“.
  - Variablen im Body: `{{varName|anweisung}}`.
- changes: präzise Änderungswünsche (kann leer sein).
- allowed_scope: eins aus {frontmatter, body, systemprompt, all}.
- diff_mode: 'plain' | 'diff'.
- preserve_comments: 'ja' | 'nein'.

Ziel:
- Erzeuge „corrected_template“: ein gültiges Template im selben Format wie input_template.
- Wenn „changes“ leer ist, gib input_template unverändert und byte‑treu zurück.
- Führe nur ausdrücklich angefragte Änderungen aus und ausschließlich innerhalb von allowed_scope.
- Erhalte alle übrigen Inhalte exakt: Reihenfolge, Whitespace, Überschriften, Variablensyntax `{{var|…}}`.
- Variablen nicht umbenennen/entfernen, außer explizit gefordert.
- Kommentare/Hinweise nur entfernen, wenn preserve_comments=='nein' UND explizit verlangt.
- Sprache: wie im input_template. Keine Erfindungen, keine externen Fakten.

Ausgabe (STRICT):
- Antworte mit GENAU EINEM JSON‑Objekt. Keine Prosa, keine Code‑Fences, keine Kommentare.
- UTF‑8, Standard‑JSON, keine trailing commas.
- Schlüssel MÜSSEN exakt lauten: "corrected_template", "diff_preview".
- Werte MÜSSEN Strings sein.
- Zeilenumbrüche MÜSSEN als \n innerhalb von JSON‑Strings codiert werden.
- Doppelte Anführungszeichen (\") und Backslashes (\\) korrekt escapen.
- Wenn diff_mode!='diff' ⇒ "diff_preview": "".

„corrected_template“:
- Vollständige Markdown‑Datei (Frontmatter; Body; optional --- systemprompt).
- Strukturell valide; Frontmatter‑Block oben, nur ein systemprompt‑Block (falls vorhanden).

„diff_preview“ (nur bei diff_mode=='diff'):
- Kurzer, inline lesbarer Diff als Markdown:
  - ~~gelöschte Teile~~
  - **hinzugefügte Teile**
- Kein Reflow unveränderter Absätze, nur minimaler Kontext.

Validierung:
- Das gesamte LLM‑Ergebnis MUSS valide JSON sein und exakt die Keys "corrected_template" und "diff_preview" enthalten.
- Bei mehrdeutigen oder nicht zulässigen Anforderungen (außerhalb allowed_scope) keine Änderung an diesen Teilen vornehmen; dennoch valides JSON liefern und das Original beibehalten.
```

```markdown
---
title: Template‑Korrektor
purpose: Korrigieren/Anpassen eines bestehenden Templates mit minimalen, expliziten Änderungen
output: { corrected_template, diff_preview }
---

# Eingabe‑Template
{{input_template|Füge hier das vollständige Template als Markdown ein (inkl. Frontmatter „--- … ---“, Body und optional „--- systemprompt“).}}

# Änderungswünsche
{{changes|Welche Attribute sollen geändert werden? Z. B. Titel, Variablennamen, Reihenfolge/Abschnitte, Formulierungen, Sprache. Wenn leer ⇒ keine Änderungen.}}

# Konfiguration
{{allowed_scope|Erlaubte Bereiche: 'frontmatter' | 'body' | 'systemprompt' | 'all'.}}
{{diff_mode|Ausgabe: 'plain' (nur neues Template) oder 'diff' (kurzer Inline‑Diff).}}
{{preserve_comments|Kommentare/Hinweise beibehalten? 'ja' | 'nein'.}}

# Ergebnis
{{corrected_template|Gib hier das korrigierte Template als vollständige Markdown‑Datei zurück (inkl. Frontmatter; Body; optional --- systemprompt).}}
{{diff_preview|Wenn diff_mode=='diff': Kurz‑Diff als Markdown (~~alt~~, **neu**). Sonst "".}}

--- systemprompt
Du bist ein „Template‑Korrektor“. Du erhältst:
- input_template: komplettes Template als Markdown mit Struktur:
  - Frontmatter: YAML zwischen den ersten beiden „---“-Linien.
  - Body: Text nach dem Frontmatter bis optional „--- systemprompt“.
  - Variablen im Body: `{{varName|anweisung}}`.
- changes: präzise Änderungswünsche (kann leer sein).
- allowed_scope: eins aus {frontmatter, body, systemprompt, all}.
- diff_mode: 'plain' | 'diff'.
- preserve_comments: 'ja' | 'nein'.

Ziel:
- Erzeuge „corrected_template“: ein gültiges Template im selben Format wie input_template.
- Wenn „changes“ leer ist, gib input_template unverändert und byte‑treu zurück.
- Führe nur ausdrücklich angefragte Änderungen aus und ausschließlich innerhalb von allowed_scope.
- Erhalte alle übrigen Inhalte exakt: Reihenfolge, Whitespace, Überschriften, Variablensyntax `{{var|…}}`.
- Variablen nicht umbenennen/entfernen, außer explizit gefordert.
- Kommentare/Hinweise nur entfernen, wenn preserve_comments=='nein' UND explizit verlangt.
- Sprache: wie im input_template. Keine Erfindungen, keine externen Fakten.

Ausgabe (STRICT):
- Antworte mit GENAU EINEM JSON‑Objekt. Keine Prosa, keine Code‑Fences, keine Kommentare.
- UTF‑8, Standard‑JSON, keine trailing commas.
- Schlüssel MÜSSEN exakt lauten: "corrected_template", "diff_preview".
- Werte MÜSSEN Strings sein.
- Zeilenumbrüche MÜSSEN als \n innerhalb von JSON‑Strings codiert werden.
- Doppelte Anführungszeichen (\") und Backslashes (\\) korrekt escapen.
- Wenn diff_mode!='diff' ⇒ "diff_preview": "".

„corrected_template“:
- Vollständige Markdown‑Datei (Frontmatter; Body; optional --- systemprompt).
- Strukturell valide; Frontmatter‑Block oben, nur ein systemprompt‑Block (falls vorhanden).

„diff_preview“ (nur bei diff_mode=='diff'):
- Kurzer, inline lesbarer Diff als Markdown:
  - ~~gelöschte Teile~~
  - **hinzugefügte Teile**
- Kein Reflow unveränderter Absätze, nur minimaler Kontext.

Validierung:
- Das gesamte LLM‑Ergebnis MUSS valide JSON sein und exakt die Keys "corrected_template" und "diff_preview" enthalten.
- Bei mehrdeutigen oder nicht zulässigen Anforderungen (außerhalb allowed_scope) keine Änderung an diesen Teilen vornehmen; dennoch valides JSON liefern und das Original beibehalten.
```

---

**User**


Okay, wir haben jetzt unten bei diesem Prompt Design Abschnitt unten diese Buttons Vorschau und Speichern. Dort möchte ich jetzt einen neuen Button machen der heißt "Magic Design". Und wenn ich darauf klicke, habe ich in jedem Abschnitt "Aufgabe", "Metadaten" oder "Rollenanweisung" ein neues Freitextfeld in dezent "Rosa", wo ich einen Änderungswunsch eingeben kann. Und im Feld steht, "was möchtest du hier ändern?". 
Dann kann ich hier eine Änderungswunsch formulieren und mit "Magic absenden". 
Ich habe im templateverzeichnis das Template magicpromptdesign.md gespeichert, das wir gerade erstellt haben - damit können wir das gesamte Template neu berechnen und das Ergebnis wieder anzeigen. 

Haben wir diesen Änderungsflow von Templates mit dem Template "magicpromptdesign.md" verstanden? Können wir den hier nochmal wiederholen.


---

**Cursor**

```typescriptreact
"use client"

import { useState, useEffect, useCallback } from "react"
import { useForm } from "react-hook-form"
import { zodResolver } from "@hookform/resolvers/zod"
import * as z from "zod"
import { Button } from "@/components/ui/button"
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card"
import { Label } from "@/components/ui/label"
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select"
import { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from "@/components/ui/tooltip"
import { StructuredTemplateEditor } from "@/components/templates/structured-template-editor"
import { useToast } from "@/hooks/use-toast"
import { Loader2, Save, Eye, Play, FolderOpen, Info } from "lucide-react"
import { useAtom, useAtomValue } from "jotai"
import { activeLibraryAtom, libraryStatusAtom } from "@/atoms/library-atom"
import { 
  templatesAtom, 
  selectedTemplateNameAtom, 
  selectedTemplateAtom,
  templatesFolderIdAtom,
  templateLoadingAtom,
  templateErrorAtom,
  type Template
} from "@/atoms/template-atom"
import { useStorage } from "@/contexts/storage-context"
import { templateContextDocsAtom } from '@/atoms/template-context-atom'
import { Checkbox } from "@/components/ui/checkbox"
import { MarkdownPreview } from "@/components/library/markdown-preview"
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs"
import { JobReportTab } from "@/components/library/job-report-tab"
import { Textarea } from "@/components/ui/textarea"
import { Separator } from "@/components/ui/separator"

// Schema für Template-Daten
const templateSchema = z.object({
  name: z.string().min(1, "Prompt-Name ist erforderlich"),
  yamlFrontmatter: z.string(),
  markdownBody: z.string(),
  systemPrompt: z.string(),
})

type TemplateFormValues = z.infer<typeof templateSchema>

export function TemplateManagement() {
  const [previewMode, setPreviewMode] = useState(false)
  const [isSaving, setIsSaving] = useState(false)
  const [isTesting, setIsTesting] = useState(false)
  const [testResult, setTestResult] = useState<string | null>(null)
  const [selectedContextIds, setSelectedContextIds] = useState<string[]>([])
  const [selectedContextMarkdown, setSelectedContextMarkdown] = useState<string>("")
  const [rightTab, setRightTab] = useState<'kontext'|'preview'|'testen'>('kontext')
  const [resultSavedItemId, setResultSavedItemId] = useState<string | null>(null)
  const [freeText, setFreeText] = useState<string>("")
  // Magic Design
  const [magicMode, setMagicMode] = useState<boolean>(false)
  const [magicBody, setMagicBody] = useState<string>("")
  const [magicFrontmatter, setMagicFrontmatter] = useState<string>("")
  const [magicSystem, setMagicSystem] = useState<string>("")
  const [magicRunning, setMagicRunning] = useState<boolean>(false)
  const [magicLastDiff, setMagicLastDiff] = useState<string>("")
  const { toast } = useToast()

  // Atoms
  const [templates, setTemplates] = useAtom(templatesAtom)
  const [selectedTemplateName, setSelectedTemplateName] = useAtom(selectedTemplateNameAtom)
  const [selectedTemplate] = useAtom(selectedTemplateAtom)
  const [templatesFolderId, setTemplatesFolderId] = useAtom(templatesFolderIdAtom)
  const [isLoading, setIsLoading] = useAtom(templateLoadingAtom)
  const [error, setError] = useAtom(templateErrorAtom)

  // Library und Storage
  const activeLibrary = useAtomValue(activeLibraryAtom)
  const libraryStatus = useAtomValue(libraryStatusAtom)
  const { 
    provider: providerInstance, 
    listItems
  } = useStorage()
  const contextDocs = useAtomValue(templateContextDocsAtom)

  const form = useForm<TemplateFormValues>({
    resolver: zodResolver(templateSchema),
    defaultValues: {
      name: "",
      yamlFrontmatter: `---
title: {{title|Titel des Dokuments}}
tags: {{tags|Relevante Tags}}
date: {{date|Datum im Format yyyy-mm-dd}}
---`,
      markdownBody: `# {{title}}

## Zusammenfassung
{{summary|Kurze Zusammenfassung des Inhalts}}

## Details
{{details|Detaillierte Beschreibung}}`,
      systemPrompt: `You are a specialized assistant that processes and structures information clearly and concisely.

IMPORTANT: Your response must be a valid JSON object where each key corresponds to a template variable.`,
    },
  })

  // Helper zum Erzeugen von Default-Werten
  function getDefaultTemplateValues(name: string): TemplateFormValues {
    return {
      name,
      yamlFrontmatter: `---\n` +
        `title: {{title|Titel des Dokuments}}\n` +
        `tags: {{tags|Relevante Tags}}\n` +
        `date: {{date|Datum im Format yyyy-mm-dd}}\n` +
        `---`,
      markdownBody: `# {{title}}\n\n## Zusammenfassung\n{{summary|Kurze Zusammenfassung des Inhalts}}\n\n## Details\n{{details|Detaillierte Beschreibung}}`,
      systemPrompt: `You are a specialized assistant that processes and structures information clearly and concisely.\n\nIMPORTANT: Your response must be a valid JSON object where each key corresponds to a template variable.`,
    }
  }

  // Template-Daten laden wenn sich die Auswahl ändert
  useEffect(() => {
    if (selectedTemplate) {
      form.reset({
        name: selectedTemplate.name,
        yamlFrontmatter: selectedTemplate.yamlFrontmatter,
        markdownBody: selectedTemplate.markdownBody,
        systemPrompt: selectedTemplate.systemPrompt,
      })
    }
  }, [selectedTemplate, form])

  // Ordner-Erstellung/Suche memoisiert, damit als Dep verwendbar
  const ensureTemplatesFolder = useCallback(async (): Promise<string> => {
    if (!providerInstance || !activeLibrary) {
      throw new Error("Keine aktive Bibliothek oder Provider verfügbar");
    }

    try {
      console.log('[TemplateManagement] Suche nach Templates-Ordner...');
      const rootItems = await listItems('root');
      const templatesFolder = rootItems.find(item => 
        item.type === 'folder' && item.metadata.name === 'templates'
      );
      if (templatesFolder) {
        console.log('[TemplateManagement] Templates-Ordner gefunden:', templatesFolder.id);
        return templatesFolder.id;
      }
      console.log('[TemplateManagement] Templates-Ordner nicht gefunden, erstelle neuen...');
      const newFolder = await providerInstance.createFolder('root', 'templates');
      console.log('[TemplateManagement] Neuer Templates-Ordner erstellt:', newFolder.id);
      return newFolder.id;
    } catch (error) {
      console.error('Fehler beim Erstellen des Templates-Ordners:', {
        error: error instanceof Error ? {
          message: error.message,
          name: error.name,
          stack: error.stack?.split('\n').slice(0, 3)
        } : error,
        libraryId: activeLibrary?.id,
        libraryPath: activeLibrary?.path,
        providerName: providerInstance?.name
      });
      let errorMessage = 'Fehler beim Erstellen des Templates-Ordners';
      if (error instanceof Error) {
        if (error.message.includes('Nicht authentifiziert')) {
          errorMessage = 'Bitte authentifizieren Sie sich bei Ihrem Cloud-Speicher, um den Templates-Ordner zu erstellen.';
        } else if (error.message.includes('Keine Berechtigung')) {
          errorMessage = 'Keine Berechtigung zum Erstellen von Ordnern in der Bibliothek.';
        } else if (error.message.includes('Bibliothek nicht gefunden')) {
          errorMessage = 'Die ausgewählte Bibliothek wurde nicht gefunden.';
        } else {
          errorMessage = `Fehler beim Erstellen des Templates-Ordners: ${error.message}`;
        }
      }
      throw new Error(errorMessage);
    }
  }, [providerInstance, activeLibrary, listItems]);

  // Templates laden mit der gleichen Logik wie Library-Komponente
  const loadTemplates = useCallback(async () => {
    if (!providerInstance || libraryStatus !== 'ready' || !activeLibrary) {
      console.log('[TemplateManagement] loadTemplates übersprungen:', {
        hasProvider: !!providerInstance,
        libraryStatus,
        hasActiveLibrary: !!activeLibrary
      });
      return;
    }

    try {
      setIsLoading(true);
      setError(null);

      console.log('[TemplateManagement] Starte Prompt-Loading:', {
        libraryId: activeLibrary.id,
        libraryPath: activeLibrary.path,
        providerName: providerInstance.name
      });

      // 1. Templates-Ordner finden oder erstellen
      const folderId = await ensureTemplatesFolder();
      setTemplatesFolderId(folderId);

      console.log('[TemplateManagement] Templates-Ordner gefunden/erstellt:', folderId);

      // 2. Alle Template-Dateien im Ordner auflisten
      const items = await listItems(folderId);
      const templateFiles = items.filter(item => 
        item.type === 'file' && 
        item.metadata.name.endsWith('.md')
      );

      console.log('[TemplateManagement] Prompt-Dateien gefunden:', templateFiles.length);

      // 3. Template-Inhalte laden
      const templatePromises = templateFiles.map(async (file) => {
        try {
          const { blob } = await providerInstance.getBinary(file.id);
          const content = await blob.text();
          const template = parseTemplateContent(content, file.metadata.name.replace('.md', ''));
          
          return {
            ...template,
            fileId: file.id,
            lastModified: typeof file.metadata.modifiedAt === 'string' 
              ? file.metadata.modifiedAt 
              : file.metadata.modifiedAt instanceof Date 
                ? file.metadata.modifiedAt.toISOString()
                : new Date().toISOString()
          } as Template;
        } catch (error) {
          console.error(`Fehler beim Parsen von ${file.metadata.name}:`, error);
          return null;
        }
      });

      const loadedTemplates = await Promise.all(templatePromises);
      const validTemplates = loadedTemplates.filter((t): t is Template => t !== null);
      
      setTemplates(validTemplates);
      
      console.log('[TemplateManagement] Prompts erfolgreich geladen:', validTemplates.length);
      
      if (validTemplates.length === 0) {
        toast({
          title: "Keine Prompts gefunden",
          description: "Erstellen Sie Ihren ersten Prompt im Verzeichnis '/templates'.",
        });
      }
    } catch (error) {
      console.error('Fehler beim Laden der Prompts:', {
        error: error instanceof Error ? {
          message: error.message,
          name: error.name,
          stack: error.stack?.split('\n').slice(0, 3)
        } : error,
        libraryId: activeLibrary?.id,
        libraryPath: activeLibrary?.path,
        providerName: providerInstance?.name
      });

      let errorMessage = 'Unbekannter Fehler beim Laden der Prompts';
      
      if (error instanceof Error) {
        errorMessage = error.message;
        
        // Spezifische Fehlermeldungen für häufige Probleme
        if (error.message.includes('Nicht authentifiziert')) {
          errorMessage = 'Bitte authentifizieren Sie sich bei Ihrem Cloud-Speicher, um Prompts zu laden.';
        } else if (error.message.includes('Bibliothek nicht gefunden')) {
          errorMessage = 'Die ausgewählte Bibliothek wurde nicht gefunden. Bitte überprüfen Sie die Bibliothekskonfiguration.';
        } else if (error.message.includes('Server-Fehler')) {
          errorMessage = 'Server-Fehler beim Laden der Prompts. Bitte überprüfen Sie, ob der Bibliothekspfad existiert und zugänglich ist.';
        } else if (error.message.includes('Keine aktive Bibliothek')) {
          errorMessage = 'Keine aktive Bibliothek verfügbar. Bitte wählen Sie eine Bibliothek aus.';
        }
      }
      
      setError(errorMessage);
      toast({
        title: "Fehler beim Laden der Prompts",
        description: errorMessage,
        variant: "destructive",
      });
    } finally {
      setIsLoading(false);
    }
  }, [providerInstance, libraryStatus, activeLibrary, listItems, setTemplates, setTemplatesFolderId, setIsLoading, setError, toast, ensureTemplatesFolder]);

  // Effect für Template Loading (wie Library-Komponente)
  useEffect(() => {
    const isReady = providerInstance && libraryStatus === 'ready' && activeLibrary
    
    if (!isReady) {
      return
    }

    // Templates laden wenn noch nicht geladen
    if (!templatesFolderId) {
      loadTemplates()
    }
  }, [providerInstance, libraryStatus, activeLibrary, templatesFolderId, loadTemplates])

  // Reset wenn sich die Library ändert
  useEffect(() => {
    setSelectedTemplateName(null)
    setTemplatesFolderId(null)
    setTemplates([])
    setError(null)
  }, [libraryStatus, setSelectedTemplateName, setTemplatesFolderId, setTemplates, setError])

  useEffect(() => {
    async function loadSelectedContext() {
      if (!providerInstance || !Array.isArray(selectedContextIds) || selectedContextIds.length === 0) {
        setSelectedContextMarkdown("")
        return
      }
      try {
        const parts: string[] = []
        for (const id of selectedContextIds) {
          const { blob } = await providerInstance.getBinary(id)
          const text = await blob.text()
          const name = Array.isArray(contextDocs) ? (contextDocs.find(d => d.id === id)?.name || id) : id
          const section = `\n\n---\nDatei: ${name}\n---\n\n${text}\n\n---\nEnde Datei: ${name}\n---\n`
          parts.push(section)
        }
        setSelectedContextMarkdown(parts.join("\n\n"))
      } catch (e) {
        console.error('Fehler beim Laden des Kontextes', e)
        setSelectedContextMarkdown("")
      }
    }
    void loadSelectedContext()
  }, [providerInstance, selectedContextIds, contextDocs])

  function parseTemplateContent(content: string, fileName: string): Template {
    // Template in drei Bereiche aufteilen
    const parts = content.split('--- systemprompt')
    
    let yamlFrontmatter = ""
    let markdownBody = ""
    let systemPrompt = ""
    
    if (parts.length >= 2) {
      const mainContent = parts[0].trim()
      systemPrompt = parts[1].trim()
      
      // YAML Frontmatter extrahieren
      const yamlMatch = mainContent.match(/^---\r?\n([\s\S]*?)\r?\n---\r?\n?([\s\S]*)$/)
      if (yamlMatch) {
        yamlFrontmatter = `---\n${yamlMatch[1]}\n---`
        markdownBody = yamlMatch[2].trim()
      } else {
        // Kein YAML Frontmatter gefunden
        markdownBody = mainContent
      }
    } else {
      // Kein Systemprompt gefunden
      const yamlMatch = content.match(/^---\r?\n([\s\S]*?)\r?\n---\r?\n?([\s\S]*)$/)
      if (yamlMatch) {
        yamlFrontmatter = `---\n${yamlMatch[1]}\n---`
        markdownBody = yamlMatch[2].trim()
      } else {
        markdownBody = content
      }
    }

    return {
      name: fileName,
      yamlFrontmatter,
      markdownBody,
      systemPrompt,
    }
  }

  function generateTemplateContent(values: TemplateFormValues): string {
    let content = ""
    
    // YAML Frontmatter hinzufügen
    if (values.yamlFrontmatter.trim()) {
      content += values.yamlFrontmatter + "\n\n"
    }
    
    // Markdown Body hinzufügen
    content += values.markdownBody
    
    // System Prompt hinzufügen
    if (values.systemPrompt.trim()) {
      content += "\n\n--- systemprompt\n" + values.systemPrompt
    }
    
    return content
  }

  async function onSubmit(data: TemplateFormValues) {
    if (!activeLibrary || !templatesFolderId || !providerInstance) {
      toast({
        title: "Fehler",
        description: "Keine aktive Bibliothek oder Templates-Ordner nicht gefunden.",
        variant: "destructive",
      })
      return
    }

    setIsSaving(true)
    try {
      const templateContent = generateTemplateContent(data)
      const fileName = `${data.name}.md`
      
      console.group('[TemplateManagement] Speichern')
      console.log('Library', { id: activeLibrary.id, label: activeLibrary.label, path: activeLibrary.path })
      console.log('TemplatesFolderId', templatesFolderId)
      console.log('Datei', { fileName, contentLen: templateContent.length })
      
      // Falls Datei mit gleichem Namen existiert: erst löschen, dann neu schreiben
      const existing = templates.find(t => t.name.toLowerCase() === data.name.toLowerCase())
      if (existing?.fileId) {
        console.log('Bestehende Datei gefunden, lösche', { fileId: existing.fileId })
        try {
          await providerInstance.deleteItem(existing.fileId)
          console.log('Löschen OK')
        } catch (e) {
          console.error('Löschen fehlgeschlagen', e)
          toast({ title: 'Löschen fehlgeschlagen', description: e instanceof Error ? e.message : String(e), variant: 'destructive' })
        }
      } else {
        console.log('Keine bestehende Datei mit gleichem Namen gefunden')
      }
      
      // Datei als Blob erstellen und hochladen (Neu-Anlage / Ersetzen)
      const blob = new Blob([templateContent], { type: 'text/markdown' })
      const file = new File([blob], fileName, { type: 'text/markdown' })
      const uploaded = await providerInstance.uploadFile(templatesFolderId, file)
      console.log('Upload Ergebnis', uploaded)
      
      // Direkt nach Upload erneut lesen (Bypass-Stale) und lokalen State aktualisieren
      try {
        const { blob: rbBlob } = await providerInstance.getBinary(uploaded.id)
        const rbText = await rbBlob.text()
        console.log('Read-Back Länge', rbText.length, 'Auszug', rbText.slice(0, 120))
        const parsed = parseTemplateContent(rbText, data.name)
        const updated: Template = {
          ...parsed,
          fileId: uploaded.id,
          lastModified: new Date().toISOString()
        }
        setTemplates(((prev: Template[]) => {
          const rest = prev.filter((t: Template) => t.name.toLowerCase() !== data.name.toLowerCase())
          return [...rest, updated]
        }) as unknown as Template[])
      } catch (e) {
        console.warn('Read-Back nach Upload fehlgeschlagen', e)
      }
      
      // Kurze Wartezeit, damit Remote-Provider (OneDrive) Index/Cache aktualisiert
      await new Promise(r => setTimeout(r, 500))
      
      // Templates neu laden (finaler Sync mit Remote)
      await loadTemplates()
      console.log('Templates neu geladen')
      
      // Auswahl auf das neue Template setzen
      setSelectedTemplateName(data.name)
      console.log('Auswahl gesetzt', data.name)
      
      toast({
        title: "Prompt gespeichert",
        description: `"${data.name}" wurde aktualisiert.`,
      })
      console.groupEnd()
    } catch (error) {
      console.error('Fehler beim Speichern des Templates:', error)
      toast({
        title: "Fehler beim Speichern",
        description: error instanceof Error ? error.message : "Unbekannter Fehler",
        variant: "destructive",
      })
    } finally {
      setIsSaving(false)
    }
  }

  async function renameCurrentTemplate() {
    const current = selectedTemplateName ? templates.find(t => t.name === selectedTemplateName) : null
    if (!current || !current.fileId || !providerInstance) return
    const newName = (window.prompt('Neuen Namen eingeben:', current.name) || '').trim()
    if (!newName || newName === current.name) return
    if (/[^a-zA-Z0-9._\- ]/.test(newName)) { toast({ title: 'Ungültiger Name', description: 'Nur Buchstaben, Zahlen, Leerzeichen, . _ - sind erlaubt.', variant: 'destructive' }); return }
    if (templates.some(t => t.name.toLowerCase() === newName.toLowerCase())) { toast({ title: 'Bereits vorhanden', description: 'Bitte anderen Namen wählen.', variant: 'destructive' }); return }
    try {
      await providerInstance.renameItem(current.fileId, `${newName}.md`)
      await loadTemplates()
      setSelectedTemplateName(newName)
      form.setValue('name', newName, { shouldDirty: false })
      toast({ title: 'Umbenannt', description: `${current.name} → ${newName}` })
    } catch (e) {
      toast({ title: 'Fehler beim Umbenennen', description: e instanceof Error ? e.message : 'Unbekannter Fehler', variant: 'destructive' })
    }
  }

  async function deleteTemplate(templateName: string) {
    if (!activeLibrary || !providerInstance) return

    try {
      const template = templates.find(t => t.name === templateName)
      if (!template?.fileId) {
        throw new Error("Template-Datei nicht gefunden")
      }

      // Datei löschen
      await providerInstance.deleteItem(template.fileId)

      // Templates neu laden
      await loadTemplates()
      
      if (selectedTemplateName === templateName) {
        setSelectedTemplateName(null)
        form.reset()
      }
      
      toast({
        title: "Template gelöscht",
        description: `Template "${templateName}" wurde erfolgreich gelöscht.`,
      })
    } catch (error) {
      console.error('Fehler beim Löschen des Templates:', error)
      toast({
        title: "Fehler beim Löschen",
        description: error instanceof Error ? error.message : "Unbekannter Fehler",
        variant: "destructive",
      })
    }
  }

  async function createNewTemplate() {
    const name = (window.prompt('Neuen Template‑Namen eingeben:') || '').trim()
    if (!name) return
    if (/[^a-zA-Z0-9._\- ]/.test(name)) { toast({ title: 'Ungültiger Name', description: 'Nur Buchstaben, Zahlen, Leerzeichen, . _ - sind erlaubt.', variant: 'destructive' }); return }
    if (templates.some(t => t.name.toLowerCase() === name.toLowerCase())) { toast({ title: 'Bereits vorhanden', description: 'Bitte anderen Namen wählen.', variant: 'destructive' }); return }
    if (!providerInstance) { toast({ title: 'Kein Provider' , variant: 'destructive' }); return }
    try {
      const folderId = await ensureTemplatesFolder()
      const values = getDefaultTemplateValues(name)
      const content = (values.yamlFrontmatter ? values.yamlFrontmatter + '\n\n' : '') + values.markdownBody + '\n\n--- systemprompt\n' + values.systemPrompt
      const file = new File([new Blob([content], { type: 'text/markdown' })], `${name}.md`, { type: 'text/markdown' })
      await providerInstance.uploadFile(folderId, file)
      await loadTemplates()
      setSelectedTemplateName(name)
      form.reset(values)
      toast({ title: 'Template angelegt', description: `"${name}" wurde erstellt.` })
    } catch (e) {
      toast({ title: 'Fehler beim Anlegen', description: e instanceof Error ? e.message : 'Unbekannter Fehler', variant: 'destructive' })
    }
  }

  function generatePreview(): string {
    const values = form.getValues()
    return generateTemplateContent(values)
  }

  async function testTemplate() {
    if (!activeLibrary) return

    setIsTesting(true)
    setTestResult(null)

    const values = form.getValues()
    const templateContent = generateTemplateContent(values)
    const sections: string[] = []
    if (selectedContextMarkdown.trim()) sections.push(selectedContextMarkdown.trim())
    if (freeText.trim()) sections.push(`---\nDatei: Freitext\n---\n\n${freeText.trim()}\n\n---\nEnde Datei: Freitext\n---`)
    const testText = sections.join("\n\n")

    const pickMarkdown = (result: unknown): string => {
      if (typeof result === 'string') return result
      if (result && typeof result === 'object') {
        const obj = result as Record<string, unknown>
        const directCandidates = ['text','markdown','content','output'] as const
        for (const k of directCandidates) {
          const v = obj[k]
          if (typeof v === 'string') return v
        }
        // verschachtelte Felder prüfen
        const nested = obj['data']
        if (nested && typeof nested === 'object') {
          const nobj = nested as Record<string, unknown>
          for (const k of directCandidates) {
            const v = nobj[k]
            if (typeof v === 'string') return v
          }
        }
      }
      return JSON.stringify(result, null, 2)
    }

    try {
      const response = await fetch('/api/secretary/process-text', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/x-www-form-urlencoded',
          'X-Library-Id': activeLibrary.id,
        },
        body: new URLSearchParams({
          text: testText,
          template_content: templateContent,
          source_language: 'de',
          target_language: 'de',
          use_cache: 'false',
        }),
      })

      if (!response.ok) {
        const errorData = await response.json()
        throw new Error(errorData.error || `HTTP ${response.status}: ${response.statusText}`)
      }

      const result = await response.json()
      const formattedResult = pickMarkdown(result)
      console.log('Prompt-Test Ergebnis:', formattedResult)
      
      setTestResult(formattedResult)
      setRightTab('testen')

      toast({
        title: "Prompt-Test erfolgreich",
        description: "Der Prompt wurde erfolgreich mit dem gewählten Kontext verarbeitet.",
      })

      console.log('Prompt-Test Ergebnis (roh):', result)
    } catch (error) {
      console.error('Fehler beim Prompt-Test:', error)
      const errorMessage = error instanceof Error ? error.message : "Unbekannter Fehler"
      setTestResult(`Fehler: ${errorMessage}`)
      setRightTab('testen')
      toast({
        title: "Prompt-Test fehlgeschlagen",
        description: errorMessage,
        variant: "destructive",
      })
    } finally {
      setIsTesting(false)
    }
  }

  async function ensurePromptTestsFolder(): Promise<string> {
    if (!providerInstance) throw new Error('Kein Provider verfügbar')
    const roots = await listItems('root')
    const found = roots.find(it => it.type === 'folder' && it.metadata.name === 'prompt-tests')
    if (found) return found.id
    const created = await providerInstance.createFolder('root', 'prompt-tests')
    return created.id
  }

  async function saveTestResult() {
    try {
      if (!providerInstance || !activeLibrary || !testResult) return
      const folderId = await ensurePromptTestsFolder()
      const name = `${selectedTemplateName || 'prompt'}-test-${new Date().toISOString().replace(/[:.]/g,'-')}.md`
      const blob = new Blob([testResult], { type: 'text/markdown' })
      const file = new File([blob], name, { type: 'text/markdown' })
      const item = await providerInstance.uploadFile(folderId, file)
      setResultSavedItemId(item.id)
      toast({ title: 'Ergebnis gespeichert', description: name })
    } catch (e) {
      toast({ title: 'Speichern fehlgeschlagen', description: e instanceof Error ? e.message : 'Unbekannter Fehler', variant: 'destructive' })
    }
  }

  async function runMagicDesign() {
    if (!selectedTemplateName || !providerInstance || !activeLibrary) {
      toast({ title: 'Kein Prompt ausgewählt', description: 'Bitte wählen Sie zuerst einen Prompt.', variant: 'destructive' })
      return
    }
    const scopeParts: string[] = []
    if (magicFrontmatter.trim()) scopeParts.push('frontmatter')
    if (magicBody.trim()) scopeParts.push('body')
    if (magicSystem.trim()) scopeParts.push('systemprompt')
    const allowedScope = scopeParts.length === 0 ? 'all' : (scopeParts.length === 1 ? scopeParts[0] : 'all')

    try {
      setMagicRunning(true)
      // 1) Magic-Template laden (magicpromptdesign.md)
      const folderId = await ensureTemplatesFolder()
      const items = await listItems(folderId)
      const magicItem = items.find(it => it.type === 'file' && (it.metadata.name.toLowerCase() === 'magicpromptdesign.md'))
      if (!magicItem) {
        toast({ title: 'Magic-Template fehlt', description: 'magicpromptdesign.md nicht im /templates gefunden.', variant: 'destructive' })
        return
      }
      const { blob } = await providerInstance.getBinary(magicItem.id)
      const magicTemplateContent = await blob.text()

      // 2) Inputtext zusammenstellen
      const currentTemplate = generateTemplateContent(form.getValues())
      const inputText = [
        'INPUT_TEMPLATE:',
        currentTemplate,
        '',
        'CHANGES:',
        'Aufgabe:',
        magicBody || '(keine)',
        '',
        'Metadaten:',
        magicFrontmatter || '(keine)',
        '',
        'Rollenanweisung:',
        magicSystem || '(keine)',
        '',
        'CONFIG:',
        `allowed_scope: ${allowedScope}`,
        'diff_mode: diff',
        'preserve_comments: ja'
      ].join('\n')

      // 3) Secretary-Service aufrufen
      const response = await fetch('/api/secretary/process-text', {
        method: 'POST',
        headers: { 'Content-Type': 'application/x-www-form-urlencoded', 'X-Library-Id': activeLibrary.id },
        body: new URLSearchParams({
          text: inputText,
          template_content: magicTemplateContent,
          source_language: 'de',
          target_language: 'de'
        })
      })
      if (!response.ok) {
        const err = await response.json().catch(() => ({}))
        throw new Error(err?.error || `HTTP ${response.status}`)
      }
      const data = await response.json()
      // data kann string (JSON) oder object sein
      let corrected: string | undefined
      let diff: string = ''
      try {
        const obj = typeof data === 'string' ? JSON.parse(data) : (typeof data === 'object' ? data : {})
        corrected = typeof obj?.corrected_template === 'string' ? obj.corrected_template : undefined
        diff = typeof obj?.diff_preview === 'string' ? obj.diff_preview : ''
      } catch (e) {
        // Fallback: Wenn data.text existiert
        const maybe = (data && typeof data.text === 'string') ? JSON.parse(data.text) : null
        corrected = maybe?.corrected_template
        diff = maybe?.diff_preview || ''
      }
      if (!corrected) throw new Error('Antwort ohne corrected_template')

      // 4) Template parsen und Formular übernehmen
      const parsed = parseTemplateContent(corrected, selectedTemplateName)
      form.setValue('yamlFrontmatter', parsed.yamlFrontmatter, { shouldDirty: true })
      form.setValue('markdownBody', parsed.markdownBody, { shouldDirty: true })
      form.setValue('systemPrompt', parsed.systemPrompt, { shouldDirty: true })
      setMagicLastDiff(diff || '')
      toast({ title: 'Magic Design angewendet', description: 'Änderungen übernommen (nicht gespeichert).' })
    } catch (e) {
      toast({ title: 'Magic fehlgeschlagen', description: e instanceof Error ? e.message : 'Unbekannter Fehler', variant: 'destructive' })
    } finally {
      setMagicRunning(false)
    }
  }

  // Render-Logik für verschiedene Status
  if (libraryStatus === "waitingForAuth") {
    return (
      <div className="flex flex-col items-center justify-center h-full text-muted-foreground">
        <span>Diese Bibliothek benötigt eine Authentifizierung.</span>
        <span className="text-sm mt-2">Bitte konfigurieren Sie die Bibliothek in den Einstellungen.</span>
      </div>
    )
  }
  
  if (libraryStatus !== "ready") {
    return (
      <div className="flex flex-col items-center justify-center h-full text-muted-foreground">
        <span>Lade Storage...</span>
      </div>
    )
  }

  if (!activeLibrary) {
    return (
      <div className="text-center text-muted-foreground">
        Bitte wählen Sie eine Bibliothek aus.
      </div>
    )
  }

  if (error) {
    return (
      <div className="text-center text-destructive">
        <p>Fehler beim Laden der Prompts:</p>
        <p className="text-sm">{error}</p>
        <Button 
          variant="outline" 
          className="mt-4"
          onClick={loadTemplates}
        >
          Erneut versuchen
        </Button>
      </div>
    )
  }

  return (
    <div className="space-y-6">

      {/* Kompakte Toolbar oben */}
      <div className="flex items-center gap-2">
        <Select value={selectedTemplateName || ''} onValueChange={(v) => { setSelectedTemplateName(v); form.setValue('name', v, { shouldDirty: false }) }} disabled={isLoading}>
          <SelectTrigger className="w-64">
            <SelectValue placeholder="Prompt auswählen..." />
          </SelectTrigger>
          <SelectContent>
            {templates.map((t) => (
              <SelectItem key={t.name} value={t.name}>{t.name}</SelectItem>
            ))}
          </SelectContent>
        </Select>
        <TooltipProvider>
          <Tooltip>
            <TooltipTrigger asChild>
              <Button variant="ghost" size="sm" className="h-8 w-8 p-0"><Info className="h-4 w-4" /></Button>
            </TooltipTrigger>
            <TooltipContent>
              <div className="flex items-center gap-2"><FolderOpen className="h-4 w-4" /><span>Ort: /templates in „{activeLibrary.label}“</span></div>
            </TooltipContent>
          </Tooltip>
        </TooltipProvider>
        <Button type="button" variant="outline" size="sm" onClick={createNewTemplate} disabled={isLoading}>Neu</Button>
        <Button type="button" variant="outline" size="sm" onClick={renameCurrentTemplate} disabled={!selectedTemplateName}>Umbenennen</Button>
        {selectedTemplateName && (
          <Button type="button" variant="destructive" size="sm" onClick={() => deleteTemplate(selectedTemplateName!)}>Löschen</Button>
        )}
      </div>

      <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
        <Card>
          <CardHeader>
            <CardTitle>Prompt Design</CardTitle>
            <CardDescription>
              Drei Bereiche: Aufgabe (was), Rollenanweisung (wie), Metadaten (Begleitinfos).
            </CardDescription>
          </CardHeader>
          <CardContent>
            <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-6">
              {/* Template-Name Feld entfernt (oben verwaltet) */}

              {!selectedTemplateName ? (
                <div className="rounded-md border border-dashed p-6 text-sm text-muted-foreground">
                  Bitte oben einen Prompt auswählen oder Neu anlegen.
                </div>
              ) : previewMode ? (
                <div className="space-y-4">
                  <div className="flex items-center justify-between">
                    <h4 className="text-sm font-medium">Prompt-Vorschau</h4>
                    <Button
                      type="button"
                      variant="outline"
                      size="sm"
                      onClick={() => setPreviewMode(false)}
                    >
                      Bearbeiten
                    </Button>
                  </div>
                  <div className="border rounded-md p-4 bg-muted/50">
                    <pre className="text-sm whitespace-pre-wrap font-mono">
                      {generatePreview()}
                    </pre>
                  </div>
                </div>
              ) : (
                <>
                  {magicMode && (
                    <div className="space-y-3">
                      <div className="text-sm font-medium">Magic Design – Änderungswünsche</div>
                      <div className="grid md:grid-cols-3 gap-3">
                        <div className="space-y-1">
                          <Label>Aufgabe</Label>
                          <Textarea value={magicBody} onChange={(e) => setMagicBody(e.target.value)} placeholder="Was möchtest du hier ändern?" className="min-h-[90px] bg-pink-50 dark:bg-pink-950/20 border-pink-300" />
                        </div>
                        <div className="space-y-1">
                          <Label>Metadaten</Label>
                          <Textarea value={magicFrontmatter} onChange={(e) => setMagicFrontmatter(e.target.value)} placeholder="Was möchtest du hier ändern?" className="min-h-[90px] bg-pink-50 dark:bg-pink-950/20 border-pink-300" />
                        </div>
                        <div className="space-y-1">
                          <Label>Rollenanweisung</Label>
                          <Textarea value={magicSystem} onChange={(e) => setMagicSystem(e.target.value)} placeholder="Was möchtest du hier ändern?" className="min-h-[90px] bg-pink-50 dark:bg-pink-950/20 border-pink-300" />
                        </div>
                      </div>
                      <div className="flex justify-end gap-2">
                        <Button type="button" variant="secondary" onClick={() => { setMagicBody(''); setMagicFrontmatter(''); setMagicSystem(''); setMagicLastDiff('') }} disabled={magicRunning}>Zurücksetzen</Button>
                        <Button type="button" onClick={runMagicDesign} disabled={magicRunning || (!magicBody && !magicFrontmatter && !magicSystem)}>
                          {magicRunning ? (<><Loader2 className="h-4 w-4 mr-2 animate-spin" /> Magic läuft…</>) : 'Magic absenden'}
                        </Button>
                      </div>
                      {magicLastDiff && (
                        <div className="space-y-1">
                          <Label>Diff‑Vorschau</Label>
                          <div className="border rounded-md p-3 bg-muted/40">
                            <MarkdownPreview content={magicLastDiff} />
                          </div>
                        </div>
                      )}
                      <Separator className="my-2" />
                    </div>
                  )}
                  <StructuredTemplateEditor
                    markdownBody={form.watch('markdownBody')}
                    yamlFrontmatter={form.watch('yamlFrontmatter')}
                    systemPrompt={form.watch('systemPrompt')}
                    onChange={({ markdownBody, yamlFrontmatter, systemPrompt }) => {
                      form.setValue('markdownBody', markdownBody, { shouldDirty: true })
                      form.setValue('yamlFrontmatter', yamlFrontmatter, { shouldDirty: true })
                      form.setValue('systemPrompt', systemPrompt, { shouldDirty: true })
                    }}
                  />
                </>
              )}

              <div className="flex justify-end gap-2">
                {selectedTemplateName && (
                  <Button type="button" variant={magicMode ? 'secondary' : 'outline'} onClick={() => setMagicMode(v => !v)}>
                    {magicMode ? 'Magic Design ausblenden' : 'Magic Design'}
                  </Button>
                )}
                <Button
                  type="button"
                  variant="outline"
                  onClick={() => setPreviewMode(!previewMode)}
                  disabled={!selectedTemplateName}
                >
                  <Eye className="h-4 w-4 mr-2" />
                  {previewMode ? "Bearbeiten" : "Vorschau"}
                </Button>
                <Button
                  type="submit"
                  disabled={!selectedTemplateName || isSaving || !form.formState.isDirty}
                >
                  {isSaving ? (
                    <>
                      <Loader2 className="h-4 w-4 mr-2 animate-spin" />
                      Wird gespeichert...
                    </>
                  ) : (
                    <>
                      <Save className="h-4 w-4 mr-2" />
                      Speichern
                    </>
                  )}
                </Button>
              </div>
            </form>
          </CardContent>
        </Card>

        <Card>
          <CardHeader>
            <CardTitle>Prompt testen</CardTitle>
            <CardDescription>
              Test mit Beispieltext. Nutzt Rollenanweisung, Aufgabe und Metadaten des Prompts.
            </CardDescription>
          </CardHeader>
          <CardContent>
            {!selectedTemplateName ? (
              <div className="rounded-md border border-dashed p-6 text-sm text-muted-foreground">
                Bitte oben einen Prompt auswählen. Die Vorschau und Test‑Funktionen werden erst danach aktiviert.
              </div>
            ) : (
              <Tabs value={rightTab} onValueChange={(v) => setRightTab(v as typeof rightTab)}>
                <TabsList className="grid grid-cols-3 w-full">
                  <TabsTrigger value="kontext">Daten‑Kontext</TabsTrigger>
                  <TabsTrigger value="preview">Prompt‑Vorschau</TabsTrigger>
                  <TabsTrigger value="testen">Testen</TabsTrigger>
                </TabsList>

                <TabsContent value="kontext" className="space-y-4 mt-4">
                  <div className="space-y-2">
                    <Label>Kontext-Texte</Label>
                    <div className="border rounded p-2 text-sm">
                      {Array.isArray(contextDocs) && contextDocs.length > 0 ? (
                        contextDocs.map(d => {
                          const checked = selectedContextIds.includes(d.id)
                          return (
                            <label key={d.id} className="flex items-center gap-2 py-1">
                              <Checkbox
                                checked={checked}
                                onCheckedChange={(v) => {
                                  const isOn = v === true
                                  setSelectedContextIds(prev => isOn ? [...prev, d.id] : prev.filter(x => x !== d.id))
                                }}
                              />
                              <span className="truncate">{d.name}</span>
                            </label>
                          )
                        })
                      ) : (
                        <div className="text-muted-foreground text-sm">Keine Kontext-Texte verfügbar</div>
                      )}
                    </div>
                  </div>

                  <div className="space-y-2">
                    <Label>Gewählter Kontext (Lesemodus)</Label>
                    <div className="border rounded-md">
                      <MarkdownPreview content={selectedContextMarkdown} />
                    </div>
                  </div>

                  <div className="space-y-2">
                    <Label>Freitext (optional)</Label>
                    <Textarea
                      value={freeText}
                      onChange={(e) => setFreeText(e.target.value)}
                      placeholder="Hier Text einkleben, um schnell zu testen"
                      className="min-h-[120px] font-mono text-sm"
                    />
                  </div>
                </TabsContent>

                <TabsContent value="preview" className="space-y-4 mt-4">
                  <div className="space-y-2">
                    <Label>Generierter Prompt (Markdown)</Label>
                    <div className="border rounded-md">
                      <MarkdownPreview content={generatePreview()} />
                    </div>
                  </div>
                  <div className="flex gap-2 justify-end">
                    <Button 
                      variant="outline" 
                      size="sm"
                      onClick={testTemplate}
                      disabled={!selectedTemplateName || isTesting}
                    >
                      {isTesting ? (
                        <>
                          <Loader2 className="h-4 w-4 mr-2 animate-spin" />
                          Teste...
                        </>
                      ) : (
                        <>
                          <Play className="h-4 w-4 mr-2" />
                          Prompt testen
                        </>
                      )}
                    </Button>
                  </div>
                </TabsContent>

                <TabsContent value="testen" className="space-y-4 mt-4">
                  <div className="flex gap-2 justify-end">
                    <Button 
                      variant="outline" 
                      size="sm"
                      onClick={testTemplate}
                      disabled={!selectedTemplateName || isTesting}
                    >
                      {isTesting ? (
                        <>
                          <Loader2 className="h-4 w-4 mr-2 animate-spin" />
                          Teste...
                        </>
                      ) : (
                        <>
                          <Play className="h-4 w-4 mr-2" />
                          Prompt testen
                        </>
                      )}
                    </Button>
                  </div>
                  {activeLibrary && providerInstance && (testResult || resultSavedItemId) ? (
                    <JobReportTab
                      libraryId={activeLibrary.id}
                      fileId={resultSavedItemId || 'preview'}
                      provider={providerInstance}
                      sourceMode="frontmatter"
                      viewMode="metaOnly"
                      mdFileId={resultSavedItemId || undefined}
                      rawContent={testResult || undefined}
                    />
                  ) : (
                    <div className="text-sm text-muted-foreground">Kein Ergebnis vorhanden.</div>
                  )}
                  <div className="flex gap-2">
                    <Button type="button" onClick={saveTestResult} disabled={!testResult}>Speichern</Button>
                  </div>
                </TabsContent>
              </Tabs>
            )}
          </CardContent>
        </Card>
      </div>
    </div>
  )
} 
```

- Verständnis des Flows: Ja. „Magic Design“ sammelt Änderungswünsche je Bereich (Aufgabe/Metadaten/Rollenanweisung), ruft mit dem Template `magicpromptdesign.md` den Secretary an, und übernimmt das korrigierte Template in den Editor. Diff‑Vorschau wird optional angezeigt; Speichern bleibt manuell.
- Implementiert:
  - Neuer Button „Magic Design“ im Prompt‑Design.
  - Drei dezente rosa Freitextfelder pro Bereich mit Platzhalter „Was möchtest du hier ändern?“
  - „Magic absenden“ startet den Aufruf:
    - Lädt `magicpromptdesign.md` aus `/templates`
    - Baut Eingabetext (Original‑Template + Änderungswünsche + Config)
    - POST an `/api/secretary/process-text` mit `template_content`
    - Übernimmt `corrected_template` in Editor; zeigt `diff_preview` unten
  - „Zurücksetzen“ leert die Änderungsfelder und Diff.
  - Magic‑State und Ladespinner; deaktiviert ohne Prompt.

Damit kannst du interaktiv kleine, explizite Anpassungen am bestehenden Template durchführen, treu zum Original und ohne Fallbacks.

---

**User**

Die rosa-roten Felder sollten innerhalb der bestehenden Tabgroups "Aufgabe" "Metadaten" und "Rollenanweisungen" jeweils oben in der ganzen Breite angezeigt werden. 

---

**Cursor**

Ich platziere die Magic-Freitextfelder direkt innerhalb der Tabs „Aufgabe“, „Metadaten“ und „Rollenanweisung“ am oberen Rand und passe die Props/Render-Logik an. Danach prüfe ich den Linter.

Ich verschiebe die Magic-Freitextfelder in die Tabs des Editors und passe die Props/Renderlogik an. Danach verschiebe ich den „Magic absenden“-Button in die Fußzeile der Form. Ich prüfe anschließend auf Linterfehler.

```typescriptreact
"use client";

import * as React from 'react'
// Hinweis: Body-Parsing erfolgt zeilenbasiert direkt in dieser Komponente
import { parseFrontmatterKeyValues } from '@/lib/markdown/frontmatter'
import { Button } from '@/components/ui/button'
import { Label } from '@/components/ui/label'
import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from '@/components/ui/table'
import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs'
import { GripVertical, Plus } from 'lucide-react'
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select'
import { MarkdownPreview } from '@/components/library/markdown-preview'
import { Textarea } from '@/components/ui/textarea'

export interface StructuredTemplateEditorProps {
  markdownBody: string
  yamlFrontmatter: string
  systemPrompt: string
  onChange: (next: { markdownBody: string; yamlFrontmatter: string; systemPrompt: string }) => void
  magicMode?: boolean
  magicValues?: { body: string; frontmatter: string; system: string }
  onMagicChange?: (next: { body?: string; frontmatter?: string; system?: string }) => void
}

type LineKind = 'text' | 'h1' | 'h2' | 'h3' | 'bold' | 'variable'

export function StructuredTemplateEditor({ markdownBody, yamlFrontmatter, systemPrompt, onChange, magicMode, magicValues, onMagicChange }: StructuredTemplateEditorProps) {
  const lines = React.useMemo(() => (typeof markdownBody === 'string' ? markdownBody.split('\n') : []), [markdownBody])
  const fmEntries = React.useMemo(() => parseFrontmatterKeyValues(yamlFrontmatter || ''), [yamlFrontmatter])
  const [sysPrompt, setSysPrompt] = React.useState(systemPrompt)
  const [tab, setTab] = React.useState<'body'|'frontmatter'|'system'>('body')
  const dragFrom = React.useRef<number | null>(null)
  const [sysEditing, setSysEditing] = React.useState(false)

  React.useEffect(() => { setSysPrompt(systemPrompt) }, [systemPrompt])

  // Zeilenbasierte Platzhalter-Erkennung (nur die betrachtete Zeile)
  function parseLine(line: string): { kind: LineKind; varKey: string; content: string } {
    const mVar = /^\s*\{\{([^}|]+)\|([^}]+)\}\}\s*$/.exec(line)
    if (mVar) return { kind: 'variable', varKey: (mVar[1] || '').trim(), content: (mVar[2] || '').trim() }
    if (/^\s*###\s+/.test(line)) return { kind: 'h3', varKey: '', content: line.replace(/^\s*###\s+/, '') }
    if (/^\s*##\s+/.test(line)) return { kind: 'h2', varKey: '', content: line.replace(/^\s*##\s+/, '') }
    if (/^\s*#\s+/.test(line)) return { kind: 'h1', varKey: '', content: line.replace(/^\s*#\s+/, '') }
    const mBold = /^\s*\*\*([\s\S]*?)\*\*\s*$/.exec(line)
    if (mBold) return { kind: 'bold', varKey: '', content: (mBold[1] || '') }
    return { kind: 'text', varKey: '', content: line }
  }

  function buildLine(kind: LineKind, content: string, varKey?: string): string {
    const text = content ?? ''
    switch (kind) {
      case 'variable': {
        const k = (varKey || '').trim()
        return k ? `{{${k}|${text}}}` : text
      }
      case 'h1': return `# ${text}`
      case 'h2': return `## ${text}`
      case 'h3': return `### ${text}`
      case 'bold': return `**${text}**`
      case 'text': default: return text
    }
  }

  function updateLineByIndex(lineIndex: number, nextLine: string) {
    const copy = lines.slice()
    if (lineIndex >= 0 && lineIndex < copy.length) copy[lineIndex] = nextLine
    onChange({ markdownBody: copy.join('\n'), yamlFrontmatter, systemPrompt: sysPrompt })
  }

  function suggestVarKey(index: number, content: string): string {
    const base = (content || '').toLowerCase().trim().replace(/[^a-z0-9]+/g, '_').replace(/^_+|_+$/g, '')
    const trimmed = base.length >= 3 ? base.slice(0, 24) : ''
    return trimmed || `var_${index + 1}`
  }

  function updateLineKind(lineIndex: number, nextKind: LineKind) {
    if (lineIndex < 0 || lineIndex >= lines.length) return
    const { content, varKey } = parseLine(lines[lineIndex])
    if (nextKind === 'variable') {
      const key = varKey && varKey.trim().length > 0 ? varKey : suggestVarKey(lineIndex, content)
      updateLineByIndex(lineIndex, buildLine('variable', content, key))
      return
    }
    updateLineByIndex(lineIndex, buildLine(nextKind, content, varKey))
  }

  function updateVarKey(lineIndex: number, nextKey: string) {
    if (lineIndex < 0 || lineIndex >= lines.length) return
    const { content } = parseLine(lines[lineIndex])
    const realKind: LineKind = 'variable'
    updateLineByIndex(lineIndex, buildLine(realKind, content, nextKey))
  }

  function updateContent(lineIndex: number, nextContent: string) {
    if (lineIndex < 0 || lineIndex >= lines.length) return
    const { kind, varKey } = parseLine(lines[lineIndex])
    updateLineByIndex(lineIndex, buildLine(kind, nextContent, varKey))
  }

  // Drag & Drop für Zeilenreihenfolge
  function handleDragStart(e: React.DragEvent, fromIndex: number) {
    e.dataTransfer.setData('text/plain', String(fromIndex))
    e.dataTransfer.effectAllowed = 'move'
  }
  function handleDragOver(e: React.DragEvent) {
    e.preventDefault()
    e.dataTransfer.dropEffect = 'move'
  }
  function handleDrop(e: React.DragEvent, toIndex: number) {
    e.preventDefault()
    const fromStr = e.dataTransfer.getData('text/plain')
    const fromIndex = Number.isInteger(Number(fromStr)) ? parseInt(fromStr, 10) : -1
    if (fromIndex < 0 || fromIndex === toIndex) return
    const arr = lines.slice()
    const [moved] = arr.splice(fromIndex, 1)
    arr.splice(toIndex, 0, moved)
    onChange({ markdownBody: arr.join('\n'), yamlFrontmatter, systemPrompt: sysPrompt })
  }

  function addLineAfter(index: number) {
    const arr = lines.slice()
    arr.splice(index + 1, 0, '')
    onChange({ markdownBody: arr.join('\n'), yamlFrontmatter, systemPrompt: sysPrompt })
  }

  const updateFrontmatterQuestion = (entryKey: string, question: string) => {
    const linesFM = (yamlFrontmatter || '').split('\n')
    const idx = linesFM.findIndex(l => new RegExp(`^${escapeRegExp(entryKey)}\\s*:`).test(l.trim()))
    if (idx >= 0) {
      const line = linesFM[idx]
      const m = /\{\{([^}|]+)\|([^}]+)\}\}/.exec(line)
      if (m) {
        linesFM[idx] = line.replace(m[0], `{{${m[1]}|${question}}}`)
      }
      onChange({ markdownBody, yamlFrontmatter: linesFM.join('\n'), systemPrompt: sysPrompt })
    }
  }

  const handleSysPromptChange = (v: string) => {
    setSysPrompt(v)
    onChange({ markdownBody, yamlFrontmatter, systemPrompt: v })
  }

  return (
    <div className="space-y-3">
      <Tabs value={tab} onValueChange={(v) => setTab(v as typeof tab)}>
        <TabsList className="grid grid-cols-3 w-full">
          <TabsTrigger value="body">Aufgabe</TabsTrigger>
          <TabsTrigger value="frontmatter">Metadaten</TabsTrigger>
          <TabsTrigger value="system">Rollenanweisung</TabsTrigger>
        </TabsList>

        <TabsContent value="body">
          {magicMode ? (
            <div className="mb-3 space-y-1">
              <Label>Änderungswunsch (Aufgabe)</Label>
              <Textarea
                value={magicValues?.body ?? ''}
                onChange={(e) => onMagicChange?.({ body: e.target.value })}
                placeholder="Was möchtest du hier ändern?"
                className="w-full min-h-[90px] bg-pink-50 dark:bg-pink-950/20 border-pink-300"
              />
            </div>
          ) : null}
          <div className="overflow-auto">
            <Table className="text-[11px] w-full border-collapse">
              <TableHeader>
                <TableRow className="[&>*]:py-1">
                  <TableHead className="w-8" />
                  <TableHead className="w-36">Typ/Variable</TableHead>
                  <TableHead>Text / Frage</TableHead>
                </TableRow>
              </TableHeader>
              <TableBody>
                {lines.length === 0 ? (
                  <TableRow><TableCell colSpan={3} className="text-muted-foreground">Keine Zeilen im Body.</TableCell></TableRow>
                ) : lines.map((line, i) => {
                  const { kind, varKey, content } = parseLine(line)
                  return (
                    <TableRow key={`line-${i}`} className="align-top" onDragOver={handleDragOver} onDrop={(e) => handleDrop(e, i)}>
                      <TableCell className="align-top w-8 py-1">
                        <div className="flex items-center gap-1">
                          <span
                            draggable
                            onDragStart={(e) => handleDragStart(e, i)}
                            className="inline-flex h-4 w-4 items-center justify-center text-muted-foreground cursor-grab hover:text-foreground"
                            title="Ziehen zum Verschieben"
                            aria-label="Ziehen zum Verschieben"
                          >
                            <GripVertical className="h-3 w-3" />
                          </span>
                          <button
                            type="button"
                            className="inline-flex h-4 w-4 items-center justify-center text-muted-foreground hover:text-foreground"
                            title="Zeile darunter einfügen"
                            aria-label="Zeile darunter einfügen"
                            onClick={() => addLineAfter(i)}
                          >
                            <Plus className="h-3 w-3" />
                          </button>
                        </div>
                      </TableCell>
                      <TableCell className="align-top w-36 py-1">
                        <div className="flex flex-col gap-1">
                          <Select value={kind} onValueChange={(v) => updateLineKind(i, v as LineKind)}>
                            <SelectTrigger className="h-7 text-[11px]">
                              <SelectValue placeholder="Text" />
                            </SelectTrigger>
                            <SelectContent>
                              <SelectItem value="text">Text</SelectItem>
                              <SelectItem value="h1">Heading 1</SelectItem>
                              <SelectItem value="h2">Heading 2</SelectItem>
                              <SelectItem value="h3">Heading 3</SelectItem>
                              <SelectItem value="bold">Bold</SelectItem>
                              <SelectItem value="variable">Variable</SelectItem>
                            </SelectContent>
                          </Select>
                          {kind === 'variable' ? (
                            <EditableTextarea
                              value={varKey}
                              onChange={(v) => updateVarKey(i, v)}
                              onBlur={() => {}}
                            />
                          ) : null}
                        </div>
                      </TableCell>
                      <TableCell className="align-top py-1">
                        <InlineEditableCell
                          value={content}
                          onChange={(val) => updateContent(i, val)}
                          placeholder={kind === 'variable' ? 'Frage/Beschreibung' : 'Markdown-Text'}
                        />
                      </TableCell>
                    </TableRow>
                  )
                })}
              </TableBody>
            </Table>
          </div>
        </TabsContent>

        <TabsContent value="frontmatter">
          {magicMode ? (
            <div className="mb-3 space-y-1">
              <Label>Änderungswunsch (Metadaten)</Label>
              <Textarea
                value={magicValues?.frontmatter ?? ''}
                onChange={(e) => onMagicChange?.({ frontmatter: e.target.value })}
                placeholder="Was möchtest du hier ändern?"
                className="w-full min-h-[90px] bg-pink-50 dark:bg-pink-950/20 border-pink-300"
              />
            </div>
          ) : null}
          <div className="max-h-[50vh] overflow-auto rounded border">
            <table className="w-full text-[11px] border-collapse">
              <thead className="sticky top-0 bg-background">
                <tr>
                  <th className="w-40 text-left px-2 py-1">Feld</th>
                  <th className="w-40 text-left px-2 py-1">Variable</th>
                  <th className="text-left px-2 py-1">Hinweis</th>
                </tr>
              </thead>
              <tbody>
                {fmEntries.length === 0 ? (
                  <tr><td colSpan={3} className="px-2 py-1 text-muted-foreground">Keine Felder im Frontmatter.</td></tr>
                ) : fmEntries.map((e, i) => {
                  const m = /\{\{([^}|]+)\|([^}]+)\}\}/.exec(e.rawValue)
                  const varKey = m ? m[1].trim() : ''
                  const varQ = m ? m[2].trim() : ''
                  return (
                    <tr key={`${e.key}-${i}`} className="align-top">
                      <td className="px-2 py-1 align-top font-mono">{e.key}</td>
                      <td className="px-2 py-1 align-top font-mono">{varKey}</td>
                      <td className="px-2 py-1 align-top">
                        <InlineEditableCell
                          value={varQ}
                          onChange={(val) => updateFrontmatterQuestion(e.key, val)}
                          placeholder="Klicken zum Bearbeiten"
                        />
                      </td>
                    </tr>
                  )
                })}
              </tbody>
            </table>
          </div>
        </TabsContent>

        <TabsContent value="system">
          {magicMode ? (
            <div className="mb-3 space-y-1">
              <Label>Änderungswunsch (Rollenanweisung)</Label>
              <Textarea
                value={magicValues?.system ?? ''}
                onChange={(e) => onMagicChange?.({ system: e.target.value })}
                placeholder="Was möchtest du hier ändern?"
                className="w-full min-h-[90px] bg-pink-50 dark:bg-pink-950/20 border-pink-300"
              />
            </div>
          ) : null}
          <div className="space-y-2">
            <Label>Rollenanweisung</Label>
            {!sysEditing ? (
              <div role="button" onClick={() => setSysEditing(true)} className="border rounded-md">
                <MarkdownPreview content={sysPrompt || ''} />
              </div>
            ) : (
              <EditableTextarea
                value={sysPrompt}
                onChange={handleSysPromptChange}
                onBlur={() => setSysEditing(false)}
              />
            )}
          </div>
        </TabsContent>
      </Tabs>
    </div>
  )
}

function escapeRegExp(s: string): string {
  return s.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')
}

// Inline-Edit Textarea, wächst dynamisch, aktiviert Edit bei Fokus/Klick
function EditableTextarea({ value, onChange, onBlur, onKeyDown }: { value: string; onChange: (v: string) => void; onBlur?: () => void; onKeyDown?: (e: React.KeyboardEvent<HTMLTextAreaElement>) => void }) {
  const [local, setLocal] = React.useState(value)
  const ref = React.useRef<HTMLTextAreaElement | null>(null)

  const autosize = React.useCallback(() => {
    const el = ref.current
    if (!el) return
    el.style.height = 'auto'
    el.style.height = `${el.scrollHeight}px`
  }, [])

  React.useEffect(() => { setLocal(value); requestAnimationFrame(autosize) }, [value, autosize])

  return (
    <textarea
      ref={ref}
      value={local}
      onChange={(e) => { setLocal(e.target.value); onChange(e.target.value); autosize() }}
      onInput={autosize}
      onBlur={onBlur}
      onKeyDown={onKeyDown}
      className="w-full min-h-[2.5rem] rounded-md border bg-background px-2 py-1 text-[11px] leading-snug overflow-hidden"
      style={{ resize: 'none' }}
    />
  )
}

// Zelle, die erst beim Klick in den Editiermodus mit autosizender Textarea wechselt
function InlineEditableCell({ value, onChange, placeholder }: { value: string; onChange: (v: string) => void; placeholder?: string }) {
  const [editing, setEditing] = React.useState(false)

  if (!editing) {
    return (
      <div
        role="button"
        onClick={() => setEditing(true)}
        className="cursor-text whitespace-pre-wrap break-words rounded-md px-2 py-1 min-h-[2.5rem]"
      >
        {value ? value : <span className="text-muted-foreground">{placeholder || 'Klicken zum Bearbeiten'}</span>}
      </div>
    )
  }

  return (
    <EditableTextarea
      value={value}
      onChange={onChange}
      onBlur={() => setEditing(false)}
      onKeyDown={(e) => { if (e.key === 'Escape') { e.preventDefault(); e.stopPropagation(); setEditing(false) } }}
    />
  )
}


```

```typescriptreact
"use client"

import { useState, useEffect, useCallback } from "react"
import { useForm } from "react-hook-form"
import { zodResolver } from "@hookform/resolvers/zod"
import * as z from "zod"
import { Button } from "@/components/ui/button"
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card"
import { Label } from "@/components/ui/label"
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select"
import { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from "@/components/ui/tooltip"
import { StructuredTemplateEditor } from "@/components/templates/structured-template-editor"
import { useToast } from "@/hooks/use-toast"
import { Loader2, Save, Eye, Play, FolderOpen, Info } from "lucide-react"
import { useAtom, useAtomValue } from "jotai"
import { activeLibraryAtom, libraryStatusAtom } from "@/atoms/library-atom"
import { 
  templatesAtom, 
  selectedTemplateNameAtom, 
  selectedTemplateAtom,
  templatesFolderIdAtom,
  templateLoadingAtom,
  templateErrorAtom,
  type Template
} from "@/atoms/template-atom"
import { useStorage } from "@/contexts/storage-context"
import { templateContextDocsAtom } from '@/atoms/template-context-atom'
import { Checkbox } from "@/components/ui/checkbox"
import { MarkdownPreview } from "@/components/library/markdown-preview"
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs"
import { JobReportTab } from "@/components/library/job-report-tab"
import { Textarea } from "@/components/ui/textarea"
import { Separator } from "@/components/ui/separator"

// Schema für Template-Daten
const templateSchema = z.object({
  name: z.string().min(1, "Prompt-Name ist erforderlich"),
  yamlFrontmatter: z.string(),
  markdownBody: z.string(),
  systemPrompt: z.string(),
})

type TemplateFormValues = z.infer<typeof templateSchema>

export function TemplateManagement() {
  const [previewMode, setPreviewMode] = useState(false)
  const [isSaving, setIsSaving] = useState(false)
  const [isTesting, setIsTesting] = useState(false)
  const [testResult, setTestResult] = useState<string | null>(null)
  const [selectedContextIds, setSelectedContextIds] = useState<string[]>([])
  const [selectedContextMarkdown, setSelectedContextMarkdown] = useState<string>("")
  const [rightTab, setRightTab] = useState<'kontext'|'preview'|'testen'>('kontext')
  const [resultSavedItemId, setResultSavedItemId] = useState<string | null>(null)
  const [freeText, setFreeText] = useState<string>("")
  // Magic Design
  const [magicMode, setMagicMode] = useState<boolean>(false)
  const [magicBody, setMagicBody] = useState<string>("")
  const [magicFrontmatter, setMagicFrontmatter] = useState<string>("")
  const [magicSystem, setMagicSystem] = useState<string>("")
  const [magicRunning, setMagicRunning] = useState<boolean>(false)
  const [magicLastDiff, setMagicLastDiff] = useState<string>("")
  const { toast } = useToast()

  // Atoms
  const [templates, setTemplates] = useAtom(templatesAtom)
  const [selectedTemplateName, setSelectedTemplateName] = useAtom(selectedTemplateNameAtom)
  const [selectedTemplate] = useAtom(selectedTemplateAtom)
  const [templatesFolderId, setTemplatesFolderId] = useAtom(templatesFolderIdAtom)
  const [isLoading, setIsLoading] = useAtom(templateLoadingAtom)
  const [error, setError] = useAtom(templateErrorAtom)

  // Library und Storage
  const activeLibrary = useAtomValue(activeLibraryAtom)
  const libraryStatus = useAtomValue(libraryStatusAtom)
  const { 
    provider: providerInstance, 
    listItems
  } = useStorage()
  const contextDocs = useAtomValue(templateContextDocsAtom)

  const form = useForm<TemplateFormValues>({
    resolver: zodResolver(templateSchema),
    defaultValues: {
      name: "",
      yamlFrontmatter: `---
title: {{title|Titel des Dokuments}}
tags: {{tags|Relevante Tags}}
date: {{date|Datum im Format yyyy-mm-dd}}
---`,
      markdownBody: `# {{title}}

## Zusammenfassung
{{summary|Kurze Zusammenfassung des Inhalts}}

## Details
{{details|Detaillierte Beschreibung}}`,
      systemPrompt: `You are a specialized assistant that processes and structures information clearly and concisely.

IMPORTANT: Your response must be a valid JSON object where each key corresponds to a template variable.`,
    },
  })

  // Helper zum Erzeugen von Default-Werten
  function getDefaultTemplateValues(name: string): TemplateFormValues {
    return {
      name,
      yamlFrontmatter: `---\n` +
        `title: {{title|Titel des Dokuments}}\n` +
        `tags: {{tags|Relevante Tags}}\n` +
        `date: {{date|Datum im Format yyyy-mm-dd}}\n` +
        `---`,
      markdownBody: `# {{title}}\n\n## Zusammenfassung\n{{summary|Kurze Zusammenfassung des Inhalts}}\n\n## Details\n{{details|Detaillierte Beschreibung}}`,
      systemPrompt: `You are a specialized assistant that processes and structures information clearly and concisely.\n\nIMPORTANT: Your response must be a valid JSON object where each key corresponds to a template variable.`,
    }
  }

  // Template-Daten laden wenn sich die Auswahl ändert
  useEffect(() => {
    if (selectedTemplate) {
      form.reset({
        name: selectedTemplate.name,
        yamlFrontmatter: selectedTemplate.yamlFrontmatter,
        markdownBody: selectedTemplate.markdownBody,
        systemPrompt: selectedTemplate.systemPrompt,
      })
    }
  }, [selectedTemplate, form])

  // Ordner-Erstellung/Suche memoisiert, damit als Dep verwendbar
  const ensureTemplatesFolder = useCallback(async (): Promise<string> => {
    if (!providerInstance || !activeLibrary) {
      throw new Error("Keine aktive Bibliothek oder Provider verfügbar");
    }

    try {
      console.log('[TemplateManagement] Suche nach Templates-Ordner...');
      const rootItems = await listItems('root');
      const templatesFolder = rootItems.find(item => 
        item.type === 'folder' && item.metadata.name === 'templates'
      );
      if (templatesFolder) {
        console.log('[TemplateManagement] Templates-Ordner gefunden:', templatesFolder.id);
        return templatesFolder.id;
      }
      console.log('[TemplateManagement] Templates-Ordner nicht gefunden, erstelle neuen...');
      const newFolder = await providerInstance.createFolder('root', 'templates');
      console.log('[TemplateManagement] Neuer Templates-Ordner erstellt:', newFolder.id);
      return newFolder.id;
    } catch (error) {
      console.error('Fehler beim Erstellen des Templates-Ordners:', {
        error: error instanceof Error ? {
          message: error.message,
          name: error.name,
          stack: error.stack?.split('\n').slice(0, 3)
        } : error,
        libraryId: activeLibrary?.id,
        libraryPath: activeLibrary?.path,
        providerName: providerInstance?.name
      });
      let errorMessage = 'Fehler beim Erstellen des Templates-Ordners';
      if (error instanceof Error) {
        if (error.message.includes('Nicht authentifiziert')) {
          errorMessage = 'Bitte authentifizieren Sie sich bei Ihrem Cloud-Speicher, um den Templates-Ordner zu erstellen.';
        } else if (error.message.includes('Keine Berechtigung')) {
          errorMessage = 'Keine Berechtigung zum Erstellen von Ordnern in der Bibliothek.';
        } else if (error.message.includes('Bibliothek nicht gefunden')) {
          errorMessage = 'Die ausgewählte Bibliothek wurde nicht gefunden.';
        } else {
          errorMessage = `Fehler beim Erstellen des Templates-Ordners: ${error.message}`;
        }
      }
      throw new Error(errorMessage);
    }
  }, [providerInstance, activeLibrary, listItems]);

  // Templates laden mit der gleichen Logik wie Library-Komponente
  const loadTemplates = useCallback(async () => {
    if (!providerInstance || libraryStatus !== 'ready' || !activeLibrary) {
      console.log('[TemplateManagement] loadTemplates übersprungen:', {
        hasProvider: !!providerInstance,
        libraryStatus,
        hasActiveLibrary: !!activeLibrary
      });
      return;
    }

    try {
      setIsLoading(true);
      setError(null);

      console.log('[TemplateManagement] Starte Prompt-Loading:', {
        libraryId: activeLibrary.id,
        libraryPath: activeLibrary.path,
        providerName: providerInstance.name
      });

      // 1. Templates-Ordner finden oder erstellen
      const folderId = await ensureTemplatesFolder();
      setTemplatesFolderId(folderId);

      console.log('[TemplateManagement] Templates-Ordner gefunden/erstellt:', folderId);

      // 2. Alle Template-Dateien im Ordner auflisten
      const items = await listItems(folderId);
      const templateFiles = items.filter(item => 
        item.type === 'file' && 
        item.metadata.name.endsWith('.md')
      );

      console.log('[TemplateManagement] Prompt-Dateien gefunden:', templateFiles.length);

      // 3. Template-Inhalte laden
      const templatePromises = templateFiles.map(async (file) => {
        try {
          const { blob } = await providerInstance.getBinary(file.id);
          const content = await blob.text();
          const template = parseTemplateContent(content, file.metadata.name.replace('.md', ''));
          
          return {
            ...template,
            fileId: file.id,
            lastModified: typeof file.metadata.modifiedAt === 'string' 
              ? file.metadata.modifiedAt 
              : file.metadata.modifiedAt instanceof Date 
                ? file.metadata.modifiedAt.toISOString()
                : new Date().toISOString()
          } as Template;
        } catch (error) {
          console.error(`Fehler beim Parsen von ${file.metadata.name}:`, error);
          return null;
        }
      });

      const loadedTemplates = await Promise.all(templatePromises);
      const validTemplates = loadedTemplates.filter((t): t is Template => t !== null);
      
      setTemplates(validTemplates);
      
      console.log('[TemplateManagement] Prompts erfolgreich geladen:', validTemplates.length);
      
      if (validTemplates.length === 0) {
        toast({
          title: "Keine Prompts gefunden",
          description: "Erstellen Sie Ihren ersten Prompt im Verzeichnis '/templates'.",
        });
      }
    } catch (error) {
      console.error('Fehler beim Laden der Prompts:', {
        error: error instanceof Error ? {
          message: error.message,
          name: error.name,
          stack: error.stack?.split('\n').slice(0, 3)
        } : error,
        libraryId: activeLibrary?.id,
        libraryPath: activeLibrary?.path,
        providerName: providerInstance?.name
      });

      let errorMessage = 'Unbekannter Fehler beim Laden der Prompts';
      
      if (error instanceof Error) {
        errorMessage = error.message;
        
        // Spezifische Fehlermeldungen für häufige Probleme
        if (error.message.includes('Nicht authentifiziert')) {
          errorMessage = 'Bitte authentifizieren Sie sich bei Ihrem Cloud-Speicher, um Prompts zu laden.';
        } else if (error.message.includes('Bibliothek nicht gefunden')) {
          errorMessage = 'Die ausgewählte Bibliothek wurde nicht gefunden. Bitte überprüfen Sie die Bibliothekskonfiguration.';
        } else if (error.message.includes('Server-Fehler')) {
          errorMessage = 'Server-Fehler beim Laden der Prompts. Bitte überprüfen Sie, ob der Bibliothekspfad existiert und zugänglich ist.';
        } else if (error.message.includes('Keine aktive Bibliothek')) {
          errorMessage = 'Keine aktive Bibliothek verfügbar. Bitte wählen Sie eine Bibliothek aus.';
        }
      }
      
      setError(errorMessage);
      toast({
        title: "Fehler beim Laden der Prompts",
        description: errorMessage,
        variant: "destructive",
      });
    } finally {
      setIsLoading(false);
    }
  }, [providerInstance, libraryStatus, activeLibrary, listItems, setTemplates, setTemplatesFolderId, setIsLoading, setError, toast, ensureTemplatesFolder]);

  // Effect für Template Loading (wie Library-Komponente)
  useEffect(() => {
    const isReady = providerInstance && libraryStatus === 'ready' && activeLibrary
    
    if (!isReady) {
      return
    }

    // Templates laden wenn noch nicht geladen
    if (!templatesFolderId) {
      loadTemplates()
    }
  }, [providerInstance, libraryStatus, activeLibrary, templatesFolderId, loadTemplates])

  // Reset wenn sich die Library ändert
  useEffect(() => {
    setSelectedTemplateName(null)
    setTemplatesFolderId(null)
    setTemplates([])
    setError(null)
  }, [libraryStatus, setSelectedTemplateName, setTemplatesFolderId, setTemplates, setError])

  useEffect(() => {
    async function loadSelectedContext() {
      if (!providerInstance || !Array.isArray(selectedContextIds) || selectedContextIds.length === 0) {
        setSelectedContextMarkdown("")
        return
      }
      try {
        const parts: string[] = []
        for (const id of selectedContextIds) {
          const { blob } = await providerInstance.getBinary(id)
          const text = await blob.text()
          const name = Array.isArray(contextDocs) ? (contextDocs.find(d => d.id === id)?.name || id) : id
          const section = `\n\n---\nDatei: ${name}\n---\n\n${text}\n\n---\nEnde Datei: ${name}\n---\n`
          parts.push(section)
        }
        setSelectedContextMarkdown(parts.join("\n\n"))
      } catch (e) {
        console.error('Fehler beim Laden des Kontextes', e)
        setSelectedContextMarkdown("")
      }
    }
    void loadSelectedContext()
  }, [providerInstance, selectedContextIds, contextDocs])

  function parseTemplateContent(content: string, fileName: string): Template {
    // Template in drei Bereiche aufteilen
    const parts = content.split('--- systemprompt')
    
    let yamlFrontmatter = ""
    let markdownBody = ""
    let systemPrompt = ""
    
    if (parts.length >= 2) {
      const mainContent = parts[0].trim()
      systemPrompt = parts[1].trim()
      
      // YAML Frontmatter extrahieren
      const yamlMatch = mainContent.match(/^---\r?\n([\s\S]*?)\r?\n---\r?\n?([\s\S]*)$/)
      if (yamlMatch) {
        yamlFrontmatter = `---\n${yamlMatch[1]}\n---`
        markdownBody = yamlMatch[2].trim()
      } else {
        // Kein YAML Frontmatter gefunden
        markdownBody = mainContent
      }
    } else {
      // Kein Systemprompt gefunden
      const yamlMatch = content.match(/^---\r?\n([\s\S]*?)\r?\n---\r?\n?([\s\S]*)$/)
      if (yamlMatch) {
        yamlFrontmatter = `---\n${yamlMatch[1]}\n---`
        markdownBody = yamlMatch[2].trim()
      } else {
        markdownBody = content
      }
    }

    return {
      name: fileName,
      yamlFrontmatter,
      markdownBody,
      systemPrompt,
    }
  }

  function generateTemplateContent(values: TemplateFormValues): string {
    let content = ""
    
    // YAML Frontmatter hinzufügen
    if (values.yamlFrontmatter.trim()) {
      content += values.yamlFrontmatter + "\n\n"
    }
    
    // Markdown Body hinzufügen
    content += values.markdownBody
    
    // System Prompt hinzufügen
    if (values.systemPrompt.trim()) {
      content += "\n\n--- systemprompt\n" + values.systemPrompt
    }
    
    return content
  }

  async function onSubmit(data: TemplateFormValues) {
    if (!activeLibrary || !templatesFolderId || !providerInstance) {
      toast({
        title: "Fehler",
        description: "Keine aktive Bibliothek oder Templates-Ordner nicht gefunden.",
        variant: "destructive",
      })
      return
    }

    setIsSaving(true)
    try {
      const templateContent = generateTemplateContent(data)
      const fileName = `${data.name}.md`
      
      console.group('[TemplateManagement] Speichern')
      console.log('Library', { id: activeLibrary.id, label: activeLibrary.label, path: activeLibrary.path })
      console.log('TemplatesFolderId', templatesFolderId)
      console.log('Datei', { fileName, contentLen: templateContent.length })
      
      // Falls Datei mit gleichem Namen existiert: erst löschen, dann neu schreiben
      const existing = templates.find(t => t.name.toLowerCase() === data.name.toLowerCase())
      if (existing?.fileId) {
        console.log('Bestehende Datei gefunden, lösche', { fileId: existing.fileId })
        try {
          await providerInstance.deleteItem(existing.fileId)
          console.log('Löschen OK')
        } catch (e) {
          console.error('Löschen fehlgeschlagen', e)
          toast({ title: 'Löschen fehlgeschlagen', description: e instanceof Error ? e.message : String(e), variant: 'destructive' })
        }
      } else {
        console.log('Keine bestehende Datei mit gleichem Namen gefunden')
      }
      
      // Datei als Blob erstellen und hochladen (Neu-Anlage / Ersetzen)
      const blob = new Blob([templateContent], { type: 'text/markdown' })
      const file = new File([blob], fileName, { type: 'text/markdown' })
      const uploaded = await providerInstance.uploadFile(templatesFolderId, file)
      console.log('Upload Ergebnis', uploaded)
      
      // Direkt nach Upload erneut lesen (Bypass-Stale) und lokalen State aktualisieren
      try {
        const { blob: rbBlob } = await providerInstance.getBinary(uploaded.id)
        const rbText = await rbBlob.text()
        console.log('Read-Back Länge', rbText.length, 'Auszug', rbText.slice(0, 120))
        const parsed = parseTemplateContent(rbText, data.name)
        const updated: Template = {
          ...parsed,
          fileId: uploaded.id,
          lastModified: new Date().toISOString()
        }
        setTemplates(((prev: Template[]) => {
          const rest = prev.filter((t: Template) => t.name.toLowerCase() !== data.name.toLowerCase())
          return [...rest, updated]
        }) as unknown as Template[])
      } catch (e) {
        console.warn('Read-Back nach Upload fehlgeschlagen', e)
      }
      
      // Kurze Wartezeit, damit Remote-Provider (OneDrive) Index/Cache aktualisiert
      await new Promise(r => setTimeout(r, 500))
      
      // Templates neu laden (finaler Sync mit Remote)
      await loadTemplates()
      console.log('Templates neu geladen')
      
      // Auswahl auf das neue Template setzen
      setSelectedTemplateName(data.name)
      console.log('Auswahl gesetzt', data.name)
      
      toast({
        title: "Prompt gespeichert",
        description: `"${data.name}" wurde aktualisiert.`,
      })
      console.groupEnd()
    } catch (error) {
      console.error('Fehler beim Speichern des Templates:', error)
      toast({
        title: "Fehler beim Speichern",
        description: error instanceof Error ? error.message : "Unbekannter Fehler",
        variant: "destructive",
      })
    } finally {
      setIsSaving(false)
    }
  }

  async function renameCurrentTemplate() {
    const current = selectedTemplateName ? templates.find(t => t.name === selectedTemplateName) : null
    if (!current || !current.fileId || !providerInstance) return
    const newName = (window.prompt('Neuen Namen eingeben:', current.name) || '').trim()
    if (!newName || newName === current.name) return
    if (/[^a-zA-Z0-9._\- ]/.test(newName)) { toast({ title: 'Ungültiger Name', description: 'Nur Buchstaben, Zahlen, Leerzeichen, . _ - sind erlaubt.', variant: 'destructive' }); return }
    if (templates.some(t => t.name.toLowerCase() === newName.toLowerCase())) { toast({ title: 'Bereits vorhanden', description: 'Bitte anderen Namen wählen.', variant: 'destructive' }); return }
    try {
      await providerInstance.renameItem(current.fileId, `${newName}.md`)
      await loadTemplates()
      setSelectedTemplateName(newName)
      form.setValue('name', newName, { shouldDirty: false })
      toast({ title: 'Umbenannt', description: `${current.name} → ${newName}` })
    } catch (e) {
      toast({ title: 'Fehler beim Umbenennen', description: e instanceof Error ? e.message : 'Unbekannter Fehler', variant: 'destructive' })
    }
  }

  async function deleteTemplate(templateName: string) {
    if (!activeLibrary || !providerInstance) return

    try {
      const template = templates.find(t => t.name === templateName)
      if (!template?.fileId) {
        throw new Error("Template-Datei nicht gefunden")
      }

      // Datei löschen
      await providerInstance.deleteItem(template.fileId)

      // Templates neu laden
      await loadTemplates()
      
      if (selectedTemplateName === templateName) {
        setSelectedTemplateName(null)
        form.reset()
      }
      
      toast({
        title: "Template gelöscht",
        description: `Template "${templateName}" wurde erfolgreich gelöscht.`,
      })
    } catch (error) {
      console.error('Fehler beim Löschen des Templates:', error)
      toast({
        title: "Fehler beim Löschen",
        description: error instanceof Error ? error.message : "Unbekannter Fehler",
        variant: "destructive",
      })
    }
  }

  async function createNewTemplate() {
    const name = (window.prompt('Neuen Template‑Namen eingeben:') || '').trim()
    if (!name) return
    if (/[^a-zA-Z0-9._\- ]/.test(name)) { toast({ title: 'Ungültiger Name', description: 'Nur Buchstaben, Zahlen, Leerzeichen, . _ - sind erlaubt.', variant: 'destructive' }); return }
    if (templates.some(t => t.name.toLowerCase() === name.toLowerCase())) { toast({ title: 'Bereits vorhanden', description: 'Bitte anderen Namen wählen.', variant: 'destructive' }); return }
    if (!providerInstance) { toast({ title: 'Kein Provider' , variant: 'destructive' }); return }
    try {
      const folderId = await ensureTemplatesFolder()
      const values = getDefaultTemplateValues(name)
      const content = (values.yamlFrontmatter ? values.yamlFrontmatter + '\n\n' : '') + values.markdownBody + '\n\n--- systemprompt\n' + values.systemPrompt
      const file = new File([new Blob([content], { type: 'text/markdown' })], `${name}.md`, { type: 'text/markdown' })
      await providerInstance.uploadFile(folderId, file)
      await loadTemplates()
      setSelectedTemplateName(name)
      form.reset(values)
      toast({ title: 'Template angelegt', description: `"${name}" wurde erstellt.` })
    } catch (e) {
      toast({ title: 'Fehler beim Anlegen', description: e instanceof Error ? e.message : 'Unbekannter Fehler', variant: 'destructive' })
    }
  }

  function generatePreview(): string {
    const values = form.getValues()
    return generateTemplateContent(values)
  }

  async function testTemplate() {
    if (!activeLibrary) return

    setIsTesting(true)
    setTestResult(null)

    const values = form.getValues()
    const templateContent = generateTemplateContent(values)
    const sections: string[] = []
    if (selectedContextMarkdown.trim()) sections.push(selectedContextMarkdown.trim())
    if (freeText.trim()) sections.push(`---\nDatei: Freitext\n---\n\n${freeText.trim()}\n\n---\nEnde Datei: Freitext\n---`)
    const testText = sections.join("\n\n")

    const pickMarkdown = (result: unknown): string => {
      if (typeof result === 'string') return result
      if (result && typeof result === 'object') {
        const obj = result as Record<string, unknown>
        const directCandidates = ['text','markdown','content','output'] as const
        for (const k of directCandidates) {
          const v = obj[k]
          if (typeof v === 'string') return v
        }
        // verschachtelte Felder prüfen
        const nested = obj['data']
        if (nested && typeof nested === 'object') {
          const nobj = nested as Record<string, unknown>
          for (const k of directCandidates) {
            const v = nobj[k]
            if (typeof v === 'string') return v
          }
        }
      }
      return JSON.stringify(result, null, 2)
    }

    try {
      const response = await fetch('/api/secretary/process-text', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/x-www-form-urlencoded',
          'X-Library-Id': activeLibrary.id,
        },
        body: new URLSearchParams({
          text: testText,
          template_content: templateContent,
          source_language: 'de',
          target_language: 'de',
          use_cache: 'false',
        }),
      })

      if (!response.ok) {
        const errorData = await response.json()
        throw new Error(errorData.error || `HTTP ${response.status}: ${response.statusText}`)
      }

      const result = await response.json()
      const formattedResult = pickMarkdown(result)
      console.log('Prompt-Test Ergebnis:', formattedResult)
      
      setTestResult(formattedResult)
      setRightTab('testen')

      toast({
        title: "Prompt-Test erfolgreich",
        description: "Der Prompt wurde erfolgreich mit dem gewählten Kontext verarbeitet.",
      })

      console.log('Prompt-Test Ergebnis (roh):', result)
    } catch (error) {
      console.error('Fehler beim Prompt-Test:', error)
      const errorMessage = error instanceof Error ? error.message : "Unbekannter Fehler"
      setTestResult(`Fehler: ${errorMessage}`)
      setRightTab('testen')
      toast({
        title: "Prompt-Test fehlgeschlagen",
        description: errorMessage,
        variant: "destructive",
      })
    } finally {
      setIsTesting(false)
    }
  }

  async function ensurePromptTestsFolder(): Promise<string> {
    if (!providerInstance) throw new Error('Kein Provider verfügbar')
    const roots = await listItems('root')
    const found = roots.find(it => it.type === 'folder' && it.metadata.name === 'prompt-tests')
    if (found) return found.id
    const created = await providerInstance.createFolder('root', 'prompt-tests')
    return created.id
  }

  async function saveTestResult() {
    try {
      if (!providerInstance || !activeLibrary || !testResult) return
      const folderId = await ensurePromptTestsFolder()
      const name = `${selectedTemplateName || 'prompt'}-test-${new Date().toISOString().replace(/[:.]/g,'-')}.md`
      const blob = new Blob([testResult], { type: 'text/markdown' })
      const file = new File([blob], name, { type: 'text/markdown' })
      const item = await providerInstance.uploadFile(folderId, file)
      setResultSavedItemId(item.id)
      toast({ title: 'Ergebnis gespeichert', description: name })
    } catch (e) {
      toast({ title: 'Speichern fehlgeschlagen', description: e instanceof Error ? e.message : 'Unbekannter Fehler', variant: 'destructive' })
    }
  }

  async function runMagicDesign() {
    if (!selectedTemplateName || !providerInstance || !activeLibrary) {
      toast({ title: 'Kein Prompt ausgewählt', description: 'Bitte wählen Sie zuerst einen Prompt.', variant: 'destructive' })
      return
    }
    const scopeParts: string[] = []
    if (magicFrontmatter.trim()) scopeParts.push('frontmatter')
    if (magicBody.trim()) scopeParts.push('body')
    if (magicSystem.trim()) scopeParts.push('systemprompt')
    const allowedScope = scopeParts.length === 0 ? 'all' : (scopeParts.length === 1 ? scopeParts[0] : 'all')

    try {
      setMagicRunning(true)
      // 1) Magic-Template laden (magicpromptdesign.md)
      const folderId = await ensureTemplatesFolder()
      const items = await listItems(folderId)
      const magicItem = items.find(it => it.type === 'file' && (it.metadata.name.toLowerCase() === 'magicpromptdesign.md'))
      if (!magicItem) {
        toast({ title: 'Magic-Template fehlt', description: 'magicpromptdesign.md nicht im /templates gefunden.', variant: 'destructive' })
        return
      }
      const { blob } = await providerInstance.getBinary(magicItem.id)
      const magicTemplateContent = await blob.text()

      // 2) Inputtext zusammenstellen
      const currentTemplate = generateTemplateContent(form.getValues())
      const inputText = [
        'INPUT_TEMPLATE:',
        currentTemplate,
        '',
        'CHANGES:',
        'Aufgabe:',
        magicBody || '(keine)',
        '',
        'Metadaten:',
        magicFrontmatter || '(keine)',
        '',
        'Rollenanweisung:',
        magicSystem || '(keine)',
        '',
        'CONFIG:',
        `allowed_scope: ${allowedScope}`,
        'diff_mode: diff',
        'preserve_comments: ja'
      ].join('\n')

      // 3) Secretary-Service aufrufen
      const response = await fetch('/api/secretary/process-text', {
        method: 'POST',
        headers: { 'Content-Type': 'application/x-www-form-urlencoded', 'X-Library-Id': activeLibrary.id },
        body: new URLSearchParams({
          text: inputText,
          template_content: magicTemplateContent,
          source_language: 'de',
          target_language: 'de'
        })
      })
      if (!response.ok) {
        const err = await response.json().catch(() => ({}))
        throw new Error(err?.error || `HTTP ${response.status}`)
      }
      const data = await response.json()
      // data kann string (JSON) oder object sein
      let corrected: string | undefined
      let diff: string = ''
      try {
        const obj = typeof data === 'string' ? JSON.parse(data) : (typeof data === 'object' ? data : {})
        corrected = typeof obj?.corrected_template === 'string' ? obj.corrected_template : undefined
        diff = typeof obj?.diff_preview === 'string' ? obj.diff_preview : ''
      } catch (e) {
        // Fallback: Wenn data.text existiert
        const maybe = (data && typeof data.text === 'string') ? JSON.parse(data.text) : null
        corrected = maybe?.corrected_template
        diff = maybe?.diff_preview || ''
      }
      if (!corrected) throw new Error('Antwort ohne corrected_template')

      // 4) Template parsen und Formular übernehmen
      const parsed = parseTemplateContent(corrected, selectedTemplateName)
      form.setValue('yamlFrontmatter', parsed.yamlFrontmatter, { shouldDirty: true })
      form.setValue('markdownBody', parsed.markdownBody, { shouldDirty: true })
      form.setValue('systemPrompt', parsed.systemPrompt, { shouldDirty: true })
      setMagicLastDiff(diff || '')
      toast({ title: 'Magic Design angewendet', description: 'Änderungen übernommen (nicht gespeichert).' })
    } catch (e) {
      toast({ title: 'Magic fehlgeschlagen', description: e instanceof Error ? e.message : 'Unbekannter Fehler', variant: 'destructive' })
    } finally {
      setMagicRunning(false)
    }
  }

  // Render-Logik für verschiedene Status
  if (libraryStatus === "waitingForAuth") {
    return (
      <div className="flex flex-col items-center justify-center h-full text-muted-foreground">
        <span>Diese Bibliothek benötigt eine Authentifizierung.</span>
        <span className="text-sm mt-2">Bitte konfigurieren Sie die Bibliothek in den Einstellungen.</span>
      </div>
    )
  }
  
  if (libraryStatus !== "ready") {
    return (
      <div className="flex flex-col items-center justify-center h-full text-muted-foreground">
        <span>Lade Storage...</span>
      </div>
    )
  }

  if (!activeLibrary) {
    return (
      <div className="text-center text-muted-foreground">
        Bitte wählen Sie eine Bibliothek aus.
      </div>
    )
  }

  if (error) {
    return (
      <div className="text-center text-destructive">
        <p>Fehler beim Laden der Prompts:</p>
        <p className="text-sm">{error}</p>
        <Button 
          variant="outline" 
          className="mt-4"
          onClick={loadTemplates}
        >
          Erneut versuchen
        </Button>
      </div>
    )
  }

  return (
    <div className="space-y-6">

      {/* Kompakte Toolbar oben */}
      <div className="flex items-center gap-2">
        <Select value={selectedTemplateName || ''} onValueChange={(v) => { setSelectedTemplateName(v); form.setValue('name', v, { shouldDirty: false }) }} disabled={isLoading}>
          <SelectTrigger className="w-64">
            <SelectValue placeholder="Prompt auswählen..." />
          </SelectTrigger>
          <SelectContent>
            {templates.map((t) => (
              <SelectItem key={t.name} value={t.name}>{t.name}</SelectItem>
            ))}
          </SelectContent>
        </Select>
        <TooltipProvider>
          <Tooltip>
            <TooltipTrigger asChild>
              <Button variant="ghost" size="sm" className="h-8 w-8 p-0"><Info className="h-4 w-4" /></Button>
            </TooltipTrigger>
            <TooltipContent>
              <div className="flex items-center gap-2"><FolderOpen className="h-4 w-4" /><span>Ort: /templates in „{activeLibrary.label}“</span></div>
            </TooltipContent>
          </Tooltip>
        </TooltipProvider>
        <Button type="button" variant="outline" size="sm" onClick={createNewTemplate} disabled={isLoading}>Neu</Button>
        <Button type="button" variant="outline" size="sm" onClick={renameCurrentTemplate} disabled={!selectedTemplateName}>Umbenennen</Button>
        {selectedTemplateName && (
          <Button type="button" variant="destructive" size="sm" onClick={() => deleteTemplate(selectedTemplateName!)}>Löschen</Button>
        )}
      </div>

      <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
        <Card>
          <CardHeader>
            <CardTitle>Prompt Design</CardTitle>
            <CardDescription>
              Drei Bereiche: Aufgabe (was), Rollenanweisung (wie), Metadaten (Begleitinfos).
            </CardDescription>
          </CardHeader>
          <CardContent>
            <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-6">
              {/* Template-Name Feld entfernt (oben verwaltet) */}

              {!selectedTemplateName ? (
                <div className="rounded-md border border-dashed p-6 text-sm text-muted-foreground">
                  Bitte oben einen Prompt auswählen oder Neu anlegen.
                </div>
              ) : previewMode ? (
                <div className="space-y-4">
                  <div className="flex items-center justify-between">
                    <h4 className="text-sm font-medium">Prompt-Vorschau</h4>
                    <Button
                      type="button"
                      variant="outline"
                      size="sm"
                      onClick={() => setPreviewMode(false)}
                    >
                      Bearbeiten
                    </Button>
                  </div>
                  <div className="border rounded-md p-4 bg-muted/50">
                    <pre className="text-sm whitespace-pre-wrap font-mono">
                      {generatePreview()}
                    </pre>
                  </div>
                </div>
              ) : (
                <>
                  <StructuredTemplateEditor
                    markdownBody={form.watch('markdownBody')}
                    yamlFrontmatter={form.watch('yamlFrontmatter')}
                    systemPrompt={form.watch('systemPrompt')}
                    magicMode={magicMode}
                    magicValues={{ body: magicBody, frontmatter: magicFrontmatter, system: magicSystem }}
                    onMagicChange={(next) => {
                      if (next.body !== undefined) setMagicBody(next.body)
                      if (next.frontmatter !== undefined) setMagicFrontmatter(next.frontmatter)
                      if (next.system !== undefined) setMagicSystem(next.system)
                    }}
                    onChange={({ markdownBody, yamlFrontmatter, systemPrompt }) => {
                      form.setValue('markdownBody', markdownBody, { shouldDirty: true })
                      form.setValue('yamlFrontmatter', yamlFrontmatter, { shouldDirty: true })
                      form.setValue('systemPrompt', systemPrompt, { shouldDirty: true })
                    }}
                  />
                </>
              )}

              <div className="flex justify-end gap-2">
                {selectedTemplateName && (
                  <Button type="button" variant={magicMode ? 'secondary' : 'outline'} onClick={() => setMagicMode(v => !v)}>
                    {magicMode ? 'Magic Design ausblenden' : 'Magic Design'}
                  </Button>
                )}
                {magicMode && (
                  <>
                    <Button type="button" variant="secondary" onClick={() => { setMagicBody(''); setMagicFrontmatter(''); setMagicSystem(''); setMagicLastDiff('') }} disabled={magicRunning}>Magic zurücksetzen</Button>
                    <Button type="button" onClick={runMagicDesign} disabled={magicRunning || (!magicBody && !magicFrontmatter && !magicSystem)}>
                      {magicRunning ? (<><Loader2 className="h-4 w-4 mr-2 animate-spin" /> Magic läuft…</>) : 'Magic absenden'}
                    </Button>
                  </>
                )}
                <Button
                  type="button"
                  variant="outline"
                  onClick={() => setPreviewMode(!previewMode)}
                  disabled={!selectedTemplateName}
                >
                  <Eye className="h-4 w-4 mr-2" />
                  {previewMode ? "Bearbeiten" : "Vorschau"}
                </Button>
                <Button
                  type="submit"
                  disabled={!selectedTemplateName || isSaving || !form.formState.isDirty}
                >
                  {isSaving ? (
                    <>
                      <Loader2 className="h-4 w-4 mr-2 animate-spin" />
                      Wird gespeichert...
                    </>
                  ) : (
                    <>
                      <Save className="h-4 w-4 mr-2" />
                      Speichern
                    </>
                  )}
                </Button>
              </div>
            </form>
          </CardContent>
        </Card>

        <Card>
          <CardHeader>
            <CardTitle>Prompt testen</CardTitle>
            <CardDescription>
              Test mit Beispieltext. Nutzt Rollenanweisung, Aufgabe und Metadaten des Prompts.
            </CardDescription>
          </CardHeader>
          <CardContent>
            {!selectedTemplateName ? (
              <div className="rounded-md border border-dashed p-6 text-sm text-muted-foreground">
                Bitte oben einen Prompt auswählen. Die Vorschau und Test‑Funktionen werden erst danach aktiviert.
              </div>
            ) : (
              <Tabs value={rightTab} onValueChange={(v) => setRightTab(v as typeof rightTab)}>
                <TabsList className="grid grid-cols-3 w-full">
                  <TabsTrigger value="kontext">Daten‑Kontext</TabsTrigger>
                  <TabsTrigger value="preview">Prompt‑Vorschau</TabsTrigger>
                  <TabsTrigger value="testen">Testen</TabsTrigger>
                </TabsList>

                <TabsContent value="kontext" className="space-y-4 mt-4">
                  <div className="space-y-2">
                    <Label>Kontext-Texte</Label>
                    <div className="border rounded p-2 text-sm">
                      {Array.isArray(contextDocs) && contextDocs.length > 0 ? (
                        contextDocs.map(d => {
                          const checked = selectedContextIds.includes(d.id)
                          return (
                            <label key={d.id} className="flex items-center gap-2 py-1">
                              <Checkbox
                                checked={checked}
                                onCheckedChange={(v) => {
                                  const isOn = v === true
                                  setSelectedContextIds(prev => isOn ? [...prev, d.id] : prev.filter(x => x !== d.id))
                                }}
                              />
                              <span className="truncate">{d.name}</span>
                            </label>
                          )
                        })
                      ) : (
                        <div className="text-muted-foreground text-sm">Keine Kontext-Texte verfügbar</div>
                      )}
                    </div>
                  </div>

                  <div className="space-y-2">
                    <Label>Gewählter Kontext (Lesemodus)</Label>
                    <div className="border rounded-md">
                      <MarkdownPreview content={selectedContextMarkdown} />
                    </div>
                  </div>

                  <div className="space-y-2">
                    <Label>Freitext (optional)</Label>
                    <Textarea
                      value={freeText}
                      onChange={(e) => setFreeText(e.target.value)}
                      placeholder="Hier Text einkleben, um schnell zu testen"
                      className="min-h-[120px] font-mono text-sm"
                    />
                  </div>
                </TabsContent>

                <TabsContent value="preview" className="space-y-4 mt-4">
                  <div className="space-y-2">
                    <Label>Generierter Prompt (Markdown)</Label>
                    <div className="border rounded-md">
                      <MarkdownPreview content={generatePreview()} />
                    </div>
                  </div>
                  <div className="flex gap-2 justify-end">
                    <Button 
                      variant="outline" 
                      size="sm"
                      onClick={testTemplate}
                      disabled={!selectedTemplateName || isTesting}
                    >
                      {isTesting ? (
                        <>
                          <Loader2 className="h-4 w-4 mr-2 animate-spin" />
                          Teste...
                        </>
                      ) : (
                        <>
                          <Play className="h-4 w-4 mr-2" />
                          Prompt testen
                        </>
                      )}
                    </Button>
                  </div>
                </TabsContent>

                <TabsContent value="testen" className="space-y-4 mt-4">
                  <div className="flex gap-2 justify-end">
                    <Button 
                      variant="outline" 
                      size="sm"
                      onClick={testTemplate}
                      disabled={!selectedTemplateName || isTesting}
                    >
                      {isTesting ? (
                        <>
                          <Loader2 className="h-4 w-4 mr-2 animate-spin" />
                          Teste...
                        </>
                      ) : (
                        <>
                          <Play className="h-4 w-4 mr-2" />
                          Prompt testen
                        </>
                      )}
                    </Button>
                  </div>
                  {activeLibrary && providerInstance && (testResult || resultSavedItemId) ? (
                    <JobReportTab
                      libraryId={activeLibrary.id}
                      fileId={resultSavedItemId || 'preview'}
                      provider={providerInstance}
                      sourceMode="frontmatter"
                      viewMode="metaOnly"
                      mdFileId={resultSavedItemId || undefined}
                      rawContent={testResult || undefined}
                    />
                  ) : (
                    <div className="text-sm text-muted-foreground">Kein Ergebnis vorhanden.</div>
                  )}
                  <div className="flex gap-2">
                    <Button type="button" onClick={saveTestResult} disabled={!testResult}>Speichern</Button>
                  </div>
                </TabsContent>
              </Tabs>
            )}
          </CardContent>
        </Card>
      </div>
    </div>
  )
} 
```

- Ich habe die Magic-Felder in die Tabs integriert:
  - Oben in „Aufgabe“, „Metadaten“ und „Rollenanweisung“ erscheint jeweils ein rosa Freitextfeld über dem jeweiligen Inhalt, wenn Magic aktiv ist.
  - Die Felder belegen die volle Breite des Tab‑Contents.

- Bedienung:
  - „Magic Design“ toggelt die Felder.
  - „Magic absenden“ bleibt in der Fußzeile der Form, ebenso „Magic zurücksetzen“.
  - Änderungen in den Tab‑Feldern werden zentral gemanagt und beim Absenden verwendet.

- Technisch:
  - `StructuredTemplateEditor` erhielt optionale Props `magicMode`, `magicValues`, `onMagicChange`.
  - Tab‑spezifische Textareas rendern nur bei aktivem `magicMode`.
  - Verkabelung in `template-management.tsx` aktualisiert.

Kurztest: Umschalten auf Magic zeigt die drei rosa Bereiche oben in den Tabs; Absenden führt den bekannten Flow aus.

---

**User**

Ich kann es nicht wirklich richtig testen, weil ich weiß nicht, wo was stecken bleibt. Können wir das berechnete Template, das von Secretary Service zurückkommt, auch in demselben Verzeichnis "prompt-tests" speichern, wie wir auch dieses "Prompt-Testen" speichern?

---

**Cursor**

Ich prüfe, wie wir derzeit Ergebnisse im Ordner `prompt-tests` speichern, um denselben Mechanismus für Magic-Design-Ergebnisse zu verwenden. Danach erweitere ich den Magic-Flow, damit das korrigierte Template dort versioniert abgelegt wird.

Ich speichere nun das von Magic Design berechnete Template automatisch im Ordner `prompt-tests` (inklusive optionaler Diff-Datei) und gebe eine Bestätigung via Toast aus. Danach prüfe ich den Linter und hake die Aufgabe ab.

```typescriptreact
"use client"

import { useState, useEffect, useCallback } from "react"
import { useForm } from "react-hook-form"
import { zodResolver } from "@hookform/resolvers/zod"
import * as z from "zod"
import { Button } from "@/components/ui/button"
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card"
import { Label } from "@/components/ui/label"
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select"
import { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from "@/components/ui/tooltip"
import { StructuredTemplateEditor } from "@/components/templates/structured-template-editor"
import { useToast } from "@/hooks/use-toast"
import { Loader2, Save, Eye, Play, FolderOpen, Info } from "lucide-react"
import { useAtom, useAtomValue } from "jotai"
import { activeLibraryAtom, libraryStatusAtom } from "@/atoms/library-atom"
import { 
  templatesAtom, 
  selectedTemplateNameAtom, 
  selectedTemplateAtom,
  templatesFolderIdAtom,
  templateLoadingAtom,
  templateErrorAtom,
  type Template
} from "@/atoms/template-atom"
import { useStorage } from "@/contexts/storage-context"
import { templateContextDocsAtom } from '@/atoms/template-context-atom'
import { Checkbox } from "@/components/ui/checkbox"
import { MarkdownPreview } from "@/components/library/markdown-preview"
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs"
import { JobReportTab } from "@/components/library/job-report-tab"
import { Textarea } from "@/components/ui/textarea"
import { Separator } from "@/components/ui/separator"

// Schema für Template-Daten
const templateSchema = z.object({
  name: z.string().min(1, "Prompt-Name ist erforderlich"),
  yamlFrontmatter: z.string(),
  markdownBody: z.string(),
  systemPrompt: z.string(),
})

type TemplateFormValues = z.infer<typeof templateSchema>

export function TemplateManagement() {
  const [previewMode, setPreviewMode] = useState(false)
  const [isSaving, setIsSaving] = useState(false)
  const [isTesting, setIsTesting] = useState(false)
  const [testResult, setTestResult] = useState<string | null>(null)
  const [selectedContextIds, setSelectedContextIds] = useState<string[]>([])
  const [selectedContextMarkdown, setSelectedContextMarkdown] = useState<string>("")
  const [rightTab, setRightTab] = useState<'kontext'|'preview'|'testen'>('kontext')
  const [resultSavedItemId, setResultSavedItemId] = useState<string | null>(null)
  const [freeText, setFreeText] = useState<string>("")
  // Magic Design
  const [magicMode, setMagicMode] = useState<boolean>(false)
  const [magicBody, setMagicBody] = useState<string>("")
  const [magicFrontmatter, setMagicFrontmatter] = useState<string>("")
  const [magicSystem, setMagicSystem] = useState<string>("")
  const [magicRunning, setMagicRunning] = useState<boolean>(false)
  const [magicLastDiff, setMagicLastDiff] = useState<string>("")
  const [magicSavedItemId, setMagicSavedItemId] = useState<string | null>(null)
  const { toast } = useToast()

  // Atoms
  const [templates, setTemplates] = useAtom(templatesAtom)
  const [selectedTemplateName, setSelectedTemplateName] = useAtom(selectedTemplateNameAtom)
  const [selectedTemplate] = useAtom(selectedTemplateAtom)
  const [templatesFolderId, setTemplatesFolderId] = useAtom(templatesFolderIdAtom)
  const [isLoading, setIsLoading] = useAtom(templateLoadingAtom)
  const [error, setError] = useAtom(templateErrorAtom)

  // Library und Storage
  const activeLibrary = useAtomValue(activeLibraryAtom)
  const libraryStatus = useAtomValue(libraryStatusAtom)
  const { 
    provider: providerInstance, 
    listItems
  } = useStorage()
  const contextDocs = useAtomValue(templateContextDocsAtom)

  const form = useForm<TemplateFormValues>({
    resolver: zodResolver(templateSchema),
    defaultValues: {
      name: "",
      yamlFrontmatter: `---
title: {{title|Titel des Dokuments}}
tags: {{tags|Relevante Tags}}
date: {{date|Datum im Format yyyy-mm-dd}}
---`,
      markdownBody: `# {{title}}

## Zusammenfassung
{{summary|Kurze Zusammenfassung des Inhalts}}

## Details
{{details|Detaillierte Beschreibung}}`,
      systemPrompt: `You are a specialized assistant that processes and structures information clearly and concisely.

IMPORTANT: Your response must be a valid JSON object where each key corresponds to a template variable.`,
    },
  })

  // Helper zum Erzeugen von Default-Werten
  function getDefaultTemplateValues(name: string): TemplateFormValues {
    return {
      name,
      yamlFrontmatter: `---\n` +
        `title: {{title|Titel des Dokuments}}\n` +
        `tags: {{tags|Relevante Tags}}\n` +
        `date: {{date|Datum im Format yyyy-mm-dd}}\n` +
        `---`,
      markdownBody: `# {{title}}\n\n## Zusammenfassung\n{{summary|Kurze Zusammenfassung des Inhalts}}\n\n## Details\n{{details|Detaillierte Beschreibung}}`,
      systemPrompt: `You are a specialized assistant that processes and structures information clearly and concisely.\n\nIMPORTANT: Your response must be a valid JSON object where each key corresponds to a template variable.`,
    }
  }

  // Template-Daten laden wenn sich die Auswahl ändert
  useEffect(() => {
    if (selectedTemplate) {
      form.reset({
        name: selectedTemplate.name,
        yamlFrontmatter: selectedTemplate.yamlFrontmatter,
        markdownBody: selectedTemplate.markdownBody,
        systemPrompt: selectedTemplate.systemPrompt,
      })
    }
  }, [selectedTemplate, form])

  // Ordner-Erstellung/Suche memoisiert, damit als Dep verwendbar
  const ensureTemplatesFolder = useCallback(async (): Promise<string> => {
    if (!providerInstance || !activeLibrary) {
      throw new Error("Keine aktive Bibliothek oder Provider verfügbar");
    }

    try {
      console.log('[TemplateManagement] Suche nach Templates-Ordner...');
      const rootItems = await listItems('root');
      const templatesFolder = rootItems.find(item => 
        item.type === 'folder' && item.metadata.name === 'templates'
      );
      if (templatesFolder) {
        console.log('[TemplateManagement] Templates-Ordner gefunden:', templatesFolder.id);
        return templatesFolder.id;
      }
      console.log('[TemplateManagement] Templates-Ordner nicht gefunden, erstelle neuen...');
      const newFolder = await providerInstance.createFolder('root', 'templates');
      console.log('[TemplateManagement] Neuer Templates-Ordner erstellt:', newFolder.id);
      return newFolder.id;
    } catch (error) {
      console.error('Fehler beim Erstellen des Templates-Ordners:', {
        error: error instanceof Error ? {
          message: error.message,
          name: error.name,
          stack: error.stack?.split('\n').slice(0, 3)
        } : error,
        libraryId: activeLibrary?.id,
        libraryPath: activeLibrary?.path,
        providerName: providerInstance?.name
      });
      let errorMessage = 'Fehler beim Erstellen des Templates-Ordners';
      if (error instanceof Error) {
        if (error.message.includes('Nicht authentifiziert')) {
          errorMessage = 'Bitte authentifizieren Sie sich bei Ihrem Cloud-Speicher, um den Templates-Ordner zu erstellen.';
        } else if (error.message.includes('Keine Berechtigung')) {
          errorMessage = 'Keine Berechtigung zum Erstellen von Ordnern in der Bibliothek.';
        } else if (error.message.includes('Bibliothek nicht gefunden')) {
          errorMessage = 'Die ausgewählte Bibliothek wurde nicht gefunden.';
        } else {
          errorMessage = `Fehler beim Erstellen des Templates-Ordners: ${error.message}`;
        }
      }
      throw new Error(errorMessage);
    }
  }, [providerInstance, activeLibrary, listItems]);

  // Templates laden mit der gleichen Logik wie Library-Komponente
  const loadTemplates = useCallback(async () => {
    if (!providerInstance || libraryStatus !== 'ready' || !activeLibrary) {
      console.log('[TemplateManagement] loadTemplates übersprungen:', {
        hasProvider: !!providerInstance,
        libraryStatus,
        hasActiveLibrary: !!activeLibrary
      });
      return;
    }

    try {
      setIsLoading(true);
      setError(null);

      console.log('[TemplateManagement] Starte Prompt-Loading:', {
        libraryId: activeLibrary.id,
        libraryPath: activeLibrary.path,
        providerName: providerInstance.name
      });

      // 1. Templates-Ordner finden oder erstellen
      const folderId = await ensureTemplatesFolder();
      setTemplatesFolderId(folderId);

      console.log('[TemplateManagement] Templates-Ordner gefunden/erstellt:', folderId);

      // 2. Alle Template-Dateien im Ordner auflisten
      const items = await listItems(folderId);
      const templateFiles = items.filter(item => 
        item.type === 'file' && 
        item.metadata.name.endsWith('.md')
      );

      console.log('[TemplateManagement] Prompt-Dateien gefunden:', templateFiles.length);

      // 3. Template-Inhalte laden
      const templatePromises = templateFiles.map(async (file) => {
        try {
          const { blob } = await providerInstance.getBinary(file.id);
          const content = await blob.text();
          const template = parseTemplateContent(content, file.metadata.name.replace('.md', ''));
          
          return {
            ...template,
            fileId: file.id,
            lastModified: typeof file.metadata.modifiedAt === 'string' 
              ? file.metadata.modifiedAt 
              : file.metadata.modifiedAt instanceof Date 
                ? file.metadata.modifiedAt.toISOString()
                : new Date().toISOString()
          } as Template;
        } catch (error) {
          console.error(`Fehler beim Parsen von ${file.metadata.name}:`, error);
          return null;
        }
      });

      const loadedTemplates = await Promise.all(templatePromises);
      const validTemplates = loadedTemplates.filter((t): t is Template => t !== null);
      
      setTemplates(validTemplates);
      
      console.log('[TemplateManagement] Prompts erfolgreich geladen:', validTemplates.length);
      
      if (validTemplates.length === 0) {
        toast({
          title: "Keine Prompts gefunden",
          description: "Erstellen Sie Ihren ersten Prompt im Verzeichnis '/templates'.",
        });
      }
    } catch (error) {
      console.error('Fehler beim Laden der Prompts:', {
        error: error instanceof Error ? {
          message: error.message,
          name: error.name,
          stack: error.stack?.split('\n').slice(0, 3)
        } : error,
        libraryId: activeLibrary?.id,
        libraryPath: activeLibrary?.path,
        providerName: providerInstance?.name
      });

      let errorMessage = 'Unbekannter Fehler beim Laden der Prompts';
      
      if (error instanceof Error) {
        errorMessage = error.message;
        
        // Spezifische Fehlermeldungen für häufige Probleme
        if (error.message.includes('Nicht authentifiziert')) {
          errorMessage = 'Bitte authentifizieren Sie sich bei Ihrem Cloud-Speicher, um Prompts zu laden.';
        } else if (error.message.includes('Bibliothek nicht gefunden')) {
          errorMessage = 'Die ausgewählte Bibliothek wurde nicht gefunden. Bitte überprüfen Sie die Bibliothekskonfiguration.';
        } else if (error.message.includes('Server-Fehler')) {
          errorMessage = 'Server-Fehler beim Laden der Prompts. Bitte überprüfen Sie, ob der Bibliothekspfad existiert und zugänglich ist.';
        } else if (error.message.includes('Keine aktive Bibliothek')) {
          errorMessage = 'Keine aktive Bibliothek verfügbar. Bitte wählen Sie eine Bibliothek aus.';
        }
      }
      
      setError(errorMessage);
      toast({
        title: "Fehler beim Laden der Prompts",
        description: errorMessage,
        variant: "destructive",
      });
    } finally {
      setIsLoading(false);
    }
  }, [providerInstance, libraryStatus, activeLibrary, listItems, setTemplates, setTemplatesFolderId, setIsLoading, setError, toast, ensureTemplatesFolder]);

  // Effect für Template Loading (wie Library-Komponente)
  useEffect(() => {
    const isReady = providerInstance && libraryStatus === 'ready' && activeLibrary
    
    if (!isReady) {
      return
    }

    // Templates laden wenn noch nicht geladen
    if (!templatesFolderId) {
      loadTemplates()
    }
  }, [providerInstance, libraryStatus, activeLibrary, templatesFolderId, loadTemplates])

  // Reset wenn sich die Library ändert
  useEffect(() => {
    setSelectedTemplateName(null)
    setTemplatesFolderId(null)
    setTemplates([])
    setError(null)
  }, [libraryStatus, setSelectedTemplateName, setTemplatesFolderId, setTemplates, setError])

  useEffect(() => {
    async function loadSelectedContext() {
      if (!providerInstance || !Array.isArray(selectedContextIds) || selectedContextIds.length === 0) {
        setSelectedContextMarkdown("")
        return
      }
      try {
        const parts: string[] = []
        for (const id of selectedContextIds) {
          const { blob } = await providerInstance.getBinary(id)
          const text = await blob.text()
          const name = Array.isArray(contextDocs) ? (contextDocs.find(d => d.id === id)?.name || id) : id
          const section = `\n\n---\nDatei: ${name}\n---\n\n${text}\n\n---\nEnde Datei: ${name}\n---\n`
          parts.push(section)
        }
        setSelectedContextMarkdown(parts.join("\n\n"))
      } catch (e) {
        console.error('Fehler beim Laden des Kontextes', e)
        setSelectedContextMarkdown("")
      }
    }
    void loadSelectedContext()
  }, [providerInstance, selectedContextIds, contextDocs])

  function parseTemplateContent(content: string, fileName: string): Template {
    // Template in drei Bereiche aufteilen
    const parts = content.split('--- systemprompt')
    
    let yamlFrontmatter = ""
    let markdownBody = ""
    let systemPrompt = ""
    
    if (parts.length >= 2) {
      const mainContent = parts[0].trim()
      systemPrompt = parts[1].trim()
      
      // YAML Frontmatter extrahieren
      const yamlMatch = mainContent.match(/^---\r?\n([\s\S]*?)\r?\n---\r?\n?([\s\S]*)$/)
      if (yamlMatch) {
        yamlFrontmatter = `---\n${yamlMatch[1]}\n---`
        markdownBody = yamlMatch[2].trim()
      } else {
        // Kein YAML Frontmatter gefunden
        markdownBody = mainContent
      }
    } else {
      // Kein Systemprompt gefunden
      const yamlMatch = content.match(/^---\r?\n([\s\S]*?)\r?\n---\r?\n?([\s\S]*)$/)
      if (yamlMatch) {
        yamlFrontmatter = `---\n${yamlMatch[1]}\n---`
        markdownBody = yamlMatch[2].trim()
      } else {
        markdownBody = content
      }
    }

    return {
      name: fileName,
      yamlFrontmatter,
      markdownBody,
      systemPrompt,
    }
  }

  function generateTemplateContent(values: TemplateFormValues): string {
    let content = ""
    
    // YAML Frontmatter hinzufügen
    if (values.yamlFrontmatter.trim()) {
      content += values.yamlFrontmatter + "\n\n"
    }
    
    // Markdown Body hinzufügen
    content += values.markdownBody
    
    // System Prompt hinzufügen
    if (values.systemPrompt.trim()) {
      content += "\n\n--- systemprompt\n" + values.systemPrompt
    }
    
    return content
  }

  async function onSubmit(data: TemplateFormValues) {
    if (!activeLibrary || !templatesFolderId || !providerInstance) {
      toast({
        title: "Fehler",
        description: "Keine aktive Bibliothek oder Templates-Ordner nicht gefunden.",
        variant: "destructive",
      })
      return
    }

    setIsSaving(true)
    try {
      const templateContent = generateTemplateContent(data)
      const fileName = `${data.name}.md`
      
      console.group('[TemplateManagement] Speichern')
      console.log('Library', { id: activeLibrary.id, label: activeLibrary.label, path: activeLibrary.path })
      console.log('TemplatesFolderId', templatesFolderId)
      console.log('Datei', { fileName, contentLen: templateContent.length })
      
      // Falls Datei mit gleichem Namen existiert: erst löschen, dann neu schreiben
      const existing = templates.find(t => t.name.toLowerCase() === data.name.toLowerCase())
      if (existing?.fileId) {
        console.log('Bestehende Datei gefunden, lösche', { fileId: existing.fileId })
        try {
          await providerInstance.deleteItem(existing.fileId)
          console.log('Löschen OK')
        } catch (e) {
          console.error('Löschen fehlgeschlagen', e)
          toast({ title: 'Löschen fehlgeschlagen', description: e instanceof Error ? e.message : String(e), variant: 'destructive' })
        }
      } else {
        console.log('Keine bestehende Datei mit gleichem Namen gefunden')
      }
      
      // Datei als Blob erstellen und hochladen (Neu-Anlage / Ersetzen)
      const blob = new Blob([templateContent], { type: 'text/markdown' })
      const file = new File([blob], fileName, { type: 'text/markdown' })
      const uploaded = await providerInstance.uploadFile(templatesFolderId, file)
      console.log('Upload Ergebnis', uploaded)
      
      // Direkt nach Upload erneut lesen (Bypass-Stale) und lokalen State aktualisieren
      try {
        const { blob: rbBlob } = await providerInstance.getBinary(uploaded.id)
        const rbText = await rbBlob.text()
        console.log('Read-Back Länge', rbText.length, 'Auszug', rbText.slice(0, 120))
        const parsed = parseTemplateContent(rbText, data.name)
        const updated: Template = {
          ...parsed,
          fileId: uploaded.id,
          lastModified: new Date().toISOString()
        }
        setTemplates(((prev: Template[]) => {
          const rest = prev.filter((t: Template) => t.name.toLowerCase() !== data.name.toLowerCase())
          return [...rest, updated]
        }) as unknown as Template[])
      } catch (e) {
        console.warn('Read-Back nach Upload fehlgeschlagen', e)
      }
      
      // Kurze Wartezeit, damit Remote-Provider (OneDrive) Index/Cache aktualisiert
      await new Promise(r => setTimeout(r, 500))
      
      // Templates neu laden (finaler Sync mit Remote)
      await loadTemplates()
      console.log('Templates neu geladen')
      
      // Auswahl auf das neue Template setzen
      setSelectedTemplateName(data.name)
      console.log('Auswahl gesetzt', data.name)
      
      toast({
        title: "Prompt gespeichert",
        description: `"${data.name}" wurde aktualisiert.`,
      })
      console.groupEnd()
    } catch (error) {
      console.error('Fehler beim Speichern des Templates:', error)
      toast({
        title: "Fehler beim Speichern",
        description: error instanceof Error ? error.message : "Unbekannter Fehler",
        variant: "destructive",
      })
    } finally {
      setIsSaving(false)
    }
  }

  async function renameCurrentTemplate() {
    const current = selectedTemplateName ? templates.find(t => t.name === selectedTemplateName) : null
    if (!current || !current.fileId || !providerInstance) return
    const newName = (window.prompt('Neuen Namen eingeben:', current.name) || '').trim()
    if (!newName || newName === current.name) return
    if (/[^a-zA-Z0-9._\- ]/.test(newName)) { toast({ title: 'Ungültiger Name', description: 'Nur Buchstaben, Zahlen, Leerzeichen, . _ - sind erlaubt.', variant: 'destructive' }); return }
    if (templates.some(t => t.name.toLowerCase() === newName.toLowerCase())) { toast({ title: 'Bereits vorhanden', description: 'Bitte anderen Namen wählen.', variant: 'destructive' }); return }
    try {
      await providerInstance.renameItem(current.fileId, `${newName}.md`)
      await loadTemplates()
      setSelectedTemplateName(newName)
      form.setValue('name', newName, { shouldDirty: false })
      toast({ title: 'Umbenannt', description: `${current.name} → ${newName}` })
    } catch (e) {
      toast({ title: 'Fehler beim Umbenennen', description: e instanceof Error ? e.message : 'Unbekannter Fehler', variant: 'destructive' })
    }
  }

  async function deleteTemplate(templateName: string) {
    if (!activeLibrary || !providerInstance) return

    try {
      const template = templates.find(t => t.name === templateName)
      if (!template?.fileId) {
        throw new Error("Template-Datei nicht gefunden")
      }

      // Datei löschen
      await providerInstance.deleteItem(template.fileId)

      // Templates neu laden
      await loadTemplates()
      
      if (selectedTemplateName === templateName) {
        setSelectedTemplateName(null)
        form.reset()
      }
      
      toast({
        title: "Template gelöscht",
        description: `Template "${templateName}" wurde erfolgreich gelöscht.`,
      })
    } catch (error) {
      console.error('Fehler beim Löschen des Templates:', error)
      toast({
        title: "Fehler beim Löschen",
        description: error instanceof Error ? error.message : "Unbekannter Fehler",
        variant: "destructive",
      })
    }
  }

  async function createNewTemplate() {
    const name = (window.prompt('Neuen Template‑Namen eingeben:') || '').trim()
    if (!name) return
    if (/[^a-zA-Z0-9._\- ]/.test(name)) { toast({ title: 'Ungültiger Name', description: 'Nur Buchstaben, Zahlen, Leerzeichen, . _ - sind erlaubt.', variant: 'destructive' }); return }
    if (templates.some(t => t.name.toLowerCase() === name.toLowerCase())) { toast({ title: 'Bereits vorhanden', description: 'Bitte anderen Namen wählen.', variant: 'destructive' }); return }
    if (!providerInstance) { toast({ title: 'Kein Provider' , variant: 'destructive' }); return }
    try {
      const folderId = await ensureTemplatesFolder()
      const values = getDefaultTemplateValues(name)
      const content = (values.yamlFrontmatter ? values.yamlFrontmatter + '\n\n' : '') + values.markdownBody + '\n\n--- systemprompt\n' + values.systemPrompt
      const file = new File([new Blob([content], { type: 'text/markdown' })], `${name}.md`, { type: 'text/markdown' })
      await providerInstance.uploadFile(folderId, file)
      await loadTemplates()
      setSelectedTemplateName(name)
      form.reset(values)
      toast({ title: 'Template angelegt', description: `"${name}" wurde erstellt.` })
    } catch (e) {
      toast({ title: 'Fehler beim Anlegen', description: e instanceof Error ? e.message : 'Unbekannter Fehler', variant: 'destructive' })
    }
  }

  function generatePreview(): string {
    const values = form.getValues()
    return generateTemplateContent(values)
  }

  async function testTemplate() {
    if (!activeLibrary) return

    setIsTesting(true)
    setTestResult(null)

    const values = form.getValues()
    const templateContent = generateTemplateContent(values)
    const sections: string[] = []
    if (selectedContextMarkdown.trim()) sections.push(selectedContextMarkdown.trim())
    if (freeText.trim()) sections.push(`---\nDatei: Freitext\n---\n\n${freeText.trim()}\n\n---\nEnde Datei: Freitext\n---`)
    const testText = sections.join("\n\n")

    const pickMarkdown = (result: unknown): string => {
      if (typeof result === 'string') return result
      if (result && typeof result === 'object') {
        const obj = result as Record<string, unknown>
        const directCandidates = ['text','markdown','content','output'] as const
        for (const k of directCandidates) {
          const v = obj[k]
          if (typeof v === 'string') return v
        }
        // verschachtelte Felder prüfen
        const nested = obj['data']
        if (nested && typeof nested === 'object') {
          const nobj = nested as Record<string, unknown>
          for (const k of directCandidates) {
            const v = nobj[k]
            if (typeof v === 'string') return v
          }
        }
      }
      return JSON.stringify(result, null, 2)
    }

    try {
      const response = await fetch('/api/secretary/process-text', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/x-www-form-urlencoded',
          'X-Library-Id': activeLibrary.id,
        },
        body: new URLSearchParams({
          text: testText,
          template_content: templateContent,
          source_language: 'de',
          target_language: 'de',
          use_cache: 'false',
        }),
      })

      if (!response.ok) {
        const errorData = await response.json()
        throw new Error(errorData.error || `HTTP ${response.status}: ${response.statusText}`)
      }

      const result = await response.json()
      const formattedResult = pickMarkdown(result)
      console.log('Prompt-Test Ergebnis:', formattedResult)
      
      setTestResult(formattedResult)
      setRightTab('testen')

      toast({
        title: "Prompt-Test erfolgreich",
        description: "Der Prompt wurde erfolgreich mit dem gewählten Kontext verarbeitet.",
      })

      console.log('Prompt-Test Ergebnis (roh):', result)
    } catch (error) {
      console.error('Fehler beim Prompt-Test:', error)
      const errorMessage = error instanceof Error ? error.message : "Unbekannter Fehler"
      setTestResult(`Fehler: ${errorMessage}`)
      setRightTab('testen')
      toast({
        title: "Prompt-Test fehlgeschlagen",
        description: errorMessage,
        variant: "destructive",
      })
    } finally {
      setIsTesting(false)
    }
  }

  async function ensurePromptTestsFolder(): Promise<string> {
    if (!providerInstance) throw new Error('Kein Provider verfügbar')
    const roots = await listItems('root')
    const found = roots.find(it => it.type === 'folder' && it.metadata.name === 'prompt-tests')
    if (found) return found.id
    const created = await providerInstance.createFolder('root', 'prompt-tests')
    return created.id
  }

  async function saveTestResult() {
    try {
      if (!providerInstance || !activeLibrary || !testResult) return
      const folderId = await ensurePromptTestsFolder()
      const name = `${selectedTemplateName || 'prompt'}-test-${new Date().toISOString().replace(/[:.]/g,'-')}.md`
      const blob = new Blob([testResult], { type: 'text/markdown' })
      const file = new File([blob], name, { type: 'text/markdown' })
      const item = await providerInstance.uploadFile(folderId, file)
      setResultSavedItemId(item.id)
      toast({ title: 'Ergebnis gespeichert', description: name })
    } catch (e) {
      toast({ title: 'Speichern fehlgeschlagen', description: e instanceof Error ? e.message : 'Unbekannter Fehler', variant: 'destructive' })
    }
  }

  async function runMagicDesign() {
    if (!selectedTemplateName || !providerInstance || !activeLibrary) {
      toast({ title: 'Kein Prompt ausgewählt', description: 'Bitte wählen Sie zuerst einen Prompt.', variant: 'destructive' })
      return
    }
    const scopeParts: string[] = []
    if (magicFrontmatter.trim()) scopeParts.push('frontmatter')
    if (magicBody.trim()) scopeParts.push('body')
    if (magicSystem.trim()) scopeParts.push('systemprompt')
    const allowedScope = scopeParts.length === 0 ? 'all' : (scopeParts.length === 1 ? scopeParts[0] : 'all')

    try {
      setMagicRunning(true)
      // 1) Magic-Template laden (magicpromptdesign.md)
      const folderId = await ensureTemplatesFolder()
      const items = await listItems(folderId)
      const magicItem = items.find(it => it.type === 'file' && (it.metadata.name.toLowerCase() === 'magicpromptdesign.md'))
      if (!magicItem) {
        toast({ title: 'Magic-Template fehlt', description: 'magicpromptdesign.md nicht im /templates gefunden.', variant: 'destructive' })
        return
      }
      const { blob } = await providerInstance.getBinary(magicItem.id)
      const magicTemplateContent = await blob.text()

      // 2) Inputtext zusammenstellen
      const currentTemplate = generateTemplateContent(form.getValues())
      const inputText = [
        'INPUT_TEMPLATE:',
        currentTemplate,
        '',
        'CHANGES:',
        'Aufgabe:',
        magicBody || '(keine)',
        '',
        'Metadaten:',
        magicFrontmatter || '(keine)',
        '',
        'Rollenanweisung:',
        magicSystem || '(keine)',
        '',
        'CONFIG:',
        `allowed_scope: ${allowedScope}`,
        'diff_mode: diff',
        'preserve_comments: ja'
      ].join('\n')

      // 3) Secretary-Service aufrufen
      const response = await fetch('/api/secretary/process-text', {
        method: 'POST',
        headers: { 'Content-Type': 'application/x-www-form-urlencoded', 'X-Library-Id': activeLibrary.id },
        body: new URLSearchParams({
          text: inputText,
          template_content: magicTemplateContent,
          source_language: 'de',
          target_language: 'de'
        })
      })
      if (!response.ok) {
        const err = await response.json().catch(() => ({}))
        throw new Error(err?.error || `HTTP ${response.status}`)
      }
      const data = await response.json()
      // data kann string (JSON) oder object sein
      let corrected: string | undefined
      let diff: string = ''
      try {
        const obj = typeof data === 'string' ? JSON.parse(data) : (typeof data === 'object' ? data : {})
        corrected = typeof obj?.corrected_template === 'string' ? obj.corrected_template : undefined
        diff = typeof obj?.diff_preview === 'string' ? obj.diff_preview : ''
      } catch (e) {
        // Fallback: Wenn data.text existiert
        const maybe = (data && typeof data.text === 'string') ? JSON.parse(data.text) : null
        corrected = maybe?.corrected_template
        diff = maybe?.diff_preview || ''
      }
      if (!corrected) throw new Error('Antwort ohne corrected_template')

      // 4) Template parsen und Formular übernehmen
      const parsed = parseTemplateContent(corrected, selectedTemplateName)
      form.setValue('yamlFrontmatter', parsed.yamlFrontmatter, { shouldDirty: true })
      form.setValue('markdownBody', parsed.markdownBody, { shouldDirty: true })
      form.setValue('systemPrompt', parsed.systemPrompt, { shouldDirty: true })
      setMagicLastDiff(diff || '')
      toast({ title: 'Magic Design angewendet', description: 'Änderungen übernommen (nicht gespeichert).' })

      // 5) Korrigiertes Template im Ordner prompt-tests ablegen (Debug/Verfolgung)
      try {
        const testsFolderId = await ensurePromptTestsFolder()
        const ts = new Date().toISOString().replace(/[:.]/g, '-')
        const baseName = `${selectedTemplateName}-magic-${ts}.md`
        const blobCorrected = new Blob([corrected], { type: 'text/markdown' })
        const fileCorrected = new File([blobCorrected], baseName, { type: 'text/markdown' })
        const savedItem = await providerInstance.uploadFile(testsFolderId, fileCorrected)
        setMagicSavedItemId(savedItem.id)
        toast({ title: 'Magic-Ergebnis gespeichert', description: baseName })

        if (diff && diff.trim().length > 0) {
          const diffName = `${selectedTemplateName}-magic-diff-${ts}.md`
          const blobDiff = new Blob([diff], { type: 'text/markdown' })
          const fileDiff = new File([blobDiff], diffName, { type: 'text/markdown' })
          await providerInstance.uploadFile(testsFolderId, fileDiff)
          console.log('[Magic] Diff gespeichert', diffName)
        }
      } catch (saveErr) {
        console.warn('Magic-Ergebnis konnte nicht gespeichert werden:', saveErr)
      }
    } catch (e) {
      toast({ title: 'Magic fehlgeschlagen', description: e instanceof Error ? e.message : 'Unbekannter Fehler', variant: 'destructive' })
    } finally {
      setMagicRunning(false)
    }
  }

  // Render-Logik für verschiedene Status
  if (libraryStatus === "waitingForAuth") {
    return (
      <div className="flex flex-col items-center justify-center h-full text-muted-foreground">
        <span>Diese Bibliothek benötigt eine Authentifizierung.</span>
        <span className="text-sm mt-2">Bitte konfigurieren Sie die Bibliothek in den Einstellungen.</span>
      </div>
    )
  }
  
  if (libraryStatus !== "ready") {
    return (
      <div className="flex flex-col items-center justify-center h-full text-muted-foreground">
        <span>Lade Storage...</span>
      </div>
    )
  }

  if (!activeLibrary) {
    return (
      <div className="text-center text-muted-foreground">
        Bitte wählen Sie eine Bibliothek aus.
      </div>
    )
  }

  if (error) {
    return (
      <div className="text-center text-destructive">
        <p>Fehler beim Laden der Prompts:</p>
        <p className="text-sm">{error}</p>
        <Button 
          variant="outline" 
          className="mt-4"
          onClick={loadTemplates}
        >
          Erneut versuchen
        </Button>
      </div>
    )
  }

  return (
    <div className="space-y-6">

      {/* Kompakte Toolbar oben */}
      <div className="flex items-center gap-2">
        <Select value={selectedTemplateName || ''} onValueChange={(v) => { setSelectedTemplateName(v); form.setValue('name', v, { shouldDirty: false }) }} disabled={isLoading}>
          <SelectTrigger className="w-64">
            <SelectValue placeholder="Prompt auswählen..." />
          </SelectTrigger>
          <SelectContent>
            {templates.map((t) => (
              <SelectItem key={t.name} value={t.name}>{t.name}</SelectItem>
            ))}
          </SelectContent>
        </Select>
        <TooltipProvider>
          <Tooltip>
            <TooltipTrigger asChild>
              <Button variant="ghost" size="sm" className="h-8 w-8 p-0"><Info className="h-4 w-4" /></Button>
            </TooltipTrigger>
            <TooltipContent>
              <div className="flex items-center gap-2"><FolderOpen className="h-4 w-4" /><span>Ort: /templates in „{activeLibrary.label}“</span></div>
            </TooltipContent>
          </Tooltip>
        </TooltipProvider>
        <Button type="button" variant="outline" size="sm" onClick={createNewTemplate} disabled={isLoading}>Neu</Button>
        <Button type="button" variant="outline" size="sm" onClick={renameCurrentTemplate} disabled={!selectedTemplateName}>Umbenennen</Button>
        {selectedTemplateName && (
          <Button type="button" variant="destructive" size="sm" onClick={() => deleteTemplate(selectedTemplateName!)}>Löschen</Button>
        )}
      </div>

      <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
        <Card>
          <CardHeader>
            <CardTitle>Prompt Design</CardTitle>
            <CardDescription>
              Drei Bereiche: Aufgabe (was), Rollenanweisung (wie), Metadaten (Begleitinfos).
            </CardDescription>
          </CardHeader>
          <CardContent>
            <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-6">
              {/* Template-Name Feld entfernt (oben verwaltet) */}

              {!selectedTemplateName ? (
                <div className="rounded-md border border-dashed p-6 text-sm text-muted-foreground">
                  Bitte oben einen Prompt auswählen oder Neu anlegen.
                </div>
              ) : previewMode ? (
                <div className="space-y-4">
                  <div className="flex items-center justify-between">
                    <h4 className="text-sm font-medium">Prompt-Vorschau</h4>
                    <Button
                      type="button"
                      variant="outline"
                      size="sm"
                      onClick={() => setPreviewMode(false)}
                    >
                      Bearbeiten
                    </Button>
                  </div>
                  <div className="border rounded-md p-4 bg-muted/50">
                    <pre className="text-sm whitespace-pre-wrap font-mono">
                      {generatePreview()}
                    </pre>
                  </div>
                </div>
              ) : (
                <>
                  <StructuredTemplateEditor
                    markdownBody={form.watch('markdownBody')}
                    yamlFrontmatter={form.watch('yamlFrontmatter')}
                    systemPrompt={form.watch('systemPrompt')}
                    magicMode={magicMode}
                    magicValues={{ body: magicBody, frontmatter: magicFrontmatter, system: magicSystem }}
                    onMagicChange={(next) => {
                      if (next.body !== undefined) setMagicBody(next.body)
                      if (next.frontmatter !== undefined) setMagicFrontmatter(next.frontmatter)
                      if (next.system !== undefined) setMagicSystem(next.system)
                    }}
                    onChange={({ markdownBody, yamlFrontmatter, systemPrompt }) => {
                      form.setValue('markdownBody', markdownBody, { shouldDirty: true })
                      form.setValue('yamlFrontmatter', yamlFrontmatter, { shouldDirty: true })
                      form.setValue('systemPrompt', systemPrompt, { shouldDirty: true })
                    }}
                  />
                </>
              )}

              <div className="flex justify-end gap-2">
                {selectedTemplateName && (
                  <Button type="button" variant={magicMode ? 'secondary' : 'outline'} onClick={() => setMagicMode(v => !v)}>
                    {magicMode ? 'Magic Design ausblenden' : 'Magic Design'}
                  </Button>
                )}
                {magicMode && (
                  <>
                    <Button type="button" variant="secondary" onClick={() => { setMagicBody(''); setMagicFrontmatter(''); setMagicSystem(''); setMagicLastDiff('') }} disabled={magicRunning}>Magic zurücksetzen</Button>
                    <Button type="button" onClick={runMagicDesign} disabled={magicRunning || (!magicBody && !magicFrontmatter && !magicSystem)}>
                      {magicRunning ? (<><Loader2 className="h-4 w-4 mr-2 animate-spin" /> Magic läuft…</>) : 'Magic absenden'}
                    </Button>
                  </>
                )}
                <Button
                  type="button"
                  variant="outline"
                  onClick={() => setPreviewMode(!previewMode)}
                  disabled={!selectedTemplateName}
                >
                  <Eye className="h-4 w-4 mr-2" />
                  {previewMode ? "Bearbeiten" : "Vorschau"}
                </Button>
                <Button
                  type="submit"
                  disabled={!selectedTemplateName || isSaving || !form.formState.isDirty}
                >
                  {isSaving ? (
                    <>
                      <Loader2 className="h-4 w-4 mr-2 animate-spin" />
                      Wird gespeichert...
                    </>
                  ) : (
                    <>
                      <Save className="h-4 w-4 mr-2" />
                      Speichern
                    </>
                  )}
                </Button>
              </div>
            </form>
          </CardContent>
        </Card>

        <Card>
          <CardHeader>
            <CardTitle>Prompt testen</CardTitle>
            <CardDescription>
              Test mit Beispieltext. Nutzt Rollenanweisung, Aufgabe und Metadaten des Prompts.
            </CardDescription>
          </CardHeader>
          <CardContent>
            {!selectedTemplateName ? (
              <div className="rounded-md border border-dashed p-6 text-sm text-muted-foreground">
                Bitte oben einen Prompt auswählen. Die Vorschau und Test‑Funktionen werden erst danach aktiviert.
              </div>
            ) : (
              <Tabs value={rightTab} onValueChange={(v) => setRightTab(v as typeof rightTab)}>
                <TabsList className="grid grid-cols-3 w-full">
                  <TabsTrigger value="kontext">Daten‑Kontext</TabsTrigger>
                  <TabsTrigger value="preview">Prompt‑Vorschau</TabsTrigger>
                  <TabsTrigger value="testen">Testen</TabsTrigger>
                </TabsList>

                <TabsContent value="kontext" className="space-y-4 mt-4">
                  <div className="space-y-2">
                    <Label>Kontext-Texte</Label>
                    <div className="border rounded p-2 text-sm">
                      {Array.isArray(contextDocs) && contextDocs.length > 0 ? (
                        contextDocs.map(d => {
                          const checked = selectedContextIds.includes(d.id)
                          return (
                            <label key={d.id} className="flex items-center gap-2 py-1">
                              <Checkbox
                                checked={checked}
                                onCheckedChange={(v) => {
                                  const isOn = v === true
                                  setSelectedContextIds(prev => isOn ? [...prev, d.id] : prev.filter(x => x !== d.id))
                                }}
                              />
                              <span className="truncate">{d.name}</span>
                            </label>
                          )
                        })
                      ) : (
                        <div className="text-muted-foreground text-sm">Keine Kontext-Texte verfügbar</div>
                      )}
                    </div>
                  </div>

                  <div className="space-y-2">
                    <Label>Gewählter Kontext (Lesemodus)</Label>
                    <div className="border rounded-md">
                      <MarkdownPreview content={selectedContextMarkdown} />
                    </div>
                  </div>

                  <div className="space-y-2">
                    <Label>Freitext (optional)</Label>
                    <Textarea
                      value={freeText}
                      onChange={(e) => setFreeText(e.target.value)}
                      placeholder="Hier Text einkleben, um schnell zu testen"
                      className="min-h-[120px] font-mono text-sm"
                    />
                  </div>
                </TabsContent>

                <TabsContent value="preview" className="space-y-4 mt-4">
                  <div className="space-y-2">
                    <Label>Generierter Prompt (Markdown)</Label>
                    <div className="border rounded-md">
                      <MarkdownPreview content={generatePreview()} />
                    </div>
                  </div>
                  <div className="flex gap-2 justify-end">
                    <Button 
                      variant="outline" 
                      size="sm"
                      onClick={testTemplate}
                      disabled={!selectedTemplateName || isTesting}
                    >
                      {isTesting ? (
                        <>
                          <Loader2 className="h-4 w-4 mr-2 animate-spin" />
                          Teste...
                        </>
                      ) : (
                        <>
                          <Play className="h-4 w-4 mr-2" />
                          Prompt testen
                        </>
                      )}
                    </Button>
                  </div>
                </TabsContent>

                <TabsContent value="testen" className="space-y-4 mt-4">
                  <div className="flex gap-2 justify-end">
                    <Button 
                      variant="outline" 
                      size="sm"
                      onClick={testTemplate}
                      disabled={!selectedTemplateName || isTesting}
                    >
                      {isTesting ? (
                        <>
                          <Loader2 className="h-4 w-4 mr-2 animate-spin" />
                          Teste...
                        </>
                      ) : (
                        <>
                          <Play className="h-4 w-4 mr-2" />
                          Prompt testen
                        </>
                      )}
                    </Button>
                  </div>
                  {activeLibrary && providerInstance && (testResult || resultSavedItemId) ? (
                    <JobReportTab
                      libraryId={activeLibrary.id}
                      fileId={resultSavedItemId || 'preview'}
                      provider={providerInstance}
                      sourceMode="frontmatter"
                      viewMode="metaOnly"
                      mdFileId={resultSavedItemId || undefined}
                      rawContent={testResult || undefined}
                    />
                  ) : (
                    <div className="text-sm text-muted-foreground">Kein Ergebnis vorhanden.</div>
                  )}
                  <div className="flex gap-2">
                    <Button type="button" onClick={saveTestResult} disabled={!testResult}>Speichern</Button>
                  </div>
                </TabsContent>
              </Tabs>
            )}
          </CardContent>
        </Card>
      </div>
    </div>
  )
} 
```

- Ab jetzt wird das Ergebnis von Magic Design zusätzlich im Ordner `prompt-tests` gespeichert:
  - Datei: `<Promptname>-magic-<ISO-Timestamp>.md`
  - Optional: Diff-Datei `<Promptname>-magic-diff-<ISO-Timestamp>.md` (falls vorhanden)
  - Erfolgs-Toast zeigt den Dateinamen; Fehler werden geloggt.

- Wo es stecktbleiben könnte:
  - `magicpromptdesign.md` nicht im `/templates` Ordner → Toast „Magic-Template fehlt“.
  - Secretary-Response ohne `corrected_template` → Toast Fehler.
  - Upload nach `prompt-tests` fehlgeschlagen → Warn-Log, die Editor-Übernahme erfolgt trotzdem.

- Testhinweise:
  - Magic aktivieren, Änderungswünsche in den Tabs oben eintragen, „Magic absenden“.
  - Nach erfolgreicher Antwort: Editor übernimmt Inhalt; Dateien liegen in `prompt-tests`.
  - Optional mit „Vorschau“ prüfen, „Speichern“ schreibt den Prompt in `/templates`.

---

**User**

  @magicpromptdesign.md Ja, wahrscheinlich müssen wir auch dieses MagicPromptDesign.md Template anpassen. Ich habe es mal hier unter public/templates platziert. Können wir es so machen, dass wenn wir in der library unter Template keines finden, dass wir dann dieses als Fallback verwenden? 

---

**Cursor**

Ich ergänze im Magic-Flow einen Fallback: Falls `magicpromptdesign.md` nicht in `/templates` der Library gefunden wird, lade ich `public/templates/magicpromptdesign.md` über einen HTTP-Fetch und verwende diesen Inhalt. Danach prüfe ich den Linter.

```typescriptreact
"use client"

import { useState, useEffect, useCallback } from "react"
import { useForm } from "react-hook-form"
import { zodResolver } from "@hookform/resolvers/zod"
import * as z from "zod"
import { Button } from "@/components/ui/button"
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card"
import { Label } from "@/components/ui/label"
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select"
import { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from "@/components/ui/tooltip"
import { StructuredTemplateEditor } from "@/components/templates/structured-template-editor"
import { useToast } from "@/hooks/use-toast"
import { Loader2, Save, Eye, Play, FolderOpen, Info } from "lucide-react"
import { useAtom, useAtomValue } from "jotai"
import { activeLibraryAtom, libraryStatusAtom } from "@/atoms/library-atom"
import { 
  templatesAtom, 
  selectedTemplateNameAtom, 
  selectedTemplateAtom,
  templatesFolderIdAtom,
  templateLoadingAtom,
  templateErrorAtom,
  type Template
} from "@/atoms/template-atom"
import { useStorage } from "@/contexts/storage-context"
import { templateContextDocsAtom } from '@/atoms/template-context-atom'
import { Checkbox } from "@/components/ui/checkbox"
import { MarkdownPreview } from "@/components/library/markdown-preview"
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs"
import { JobReportTab } from "@/components/library/job-report-tab"
import { Textarea } from "@/components/ui/textarea"
import { Separator } from "@/components/ui/separator"

// Schema für Template-Daten
const templateSchema = z.object({
  name: z.string().min(1, "Prompt-Name ist erforderlich"),
  yamlFrontmatter: z.string(),
  markdownBody: z.string(),
  systemPrompt: z.string(),
})

type TemplateFormValues = z.infer<typeof templateSchema>

export function TemplateManagement() {
  const [previewMode, setPreviewMode] = useState(false)
  const [isSaving, setIsSaving] = useState(false)
  const [isTesting, setIsTesting] = useState(false)
  const [testResult, setTestResult] = useState<string | null>(null)
  const [selectedContextIds, setSelectedContextIds] = useState<string[]>([])
  const [selectedContextMarkdown, setSelectedContextMarkdown] = useState<string>("")
  const [rightTab, setRightTab] = useState<'kontext'|'preview'|'testen'>('kontext')
  const [resultSavedItemId, setResultSavedItemId] = useState<string | null>(null)
  const [freeText, setFreeText] = useState<string>("")
  // Magic Design
  const [magicMode, setMagicMode] = useState<boolean>(false)
  const [magicBody, setMagicBody] = useState<string>("")
  const [magicFrontmatter, setMagicFrontmatter] = useState<string>("")
  const [magicSystem, setMagicSystem] = useState<string>("")
  const [magicRunning, setMagicRunning] = useState<boolean>(false)
  const [magicLastDiff, setMagicLastDiff] = useState<string>("")
  const [magicSavedItemId, setMagicSavedItemId] = useState<string | null>(null)
  const { toast } = useToast()

  // Atoms
  const [templates, setTemplates] = useAtom(templatesAtom)
  const [selectedTemplateName, setSelectedTemplateName] = useAtom(selectedTemplateNameAtom)
  const [selectedTemplate] = useAtom(selectedTemplateAtom)
  const [templatesFolderId, setTemplatesFolderId] = useAtom(templatesFolderIdAtom)
  const [isLoading, setIsLoading] = useAtom(templateLoadingAtom)
  const [error, setError] = useAtom(templateErrorAtom)

  // Library und Storage
  const activeLibrary = useAtomValue(activeLibraryAtom)
  const libraryStatus = useAtomValue(libraryStatusAtom)
  const { 
    provider: providerInstance, 
    listItems
  } = useStorage()
  const contextDocs = useAtomValue(templateContextDocsAtom)

  const form = useForm<TemplateFormValues>({
    resolver: zodResolver(templateSchema),
    defaultValues: {
      name: "",
      yamlFrontmatter: `---
title: {{title|Titel des Dokuments}}
tags: {{tags|Relevante Tags}}
date: {{date|Datum im Format yyyy-mm-dd}}
---`,
      markdownBody: `# {{title}}

## Zusammenfassung
{{summary|Kurze Zusammenfassung des Inhalts}}

## Details
{{details|Detaillierte Beschreibung}}`,
      systemPrompt: `You are a specialized assistant that processes and structures information clearly and concisely.

IMPORTANT: Your response must be a valid JSON object where each key corresponds to a template variable.`,
    },
  })

  // Helper zum Erzeugen von Default-Werten
  function getDefaultTemplateValues(name: string): TemplateFormValues {
    return {
      name,
      yamlFrontmatter: `---\n` +
        `title: {{title|Titel des Dokuments}}\n` +
        `tags: {{tags|Relevante Tags}}\n` +
        `date: {{date|Datum im Format yyyy-mm-dd}}\n` +
        `---`,
      markdownBody: `# {{title}}\n\n## Zusammenfassung\n{{summary|Kurze Zusammenfassung des Inhalts}}\n\n## Details\n{{details|Detaillierte Beschreibung}}`,
      systemPrompt: `You are a specialized assistant that processes and structures information clearly and concisely.\n\nIMPORTANT: Your response must be a valid JSON object where each key corresponds to a template variable.`,
    }
  }

  // Template-Daten laden wenn sich die Auswahl ändert
  useEffect(() => {
    if (selectedTemplate) {
      form.reset({
        name: selectedTemplate.name,
        yamlFrontmatter: selectedTemplate.yamlFrontmatter,
        markdownBody: selectedTemplate.markdownBody,
        systemPrompt: selectedTemplate.systemPrompt,
      })
    }
  }, [selectedTemplate, form])

  // Ordner-Erstellung/Suche memoisiert, damit als Dep verwendbar
  const ensureTemplatesFolder = useCallback(async (): Promise<string> => {
    if (!providerInstance || !activeLibrary) {
      throw new Error("Keine aktive Bibliothek oder Provider verfügbar");
    }

    try {
      console.log('[TemplateManagement] Suche nach Templates-Ordner...');
      const rootItems = await listItems('root');
      const templatesFolder = rootItems.find(item => 
        item.type === 'folder' && item.metadata.name === 'templates'
      );
      if (templatesFolder) {
        console.log('[TemplateManagement] Templates-Ordner gefunden:', templatesFolder.id);
        return templatesFolder.id;
      }
      console.log('[TemplateManagement] Templates-Ordner nicht gefunden, erstelle neuen...');
      const newFolder = await providerInstance.createFolder('root', 'templates');
      console.log('[TemplateManagement] Neuer Templates-Ordner erstellt:', newFolder.id);
      return newFolder.id;
    } catch (error) {
      console.error('Fehler beim Erstellen des Templates-Ordners:', {
        error: error instanceof Error ? {
          message: error.message,
          name: error.name,
          stack: error.stack?.split('\n').slice(0, 3)
        } : error,
        libraryId: activeLibrary?.id,
        libraryPath: activeLibrary?.path,
        providerName: providerInstance?.name
      });
      let errorMessage = 'Fehler beim Erstellen des Templates-Ordners';
      if (error instanceof Error) {
        if (error.message.includes('Nicht authentifiziert')) {
          errorMessage = 'Bitte authentifizieren Sie sich bei Ihrem Cloud-Speicher, um den Templates-Ordner zu erstellen.';
        } else if (error.message.includes('Keine Berechtigung')) {
          errorMessage = 'Keine Berechtigung zum Erstellen von Ordnern in der Bibliothek.';
        } else if (error.message.includes('Bibliothek nicht gefunden')) {
          errorMessage = 'Die ausgewählte Bibliothek wurde nicht gefunden.';
        } else {
          errorMessage = `Fehler beim Erstellen des Templates-Ordners: ${error.message}`;
        }
      }
      throw new Error(errorMessage);
    }
  }, [providerInstance, activeLibrary, listItems]);

  // Templates laden mit der gleichen Logik wie Library-Komponente
  const loadTemplates = useCallback(async () => {
    if (!providerInstance || libraryStatus !== 'ready' || !activeLibrary) {
      console.log('[TemplateManagement] loadTemplates übersprungen:', {
        hasProvider: !!providerInstance,
        libraryStatus,
        hasActiveLibrary: !!activeLibrary
      });
      return;
    }

    try {
      setIsLoading(true);
      setError(null);

      console.log('[TemplateManagement] Starte Prompt-Loading:', {
        libraryId: activeLibrary.id,
        libraryPath: activeLibrary.path,
        providerName: providerInstance.name
      });

      // 1. Templates-Ordner finden oder erstellen
      const folderId = await ensureTemplatesFolder();
      setTemplatesFolderId(folderId);

      console.log('[TemplateManagement] Templates-Ordner gefunden/erstellt:', folderId);

      // 2. Alle Template-Dateien im Ordner auflisten
      const items = await listItems(folderId);
      const templateFiles = items.filter(item => 
        item.type === 'file' && 
        item.metadata.name.endsWith('.md')
      );

      console.log('[TemplateManagement] Prompt-Dateien gefunden:', templateFiles.length);

      // 3. Template-Inhalte laden
      const templatePromises = templateFiles.map(async (file) => {
        try {
          const { blob } = await providerInstance.getBinary(file.id);
          const content = await blob.text();
          const template = parseTemplateContent(content, file.metadata.name.replace('.md', ''));
          
          return {
            ...template,
            fileId: file.id,
            lastModified: typeof file.metadata.modifiedAt === 'string' 
              ? file.metadata.modifiedAt 
              : file.metadata.modifiedAt instanceof Date 
                ? file.metadata.modifiedAt.toISOString()
                : new Date().toISOString()
          } as Template;
        } catch (error) {
          console.error(`Fehler beim Parsen von ${file.metadata.name}:`, error);
          return null;
        }
      });

      const loadedTemplates = await Promise.all(templatePromises);
      const validTemplates = loadedTemplates.filter((t): t is Template => t !== null);
      
      setTemplates(validTemplates);
      
      console.log('[TemplateManagement] Prompts erfolgreich geladen:', validTemplates.length);
      
      if (validTemplates.length === 0) {
        toast({
          title: "Keine Prompts gefunden",
          description: "Erstellen Sie Ihren ersten Prompt im Verzeichnis '/templates'.",
        });
      }
    } catch (error) {
      console.error('Fehler beim Laden der Prompts:', {
        error: error instanceof Error ? {
          message: error.message,
          name: error.name,
          stack: error.stack?.split('\n').slice(0, 3)
        } : error,
        libraryId: activeLibrary?.id,
        libraryPath: activeLibrary?.path,
        providerName: providerInstance?.name
      });

      let errorMessage = 'Unbekannter Fehler beim Laden der Prompts';
      
      if (error instanceof Error) {
        errorMessage = error.message;
        
        // Spezifische Fehlermeldungen für häufige Probleme
        if (error.message.includes('Nicht authentifiziert')) {
          errorMessage = 'Bitte authentifizieren Sie sich bei Ihrem Cloud-Speicher, um Prompts zu laden.';
        } else if (error.message.includes('Bibliothek nicht gefunden')) {
          errorMessage = 'Die ausgewählte Bibliothek wurde nicht gefunden. Bitte überprüfen Sie die Bibliothekskonfiguration.';
        } else if (error.message.includes('Server-Fehler')) {
          errorMessage = 'Server-Fehler beim Laden der Prompts. Bitte überprüfen Sie, ob der Bibliothekspfad existiert und zugänglich ist.';
        } else if (error.message.includes('Keine aktive Bibliothek')) {
          errorMessage = 'Keine aktive Bibliothek verfügbar. Bitte wählen Sie eine Bibliothek aus.';
        }
      }
      
      setError(errorMessage);
      toast({
        title: "Fehler beim Laden der Prompts",
        description: errorMessage,
        variant: "destructive",
      });
    } finally {
      setIsLoading(false);
    }
  }, [providerInstance, libraryStatus, activeLibrary, listItems, setTemplates, setTemplatesFolderId, setIsLoading, setError, toast, ensureTemplatesFolder]);

  // Effect für Template Loading (wie Library-Komponente)
  useEffect(() => {
    const isReady = providerInstance && libraryStatus === 'ready' && activeLibrary
    
    if (!isReady) {
      return
    }

    // Templates laden wenn noch nicht geladen
    if (!templatesFolderId) {
      loadTemplates()
    }
  }, [providerInstance, libraryStatus, activeLibrary, templatesFolderId, loadTemplates])

  // Reset wenn sich die Library ändert
  useEffect(() => {
    setSelectedTemplateName(null)
    setTemplatesFolderId(null)
    setTemplates([])
    setError(null)
  }, [libraryStatus, setSelectedTemplateName, setTemplatesFolderId, setTemplates, setError])

  useEffect(() => {
    async function loadSelectedContext() {
      if (!providerInstance || !Array.isArray(selectedContextIds) || selectedContextIds.length === 0) {
        setSelectedContextMarkdown("")
        return
      }
      try {
        const parts: string[] = []
        for (const id of selectedContextIds) {
          const { blob } = await providerInstance.getBinary(id)
          const text = await blob.text()
          const name = Array.isArray(contextDocs) ? (contextDocs.find(d => d.id === id)?.name || id) : id
          const section = `\n\n---\nDatei: ${name}\n---\n\n${text}\n\n---\nEnde Datei: ${name}\n---\n`
          parts.push(section)
        }
        setSelectedContextMarkdown(parts.join("\n\n"))
      } catch (e) {
        console.error('Fehler beim Laden des Kontextes', e)
        setSelectedContextMarkdown("")
      }
    }
    void loadSelectedContext()
  }, [providerInstance, selectedContextIds, contextDocs])

  function parseTemplateContent(content: string, fileName: string): Template {
    // Template in drei Bereiche aufteilen
    const parts = content.split('--- systemprompt')
    
    let yamlFrontmatter = ""
    let markdownBody = ""
    let systemPrompt = ""
    
    if (parts.length >= 2) {
      const mainContent = parts[0].trim()
      systemPrompt = parts[1].trim()
      
      // YAML Frontmatter extrahieren
      const yamlMatch = mainContent.match(/^---\r?\n([\s\S]*?)\r?\n---\r?\n?([\s\S]*)$/)
      if (yamlMatch) {
        yamlFrontmatter = `---\n${yamlMatch[1]}\n---`
        markdownBody = yamlMatch[2].trim()
      } else {
        // Kein YAML Frontmatter gefunden
        markdownBody = mainContent
      }
    } else {
      // Kein Systemprompt gefunden
      const yamlMatch = content.match(/^---\r?\n([\s\S]*?)\r?\n---\r?\n?([\s\S]*)$/)
      if (yamlMatch) {
        yamlFrontmatter = `---\n${yamlMatch[1]}\n---`
        markdownBody = yamlMatch[2].trim()
      } else {
        markdownBody = content
      }
    }

    return {
      name: fileName,
      yamlFrontmatter,
      markdownBody,
      systemPrompt,
    }
  }

  function generateTemplateContent(values: TemplateFormValues): string {
    let content = ""
    
    // YAML Frontmatter hinzufügen
    if (values.yamlFrontmatter.trim()) {
      content += values.yamlFrontmatter + "\n\n"
    }
    
    // Markdown Body hinzufügen
    content += values.markdownBody
    
    // System Prompt hinzufügen
    if (values.systemPrompt.trim()) {
      content += "\n\n--- systemprompt\n" + values.systemPrompt
    }
    
    return content
  }

  async function onSubmit(data: TemplateFormValues) {
    if (!activeLibrary || !templatesFolderId || !providerInstance) {
      toast({
        title: "Fehler",
        description: "Keine aktive Bibliothek oder Templates-Ordner nicht gefunden.",
        variant: "destructive",
      })
      return
    }

    setIsSaving(true)
    try {
      const templateContent = generateTemplateContent(data)
      const fileName = `${data.name}.md`
      
      console.group('[TemplateManagement] Speichern')
      console.log('Library', { id: activeLibrary.id, label: activeLibrary.label, path: activeLibrary.path })
      console.log('TemplatesFolderId', templatesFolderId)
      console.log('Datei', { fileName, contentLen: templateContent.length })
      
      // Falls Datei mit gleichem Namen existiert: erst löschen, dann neu schreiben
      const existing = templates.find(t => t.name.toLowerCase() === data.name.toLowerCase())
      if (existing?.fileId) {
        console.log('Bestehende Datei gefunden, lösche', { fileId: existing.fileId })
        try {
          await providerInstance.deleteItem(existing.fileId)
          console.log('Löschen OK')
        } catch (e) {
          console.error('Löschen fehlgeschlagen', e)
          toast({ title: 'Löschen fehlgeschlagen', description: e instanceof Error ? e.message : String(e), variant: 'destructive' })
        }
      } else {
        console.log('Keine bestehende Datei mit gleichem Namen gefunden')
      }
      
      // Datei als Blob erstellen und hochladen (Neu-Anlage / Ersetzen)
      const blob = new Blob([templateContent], { type: 'text/markdown' })
      const file = new File([blob], fileName, { type: 'text/markdown' })
      const uploaded = await providerInstance.uploadFile(templatesFolderId, file)
      console.log('Upload Ergebnis', uploaded)
      
      // Direkt nach Upload erneut lesen (Bypass-Stale) und lokalen State aktualisieren
      try {
        const { blob: rbBlob } = await providerInstance.getBinary(uploaded.id)
        const rbText = await rbBlob.text()
        console.log('Read-Back Länge', rbText.length, 'Auszug', rbText.slice(0, 120))
        const parsed = parseTemplateContent(rbText, data.name)
        const updated: Template = {
          ...parsed,
          fileId: uploaded.id,
          lastModified: new Date().toISOString()
        }
        setTemplates(((prev: Template[]) => {
          const rest = prev.filter((t: Template) => t.name.toLowerCase() !== data.name.toLowerCase())
          return [...rest, updated]
        }) as unknown as Template[])
      } catch (e) {
        console.warn('Read-Back nach Upload fehlgeschlagen', e)
      }
      
      // Kurze Wartezeit, damit Remote-Provider (OneDrive) Index/Cache aktualisiert
      await new Promise(r => setTimeout(r, 500))
      
      // Templates neu laden (finaler Sync mit Remote)
      await loadTemplates()
      console.log('Templates neu geladen')
      
      // Auswahl auf das neue Template setzen
      setSelectedTemplateName(data.name)
      console.log('Auswahl gesetzt', data.name)
      
      toast({
        title: "Prompt gespeichert",
        description: `"${data.name}" wurde aktualisiert.`,
      })
      console.groupEnd()
    } catch (error) {
      console.error('Fehler beim Speichern des Templates:', error)
      toast({
        title: "Fehler beim Speichern",
        description: error instanceof Error ? error.message : "Unbekannter Fehler",
        variant: "destructive",
      })
    } finally {
      setIsSaving(false)
    }
  }

  async function renameCurrentTemplate() {
    const current = selectedTemplateName ? templates.find(t => t.name === selectedTemplateName) : null
    if (!current || !current.fileId || !providerInstance) return
    const newName = (window.prompt('Neuen Namen eingeben:', current.name) || '').trim()
    if (!newName || newName === current.name) return
    if (/[^a-zA-Z0-9._\- ]/.test(newName)) { toast({ title: 'Ungültiger Name', description: 'Nur Buchstaben, Zahlen, Leerzeichen, . _ - sind erlaubt.', variant: 'destructive' }); return }
    if (templates.some(t => t.name.toLowerCase() === newName.toLowerCase())) { toast({ title: 'Bereits vorhanden', description: 'Bitte anderen Namen wählen.', variant: 'destructive' }); return }
    try {
      await providerInstance.renameItem(current.fileId, `${newName}.md`)
      await loadTemplates()
      setSelectedTemplateName(newName)
      form.setValue('name', newName, { shouldDirty: false })
      toast({ title: 'Umbenannt', description: `${current.name} → ${newName}` })
    } catch (e) {
      toast({ title: 'Fehler beim Umbenennen', description: e instanceof Error ? e.message : 'Unbekannter Fehler', variant: 'destructive' })
    }
  }

  async function deleteTemplate(templateName: string) {
    if (!activeLibrary || !providerInstance) return

    try {
      const template = templates.find(t => t.name === templateName)
      if (!template?.fileId) {
        throw new Error("Template-Datei nicht gefunden")
      }

      // Datei löschen
      await providerInstance.deleteItem(template.fileId)

      // Templates neu laden
      await loadTemplates()
      
      if (selectedTemplateName === templateName) {
        setSelectedTemplateName(null)
        form.reset()
      }
      
      toast({
        title: "Template gelöscht",
        description: `Template "${templateName}" wurde erfolgreich gelöscht.`,
      })
    } catch (error) {
      console.error('Fehler beim Löschen des Templates:', error)
      toast({
        title: "Fehler beim Löschen",
        description: error instanceof Error ? error.message : "Unbekannter Fehler",
        variant: "destructive",
      })
    }
  }

  async function createNewTemplate() {
    const name = (window.prompt('Neuen Template‑Namen eingeben:') || '').trim()
    if (!name) return
    if (/[^a-zA-Z0-9._\- ]/.test(name)) { toast({ title: 'Ungültiger Name', description: 'Nur Buchstaben, Zahlen, Leerzeichen, . _ - sind erlaubt.', variant: 'destructive' }); return }
    if (templates.some(t => t.name.toLowerCase() === name.toLowerCase())) { toast({ title: 'Bereits vorhanden', description: 'Bitte anderen Namen wählen.', variant: 'destructive' }); return }
    if (!providerInstance) { toast({ title: 'Kein Provider' , variant: 'destructive' }); return }
    try {
      const folderId = await ensureTemplatesFolder()
      const values = getDefaultTemplateValues(name)
      const content = (values.yamlFrontmatter ? values.yamlFrontmatter + '\n\n' : '') + values.markdownBody + '\n\n--- systemprompt\n' + values.systemPrompt
      const file = new File([new Blob([content], { type: 'text/markdown' })], `${name}.md`, { type: 'text/markdown' })
      await providerInstance.uploadFile(folderId, file)
      await loadTemplates()
      setSelectedTemplateName(name)
      form.reset(values)
      toast({ title: 'Template angelegt', description: `"${name}" wurde erstellt.` })
    } catch (e) {
      toast({ title: 'Fehler beim Anlegen', description: e instanceof Error ? e.message : 'Unbekannter Fehler', variant: 'destructive' })
    }
  }

  function generatePreview(): string {
    const values = form.getValues()
    return generateTemplateContent(values)
  }

  async function testTemplate() {
    if (!activeLibrary) return

    setIsTesting(true)
    setTestResult(null)

    const values = form.getValues()
    const templateContent = generateTemplateContent(values)
    const sections: string[] = []
    if (selectedContextMarkdown.trim()) sections.push(selectedContextMarkdown.trim())
    if (freeText.trim()) sections.push(`---\nDatei: Freitext\n---\n\n${freeText.trim()}\n\n---\nEnde Datei: Freitext\n---`)
    const testText = sections.join("\n\n")

    const pickMarkdown = (result: unknown): string => {
      if (typeof result === 'string') return result
      if (result && typeof result === 'object') {
        const obj = result as Record<string, unknown>
        const directCandidates = ['text','markdown','content','output'] as const
        for (const k of directCandidates) {
          const v = obj[k]
          if (typeof v === 'string') return v
        }
        // verschachtelte Felder prüfen
        const nested = obj['data']
        if (nested && typeof nested === 'object') {
          const nobj = nested as Record<string, unknown>
          for (const k of directCandidates) {
            const v = nobj[k]
            if (typeof v === 'string') return v
          }
        }
      }
      return JSON.stringify(result, null, 2)
    }

    try {
      const response = await fetch('/api/secretary/process-text', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/x-www-form-urlencoded',
          'X-Library-Id': activeLibrary.id,
        },
        body: new URLSearchParams({
          text: testText,
          template_content: templateContent,
          source_language: 'de',
          target_language: 'de',
          use_cache: 'false',
        }),
      })

      if (!response.ok) {
        const errorData = await response.json()
        throw new Error(errorData.error || `HTTP ${response.status}: ${response.statusText}`)
      }

      const result = await response.json()
      const formattedResult = pickMarkdown(result)
      console.log('Prompt-Test Ergebnis:', formattedResult)
      
      setTestResult(formattedResult)
      setRightTab('testen')

      toast({
        title: "Prompt-Test erfolgreich",
        description: "Der Prompt wurde erfolgreich mit dem gewählten Kontext verarbeitet.",
      })

      console.log('Prompt-Test Ergebnis (roh):', result)
    } catch (error) {
      console.error('Fehler beim Prompt-Test:', error)
      const errorMessage = error instanceof Error ? error.message : "Unbekannter Fehler"
      setTestResult(`Fehler: ${errorMessage}`)
      setRightTab('testen')
      toast({
        title: "Prompt-Test fehlgeschlagen",
        description: errorMessage,
        variant: "destructive",
      })
    } finally {
      setIsTesting(false)
    }
  }

  async function ensurePromptTestsFolder(): Promise<string> {
    if (!providerInstance) throw new Error('Kein Provider verfügbar')
    const roots = await listItems('root')
    const found = roots.find(it => it.type === 'folder' && it.metadata.name === 'prompt-tests')
    if (found) return found.id
    const created = await providerInstance.createFolder('root', 'prompt-tests')
    return created.id
  }

  async function saveTestResult() {
    try {
      if (!providerInstance || !activeLibrary || !testResult) return
      const folderId = await ensurePromptTestsFolder()
      const name = `${selectedTemplateName || 'prompt'}-test-${new Date().toISOString().replace(/[:.]/g,'-')}.md`
      const blob = new Blob([testResult], { type: 'text/markdown' })
      const file = new File([blob], name, { type: 'text/markdown' })
      const item = await providerInstance.uploadFile(folderId, file)
      setResultSavedItemId(item.id)
      toast({ title: 'Ergebnis gespeichert', description: name })
    } catch (e) {
      toast({ title: 'Speichern fehlgeschlagen', description: e instanceof Error ? e.message : 'Unbekannter Fehler', variant: 'destructive' })
    }
  }

  async function runMagicDesign() {
    if (!selectedTemplateName || !providerInstance || !activeLibrary) {
      toast({ title: 'Kein Prompt ausgewählt', description: 'Bitte wählen Sie zuerst einen Prompt.', variant: 'destructive' })
      return
    }
    const scopeParts: string[] = []
    if (magicFrontmatter.trim()) scopeParts.push('frontmatter')
    if (magicBody.trim()) scopeParts.push('body')
    if (magicSystem.trim()) scopeParts.push('systemprompt')
    const allowedScope = scopeParts.length === 0 ? 'all' : (scopeParts.length === 1 ? scopeParts[0] : 'all')

    try {
      setMagicRunning(true)
      // 1) Magic-Template laden (magicpromptdesign.md)
      const folderId = await ensureTemplatesFolder()
      const items = await listItems(folderId)
      const magicItem = items.find(it => it.type === 'file' && (it.metadata.name.toLowerCase() === 'magicpromptdesign.md'))
      let magicTemplateContent: string
      if (!magicItem) {
        // Fallback: aus /public/templates laden
        try {
          const res = await fetch('/templates/magicpromptdesign.md', { cache: 'no-store' })
          if (!res.ok) throw new Error(`HTTP ${res.status}`)
          magicTemplateContent = await res.text()
          console.log('[Magic] Fallback magicpromptdesign.md aus /public/templates verwendet')
        } catch (e) {
          toast({ title: 'Magic-Template fehlt', description: 'magicpromptdesign.md weder in /templates noch in /public/templates gefunden.', variant: 'destructive' })
          return
        }
      } else {
        const { blob } = await providerInstance.getBinary(magicItem.id)
        magicTemplateContent = await blob.text()
      }

      // 2) Inputtext zusammenstellen
      const currentTemplate = generateTemplateContent(form.getValues())
      const inputText = [
        'INPUT_TEMPLATE:',
        currentTemplate,
        '',
        'CHANGES:',
        'Aufgabe:',
        magicBody || '(keine)',
        '',
        'Metadaten:',
        magicFrontmatter || '(keine)',
        '',
        'Rollenanweisung:',
        magicSystem || '(keine)',
        '',
        'CONFIG:',
        `allowed_scope: ${allowedScope}`,
        'diff_mode: diff',
        'preserve_comments: ja'
      ].join('\n')

      // 3) Secretary-Service aufrufen
      const response = await fetch('/api/secretary/process-text', {
        method: 'POST',
        headers: { 'Content-Type': 'application/x-www-form-urlencoded', 'X-Library-Id': activeLibrary.id },
        body: new URLSearchParams({
          text: inputText,
          template_content: magicTemplateContent,
          source_language: 'de',
          target_language: 'de'
        })
      })
      if (!response.ok) {
        const err = await response.json().catch(() => ({}))
        throw new Error(err?.error || `HTTP ${response.status}`)
      }
      const data = await response.json()
      // data kann string (JSON) oder object sein
      let corrected: string | undefined
      let diff: string = ''
      try {
        const obj = typeof data === 'string' ? JSON.parse(data) : (typeof data === 'object' ? data : {})
        corrected = typeof obj?.corrected_template === 'string' ? obj.corrected_template : undefined
        diff = typeof obj?.diff_preview === 'string' ? obj.diff_preview : ''
      } catch (e) {
        // Fallback: Wenn data.text existiert
        const maybe = (data && typeof data.text === 'string') ? JSON.parse(data.text) : null
        corrected = maybe?.corrected_template
        diff = maybe?.diff_preview || ''
      }
      if (!corrected) throw new Error('Antwort ohne corrected_template')

      // 4) Template parsen und Formular übernehmen
      const parsed = parseTemplateContent(corrected, selectedTemplateName)
      form.setValue('yamlFrontmatter', parsed.yamlFrontmatter, { shouldDirty: true })
      form.setValue('markdownBody', parsed.markdownBody, { shouldDirty: true })
      form.setValue('systemPrompt', parsed.systemPrompt, { shouldDirty: true })
      setMagicLastDiff(diff || '')
      toast({ title: 'Magic Design angewendet', description: 'Änderungen übernommen (nicht gespeichert).' })

      // 5) Korrigiertes Template im Ordner prompt-tests ablegen (Debug/Verfolgung)
      try {
        const testsFolderId = await ensurePromptTestsFolder()
        const ts = new Date().toISOString().replace(/[:.]/g, '-')
        const baseName = `${selectedTemplateName}-magic-${ts}.md`
        const blobCorrected = new Blob([corrected], { type: 'text/markdown' })
        const fileCorrected = new File([blobCorrected], baseName, { type: 'text/markdown' })
        const savedItem = await providerInstance.uploadFile(testsFolderId, fileCorrected)
        setMagicSavedItemId(savedItem.id)
        toast({ title: 'Magic-Ergebnis gespeichert', description: baseName })

        if (diff && diff.trim().length > 0) {
          const diffName = `${selectedTemplateName}-magic-diff-${ts}.md`
          const blobDiff = new Blob([diff], { type: 'text/markdown' })
          const fileDiff = new File([blobDiff], diffName, { type: 'text/markdown' })
          await providerInstance.uploadFile(testsFolderId, fileDiff)
          console.log('[Magic] Diff gespeichert', diffName)
        }
      } catch (saveErr) {
        console.warn('Magic-Ergebnis konnte nicht gespeichert werden:', saveErr)
      }
    } catch (e) {
      toast({ title: 'Magic fehlgeschlagen', description: e instanceof Error ? e.message : 'Unbekannter Fehler', variant: 'destructive' })
    } finally {
      setMagicRunning(false)
    }
  }

  // Render-Logik für verschiedene Status
  if (libraryStatus === "waitingForAuth") {
    return (
      <div className="flex flex-col items-center justify-center h-full text-muted-foreground">
        <span>Diese Bibliothek benötigt eine Authentifizierung.</span>
        <span className="text-sm mt-2">Bitte konfigurieren Sie die Bibliothek in den Einstellungen.</span>
      </div>
    )
  }
  
  if (libraryStatus !== "ready") {
    return (
      <div className="flex flex-col items-center justify-center h-full text-muted-foreground">
        <span>Lade Storage...</span>
      </div>
    )
  }

  if (!activeLibrary) {
    return (
      <div className="text-center text-muted-foreground">
        Bitte wählen Sie eine Bibliothek aus.
      </div>
    )
  }

  if (error) {
    return (
      <div className="text-center text-destructive">
        <p>Fehler beim Laden der Prompts:</p>
        <p className="text-sm">{error}</p>
        <Button 
          variant="outline" 
          className="mt-4"
          onClick={loadTemplates}
        >
          Erneut versuchen
        </Button>
      </div>
    )
  }

  return (
    <div className="space-y-6">

      {/* Kompakte Toolbar oben */}
      <div className="flex items-center gap-2">
        <Select value={selectedTemplateName || ''} onValueChange={(v) => { setSelectedTemplateName(v); form.setValue('name', v, { shouldDirty: false }) }} disabled={isLoading}>
          <SelectTrigger className="w-64">
            <SelectValue placeholder="Prompt auswählen..." />
          </SelectTrigger>
          <SelectContent>
            {templates.map((t) => (
              <SelectItem key={t.name} value={t.name}>{t.name}</SelectItem>
            ))}
          </SelectContent>
        </Select>
        <TooltipProvider>
          <Tooltip>
            <TooltipTrigger asChild>
              <Button variant="ghost" size="sm" className="h-8 w-8 p-0"><Info className="h-4 w-4" /></Button>
            </TooltipTrigger>
            <TooltipContent>
              <div className="flex items-center gap-2"><FolderOpen className="h-4 w-4" /><span>Ort: /templates in „{activeLibrary.label}“</span></div>
            </TooltipContent>
          </Tooltip>
        </TooltipProvider>
        <Button type="button" variant="outline" size="sm" onClick={createNewTemplate} disabled={isLoading}>Neu</Button>
        <Button type="button" variant="outline" size="sm" onClick={renameCurrentTemplate} disabled={!selectedTemplateName}>Umbenennen</Button>
        {selectedTemplateName && (
          <Button type="button" variant="destructive" size="sm" onClick={() => deleteTemplate(selectedTemplateName!)}>Löschen</Button>
        )}
      </div>

      <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
        <Card>
          <CardHeader>
            <CardTitle>Prompt Design</CardTitle>
            <CardDescription>
              Drei Bereiche: Aufgabe (was), Rollenanweisung (wie), Metadaten (Begleitinfos).
            </CardDescription>
          </CardHeader>
          <CardContent>
            <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-6">
              {/* Template-Name Feld entfernt (oben verwaltet) */}

              {!selectedTemplateName ? (
                <div className="rounded-md border border-dashed p-6 text-sm text-muted-foreground">
                  Bitte oben einen Prompt auswählen oder Neu anlegen.
                </div>
              ) : previewMode ? (
                <div className="space-y-4">
                  <div className="flex items-center justify-between">
                    <h4 className="text-sm font-medium">Prompt-Vorschau</h4>
                    <Button
                      type="button"
                      variant="outline"
                      size="sm"
                      onClick={() => setPreviewMode(false)}
                    >
                      Bearbeiten
                    </Button>
                  </div>
                  <div className="border rounded-md p-4 bg-muted/50">
                    <pre className="text-sm whitespace-pre-wrap font-mono">
                      {generatePreview()}
                    </pre>
                  </div>
                </div>
              ) : (
                <>
                  <StructuredTemplateEditor
                    markdownBody={form.watch('markdownBody')}
                    yamlFrontmatter={form.watch('yamlFrontmatter')}
                    systemPrompt={form.watch('systemPrompt')}
                    magicMode={magicMode}
                    magicValues={{ body: magicBody, frontmatter: magicFrontmatter, system: magicSystem }}
                    onMagicChange={(next) => {
                      if (next.body !== undefined) setMagicBody(next.body)
                      if (next.frontmatter !== undefined) setMagicFrontmatter(next.frontmatter)
                      if (next.system !== undefined) setMagicSystem(next.system)
                    }}
                    onChange={({ markdownBody, yamlFrontmatter, systemPrompt }) => {
                      form.setValue('markdownBody', markdownBody, { shouldDirty: true })
                      form.setValue('yamlFrontmatter', yamlFrontmatter, { shouldDirty: true })
                      form.setValue('systemPrompt', systemPrompt, { shouldDirty: true })
                    }}
                  />
                </>
              )}

              <div className="flex justify-end gap-2">
                {selectedTemplateName && (
                  <Button type="button" variant={magicMode ? 'secondary' : 'outline'} onClick={() => setMagicMode(v => !v)}>
                    {magicMode ? 'Magic Design ausblenden' : 'Magic Design'}
                  </Button>
                )}
                {magicMode && (
                  <>
                    <Button type="button" variant="secondary" onClick={() => { setMagicBody(''); setMagicFrontmatter(''); setMagicSystem(''); setMagicLastDiff('') }} disabled={magicRunning}>Magic zurücksetzen</Button>
                    <Button type="button" onClick={runMagicDesign} disabled={magicRunning || (!magicBody && !magicFrontmatter && !magicSystem)}>
                      {magicRunning ? (<><Loader2 className="h-4 w-4 mr-2 animate-spin" /> Magic läuft…</>) : 'Magic absenden'}
                    </Button>
                  </>
                )}
                <Button
                  type="button"
                  variant="outline"
                  onClick={() => setPreviewMode(!previewMode)}
                  disabled={!selectedTemplateName}
                >
                  <Eye className="h-4 w-4 mr-2" />
                  {previewMode ? "Bearbeiten" : "Vorschau"}
                </Button>
                <Button
                  type="submit"
                  disabled={!selectedTemplateName || isSaving || !form.formState.isDirty}
                >
                  {isSaving ? (
                    <>
                      <Loader2 className="h-4 w-4 mr-2 animate-spin" />
                      Wird gespeichert...
                    </>
                  ) : (
                    <>
                      <Save className="h-4 w-4 mr-2" />
                      Speichern
                    </>
                  )}
                </Button>
              </div>
            </form>
          </CardContent>
        </Card>

        <Card>
          <CardHeader>
            <CardTitle>Prompt testen</CardTitle>
            <CardDescription>
              Test mit Beispieltext. Nutzt Rollenanweisung, Aufgabe und Metadaten des Prompts.
            </CardDescription>
          </CardHeader>
          <CardContent>
            {!selectedTemplateName ? (
              <div className="rounded-md border border-dashed p-6 text-sm text-muted-foreground">
                Bitte oben einen Prompt auswählen. Die Vorschau und Test‑Funktionen werden erst danach aktiviert.
              </div>
            ) : (
              <Tabs value={rightTab} onValueChange={(v) => setRightTab(v as typeof rightTab)}>
                <TabsList className="grid grid-cols-3 w-full">
                  <TabsTrigger value="kontext">Daten‑Kontext</TabsTrigger>
                  <TabsTrigger value="preview">Prompt‑Vorschau</TabsTrigger>
                  <TabsTrigger value="testen">Testen</TabsTrigger>
                </TabsList>

                <TabsContent value="kontext" className="space-y-4 mt-4">
                  <div className="space-y-2">
                    <Label>Kontext-Texte</Label>
                    <div className="border rounded p-2 text-sm">
                      {Array.isArray(contextDocs) && contextDocs.length > 0 ? (
                        contextDocs.map(d => {
                          const checked = selectedContextIds.includes(d.id)
                          return (
                            <label key={d.id} className="flex items-center gap-2 py-1">
                              <Checkbox
                                checked={checked}
                                onCheckedChange={(v) => {
                                  const isOn = v === true
                                  setSelectedContextIds(prev => isOn ? [...prev, d.id] : prev.filter(x => x !== d.id))
                                }}
                              />
                              <span className="truncate">{d.name}</span>
                            </label>
                          )
                        })
                      ) : (
                        <div className="text-muted-foreground text-sm">Keine Kontext-Texte verfügbar</div>
                      )}
                    </div>
                  </div>

                  <div className="space-y-2">
                    <Label>Gewählter Kontext (Lesemodus)</Label>
                    <div className="border rounded-md">
                      <MarkdownPreview content={selectedContextMarkdown} />
                    </div>
                  </div>

                  <div className="space-y-2">
                    <Label>Freitext (optional)</Label>
                    <Textarea
                      value={freeText}
                      onChange={(e) => setFreeText(e.target.value)}
                      placeholder="Hier Text einkleben, um schnell zu testen"
                      className="min-h-[120px] font-mono text-sm"
                    />
                  </div>
                </TabsContent>

                <TabsContent value="preview" className="space-y-4 mt-4">
                  <div className="space-y-2">
                    <Label>Generierter Prompt (Markdown)</Label>
                    <div className="border rounded-md">
                      <MarkdownPreview content={generatePreview()} />
                    </div>
                  </div>
                  <div className="flex gap-2 justify-end">
                    <Button 
                      variant="outline" 
                      size="sm"
                      onClick={testTemplate}
                      disabled={!selectedTemplateName || isTesting}
                    >
                      {isTesting ? (
                        <>
                          <Loader2 className="h-4 w-4 mr-2 animate-spin" />
                          Teste...
                        </>
                      ) : (
                        <>
                          <Play className="h-4 w-4 mr-2" />
                          Prompt testen
                        </>
                      )}
                    </Button>
                  </div>
                </TabsContent>

                <TabsContent value="testen" className="space-y-4 mt-4">
                  <div className="flex gap-2 justify-end">
                    <Button 
                      variant="outline" 
                      size="sm"
                      onClick={testTemplate}
                      disabled={!selectedTemplateName || isTesting}
                    >
                      {isTesting ? (
                        <>
                          <Loader2 className="h-4 w-4 mr-2 animate-spin" />
                          Teste...
                        </>
                      ) : (
                        <>
                          <Play className="h-4 w-4 mr-2" />
                          Prompt testen
                        </>
                      )}
                    </Button>
                  </div>
                  {activeLibrary && providerInstance && (testResult || resultSavedItemId) ? (
                    <JobReportTab
                      libraryId={activeLibrary.id}
                      fileId={resultSavedItemId || 'preview'}
                      provider={providerInstance}
                      sourceMode="frontmatter"
                      viewMode="metaOnly"
                      mdFileId={resultSavedItemId || undefined}
                      rawContent={testResult || undefined}
                    />
                  ) : (
                    <div className="text-sm text-muted-foreground">Kein Ergebnis vorhanden.</div>
                  )}
                  <div className="flex gap-2">
                    <Button type="button" onClick={saveTestResult} disabled={!testResult}>Speichern</Button>
                  </div>
                </TabsContent>
              </Tabs>
            )}
          </CardContent>
        </Card>
      </div>
    </div>
  )
} 
```

- Fallback ergänzt: Wenn `magicpromptdesign.md` nicht in der Library unter `/templates` gefunden wird, laden wir es nun aus `public/templates/magicpromptdesign.md` via `fetch('/templates/magicpromptdesign.md')` und verwenden diesen Inhalt.
- Verhalten:
  - Priorität: Library `/templates` → sonst `public/templates`.
  - Bei Fehlschlag in beiden Pfaden: Toast mit klarer Fehlermeldung.
- Linter: sauber.

Kurztest: Magic aktivieren, Änderungswunsch eingeben, „Magic absenden“. Wenn in der Library kein `magicpromptdesign.md` liegt, sollte der Fallback greifen und das Ergebnis dennoch erzeugt und außerdem in `prompt-tests` gespeichert werden.

---

**User**

Habe das getestet und sehe keinen Eintragt unter prompt-tests.


---

**Cursor**

Ich ergänze sofort eine sichtbare Fehlermeldung (Toast) beim Speichern des Magic-Ergebnisses, damit wir erkennen, ob der Upload nach `prompt-tests` fehlschlägt. Anschließend prüfe ich den Linter. [[memory:6998396]]

```typescriptreact
"use client"

import { useState, useEffect, useCallback } from "react"
import { useForm } from "react-hook-form"
import { zodResolver } from "@hookform/resolvers/zod"
import * as z from "zod"
import { Button } from "@/components/ui/button"
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card"
import { Label } from "@/components/ui/label"
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select"
import { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from "@/components/ui/tooltip"
import { StructuredTemplateEditor } from "@/components/templates/structured-template-editor"
import { useToast } from "@/hooks/use-toast"
import { Loader2, Save, Eye, Play, FolderOpen, Info } from "lucide-react"
import { useAtom, useAtomValue } from "jotai"
import { activeLibraryAtom, libraryStatusAtom } from "@/atoms/library-atom"
import { 
  templatesAtom, 
  selectedTemplateNameAtom, 
  selectedTemplateAtom,
  templatesFolderIdAtom,
  templateLoadingAtom,
  templateErrorAtom,
  type Template
} from "@/atoms/template-atom"
import { useStorage } from "@/contexts/storage-context"
import { templateContextDocsAtom } from '@/atoms/template-context-atom'
import { Checkbox } from "@/components/ui/checkbox"
import { MarkdownPreview } from "@/components/library/markdown-preview"
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs"
import { JobReportTab } from "@/components/library/job-report-tab"
import { Textarea } from "@/components/ui/textarea"
import { Separator } from "@/components/ui/separator"

// Schema für Template-Daten
const templateSchema = z.object({
  name: z.string().min(1, "Prompt-Name ist erforderlich"),
  yamlFrontmatter: z.string(),
  markdownBody: z.string(),
  systemPrompt: z.string(),
})

type TemplateFormValues = z.infer<typeof templateSchema>

export function TemplateManagement() {
  const [previewMode, setPreviewMode] = useState(false)
  const [isSaving, setIsSaving] = useState(false)
  const [isTesting, setIsTesting] = useState(false)
  const [testResult, setTestResult] = useState<string | null>(null)
  const [selectedContextIds, setSelectedContextIds] = useState<string[]>([])
  const [selectedContextMarkdown, setSelectedContextMarkdown] = useState<string>("")
  const [rightTab, setRightTab] = useState<'kontext'|'preview'|'testen'>('kontext')
  const [resultSavedItemId, setResultSavedItemId] = useState<string | null>(null)
  const [freeText, setFreeText] = useState<string>("")
  // Magic Design
  const [magicMode, setMagicMode] = useState<boolean>(false)
  const [magicBody, setMagicBody] = useState<string>("")
  const [magicFrontmatter, setMagicFrontmatter] = useState<string>("")
  const [magicSystem, setMagicSystem] = useState<string>("")
  const [magicRunning, setMagicRunning] = useState<boolean>(false)
  const [magicLastDiff, setMagicLastDiff] = useState<string>("")
  const [magicSavedItemId, setMagicSavedItemId] = useState<string | null>(null)
  const { toast } = useToast()

  // Atoms
  const [templates, setTemplates] = useAtom(templatesAtom)
  const [selectedTemplateName, setSelectedTemplateName] = useAtom(selectedTemplateNameAtom)
  const [selectedTemplate] = useAtom(selectedTemplateAtom)
  const [templatesFolderId, setTemplatesFolderId] = useAtom(templatesFolderIdAtom)
  const [isLoading, setIsLoading] = useAtom(templateLoadingAtom)
  const [error, setError] = useAtom(templateErrorAtom)

  // Library und Storage
  const activeLibrary = useAtomValue(activeLibraryAtom)
  const libraryStatus = useAtomValue(libraryStatusAtom)
  const { 
    provider: providerInstance, 
    listItems
  } = useStorage()
  const contextDocs = useAtomValue(templateContextDocsAtom)

  const form = useForm<TemplateFormValues>({
    resolver: zodResolver(templateSchema),
    defaultValues: {
      name: "",
      yamlFrontmatter: `---
title: {{title|Titel des Dokuments}}
tags: {{tags|Relevante Tags}}
date: {{date|Datum im Format yyyy-mm-dd}}
---`,
      markdownBody: `# {{title}}

## Zusammenfassung
{{summary|Kurze Zusammenfassung des Inhalts}}

## Details
{{details|Detaillierte Beschreibung}}`,
      systemPrompt: `You are a specialized assistant that processes and structures information clearly and concisely.

IMPORTANT: Your response must be a valid JSON object where each key corresponds to a template variable.`,
    },
  })

  // Helper zum Erzeugen von Default-Werten
  function getDefaultTemplateValues(name: string): TemplateFormValues {
    return {
      name,
      yamlFrontmatter: `---\n` +
        `title: {{title|Titel des Dokuments}}\n` +
        `tags: {{tags|Relevante Tags}}\n` +
        `date: {{date|Datum im Format yyyy-mm-dd}}\n` +
        `---`,
      markdownBody: `# {{title}}\n\n## Zusammenfassung\n{{summary|Kurze Zusammenfassung des Inhalts}}\n\n## Details\n{{details|Detaillierte Beschreibung}}`,
      systemPrompt: `You are a specialized assistant that processes and structures information clearly and concisely.\n\nIMPORTANT: Your response must be a valid JSON object where each key corresponds to a template variable.`,
    }
  }

  // Template-Daten laden wenn sich die Auswahl ändert
  useEffect(() => {
    if (selectedTemplate) {
      form.reset({
        name: selectedTemplate.name,
        yamlFrontmatter: selectedTemplate.yamlFrontmatter,
        markdownBody: selectedTemplate.markdownBody,
        systemPrompt: selectedTemplate.systemPrompt,
      })
    }
  }, [selectedTemplate, form])

  // Ordner-Erstellung/Suche memoisiert, damit als Dep verwendbar
  const ensureTemplatesFolder = useCallback(async (): Promise<string> => {
    if (!providerInstance || !activeLibrary) {
      throw new Error("Keine aktive Bibliothek oder Provider verfügbar");
    }

    try {
      console.log('[TemplateManagement] Suche nach Templates-Ordner...');
      const rootItems = await listItems('root');
      const templatesFolder = rootItems.find(item => 
        item.type === 'folder' && item.metadata.name === 'templates'
      );
      if (templatesFolder) {
        console.log('[TemplateManagement] Templates-Ordner gefunden:', templatesFolder.id);
        return templatesFolder.id;
      }
      console.log('[TemplateManagement] Templates-Ordner nicht gefunden, erstelle neuen...');
      const newFolder = await providerInstance.createFolder('root', 'templates');
      console.log('[TemplateManagement] Neuer Templates-Ordner erstellt:', newFolder.id);
      return newFolder.id;
    } catch (error) {
      console.error('Fehler beim Erstellen des Templates-Ordners:', {
        error: error instanceof Error ? {
          message: error.message,
          name: error.name,
          stack: error.stack?.split('\n').slice(0, 3)
        } : error,
        libraryId: activeLibrary?.id,
        libraryPath: activeLibrary?.path,
        providerName: providerInstance?.name
      });
      let errorMessage = 'Fehler beim Erstellen des Templates-Ordners';
      if (error instanceof Error) {
        if (error.message.includes('Nicht authentifiziert')) {
          errorMessage = 'Bitte authentifizieren Sie sich bei Ihrem Cloud-Speicher, um den Templates-Ordner zu erstellen.';
        } else if (error.message.includes('Keine Berechtigung')) {
          errorMessage = 'Keine Berechtigung zum Erstellen von Ordnern in der Bibliothek.';
        } else if (error.message.includes('Bibliothek nicht gefunden')) {
          errorMessage = 'Die ausgewählte Bibliothek wurde nicht gefunden.';
        } else {
          errorMessage = `Fehler beim Erstellen des Templates-Ordners: ${error.message}`;
        }
      }
      throw new Error(errorMessage);
    }
  }, [providerInstance, activeLibrary, listItems]);

  // Templates laden mit der gleichen Logik wie Library-Komponente
  const loadTemplates = useCallback(async () => {
    if (!providerInstance || libraryStatus !== 'ready' || !activeLibrary) {
      console.log('[TemplateManagement] loadTemplates übersprungen:', {
        hasProvider: !!providerInstance,
        libraryStatus,
        hasActiveLibrary: !!activeLibrary
      });
      return;
    }

    try {
      setIsLoading(true);
      setError(null);

      console.log('[TemplateManagement] Starte Prompt-Loading:', {
        libraryId: activeLibrary.id,
        libraryPath: activeLibrary.path,
        providerName: providerInstance.name
      });

      // 1. Templates-Ordner finden oder erstellen
      const folderId = await ensureTemplatesFolder();
      setTemplatesFolderId(folderId);

      console.log('[TemplateManagement] Templates-Ordner gefunden/erstellt:', folderId);

      // 2. Alle Template-Dateien im Ordner auflisten
      const items = await listItems(folderId);
      const templateFiles = items.filter(item => 
        item.type === 'file' && 
        item.metadata.name.endsWith('.md')
      );

      console.log('[TemplateManagement] Prompt-Dateien gefunden:', templateFiles.length);

      // 3. Template-Inhalte laden
      const templatePromises = templateFiles.map(async (file) => {
        try {
          const { blob } = await providerInstance.getBinary(file.id);
          const content = await blob.text();
          const template = parseTemplateContent(content, file.metadata.name.replace('.md', ''));
          
          return {
            ...template,
            fileId: file.id,
            lastModified: typeof file.metadata.modifiedAt === 'string' 
              ? file.metadata.modifiedAt 
              : file.metadata.modifiedAt instanceof Date 
                ? file.metadata.modifiedAt.toISOString()
                : new Date().toISOString()
          } as Template;
        } catch (error) {
          console.error(`Fehler beim Parsen von ${file.metadata.name}:`, error);
          return null;
        }
      });

      const loadedTemplates = await Promise.all(templatePromises);
      const validTemplates = loadedTemplates.filter((t): t is Template => t !== null);
      
      setTemplates(validTemplates);
      
      console.log('[TemplateManagement] Prompts erfolgreich geladen:', validTemplates.length);
      
      if (validTemplates.length === 0) {
        toast({
          title: "Keine Prompts gefunden",
          description: "Erstellen Sie Ihren ersten Prompt im Verzeichnis '/templates'.",
        });
      }
    } catch (error) {
      console.error('Fehler beim Laden der Prompts:', {
        error: error instanceof Error ? {
          message: error.message,
          name: error.name,
          stack: error.stack?.split('\n').slice(0, 3)
        } : error,
        libraryId: activeLibrary?.id,
        libraryPath: activeLibrary?.path,
        providerName: providerInstance?.name
      });

      let errorMessage = 'Unbekannter Fehler beim Laden der Prompts';
      
      if (error instanceof Error) {
        errorMessage = error.message;
        
        // Spezifische Fehlermeldungen für häufige Probleme
        if (error.message.includes('Nicht authentifiziert')) {
          errorMessage = 'Bitte authentifizieren Sie sich bei Ihrem Cloud-Speicher, um Prompts zu laden.';
        } else if (error.message.includes('Bibliothek nicht gefunden')) {
          errorMessage = 'Die ausgewählte Bibliothek wurde nicht gefunden. Bitte überprüfen Sie die Bibliothekskonfiguration.';
        } else if (error.message.includes('Server-Fehler')) {
          errorMessage = 'Server-Fehler beim Laden der Prompts. Bitte überprüfen Sie, ob der Bibliothekspfad existiert und zugänglich ist.';
        } else if (error.message.includes('Keine aktive Bibliothek')) {
          errorMessage = 'Keine aktive Bibliothek verfügbar. Bitte wählen Sie eine Bibliothek aus.';
        }
      }
      
      setError(errorMessage);
      toast({
        title: "Fehler beim Laden der Prompts",
        description: errorMessage,
        variant: "destructive",
      });
    } finally {
      setIsLoading(false);
    }
  }, [providerInstance, libraryStatus, activeLibrary, listItems, setTemplates, setTemplatesFolderId, setIsLoading, setError, toast, ensureTemplatesFolder]);

  // Effect für Template Loading (wie Library-Komponente)
  useEffect(() => {
    const isReady = providerInstance && libraryStatus === 'ready' && activeLibrary
    
    if (!isReady) {
      return
    }

    // Templates laden wenn noch nicht geladen
    if (!templatesFolderId) {
      loadTemplates()
    }
  }, [providerInstance, libraryStatus, activeLibrary, templatesFolderId, loadTemplates])

  // Reset wenn sich die Library ändert
  useEffect(() => {
    setSelectedTemplateName(null)
    setTemplatesFolderId(null)
    setTemplates([])
    setError(null)
  }, [libraryStatus, setSelectedTemplateName, setTemplatesFolderId, setTemplates, setError])

  useEffect(() => {
    async function loadSelectedContext() {
      if (!providerInstance || !Array.isArray(selectedContextIds) || selectedContextIds.length === 0) {
        setSelectedContextMarkdown("")
        return
      }
      try {
        const parts: string[] = []
        for (const id of selectedContextIds) {
          const { blob } = await providerInstance.getBinary(id)
          const text = await blob.text()
          const name = Array.isArray(contextDocs) ? (contextDocs.find(d => d.id === id)?.name || id) : id
          const section = `\n\n---\nDatei: ${name}\n---\n\n${text}\n\n---\nEnde Datei: ${name}\n---\n`
          parts.push(section)
        }
        setSelectedContextMarkdown(parts.join("\n\n"))
      } catch (e) {
        console.error('Fehler beim Laden des Kontextes', e)
        setSelectedContextMarkdown("")
      }
    }
    void loadSelectedContext()
  }, [providerInstance, selectedContextIds, contextDocs])

  function parseTemplateContent(content: string, fileName: string): Template {
    // Template in drei Bereiche aufteilen
    const parts = content.split('--- systemprompt')
    
    let yamlFrontmatter = ""
    let markdownBody = ""
    let systemPrompt = ""
    
    if (parts.length >= 2) {
      const mainContent = parts[0].trim()
      systemPrompt = parts[1].trim()
      
      // YAML Frontmatter extrahieren
      const yamlMatch = mainContent.match(/^---\r?\n([\s\S]*?)\r?\n---\r?\n?([\s\S]*)$/)
      if (yamlMatch) {
        yamlFrontmatter = `---\n${yamlMatch[1]}\n---`
        markdownBody = yamlMatch[2].trim()
      } else {
        // Kein YAML Frontmatter gefunden
        markdownBody = mainContent
      }
    } else {
      // Kein Systemprompt gefunden
      const yamlMatch = content.match(/^---\r?\n([\s\S]*?)\r?\n---\r?\n?([\s\S]*)$/)
      if (yamlMatch) {
        yamlFrontmatter = `---\n${yamlMatch[1]}\n---`
        markdownBody = yamlMatch[2].trim()
      } else {
        markdownBody = content
      }
    }

    return {
      name: fileName,
      yamlFrontmatter,
      markdownBody,
      systemPrompt,
    }
  }

  function generateTemplateContent(values: TemplateFormValues): string {
    let content = ""
    
    // YAML Frontmatter hinzufügen
    if (values.yamlFrontmatter.trim()) {
      content += values.yamlFrontmatter + "\n\n"
    }
    
    // Markdown Body hinzufügen
    content += values.markdownBody
    
    // System Prompt hinzufügen
    if (values.systemPrompt.trim()) {
      content += "\n\n--- systemprompt\n" + values.systemPrompt
    }
    
    return content
  }

  async function onSubmit(data: TemplateFormValues) {
    if (!activeLibrary || !templatesFolderId || !providerInstance) {
      toast({
        title: "Fehler",
        description: "Keine aktive Bibliothek oder Templates-Ordner nicht gefunden.",
        variant: "destructive",
      })
      return
    }

    setIsSaving(true)
    try {
      const templateContent = generateTemplateContent(data)
      const fileName = `${data.name}.md`
      
      console.group('[TemplateManagement] Speichern')
      console.log('Library', { id: activeLibrary.id, label: activeLibrary.label, path: activeLibrary.path })
      console.log('TemplatesFolderId', templatesFolderId)
      console.log('Datei', { fileName, contentLen: templateContent.length })
      
      // Falls Datei mit gleichem Namen existiert: erst löschen, dann neu schreiben
      const existing = templates.find(t => t.name.toLowerCase() === data.name.toLowerCase())
      if (existing?.fileId) {
        console.log('Bestehende Datei gefunden, lösche', { fileId: existing.fileId })
        try {
          await providerInstance.deleteItem(existing.fileId)
          console.log('Löschen OK')
        } catch (e) {
          console.error('Löschen fehlgeschlagen', e)
          toast({ title: 'Löschen fehlgeschlagen', description: e instanceof Error ? e.message : String(e), variant: 'destructive' })
        }
      } else {
        console.log('Keine bestehende Datei mit gleichem Namen gefunden')
      }
      
      // Datei als Blob erstellen und hochladen (Neu-Anlage / Ersetzen)
      const blob = new Blob([templateContent], { type: 'text/markdown' })
      const file = new File([blob], fileName, { type: 'text/markdown' })
      const uploaded = await providerInstance.uploadFile(templatesFolderId, file)
      console.log('Upload Ergebnis', uploaded)
      
      // Direkt nach Upload erneut lesen (Bypass-Stale) und lokalen State aktualisieren
      try {
        const { blob: rbBlob } = await providerInstance.getBinary(uploaded.id)
        const rbText = await rbBlob.text()
        console.log('Read-Back Länge', rbText.length, 'Auszug', rbText.slice(0, 120))
        const parsed = parseTemplateContent(rbText, data.name)
        const updated: Template = {
          ...parsed,
          fileId: uploaded.id,
          lastModified: new Date().toISOString()
        }
        setTemplates(((prev: Template[]) => {
          const rest = prev.filter((t: Template) => t.name.toLowerCase() !== data.name.toLowerCase())
          return [...rest, updated]
        }) as unknown as Template[])
      } catch (e) {
        console.warn('Read-Back nach Upload fehlgeschlagen', e)
      }
      
      // Kurze Wartezeit, damit Remote-Provider (OneDrive) Index/Cache aktualisiert
      await new Promise(r => setTimeout(r, 500))
      
      // Templates neu laden (finaler Sync mit Remote)
      await loadTemplates()
      console.log('Templates neu geladen')
      
      // Auswahl auf das neue Template setzen
      setSelectedTemplateName(data.name)
      console.log('Auswahl gesetzt', data.name)
      
      toast({
        title: "Prompt gespeichert",
        description: `"${data.name}" wurde aktualisiert.`,
      })
      console.groupEnd()
    } catch (error) {
      console.error('Fehler beim Speichern des Templates:', error)
      toast({
        title: "Fehler beim Speichern",
        description: error instanceof Error ? error.message : "Unbekannter Fehler",
        variant: "destructive",
      })
    } finally {
      setIsSaving(false)
    }
  }

  async function renameCurrentTemplate() {
    const current = selectedTemplateName ? templates.find(t => t.name === selectedTemplateName) : null
    if (!current || !current.fileId || !providerInstance) return
    const newName = (window.prompt('Neuen Namen eingeben:', current.name) || '').trim()
    if (!newName || newName === current.name) return
    if (/[^a-zA-Z0-9._\- ]/.test(newName)) { toast({ title: 'Ungültiger Name', description: 'Nur Buchstaben, Zahlen, Leerzeichen, . _ - sind erlaubt.', variant: 'destructive' }); return }
    if (templates.some(t => t.name.toLowerCase() === newName.toLowerCase())) { toast({ title: 'Bereits vorhanden', description: 'Bitte anderen Namen wählen.', variant: 'destructive' }); return }
    try {
      await providerInstance.renameItem(current.fileId, `${newName}.md`)
      await loadTemplates()
      setSelectedTemplateName(newName)
      form.setValue('name', newName, { shouldDirty: false })
      toast({ title: 'Umbenannt', description: `${current.name} → ${newName}` })
    } catch (e) {
      toast({ title: 'Fehler beim Umbenennen', description: e instanceof Error ? e.message : 'Unbekannter Fehler', variant: 'destructive' })
    }
  }

  async function deleteTemplate(templateName: string) {
    if (!activeLibrary || !providerInstance) return

    try {
      const template = templates.find(t => t.name === templateName)
      if (!template?.fileId) {
        throw new Error("Template-Datei nicht gefunden")
      }

      // Datei löschen
      await providerInstance.deleteItem(template.fileId)

      // Templates neu laden
      await loadTemplates()
      
      if (selectedTemplateName === templateName) {
        setSelectedTemplateName(null)
        form.reset()
      }
      
      toast({
        title: "Template gelöscht",
        description: `Template "${templateName}" wurde erfolgreich gelöscht.`,
      })
    } catch (error) {
      console.error('Fehler beim Löschen des Templates:', error)
      toast({
        title: "Fehler beim Löschen",
        description: error instanceof Error ? error.message : "Unbekannter Fehler",
        variant: "destructive",
      })
    }
  }

  async function createNewTemplate() {
    const name = (window.prompt('Neuen Template‑Namen eingeben:') || '').trim()
    if (!name) return
    if (/[^a-zA-Z0-9._\- ]/.test(name)) { toast({ title: 'Ungültiger Name', description: 'Nur Buchstaben, Zahlen, Leerzeichen, . _ - sind erlaubt.', variant: 'destructive' }); return }
    if (templates.some(t => t.name.toLowerCase() === name.toLowerCase())) { toast({ title: 'Bereits vorhanden', description: 'Bitte anderen Namen wählen.', variant: 'destructive' }); return }
    if (!providerInstance) { toast({ title: 'Kein Provider' , variant: 'destructive' }); return }
    try {
      const folderId = await ensureTemplatesFolder()
      const values = getDefaultTemplateValues(name)
      const content = (values.yamlFrontmatter ? values.yamlFrontmatter + '\n\n' : '') + values.markdownBody + '\n\n--- systemprompt\n' + values.systemPrompt
      const file = new File([new Blob([content], { type: 'text/markdown' })], `${name}.md`, { type: 'text/markdown' })
      await providerInstance.uploadFile(folderId, file)
      await loadTemplates()
      setSelectedTemplateName(name)
      form.reset(values)
      toast({ title: 'Template angelegt', description: `"${name}" wurde erstellt.` })
    } catch (e) {
      toast({ title: 'Fehler beim Anlegen', description: e instanceof Error ? e.message : 'Unbekannter Fehler', variant: 'destructive' })
    }
  }

  function generatePreview(): string {
    const values = form.getValues()
    return generateTemplateContent(values)
  }

  async function testTemplate() {
    if (!activeLibrary) return

    setIsTesting(true)
    setTestResult(null)

    const values = form.getValues()
    const templateContent = generateTemplateContent(values)
    const sections: string[] = []
    if (selectedContextMarkdown.trim()) sections.push(selectedContextMarkdown.trim())
    if (freeText.trim()) sections.push(`---\nDatei: Freitext\n---\n\n${freeText.trim()}\n\n---\nEnde Datei: Freitext\n---`)
    const testText = sections.join("\n\n")

    const pickMarkdown = (result: unknown): string => {
      if (typeof result === 'string') return result
      if (result && typeof result === 'object') {
        const obj = result as Record<string, unknown>
        const directCandidates = ['text','markdown','content','output'] as const
        for (const k of directCandidates) {
          const v = obj[k]
          if (typeof v === 'string') return v
        }
        // verschachtelte Felder prüfen
        const nested = obj['data']
        if (nested && typeof nested === 'object') {
          const nobj = nested as Record<string, unknown>
          for (const k of directCandidates) {
            const v = nobj[k]
            if (typeof v === 'string') return v
          }
        }
      }
      return JSON.stringify(result, null, 2)
    }

    try {
      const response = await fetch('/api/secretary/process-text', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/x-www-form-urlencoded',
          'X-Library-Id': activeLibrary.id,
        },
        body: new URLSearchParams({
          text: testText,
          template_content: templateContent,
          source_language: 'de',
          target_language: 'de',
          use_cache: 'false',
        }),
      })

      if (!response.ok) {
        const errorData = await response.json()
        throw new Error(errorData.error || `HTTP ${response.status}: ${response.statusText}`)
      }

      const result = await response.json()
      const formattedResult = pickMarkdown(result)
      console.log('Prompt-Test Ergebnis:', formattedResult)
      
      setTestResult(formattedResult)
      setRightTab('testen')

      toast({
        title: "Prompt-Test erfolgreich",
        description: "Der Prompt wurde erfolgreich mit dem gewählten Kontext verarbeitet.",
      })

      console.log('Prompt-Test Ergebnis (roh):', result)
    } catch (error) {
      console.error('Fehler beim Prompt-Test:', error)
      const errorMessage = error instanceof Error ? error.message : "Unbekannter Fehler"
      setTestResult(`Fehler: ${errorMessage}`)
      setRightTab('testen')
      toast({
        title: "Prompt-Test fehlgeschlagen",
        description: errorMessage,
        variant: "destructive",
      })
    } finally {
      setIsTesting(false)
    }
  }

  async function ensurePromptTestsFolder(): Promise<string> {
    if (!providerInstance) throw new Error('Kein Provider verfügbar')
    const roots = await listItems('root')
    const found = roots.find(it => it.type === 'folder' && it.metadata.name === 'prompt-tests')
    if (found) return found.id
    const created = await providerInstance.createFolder('root', 'prompt-tests')
    return created.id
  }

  async function saveTestResult() {
    try {
      if (!providerInstance || !activeLibrary || !testResult) return
      const folderId = await ensurePromptTestsFolder()
      const name = `${selectedTemplateName || 'prompt'}-test-${new Date().toISOString().replace(/[:.]/g,'-')}.md`
      const blob = new Blob([testResult], { type: 'text/markdown' })
      const file = new File([blob], name, { type: 'text/markdown' })
      const item = await providerInstance.uploadFile(folderId, file)
      setResultSavedItemId(item.id)
      toast({ title: 'Ergebnis gespeichert', description: name })
    } catch (e) {
      toast({ title: 'Speichern fehlgeschlagen', description: e instanceof Error ? e.message : 'Unbekannter Fehler', variant: 'destructive' })
    }
  }

  async function runMagicDesign() {
    if (!selectedTemplateName || !providerInstance || !activeLibrary) {
      toast({ title: 'Kein Prompt ausgewählt', description: 'Bitte wählen Sie zuerst einen Prompt.', variant: 'destructive' })
      return
    }
    const scopeParts: string[] = []
    if (magicFrontmatter.trim()) scopeParts.push('frontmatter')
    if (magicBody.trim()) scopeParts.push('body')
    if (magicSystem.trim()) scopeParts.push('systemprompt')
    const allowedScope = scopeParts.length === 0 ? 'all' : (scopeParts.length === 1 ? scopeParts[0] : 'all')

    try {
      setMagicRunning(true)
      // 1) Magic-Template laden (magicpromptdesign.md)
      const folderId = await ensureTemplatesFolder()
      const items = await listItems(folderId)
      const magicItem = items.find(it => it.type === 'file' && (it.metadata.name.toLowerCase() === 'magicpromptdesign.md'))
      let magicTemplateContent: string
      if (!magicItem) {
        // Fallback: aus /public/templates laden
        try {
          const res = await fetch('/templates/magicpromptdesign.md', { cache: 'no-store' })
          if (!res.ok) throw new Error(`HTTP ${res.status}`)
          magicTemplateContent = await res.text()
          console.log('[Magic] Fallback magicpromptdesign.md aus /public/templates verwendet')
        } catch (e) {
          toast({ title: 'Magic-Template fehlt', description: 'magicpromptdesign.md weder in /templates noch in /public/templates gefunden.', variant: 'destructive' })
          return
        }
      } else {
        const { blob } = await providerInstance.getBinary(magicItem.id)
        magicTemplateContent = await blob.text()
      }

      // 2) Inputtext zusammenstellen
      const currentTemplate = generateTemplateContent(form.getValues())
      const inputText = [
        'INPUT_TEMPLATE:',
        currentTemplate,
        '',
        'CHANGES:',
        'Aufgabe:',
        magicBody || '(keine)',
        '',
        'Metadaten:',
        magicFrontmatter || '(keine)',
        '',
        'Rollenanweisung:',
        magicSystem || '(keine)',
        '',
        'CONFIG:',
        `allowed_scope: ${allowedScope}`,
        'diff_mode: diff',
        'preserve_comments: ja'
      ].join('\n')

      // 3) Secretary-Service aufrufen
      const response = await fetch('/api/secretary/process-text', {
        method: 'POST',
        headers: { 'Content-Type': 'application/x-www-form-urlencoded', 'X-Library-Id': activeLibrary.id },
        body: new URLSearchParams({
          text: inputText,
          template_content: magicTemplateContent,
          source_language: 'de',
          target_language: 'de'
        })
      })
      if (!response.ok) {
        const err = await response.json().catch(() => ({}))
        throw new Error(err?.error || `HTTP ${response.status}`)
      }
      const data = await response.json()
      // data kann string (JSON) oder object sein
      let corrected: string | undefined
      let diff: string = ''
      try {
        const obj = typeof data === 'string' ? JSON.parse(data) : (typeof data === 'object' ? data : {})
        corrected = typeof obj?.corrected_template === 'string' ? obj.corrected_template : undefined
        diff = typeof obj?.diff_preview === 'string' ? obj.diff_preview : ''
      } catch (e) {
        // Fallback: Wenn data.text existiert
        const maybe = (data && typeof data.text === 'string') ? JSON.parse(data.text) : null
        corrected = maybe?.corrected_template
        diff = maybe?.diff_preview || ''
      }
      if (!corrected) throw new Error('Antwort ohne corrected_template')

      // 4) Template parsen und Formular übernehmen
      const parsed = parseTemplateContent(corrected, selectedTemplateName)
      form.setValue('yamlFrontmatter', parsed.yamlFrontmatter, { shouldDirty: true })
      form.setValue('markdownBody', parsed.markdownBody, { shouldDirty: true })
      form.setValue('systemPrompt', parsed.systemPrompt, { shouldDirty: true })
      setMagicLastDiff(diff || '')
      toast({ title: 'Magic Design angewendet', description: 'Änderungen übernommen (nicht gespeichert).' })

      // 5) Korrigiertes Template im Ordner prompt-tests ablegen (Debug/Verfolgung)
      try {
        const testsFolderId = await ensurePromptTestsFolder()
        const ts = new Date().toISOString().replace(/[:.]/g, '-')
        const baseName = `${selectedTemplateName}-magic-${ts}.md`
        const blobCorrected = new Blob([corrected], { type: 'text/markdown' })
        const fileCorrected = new File([blobCorrected], baseName, { type: 'text/markdown' })
        const savedItem = await providerInstance.uploadFile(testsFolderId, fileCorrected)
        setMagicSavedItemId(savedItem.id)
        toast({ title: 'Magic-Ergebnis gespeichert', description: baseName })

        if (diff && diff.trim().length > 0) {
          const diffName = `${selectedTemplateName}-magic-diff-${ts}.md`
          const blobDiff = new Blob([diff], { type: 'text/markdown' })
          const fileDiff = new File([blobDiff], diffName, { type: 'text/markdown' })
          await providerInstance.uploadFile(testsFolderId, fileDiff)
          console.log('[Magic] Diff gespeichert', diffName)
        }
      } catch (saveErr) {
        console.warn('Magic-Ergebnis konnte nicht gespeichert werden:', saveErr)
        const msg = saveErr instanceof Error ? saveErr.message : 'Unbekannter Fehler'
        toast({ title: 'Magic-Ergebnis NICHT gespeichert', description: msg, variant: 'destructive' })
      }
    } catch (e) {
      toast({ title: 'Magic fehlgeschlagen', description: e instanceof Error ? e.message : 'Unbekannter Fehler', variant: 'destructive' })
    } finally {
      setMagicRunning(false)
    }
  }

  // Render-Logik für verschiedene Status
  if (libraryStatus === "waitingForAuth") {
    return (
      <div className="flex flex-col items-center justify-center h-full text-muted-foreground">
        <span>Diese Bibliothek benötigt eine Authentifizierung.</span>
        <span className="text-sm mt-2">Bitte konfigurieren Sie die Bibliothek in den Einstellungen.</span>
      </div>
    )
  }
  
  if (libraryStatus !== "ready") {
    return (
      <div className="flex flex-col items-center justify-center h-full text-muted-foreground">
        <span>Lade Storage...</span>
      </div>
    )
  }

  if (!activeLibrary) {
    return (
      <div className="text-center text-muted-foreground">
        Bitte wählen Sie eine Bibliothek aus.
      </div>
    )
  }

  if (error) {
    return (
      <div className="text-center text-destructive">
        <p>Fehler beim Laden der Prompts:</p>
        <p className="text-sm">{error}</p>
        <Button 
          variant="outline" 
          className="mt-4"
          onClick={loadTemplates}
        >
          Erneut versuchen
        </Button>
      </div>
    )
  }

  return (
    <div className="space-y-6">

      {/* Kompakte Toolbar oben */}
      <div className="flex items-center gap-2">
        <Select value={selectedTemplateName || ''} onValueChange={(v) => { setSelectedTemplateName(v); form.setValue('name', v, { shouldDirty: false }) }} disabled={isLoading}>
          <SelectTrigger className="w-64">
            <SelectValue placeholder="Prompt auswählen..." />
          </SelectTrigger>
          <SelectContent>
            {templates.map((t) => (
              <SelectItem key={t.name} value={t.name}>{t.name}</SelectItem>
            ))}
          </SelectContent>
        </Select>
        <TooltipProvider>
          <Tooltip>
            <TooltipTrigger asChild>
              <Button variant="ghost" size="sm" className="h-8 w-8 p-0"><Info className="h-4 w-4" /></Button>
            </TooltipTrigger>
            <TooltipContent>
              <div className="flex items-center gap-2"><FolderOpen className="h-4 w-4" /><span>Ort: /templates in „{activeLibrary.label}“</span></div>
            </TooltipContent>
          </Tooltip>
        </TooltipProvider>
        <Button type="button" variant="outline" size="sm" onClick={createNewTemplate} disabled={isLoading}>Neu</Button>
        <Button type="button" variant="outline" size="sm" onClick={renameCurrentTemplate} disabled={!selectedTemplateName}>Umbenennen</Button>
        {selectedTemplateName && (
          <Button type="button" variant="destructive" size="sm" onClick={() => deleteTemplate(selectedTemplateName!)}>Löschen</Button>
        )}
      </div>

      <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
        <Card>
          <CardHeader>
            <CardTitle>Prompt Design</CardTitle>
            <CardDescription>
              Drei Bereiche: Aufgabe (was), Rollenanweisung (wie), Metadaten (Begleitinfos).
            </CardDescription>
          </CardHeader>
          <CardContent>
            <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-6">
              {/* Template-Name Feld entfernt (oben verwaltet) */}

              {!selectedTemplateName ? (
                <div className="rounded-md border border-dashed p-6 text-sm text-muted-foreground">
                  Bitte oben einen Prompt auswählen oder Neu anlegen.
                </div>
              ) : previewMode ? (
                <div className="space-y-4">
                  <div className="flex items-center justify-between">
                    <h4 className="text-sm font-medium">Prompt-Vorschau</h4>
                    <Button
                      type="button"
                      variant="outline"
                      size="sm"
                      onClick={() => setPreviewMode(false)}
                    >
                      Bearbeiten
                    </Button>
                  </div>
                  <div className="border rounded-md p-4 bg-muted/50">
                    <pre className="text-sm whitespace-pre-wrap font-mono">
                      {generatePreview()}
                    </pre>
                  </div>
                </div>
              ) : (
                <>
                  <StructuredTemplateEditor
                    markdownBody={form.watch('markdownBody')}
                    yamlFrontmatter={form.watch('yamlFrontmatter')}
                    systemPrompt={form.watch('systemPrompt')}
                    magicMode={magicMode}
                    magicValues={{ body: magicBody, frontmatter: magicFrontmatter, system: magicSystem }}
                    onMagicChange={(next) => {
                      if (next.body !== undefined) setMagicBody(next.body)
                      if (next.frontmatter !== undefined) setMagicFrontmatter(next.frontmatter)
                      if (next.system !== undefined) setMagicSystem(next.system)
                    }}
                    onChange={({ markdownBody, yamlFrontmatter, systemPrompt }) => {
                      form.setValue('markdownBody', markdownBody, { shouldDirty: true })
                      form.setValue('yamlFrontmatter', yamlFrontmatter, { shouldDirty: true })
                      form.setValue('systemPrompt', systemPrompt, { shouldDirty: true })
                    }}
                  />
                </>
              )}

              <div className="flex justify-end gap-2">
                {selectedTemplateName && (
                  <Button type="button" variant={magicMode ? 'secondary' : 'outline'} onClick={() => setMagicMode(v => !v)}>
                    {magicMode ? 'Magic Design ausblenden' : 'Magic Design'}
                  </Button>
                )}
                {magicMode && (
                  <>
                    <Button type="button" variant="secondary" onClick={() => { setMagicBody(''); setMagicFrontmatter(''); setMagicSystem(''); setMagicLastDiff('') }} disabled={magicRunning}>Magic zurücksetzen</Button>
                    <Button type="button" onClick={runMagicDesign} disabled={magicRunning || (!magicBody && !magicFrontmatter && !magicSystem)}>
                      {magicRunning ? (<><Loader2 className="h-4 w-4 mr-2 animate-spin" /> Magic läuft…</>) : 'Magic absenden'}
                    </Button>
                  </>
                )}
                <Button
                  type="button"
                  variant="outline"
                  onClick={() => setPreviewMode(!previewMode)}
                  disabled={!selectedTemplateName}
                >
                  <Eye className="h-4 w-4 mr-2" />
                  {previewMode ? "Bearbeiten" : "Vorschau"}
                </Button>
                <Button
                  type="submit"
                  disabled={!selectedTemplateName || isSaving || !form.formState.isDirty}
                >
                  {isSaving ? (
                    <>
                      <Loader2 className="h-4 w-4 mr-2 animate-spin" />
                      Wird gespeichert...
                    </>
                  ) : (
                    <>
                      <Save className="h-4 w-4 mr-2" />
                      Speichern
                    </>
                  )}
                </Button>
              </div>
            </form>
          </CardContent>
        </Card>

        <Card>
          <CardHeader>
            <CardTitle>Prompt testen</CardTitle>
            <CardDescription>
              Test mit Beispieltext. Nutzt Rollenanweisung, Aufgabe und Metadaten des Prompts.
            </CardDescription>
          </CardHeader>
          <CardContent>
            {!selectedTemplateName ? (
              <div className="rounded-md border border-dashed p-6 text-sm text-muted-foreground">
                Bitte oben einen Prompt auswählen. Die Vorschau und Test‑Funktionen werden erst danach aktiviert.
              </div>
            ) : (
              <Tabs value={rightTab} onValueChange={(v) => setRightTab(v as typeof rightTab)}>
                <TabsList className="grid grid-cols-3 w-full">
                  <TabsTrigger value="kontext">Daten‑Kontext</TabsTrigger>
                  <TabsTrigger value="preview">Prompt‑Vorschau</TabsTrigger>
                  <TabsTrigger value="testen">Testen</TabsTrigger>
                </TabsList>

                <TabsContent value="kontext" className="space-y-4 mt-4">
                  <div className="space-y-2">
                    <Label>Kontext-Texte</Label>
                    <div className="border rounded p-2 text-sm">
                      {Array.isArray(contextDocs) && contextDocs.length > 0 ? (
                        contextDocs.map(d => {
                          const checked = selectedContextIds.includes(d.id)
                          return (
                            <label key={d.id} className="flex items-center gap-2 py-1">
                              <Checkbox
                                checked={checked}
                                onCheckedChange={(v) => {
                                  const isOn = v === true
                                  setSelectedContextIds(prev => isOn ? [...prev, d.id] : prev.filter(x => x !== d.id))
                                }}
                              />
                              <span className="truncate">{d.name}</span>
                            </label>
                          )
                        })
                      ) : (
                        <div className="text-muted-foreground text-sm">Keine Kontext-Texte verfügbar</div>
                      )}
                    </div>
                  </div>

                  <div className="space-y-2">
                    <Label>Gewählter Kontext (Lesemodus)</Label>
                    <div className="border rounded-md">
                      <MarkdownPreview content={selectedContextMarkdown} />
                    </div>
                  </div>

                  <div className="space-y-2">
                    <Label>Freitext (optional)</Label>
                    <Textarea
                      value={freeText}
                      onChange={(e) => setFreeText(e.target.value)}
                      placeholder="Hier Text einkleben, um schnell zu testen"
                      className="min-h-[120px] font-mono text-sm"
                    />
                  </div>
                </TabsContent>

                <TabsContent value="preview" className="space-y-4 mt-4">
                  <div className="space-y-2">
                    <Label>Generierter Prompt (Markdown)</Label>
                    <div className="border rounded-md">
                      <MarkdownPreview content={generatePreview()} />
                    </div>
                  </div>
                  <div className="flex gap-2 justify-end">
                    <Button 
                      variant="outline" 
                      size="sm"
                      onClick={testTemplate}
                      disabled={!selectedTemplateName || isTesting}
                    >
                      {isTesting ? (
                        <>
                          <Loader2 className="h-4 w-4 mr-2 animate-spin" />
                          Teste...
                        </>
                      ) : (
                        <>
                          <Play className="h-4 w-4 mr-2" />
                          Prompt testen
                        </>
                      )}
                    </Button>
                  </div>
                </TabsContent>

                <TabsContent value="testen" className="space-y-4 mt-4">
                  <div className="flex gap-2 justify-end">
                    <Button 
                      variant="outline" 
                      size="sm"
                      onClick={testTemplate}
                      disabled={!selectedTemplateName || isTesting}
                    >
                      {isTesting ? (
                        <>
                          <Loader2 className="h-4 w-4 mr-2 animate-spin" />
                          Teste...
                        </>
                      ) : (
                        <>
                          <Play className="h-4 w-4 mr-2" />
                          Prompt testen
                        </>
                      )}
                    </Button>
                  </div>
                  {activeLibrary && providerInstance && (testResult || resultSavedItemId) ? (
                    <JobReportTab
                      libraryId={activeLibrary.id}
                      fileId={resultSavedItemId || 'preview'}
                      provider={providerInstance}
                      sourceMode="frontmatter"
                      viewMode="metaOnly"
                      mdFileId={resultSavedItemId || undefined}
                      rawContent={testResult || undefined}
                    />
                  ) : (
                    <div className="text-sm text-muted-foreground">Kein Ergebnis vorhanden.</div>
                  )}
                  <div className="flex gap-2">
                    <Button type="button" onClick={saveTestResult} disabled={!testResult}>Speichern</Button>
                  </div>
                </TabsContent>
              </Tabs>
            )}
          </CardContent>
        </Card>
      </div>
    </div>
  )
} 
```

- Es wird jetzt ein roter Toast angezeigt, falls das Speichern unter `prompt-tests` fehlschlägt. So sehen wir sofort, ob der Upload scheitert und mit welcher Fehlermeldung.
- Bitte den Magic‑Flow noch einmal ausführen. Wenn kein Toast kommt und trotzdem keine Datei erscheint, sag mir kurz:
  - Bibliothek aktiv? Schreibrechte vorhanden?
  - Existiert der Ordner `prompt-tests` im Root? (wird automatisch erstellt, falls nicht)
  - Wurde ein Toast „Magic‑Ergebnis gespeichert: <Name>“ angezeigt?

Kurz: Ohne Fehler‑Toast sollte eine Datei `…-magic-<timestamp>.md` im Root‑Ordner `prompt-tests` liegen.

---

**User**

TypeError: state.templates.find is not a function
    at Object.eval [as read] (webpack-internal:///(app-pages-browser)/./src/atoms/template-atom.ts:43:28)
    at atomRead (webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/jotai@2.12.5_@types+react@18.3.23_react@18.2.0/node_modules/jotai/vanilla/internals.js:206:24)
    at readAtomState (webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/jotai@2.12.5_@types+react@18.3.23_react@18.2.0/node_modules/jotai/vanilla/internals.js:415:28)
    at recomputeInvalidatedAtoms (webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/jotai@2.12.5_@types+react@18.3.23_react@18.2.0/node_modules/jotai/vanilla/internals.js:322:9)
    at Object.set (webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/jotai@2.12.5_@types+react@18.3.23_react@18.2.0/node_modules/jotai/vanilla/internals.js:614:9)
    at useSetAtom.useCallback[setAtom] (webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/jotai@2.12.5_@types+react@18.3.23_react@18.2.0/node_modules/jotai/react.js:186:30)
    at onSubmit (webpack-internal:///(app-pages-browser)/./src/components/templates/template-management.tsx:474:17)
    at async eval (webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/react-hook-form@7.57.0_react@18.2.0/node_modules/react-hook-form/dist/index.esm.mjs:2053:17)
    at TemplatesPage (rsc://React/Server/webpack-internal:///(rsc)/./src/app/templates/page.tsx?6:18:94)

---

**Cursor**

Ich untersuche die Definition von `templatesAtom`, um die Ursache des `find is not a function` Fehlers zu identifizieren und den Setter korrekt anzuwenden. Danach passe ich die Aktualisierung in `onSubmit` an.

Ich habe den Fehler lokalisiert: Wir haben `setTemplates` mit einer Funktions-Signatur aufgerufen, aber der Atom-Setter erwartet direkt ein Array. Ich ersetze den fehlerhaften Aufruf durch eine korrekte Array-Zuweisung. Danach prüfe ich Linterfehler.

```typescriptreact
"use client"

import { useState, useEffect, useCallback } from "react"
import { useForm } from "react-hook-form"
import { zodResolver } from "@hookform/resolvers/zod"
import * as z from "zod"
import { Button } from "@/components/ui/button"
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card"
import { Label } from "@/components/ui/label"
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select"
import { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from "@/components/ui/tooltip"
import { StructuredTemplateEditor } from "@/components/templates/structured-template-editor"
import { useToast } from "@/hooks/use-toast"
import { Loader2, Save, Eye, Play, FolderOpen, Info } from "lucide-react"
import { useAtom, useAtomValue } from "jotai"
import { activeLibraryAtom, libraryStatusAtom } from "@/atoms/library-atom"
import { 
  templatesAtom, 
  selectedTemplateNameAtom, 
  selectedTemplateAtom,
  templatesFolderIdAtom,
  templateLoadingAtom,
  templateErrorAtom,
  type Template
} from "@/atoms/template-atom"
import { useStorage } from "@/contexts/storage-context"
import { templateContextDocsAtom } from '@/atoms/template-context-atom'
import { Checkbox } from "@/components/ui/checkbox"
import { MarkdownPreview } from "@/components/library/markdown-preview"
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs"
import { JobReportTab } from "@/components/library/job-report-tab"
import { Textarea } from "@/components/ui/textarea"
import { Separator } from "@/components/ui/separator"

// Schema für Template-Daten
const templateSchema = z.object({
  name: z.string().min(1, "Prompt-Name ist erforderlich"),
  yamlFrontmatter: z.string(),
  markdownBody: z.string(),
  systemPrompt: z.string(),
})

type TemplateFormValues = z.infer<typeof templateSchema>

export function TemplateManagement() {
  const [previewMode, setPreviewMode] = useState(false)
  const [isSaving, setIsSaving] = useState(false)
  const [isTesting, setIsTesting] = useState(false)
  const [testResult, setTestResult] = useState<string | null>(null)
  const [selectedContextIds, setSelectedContextIds] = useState<string[]>([])
  const [selectedContextMarkdown, setSelectedContextMarkdown] = useState<string>("")
  const [rightTab, setRightTab] = useState<'kontext'|'preview'|'testen'>('kontext')
  const [resultSavedItemId, setResultSavedItemId] = useState<string | null>(null)
  const [freeText, setFreeText] = useState<string>("")
  // Magic Design
  const [magicMode, setMagicMode] = useState<boolean>(false)
  const [magicBody, setMagicBody] = useState<string>("")
  const [magicFrontmatter, setMagicFrontmatter] = useState<string>("")
  const [magicSystem, setMagicSystem] = useState<string>("")
  const [magicRunning, setMagicRunning] = useState<boolean>(false)
  const [magicLastDiff, setMagicLastDiff] = useState<string>("")
  const [magicSavedItemId, setMagicSavedItemId] = useState<string | null>(null)
  const { toast } = useToast()

  // Atoms
  const [templates, setTemplates] = useAtom(templatesAtom)
  const [selectedTemplateName, setSelectedTemplateName] = useAtom(selectedTemplateNameAtom)
  const [selectedTemplate] = useAtom(selectedTemplateAtom)
  const [templatesFolderId, setTemplatesFolderId] = useAtom(templatesFolderIdAtom)
  const [isLoading, setIsLoading] = useAtom(templateLoadingAtom)
  const [error, setError] = useAtom(templateErrorAtom)

  // Library und Storage
  const activeLibrary = useAtomValue(activeLibraryAtom)
  const libraryStatus = useAtomValue(libraryStatusAtom)
  const { 
    provider: providerInstance, 
    listItems
  } = useStorage()
  const contextDocs = useAtomValue(templateContextDocsAtom)

  const form = useForm<TemplateFormValues>({
    resolver: zodResolver(templateSchema),
    defaultValues: {
      name: "",
      yamlFrontmatter: `---
title: {{title|Titel des Dokuments}}
tags: {{tags|Relevante Tags}}
date: {{date|Datum im Format yyyy-mm-dd}}
---`,
      markdownBody: `# {{title}}

## Zusammenfassung
{{summary|Kurze Zusammenfassung des Inhalts}}

## Details
{{details|Detaillierte Beschreibung}}`,
      systemPrompt: `You are a specialized assistant that processes and structures information clearly and concisely.

IMPORTANT: Your response must be a valid JSON object where each key corresponds to a template variable.`,
    },
  })

  // Helper zum Erzeugen von Default-Werten
  function getDefaultTemplateValues(name: string): TemplateFormValues {
    return {
      name,
      yamlFrontmatter: `---\n` +
        `title: {{title|Titel des Dokuments}}\n` +
        `tags: {{tags|Relevante Tags}}\n` +
        `date: {{date|Datum im Format yyyy-mm-dd}}\n` +
        `---`,
      markdownBody: `# {{title}}\n\n## Zusammenfassung\n{{summary|Kurze Zusammenfassung des Inhalts}}\n\n## Details\n{{details|Detaillierte Beschreibung}}`,
      systemPrompt: `You are a specialized assistant that processes and structures information clearly and concisely.\n\nIMPORTANT: Your response must be a valid JSON object where each key corresponds to a template variable.`,
    }
  }

  // Template-Daten laden wenn sich die Auswahl ändert
  useEffect(() => {
    if (selectedTemplate) {
      form.reset({
        name: selectedTemplate.name,
        yamlFrontmatter: selectedTemplate.yamlFrontmatter,
        markdownBody: selectedTemplate.markdownBody,
        systemPrompt: selectedTemplate.systemPrompt,
      })
    }
  }, [selectedTemplate, form])

  // Ordner-Erstellung/Suche memoisiert, damit als Dep verwendbar
  const ensureTemplatesFolder = useCallback(async (): Promise<string> => {
    if (!providerInstance || !activeLibrary) {
      throw new Error("Keine aktive Bibliothek oder Provider verfügbar");
    }

    try {
      console.log('[TemplateManagement] Suche nach Templates-Ordner...');
      const rootItems = await listItems('root');
      const templatesFolder = rootItems.find(item => 
        item.type === 'folder' && item.metadata.name === 'templates'
      );
      if (templatesFolder) {
        console.log('[TemplateManagement] Templates-Ordner gefunden:', templatesFolder.id);
        return templatesFolder.id;
      }
      console.log('[TemplateManagement] Templates-Ordner nicht gefunden, erstelle neuen...');
      const newFolder = await providerInstance.createFolder('root', 'templates');
      console.log('[TemplateManagement] Neuer Templates-Ordner erstellt:', newFolder.id);
      return newFolder.id;
    } catch (error) {
      console.error('Fehler beim Erstellen des Templates-Ordners:', {
        error: error instanceof Error ? {
          message: error.message,
          name: error.name,
          stack: error.stack?.split('\n').slice(0, 3)
        } : error,
        libraryId: activeLibrary?.id,
        libraryPath: activeLibrary?.path,
        providerName: providerInstance?.name
      });
      let errorMessage = 'Fehler beim Erstellen des Templates-Ordners';
      if (error instanceof Error) {
        if (error.message.includes('Nicht authentifiziert')) {
          errorMessage = 'Bitte authentifizieren Sie sich bei Ihrem Cloud-Speicher, um den Templates-Ordner zu erstellen.';
        } else if (error.message.includes('Keine Berechtigung')) {
          errorMessage = 'Keine Berechtigung zum Erstellen von Ordnern in der Bibliothek.';
        } else if (error.message.includes('Bibliothek nicht gefunden')) {
          errorMessage = 'Die ausgewählte Bibliothek wurde nicht gefunden.';
        } else {
          errorMessage = `Fehler beim Erstellen des Templates-Ordners: ${error.message}`;
        }
      }
      throw new Error(errorMessage);
    }
  }, [providerInstance, activeLibrary, listItems]);

  // Templates laden mit der gleichen Logik wie Library-Komponente
  const loadTemplates = useCallback(async () => {
    if (!providerInstance || libraryStatus !== 'ready' || !activeLibrary) {
      console.log('[TemplateManagement] loadTemplates übersprungen:', {
        hasProvider: !!providerInstance,
        libraryStatus,
        hasActiveLibrary: !!activeLibrary
      });
      return;
    }

    try {
      setIsLoading(true);
      setError(null);

      console.log('[TemplateManagement] Starte Prompt-Loading:', {
        libraryId: activeLibrary.id,
        libraryPath: activeLibrary.path,
        providerName: providerInstance.name
      });

      // 1. Templates-Ordner finden oder erstellen
      const folderId = await ensureTemplatesFolder();
      setTemplatesFolderId(folderId);

      console.log('[TemplateManagement] Templates-Ordner gefunden/erstellt:', folderId);

      // 2. Alle Template-Dateien im Ordner auflisten
      const items = await listItems(folderId);
      const templateFiles = items.filter(item => 
        item.type === 'file' && 
        item.metadata.name.endsWith('.md')
      );

      console.log('[TemplateManagement] Prompt-Dateien gefunden:', templateFiles.length);

      // 3. Template-Inhalte laden
      const templatePromises = templateFiles.map(async (file) => {
        try {
          const { blob } = await providerInstance.getBinary(file.id);
          const content = await blob.text();
          const template = parseTemplateContent(content, file.metadata.name.replace('.md', ''));
          
          return {
            ...template,
            fileId: file.id,
            lastModified: typeof file.metadata.modifiedAt === 'string' 
              ? file.metadata.modifiedAt 
              : file.metadata.modifiedAt instanceof Date 
                ? file.metadata.modifiedAt.toISOString()
                : new Date().toISOString()
          } as Template;
        } catch (error) {
          console.error(`Fehler beim Parsen von ${file.metadata.name}:`, error);
          return null;
        }
      });

      const loadedTemplates = await Promise.all(templatePromises);
      const validTemplates = loadedTemplates.filter((t): t is Template => t !== null);
      
      setTemplates(validTemplates);
      
      console.log('[TemplateManagement] Prompts erfolgreich geladen:', validTemplates.length);
      
      if (validTemplates.length === 0) {
        toast({
          title: "Keine Prompts gefunden",
          description: "Erstellen Sie Ihren ersten Prompt im Verzeichnis '/templates'.",
        });
      }
    } catch (error) {
      console.error('Fehler beim Laden der Prompts:', {
        error: error instanceof Error ? {
          message: error.message,
          name: error.name,
          stack: error.stack?.split('\n').slice(0, 3)
        } : error,
        libraryId: activeLibrary?.id,
        libraryPath: activeLibrary?.path,
        providerName: providerInstance?.name
      });

      let errorMessage = 'Unbekannter Fehler beim Laden der Prompts';
      
      if (error instanceof Error) {
        errorMessage = error.message;
        
        // Spezifische Fehlermeldungen für häufige Probleme
        if (error.message.includes('Nicht authentifiziert')) {
          errorMessage = 'Bitte authentifizieren Sie sich bei Ihrem Cloud-Speicher, um Prompts zu laden.';
        } else if (error.message.includes('Bibliothek nicht gefunden')) {
          errorMessage = 'Die ausgewählte Bibliothek wurde nicht gefunden. Bitte überprüfen Sie die Bibliothekskonfiguration.';
        } else if (error.message.includes('Server-Fehler')) {
          errorMessage = 'Server-Fehler beim Laden der Prompts. Bitte überprüfen Sie, ob der Bibliothekspfad existiert und zugänglich ist.';
        } else if (error.message.includes('Keine aktive Bibliothek')) {
          errorMessage = 'Keine aktive Bibliothek verfügbar. Bitte wählen Sie eine Bibliothek aus.';
        }
      }
      
      setError(errorMessage);
      toast({
        title: "Fehler beim Laden der Prompts",
        description: errorMessage,
        variant: "destructive",
      });
    } finally {
      setIsLoading(false);
    }
  }, [providerInstance, libraryStatus, activeLibrary, listItems, setTemplates, setTemplatesFolderId, setIsLoading, setError, toast, ensureTemplatesFolder]);

  // Effect für Template Loading (wie Library-Komponente)
  useEffect(() => {
    const isReady = providerInstance && libraryStatus === 'ready' && activeLibrary
    
    if (!isReady) {
      return
    }

    // Templates laden wenn noch nicht geladen
    if (!templatesFolderId) {
      loadTemplates()
    }
  }, [providerInstance, libraryStatus, activeLibrary, templatesFolderId, loadTemplates])

  // Reset wenn sich die Library ändert
  useEffect(() => {
    setSelectedTemplateName(null)
    setTemplatesFolderId(null)
    setTemplates([])
    setError(null)
  }, [libraryStatus, setSelectedTemplateName, setTemplatesFolderId, setTemplates, setError])

  useEffect(() => {
    async function loadSelectedContext() {
      if (!providerInstance || !Array.isArray(selectedContextIds) || selectedContextIds.length === 0) {
        setSelectedContextMarkdown("")
        return
      }
      try {
        const parts: string[] = []
        for (const id of selectedContextIds) {
          const { blob } = await providerInstance.getBinary(id)
          const text = await blob.text()
          const name = Array.isArray(contextDocs) ? (contextDocs.find(d => d.id === id)?.name || id) : id
          const section = `\n\n---\nDatei: ${name}\n---\n\n${text}\n\n---\nEnde Datei: ${name}\n---\n`
          parts.push(section)
        }
        setSelectedContextMarkdown(parts.join("\n\n"))
      } catch (e) {
        console.error('Fehler beim Laden des Kontextes', e)
        setSelectedContextMarkdown("")
      }
    }
    void loadSelectedContext()
  }, [providerInstance, selectedContextIds, contextDocs])

  function parseTemplateContent(content: string, fileName: string): Template {
    // Template in drei Bereiche aufteilen
    const parts = content.split('--- systemprompt')
    
    let yamlFrontmatter = ""
    let markdownBody = ""
    let systemPrompt = ""
    
    if (parts.length >= 2) {
      const mainContent = parts[0].trim()
      systemPrompt = parts[1].trim()
      
      // YAML Frontmatter extrahieren
      const yamlMatch = mainContent.match(/^---\r?\n([\s\S]*?)\r?\n---\r?\n?([\s\S]*)$/)
      if (yamlMatch) {
        yamlFrontmatter = `---\n${yamlMatch[1]}\n---`
        markdownBody = yamlMatch[2].trim()
      } else {
        // Kein YAML Frontmatter gefunden
        markdownBody = mainContent
      }
    } else {
      // Kein Systemprompt gefunden
      const yamlMatch = content.match(/^---\r?\n([\s\S]*?)\r?\n---\r?\n?([\s\S]*)$/)
      if (yamlMatch) {
        yamlFrontmatter = `---\n${yamlMatch[1]}\n---`
        markdownBody = yamlMatch[2].trim()
      } else {
        markdownBody = content
      }
    }

    return {
      name: fileName,
      yamlFrontmatter,
      markdownBody,
      systemPrompt,
    }
  }

  function generateTemplateContent(values: TemplateFormValues): string {
    let content = ""
    
    // YAML Frontmatter hinzufügen
    if (values.yamlFrontmatter.trim()) {
      content += values.yamlFrontmatter + "\n\n"
    }
    
    // Markdown Body hinzufügen
    content += values.markdownBody
    
    // System Prompt hinzufügen
    if (values.systemPrompt.trim()) {
      content += "\n\n--- systemprompt\n" + values.systemPrompt
    }
    
    return content
  }

  async function onSubmit(data: TemplateFormValues) {
    if (!activeLibrary || !templatesFolderId || !providerInstance) {
      toast({
        title: "Fehler",
        description: "Keine aktive Bibliothek oder Templates-Ordner nicht gefunden.",
        variant: "destructive",
      })
      return
    }

    setIsSaving(true)
    try {
      const templateContent = generateTemplateContent(data)
      const fileName = `${data.name}.md`
      
      console.group('[TemplateManagement] Speichern')
      console.log('Library', { id: activeLibrary.id, label: activeLibrary.label, path: activeLibrary.path })
      console.log('TemplatesFolderId', templatesFolderId)
      console.log('Datei', { fileName, contentLen: templateContent.length })
      
      // Falls Datei mit gleichem Namen existiert: erst löschen, dann neu schreiben
      const existing = templates.find(t => t.name.toLowerCase() === data.name.toLowerCase())
      if (existing?.fileId) {
        console.log('Bestehende Datei gefunden, lösche', { fileId: existing.fileId })
        try {
          await providerInstance.deleteItem(existing.fileId)
          console.log('Löschen OK')
        } catch (e) {
          console.error('Löschen fehlgeschlagen', e)
          toast({ title: 'Löschen fehlgeschlagen', description: e instanceof Error ? e.message : String(e), variant: 'destructive' })
        }
      } else {
        console.log('Keine bestehende Datei mit gleichem Namen gefunden')
      }
      
      // Datei als Blob erstellen und hochladen (Neu-Anlage / Ersetzen)
      const blob = new Blob([templateContent], { type: 'text/markdown' })
      const file = new File([blob], fileName, { type: 'text/markdown' })
      const uploaded = await providerInstance.uploadFile(templatesFolderId, file)
      console.log('Upload Ergebnis', uploaded)
      
      // Direkt nach Upload erneut lesen (Bypass-Stale) und lokalen State aktualisieren
      try {
        const { blob: rbBlob } = await providerInstance.getBinary(uploaded.id)
        const rbText = await rbBlob.text()
        console.log('Read-Back Länge', rbText.length, 'Auszug', rbText.slice(0, 120))
        const parsed = parseTemplateContent(rbText, data.name)
        const updated: Template = {
          ...parsed,
          fileId: uploaded.id,
          lastModified: new Date().toISOString()
        }
        const nextTemplates = templates
          .filter((t) => t.name.toLowerCase() !== data.name.toLowerCase())
          .concat(updated)
        setTemplates(nextTemplates)
      } catch (e) {
        console.warn('Read-Back nach Upload fehlgeschlagen', e)
      }
      
      // Kurze Wartezeit, damit Remote-Provider (OneDrive) Index/Cache aktualisiert
      await new Promise(r => setTimeout(r, 500))
      
      // Templates neu laden (finaler Sync mit Remote)
      await loadTemplates()
      console.log('Templates neu geladen')
      
      // Auswahl auf das neue Template setzen
      setSelectedTemplateName(data.name)
      console.log('Auswahl gesetzt', data.name)
      
      toast({
        title: "Prompt gespeichert",
        description: `"${data.name}" wurde aktualisiert.`,
      })
      console.groupEnd()
    } catch (error) {
      console.error('Fehler beim Speichern des Templates:', error)
      toast({
        title: "Fehler beim Speichern",
        description: error instanceof Error ? error.message : "Unbekannter Fehler",
        variant: "destructive",
      })
    } finally {
      setIsSaving(false)
    }
  }

  async function renameCurrentTemplate() {
    const current = selectedTemplateName ? templates.find(t => t.name === selectedTemplateName) : null
    if (!current || !current.fileId || !providerInstance) return
    const newName = (window.prompt('Neuen Namen eingeben:', current.name) || '').trim()
    if (!newName || newName === current.name) return
    if (/[^a-zA-Z0-9._\- ]/.test(newName)) { toast({ title: 'Ungültiger Name', description: 'Nur Buchstaben, Zahlen, Leerzeichen, . _ - sind erlaubt.', variant: 'destructive' }); return }
    if (templates.some(t => t.name.toLowerCase() === newName.toLowerCase())) { toast({ title: 'Bereits vorhanden', description: 'Bitte anderen Namen wählen.', variant: 'destructive' }); return }
    try {
      await providerInstance.renameItem(current.fileId, `${newName}.md`)
      await loadTemplates()
      setSelectedTemplateName(newName)
      form.setValue('name', newName, { shouldDirty: false })
      toast({ title: 'Umbenannt', description: `${current.name} → ${newName}` })
    } catch (e) {
      toast({ title: 'Fehler beim Umbenennen', description: e instanceof Error ? e.message : 'Unbekannter Fehler', variant: 'destructive' })
    }
  }

  async function deleteTemplate(templateName: string) {
    if (!activeLibrary || !providerInstance) return

    try {
      const template = templates.find(t => t.name === templateName)
      if (!template?.fileId) {
        throw new Error("Template-Datei nicht gefunden")
      }

      // Datei löschen
      await providerInstance.deleteItem(template.fileId)

      // Templates neu laden
      await loadTemplates()
      
      if (selectedTemplateName === templateName) {
        setSelectedTemplateName(null)
        form.reset()
      }
      
      toast({
        title: "Template gelöscht",
        description: `Template "${templateName}" wurde erfolgreich gelöscht.`,
      })
    } catch (error) {
      console.error('Fehler beim Löschen des Templates:', error)
      toast({
        title: "Fehler beim Löschen",
        description: error instanceof Error ? error.message : "Unbekannter Fehler",
        variant: "destructive",
      })
    }
  }

  async function createNewTemplate() {
    const name = (window.prompt('Neuen Template‑Namen eingeben:') || '').trim()
    if (!name) return
    if (/[^a-zA-Z0-9._\- ]/.test(name)) { toast({ title: 'Ungültiger Name', description: 'Nur Buchstaben, Zahlen, Leerzeichen, . _ - sind erlaubt.', variant: 'destructive' }); return }
    if (templates.some(t => t.name.toLowerCase() === name.toLowerCase())) { toast({ title: 'Bereits vorhanden', description: 'Bitte anderen Namen wählen.', variant: 'destructive' }); return }
    if (!providerInstance) { toast({ title: 'Kein Provider' , variant: 'destructive' }); return }
    try {
      const folderId = await ensureTemplatesFolder()
      const values = getDefaultTemplateValues(name)
      const content = (values.yamlFrontmatter ? values.yamlFrontmatter + '\n\n' : '') + values.markdownBody + '\n\n--- systemprompt\n' + values.systemPrompt
      const file = new File([new Blob([content], { type: 'text/markdown' })], `${name}.md`, { type: 'text/markdown' })
      await providerInstance.uploadFile(folderId, file)
      await loadTemplates()
      setSelectedTemplateName(name)
      form.reset(values)
      toast({ title: 'Template angelegt', description: `"${name}" wurde erstellt.` })
    } catch (e) {
      toast({ title: 'Fehler beim Anlegen', description: e instanceof Error ? e.message : 'Unbekannter Fehler', variant: 'destructive' })
    }
  }

  function generatePreview(): string {
    const values = form.getValues()
    return generateTemplateContent(values)
  }

  async function testTemplate() {
    if (!activeLibrary) return

    setIsTesting(true)
    setTestResult(null)

    const values = form.getValues()
    const templateContent = generateTemplateContent(values)
    const sections: string[] = []
    if (selectedContextMarkdown.trim()) sections.push(selectedContextMarkdown.trim())
    if (freeText.trim()) sections.push(`---\nDatei: Freitext\n---\n\n${freeText.trim()}\n\n---\nEnde Datei: Freitext\n---`)
    const testText = sections.join("\n\n")

    const pickMarkdown = (result: unknown): string => {
      if (typeof result === 'string') return result
      if (result && typeof result === 'object') {
        const obj = result as Record<string, unknown>
        const directCandidates = ['text','markdown','content','output'] as const
        for (const k of directCandidates) {
          const v = obj[k]
          if (typeof v === 'string') return v
        }
        // verschachtelte Felder prüfen
        const nested = obj['data']
        if (nested && typeof nested === 'object') {
          const nobj = nested as Record<string, unknown>
          for (const k of directCandidates) {
            const v = nobj[k]
            if (typeof v === 'string') return v
          }
        }
      }
      return JSON.stringify(result, null, 2)
    }

    try {
      const response = await fetch('/api/secretary/process-text', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/x-www-form-urlencoded',
          'X-Library-Id': activeLibrary.id,
        },
        body: new URLSearchParams({
          text: testText,
          template_content: templateContent,
          source_language: 'de',
          target_language: 'de',
          use_cache: 'false',
        }),
      })

      if (!response.ok) {
        const errorData = await response.json()
        throw new Error(errorData.error || `HTTP ${response.status}: ${response.statusText}`)
      }

      const result = await response.json()
      const formattedResult = pickMarkdown(result)
      console.log('Prompt-Test Ergebnis:', formattedResult)
      
      setTestResult(formattedResult)
      setRightTab('testen')

      toast({
        title: "Prompt-Test erfolgreich",
        description: "Der Prompt wurde erfolgreich mit dem gewählten Kontext verarbeitet.",
      })

      console.log('Prompt-Test Ergebnis (roh):', result)
    } catch (error) {
      console.error('Fehler beim Prompt-Test:', error)
      const errorMessage = error instanceof Error ? error.message : "Unbekannter Fehler"
      setTestResult(`Fehler: ${errorMessage}`)
      setRightTab('testen')
      toast({
        title: "Prompt-Test fehlgeschlagen",
        description: errorMessage,
        variant: "destructive",
      })
    } finally {
      setIsTesting(false)
    }
  }

  async function ensurePromptTestsFolder(): Promise<string> {
    if (!providerInstance) throw new Error('Kein Provider verfügbar')
    const roots = await listItems('root')
    const found = roots.find(it => it.type === 'folder' && it.metadata.name === 'prompt-tests')
    if (found) return found.id
    const created = await providerInstance.createFolder('root', 'prompt-tests')
    return created.id
  }

  async function saveTestResult() {
    try {
      if (!providerInstance || !activeLibrary || !testResult) return
      const folderId = await ensurePromptTestsFolder()
      const name = `${selectedTemplateName || 'prompt'}-test-${new Date().toISOString().replace(/[:.]/g,'-')}.md`
      const blob = new Blob([testResult], { type: 'text/markdown' })
      const file = new File([blob], name, { type: 'text/markdown' })
      const item = await providerInstance.uploadFile(folderId, file)
      setResultSavedItemId(item.id)
      toast({ title: 'Ergebnis gespeichert', description: name })
    } catch (e) {
      toast({ title: 'Speichern fehlgeschlagen', description: e instanceof Error ? e.message : 'Unbekannter Fehler', variant: 'destructive' })
    }
  }

  async function runMagicDesign() {
    if (!selectedTemplateName || !providerInstance || !activeLibrary) {
      toast({ title: 'Kein Prompt ausgewählt', description: 'Bitte wählen Sie zuerst einen Prompt.', variant: 'destructive' })
      return
    }
    const scopeParts: string[] = []
    if (magicFrontmatter.trim()) scopeParts.push('frontmatter')
    if (magicBody.trim()) scopeParts.push('body')
    if (magicSystem.trim()) scopeParts.push('systemprompt')
    const allowedScope = scopeParts.length === 0 ? 'all' : (scopeParts.length === 1 ? scopeParts[0] : 'all')

    try {
      setMagicRunning(true)
      // 1) Magic-Template laden (magicpromptdesign.md)
      const folderId = await ensureTemplatesFolder()
      const items = await listItems(folderId)
      const magicItem = items.find(it => it.type === 'file' && (it.metadata.name.toLowerCase() === 'magicpromptdesign.md'))
      let magicTemplateContent: string
      if (!magicItem) {
        // Fallback: aus /public/templates laden
        try {
          const res = await fetch('/templates/magicpromptdesign.md', { cache: 'no-store' })
          if (!res.ok) throw new Error(`HTTP ${res.status}`)
          magicTemplateContent = await res.text()
          console.log('[Magic] Fallback magicpromptdesign.md aus /public/templates verwendet')
        } catch (e) {
          toast({ title: 'Magic-Template fehlt', description: 'magicpromptdesign.md weder in /templates noch in /public/templates gefunden.', variant: 'destructive' })
          return
        }
      } else {
        const { blob } = await providerInstance.getBinary(magicItem.id)
        magicTemplateContent = await blob.text()
      }

      // 2) Inputtext zusammenstellen
      const currentTemplate = generateTemplateContent(form.getValues())
      const inputText = [
        'INPUT_TEMPLATE:',
        currentTemplate,
        '',
        'CHANGES:',
        'Aufgabe:',
        magicBody || '(keine)',
        '',
        'Metadaten:',
        magicFrontmatter || '(keine)',
        '',
        'Rollenanweisung:',
        magicSystem || '(keine)',
        '',
        'CONFIG:',
        `allowed_scope: ${allowedScope}`,
        'diff_mode: diff',
        'preserve_comments: ja'
      ].join('\n')

      // 3) Secretary-Service aufrufen
      const response = await fetch('/api/secretary/process-text', {
        method: 'POST',
        headers: { 'Content-Type': 'application/x-www-form-urlencoded', 'X-Library-Id': activeLibrary.id },
        body: new URLSearchParams({
          text: inputText,
          template_content: magicTemplateContent,
          source_language: 'de',
          target_language: 'de'
        })
      })
      if (!response.ok) {
        const err = await response.json().catch(() => ({}))
        throw new Error(err?.error || `HTTP ${response.status}`)
      }
      const data = await response.json()
      // data kann string (JSON) oder object sein
      let corrected: string | undefined
      let diff: string = ''
      try {
        const obj = typeof data === 'string' ? JSON.parse(data) : (typeof data === 'object' ? data : {})
        corrected = typeof obj?.corrected_template === 'string' ? obj.corrected_template : undefined
        diff = typeof obj?.diff_preview === 'string' ? obj.diff_preview : ''
      } catch (e) {
        // Fallback: Wenn data.text existiert
        const maybe = (data && typeof data.text === 'string') ? JSON.parse(data.text) : null
        corrected = maybe?.corrected_template
        diff = maybe?.diff_preview || ''
      }
      if (!corrected) throw new Error('Antwort ohne corrected_template')

      // 4) Template parsen und Formular übernehmen
      const parsed = parseTemplateContent(corrected, selectedTemplateName)
      form.setValue('yamlFrontmatter', parsed.yamlFrontmatter, { shouldDirty: true })
      form.setValue('markdownBody', parsed.markdownBody, { shouldDirty: true })
      form.setValue('systemPrompt', parsed.systemPrompt, { shouldDirty: true })
      setMagicLastDiff(diff || '')
      toast({ title: 'Magic Design angewendet', description: 'Änderungen übernommen (nicht gespeichert).' })

      // 5) Korrigiertes Template im Ordner prompt-tests ablegen (Debug/Verfolgung)
      try {
        const testsFolderId = await ensurePromptTestsFolder()
        const ts = new Date().toISOString().replace(/[:.]/g, '-')
        const baseName = `${selectedTemplateName}-magic-${ts}.md`
        const blobCorrected = new Blob([corrected], { type: 'text/markdown' })
        const fileCorrected = new File([blobCorrected], baseName, { type: 'text/markdown' })
        const savedItem = await providerInstance.uploadFile(testsFolderId, fileCorrected)
        setMagicSavedItemId(savedItem.id)
        toast({ title: 'Magic-Ergebnis gespeichert', description: baseName })

        if (diff && diff.trim().length > 0) {
          const diffName = `${selectedTemplateName}-magic-diff-${ts}.md`
          const blobDiff = new Blob([diff], { type: 'text/markdown' })
          const fileDiff = new File([blobDiff], diffName, { type: 'text/markdown' })
          await providerInstance.uploadFile(testsFolderId, fileDiff)
          console.log('[Magic] Diff gespeichert', diffName)
        }
      } catch (saveErr) {
        console.warn('Magic-Ergebnis konnte nicht gespeichert werden:', saveErr)
        const msg = saveErr instanceof Error ? saveErr.message : 'Unbekannter Fehler'
        toast({ title: 'Magic-Ergebnis NICHT gespeichert', description: msg, variant: 'destructive' })
      }
    } catch (e) {
      toast({ title: 'Magic fehlgeschlagen', description: e instanceof Error ? e.message : 'Unbekannter Fehler', variant: 'destructive' })
    } finally {
      setMagicRunning(false)
    }
  }

  // Render-Logik für verschiedene Status
  if (libraryStatus === "waitingForAuth") {
    return (
      <div className="flex flex-col items-center justify-center h-full text-muted-foreground">
        <span>Diese Bibliothek benötigt eine Authentifizierung.</span>
        <span className="text-sm mt-2">Bitte konfigurieren Sie die Bibliothek in den Einstellungen.</span>
      </div>
    )
  }
  
  if (libraryStatus !== "ready") {
    return (
      <div className="flex flex-col items-center justify-center h-full text-muted-foreground">
        <span>Lade Storage...</span>
      </div>
    )
  }

  if (!activeLibrary) {
    return (
      <div className="text-center text-muted-foreground">
        Bitte wählen Sie eine Bibliothek aus.
      </div>
    )
  }

  if (error) {
    return (
      <div className="text-center text-destructive">
        <p>Fehler beim Laden der Prompts:</p>
        <p className="text-sm">{error}</p>
        <Button 
          variant="outline" 
          className="mt-4"
          onClick={loadTemplates}
        >
          Erneut versuchen
        </Button>
      </div>
    )
  }

  return (
    <div className="space-y-6">

      {/* Kompakte Toolbar oben */}
      <div className="flex items-center gap-2">
        <Select value={selectedTemplateName || ''} onValueChange={(v) => { setSelectedTemplateName(v); form.setValue('name', v, { shouldDirty: false }) }} disabled={isLoading}>
          <SelectTrigger className="w-64">
            <SelectValue placeholder="Prompt auswählen..." />
          </SelectTrigger>
          <SelectContent>
            {templates.map((t) => (
              <SelectItem key={t.name} value={t.name}>{t.name}</SelectItem>
            ))}
          </SelectContent>
        </Select>
        <TooltipProvider>
          <Tooltip>
            <TooltipTrigger asChild>
              <Button variant="ghost" size="sm" className="h-8 w-8 p-0"><Info className="h-4 w-4" /></Button>
            </TooltipTrigger>
            <TooltipContent>
              <div className="flex items-center gap-2"><FolderOpen className="h-4 w-4" /><span>Ort: /templates in „{activeLibrary.label}“</span></div>
            </TooltipContent>
          </Tooltip>
        </TooltipProvider>
        <Button type="button" variant="outline" size="sm" onClick={createNewTemplate} disabled={isLoading}>Neu</Button>
        <Button type="button" variant="outline" size="sm" onClick={renameCurrentTemplate} disabled={!selectedTemplateName}>Umbenennen</Button>
        {selectedTemplateName && (
          <Button type="button" variant="destructive" size="sm" onClick={() => deleteTemplate(selectedTemplateName!)}>Löschen</Button>
        )}
      </div>

      <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
        <Card>
          <CardHeader>
            <CardTitle>Prompt Design</CardTitle>
            <CardDescription>
              Drei Bereiche: Aufgabe (was), Rollenanweisung (wie), Metadaten (Begleitinfos).
            </CardDescription>
          </CardHeader>
          <CardContent>
            <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-6">
              {/* Template-Name Feld entfernt (oben verwaltet) */}

              {!selectedTemplateName ? (
                <div className="rounded-md border border-dashed p-6 text-sm text-muted-foreground">
                  Bitte oben einen Prompt auswählen oder Neu anlegen.
                </div>
              ) : previewMode ? (
                <div className="space-y-4">
                  <div className="flex items-center justify-between">
                    <h4 className="text-sm font-medium">Prompt-Vorschau</h4>
                    <Button
                      type="button"
                      variant="outline"
                      size="sm"
                      onClick={() => setPreviewMode(false)}
                    >
                      Bearbeiten
                    </Button>
                  </div>
                  <div className="border rounded-md p-4 bg-muted/50">
                    <pre className="text-sm whitespace-pre-wrap font-mono">
                      {generatePreview()}
                    </pre>
                  </div>
                </div>
              ) : (
                <>
                  <StructuredTemplateEditor
                    markdownBody={form.watch('markdownBody')}
                    yamlFrontmatter={form.watch('yamlFrontmatter')}
                    systemPrompt={form.watch('systemPrompt')}
                    magicMode={magicMode}
                    magicValues={{ body: magicBody, frontmatter: magicFrontmatter, system: magicSystem }}
                    onMagicChange={(next) => {
                      if (next.body !== undefined) setMagicBody(next.body)
                      if (next.frontmatter !== undefined) setMagicFrontmatter(next.frontmatter)
                      if (next.system !== undefined) setMagicSystem(next.system)
                    }}
                    onChange={({ markdownBody, yamlFrontmatter, systemPrompt }) => {
                      form.setValue('markdownBody', markdownBody, { shouldDirty: true })
                      form.setValue('yamlFrontmatter', yamlFrontmatter, { shouldDirty: true })
                      form.setValue('systemPrompt', systemPrompt, { shouldDirty: true })
                    }}
                  />
                </>
              )}

              <div className="flex justify-end gap-2">
                {selectedTemplateName && (
                  <Button type="button" variant={magicMode ? 'secondary' : 'outline'} onClick={() => setMagicMode(v => !v)}>
                    {magicMode ? 'Magic Design ausblenden' : 'Magic Design'}
                  </Button>
                )}
                {magicMode && (
                  <>
                    <Button type="button" variant="secondary" onClick={() => { setMagicBody(''); setMagicFrontmatter(''); setMagicSystem(''); setMagicLastDiff('') }} disabled={magicRunning}>Magic zurücksetzen</Button>
                    <Button type="button" onClick={runMagicDesign} disabled={magicRunning || (!magicBody && !magicFrontmatter && !magicSystem)}>
                      {magicRunning ? (<><Loader2 className="h-4 w-4 mr-2 animate-spin" /> Magic läuft…</>) : 'Magic absenden'}
                    </Button>
                  </>
                )}
                <Button
                  type="button"
                  variant="outline"
                  onClick={() => setPreviewMode(!previewMode)}
                  disabled={!selectedTemplateName}
                >
                  <Eye className="h-4 w-4 mr-2" />
                  {previewMode ? "Bearbeiten" : "Vorschau"}
                </Button>
                <Button
                  type="submit"
                  disabled={!selectedTemplateName || isSaving || !form.formState.isDirty}
                >
                  {isSaving ? (
                    <>
                      <Loader2 className="h-4 w-4 mr-2 animate-spin" />
                      Wird gespeichert...
                    </>
                  ) : (
                    <>
                      <Save className="h-4 w-4 mr-2" />
                      Speichern
                    </>
                  )}
                </Button>
              </div>
            </form>
          </CardContent>
        </Card>

        <Card>
          <CardHeader>
            <CardTitle>Prompt testen</CardTitle>
            <CardDescription>
              Test mit Beispieltext. Nutzt Rollenanweisung, Aufgabe und Metadaten des Prompts.
            </CardDescription>
          </CardHeader>
          <CardContent>
            {!selectedTemplateName ? (
              <div className="rounded-md border border-dashed p-6 text-sm text-muted-foreground">
                Bitte oben einen Prompt auswählen. Die Vorschau und Test‑Funktionen werden erst danach aktiviert.
              </div>
            ) : (
              <Tabs value={rightTab} onValueChange={(v) => setRightTab(v as typeof rightTab)}>
                <TabsList className="grid grid-cols-3 w-full">
                  <TabsTrigger value="kontext">Daten‑Kontext</TabsTrigger>
                  <TabsTrigger value="preview">Prompt‑Vorschau</TabsTrigger>
                  <TabsTrigger value="testen">Testen</TabsTrigger>
                </TabsList>

                <TabsContent value="kontext" className="space-y-4 mt-4">
                  <div className="space-y-2">
                    <Label>Kontext-Texte</Label>
                    <div className="border rounded p-2 text-sm">
                      {Array.isArray(contextDocs) && contextDocs.length > 0 ? (
                        contextDocs.map(d => {
                          const checked = selectedContextIds.includes(d.id)
                          return (
                            <label key={d.id} className="flex items-center gap-2 py-1">
                              <Checkbox
                                checked={checked}
                                onCheckedChange={(v) => {
                                  const isOn = v === true
                                  setSelectedContextIds(prev => isOn ? [...prev, d.id] : prev.filter(x => x !== d.id))
                                }}
                              />
                              <span className="truncate">{d.name}</span>
                            </label>
                          )
                        })
                      ) : (
                        <div className="text-muted-foreground text-sm">Keine Kontext-Texte verfügbar</div>
                      )}
                    </div>
                  </div>

                  <div className="space-y-2">
                    <Label>Gewählter Kontext (Lesemodus)</Label>
                    <div className="border rounded-md">
                      <MarkdownPreview content={selectedContextMarkdown} />
                    </div>
                  </div>

                  <div className="space-y-2">
                    <Label>Freitext (optional)</Label>
                    <Textarea
                      value={freeText}
                      onChange={(e) => setFreeText(e.target.value)}
                      placeholder="Hier Text einkleben, um schnell zu testen"
                      className="min-h-[120px] font-mono text-sm"
                    />
                  </div>
                </TabsContent>

                <TabsContent value="preview" className="space-y-4 mt-4">
                  <div className="space-y-2">
                    <Label>Generierter Prompt (Markdown)</Label>
                    <div className="border rounded-md">
                      <MarkdownPreview content={generatePreview()} />
                    </div>
                  </div>
                  <div className="flex gap-2 justify-end">
                    <Button 
                      variant="outline" 
                      size="sm"
                      onClick={testTemplate}
                      disabled={!selectedTemplateName || isTesting}
                    >
                      {isTesting ? (
                        <>
                          <Loader2 className="h-4 w-4 mr-2 animate-spin" />
                          Teste...
                        </>
                      ) : (
                        <>
                          <Play className="h-4 w-4 mr-2" />
                          Prompt testen
                        </>
                      )}
                    </Button>
                  </div>
                </TabsContent>

                <TabsContent value="testen" className="space-y-4 mt-4">
                  <div className="flex gap-2 justify-end">
                    <Button 
                      variant="outline" 
                      size="sm"
                      onClick={testTemplate}
                      disabled={!selectedTemplateName || isTesting}
                    >
                      {isTesting ? (
                        <>
                          <Loader2 className="h-4 w-4 mr-2 animate-spin" />
                          Teste...
                        </>
                      ) : (
                        <>
                          <Play className="h-4 w-4 mr-2" />
                          Prompt testen
                        </>
                      )}
                    </Button>
                  </div>
                  {activeLibrary && providerInstance && (testResult || resultSavedItemId) ? (
                    <JobReportTab
                      libraryId={activeLibrary.id}
                      fileId={resultSavedItemId || 'preview'}
                      provider={providerInstance}
                      sourceMode="frontmatter"
                      viewMode="metaOnly"
                      mdFileId={resultSavedItemId || undefined}
                      rawContent={testResult || undefined}
                    />
                  ) : (
                    <div className="text-sm text-muted-foreground">Kein Ergebnis vorhanden.</div>
                  )}
                  <div className="flex gap-2">
                    <Button type="button" onClick={saveTestResult} disabled={!testResult}>Speichern</Button>
                  </div>
                </TabsContent>
              </Tabs>
            )}
          </CardContent>
        </Card>
      </div>
    </div>
  )
} 
```

- Ursache: `templatesAtom` erwartet beim Setzen ein Array. Wir haben irrtümlich `setTemplates((prev) => ...)` genutzt; dadurch wurde ein Funktionswert in den Atom-State geschrieben, wodurch `state.templates.find` fehlschlug.
- Fix: In `onSubmit` ersetze ich den Funktions‑Setter durch eine Array‑Zuweisung:
```12:14:src/components/templates/template-management.tsx
const nextTemplates = templates
  .filter((t) => t.name.toLowerCase() !== data.name.toLowerCase())
  .concat(updated)
setTemplates(nextTemplates)
```
- Linter: sauber.

Bitte erneut speichern testen; der Fehler sollte verschwinden.

```typescriptreact
const nextTemplates = templates
  .filter((t) => t.name.toLowerCase() !== data.name.toLowerCase())
  .concat(updated)
setTemplates(nextTemplates)
```

