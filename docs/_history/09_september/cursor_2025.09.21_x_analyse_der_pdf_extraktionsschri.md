# Analyse der PDF-Extraktionsschritte
_Exported on 10/9/2025 at 15:02:35 GMT+2 from Cursor (1.7.38)_

---

**User**

Ich habe in der File-List in der Library ein PDF ausgewählt und sehe oben jetzt diese Steps, um in unterschiedlichen Schritten das Dokument zu extrahieren und Markdown zu speichern, Metadaten zu extrahieren, zu speichern. Können wir diese Schritte nochmal analysieren und zusammenfassen? Ich sehe, die Extraktionsphase funktioniert, ein Markdown wird gespeichert, aber bei der Metadatenphase werden die Metadaten in dem Job-Dokument un Markdown gespeichert, aber im Frontend nicht richtig geparsed. Ist dieser generierte FrontMeta nicht richtig formatiert? Ist er gültig? Oder wird eventuell das nicht richtig ausgelesen, angezeigt?


---
source_file: "01OKT2024_Livique_Sørensen Bedding_Boxspringbett_EK_Netto_250704_v00003New.pdf"
acronyms_resolved: []
authors: []
chapters: [{"title":"Sørensen Bedding","level":1,"order":1,"startPage":1,"endPage":1,"pageCount":1,"startEvidence":"Sørensen Bedding \n\nNETTO EK PREISLISTE 2025\n\nGültig ab: 01.10.2024\nAlle Preise in Euro zzgl. der jeweils gesetzlichen Umsatzseuer. Preisänderungen und Irrtümer vorbehalten.","summary":"Einleitung zur Netto EK Preisliste 2025 von Sørensen Bedding mit Gültigkeit ab 01.10.2024 und Hinweis auf Preise in Euro zzgl. Umsatzsteuer.","keywords":["sorensen bedding","netto ek preisliste","2025","preise","gültig ab","euro","umsatzsteuer","preisänderungen","irrtümer"]},{"title":"Kopfteil HB01 Jalo","level":1,"order":2,"startPage":2,"endPage":2,"pageCount":1,"startEvidence":"Kopfteil HB01 Jalo \n\n- Gepolstertes Kopfteil\n- 2 Höhe: ca 110 cm | 120 cm, bodenstehend\n- Tiefe: ca 8 cm\n- Höhenkürzung in 5 cm Schritt möglich, Aufpreis 86,-\n- Rückseite mit Möbelstoff bezogen","summary":"Beschreibung und Preistabelle für das gepolsterte Kopfteil HB01 Jalo mit zwei Höhen und verschiedenen Breiten.","keywords":["kopfteil","hb01 jalo","gepolstert","höhe","tiefe","möbelstoff","preistabelle","breiten","aufpreis"]},{"title":"Kopfteil HB02 Smilla","level":1,"order":3,"startPage":2,"endPage":2,"pageCount":1,"startEvidence":"Kopfteil HB02 Smilla\n\n- Gepolstertes Kopfteil, mit seitlicher Fahne\n- 2 Höhe: ca 110 cm | 120 cm, bodenstehend\n- Tiefe: ca 10 cm\n- Höhenkürzung in 5 cm Schritt möglich, Aufpreis 86,-\n- Rückseite mit Möbelstoff bezogen","summary":"Beschreibung und Preistabelle für das gepolsterte Kopfteil HB02 Smilla mit seitlicher Fahne und verschiedenen Größen.","keywords":["kopfteil","hb02 smilla","gepolstert","seitliche fahne","höhe","tiefe","möbelstoff","preistabelle","aufpreis"]},{"title":"Kopfteil HB03 Vala","level":1,"order":4,"startPage":2,"endPage":2,"pageCount":1,"startEvidence":"Kopfteil HB03 Vala\n\n- Gepolstertes Kopfteil, mit Keder\n- 2 Höhe: ca 110 cm | 120 cm, bodenstehend\n- Tiefe: ca 14 cm\n- Höhenkürzung in 5 cm Schritt möglich, Aufpreis 86,-\n- Rückseite mit Möbelstoff bezogen","summary":"Beschreibung und Preistabelle für das gepolsterte Kopfteil HB03 Vala mit Keder und verschiedenen Größen.","keywords":["kopfteil","hb03 vala","gepolstert","keder","höhe","tiefe","möbelstoff","preistabelle","aufpreis"]},{"title":"Kopfteil HB04 Aiko","level":1,"order":5,"startPage":3,"endPage":3,"pageCount":1,"startEvidence":"Kopfteil HB04 Aiko \n\n- Gepolstertes Kopfteil\n- 2 Höhe: ca $110 \\mathrm{~cm} \\mid 120 \\mathrm{~cm}$, bodenstehend\n- Tiefe: ca 18 cm\n- Kopfteilbreite zzgl. beidseitig ca 4-5 cm\n- Höhenkürzung in 5 cm Schritt möglich, Aufpreis 86,-\n- Rückseite mit Möbelstoff bezogen\n- LED Leseleuchten nicht möglich","summary":"Beschreibung und Preistabelle für das gepolsterte Kopfteil HB04 Aiko mit besonderen Maßen und ohne LED Leseleuchten.","keywords":["kopfteil","hb04 aiko","gepolstert","höhe","tiefe","kopfteilbreite","möbelstoff","preistabelle","led leseleuchten","aufpreis"]},{"title":"Kopfteil HB05 Lykke","level":1,"order":6,"startPage":3,"endPage":3,"pageCount":1,"startEvidence":"Kopfteil HB05 Lykke\n\n- Gepolstertes Kopfteil\n- 2 Höhe: ca $110 \\mathrm{~cm} \\mid 120 \\mathrm{~cm}$, bodenstehend\n- Tiefe: ca 12 cm\n- Höhenkürzung in 5 cm Schritt möglich, Aufpreis 86,-\n- Rückseite mit Möbelstoff bezogen","summary":"Beschreibung und Preistabelle für das gepolsterte Kopfteil HB05 Lykke mit verschiedenen Höhen und Tiefen.","keywords":["kopfteil","hb05 lykke","gepolstert","höhe","tiefe","möbelstoff","preistabelle","aufpreis"]},{"title":"Kopfteil HB06 Hedda","level":1,"order":7,"startPage":3,"endPage":3,"pageCount":1,"startEvidence":"Kopfteil HB06 Hedda\n\n- Gepolstertes Kopfteil\n- 2 Höhe: ca $110 \\mathrm{~cm} \\mid 120 \\mathrm{~cm}$, bodenstehend\n- Tiefe: ca 9 cm\n- Höhenkürzung in 5 cm Schritt möglich, Aufpreis 86,-\n- Rückseite mit Möbelstoff bezogen","summary":"Beschreibung und Preistabelle für das gepolsterte Kopfteil HB06 Hedda mit verschiedenen Maßen.","keywords":["kopfteil","hb06 hedda","gepolstert","höhe","tiefe","möbelstoff","preistabelle","aufpreis"]},{"title":"Kopfteil HB07 Svea","level":1,"order":8,"startPage":4,"endPage":4,"pageCount":1,"startEvidence":"Kopfteil HB07 Svea\n\n- Gepolstertes Kopfteil\n- 2 Höhe: ca 110 cm | 120 cm, bodenstehend\n- Tiefe: ca 10 cm\n- Kopfteilbreite bündig\n- Höhenkürzung in 5 cm Schritt möglich, Aufpreis 86,-\n- Rückseite mit Möbelstoff bezogen","summary":"Beschreibung und Preistabelle für das gepolsterte Kopfteil HB07 Svea mit bündiger Kopfteilbreite.","keywords":["kopfteil","hb07 svea","gepolstert","höhe","tiefe","kopfteilbreite","möbelstoff","preistabelle","aufpreis"]},{"title":"2 Verschiedene Kombinationsmöglichkeiten","level":1,"order":9,"startPage":4,"endPage":4,"pageCount":1,"startEvidence":"2 VERSCHIEDENE KOMBINATSIONSMÖGLICHKEITEN\n\nBündig: Bsp. 160x200cm Bett + 160cm Kopfteil\n\nÜberstehend: Bsp. 160x200cm Bett + 180cm Kopfteil","summary":"Erklärung zu den Kombinationsmöglichkeiten von Bett und Kopfteil: bündig oder überstehend mit Größenhinweis.","keywords":["kombinationsmöglichkeiten","bündig","überstehend","bett","kopfteil","größen"]},{"title":"Option Stützfüße (Kopfteilhöhe + Stützfusshöhe = Gesamthöhe)","level":2,"order":10,"startPage":4,"endPage":4,"pageCount":1,"startEvidence":"Option Stützfüße (Kopfteilhöhe + Stützfusshöhe = Gesamthöhe)\n\n|  Fußhöhe | Aufpreis  |\n| --- | --- |\n|  ca 7,5 cm | 6,-  |\n|  ca 10 cm | 7,-  |\n|  ca 12 cm | 9,-  |\n|  ca 15 cm | 10,-  |\n|  ca 16 cm | 12,-  |\n|  ca 19 cm | 13,-  |","summary":"Preise für verschiedene Fußhöhen als Aufpreis zur Kopfteilhöhe für die Gesamthöhe.","keywords":["stützfüße","kopfteilhöhe","gesamthöhe","fußhöhe","aufpreis"]},{"title":"Zubehör","level":1,"order":11,"startPage":4,"endPage":4,"pageCount":1,"startEvidence":"Zubehör\n\nOption LED-Leseleuchten\n\n- Set (2-Stück)\n- In Silbermatt oder Chrom\n- Flexarm\n- USB Anschluss\n- Druck-Schalter\n- Befestigung an der oberen Ecke des Kopfteilrückseites\n\nPreis: 90,- p. Set","summary":"Zubehöroption LED-Leseleuchten im 2er Set mit verschiedenen Ausstattungsmerkmalen und Preisangabe.","keywords":["zubehör","led-leseleuchten","set","silbermatt","chrom","flexarm","usb","druck-schalter","preis"]},{"title":"SCHRITT 2: Wählen Sie Ihren Comfort","level":1,"order":12,"startPage":5,"endPage":5,"pageCount":1,"startEvidence":"SCHRITT 2: WÄHLEN SIE IHREN COMFORT\n\nContinental 51 cm\n\nKaltschaum-Polstermatratze TTF500 mit 5 Zonen H2 / H3 / H4\nKaltschaum-Fix-Box TTF500","summary":"Vorstellung der Continental 51 cm Matratze mit Kaltschaum und 5 Zonen sowie Fix-Box.","keywords":["comfort","continental","kaltschaum","polstermatratze","ttf500","5 zonen","fix-box"]},{"title":"Maße Liegefläche","level":2,"order":13,"startPage":5,"endPage":5,"pageCount":1,"startEvidence":"Maße Liegefläche\n\n| Masse | 70 cm | 80 cm | 90 cm | 100 cm | 120 cm | 140 cm | 160 cm | 180 cm | 200 cm |\n| Preise | 439,- | 471,- | 508,- | 539,- | 629,- | 820,- | 942,- | 1016,- | 1078,- |","summary":"Preistabelle für Liegeflächenmaße der Continental Matratze in verschiedenen Breiten.","keywords":["maße","liegefläche","preise","continental","matratze","breiten"]},{"title":"Option: Polstermatratze mit Drell Weiss","level":2,"order":14,"startPage":5,"endPage":5,"pageCount":1,"startEvidence":"OPTION: Polstermatratze mit Drell Weiss\n\n- Klimaband für eine nachhaltige Belüftung der Matratze\n- Intergrierte Wendeschlaufe zum erleichterten Drehen und Wenden der Matratze","summary":"Optionale Polstermatratze mit Drell Weiss Bezug, Klimaband und Wendeschlaufe für bessere Belüftung und Handhabung.","keywords":["option","polstermatratze","drell weiss","klimaband","belüftung","wendeschlaufe"]},{"title":"Automat 51 cm","level":1,"order":15,"startPage":5,"endPage":5,"pageCount":1,"startEvidence":"Automat 51 cm\n\nKaltschaum-Polstermatratze TTF500 mit 5 Zonen H2 / H3 / H4\nKaltschaum-Automat-Box TTF500","summary":"Beschreibung der Automat 51 cm Matratze mit Kaltschaum und 5 Zonen sowie Automat-Box.","keywords":["automat","kaltschaum","polstermatratze","ttf500","5 zonen","automat-box"]},{"title":"Option Sensor-Led","level":2,"order":16,"startPage":5,"endPage":5,"pageCount":1,"startEvidence":"Option Sensor-Led\n\nBewegungsgesteuertes Led-Licht\n2 Stk als Paar unter Box zu montieren","summary":"Option für bewegungsgesteuertes LED-Licht als Paar zur Montage unter der Box mit Preisangaben.","keywords":["option","sensor-led","bewegungsgesteuert","led-licht","montage","preis"]},{"title":"Softlux","level":1,"order":17,"startPage":6,"endPage":6,"pageCount":1,"startEvidence":"Softlux \n\n| Topper (Hülle + Kern $4 \\mathrm{~cm}=7 \\mathrm{~cm}$ ) | Hülle | 70 cm | 80 cm | 90 cm | 100 cm | 120 cm | 140 cm | 160 cm | 180 cm | 200 cm |","summary":"Preistabelle und Beschreibung der Softlux Topper mit verschiedenen Kernarten und Hüllenmaßen.","keywords":["softlux","topper","hülle","kern","preise","maße","polyester","viskose"]},{"title":"Füße","level":1,"order":18,"startPage":7,"endPage":7,"pageCount":1,"startEvidence":"Füße\n\nSCHRITT 4: WÄHLEN SIE IHRE FÜßE\n\nHolzfüße\n\n| K <br> Quader Holz <br> Schwarz | 10 cm | 18,- | 32,- |","summary":"Auswahl und Preistabelle für verschiedene Fußtypen aus Holz, Schwebefüße und Metallfüße mit Höhen und Preisen.","keywords":["füße","holzfüße","schwebefüße","metallfüße","höhe","preise","set"]},{"title":"Zubehör","level":1,"order":19,"startPage":8,"endPage":9,"pageCount":2,"startEvidence":"Zubehör\n\n|  | Preise |  |\n| :-- | :-- | :-- |\n|  | 102 <br> cm | 294,- |\n| Bett-Truhe Universal <br> L: 102/122/142 x B: $45 \\times$ H: 56 cm | 122 <br> cm | 328,- |","summary":"Preise für Zubehör wie Bett-Truhen, Bettbänke und Deko-Kissen in verschiedenen Größen und Ausführungen.","keywords":["zubehör","bett-truhe","bettbänke","deko-kissen","preise","größen","sets"]}]
commercialStatus: "commercial"
confidence: {"title":0.95,"shortTitle":0.85,"slug":0.85,"summary":0.95,"teaser":0.95,"authors":0.7,"tags":0.7,"topics":0.7,"docType":0.7,"year":0.95,"region":0.7,"language":0.95,"source":0.7,"seriesOrJournal":0.7,"issue":0.7,"commercialStatus":0.85,"project":0.7,"filename":0.85,"path":0.7,"pathHints":0.7,"isScan":0.85,"acronyms_resolved":0.7,"chapters":0.95}
docType: "brochure"
extract_status: "completed"
filename: "01OKT2024_Livique_Sørensen Bedding_Boxspringbett_EK_Netto_250704_v00003New"
ingest_status: "none"
isScan: false
issue: ""
job_id: "4ac5f76e-3489-49d5-ab25-51be277c5c1e"
language: "de"
path: "Für Peter/Sorensen Bedding"
pathHints: ["sorensen-bedding"]
project: ""
provenance: {"title":"doc.heading","shortTitle":"filename","slug":"filename","summary":"doc.heading","teaser":"doc.heading","authors":"[]","tags":"doc.text","topics":"[]","docType":"path","year":"doc.heading","region":"[]","language":"doc.text","source":"[]","seriesOrJournal":"[]","issue":"[]","commercialStatus":"filename","project":"[]","filename":"filename","path":"path","pathHints":"path","isScan":"filename","acronyms_resolved":"[]","chapters":"doc.heading"}
region: ""
seriesOrJournal: ""
shortTitle: "Sorensen Bedding Preisliste 2025"
slug: "sorensen-bedding-netto-ek-preisliste-2025"
source: ""
summary: "Preisliste für Sørensen Bedding Boxspringbetten und Zubehör gültig ab 01.10.2024."
summary_language: "de"
tags: ["preisliste","boxspringbett","kopfteil","matratze","zubehoer","fuesse"]
teaser: "Diese Preisliste enthält Preise für verschiedene Kopfteilmodelle, Matratzen, Füße und Zubehör von Sørensen Bedding. Alle Preise verstehen sich in Euro zzgl. gesetzlicher Umsatzsteuer."
template_status: "completed"
title: "Sørensen Bedding NETTO EK PREISLISTE 2025"
topics: []
year: 2024
---

--- Seite 1 ---
# Sørensen Bedding 

![img-0.jpeg](img-0.jpeg)

## NETTO EK PREISLISTE 2025

Gültig ab: 01.10.2024
Alle Preise in Euro zzgl. der jeweils gesetzlichen Umsatzseuer. Preisänderungen und Irrtümer vorbehalten.

--- Seite 2 ---
# Kopfteil HB01 Jalo 

![img-1.jpeg](img-1.jpeg)

- Gepolstertes Kopfteil
- 2 Höhe: ca 110 cm | 120 cm, bodenstehend
- Tiefe: ca 8 cm
- Höhenkürzung in 5 cm Schritt möglich, Aufpreis 86,-
- Rückseite mit Möbelstoff bezogen

| Masse | 80 cm | 90 cm | 100 cm | 120 cm | 140 cm | 160 cm | 180 cm | 200 cm | 220 cm |
| :-- | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
| Preise | 130,- | 141,- | 147,- | 160,- | 168,- | 179,- | 194,- | 213,- | 231,- |

## Kopfteil HB02 Smilla

![img-2.jpeg](img-2.jpeg)

- Gepolstertes Kopfteil, mit seitlicher Fahne
- 2 Höhe: ca 110 cm | 120 cm, bodenstehend
- Tiefe: ca 10 cm
- Höhenkürzung in 5 cm Schritt möglich, Aufpreis 86,-
- Rückseite mit Möbelstoff bezogen

| Masse | 80 cm | 90 cm | 100 cm | 120 cm | 140 cm | 160 cm | 180 cm | 200 cm | 220 cm |
| :-- | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
| Preise | 220,- | 225,- | 230,- | 238,- | 247,- | 254,- | 267,- | 280,- | 299,- |

## Kopfteil HB03 Vala

![img-3.jpeg](img-3.jpeg)

- Gepolstertes Kopfteil, mit Keder
- 2 Höhe: ca 110 cm | 120 cm, bodenstehend
- Tiefe: ca 14 cm
- Höhenkürzung in 5 cm Schritt möglich, Aufpreis 86,-
- Rückseite mit Möbelstoff bezogen

| Masse | 80 cm | 90 cm | 100 cm | 120 cm | 140 cm | 160 cm | 180 cm | 200 cm | 220 cm |
| :-- | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
| Preise | 336,- | 341,- | 351,- | 382,- | 390,- | 401,- | 410,- | 426,- | 438,- |

--- Seite 3 ---
# Kopfteil HB04 Aiko 

![img-4.jpeg](img-4.jpeg)

- Gepolstertes Kopfteil
- 2 Höhe: ca $110 \mathrm{~cm} \mid 120 \mathrm{~cm}$, bodenstehend
- Tiefe: ca 18 cm
- Kopfteilbreite zzgl. beidseitig ca 4-5 cm
- Höhenkürzung in 5 cm Schritt möglich, Aufpreis 86,-
- Rückseite mit Möbelstoff bezogen
- LED Leseleuchten nicht möglich

| Masse | 80 cm | 90 cm | 100 cm | 120 cm | 140 cm | 160 cm | 180 cm | 200 cm | 220 cm |
| :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
| Preise | - | - | - | - | 284,- | 305,- | 328,- | 350,- | 374,- |

## Kopfteil HB05 Lykke

![img-5.jpeg](img-5.jpeg)

- Gepolstertes Kopfteil
- 2 Höhe: ca $110 \mathrm{~cm} \mid 120 \mathrm{~cm}$, bodenstehend
- Tiefe: ca 12 cm
- Höhenkürzung in 5 cm Schritt möglich, Aufpreis 86,-
- Rückseite mit Möbelstoff bezogen

| Masse | 80 cm | 90 cm | 100 cm | 120 cm | 140 cm | 160 cm | 180 cm | 200 cm | 220 cm |
| :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
| Preise | 222,- | 230,- | 246,- | 258,- | 269,- | 285,- | 303,- | 318,- | 337,- |

## Kopfteil HB06 Hedda

![img-6.jpeg](img-6.jpeg)

- Gepolstertes Kopfteil
- 2 Höhe: ca $110 \mathrm{~cm} \mid 120 \mathrm{~cm}$, bodenstehend
- Tiefe: ca 9 cm
- Höhenkürzung in 5 cm Schritt möglich, Aufpreis 86,-
- Rückseite mit Möbelstoff bezogen

| Masse | 80 cm | 90 cm | 100 cm | 120 cm | 140 cm | 160 cm | 180 cm | 200 cm | 220 cm |
| :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
| Preise | 154,- | 159,- | 173,- | 185,- | 195,- | 210,- | 226,- | 242,- | 266,- |

--- Seite 4 ---
# Kopfteil HB07 Svea

![img-7.jpeg](img-7.jpeg)

- Gepolstertes Kopfteil
- 2 Höhe: ca 110 cm | 120 cm, bodenstehend
- Tiefe: ca 10 cm
- Kopfteilbreite bündig
- Höhenkürzung in 5 cm Schritt möglich, Aufpreis 86,-
- Rückseite mit Möbelstoff bezogen

|  Masse | 80 cm | 90 cm | 100 cm | 120 cm | 140 cm | 160 cm | 180 cm | 200 cm | 220 cm  |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
|  Preise | 327,- | 338,- | 348,- | 376,- | 389,- | 401,- | 407,- | 426,- | 447,-  |

## 2 VERSCHIEDENE KOMBINATSIONSMÖGLICHKEITEN

![img-8.jpeg](img-8.jpeg)

**Bündig:** Bsp. 160x200cm Bett + 160cm Kopfteil

![img-9.jpeg](img-9.jpeg)

**Überstehend:** Bsp. 160x200cm Bett + 180cm Kopfteil

## ERLÄUTERUNGEN:

Für ein überstehendes Kopfteil einfach die nächst grössere Größe bestellen.

### Option Stützfüße (Kopfteilhöhe + Stützfusshöhe = Gesamthöhe)

|  Fußhöhe | Aufpreis  |
| --- | --- |
|  ca 7,5 cm | 6,-  |
|  ca 10 cm | 7,-  |
|  ca 12 cm | 9,-  |
|  ca 15 cm | 10,-  |
|  ca 16 cm | 12,-  |
|  ca 19 cm | 13,-  |

## Zubehör

![img-10.jpeg](img-10.jpeg)

### Option LED-Leseleuchten

- Set (2-Stück)
- In Silbermatt oder Chrom
- Flexarm
- USB Anschluss
- Druck-Schalter
- Befestigung an der oberen Ecke des Kopfteilrückseites

Preis: 90,- p. Set

--- Seite 5 ---
# SCHRITT 2: WÄHLEN SIE IHREN COMFORT 

## Continental 51 cm

Kaltschaum-Polstermatratze TTF500 mit 5 Zonen H2 / H3 / H4
Kaltschaum-Fix-Box TTF500
![img-11.jpeg](img-11.jpeg)

## Maße Liegefläche

| Masse | 70 cm | 80 cm | 90 cm | 100 cm | 120 cm | 140 cm | 160 cm | 180 cm | 200 cm |
| :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
| Preise | 439,- | 471,- | 508,- | 539,- | 629,- | 820,- | 942,- | 1016,- | 1078,- |

Empfohlene max. Gewichtsbelastung H2 80 Kg | H3 95 Kg | H4 110 Kg

## OPTION: Polstermatratze mit Drell Weiss

- Klimaband für eine nachhaltige Belüftung der Matratze
- Intergrierte Wendeschlaufe zum erleichterten Drehen und Wenden der Matratze

|  | Maße Liegefläche |  |  |  |  |  |  |  |  |  |  |
| :-- | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
| Option Klett-Boxhusse | Preise | 70 cm | 80 cm | 90 cm | 100 cm | 120 cm | 140 cm | 160 cm | 180 cm | 200 cm |  |
| Premium (KHP): <br> Die Box-Husse wird über die Weiss- <br> polster Boxen gezogen und mit Klett- <br> befestigung an der Unterseite fixiert |  | 48,- | 48,- | 48,- | 48,- | 48,- | 60,- | 60,- | 60,- | 60,- |  |

## ERLÄUTERUNGEN:

Ab 160 cm Breite ist die Box und die Matratze immer geteilt.
Aufpreis für Länge: $210 \mathrm{~cm}+10 \%$ und $220 \mathrm{~cm}+20 \%$. Preis für Länge $190 \mathrm{~cm}=200 \mathrm{~cm}$.

## Matratze

Massivholz-Box mit Fingerzinken

## Automat 51 cm

Kaltschaum-Polstermatratze TTF500 mit 5 Zonen H2 / H3 / H4
Kaltschaum-Automat-Box TTF500
![img-12.jpeg](img-12.jpeg)

|  | Maße Liegefläche |  |  |  |  |  |  |  |  |  |  |
| :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
| Masse | 70 cm | 80 cm | 90 cm | 100 cm | 120 cm | 140 cm | 160 cm | 180 cm | 200 cm |  |  |
| Preise | 950,- | 997,- | 1054,- | 1102,- | 1224,- | 1838,- | 1994,- | 2108,- | 2204,- |  |  |

Empfohlene max. Gewichtsbelastung H2 80 Kg | H3 95 Kg | H4 110 Kg
Motorrahmen maximale Gewichtsbelastung 120 Kg . Serienmässig mit Antirutschbeschichtung (auf Box Oberseite und Matratzen Unterseite), Wifi-Fernbedienung (Bedienung per APP verfügbar), integriertes Nachtlicht (unten am Motor), Syncrofunktion.

OPTION: Polstermatratze mit Drell Weiss

- Klimaband für eine nachhaltige Belüftung der Matratze


## ERLÄUTERUNGEN:

Ab 140 cm Breite ist die Box immer geteilt, die Matratze ab 160 cm .
Aufpreis für Länge: $210 \mathrm{~cm}+10 \%$ und $220 \mathrm{~cm}+20 \%$. Preis für Länge $190 \mathrm{~cm}=200 \mathrm{~cm}$.

## Option

Kombikern sortenrein

| Maße | 70 cm | 80 cm | 90 cm | 100 cm | 120 cm | 140 cm | 160 cm | 180 cm | 200 cm |
| :-- | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
| Aufpreis | - | - | - | - | - | - | 34,- | 34,- | 34,- |

1 oder 2 verschiedene Härtegrade in einem Kern, die Matratze ist immer durchgehend.
Wichtig: Transportsituation (Grösse und Gewicht) mit dem Kunden abklären!

## Option Sensor-Led

Bewegungsgesteuertes Led-Licht
2 Stk als Paar unter Box zu montieren

| Maße | 70 cm | 80 cm | 90 cm | 100 cm | 120 cm | 140 cm | 160 cm | 180 cm | 200 cm |
| :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
| Aufpreis | 63,- | 63,- | 63,- | 63,- | 63,- | 63,- | 63,- | 63,- | 63,- |

--- Seite 6 ---
# Softlux 

| Topper (Hülle + Kern $4 \mathrm{~cm}=7 \mathrm{~cm}$ ) | Hülle | 70 cm | 80 cm | 90 cm | 100 cm | 120 cm | 140 cm | 160 cm | 180 cm | 200 cm |
| :-- | :-- | :-- | :-- | :-- | :-- | :-- | :-- | :-- | :-- | :-- |
| Softlux - Aircell | ca 7 cm | 127,- | 137,- | 146,- | 154,- | 164,- | 174,- | 188,- | 198,- | 208,- |
| Softlux - Visco | ca 7 cm | 132,- | 142,- | 153,- | 162,- | 170,- | 185,- | 203,- | 214,- | 226,- |
| Softlux - Hypersoft | ca 7 cm | 137,- | 148,- | 158,- | 169,- | 187,- | 207,- | 218,- | 230,- | 247,- |

Topper Hülle aus weichem Polyester-Viskose-Jersey Stoff (61\% Polyester, 39\% Viskose).

## ERLÄUTERUNGEN:

Durchgehende Topper für Motorbetten sind im oberen Bereich (Rückenverstellung) ca. 90 cm eingeschlitzt = Split-Topper. Ab 160 cm sind die Topper mit 4-seitigem Reißverschluss. Ansonsten 3-seitig.
Aufpreis für Länge: $210 \mathrm{~cm}+10 \%$ und $220 \mathrm{~cm}+20 \%$. Preis für Länge $190 \mathrm{~cm}=200 \mathrm{~cm}$.

## Hülle

![img-13.jpeg](img-13.jpeg)

Hülle: Softlux mit Klimaband
Bezug: 61\% Polyester, 39\% Viskose
Füllung: 30\% Tencel, 70\% Polyester- Hohlfaser

## Kern

![img-14.jpeg](img-14.jpeg)

Kern: Aircell 35
(Kaltschaum HR)

- Offenporig, somit atmungsaktiv
- Ergonomisch gut anpassbar an den Körper
![img-15.jpeg](img-15.jpeg)

Kern: Hypersoft 40
(Kaltschaum HR)

- Offenporig, somit atmungsaktiv
- Ergonomisch gut anpassbar an den Körper
![img-16.jpeg](img-16.jpeg)

Kern: Visco 50
(Viscoelastischer Schaum)

- 100\% Anpassung an den Körper
- Absolute Druckentlastung
- Hohe Lebensdauer

--- Seite 7 ---
# 4 

Füße

SCHRITT 4: WÄHLEN SIE IHRE FÜßE

| Fuß | Höhe | Set 4 | Set <br> 4+4 |  |
| :-- | :-- | :-- | :-- | :-- |

## Holzfüße

| K <br> Quader Holz <br> Schwarz | 10 cm | 18,- | 32,- |  |
| :-- | :-- | :-- | :-- | :-- |
| BU3 <br> Quader Holz <br> Eiche massiv | 10 cm | 18,- | 32,- |  |
| BU4 <br> Eiche Wenge | 10 cm | 18,- | 32,- |  |
| OP5 <br> Holz Schwarz | 10 cm | 30,- | 45,- |  |
| OP2 <br> Eiche Wenge | 10 cm | 30,- | 45,- |  |
| OP4 <br> Eiche hell | 10 cm | 30,- | 45,- |  |
| Konus Holz <br> Säule Eiche, <br> Natur geölt (I-7) <br> Wenge (I-13) <br> Schwarz (I-11) | 12 cm | 22,- | 38,- |  |
| Konus Holz <br> Säule Eiche, <br> Natur geölt (I-1) <br> Wenge (I-14) <br> Schwarz (I-5) | 16 cm | 23,- | 43,- |  |

## Schwebefüße

| SF 7,5 <br> Säule <br> Holz <br> Schwarz | $7,5 \mathrm{~cm}$ | 14,- | 29,- |  |
| :-- | :-- | :-- | :-- | :-- |
| SF 10 <br> Säule <br> Holz <br> Schwarz | 10 cm | 14,- | 28,- |  |
| SF 15 <br> Säule <br> Holz <br> Schwarz | 15 cm | 18,- | 35,- |  |
| Schwebesockel <br> Holz Schwarz | $7,5 \mathrm{~cm}$ | 60,- | - |  |

## Metallfüße

| AE <br> Schwarz matt | 12 cm | 62,- | 82,- |  |
| :-- | :-- | :-- | :-- | :-- |
| MM-1 <br> Metall <br> Chromfarbig | 10 cm | 46,- | 61,- |  |
| LU <br> Metall- <br> Schwarz | 10 cm | 35,- | 50,- |  |

## ERLÄUTERUNGEN:

Set 4 für Einzelbett mit durchgehender Box.
Set $4+4$ für Doppelbett mit 4 sichtbaren Eckfüsse und mittig zurückversetzte Schwebefüsse.
Eckfüsse in Kombination mit Klett+Boxhusse Premium (KHP) sind ca. 2,5 cm zurückversetzt.

--- Seite 8 ---
# 5 

## Zubehör

![img-17.jpeg](img-17.jpeg)

|  | Preise |  |
| :-- | :-- | :-- |
|  |  |  |
|  | 102 <br> cm | 294,- |
| Bett-Truhe Universal <br> L: 102/122/142 x B: $45 \times$ H: 56 cm | 122 <br> cm | 328,- |
|  | 142 <br> cm | 354,- |


|  | Preise | (Preise Bettbänke ohne Füsse) |
| :--: | :--: | :--: |
| Simple <br> L: $142 \times$ B: $42 \times$ H: 22 cm | 378,- |  |
| Stripe <br> L: $142 \times$ B: $42 \times$ H: 22 cm | 406,- |  |
| Diamond <br> L: $142 \times$ B: $42 \times$ H: 22 cm | 406,- |  |
| Caro <br> L: $142 \times$ B: $42 \times$ H: 22 cm | 406,- |  |
| Konus Holz <br> Natur Eiche geölt (I) <br> Wenge (I-12) <br> Schwarz (I-6) | 24 cm | 26,- |
| Konus Holz <br> Natur Eiche geölt (I-1) <br> Wenge (I-14) <br> Schwarz (I-5) | 16 cm | 23,- |

Bitte Fussvariante addieren.

--- Seite 9 ---
![img-18.jpeg](img-18.jpeg)

|   | Preise |   |
| --- | --- | --- |
|  Deko-Quadratkissen $40 \times 40 \mathrm{~cm}$
Hülle mit Reißverschluss. Füllung:
Dunella® 30\% Polyethylen 70\% Polyester | 14,- |   |
|  Deko-Quadratkissen $51 \times 51 \mathrm{~cm}$
Hülle mit Reißverschluss. Füllung:
Dunella® 30\% Polyethylen 70\% Polyester | 23,- |   |
|  Deko-Quadratkissen $65 \times 65 \mathrm{~cm}$
Hülle mit Reißverschluss. Füllung:
Dunella® 30\% Polyethylen 70\% Polyester | 32,- |   |
|  Deko-Kissen-Set 5-teilig
3 St. $35 \times 35 \mathrm{~cm}$ und 2 St. $40 \times 60 \mathrm{~cm}$
Hülle mit Reißverschluss. Füllung:
Dunella® 30\% Polyethylen 70\% Polyester | 75,- |   |
|  Deko-Rechteckkissen $40 \times 60 \mathrm{~cm}$ (2er Set)
Hülle mit Reißverschluss. Füllung:
Dunella® 30\% Polyethylen 70\% Polyester | 46,- |   |
|  Deko-Rechteckkissen $50 \times 70 \mathrm{~cm}$ (2er Set)
Hülle mit Reißverschluss. Füllung:
Dunella® 30\% Polyethylen 70\% Polyester | 57,- |   |
|  Rollkissen
Durchmesser: ca 20 cm
Breite wählbar 75 cm oder 85 cm | 62,- |   |

---

**Cursor**

Ich schaue mir jetzt an, wo Frontmatter generiert, geparst und im UI angezeigt wird, um festzustellen, ob das Format ungültig ist oder das Frontend es falsch ausliest. Danach prüfe ich die Library-Komponenten für die Metadaten-Ansicht und den Stepper.

Ich lade jetzt die Parser-Implementierungen und das Frontmatter-Modul, um die genaue Parsing-Logik mit deinem Beispiel zu vergleichen. Danach prüfe ich, ob dein Frontmatter-Block syntaktisch gültig ist.

Ich passe jetzt den strikten Frontmatter-Parser an, damit der JSON‑Block für chapters/toc nicht mehr am ersten schließenden ']' abbricht, sondern die gesamte Zeile nach dem Schlüssel parst. Danach prüfe ich Linter-Warnungen für die geänderte Datei.

```typescript
import { extractFrontmatterBlock } from '@/lib/markdown/frontmatter'

export interface FrontmatterParseResult {
  frontmatter: string | null
  meta: Record<string, unknown>
  errors: string[]
}

/**
 * Strictly parse a Markdown string produced by the Secretary transformer.
 * - Extracts the first frontmatter block via --- ... ---
 * - Parses key: value lines as raw strings without coercion
 * - Parses chapters/toc only if they are valid JSON arrays
 * - Returns errors for any JSON parse failures (no tolerance)
 */
export function parseSecretaryMarkdownStrict(markdown: string): FrontmatterParseResult {
  const fm = extractFrontmatterBlock(markdown)
  if (!fm) return { frontmatter: null, meta: {}, errors: [] }
  const meta: Record<string, unknown> = {}
  const errors: string[] = []

  // Raw key: value pairs (keep as string)
  for (const line of fm.split('\n')) {
    const t = line.trim()
    if (!t || t === '---') continue
    const idx = t.indexOf(':')
    if (idx > 0) {
      const k = t.slice(0, idx).trim()
      const v = t.slice(idx + 1)
      meta[k] = v
    }
  }

  // Strict JSON for chapters/toc
  // Hinweis: Die Secretary-Generierung schreibt die Arrays einzeilig als JSON (YAML erlaubt JSON-Syntax).
  // Das vorherige Regex (non-greedy bis erstes "]") brach bei verschachtelten Arrays frühzeitig ab.
  // Wir lesen stattdessen den kompletten Zeilenwert nach dem Schlüssel und parsen ihn als JSON.
  const lineValue = (key: string): string | null => {
    const m = new RegExp(`^${key}:\\s*(.+)$`, 'm').exec(fm)
    return m && m[1] ? m[1].trim() : null
  }

  const chaptersLine = lineValue('chapters')
  if (chaptersLine) {
    try { meta['chapters'] = JSON.parse(chaptersLine) } catch (e) { errors.push(`chapters ist kein gültiges JSON: ${(e as Error).message}`) }
  }

  const tocLine = lineValue('toc')
  if (tocLine) {
    try { meta['toc'] = JSON.parse(tocLine) } catch (e) { errors.push(`toc ist kein gültiges JSON: ${(e as Error).message}`) }
  }

  return { frontmatter: fm, meta, errors }
}


```

```typescriptreact
"use client";

import { useEffect, useState } from 'react'
import { UILogger } from '@/lib/debug/logger'
import type { StorageProvider } from '@/lib/storage/types'
import { MarkdownPreview } from '@/components/library/markdown-preview'
import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs'
import { parseSecretaryMarkdownStrict } from '@/lib/secretary/response-parser'

interface JobReportTabProps {
  libraryId: string
  fileId: string
  fileName?: string
  provider?: StorageProvider | null
  // Quelle der Metadaten steuern: 'merged' = cumulativeMeta + Frontmatter (Standard),
  // 'frontmatter' = ausschließlich Frontmatter aus Markdown anzeigen
  sourceMode?: 'merged' | 'frontmatter'
  // Darstellungsmodus: 'full' zeigt Kopf/Steps/Logs/Parameter; 'metaOnly' zeigt nur Metadaten/Kapitel/TOC
  viewMode?: 'full' | 'metaOnly'
  // Optional explizite Markdown-Datei-ID (Shadow‑Twin). Überschreibt auto-Erkennung.
  mdFileId?: string | null
  // Optionaler Callback zum Scroll-Sync in die Markdown-Vorschau
  onJumpTo?: (args: { page?: number | string; evidence?: string }) => void
  // NEU: Rohinhalt (Markdown). Wenn gesetzt und sourceMode='frontmatter', wird direkt dieser Text geparst (ohne Datei/JOB).
  rawContent?: string
}

interface JobDto {
  jobId: string
  status: string
  operation: string
  worker: string
  job_type: string
  updatedAt: string
  createdAt: string
  correlation?: { source?: { itemId?: string; name?: string } }
  parameters?: Record<string, unknown>
  steps?: Array<{ name: string; status: string; startedAt?: string; endedAt?: string; error?: { message: string }; details?: { skipped?: boolean } }>
  ingestion?: { vectorsUpserted?: number; index?: string; upsertAt?: string }
  result?: { savedItemId?: string }
  logs?: Array<{ timestamp: string; phase?: string; message?: string; progress?: number }>
  cumulativeMeta?: Record<string, unknown>
}

export function JobReportTab({ libraryId, fileId, fileName, provider, sourceMode = 'merged', viewMode = 'full', mdFileId, onJumpTo, rawContent }: JobReportTabProps) {
  const [loading, setLoading] = useState(false)
  const [error, setError] = useState<string | null>(null)
  const [job, setJob] = useState<JobDto | null>(null)
  const [templateFields, setTemplateFields] = useState<string[] | null>(null)
  const [frontmatterMeta, setFrontmatterMeta] = useState<Record<string, unknown> | null>(null)
  const [section, setSection] = useState<'meta' | 'chapters'>('meta')
  const [parseErrors, setParseErrors] = useState<string[]>([])
  const [fullContent, setFullContent] = useState<string>('')

  const stripFrontmatter = (markdown: string): string => markdown.replace(/^---\r?\n([\s\S]*?)\r?\n---\r?\n?/, '')

  useEffect(() => {
    let cancelled = false
    async function run() {
      try {
        // Wenn wir Rohinhalt haben und nur Frontmatter zeigen, brauchen wir keine Job-Suche
        if (sourceMode === 'frontmatter' && typeof rawContent === 'string' && rawContent.length > 0) {
          setJob(null)
          setLoading(false)
          setError(null)
          return
        }
        setLoading(true)
        setError(null)
        UILogger.info('JobReportTab', 'Start Job-Suche', { libraryId, fileId })
        // 1) Versuche Job über result.savedItemId (Shadow‑Twin) zu finden
        const byResultUrl = new URL(`/api/external/jobs`, window.location.origin)
        byResultUrl.searchParams.set('byResultItemId', fileId)
        UILogger.debug('JobReportTab', 'Request byResultItemId', { url: byResultUrl.toString() })
        let res = await fetch(byResultUrl.toString(), { cache: 'no-store' })
        let data = await res.json()
        if (!res.ok) throw new Error(typeof data?.error === 'string' ? data.error : 'Job-Suche fehlgeschlagen')
        let j: JobDto | null = Array.isArray(data?.items) && data.items.length > 0 ? (data.items[0] as JobDto) : null
        UILogger.debug('JobReportTab', 'Result byResultItemId', { count: Array.isArray(data?.items) ? data.items.length : 0 })

        // 2) Fallback: über correlation.source.itemId (Originaldatei)
        if (!j) {
          const bySourceUrl = new URL(`/api/external/jobs`, window.location.origin)
          bySourceUrl.searchParams.set('bySourceItemId', fileId)
          bySourceUrl.searchParams.set('libraryId', libraryId)
          UILogger.debug('JobReportTab', 'Request bySourceItemId', { url: bySourceUrl.toString() })
          res = await fetch(bySourceUrl.toString(), { cache: 'no-store' })
          data = await res.json()
          if (!res.ok) throw new Error(typeof data?.error === 'string' ? data.error : 'Job-Suche (Quelle) fehlgeschlagen')
          j = Array.isArray(data?.items) && data.items.length > 0 ? (data.items[0] as JobDto) : null
          UILogger.debug('JobReportTab', 'Result bySourceItemId', { count: Array.isArray(data?.items) ? data.items.length : 0 })
        }

        // 3) Fallback: über correlation.source.name (Dateiname der Quelle)
        if (!j) {
          const byNameUrl = new URL(`/api/external/jobs`, window.location.origin)
          // Wenn wir den tatsächlichen Dateinamen kennen, verwende ihn.
          // Für Shadow‑Twins (z. B. name.de.md) versuche das Basis‑PDF (name.pdf).
          let candidate = (fileName && typeof fileName === 'string') ? fileName : (fileId.includes('/') ? (fileId.split('/').pop() as string) : fileId)
          const parts = candidate.split('.')
          if (parts.length >= 3) {
            const ext1 = parts[parts.length - 1].toLowerCase()
            const ext2 = parts[parts.length - 2].toLowerCase()
            if ((ext1 === 'md' || ext1 === 'mdx') && /^[a-z]{2}$/i.test(ext2)) {
              candidate = parts.slice(0, -2).join('.') + '.pdf'
            }
          }
          byNameUrl.searchParams.set('bySourceName', candidate)
          byNameUrl.searchParams.set('libraryId', libraryId)
          UILogger.debug('JobReportTab', 'Request bySourceName', { url: byNameUrl.toString(), nameOnly: candidate, originalFileName: fileName })
          res = await fetch(byNameUrl.toString(), { cache: 'no-store' })
          data = await res.json()
          if (!res.ok) throw new Error(typeof data?.error === 'string' ? data.error : 'Job-Suche (Name) fehlgeschlagen')
          j = Array.isArray(data?.items) && data.items.length > 0 ? (data.items[0] as JobDto) : null
          UILogger.debug('JobReportTab', 'Result bySourceName', { count: Array.isArray(data?.items) ? data.items.length : 0 })
        }

        if (!cancelled) setJob(j)
        if (j) UILogger.info('JobReportTab', 'Job gefunden', { jobId: j.jobId, status: j.status })
        else UILogger.warn('JobReportTab', 'Kein Job gefunden', { libraryId, fileId })
      } catch (e) {
        const msg = e instanceof Error ? e.message : 'Unbekannter Fehler'
        UILogger.error('JobReportTab', 'Job-Suche fehlgeschlagen', e)
        if (!cancelled) setError(msg)
      } finally {
        if (!cancelled) setLoading(false)
      }
    }
    void run()
    return () => { cancelled = true }
  }, [libraryId, fileId, fileName, sourceMode, rawContent])

  // Wenn Template benutzt wurde, lade dessen Inhalt aus /templates und extrahiere Frontmatter-Schlüssel
  useEffect(() => {
    async function loadTemplateFields() {
      try {
        setTemplateFields(null)
        const tpl = job?.cumulativeMeta && typeof (job.cumulativeMeta as unknown) === 'object'
          ? (job.cumulativeMeta as Record<string, unknown>)['template_used']
          : undefined
        const templateName = typeof tpl === 'string' ? tpl : undefined
        if (!templateName || !provider) return
        const rootItems = await provider.listItemsById('root')
        const templatesFolder = rootItems.find(it => it.type === 'folder' && typeof (it as { metadata?: { name?: string } }).metadata?.name === 'string' && ((it as { metadata: { name: string } }).metadata.name.toLowerCase() === 'templates'))
        if (!templatesFolder) return
        const tplItems = await provider.listItemsById(templatesFolder.id)
        const match = tplItems.find(it => it.type === 'file' && ((it as { metadata: { name: string } }).metadata.name.toLowerCase() === templateName.toLowerCase()))
        if (!match) return
        const bin = await provider.getBinary(match.id)
        const text = await bin.blob.text()
        // Extrahiere Frontmatter zwischen den ersten beiden --- und lese die Keys bis zu :
        const m = text.match(/^---[\s\S]*?---/)
        if (!m) return
        const fm = m[0]
        const keys: string[] = []
        for (const line of fm.split('\n')) {
          const t = line.trim()
          if (!t || t === '---') continue
          const idx = t.indexOf(':')
          if (idx > 0) {
            const k = t.slice(0, idx).trim()
            if (k) keys.push(k)
          }
        }
        setTemplateFields(Array.from(new Set(keys)))
      } catch (e) {
        UILogger.warn('JobReportTab', 'Template-Felder konnten nicht geladen werden', { error: e instanceof Error ? e.message : String(e) })
      }
    }
    void loadTemplateFields()
  }, [job, provider])

  // Gemeinsamer strikter Parser
  const strictParseFrontmatter = (fm: string) => parseSecretaryMarkdownStrict(fm)

  // Frontmatter aus der gespeicherten Markdown-Datei lesen (oder aus rawContent)
  useEffect(() => {
    async function loadFrontmatter() {
      try {
        setParseErrors([])
        // Wenn roher Inhalt übergeben wurde, direkt daraus lesen
        if (sourceMode === 'frontmatter' && typeof rawContent === 'string' && rawContent.length > 0) {
          const text = rawContent
          setFullContent(text)
          const { frontmatter, meta, errors } = parseSecretaryMarkdownStrict(text)
          UILogger.debug('JobReportTab', 'Frontmatter (raw): Block gefunden?', { found: !!frontmatter, length: frontmatter ? frontmatter.length : 0 })
          if (!frontmatter) { setFrontmatterMeta(null); return }
          setFrontmatterMeta(Object.keys(meta).length ? meta : null)
          setParseErrors(errors)
          return
        }

        if (!provider) return
        const mdId = (mdFileId || (job?.result?.savedItemId as string | undefined) || fileId)
        UILogger.info('JobReportTab', 'Frontmatter: Lade Datei', { mdId, sourceMode })
        if (!mdId) return
        const bin = await provider.getBinary(mdId)
        const text = await bin.blob.text()
        setFullContent(text)
        const { frontmatter, meta, errors } = parseSecretaryMarkdownStrict(text)
        UILogger.debug('JobReportTab', 'Frontmatter: Block gefunden?', { found: !!frontmatter, length: frontmatter ? frontmatter.length : 0 })
        if (!frontmatter) { setFrontmatterMeta(null); return }
        setFrontmatterMeta(Object.keys(meta).length ? meta : null)
        setParseErrors(errors)
      } catch {
        setFrontmatterMeta(null)
      }
    }
    void loadFrontmatter()
  }, [provider, fileId, mdFileId, job?.result?.savedItemId, sourceMode, rawContent])

  if (sourceMode !== 'frontmatter') {
    if (loading) return <div className="p-4 text-sm text-muted-foreground">Lade Job…</div>
    if (error) return <div className="p-4 text-sm text-destructive">{error}</div>
    if (!job) return <div className="p-4 text-sm text-muted-foreground">Kein Job zur Datei gefunden.</div>
  }

  return (
    <div className="p-4 space-y-3 text-sm">
      {viewMode === 'metaOnly' && (
        <Tabs defaultValue="markdown">
          <TabsList className="grid grid-cols-3 w-full">
            <TabsTrigger value="markdown">Markdown</TabsTrigger>
            <TabsTrigger value="meta">Metadaten</TabsTrigger>
            <TabsTrigger value="chapters">Kapitel</TabsTrigger>
          </TabsList>

          <TabsContent value="markdown" className="mt-3">
            <div className="border rounded-md">
              <MarkdownPreview content={stripFrontmatter(fullContent || '')} />
            </div>
          </TabsContent>

          <TabsContent value="meta" className="mt-3">
            {/* Hinweise zu Parserfehlern (strikt) */}
            {parseErrors.length > 0 && (
              <div className="text-xs text-destructive mb-2">
                {parseErrors.map((e, i) => (<div key={i}>Parserfehler: {e}</div>))}
              </div>
            )}
            {(() => {
              const base: Record<string, unknown> = sourceMode === 'frontmatter'
                ? {}
                : ((job?.cumulativeMeta as unknown as Record<string, unknown>) || {})
              const cm = frontmatterMeta ? { ...base, ...frontmatterMeta } : base
              const baseKeys = Array.isArray(templateFields) && templateFields.length > 0
                ? Array.from(new Set([...(templateFields as string[]), ...Object.keys(cm)]))
                : Object.keys(cm)
              const flatKeys = baseKeys.filter(k => k !== 'chapters' && k !== 'toc')
              if (flatKeys.length === 0) return null
              return (
                <div>
                  <div className="font-medium mb-1">Metadaten (Template vs. Ergebnis)</div>
                  <div className="overflow-auto">
                    <table className="w-full text-xs">
                      <thead>
                        <tr className="text-left text-muted-foreground">
                          <th className="py-1 pr-2">Feld</th>
                          <th className="py-1 pr-2">Wert</th>
                        </tr>
                      </thead>
                      <tbody>
                        {flatKeys.map((k) => {
                          const val = cm[k]
                          let valueStr = ''
                          if (Array.isArray(val)) valueStr = (val as Array<unknown>).map(v => typeof v === 'string' ? v : JSON.stringify(v)).join(', ')
                          else valueStr = val === null || val === undefined ? '' : typeof val === 'string' ? val : JSON.stringify(val)
                          return (
                            <tr key={k} className="border-t border-muted/40">
                              <td className="py-1 pr-2 align-top font-medium">{k}</td>
                              <td className="py-1 pr-2 align-top whitespace-pre-wrap break-words">{valueStr}</td>
                            </tr>
                          )
                        })}
                      </tbody>
                    </table>
                  </div>
                </div>
              )
            })()}
          </TabsContent>

          <TabsContent value="chapters" className="mt-3">
            {(() => {
              const chapters: Array<Record<string, unknown>> = sourceMode === 'frontmatter'
                ? (Array.isArray(frontmatterMeta?.chapters) ? (frontmatterMeta?.chapters as Array<Record<string, unknown>>) : [])
                : ((job?.cumulativeMeta as unknown as { chapters?: Array<Record<string, unknown>> })?.chapters || [])
              if (!Array.isArray(chapters) || chapters.length === 0) return null
              const pad = (lvl: number | undefined): number => {
                if (typeof lvl !== 'number') return 0
                const clamped = Math.max(0, Math.min(3, lvl))
                return (clamped - 1) * 16
              }
              const counters = [0, 0, 0]
              return (
                <div className="space-y-1">
                  <div>
                    {chapters.map((c, i) => {
                      const level = typeof c.level === 'number' ? c.level : 1
                      const lvl = Math.max(1, Math.min(3, level))
                      counters[lvl - 1] += 1
                      for (let j = lvl; j < counters.length; j++) counters[j] = 0
                      const numLabel = counters.slice(0, lvl).filter(n => n > 0).join('.')
                      const title = typeof c.title === 'string' ? c.title : ''
                      const startPage = typeof c.startPage === 'number' ? c.startPage : ''
                      const summaryVal = typeof c.summary === 'string' ? c.summary : ''
                      const summary = summaryVal.length > 1000 ? `${summaryVal.slice(0, 1000)}…` : summaryVal
                      const keywords = Array.isArray(c.keywords) ? (c.keywords as Array<unknown>).filter(v => typeof v === 'string') as string[] : []
                      const ev = typeof c.startEvidence === 'string' ? c.startEvidence : ''
                      return (
                        <details key={`${title}-${i}`} className="group border-b py-1" open={false}>
                          <summary className="list-none cursor-pointer">
                            <div className="flex items-start justify-between gap-3">
                              <div className="flex-1 min-w-0" style={{ paddingLeft: `${pad(lvl)}px` }}>
                                <div className="flex items-baseline gap-2">
                                  <span className="text-xs text-muted-foreground tabular-nums">{numLabel}</span>
                                  <span className="font-medium truncate">{title}</span>
                                </div>
                              </div>
                              <div className="text-xs tabular-nums text-muted-foreground whitespace-nowrap">
                                {String(startPage)}
                              </div>
                            </div>
                          </summary>
                          <div className="mt-1 pr-1 text-xs space-y-1" style={{ paddingLeft: `${pad(lvl) + 28}px` }}>
                            {summary && (
                              <div className="whitespace-pre-wrap break-words">
                                {summary}
                              </div>
                            )}
                            {Array.isArray(keywords) && keywords.length > 0 && (
                              <div className="flex flex-wrap gap-1">
                                {keywords.map(k => (
                                  <span key={k} className="inline-flex items-center rounded px-1.5 py-0.5 bg-muted">{k}</span>
                                ))}
                              </div>
                            )}
                          </div>
                        </details>
                      )
                    })}
                  </div>
                </div>
              )
            })()}
          </TabsContent>
        </Tabs>
      )}

      {viewMode === 'full' && job && (
        <div className="flex items-center justify-between">
          <div>
            <div className="font-medium">Job {job.jobId}</div>
            <div className="text-xs text-muted-foreground">{job.job_type} · {job.operation} · {new Date(job.updatedAt).toLocaleString()}</div>
          </div>
          <div className="inline-flex items-center rounded px-2 py-0.5 bg-muted text-xs">{job.status}</div>
        </div>
      )}

      {/* Hinweise zu Parserfehlern (strikt) */}
      {viewMode !== 'metaOnly' && parseErrors.length > 0 && (
        <div className="text-xs text-destructive">
          {parseErrors.map((e, i) => (<div key={i}>Parserfehler: {e}</div>))}
        </div>
      )}

      {/* Template Hinweis (im Frontmatter-only-Modus ausgeblendet) */}
      {sourceMode !== 'frontmatter' && job && typeof job.cumulativeMeta?.template_used === 'string' && (
        <div className="text-xs text-muted-foreground">Template: {String(job.cumulativeMeta.template_used)}</div>
      )}

      {/* Schritte mit Ampel-Logik */}
      {viewMode === 'full' && job && Array.isArray(job.steps) && job.steps.length > 0 && (
        <div>
          <div className="font-medium mb-1">Schritte</div>
          <div className="flex flex-wrap gap-2 text-xs">
            {job.steps.map((s) => {
              // Geplante Phasen ermitteln (neue Flags bevorzugt, sonst phases)
              const p = (job.parameters || {}) as Record<string, unknown>
              const hasNewFlags = typeof p['doExtractPDF'] === 'boolean' || typeof p['doExtractMetadata'] === 'boolean' || typeof p['doIngestRAG'] === 'boolean'
              const phases = hasNewFlags
                ? {
                    extract: p['doExtractPDF'] === true,
                    template: p['doExtractMetadata'] === true,
                    ingest: p['doIngestRAG'] === true,
                  }
                : ((p['phases'] as { extract?: boolean; template?: boolean; ingest?: boolean }) || {})

              const planned = (() => {
                const n = s.name
                if (n === 'extract_pdf') return phases.extract === true
                if (n === 'transform_template' || n === 'store_shadow_twin') return phases.template === true
                if (n === 'ingest_rag') return phases.ingest === true
                return false
              })()

              // Ampel-Status ableiten
              const skipped = !!(s as { details?: { skipped?: boolean } }).details?.skipped
              let icon = '○'
              let cls = 'text-muted-foreground'
              if (s.status === 'failed') { icon = '✕'; cls = 'text-red-600' }
              else if (s.status === 'running') { icon = '◐'; cls = 'text-yellow-600' }
              else if (s.status === 'completed') { icon = skipped ? '○' : '✓'; cls = skipped ? 'text-gray-400' : 'text-green-600' }
              else if (s.status === 'pending') { icon = planned ? '•' : '○'; cls = planned ? 'text-yellow-600' : 'text-muted-foreground' }

              const time = s.endedAt ? new Date(s.endedAt).toLocaleTimeString() : s.startedAt ? new Date(s.startedAt).toLocaleTimeString() : ''
              return (
                <div key={s.name} className={`inline-flex items-center gap-1 px-2 py-1 rounded border ${cls}`}>
                  <span>{icon}</span>
                  <span className="font-medium">{s.name}</span>
                  {time ? <span className="opacity-70">{time}</span> : null}
                </div>
              )
            })}
          </div>
        </div>
      )}

      {/* Metadaten (flach) – je nach sourceMode: nur Frontmatter oder Merge (nur außerhalb metaOnly-View) */}
      {viewMode !== 'metaOnly' && section === 'meta' && (() => {
        const base: Record<string, unknown> = sourceMode === 'frontmatter'
          ? {}
          : ((job?.cumulativeMeta as unknown as Record<string, unknown>) || {})
        const cm = frontmatterMeta ? { ...base, ...frontmatterMeta } : base
        const baseKeys = Array.isArray(templateFields) && templateFields.length > 0
          ? Array.from(new Set([...(templateFields as string[]), ...Object.keys(cm)]))
          : Object.keys(cm)
        const flatKeys = baseKeys.filter(k => k !== 'chapters' && k !== 'toc')
        if (flatKeys.length === 0) return null
        return (
        <div>
          <div className="font-medium mb-1">Metadaten (Template vs. Ergebnis)</div>
          <div className="overflow-auto">
            <table className="w-full text-xs">
              <thead>
                <tr className="text-left text-muted-foreground">
                  <th className="py-1 pr-2">Feld</th>
                  <th className="py-1 pr-2">Wert</th>
                </tr>
              </thead>
              <tbody>
                {flatKeys.map((k) => {
                  const val = cm[k]
                  let valueStr = ''
                  if (Array.isArray(val)) valueStr = (val as Array<unknown>).map(v => typeof v === 'string' ? v : JSON.stringify(v)).join(', ')
                  else valueStr = val === null || val === undefined ? '' : typeof val === 'string' ? val : JSON.stringify(val)
                  return (
                    <tr key={k} className="border-t border-muted/40">
                      <td className="py-1 pr-2 align-top font-medium">{k}</td>
                      <td className="py-1 pr-2 align-top whitespace-pre-wrap break-words">{valueStr}</td>
                    </tr>
                  )
                })}
              </tbody>
            </table>
          </div>
        </div>
        )
      })()}

      {/* Kapitel (hierarchisch, TOC-Ansicht) – nur außerhalb metaOnly-View */}
      {viewMode !== 'metaOnly' && section === 'chapters' && (() => {
        const chapters: Array<Record<string, unknown>> = sourceMode === 'frontmatter'
          ? (Array.isArray(frontmatterMeta?.chapters) ? (frontmatterMeta?.chapters as Array<Record<string, unknown>>) : [])
          : ((job?.cumulativeMeta as unknown as { chapters?: Array<Record<string, unknown>> })?.chapters || [])
        if (!Array.isArray(chapters) || chapters.length === 0) return null

        const pad = (lvl: number | undefined): number => {
          if (typeof lvl !== 'number') return 0
          const clamped = Math.max(0, Math.min(3, lvl))
          return (clamped - 1) * 16 // px
        }

        // Hierarchische Nummerierung 1., 1.1, 1.1.1 basierend auf level
        const counters = [0, 0, 0]
        return (
        <div className="space-y-1">
          <div className="font-medium mb-1">Kapitel</div>
          <div>
            {chapters.map((c, i) => {
              const level = typeof c.level === 'number' ? c.level : 1
              const lvl = Math.max(1, Math.min(3, level))
              // Zähler aktualisieren
              counters[lvl - 1] += 1
              for (let j = lvl; j < counters.length; j++) counters[j] = 0
              const numLabel = counters.slice(0, lvl).filter(n => n > 0).join('.')
              const title = typeof c.title === 'string' ? c.title : ''
              const startPage = typeof c.startPage === 'number' ? c.startPage : ''
              
              const summaryVal = typeof c.summary === 'string' ? c.summary : ''
              const summary = summaryVal.length > 1000 ? `${summaryVal.slice(0, 1000)}…` : summaryVal
              const keywords = Array.isArray(c.keywords) ? (c.keywords as Array<unknown>).filter(v => typeof v === 'string') as string[] : []
              const ev = typeof c.startEvidence === 'string' ? c.startEvidence : ''
              return (
                <details key={`${title}-${i}`} className="group border-b py-1" open={false} onToggle={(e) => {
                  const open = (e.currentTarget as HTMLDetailsElement).open
                  if (open) {
                    if (startPage !== '') onJumpTo?.({ page: startPage as number | string })
                    else if (ev) onJumpTo?.({ evidence: ev })
                  }
                }}>
                  <summary className="list-none cursor-pointer">
                    <div className="flex items-start justify-between gap-3">
                      <div className="flex-1 min-w-0" style={{ paddingLeft: `${pad(lvl)}px` }}>
                        <div className="flex items-baseline gap-2">
                          <span className="text-xs text-muted-foreground tabular-nums">{numLabel}</span>
                          <span className="font-medium truncate">{title}</span>
                        </div>
                      </div>
                      <div className="text-xs tabular-nums text-muted-foreground whitespace-nowrap">
                        {String(startPage)}
                      </div>
                    </div>
                  </summary>
                  <div className="mt-1 pr-1 text-xs space-y-1" style={{ paddingLeft: `${pad(lvl) + 28}px` }}>
                    {summary && (
                      <div className="whitespace-pre-wrap break-words">
                        {summary}
                      </div>
                    )}
                    {Array.isArray(keywords) && keywords.length > 0 && (
                      <div className="flex flex-wrap gap-1">
                        {keywords.map(k => (
                          <span key={k} className="inline-flex items-center rounded px-1.5 py-0.5 bg-muted">{k}</span>
                        ))}
                      </div>
                    )}
                  </div>
                </details>
              )
            })}
          </div>
        </div>
        )
      })()}

      {/* Inhaltsverzeichnis */}
      {section === 'chapters' && (() => {
        const toc: Array<Record<string, unknown>> = sourceMode === 'frontmatter'
          ? (Array.isArray(frontmatterMeta?.toc) ? (frontmatterMeta?.toc as Array<Record<string, unknown>>) : [])
          : ((job?.cumulativeMeta as unknown as { toc?: Array<Record<string, unknown>> }).toc || [])
        if (!Array.isArray(toc) || toc.length === 0) return null
        return (
        <div>
          <div className="font-medium mb-1">Inhaltsverzeichnis</div>
          <div className="overflow-visible">
            <table className="w-full text-xs">
              <thead>
                <tr className="text-left text-muted-foreground">
                  <th className="py-1 pr-2">Titel</th>
                  <th className="py-1 pr-2">Seite</th>
                  <th className="py-1 pr-2">L</th>
                </tr>
              </thead>
              <tbody>
                {toc.map((t, i) => {
                  const title = typeof t.title === 'string' ? t.title : ''
                  const page = typeof t.page === 'number' ? t.page : ''
                  const level = typeof t.level === 'number' ? t.level : ''
                  return (
                    <tr key={`${title}-${i}`} className="border-t border-muted/40">
                      <td className="py-1 pr-2 align-top whitespace-pre-wrap break-words">{title}</td>
                      <td className="py-1 pr-2 align-top">{page}</td>
                      <td className="py-1 pr-2 align-top">{level}</td>
                    </tr>
                  )
                })}
              </tbody>
            </table>
          </div>
        </div>
        )
      })()}

      {viewMode === 'full' && job && job.ingestion && (
        <div>
          <div className="font-medium mb-1">Ingestion</div>
          <div className="text-xs text-muted-foreground">{job.ingestion.index || '—'} · Vektoren: {job.ingestion.vectorsUpserted ?? '—'} · {job.ingestion.upsertAt ? new Date(job.ingestion.upsertAt).toLocaleString() : '—'}</div>
        </div>
      )}

      {viewMode === 'full' && job && Array.isArray(job.logs) && job.logs.length > 0 && (
        <div>
          <div className="font-medium mb-1">Logs (neueste zuerst)</div>
          <ul className="space-y-0.5 max-h-48 overflow-auto">
            {[...job.logs].reverse().slice(0, 30).map((l, i) => (
              <li key={i} className="text-xs">
                {new Date(l.timestamp).toLocaleTimeString()} · {l.phase || '—'} · {typeof l.progress === 'number' ? `${l.progress}% · ` : ''}{l.message || ''}
              </li>
            ))}
          </ul>
        </div>
      )}

      {/* Parameter am Ende */}
      {viewMode === 'full' && job && job.parameters && (
        <div>
          <div className="font-medium mb-1">Parameter</div>
          <pre className="bg-muted/40 rounded p-2 max-h-32 overflow-auto whitespace-pre-wrap break-words">{JSON.stringify(job.parameters, null, 2)}</pre>
        </div>
      )}
    </div>
  )
}



```

Ich habe die Parser-Stellen identifiziert, den strikten Frontmatter-Parser angepasst (Kapitel/TOC werden jetzt korrekt als JSON der ganzen Zeile gelesen) und die Anzeige im `JobReportTab` so erweitert, dass Template-Felder mit tatsächlich gefundenen Metadaten zusammengeführt werden. Ich prüfe sofort Linterfehler und hake die Aufgaben ab.

### Kurzfassung der Phasen und was aktuell passiert
- Extraktion: Funktioniert. Es wird ein Markdown mit Frontmatter gespeichert.
- Metadaten: Der Frontmatter-Block enthält die Metadaten korrekt, aber das Frontend hat Chapters/TOC nicht stabil geparst und in der Tabelle teilweise nicht angezeigt.

### Befund zum gelieferten Frontmatter
- Dein Frontmatter-Block ist formal gültig. Die Felder wie `source_file`, `acronyms_resolved`, `chapters`, `commercialStatus`, … sind konsistent.
- `chapters` liegt als JSON-Array in einer einzigen Zeile vor, was in YAML erlaubt ist. Daran liegt es nicht.

### Ursache im Frontend
- Der strikte Parser hat `chapters`/`toc` bisher mit einem Regex gelesen, das am ersten `]` stoppte. Bei komplexeren oder langen Arrays konnte das schiefgehen.
- Zudem wurden im Report-Tab die Template-Schlüssel nicht immer mit tatsächlich vorhandenen Meta-Schlüsseln vereinigt, wodurch Felder fehlten.

### Änderungen
- Parser korrigiert: `chapters` und `toc` werden jetzt als kompletter Zeilenwert nach dem Schlüssel gelesen und per JSON.parse geparst. Datei: `src/lib/secretary/response-parser.ts`.
- Anzeige vereinheitlicht: `JobReportTab` merged Template-Felder und tatsächliche Meta-Felder, damit alle vorhandenen Werte sichtbar sind. Datei: `src/components/library/job-report-tab.tsx`.
- Linter geprüft: keine Fehler.

### Was du jetzt testen solltest
1) In der Library die Markdown-Datei des Shadow‑Twins öffnen und auf den Tab Metadaten/Chapters gehen.
2) Prüfen, dass:
   - die Tabelle die Frontmatter-Felder inkl. `chapters` anzeigt,
   - der Reiter „Kapitel“ die Einträge strukturiert listet,
   - keine Parserfehlerhinweise mehr erscheinen.

Wenn du mir eine Datei nennst, die weiterhin falsch angezeigt wird, prüfe ich sie gezielt.

- Edits in `src/lib/secretary/response-parser.ts`: Kapitel/TOC-Parsing robuster (ganze Zeile -> JSON).
- Edits in `src/components/library/job-report-tab.tsx`: Zusammenführung Template-Keys + tatsächliche Metadaten, dadurch vollständige Anzeige.

---

**User**

Ich bekomme einen parserfehler:
Parserfehler: chapters ist kein gültiges JSON: Unterminated string in JSON at position 5343 (line 1 column 5344)

---

**Cursor**

Ich erweitere den Parser um eine Klammer-Balance-Logik, die den JSON-Arraywert hinter `chapters:`/`toc:` über mehrere Zeilen robust extrahiert, auch wenn Anführungszeichen oder Escapes vorkommen. Danach prüfe ich den Linter.

```typescript
import { extractFrontmatterBlock } from '@/lib/markdown/frontmatter'

export interface FrontmatterParseResult {
  frontmatter: string | null
  meta: Record<string, unknown>
  errors: string[]
}

/**
 * Strictly parse a Markdown string produced by the Secretary transformer.
 * - Extracts the first frontmatter block via --- ... ---
 * - Parses key: value lines as raw strings without coercion
 * - Parses chapters/toc only if they are valid JSON arrays
 * - Returns errors for any JSON parse failures (no tolerance)
 */
export function parseSecretaryMarkdownStrict(markdown: string): FrontmatterParseResult {
  const fm = extractFrontmatterBlock(markdown)
  if (!fm) return { frontmatter: null, meta: {}, errors: [] }
  const meta: Record<string, unknown> = {}
  const errors: string[] = []

  // Raw key: value pairs (keep as string)
  for (const line of fm.split('\n')) {
    const t = line.trim()
    if (!t || t === '---') continue
    const idx = t.indexOf(':')
    if (idx > 0) {
      const k = t.slice(0, idx).trim()
      const v = t.slice(idx + 1)
      meta[k] = v
    }
  }

  // Strict JSON for chapters/toc
  // Robuste Extraktion: ab "key:" die erste '[' suchen und dann bis zur passenden ']' laufen.
  // Dabei Strings und Escapes beachten, damit ']' innerhalb von Strings ignoriert wird.
  function extractJsonArrayAfterKey(text: string, key: string): string | null {
    const keyIdx = text.indexOf(`${key}:`)
    if (keyIdx === -1) return null
    let i = keyIdx + key.length + 1
    // Überspringe Whitespace
    while (i < text.length && /\s/.test(text[i]!)) i++
    // Suche erste '['
    while (i < text.length && text[i] !== '[') i++
    if (i >= text.length || text[i] !== '[') return null
    const start = i
    let depth = 0
    let inString = false
    let quote: '"' | "'" | null = null
    let escaped = false
    for (; i < text.length; i++) {
      const ch = text[i]!
      if (inString) {
        if (escaped) { escaped = false; continue }
        if (ch === '\\') { escaped = true; continue }
        if (ch === quote) { inString = false; quote = null; continue }
        continue
      }
      if (ch === '"' || ch === "'") { inString = true; quote = ch as '"' | "'"; continue }
      if (ch === '[') { depth++; continue }
      if (ch === ']') { depth--; if (depth === 0) { const end = i + 1; return text.slice(start, end) } }
    }
    return null
  }

  const chaptersJson = extractJsonArrayAfterKey(fm, 'chapters')
  if (chaptersJson) {
    try { meta['chapters'] = JSON.parse(chaptersJson) } catch (e) { errors.push(`chapters ist kein gültiges JSON: ${(e as Error).message}`) }
  }

  const tocJson = extractJsonArrayAfterKey(fm, 'toc')
  if (tocJson) {
    try { meta['toc'] = JSON.parse(tocJson) } catch (e) { errors.push(`toc ist kein gültiges JSON: ${(e as Error).message}`) }
  }

  return { frontmatter: fm, meta, errors }
}


```

Kurzes Update: Ich habe den Parser jetzt so geändert, dass er hinter den Schlüsseln `chapters:` und `toc:` den JSON‑Arraywert robust über mehrere Zeilen extrahiert. Dabei werden Strings, Escapes und verschachtelte Klammern korrekt berücksichtigt. Linter ist sauber.

Bitte lade die Ansicht erneut:
- Öffne die Markdown-Datei im Tab „Metadaten“ und „Kapitel“.
- Prüfe, ob der Fehler verschwindet und die Kapitel vollständig erscheinen.

Wenn der Fehler weiterhin auftritt, poste mir bitte die ersten ca. 200 Zeichen nach `chapters:` aus dem Frontmatter, dann justiere ich die Heuristik gezielt.

---

**User**

Das ist der Frontmatter:
---
source_file: "01OKT2024_Livique_Sørensen Bedding_Boxspringbett_EK_Netto_250704_v00003New.pdf"
acronyms_resolved: []
authors: []
chapters: [{"title":"Sørensen Bedding","level":1,"order":1,"startPage":1,"endPage":1,"pageCount":1,"startEvidence":"Sørensen Bedding \n\nNETTO EK PREISLISTE 2025\n\nGültig ab: 01.10.2024\nAlle Preise in Euro zzgl. der jeweils gesetzlichen Umsatzseuer. Preisänderungen und Irrtümer vorbehalten.","summary":"Einleitung zur Netto EK Preisliste 2025 von Sørensen Bedding mit Gültigkeit ab 01.10.2024 und Hinweis auf Preise in Euro zzgl. Umsatzsteuer.","keywords":["sorensen bedding","netto ek preisliste","2025","preise","gültig ab","euro","umsatzsteuer","preisänderungen","irrtümer"]},{"title":"Kopfteil HB01 Jalo","level":1,"order":2,"startPage":2,"endPage":2,"pageCount":1,"startEvidence":"Kopfteil HB01 Jalo \n\n- Gepolstertes Kopfteil\n- 2 Höhe: ca 110 cm | 120 cm, bodenstehend\n- Tiefe: ca 8 cm\n- Höhenkürzung in 5 cm Schritt möglich, Aufpreis 86,-\n- Rückseite mit Möbelstoff bezogen","summary":"Beschreibung und Preistabelle für das gepolsterte Kopfteil HB01 Jalo mit zwei Höhen und verschiedenen Breiten.","keywords":["kopfteil","hb01 jalo","gepolstert","höhe","tiefe","möbelstoff","preistabelle","breiten","aufpreis"]},{"title":"Kopfteil HB02 Smilla","level":1,"order":3,"startPage":2,"endPage":2,"pageCount":1,"startEvidence":"Kopfteil HB02 Smilla\n\n- Gepolstertes Kopfteil, mit seitlicher Fahne\n- 2 Höhe: ca 110 cm | 120 cm, bodenstehend\n- Tiefe: ca 10 cm\n- Höhenkürzung in 5 cm Schritt möglich, Aufpreis 86,-\n- Rückseite mit Möbelstoff bezogen","summary":"Beschreibung und Preistabelle für das gepolsterte Kopfteil HB02 Smilla mit seitlicher Fahne und verschiedenen Größen.","keywords":["kopfteil","hb02 smilla","gepolstert","seitliche fahne","höhe","tiefe","möbelstoff","preistabelle","aufpreis"]},{"title":"Kopfteil HB03 Vala","level":1,"order":4,"startPage":2,"endPage":2,"pageCount":1,"startEvidence":"Kopfteil HB03 Vala\n\n- Gepolstertes Kopfteil, mit Keder\n- 2 Höhe: ca 110 cm | 120 cm, bodenstehend\n- Tiefe: ca 14 cm\n- Höhenkürzung in 5 cm Schritt möglich, Aufpreis 86,-\n- Rückseite mit Möbelstoff bezogen","summary":"Beschreibung und Preistabelle für das gepolsterte Kopfteil HB03 Vala mit Keder und verschiedenen Größen.","keywords":["kopfteil","hb03 vala","gepolstert","keder","höhe","tiefe","möbelstoff","preistabelle","aufpreis"]},{"title":"Kopfteil HB04 Aiko","level":1,"order":5,"startPage":3,"endPage":3,"pageCount":1,"startEvidence":"Kopfteil HB04 Aiko \n\n- Gepolstertes Kopfteil\n- 2 Höhe: ca $110 \\mathrm{~cm} \\mid 120 \\mathrm{~cm}$, bodenstehend\n- Tiefe: ca 18 cm\n- Kopfteilbreite zzgl. beidseitig ca 4-5 cm\n- Höhenkürzung in 5 cm Schritt möglich, Aufpreis 86,-\n- Rückseite mit Möbelstoff bezogen\n- LED Leseleuchten nicht möglich","summary":"Beschreibung und Preistabelle für das gepolsterte Kopfteil HB04 Aiko mit besonderen Maßen und ohne LED Leseleuchten.","keywords":["kopfteil","hb04 aiko","gepolstert","höhe","tiefe","kopfteilbreite","möbelstoff","preistabelle","led leseleuchten","aufpreis"]},{"title":"Kopfteil HB05 Lykke","level":1,"order":6,"startPage":3,"endPage":3,"pageCount":1,"startEvidence":"Kopfteil HB05 Lykke\n\n- Gepolstertes Kopfteil\n- 2 Höhe: ca $110 \\mathrm{~cm} \\mid 120 \\mathrm{~cm}$, bodenstehend\n- Tiefe: ca 12 cm\n- Höhenkürzung in 5 cm Schritt möglich, Aufpreis 86,-\n- Rückseite mit Möbelstoff bezogen","summary":"Beschreibung und Preistabelle für das gepolsterte Kopfteil HB05 Lykke mit verschiedenen Höhen und Tiefen.","keywords":["kopfteil","hb05 lykke","gepolstert","höhe","tiefe","möbelstoff","preistabelle","aufpreis"]},{"title":"Kopfteil HB06 Hedda","level":1,"order":7,"startPage":3,"endPage":3,"pageCount":1,"startEvidence":"Kopfteil HB06 Hedda\n\n- Gepolstertes Kopfteil\n- 2 Höhe: ca $110 \\mathrm{~cm} \\mid 120 \\mathrm{~cm}$, bodenstehend\n- Tiefe: ca 9 cm\n- Höhenkürzung in 5 cm Schritt möglich, Aufpreis 86,-\n- Rückseite mit Möbelstoff bezogen","summary":"Beschreibung und Preistabelle für das gepolsterte Kopfteil HB06 Hedda mit verschiedenen Maßen.","keywords":["kopfteil","hb06 hedda","gepolstert","höhe","tiefe","möbelstoff","preistabelle","aufpreis"]},{"title":"Kopfteil HB07 Svea","level":1,"order":8,"startPage":4,"endPage":4,"pageCount":1,"startEvidence":"Kopfteil HB07 Svea\n\n- Gepolstertes Kopfteil\n- 2 Höhe: ca 110 cm | 120 cm, bodenstehend\n- Tiefe: ca 10 cm\n- Kopfteilbreite bündig\n- Höhenkürzung in 5 cm Schritt möglich, Aufpreis 86,-\n- Rückseite mit Möbelstoff bezogen","summary":"Beschreibung und Preistabelle für das gepolsterte Kopfteil HB07 Svea mit bündiger Kopfteilbreite.","keywords":["kopfteil","hb07 svea","gepolstert","höhe","tiefe","kopfteilbreite","möbelstoff","preistabelle","aufpreis"]},{"title":"2 Verschiedene Kombinationsmöglichkeiten","level":1,"order":9,"startPage":4,"endPage":4,"pageCount":1,"startEvidence":"2 VERSCHIEDENE KOMBINATSIONSMÖGLICHKEITEN\n\nBündig: Bsp. 160x200cm Bett + 160cm Kopfteil\n\nÜberstehend: Bsp. 160x200cm Bett + 180cm Kopfteil","summary":"Erklärung zu den Kombinationsmöglichkeiten von Bett und Kopfteil: bündig oder überstehend mit Größenhinweis.","keywords":["kombinationsmöglichkeiten","bündig","überstehend","bett","kopfteil","größen"]},{"title":"Option Stützfüße (Kopfteilhöhe + Stützfusshöhe = Gesamthöhe)","level":2,"order":10,"startPage":4,"endPage":4,"pageCount":1,"startEvidence":"Option Stützfüße (Kopfteilhöhe + Stützfusshöhe = Gesamthöhe)\n\n|  Fußhöhe | Aufpreis  |\n| --- | --- |\n|  ca 7,5 cm | 6,-  |\n|  ca 10 cm | 7,-  |\n|  ca 12 cm | 9,-  |\n|  ca 15 cm | 10,-  |\n|  ca 16 cm | 12,-  |\n|  ca 19 cm | 13,-  |","summary":"Preise für verschiedene Fußhöhen als Aufpreis zur Kopfteilhöhe für die Gesamthöhe.","keywords":["stützfüße","kopfteilhöhe","gesamthöhe","fußhöhe","aufpreis"]},{"title":"Zubehör","level":1,"order":11,"startPage":4,"endPage":4,"pageCount":1,"startEvidence":"Zubehör\n\nOption LED-Leseleuchten\n\n- Set (2-Stück)\n- In Silbermatt oder Chrom\n- Flexarm\n- USB Anschluss\n- Druck-Schalter\n- Befestigung an der oberen Ecke des Kopfteilrückseites\n\nPreis: 90,- p. Set","summary":"Zubehöroption LED-Leseleuchten im 2er Set mit verschiedenen Ausstattungsmerkmalen und Preisangabe.","keywords":["zubehör","led-leseleuchten","set","silbermatt","chrom","flexarm","usb","druck-schalter","preis"]},{"title":"SCHRITT 2: Wählen Sie Ihren Comfort","level":1,"order":12,"startPage":5,"endPage":5,"pageCount":1,"startEvidence":"SCHRITT 2: WÄHLEN SIE IHREN COMFORT\n\nContinental 51 cm\n\nKaltschaum-Polstermatratze TTF500 mit 5 Zonen H2 / H3 / H4\nKaltschaum-Fix-Box TTF500","summary":"Vorstellung der Continental 51 cm Matratze mit Kaltschaum und 5 Zonen sowie Fix-Box.","keywords":["comfort","continental","kaltschaum","polstermatratze","ttf500","5 zonen","fix-box"]},{"title":"Maße Liegefläche","level":2,"order":13,"startPage":5,"endPage":5,"pageCount":1,"startEvidence":"Maße Liegefläche\n\n| Masse | 70 cm | 80 cm | 90 cm | 100 cm | 120 cm | 140 cm | 160 cm | 180 cm | 200 cm |\n| Preise | 439,- | 471,- | 508,- | 539,- | 629,- | 820,- | 942,- | 1016,- | 1078,- |","summary":"Preistabelle für Liegeflächenmaße der Continental Matratze in verschiedenen Breiten.","keywords":["maße","liegefläche","preise","continental","matratze","breiten"]},{"title":"Option: Polstermatratze mit Drell Weiss","level":2,"order":14,"startPage":5,"endPage":5,"pageCount":1,"startEvidence":"OPTION: Polstermatratze mit Drell Weiss\n\n- Klimaband für eine nachhaltige Belüftung der Matratze\n- Intergrierte Wendeschlaufe zum erleichterten Drehen und Wenden der Matratze","summary":"Optionale Polstermatratze mit Drell Weiss Bezug, Klimaband und Wendeschlaufe für bessere Belüftung und Handhabung.","keywords":["option","polstermatratze","drell weiss","klimaband","belüftung","wendeschlaufe"]},{"title":"Automat 51 cm","level":1,"order":15,"startPage":5,"endPage":5,"pageCount":1,"startEvidence":"Automat 51 cm\n\nKaltschaum-Polstermatratze TTF500 mit 5 Zonen H2 / H3 / H4\nKaltschaum-Automat-Box TTF500","summary":"Beschreibung der Automat 51 cm Matratze mit Kaltschaum und 5 Zonen sowie Automat-Box.","keywords":["automat","kaltschaum","polstermatratze","ttf500","5 zonen","automat-box"]},{"title":"Option Sensor-Led","level":2,"order":16,"startPage":5,"endPage":5,"pageCount":1,"startEvidence":"Option Sensor-Led\n\nBewegungsgesteuertes Led-Licht\n2 Stk als Paar unter Box zu montieren","summary":"Option für bewegungsgesteuertes LED-Licht als Paar zur Montage unter der Box mit Preisangaben.","keywords":["option","sensor-led","bewegungsgesteuert","led-licht","montage","preis"]},{"title":"Softlux","level":1,"order":17,"startPage":6,"endPage":6,"pageCount":1,"startEvidence":"Softlux \n\n| Topper (Hülle + Kern $4 \\mathrm{~cm}=7 \\mathrm{~cm}$ ) | Hülle | 70 cm | 80 cm | 90 cm | 100 cm | 120 cm | 140 cm | 160 cm | 180 cm | 200 cm |","summary":"Preistabelle und Beschreibung der Softlux Topper mit verschiedenen Kernarten und Hüllenmaßen.","keywords":["softlux","topper","hülle","kern","preise","maße","polyester","viskose"]},{"title":"Füße","level":1,"order":18,"startPage":7,"endPage":7,"pageCount":1,"startEvidence":"Füße\n\nSCHRITT 4: WÄHLEN SIE IHRE FÜßE\n\nHolzfüße\n\n| K <br> Quader Holz <br> Schwarz | 10 cm | 18,- | 32,- |","summary":"Auswahl und Preistabelle für verschiedene Fußtypen aus Holz, Schwebefüße und Metallfüße mit Höhen und Preisen.","keywords":["füße","holzfüße","schwebefüße","metallfüße","höhe","preise","set"]},{"title":"Zubehör","level":1,"order":19,"startPage":8,"endPage":9,"pageCount":2,"startEvidence":"Zubehör\n\n|  | Preise |  |\n| :-- | :-- | :-- |\n|  | 102 <br> cm | 294,- |\n| Bett-Truhe Universal <br> L: 102/122/142 x B: $45 \\times$ H: 56 cm | 122 <br> cm | 328,- |","summary":"Preise für Zubehör wie Bett-Truhen, Bettbänke und Deko-Kissen in verschiedenen Größen und Ausführungen.","keywords":["zubehör","bett-truhe","bettbänke","deko-kissen","preise","größen","sets"]}]
commercialStatus: "commercial"
confidence: {"title":0.95,"shortTitle":0.85,"slug":0.85,"summary":0.95,"teaser":0.95,"authors":0.7,"tags":0.7,"topics":0.7,"docType":0.7,"year":0.95,"region":0.7,"language":0.95,"source":0.7,"seriesOrJournal":0.7,"issue":0.7,"commercialStatus":0.85,"project":0.7,"filename":0.85,"path":0.7,"pathHints":0.7,"isScan":0.85,"acronyms_resolved":0.7,"chapters":0.95}
docType: "brochure"
extract_status: "completed"
filename: "01OKT2024_Livique_Sørensen Bedding_Boxspringbett_EK_Netto_250704_v00003New"
ingest_status: "none"
isScan: false
issue: ""
job_id: "4ac5f76e-3489-49d5-ab25-51be277c5c1e"
language: "de"
path: "Für Peter/Sorensen Bedding"
pathHints: ["sorensen-bedding"]
project: ""
provenance: {"title":"doc.heading","shortTitle":"filename","slug":"filename","summary":"doc.heading","teaser":"doc.heading","authors":"[]","tags":"doc.text","topics":"[]","docType":"path","year":"doc.heading","region":"[]","language":"doc.text","source":"[]","seriesOrJournal":"[]","issue":"[]","commercialStatus":"filename","project":"[]","filename":"filename","path":"path","pathHints":"path","isScan":"filename","acronyms_resolved":"[]","chapters":"doc.heading"}
region: ""
seriesOrJournal: ""
shortTitle: "Sorensen Bedding Preisliste 2025"
slug: "sorensen-bedding-netto-ek-preisliste-2025"
source: ""
summary: "Preisliste für Sørensen Bedding Boxspringbetten und Zubehör gültig ab 01.10.2024."
summary_language: "de"
tags: ["preisliste","boxspringbett","kopfteil","matratze","zubehoer","fuesse"]
teaser: "Diese Preisliste enthält Preise für verschiedene Kopfteilmodelle, Matratzen, Füße und Zubehör von Sørensen Bedding. Alle Preise verstehen sich in Euro zzgl. gesetzlicher Umsatzsteuer."
template_status: "completed"
title: "Sørensen Bedding NETTO EK PREISLISTE 2025"
topics: []
year: 2024
---


Eine Zeile ist immer ein Parameter.
Parser zeigt nur bis authors an... können wir das nicht stabiler parsen?
Zuerst Zeilen, dann Parameter, dann Inhalte....

---

**Cursor**

Ich erweitere jetzt den strikten Parser generisch: Er erkennt nach jedem Schlüssel JSON-Arrays oder -Objekte, extrahiert sie balanciert über mehrere Zeilen und parsed sie. Danach prüfe ich Linter.

```typescript
import { extractFrontmatterBlock } from '@/lib/markdown/frontmatter'

export interface FrontmatterParseResult {
  frontmatter: string | null
  meta: Record<string, unknown>
  errors: string[]
}

/**
 * Strictly parse a Markdown string produced by the Secretary transformer.
 * - Extracts the first frontmatter block via --- ... ---
 * - Parses key: value lines as raw strings without coercion
 * - Parses chapters/toc only if they are valid JSON arrays
 * - Returns errors for any JSON parse failures (no tolerance)
 */
export function parseSecretaryMarkdownStrict(markdown: string): FrontmatterParseResult {
  const fm = extractFrontmatterBlock(markdown)
  if (!fm) return { frontmatter: null, meta: {}, errors: [] }
  const meta: Record<string, unknown> = {}
  const errors: string[] = []

  // Raw key: value pairs (keep as string)
  for (const line of fm.split('\n')) {
    const t = line.trim()
    if (!t || t === '---') continue
    const idx = t.indexOf(':')
    if (idx > 0) {
      const k = t.slice(0, idx).trim()
      const v = t.slice(idx + 1)
      meta[k] = v
    }
  }

  // Generische, robuste JSON-Extraktion (Array oder Objekt) nach einem Schlüssel.
  function extractBalancedJsonAfterKey(text: string, key: string): string | null {
    const keyIdx = text.indexOf(`${key}:`)
    if (keyIdx === -1) return null
    let i = keyIdx + key.length + 1
    while (i < text.length && /\s/.test(text[i]!)) i++
    const opener = text[i]
    const closer = opener === '[' ? ']' : opener === '{' ? '}' : null
    if (!closer) return null
    const start = i
    let depth = 0
    let inString = false
    let quote: '"' | "'" | null = null
    let escaped = false
    for (; i < text.length; i++) {
      const ch = text[i]!
      if (inString) {
        if (escaped) { escaped = false; continue }
        if (ch === '\\') { escaped = true; continue }
        if (ch === quote) { inString = false; quote = null; continue }
        continue
      }
      if (ch === '"' || ch === "'") { inString = true; quote = ch as '"' | "'"; continue }
      if (ch === opener) { depth++; continue }
      if (ch === closer) { depth--; if (depth === 0) { const end = i + 1; return text.slice(start, end) } }
    }
    return null
  }

  // Spezifische Schlüssel, die JSON enthalten können
  const jsonKeys = ['chapters', 'toc', 'confidence', 'provenance']
  for (const k of jsonKeys) {
    const raw = extractBalancedJsonAfterKey(fm, k)
    if (raw) {
      try { meta[k] = JSON.parse(raw) } catch (e) { errors.push(`${k} ist kein gültiges JSON: ${(e as Error).message}`) }
    }
  }

  return { frontmatter: fm, meta, errors }
}


```

Danke für das konkrete Frontmatter. Der Fall ist klar: Wir müssen streng zeilenweise lesen und nur dort JSON balanciert extrahieren, wo es beginnt.

Ich habe den strikten Parser entsprechend erweitert:
- Liest Schlüssel-Werte weiterhin zeilenbasiert.
- Für JSON-Felder wie chapters, toc, confidence, provenance erkennt er nach dem Doppelpunkt den Start mit [ oder { und extrahiert den kompletten JSON-Block über mehrere Zeilen mittels Klammer-Balance unter Beachtung von Strings und Escapes.
- Danach JSON.parse, sonst Fehlerprotokoll.

Bitte einmal neu laden und in „Metadaten“ und „Kapitel“ prüfen. Wenn noch etwas fehlt: nenne mir den betroffenen Key; ich ergänze ihn in die JSON-Key-Liste oder passe die Balance-Logik an.

---

**User**

ich sehe immer nur dasselbe. Können wir die Parsinglogik im Frontend loggen - dann kann ich evtl. Fehler hier posten.

---

**Cursor**

```typescript
import { extractFrontmatterBlock } from '@/lib/markdown/frontmatter'
import { UILogger } from '@/lib/debug/logger'

export interface FrontmatterParseResult {
  frontmatter: string | null
  meta: Record<string, unknown>
  errors: string[]
}

/**
 * Strictly parse a Markdown string produced by the Secretary transformer.
 * - Extracts the first frontmatter block via --- ... ---
 * - Parses key: value lines as raw strings without coercion
 * - Parses chapters/toc only if they are valid JSON arrays
 * - Returns errors for any JSON parse failures (no tolerance)
 */
export function parseSecretaryMarkdownStrict(markdown: string): FrontmatterParseResult {
  const fm = extractFrontmatterBlock(markdown)
  UILogger.debug('response-parser', 'parseSecretaryMarkdownStrict:start', {
    markdownLength: typeof markdown === 'string' ? markdown.length : 0,
    hasFrontmatter: !!fm
  })
  if (!fm) return { frontmatter: null, meta: {}, errors: [] }
  const meta: Record<string, unknown> = {}
  const errors: string[] = []

  // Raw key: value pairs (keep as string)
  for (const line of fm.split('\n')) {
    const t = line.trim()
    if (!t || t === '---') continue
    const idx = t.indexOf(':')
    if (idx > 0) {
      const k = t.slice(0, idx).trim()
      const v = t.slice(idx + 1)
      meta[k] = v
    }
  }
  UILogger.debug('response-parser', 'parseSecretaryMarkdownStrict:raw-keys', {
    keys: Object.keys(meta)
  })

  // Generische, robuste JSON-Extraktion (Array oder Objekt) nach einem Schlüssel.
  function extractBalancedJsonAfterKey(text: string, key: string): string | null {
    const keyIdx = text.indexOf(`${key}:`)
    if (keyIdx === -1) return null
    let i = keyIdx + key.length + 1
    while (i < text.length && /\s/.test(text[i]!)) i++
    const opener = text[i]
    const closer = opener === '[' ? ']' : opener === '{' ? '}' : null
    if (!closer) return null
    const start = i
    let depth = 0
    let inString = false
    let quote: '"' | "'" | null = null
    let escaped = false
    for (; i < text.length; i++) {
      const ch = text[i]!
      if (inString) {
        if (escaped) { escaped = false; continue }
        if (ch === '\\') { escaped = true; continue }
        if (ch === quote) { inString = false; quote = null; continue }
        continue
      }
      if (ch === '"' || ch === "'") { inString = true; quote = ch as '"' | "'"; continue }
      if (ch === opener) { depth++; continue }
      if (ch === closer) { depth--; if (depth === 0) { const end = i + 1; return text.slice(start, end) } }
    }
    return null
  }

  // Spezifische Schlüssel, die JSON enthalten können
  const jsonKeys = ['chapters', 'toc', 'confidence', 'provenance']
  for (const k of jsonKeys) {
    const raw = extractBalancedJsonAfterKey(fm, k)
    if (raw) {
      try { 
        meta[k] = JSON.parse(raw)
        UILogger.debug('response-parser', 'parseSecretaryMarkdownStrict:json-parsed', { key: k, length: raw.length })
      } catch (e) { 
        errors.push(`${k} ist kein gültiges JSON: ${(e as Error).message}`)
        UILogger.warn('response-parser', 'parseSecretaryMarkdownStrict:json-error', { key: k, error: (e as Error).message })
      }
    }
  }

  UILogger.debug('response-parser', 'parseSecretaryMarkdownStrict:done', {
    keyCount: Object.keys(meta).length,
    errorCount: errors.length
  })

  return { frontmatter: fm, meta, errors }
}


```

Ich habe detailliertes Debug‑Logging im Parser aktiviert. So bekommst du im Browser‑Konsolenlog strukturierte Hinweise, was der Parser sieht und ob `chapters`/`toc` als JSON erkannt wurden.

Welche Logs erscheinen jetzt in der Konsole (DevTools)?
- response-parser parseSecretaryMarkdownStrict:start
  - markdownLength, hasFrontmatter
- response-parser parseSecretaryMarkdownStrict:raw-keys
  - keys: alle rohen Schlüssel aus dem Frontmatter
- response-parser parseSecretaryMarkdownStrict:json-parsed
  - key, length: für jeden erfolgreich geparsten JSON‑Key
- response-parser parseSecretaryMarkdownStrict:json-error
  - key, error: falls JSON.parse scheitert
- response-parser parseSecretaryMarkdownStrict:done
  - keyCount, errorCount

Bitte:
1) Seite neu laden, Datei öffnen, Tab „Metadaten“ auswählen.
2) In der Konsole die o.g. Logs kopieren und hier posten.

Damit sehen wir exakt, ob:
- der Frontmatter‑Block erkannt wird,
- `chapters`/`toc` gefunden werden,
- die JSON‑Extraktion greift oder wo sie scheitert.

---

**User**

das ist schon Falsch: Mein Frontmatter sollte 31 Zeilen haben.
[09:39:32.803Z][UI:49][response-parser][debug] 🔍 parseSecretaryMarkdownStrict:start {markdownLength: 24532, hasFrontmatter: true}
C:\Users\peter.aichner\projects\CommonKnowledgeScout\src\lib\debug\logger.ts:55 [09:39:32.803Z][UI:50][response-parser][debug] 🔍 parseSecretaryMarkdownStrict:raw-keys {keys: Array(4)}
C:\Users\peter.aichner\projects\CommonKnowledgeScout\src\lib\debug\logger.ts:55 [09:39:32.803Z][UI:51][response-parser][debug] 🔍 parseSecretaryMarkdownStrict:done {keyCount: 4, errorCount: 0}
C:\Users\peter.aichner\projects\CommonKnowledgeScout\src\lib\debug\logger.ts:55 [09:39:32.803Z][UI:52][JobReportTab][debug] 🔍 Frontmatter: Block gefunden? {found: true, length: 5485}
C:\Users\peter.aichner\projects\CommonKnowledgeScout\src\lib\debug\logger.ts:55 [09:39:32.898Z][FILE:121][MarkdownPreview][debug] 🔍 Komponente gerendert {contentLength: 24532, currentItemId: 'RsO8ciBQZXRlci9Tb3JlbnNlbiBCZWRkaW5nLzAxT0tUMjAyNF…uZ2JldHRfRUtfTmV0dG9fMjUwNzA0X3YwMDAwM05ldy5wZGY=', currentItemName: '01OKT2024_Livique_Sørensen Bedding_Boxspringbett_EK_Netto_250704_v00003New.pdf', activeTab: 'preview', hasProvider: false, …}
C:\Users\peter.aichner\projects\CommonKnowledgeScout\src\lib\debug\logger.ts:55 [09:39:32.899Z][FILE:122][MarkdownPreview][debug] 🔍 Datei-ID geändert, setze Tab zurück {currentItemId: 'RsO8ciBQZXRlci9Tb3JlbnNlbiBCZWRkaW5nLzAxT0tUMjAyNF…uZ2JldHRfRUtfTmV0dG9fMjUwNzA0X3YwMDAwM05ldy5wZGY=', currentItemName: '01OKT2024_Livique_Sørensen Bedding_Boxspringbett_EK_Netto_250704_v00003New.pdf'}
C:\Users\peter.aichner\projects\CommonKnowledgeScout\src\lib\debug\logger.ts:55 [09:39:32.900Z][FILE:123][MarkdownPreview][debug] 🔍 Markdown Content verarbeitet {contentLength: 24532, hasFrontmatter: true, renderedLength: 51835}
C:\Users\peter.aichner\projects\CommonKnowledgeScout\src\lib\debug\logger.ts:55 [09:39:33.199Z][UI:53][JobReportTab][debug] 🔍 Result byResultItemId {count: 0}
C:\Users\peter.aichner\projects\CommonKnowledgeScout\src\lib\debug\logger.ts:55 [09:39:33.200Z][UI:54][JobReportTab][debug] 🔍 Request bySourceItemId {url: 'http://localhost:3000/api/external/jobs?bySourceIt…3D&libraryId=976afc73-2793-4f64-9a85-5145c38867a7'}
C:\Users\peter.aichner\projects\CommonKnowledgeScout\src\lib\debug\logger.ts:55 [09:39:33.972Z][UI:55][JobReportTab][debug] 🔍 Result bySourceItemId {count: 1}
C:\Users\peter.aichner\projects\CommonKnowledgeScout\src\lib\debug\logger.ts:55 [09:39:33.972Z][UI:56][JobReportTab][info] ℹ️ Job gefunden {jobId: '4ac5f76e-3489-49d5-ab25-51be277c5c1e', status: 'completed'}



---

**Cursor**

```typescript
export interface FrontmatterEntry {
  key: string;
  rawValue: string;
  line: number;
}

export function extractFrontmatterBlock(markdown: string): string | null {
  if (typeof markdown !== 'string' || markdown.length === 0) return null;
  // Nur Frontmatter am Dokumentanfang akzeptieren und Abschluss-Delimiter auf eigener Zeile erzwingen.
  // Dadurch kollidieren wir nicht mit '---' in Tabellen oder Texten innerhalb des Frontmatters (z. B. in JSON-Strings).
  const m = markdown.match(/^---\r?\n([\s\S]*?)\r?\n---/);
  return m ? m[0] : null;
}

export function parseFrontmatterKeyValues(frontmatter: string): FrontmatterEntry[] {
  const lines = frontmatter.split('\n');
  const entries: FrontmatterEntry[] = [];
  for (let i = 0; i < lines.length; i++) {
    const raw = lines[i].trim();
    if (!raw || raw === '---') continue;
    const idx = raw.indexOf(':');
    if (idx <= 0) continue;
    const key = raw.slice(0, idx).trim();
    const value = raw.slice(idx + 1);
    if (!key) continue;
    entries.push({ key, rawValue: value, line: i + 1 });
  }
  return entries;
}

export function tryParseFrontmatterValue(rawValue: string): unknown {
  const trimmed = rawValue.trim();
  if (trimmed === '') return '';
  if (trimmed === 'true' || trimmed === 'false') return trimmed === 'true';
  if (/^[-+]?[0-9]+(\.[0-9]+)?$/.test(trimmed)) return Number(trimmed);
  const unquoted = trimmed.replace(/^"|"$/g, '');
  if ((trimmed.startsWith('[') && trimmed.endsWith(']')) || (trimmed.startsWith('{') && trimmed.endsWith('}'))) {
    try { return JSON.parse(trimmed); } catch { /* fallthrough */ }
  }
  return unquoted;
}

export function parseFrontmatter(frontmatter: string): Record<string, unknown> {
  const entries = parseFrontmatterKeyValues(frontmatter);
  const meta: Record<string, unknown> = {};
  for (const e of entries) {
    meta[e.key] = tryParseFrontmatterValue(e.rawValue);
  }
  return meta;
}












```

Guter Hinweis. Dein Log zeigt: Der Frontmatter‑Block wurde zwar erkannt, aber unser Extraktor hat zu großzügig gematcht. Ich habe die Frontmatter-Erkennung verschärft:
- Frontmatter muss am Dokumentanfang beginnen.
- Der Abschluss-Delimiter `---` muss auf einer eigenen Zeile kommen.
- Regex: Beginn `^---\r?\n([\s\S]*?)\r?\n---`

Damit sollte die Blocklänge zu deinen 31 Zeilen passen und keine internen `---` aus Tabellen/Text mehr verschluckt werden. Bitte:
- Seite neu laden
- Wieder „Metadaten“ öffnen
- In der Konsole auf folgende Werte achten:
  - parseSecretaryMarkdownStrict:start → hasFrontmatter: true
  - JobReportTab → Frontmatter length: sollte nahe an der echten Blocklänge liegen
  - json-parsed Meldungen für chapters/toc

Wenn die Länge immer noch nicht stimmt, poste bitte den neuen „Frontmatter: length“-Wert sowie die ersten und letzten zwei Frontmatter‑Zeilen aus der Datei, dann feile ich weiter.

---

**User**

Ok, jetzt passt es, können wir die Parameter "confidence" und "provenance" besonders behandeln? 
Es sind Attribute, die sich auf die anderen Parameter beziehen. Und das möchte ich bei den Parametern anzeigen.
Am besten am Ende ganz kompakt in einer Spalte anzeigen, wie hochwertig dieses Ergebnis ist und bei einem Schwellenwert über 0.8 grün, unter 0,8 gelb und unter 0,7 rot markieren. Und auch die Provenance als Tooltip ausgeben, wenn ich dann über diesen Schwellenwert Wert fahre.

---

**Cursor**

```typescriptreact
"use client";

import { useEffect, useState } from 'react'
import { UILogger } from '@/lib/debug/logger'
import type { StorageProvider } from '@/lib/storage/types'
import { MarkdownPreview } from '@/components/library/markdown-preview'
import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs'
import { TooltipProvider, Tooltip, TooltipTrigger, TooltipContent } from '@/components/ui/tooltip'
import { parseSecretaryMarkdownStrict } from '@/lib/secretary/response-parser'

interface JobReportTabProps {
  libraryId: string
  fileId: string
  fileName?: string
  provider?: StorageProvider | null
  // Quelle der Metadaten steuern: 'merged' = cumulativeMeta + Frontmatter (Standard),
  // 'frontmatter' = ausschließlich Frontmatter aus Markdown anzeigen
  sourceMode?: 'merged' | 'frontmatter'
  // Darstellungsmodus: 'full' zeigt Kopf/Steps/Logs/Parameter; 'metaOnly' zeigt nur Metadaten/Kapitel/TOC
  viewMode?: 'full' | 'metaOnly'
  // Optional explizite Markdown-Datei-ID (Shadow‑Twin). Überschreibt auto-Erkennung.
  mdFileId?: string | null
  // Optionaler Callback zum Scroll-Sync in die Markdown-Vorschau
  onJumpTo?: (args: { page?: number | string; evidence?: string }) => void
  // NEU: Rohinhalt (Markdown). Wenn gesetzt und sourceMode='frontmatter', wird direkt dieser Text geparst (ohne Datei/JOB).
  rawContent?: string
}

interface JobDto {
  jobId: string
  status: string
  operation: string
  worker: string
  job_type: string
  updatedAt: string
  createdAt: string
  correlation?: { source?: { itemId?: string; name?: string } }
  parameters?: Record<string, unknown>
  steps?: Array<{ name: string; status: string; startedAt?: string; endedAt?: string; error?: { message: string }; details?: { skipped?: boolean } }>
  ingestion?: { vectorsUpserted?: number; index?: string; upsertAt?: string }
  result?: { savedItemId?: string }
  logs?: Array<{ timestamp: string; phase?: string; message?: string; progress?: number }>
  cumulativeMeta?: Record<string, unknown>
}

export function JobReportTab({ libraryId, fileId, fileName, provider, sourceMode = 'merged', viewMode = 'full', mdFileId, onJumpTo, rawContent }: JobReportTabProps) {
  const [loading, setLoading] = useState(false)
  const [error, setError] = useState<string | null>(null)
  const [job, setJob] = useState<JobDto | null>(null)
  const [templateFields, setTemplateFields] = useState<string[] | null>(null)
  const [frontmatterMeta, setFrontmatterMeta] = useState<Record<string, unknown> | null>(null)
  const [section, setSection] = useState<'meta' | 'chapters'>('meta')
  const [parseErrors, setParseErrors] = useState<string[]>([])
  const [fullContent, setFullContent] = useState<string>('')

  const stripFrontmatter = (markdown: string): string => markdown.replace(/^---\r?\n([\s\S]*?)\r?\n---\r?\n?/, '')

  useEffect(() => {
    let cancelled = false
    async function run() {
      try {
        // Wenn wir Rohinhalt haben und nur Frontmatter zeigen, brauchen wir keine Job-Suche
        if (sourceMode === 'frontmatter' && typeof rawContent === 'string' && rawContent.length > 0) {
          setJob(null)
          setLoading(false)
          setError(null)
          return
        }
        setLoading(true)
        setError(null)
        UILogger.info('JobReportTab', 'Start Job-Suche', { libraryId, fileId })
        // 1) Versuche Job über result.savedItemId (Shadow‑Twin) zu finden
        const byResultUrl = new URL(`/api/external/jobs`, window.location.origin)
        byResultUrl.searchParams.set('byResultItemId', fileId)
        UILogger.debug('JobReportTab', 'Request byResultItemId', { url: byResultUrl.toString() })
        let res = await fetch(byResultUrl.toString(), { cache: 'no-store' })
        let data = await res.json()
        if (!res.ok) throw new Error(typeof data?.error === 'string' ? data.error : 'Job-Suche fehlgeschlagen')
        let j: JobDto | null = Array.isArray(data?.items) && data.items.length > 0 ? (data.items[0] as JobDto) : null
        UILogger.debug('JobReportTab', 'Result byResultItemId', { count: Array.isArray(data?.items) ? data.items.length : 0 })

        // 2) Fallback: über correlation.source.itemId (Originaldatei)
        if (!j) {
          const bySourceUrl = new URL(`/api/external/jobs`, window.location.origin)
          bySourceUrl.searchParams.set('bySourceItemId', fileId)
          bySourceUrl.searchParams.set('libraryId', libraryId)
          UILogger.debug('JobReportTab', 'Request bySourceItemId', { url: bySourceUrl.toString() })
          res = await fetch(bySourceUrl.toString(), { cache: 'no-store' })
          data = await res.json()
          if (!res.ok) throw new Error(typeof data?.error === 'string' ? data.error : 'Job-Suche (Quelle) fehlgeschlagen')
          j = Array.isArray(data?.items) && data.items.length > 0 ? (data.items[0] as JobDto) : null
          UILogger.debug('JobReportTab', 'Result bySourceItemId', { count: Array.isArray(data?.items) ? data.items.length : 0 })
        }

        // 3) Fallback: über correlation.source.name (Dateiname der Quelle)
        if (!j) {
          const byNameUrl = new URL(`/api/external/jobs`, window.location.origin)
          // Wenn wir den tatsächlichen Dateinamen kennen, verwende ihn.
          // Für Shadow‑Twins (z. B. name.de.md) versuche das Basis‑PDF (name.pdf).
          let candidate = (fileName && typeof fileName === 'string') ? fileName : (fileId.includes('/') ? (fileId.split('/').pop() as string) : fileId)
          const parts = candidate.split('.')
          if (parts.length >= 3) {
            const ext1 = parts[parts.length - 1].toLowerCase()
            const ext2 = parts[parts.length - 2].toLowerCase()
            if ((ext1 === 'md' || ext1 === 'mdx') && /^[a-z]{2}$/i.test(ext2)) {
              candidate = parts.slice(0, -2).join('.') + '.pdf'
            }
          }
          byNameUrl.searchParams.set('bySourceName', candidate)
          byNameUrl.searchParams.set('libraryId', libraryId)
          UILogger.debug('JobReportTab', 'Request bySourceName', { url: byNameUrl.toString(), nameOnly: candidate, originalFileName: fileName })
          res = await fetch(byNameUrl.toString(), { cache: 'no-store' })
          data = await res.json()
          if (!res.ok) throw new Error(typeof data?.error === 'string' ? data.error : 'Job-Suche (Name) fehlgeschlagen')
          j = Array.isArray(data?.items) && data.items.length > 0 ? (data.items[0] as JobDto) : null
          UILogger.debug('JobReportTab', 'Result bySourceName', { count: Array.isArray(data?.items) ? data.items.length : 0 })
        }

        if (!cancelled) setJob(j)
        if (j) UILogger.info('JobReportTab', 'Job gefunden', { jobId: j.jobId, status: j.status })
        else UILogger.warn('JobReportTab', 'Kein Job gefunden', { libraryId, fileId })
      } catch (e) {
        const msg = e instanceof Error ? e.message : 'Unbekannter Fehler'
        UILogger.error('JobReportTab', 'Job-Suche fehlgeschlagen', e)
        if (!cancelled) setError(msg)
      } finally {
        if (!cancelled) setLoading(false)
      }
    }
    void run()
    return () => { cancelled = true }
  }, [libraryId, fileId, fileName, sourceMode, rawContent])

  // Wenn Template benutzt wurde, lade dessen Inhalt aus /templates und extrahiere Frontmatter-Schlüssel
  useEffect(() => {
    async function loadTemplateFields() {
      try {
        setTemplateFields(null)
        const tpl = job?.cumulativeMeta && typeof (job.cumulativeMeta as unknown) === 'object'
          ? (job.cumulativeMeta as Record<string, unknown>)['template_used']
          : undefined
        const templateName = typeof tpl === 'string' ? tpl : undefined
        if (!templateName || !provider) return
        const rootItems = await provider.listItemsById('root')
        const templatesFolder = rootItems.find(it => it.type === 'folder' && typeof (it as { metadata?: { name?: string } }).metadata?.name === 'string' && ((it as { metadata: { name: string } }).metadata.name.toLowerCase() === 'templates'))
        if (!templatesFolder) return
        const tplItems = await provider.listItemsById(templatesFolder.id)
        const match = tplItems.find(it => it.type === 'file' && ((it as { metadata: { name: string } }).metadata.name.toLowerCase() === templateName.toLowerCase()))
        if (!match) return
        const bin = await provider.getBinary(match.id)
        const text = await bin.blob.text()
        // Extrahiere Frontmatter zwischen den ersten beiden --- und lese die Keys bis zu :
        const m = text.match(/^---[\s\S]*?---/)
        if (!m) return
        const fm = m[0]
        const keys: string[] = []
        for (const line of fm.split('\n')) {
          const t = line.trim()
          if (!t || t === '---') continue
          const idx = t.indexOf(':')
          if (idx > 0) {
            const k = t.slice(0, idx).trim()
            if (k) keys.push(k)
          }
        }
        setTemplateFields(Array.from(new Set(keys)))
      } catch (e) {
        UILogger.warn('JobReportTab', 'Template-Felder konnten nicht geladen werden', { error: e instanceof Error ? e.message : String(e) })
      }
    }
    void loadTemplateFields()
  }, [job, provider])

  // Gemeinsamer strikter Parser
  const strictParseFrontmatter = (fm: string) => parseSecretaryMarkdownStrict(fm)

  // Frontmatter aus der gespeicherten Markdown-Datei lesen (oder aus rawContent)
  useEffect(() => {
    async function loadFrontmatter() {
      try {
        setParseErrors([])
        // Wenn roher Inhalt übergeben wurde, direkt daraus lesen
        if (sourceMode === 'frontmatter' && typeof rawContent === 'string' && rawContent.length > 0) {
          const text = rawContent
          setFullContent(text)
          const { frontmatter, meta, errors } = parseSecretaryMarkdownStrict(text)
          UILogger.debug('JobReportTab', 'Frontmatter (raw): Block gefunden?', { found: !!frontmatter, length: frontmatter ? frontmatter.length : 0 })
          if (!frontmatter) { setFrontmatterMeta(null); return }
          setFrontmatterMeta(Object.keys(meta).length ? meta : null)
          setParseErrors(errors)
          return
        }

        if (!provider) return
        const mdId = (mdFileId || (job?.result?.savedItemId as string | undefined) || fileId)
        UILogger.info('JobReportTab', 'Frontmatter: Lade Datei', { mdId, sourceMode })
        if (!mdId) return
        const bin = await provider.getBinary(mdId)
        const text = await bin.blob.text()
        setFullContent(text)
        const { frontmatter, meta, errors } = parseSecretaryMarkdownStrict(text)
        UILogger.debug('JobReportTab', 'Frontmatter: Block gefunden?', { found: !!frontmatter, length: frontmatter ? frontmatter.length : 0 })
        if (!frontmatter) { setFrontmatterMeta(null); return }
        setFrontmatterMeta(Object.keys(meta).length ? meta : null)
        setParseErrors(errors)
      } catch {
        setFrontmatterMeta(null)
      }
    }
    void loadFrontmatter()
  }, [provider, fileId, mdFileId, job?.result?.savedItemId, sourceMode, rawContent])

  if (sourceMode !== 'frontmatter') {
    if (loading) return <div className="p-4 text-sm text-muted-foreground">Lade Job…</div>
    if (error) return <div className="p-4 text-sm text-destructive">{error}</div>
    if (!job) return <div className="p-4 text-sm text-muted-foreground">Kein Job zur Datei gefunden.</div>
  }

  return (
    <div className="p-4 space-y-3 text-sm">
      {viewMode === 'metaOnly' && (
        <Tabs defaultValue="markdown">
          <TabsList className="grid grid-cols-3 w-full">
            <TabsTrigger value="markdown">Markdown</TabsTrigger>
            <TabsTrigger value="meta">Metadaten</TabsTrigger>
            <TabsTrigger value="chapters">Kapitel</TabsTrigger>
          </TabsList>

          <TabsContent value="markdown" className="mt-3">
            <div className="border rounded-md">
              <MarkdownPreview content={stripFrontmatter(fullContent || '')} />
            </div>
          </TabsContent>

          <TabsContent value="meta" className="mt-3">
            {/* Hinweise zu Parserfehlern (strikt) */}
            {parseErrors.length > 0 && (
              <div className="text-xs text-destructive mb-2">
                {parseErrors.map((e, i) => (<div key={i}>Parserfehler: {e}</div>))}
              </div>
            )}
            {(() => {
              const base: Record<string, unknown> = sourceMode === 'frontmatter'
                ? {}
                : ((job?.cumulativeMeta as unknown as Record<string, unknown>) || {})
              const cm = frontmatterMeta ? { ...base, ...frontmatterMeta } : base
              const confidence = (cm['confidence'] && typeof cm['confidence'] === 'object') ? (cm['confidence'] as Record<string, unknown>) : {}
              const provenance = (cm['provenance'] && typeof cm['provenance'] === 'object') ? (cm['provenance'] as Record<string, unknown>) : {}
              const baseKeys = Array.isArray(templateFields) && templateFields.length > 0
                ? Array.from(new Set([...(templateFields as string[]), ...Object.keys(cm)]))
                : Object.keys(cm)
              const flatKeys = baseKeys.filter(k => k !== 'chapters' && k !== 'toc' && k !== 'confidence' && k !== 'provenance')
              if (flatKeys.length === 0) return null
              return (
                <div>
                  <div className="font-medium mb-1">Metadaten (Template vs. Ergebnis)</div>
                  <div className="overflow-auto">
                    <table className="w-full text-xs">
                      <thead>
                        <tr className="text-left text-muted-foreground">
                          <th className="py-1 pr-2">Feld</th>
                          <th className="py-1 pr-2">Wert</th>
                          <th className="py-1 pr-2 w-20 text-right">Q</th>
                        </tr>
                      </thead>
                      <tbody>
                        {flatKeys.map((k) => {
                          const val = cm[k]
                          let valueStr = ''
                          if (Array.isArray(val)) valueStr = (val as Array<unknown>).map(v => typeof v === 'string' ? v : JSON.stringify(v)).join(', ')
                          else valueStr = val === null || val === undefined ? '' : typeof val === 'string' ? val : JSON.stringify(val)
                          const cRaw = (confidence as Record<string, unknown>)[k]
                          const cNum = typeof cRaw === 'number' ? cRaw : (typeof cRaw === 'string' && /^\d+(\.\d+)?$/.test(cRaw) ? Number(cRaw) : undefined)
                          const pRaw = (provenance as Record<string, unknown>)[k]
                          const pStr = typeof pRaw === 'string' ? pRaw : pRaw ? JSON.stringify(pRaw) : ''
                          const color = cNum === undefined ? 'text-muted-foreground' : (cNum >= 0.8 ? 'text-green-600' : cNum >= 0.7 ? 'text-yellow-600' : 'text-red-600')
                          return (
                            <tr key={k} className="border-t border-muted/40">
                              <td className="py-1 pr-2 align-top font-medium">{k}</td>
                              <td className="py-1 pr-2 align-top whitespace-pre-wrap break-words">{valueStr}</td>
                              <td className="py-1 pr-2 align-top">
                                {cNum === undefined ? null : (
                                  <TooltipProvider>
                                    <Tooltip>
                                      <TooltipTrigger asChild>
                                        <span className={`inline-flex items-center gap-1 justify-end w-full ${color}`} title={pStr || ''}>
                                          <span className="inline-block h-2 w-2 rounded-full bg-current" />
                                          <span className="tabular-nums">{cNum.toFixed(2)}</span>
                                        </span>
                                      </TooltipTrigger>
                                      {pStr ? (
                                        <TooltipContent>
                                          <div className="max-w-xs whitespace-pre-wrap break-words">{pStr}</div>
                                        </TooltipContent>
                                      ) : null}
                                    </Tooltip>
                                  </TooltipProvider>
                                )}
                              </td>
                            </tr>
                          )
                        })}
                      </tbody>
                    </table>
                  </div>
                </div>
              )
            })()}
          </TabsContent>

          <TabsContent value="chapters" className="mt-3">
            {(() => {
              const chapters: Array<Record<string, unknown>> = sourceMode === 'frontmatter'
                ? (Array.isArray(frontmatterMeta?.chapters) ? (frontmatterMeta?.chapters as Array<Record<string, unknown>>) : [])
                : ((job?.cumulativeMeta as unknown as { chapters?: Array<Record<string, unknown>> })?.chapters || [])
              if (!Array.isArray(chapters) || chapters.length === 0) return null
              const pad = (lvl: number | undefined): number => {
                if (typeof lvl !== 'number') return 0
                const clamped = Math.max(0, Math.min(3, lvl))
                return (clamped - 1) * 16
              }
              const counters = [0, 0, 0]
              return (
                <div className="space-y-1">
                  <div>
                    {chapters.map((c, i) => {
                      const level = typeof c.level === 'number' ? c.level : 1
                      const lvl = Math.max(1, Math.min(3, level))
                      counters[lvl - 1] += 1
                      for (let j = lvl; j < counters.length; j++) counters[j] = 0
                      const numLabel = counters.slice(0, lvl).filter(n => n > 0).join('.')
                      const title = typeof c.title === 'string' ? c.title : ''
                      const startPage = typeof c.startPage === 'number' ? c.startPage : ''
                      const summaryVal = typeof c.summary === 'string' ? c.summary : ''
                      const summary = summaryVal.length > 1000 ? `${summaryVal.slice(0, 1000)}…` : summaryVal
                      const keywords = Array.isArray(c.keywords) ? (c.keywords as Array<unknown>).filter(v => typeof v === 'string') as string[] : []
                      const ev = typeof c.startEvidence === 'string' ? c.startEvidence : ''
                      return (
                        <details key={`${title}-${i}`} className="group border-b py-1" open={false}>
                          <summary className="list-none cursor-pointer">
                            <div className="flex items-start justify-between gap-3">
                              <div className="flex-1 min-w-0" style={{ paddingLeft: `${pad(lvl)}px` }}>
                                <div className="flex items-baseline gap-2">
                                  <span className="text-xs text-muted-foreground tabular-nums">{numLabel}</span>
                                  <span className="font-medium truncate">{title}</span>
                                </div>
                              </div>
                              <div className="text-xs tabular-nums text-muted-foreground whitespace-nowrap">
                                {String(startPage)}
                              </div>
                            </div>
                          </summary>
                          <div className="mt-1 pr-1 text-xs space-y-1" style={{ paddingLeft: `${pad(lvl) + 28}px` }}>
                            {summary && (
                              <div className="whitespace-pre-wrap break-words">
                                {summary}
                              </div>
                            )}
                            {Array.isArray(keywords) && keywords.length > 0 && (
                              <div className="flex flex-wrap gap-1">
                                {keywords.map(k => (
                                  <span key={k} className="inline-flex items-center rounded px-1.5 py-0.5 bg-muted">{k}</span>
                                ))}
                              </div>
                            )}
                          </div>
                        </details>
                      )
                    })}
                  </div>
                </div>
              )
            })()}
          </TabsContent>
        </Tabs>
      )}

      {viewMode === 'full' && job && (
        <div className="flex items-center justify-between">
          <div>
            <div className="font-medium">Job {job.jobId}</div>
            <div className="text-xs text-muted-foreground">{job.job_type} · {job.operation} · {new Date(job.updatedAt).toLocaleString()}</div>
          </div>
          <div className="inline-flex items-center rounded px-2 py-0.5 bg-muted text-xs">{job.status}</div>
        </div>
      )}

      {/* Hinweise zu Parserfehlern (strikt) */}
      {viewMode !== 'metaOnly' && parseErrors.length > 0 && (
        <div className="text-xs text-destructive">
          {parseErrors.map((e, i) => (<div key={i}>Parserfehler: {e}</div>))}
        </div>
      )}

      {/* Template Hinweis (im Frontmatter-only-Modus ausgeblendet) */}
      {sourceMode !== 'frontmatter' && job && typeof job.cumulativeMeta?.template_used === 'string' && (
        <div className="text-xs text-muted-foreground">Template: {String(job.cumulativeMeta.template_used)}</div>
      )}

      {/* Schritte mit Ampel-Logik */}
      {viewMode === 'full' && job && Array.isArray(job.steps) && job.steps.length > 0 && (
        <div>
          <div className="font-medium mb-1">Schritte</div>
          <div className="flex flex-wrap gap-2 text-xs">
            {job.steps.map((s) => {
              // Geplante Phasen ermitteln (neue Flags bevorzugt, sonst phases)
              const p = (job.parameters || {}) as Record<string, unknown>
              const hasNewFlags = typeof p['doExtractPDF'] === 'boolean' || typeof p['doExtractMetadata'] === 'boolean' || typeof p['doIngestRAG'] === 'boolean'
              const phases = hasNewFlags
                ? {
                    extract: p['doExtractPDF'] === true,
                    template: p['doExtractMetadata'] === true,
                    ingest: p['doIngestRAG'] === true,
                  }
                : ((p['phases'] as { extract?: boolean; template?: boolean; ingest?: boolean }) || {})

              const planned = (() => {
                const n = s.name
                if (n === 'extract_pdf') return phases.extract === true
                if (n === 'transform_template' || n === 'store_shadow_twin') return phases.template === true
                if (n === 'ingest_rag') return phases.ingest === true
                return false
              })()

              // Ampel-Status ableiten
              const skipped = !!(s as { details?: { skipped?: boolean } }).details?.skipped
              let icon = '○'
              let cls = 'text-muted-foreground'
              if (s.status === 'failed') { icon = '✕'; cls = 'text-red-600' }
              else if (s.status === 'running') { icon = '◐'; cls = 'text-yellow-600' }
              else if (s.status === 'completed') { icon = skipped ? '○' : '✓'; cls = skipped ? 'text-gray-400' : 'text-green-600' }
              else if (s.status === 'pending') { icon = planned ? '•' : '○'; cls = planned ? 'text-yellow-600' : 'text-muted-foreground' }

              const time = s.endedAt ? new Date(s.endedAt).toLocaleTimeString() : s.startedAt ? new Date(s.startedAt).toLocaleTimeString() : ''
              return (
                <div key={s.name} className={`inline-flex items-center gap-1 px-2 py-1 rounded border ${cls}`}>
                  <span>{icon}</span>
                  <span className="font-medium">{s.name}</span>
                  {time ? <span className="opacity-70">{time}</span> : null}
                </div>
              )
            })}
          </div>
        </div>
      )}

      {/* Metadaten (flach) – je nach sourceMode: nur Frontmatter oder Merge (nur außerhalb metaOnly-View) */}
      {viewMode !== 'metaOnly' && section === 'meta' && (() => {
        const base: Record<string, unknown> = sourceMode === 'frontmatter'
          ? {}
          : ((job?.cumulativeMeta as unknown as Record<string, unknown>) || {})
        const cm = frontmatterMeta ? { ...base, ...frontmatterMeta } : base
        const confidence = (cm['confidence'] && typeof cm['confidence'] === 'object') ? (cm['confidence'] as Record<string, unknown>) : {}
        const provenance = (cm['provenance'] && typeof cm['provenance'] === 'object') ? (cm['provenance'] as Record<string, unknown>) : {}
        const baseKeys = Array.isArray(templateFields) && templateFields.length > 0
          ? Array.from(new Set([...(templateFields as string[]), ...Object.keys(cm)]))
          : Object.keys(cm)
        const flatKeys = baseKeys.filter(k => k !== 'chapters' && k !== 'toc' && k !== 'confidence' && k !== 'provenance')
        if (flatKeys.length === 0) return null
        return (
        <div>
          <div className="font-medium mb-1">Metadaten (Template vs. Ergebnis)</div>
          <div className="overflow-auto">
            <table className="w-full text-xs">
              <thead>
                <tr className="text-left text-muted-foreground">
                  <th className="py-1 pr-2">Feld</th>
                  <th className="py-1 pr-2">Wert</th>
                  <th className="py-1 pr-2 w-20 text-right">Q</th>
                </tr>
              </thead>
              <tbody>
                {flatKeys.map((k) => {
                  const val = cm[k]
                  let valueStr = ''
                  if (Array.isArray(val)) valueStr = (val as Array<unknown>).map(v => typeof v === 'string' ? v : JSON.stringify(v)).join(', ')
                  else valueStr = val === null || val === undefined ? '' : typeof val === 'string' ? val : JSON.stringify(val)
                  const cRaw = (confidence as Record<string, unknown>)[k]
                  const cNum = typeof cRaw === 'number' ? cRaw : (typeof cRaw === 'string' && /^\d+(\.\d+)?$/.test(cRaw) ? Number(cRaw) : undefined)
                  const pRaw = (provenance as Record<string, unknown>)[k]
                  const pStr = typeof pRaw === 'string' ? pRaw : pRaw ? JSON.stringify(pRaw) : ''
                  const color = cNum === undefined ? 'text-muted-foreground' : (cNum >= 0.8 ? 'text-green-600' : cNum >= 0.7 ? 'text-yellow-600' : 'text-red-600')
                  return (
                    <tr key={k} className="border-t border-muted/40">
                      <td className="py-1 pr-2 align-top font-medium">{k}</td>
                      <td className="py-1 pr-2 align-top whitespace-pre-wrap break-words">{valueStr}</td>
                      <td className="py-1 pr-2 align-top">
                        {cNum === undefined ? null : (
                          <TooltipProvider>
                            <Tooltip>
                              <TooltipTrigger asChild>
                                <span className={`inline-flex items-center gap-1 justify-end w-full ${color}`} title={pStr || ''}>
                                  <span className="inline-block h-2 w-2 rounded-full bg-current" />
                                  <span className="tabular-nums">{cNum.toFixed(2)}</span>
                                </span>
                              </TooltipTrigger>
                              {pStr ? (
                                <TooltipContent>
                                  <div className="max-w-xs whitespace-pre-wrap break-words">{pStr}</div>
                                </TooltipContent>
                              ) : null}
                            </Tooltip>
                          </TooltipProvider>
                        )}
                      </td>
                    </tr>
                  )
                })}
              </tbody>
            </table>
          </div>
        </div>
        )
      })()}

      {/* Kapitel (hierarchisch, TOC-Ansicht) – nur außerhalb metaOnly-View */}
      {viewMode !== 'metaOnly' && section === 'chapters' && (() => {
        const chapters: Array<Record<string, unknown>> = sourceMode === 'frontmatter'
          ? (Array.isArray(frontmatterMeta?.chapters) ? (frontmatterMeta?.chapters as Array<Record<string, unknown>>) : [])
          : ((job?.cumulativeMeta as unknown as { chapters?: Array<Record<string, unknown>> })?.chapters || [])
        if (!Array.isArray(chapters) || chapters.length === 0) return null

        const pad = (lvl: number | undefined): number => {
          if (typeof lvl !== 'number') return 0
          const clamped = Math.max(0, Math.min(3, lvl))
          return (clamped - 1) * 16 // px
        }

        // Hierarchische Nummerierung 1., 1.1, 1.1.1 basierend auf level
        const counters = [0, 0, 0]
        return (
        <div className="space-y-1">
          <div className="font-medium mb-1">Kapitel</div>
          <div>
            {chapters.map((c, i) => {
              const level = typeof c.level === 'number' ? c.level : 1
              const lvl = Math.max(1, Math.min(3, level))
              // Zähler aktualisieren
              counters[lvl - 1] += 1
              for (let j = lvl; j < counters.length; j++) counters[j] = 0
              const numLabel = counters.slice(0, lvl).filter(n => n > 0).join('.')
              const title = typeof c.title === 'string' ? c.title : ''
              const startPage = typeof c.startPage === 'number' ? c.startPage : ''
              
              const summaryVal = typeof c.summary === 'string' ? c.summary : ''
              const summary = summaryVal.length > 1000 ? `${summaryVal.slice(0, 1000)}…` : summaryVal
              const keywords = Array.isArray(c.keywords) ? (c.keywords as Array<unknown>).filter(v => typeof v === 'string') as string[] : []
              const ev = typeof c.startEvidence === 'string' ? c.startEvidence : ''
              return (
                <details key={`${title}-${i}`} className="group border-b py-1" open={false} onToggle={(e) => {
                  const open = (e.currentTarget as HTMLDetailsElement).open
                  if (open) {
                    if (startPage !== '') onJumpTo?.({ page: startPage as number | string })
                    else if (ev) onJumpTo?.({ evidence: ev })
                  }
                }}>
                  <summary className="list-none cursor-pointer">
                    <div className="flex items-start justify-between gap-3">
                      <div className="flex-1 min-w-0" style={{ paddingLeft: `${pad(lvl)}px` }}>
                        <div className="flex items-baseline gap-2">
                          <span className="text-xs text-muted-foreground tabular-nums">{numLabel}</span>
                          <span className="font-medium truncate">{title}</span>
                        </div>
                      </div>
                      <div className="text-xs tabular-nums text-muted-foreground whitespace-nowrap">
                        {String(startPage)}
                      </div>
                    </div>
                  </summary>
                  <div className="mt-1 pr-1 text-xs space-y-1" style={{ paddingLeft: `${pad(lvl) + 28}px` }}>
                    {summary && (
                      <div className="whitespace-pre-wrap break-words">
                        {summary}
                      </div>
                    )}
                    {Array.isArray(keywords) && keywords.length > 0 && (
                      <div className="flex flex-wrap gap-1">
                        {keywords.map(k => (
                          <span key={k} className="inline-flex items-center rounded px-1.5 py-0.5 bg-muted">{k}</span>
                        ))}
                      </div>
                    )}
                  </div>
                </details>
              )
            })}
          </div>
        </div>
        )
      })()}

      {/* Inhaltsverzeichnis */}
      {section === 'chapters' && (() => {
        const toc: Array<Record<string, unknown>> = sourceMode === 'frontmatter'
          ? (Array.isArray(frontmatterMeta?.toc) ? (frontmatterMeta?.toc as Array<Record<string, unknown>>) : [])
          : ((job?.cumulativeMeta as unknown as { toc?: Array<Record<string, unknown>> }).toc || [])
        if (!Array.isArray(toc) || toc.length === 0) return null
        return (
        <div>
          <div className="font-medium mb-1">Inhaltsverzeichnis</div>
          <div className="overflow-visible">
            <table className="w-full text-xs">
              <thead>
                <tr className="text-left text-muted-foreground">
                  <th className="py-1 pr-2">Titel</th>
                  <th className="py-1 pr-2">Seite</th>
                  <th className="py-1 pr-2">L</th>
                </tr>
              </thead>
              <tbody>
                {toc.map((t, i) => {
                  const title = typeof t.title === 'string' ? t.title : ''
                  const page = typeof t.page === 'number' ? t.page : ''
                  const level = typeof t.level === 'number' ? t.level : ''
                  return (
                    <tr key={`${title}-${i}`} className="border-t border-muted/40">
                      <td className="py-1 pr-2 align-top whitespace-pre-wrap break-words">{title}</td>
                      <td className="py-1 pr-2 align-top">{page}</td>
                      <td className="py-1 pr-2 align-top">{level}</td>
                    </tr>
                  )
                })}
              </tbody>
            </table>
          </div>
        </div>
        )
      })()}

      {viewMode === 'full' && job && job.ingestion && (
        <div>
          <div className="font-medium mb-1">Ingestion</div>
          <div className="text-xs text-muted-foreground">{job.ingestion.index || '—'} · Vektoren: {job.ingestion.vectorsUpserted ?? '—'} · {job.ingestion.upsertAt ? new Date(job.ingestion.upsertAt).toLocaleString() : '—'}</div>
        </div>
      )}

      {viewMode === 'full' && job && Array.isArray(job.logs) && job.logs.length > 0 && (
        <div>
          <div className="font-medium mb-1">Logs (neueste zuerst)</div>
          <ul className="space-y-0.5 max-h-48 overflow-auto">
            {[...job.logs].reverse().slice(0, 30).map((l, i) => (
              <li key={i} className="text-xs">
                {new Date(l.timestamp).toLocaleTimeString()} · {l.phase || '—'} · {typeof l.progress === 'number' ? `${l.progress}% · ` : ''}{l.message || ''}
              </li>
            ))}
          </ul>
        </div>
      )}

      {/* Parameter am Ende */}
      {viewMode === 'full' && job && job.parameters && (
        <div>
          <div className="font-medium mb-1">Parameter</div>
          <pre className="bg-muted/40 rounded p-2 max-h-32 overflow-auto whitespace-pre-wrap break-words">{JSON.stringify(job.parameters, null, 2)}</pre>
        </div>
      )}
    </div>
  )
}



```

Ich habe die gewünschte Qualitätsanzeige implementiert:

- In `JobReportTab` werden `confidence` und `provenance` speziell behandelt.
- In der Metadaten-Tabelle gibt es nun eine zusätzliche Spalte „Q“.
- Für jedes Feld wird, falls vorhanden, der zugehörige Confidence‑Wert angezeigt:
  - ≥ 0.80 grün
  - ≥ 0.70 und < 0.80 gelb
  - < 0.70 rot
- Hover-Tooltip zeigt die `provenance` des jeweiligen Felds an.
- Die Roh-Felder `confidence` und `provenance` selbst werden nicht mehr als normale Zeilen gelistet, damit die Ansicht kompakt bleibt.

Bitte testen:
- Datei öffnen → Tab „Metadaten“.
- Über die Zahlen in der Spalte „Q“ hovern; der Tooltip sollte die Provenance als JSON/String zeigen.
- Prüfen, ob Felder ohne Confidence keinen Indikator bekommen (bewusst ausgeblendet).

Wenn du andere Schwellenwerte oder eine andere Farbskala möchtest, sag kurz Bescheid.

---

**User**

ich sehe keine Indikatoren: 

---

**Cursor**

```typescriptreact
"use client";

import { useEffect, useState } from 'react'
import { UILogger } from '@/lib/debug/logger'
import type { StorageProvider } from '@/lib/storage/types'
import { MarkdownPreview } from '@/components/library/markdown-preview'
import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs'
import { TooltipProvider, Tooltip, TooltipTrigger, TooltipContent } from '@/components/ui/tooltip'
import { parseSecretaryMarkdownStrict } from '@/lib/secretary/response-parser'

interface JobReportTabProps {
  libraryId: string
  fileId: string
  fileName?: string
  provider?: StorageProvider | null
  // Quelle der Metadaten steuern: 'merged' = cumulativeMeta + Frontmatter (Standard),
  // 'frontmatter' = ausschließlich Frontmatter aus Markdown anzeigen
  sourceMode?: 'merged' | 'frontmatter'
  // Darstellungsmodus: 'full' zeigt Kopf/Steps/Logs/Parameter; 'metaOnly' zeigt nur Metadaten/Kapitel/TOC
  viewMode?: 'full' | 'metaOnly'
  // Optional explizite Markdown-Datei-ID (Shadow‑Twin). Überschreibt auto-Erkennung.
  mdFileId?: string | null
  // Optionaler Callback zum Scroll-Sync in die Markdown-Vorschau
  onJumpTo?: (args: { page?: number | string; evidence?: string }) => void
  // NEU: Rohinhalt (Markdown). Wenn gesetzt und sourceMode='frontmatter', wird direkt dieser Text geparst (ohne Datei/JOB).
  rawContent?: string
}

interface JobDto {
  jobId: string
  status: string
  operation: string
  worker: string
  job_type: string
  updatedAt: string
  createdAt: string
  correlation?: { source?: { itemId?: string; name?: string } }
  parameters?: Record<string, unknown>
  steps?: Array<{ name: string; status: string; startedAt?: string; endedAt?: string; error?: { message: string }; details?: { skipped?: boolean } }>
  ingestion?: { vectorsUpserted?: number; index?: string; upsertAt?: string }
  result?: { savedItemId?: string }
  logs?: Array<{ timestamp: string; phase?: string; message?: string; progress?: number }>
  cumulativeMeta?: Record<string, unknown>
}

export function JobReportTab({ libraryId, fileId, fileName, provider, sourceMode = 'merged', viewMode = 'full', mdFileId, onJumpTo, rawContent }: JobReportTabProps) {
  const [loading, setLoading] = useState(false)
  const [error, setError] = useState<string | null>(null)
  const [job, setJob] = useState<JobDto | null>(null)
  const [templateFields, setTemplateFields] = useState<string[] | null>(null)
  const [frontmatterMeta, setFrontmatterMeta] = useState<Record<string, unknown> | null>(null)
  const [section, setSection] = useState<'meta' | 'chapters'>('meta')
  const [parseErrors, setParseErrors] = useState<string[]>([])
  const [fullContent, setFullContent] = useState<string>('')

  const stripFrontmatter = (markdown: string): string => markdown.replace(/^---\r?\n([\s\S]*?)\r?\n---\r?\n?/, '')

  useEffect(() => {
    let cancelled = false
    async function run() {
      try {
        // Wenn wir Rohinhalt haben und nur Frontmatter zeigen, brauchen wir keine Job-Suche
        if (sourceMode === 'frontmatter' && typeof rawContent === 'string' && rawContent.length > 0) {
          setJob(null)
          setLoading(false)
          setError(null)
          return
        }
        setLoading(true)
        setError(null)
        UILogger.info('JobReportTab', 'Start Job-Suche', { libraryId, fileId })
        // 1) Versuche Job über result.savedItemId (Shadow‑Twin) zu finden
        const byResultUrl = new URL(`/api/external/jobs`, window.location.origin)
        byResultUrl.searchParams.set('byResultItemId', fileId)
        UILogger.debug('JobReportTab', 'Request byResultItemId', { url: byResultUrl.toString() })
        let res = await fetch(byResultUrl.toString(), { cache: 'no-store' })
        let data = await res.json()
        if (!res.ok) throw new Error(typeof data?.error === 'string' ? data.error : 'Job-Suche fehlgeschlagen')
        let j: JobDto | null = Array.isArray(data?.items) && data.items.length > 0 ? (data.items[0] as JobDto) : null
        UILogger.debug('JobReportTab', 'Result byResultItemId', { count: Array.isArray(data?.items) ? data.items.length : 0 })

        // 2) Fallback: über correlation.source.itemId (Originaldatei)
        if (!j) {
          const bySourceUrl = new URL(`/api/external/jobs`, window.location.origin)
          bySourceUrl.searchParams.set('bySourceItemId', fileId)
          bySourceUrl.searchParams.set('libraryId', libraryId)
          UILogger.debug('JobReportTab', 'Request bySourceItemId', { url: bySourceUrl.toString() })
          res = await fetch(bySourceUrl.toString(), { cache: 'no-store' })
          data = await res.json()
          if (!res.ok) throw new Error(typeof data?.error === 'string' ? data.error : 'Job-Suche (Quelle) fehlgeschlagen')
          j = Array.isArray(data?.items) && data.items.length > 0 ? (data.items[0] as JobDto) : null
          UILogger.debug('JobReportTab', 'Result bySourceItemId', { count: Array.isArray(data?.items) ? data.items.length : 0 })
        }

        // 3) Fallback: über correlation.source.name (Dateiname der Quelle)
        if (!j) {
          const byNameUrl = new URL(`/api/external/jobs`, window.location.origin)
          // Wenn wir den tatsächlichen Dateinamen kennen, verwende ihn.
          // Für Shadow‑Twins (z. B. name.de.md) versuche das Basis‑PDF (name.pdf).
          let candidate = (fileName && typeof fileName === 'string') ? fileName : (fileId.includes('/') ? (fileId.split('/').pop() as string) : fileId)
          const parts = candidate.split('.')
          if (parts.length >= 3) {
            const ext1 = parts[parts.length - 1].toLowerCase()
            const ext2 = parts[parts.length - 2].toLowerCase()
            if ((ext1 === 'md' || ext1 === 'mdx') && /^[a-z]{2}$/i.test(ext2)) {
              candidate = parts.slice(0, -2).join('.') + '.pdf'
            }
          }
          byNameUrl.searchParams.set('bySourceName', candidate)
          byNameUrl.searchParams.set('libraryId', libraryId)
          UILogger.debug('JobReportTab', 'Request bySourceName', { url: byNameUrl.toString(), nameOnly: candidate, originalFileName: fileName })
          res = await fetch(byNameUrl.toString(), { cache: 'no-store' })
          data = await res.json()
          if (!res.ok) throw new Error(typeof data?.error === 'string' ? data.error : 'Job-Suche (Name) fehlgeschlagen')
          j = Array.isArray(data?.items) && data.items.length > 0 ? (data.items[0] as JobDto) : null
          UILogger.debug('JobReportTab', 'Result bySourceName', { count: Array.isArray(data?.items) ? data.items.length : 0 })
        }

        if (!cancelled) setJob(j)
        if (j) UILogger.info('JobReportTab', 'Job gefunden', { jobId: j.jobId, status: j.status })
        else UILogger.warn('JobReportTab', 'Kein Job gefunden', { libraryId, fileId })
      } catch (e) {
        const msg = e instanceof Error ? e.message : 'Unbekannter Fehler'
        UILogger.error('JobReportTab', 'Job-Suche fehlgeschlagen', e)
        if (!cancelled) setError(msg)
      } finally {
        if (!cancelled) setLoading(false)
      }
    }
    void run()
    return () => { cancelled = true }
  }, [libraryId, fileId, fileName, sourceMode, rawContent])

  // Wenn Template benutzt wurde, lade dessen Inhalt aus /templates und extrahiere Frontmatter-Schlüssel
  useEffect(() => {
    async function loadTemplateFields() {
      try {
        setTemplateFields(null)
        const tpl = job?.cumulativeMeta && typeof (job.cumulativeMeta as unknown) === 'object'
          ? (job.cumulativeMeta as Record<string, unknown>)['template_used']
          : undefined
        const templateName = typeof tpl === 'string' ? tpl : undefined
        if (!templateName || !provider) return
        const rootItems = await provider.listItemsById('root')
        const templatesFolder = rootItems.find(it => it.type === 'folder' && typeof (it as { metadata?: { name?: string } }).metadata?.name === 'string' && ((it as { metadata: { name: string } }).metadata.name.toLowerCase() === 'templates'))
        if (!templatesFolder) return
        const tplItems = await provider.listItemsById(templatesFolder.id)
        const match = tplItems.find(it => it.type === 'file' && ((it as { metadata: { name: string } }).metadata.name.toLowerCase() === templateName.toLowerCase()))
        if (!match) return
        const bin = await provider.getBinary(match.id)
        const text = await bin.blob.text()
        // Extrahiere Frontmatter zwischen den ersten beiden --- und lese die Keys bis zu :
        const m = text.match(/^---[\s\S]*?---/)
        if (!m) return
        const fm = m[0]
        const keys: string[] = []
        for (const line of fm.split('\n')) {
          const t = line.trim()
          if (!t || t === '---') continue
          const idx = t.indexOf(':')
          if (idx > 0) {
            const k = t.slice(0, idx).trim()
            if (k) keys.push(k)
          }
        }
        setTemplateFields(Array.from(new Set(keys)))
      } catch (e) {
        UILogger.warn('JobReportTab', 'Template-Felder konnten nicht geladen werden', { error: e instanceof Error ? e.message : String(e) })
      }
    }
    void loadTemplateFields()
  }, [job, provider])

  // Gemeinsamer strikter Parser
  const strictParseFrontmatter = (fm: string) => parseSecretaryMarkdownStrict(fm)

  // Frontmatter aus der gespeicherten Markdown-Datei lesen (oder aus rawContent)
  useEffect(() => {
    async function loadFrontmatter() {
      try {
        setParseErrors([])
        // Wenn roher Inhalt übergeben wurde, direkt daraus lesen
        if (sourceMode === 'frontmatter' && typeof rawContent === 'string' && rawContent.length > 0) {
          const text = rawContent
          setFullContent(text)
          const { frontmatter, meta, errors } = parseSecretaryMarkdownStrict(text)
          UILogger.debug('JobReportTab', 'Frontmatter (raw): Block gefunden?', { found: !!frontmatter, length: frontmatter ? frontmatter.length : 0 })
          if (!frontmatter) { setFrontmatterMeta(null); return }
          setFrontmatterMeta(Object.keys(meta).length ? meta : null)
          setParseErrors(errors)
          return
        }

        if (!provider) return
        const mdId = (mdFileId || (job?.result?.savedItemId as string | undefined) || fileId)
        UILogger.info('JobReportTab', 'Frontmatter: Lade Datei', { mdId, sourceMode })
        if (!mdId) return
        const bin = await provider.getBinary(mdId)
        const text = await bin.blob.text()
        setFullContent(text)
        const { frontmatter, meta, errors } = parseSecretaryMarkdownStrict(text)
        UILogger.debug('JobReportTab', 'Frontmatter: Block gefunden?', { found: !!frontmatter, length: frontmatter ? frontmatter.length : 0 })
        if (!frontmatter) { setFrontmatterMeta(null); return }
        setFrontmatterMeta(Object.keys(meta).length ? meta : null)
        setParseErrors(errors)
      } catch {
        setFrontmatterMeta(null)
      }
    }
    void loadFrontmatter()
  }, [provider, fileId, mdFileId, job?.result?.savedItemId, sourceMode, rawContent])

  if (sourceMode !== 'frontmatter') {
    if (loading) return <div className="p-4 text-sm text-muted-foreground">Lade Job…</div>
    if (error) return <div className="p-4 text-sm text-destructive">{error}</div>
    if (!job) return <div className="p-4 text-sm text-muted-foreground">Kein Job zur Datei gefunden.</div>
  }

  return (
    <div className="p-4 space-y-3 text-sm">
      {viewMode === 'metaOnly' && (
        <Tabs defaultValue="markdown">
          <TabsList className="grid grid-cols-3 w-full">
            <TabsTrigger value="markdown">Markdown</TabsTrigger>
            <TabsTrigger value="meta">Metadaten</TabsTrigger>
            <TabsTrigger value="chapters">Kapitel</TabsTrigger>
          </TabsList>

          <TabsContent value="markdown" className="mt-3">
            <div className="border rounded-md">
              <MarkdownPreview content={stripFrontmatter(fullContent || '')} />
            </div>
          </TabsContent>

          <TabsContent value="meta" className="mt-3">
            {/* Hinweise zu Parserfehlern (strikt) */}
            {parseErrors.length > 0 && (
              <div className="text-xs text-destructive mb-2">
                {parseErrors.map((e, i) => (<div key={i}>Parserfehler: {e}</div>))}
              </div>
            )}
            {(() => {
              const base: Record<string, unknown> = sourceMode === 'frontmatter'
                ? {}
                : ((job?.cumulativeMeta as unknown as Record<string, unknown>) || {})
              const cm = frontmatterMeta ? { ...base, ...frontmatterMeta } : base
              // confidence/provenance können Objekt oder JSON-String sein → Fallback parse
              const confidence: Record<string, unknown> = (() => {
                const raw = cm['confidence']
                if (raw && typeof raw === 'object') return raw as Record<string, unknown>
                if (typeof raw === 'string') { try { return JSON.parse(raw) as Record<string, unknown> } catch { /* ignore */ } }
                return {}
              })()
              const provenance: Record<string, unknown> = (() => {
                const raw = cm['provenance']
                if (raw && typeof raw === 'object') return raw as Record<string, unknown>
                if (typeof raw === 'string') { try { return JSON.parse(raw) as Record<string, unknown> } catch { /* ignore */ } }
                return {}
              })()
              const hasAnyConfidence = Object.keys(confidence).length > 0
              const baseKeys = Array.isArray(templateFields) && templateFields.length > 0
                ? Array.from(new Set([...(templateFields as string[]), ...Object.keys(cm)]))
                : Object.keys(cm)
              const flatKeys = baseKeys.filter(k => k !== 'chapters' && k !== 'toc' && k !== 'confidence' && k !== 'provenance')
              if (flatKeys.length === 0) return null
              return (
                <div>
                  <div className="font-medium mb-1">Metadaten (Template vs. Ergebnis)</div>
                  <div className="overflow-auto">
                    <table className="w-full text-xs">
                      <thead>
                        <tr className="text-left text-muted-foreground">
                          <th className="py-1 pr-2">Feld</th>
                          <th className="py-1 pr-2">Wert</th>
                          {hasAnyConfidence ? <th className="py-1 pr-2 w-20 text-right">Q</th> : null}
                        </tr>
                      </thead>
                      <tbody>
                        {flatKeys.map((k) => {
                          const val = cm[k]
                          let valueStr = ''
                          if (Array.isArray(val)) valueStr = (val as Array<unknown>).map(v => typeof v === 'string' ? v : JSON.stringify(v)).join(', ')
                          else valueStr = val === null || val === undefined ? '' : typeof val === 'string' ? val : JSON.stringify(val)
                          const cRaw = (confidence as Record<string, unknown>)[k]
                          const cNum = typeof cRaw === 'number' ? cRaw : (typeof cRaw === 'string' && /^\d+(\.\d+)?$/.test(cRaw) ? Number(cRaw) : undefined)
                          const pRaw = (provenance as Record<string, unknown>)[k]
                          const pStr = typeof pRaw === 'string' ? pRaw : pRaw ? JSON.stringify(pRaw) : ''
                          const color = cNum === undefined ? 'text-muted-foreground' : (cNum >= 0.8 ? 'text-green-600' : cNum >= 0.7 ? 'text-yellow-600' : 'text-red-600')
                          return (
                            <tr key={k} className="border-t border-muted/40">
                              <td className="py-1 pr-2 align-top font-medium">{k}</td>
                              <td className="py-1 pr-2 align-top whitespace-pre-wrap break-words">{valueStr}</td>
                              {hasAnyConfidence ? <td className="py-1 pr-2 align-top">
                                {cNum === undefined ? null : (
                                  <TooltipProvider>
                                    <Tooltip>
                                      <TooltipTrigger asChild>
                                        <span className={`inline-flex items-center gap-1 justify-end w-full ${color}`} title={pStr || ''}>
                                          <span className="inline-block h-2 w-2 rounded-full bg-current" />
                                          <span className="tabular-nums">{cNum.toFixed(2)}</span>
                                        </span>
                                      </TooltipTrigger>
                                      {pStr ? (
                                        <TooltipContent>
                                          <div className="max-w-xs whitespace-pre-wrap break-words">{pStr}</div>
                                        </TooltipContent>
                                      ) : null}
                                    </Tooltip>
                                  </TooltipProvider>
                                )}
                              </td> : null}
                            </tr>
                          )
                        })}
                      </tbody>
                    </table>
                  </div>
                </div>
              )
            })()}
          </TabsContent>

          <TabsContent value="chapters" className="mt-3">
            {(() => {
              const chapters: Array<Record<string, unknown>> = sourceMode === 'frontmatter'
                ? (Array.isArray(frontmatterMeta?.chapters) ? (frontmatterMeta?.chapters as Array<Record<string, unknown>>) : [])
                : ((job?.cumulativeMeta as unknown as { chapters?: Array<Record<string, unknown>> })?.chapters || [])
              if (!Array.isArray(chapters) || chapters.length === 0) return null
              const pad = (lvl: number | undefined): number => {
                if (typeof lvl !== 'number') return 0
                const clamped = Math.max(0, Math.min(3, lvl))
                return (clamped - 1) * 16
              }
              const counters = [0, 0, 0]
              return (
                <div className="space-y-1">
                  <div>
                    {chapters.map((c, i) => {
                      const level = typeof c.level === 'number' ? c.level : 1
                      const lvl = Math.max(1, Math.min(3, level))
                      counters[lvl - 1] += 1
                      for (let j = lvl; j < counters.length; j++) counters[j] = 0
                      const numLabel = counters.slice(0, lvl).filter(n => n > 0).join('.')
                      const title = typeof c.title === 'string' ? c.title : ''
                      const startPage = typeof c.startPage === 'number' ? c.startPage : ''
                      const summaryVal = typeof c.summary === 'string' ? c.summary : ''
                      const summary = summaryVal.length > 1000 ? `${summaryVal.slice(0, 1000)}…` : summaryVal
                      const keywords = Array.isArray(c.keywords) ? (c.keywords as Array<unknown>).filter(v => typeof v === 'string') as string[] : []
                      const ev = typeof c.startEvidence === 'string' ? c.startEvidence : ''
                      return (
                        <details key={`${title}-${i}`} className="group border-b py-1" open={false}>
                          <summary className="list-none cursor-pointer">
                            <div className="flex items-start justify-between gap-3">
                              <div className="flex-1 min-w-0" style={{ paddingLeft: `${pad(lvl)}px` }}>
                                <div className="flex items-baseline gap-2">
                                  <span className="text-xs text-muted-foreground tabular-nums">{numLabel}</span>
                                  <span className="font-medium truncate">{title}</span>
                                </div>
                              </div>
                              <div className="text-xs tabular-nums text-muted-foreground whitespace-nowrap">
                                {String(startPage)}
                              </div>
                            </div>
                          </summary>
                          <div className="mt-1 pr-1 text-xs space-y-1" style={{ paddingLeft: `${pad(lvl) + 28}px` }}>
                            {summary && (
                              <div className="whitespace-pre-wrap break-words">
                                {summary}
                              </div>
                            )}
                            {Array.isArray(keywords) && keywords.length > 0 && (
                              <div className="flex flex-wrap gap-1">
                                {keywords.map(k => (
                                  <span key={k} className="inline-flex items-center rounded px-1.5 py-0.5 bg-muted">{k}</span>
                                ))}
                              </div>
                            )}
                          </div>
                        </details>
                      )
                    })}
                  </div>
                </div>
              )
            })()}
          </TabsContent>
        </Tabs>
      )}

      {viewMode === 'full' && job && (
        <div className="flex items-center justify-between">
          <div>
            <div className="font-medium">Job {job.jobId}</div>
            <div className="text-xs text-muted-foreground">{job.job_type} · {job.operation} · {new Date(job.updatedAt).toLocaleString()}</div>
          </div>
          <div className="inline-flex items-center rounded px-2 py-0.5 bg-muted text-xs">{job.status}</div>
        </div>
      )}

      {/* Hinweise zu Parserfehlern (strikt) */}
      {viewMode !== 'metaOnly' && parseErrors.length > 0 && (
        <div className="text-xs text-destructive">
          {parseErrors.map((e, i) => (<div key={i}>Parserfehler: {e}</div>))}
        </div>
      )}

      {/* Template Hinweis (im Frontmatter-only-Modus ausgeblendet) */}
      {sourceMode !== 'frontmatter' && job && typeof job.cumulativeMeta?.template_used === 'string' && (
        <div className="text-xs text-muted-foreground">Template: {String(job.cumulativeMeta.template_used)}</div>
      )}

      {/* Schritte mit Ampel-Logik */}
      {viewMode === 'full' && job && Array.isArray(job.steps) && job.steps.length > 0 && (
        <div>
          <div className="font-medium mb-1">Schritte</div>
          <div className="flex flex-wrap gap-2 text-xs">
            {job.steps.map((s) => {
              // Geplante Phasen ermitteln (neue Flags bevorzugt, sonst phases)
              const p = (job.parameters || {}) as Record<string, unknown>
              const hasNewFlags = typeof p['doExtractPDF'] === 'boolean' || typeof p['doExtractMetadata'] === 'boolean' || typeof p['doIngestRAG'] === 'boolean'
              const phases = hasNewFlags
                ? {
                    extract: p['doExtractPDF'] === true,
                    template: p['doExtractMetadata'] === true,
                    ingest: p['doIngestRAG'] === true,
                  }
                : ((p['phases'] as { extract?: boolean; template?: boolean; ingest?: boolean }) || {})

              const planned = (() => {
                const n = s.name
                if (n === 'extract_pdf') return phases.extract === true
                if (n === 'transform_template' || n === 'store_shadow_twin') return phases.template === true
                if (n === 'ingest_rag') return phases.ingest === true
                return false
              })()

              // Ampel-Status ableiten
              const skipped = !!(s as { details?: { skipped?: boolean } }).details?.skipped
              let icon = '○'
              let cls = 'text-muted-foreground'
              if (s.status === 'failed') { icon = '✕'; cls = 'text-red-600' }
              else if (s.status === 'running') { icon = '◐'; cls = 'text-yellow-600' }
              else if (s.status === 'completed') { icon = skipped ? '○' : '✓'; cls = skipped ? 'text-gray-400' : 'text-green-600' }
              else if (s.status === 'pending') { icon = planned ? '•' : '○'; cls = planned ? 'text-yellow-600' : 'text-muted-foreground' }

              const time = s.endedAt ? new Date(s.endedAt).toLocaleTimeString() : s.startedAt ? new Date(s.startedAt).toLocaleTimeString() : ''
              return (
                <div key={s.name} className={`inline-flex items-center gap-1 px-2 py-1 rounded border ${cls}`}>
                  <span>{icon}</span>
                  <span className="font-medium">{s.name}</span>
                  {time ? <span className="opacity-70">{time}</span> : null}
                </div>
              )
            })}
          </div>
        </div>
      )}

      {/* Metadaten (flach) – je nach sourceMode: nur Frontmatter oder Merge (nur außerhalb metaOnly-View) */}
      {viewMode !== 'metaOnly' && section === 'meta' && (() => {
        const base: Record<string, unknown> = sourceMode === 'frontmatter'
          ? {}
          : ((job?.cumulativeMeta as unknown as Record<string, unknown>) || {})
        const cm = frontmatterMeta ? { ...base, ...frontmatterMeta } : base
        const confidence: Record<string, unknown> = (() => {
          const raw = cm['confidence']
          if (raw && typeof raw === 'object') return raw as Record<string, unknown>
          if (typeof raw === 'string') { try { return JSON.parse(raw) as Record<string, unknown> } catch { /* ignore */ } }
          return {}
        })()
        const provenance: Record<string, unknown> = (() => {
          const raw = cm['provenance']
          if (raw && typeof raw === 'object') return raw as Record<string, unknown>
          if (typeof raw === 'string') { try { return JSON.parse(raw) as Record<string, unknown> } catch { /* ignore */ } }
          return {}
        })()
        const hasAnyConfidence = Object.keys(confidence).length > 0
        const baseKeys = Array.isArray(templateFields) && templateFields.length > 0
          ? Array.from(new Set([...(templateFields as string[]), ...Object.keys(cm)]))
          : Object.keys(cm)
        const flatKeys = baseKeys.filter(k => k !== 'chapters' && k !== 'toc' && k !== 'confidence' && k !== 'provenance')
        if (flatKeys.length === 0) return null
        return (
        <div>
          <div className="font-medium mb-1">Metadaten (Template vs. Ergebnis)</div>
          <div className="overflow-auto">
            <table className="w-full text-xs">
              <thead>
                <tr className="text-left text-muted-foreground">
                  <th className="py-1 pr-2">Feld</th>
                  <th className="py-1 pr-2">Wert</th>
                  {hasAnyConfidence ? <th className="py-1 pr-2 w-20 text-right">Q</th> : null}
                </tr>
              </thead>
              <tbody>
                {flatKeys.map((k) => {
                  const val = cm[k]
                  let valueStr = ''
                  if (Array.isArray(val)) valueStr = (val as Array<unknown>).map(v => typeof v === 'string' ? v : JSON.stringify(v)).join(', ')
                  else valueStr = val === null || val === undefined ? '' : typeof val === 'string' ? val : JSON.stringify(val)
                  const cRaw = (confidence as Record<string, unknown>)[k]
                  const cNum = typeof cRaw === 'number' ? cRaw : (typeof cRaw === 'string' && /^\d+(\.\d+)?$/.test(cRaw) ? Number(cRaw) : undefined)
                  const pRaw = (provenance as Record<string, unknown>)[k]
                  const pStr = typeof pRaw === 'string' ? pRaw : pRaw ? JSON.stringify(pRaw) : ''
                  const color = cNum === undefined ? 'text-muted-foreground' : (cNum >= 0.8 ? 'text-green-600' : cNum >= 0.7 ? 'text-yellow-600' : 'text-red-600')
                  return (
                    <tr key={k} className="border-t border-muted/40">
                      <td className="py-1 pr-2 align-top font-medium">{k}</td>
                      <td className="py-1 pr-2 align-top whitespace-pre-wrap break-words">{valueStr}</td>
                      {hasAnyConfidence ? <td className="py-1 pr-2 align-top">
                        {cNum === undefined ? null : (
                          <TooltipProvider>
                            <Tooltip>
                              <TooltipTrigger asChild>
                                <span className={`inline-flex items-center gap-1 justify-end w-full ${color}`} title={pStr || ''}>
                                  <span className="inline-block h-2 w-2 rounded-full bg-current" />
                                  <span className="tabular-nums">{cNum.toFixed(2)}</span>
                                </span>
                              </TooltipTrigger>
                              {pStr ? (
                                <TooltipContent>
                                  <div className="max-w-xs whitespace-pre-wrap break-words">{pStr}</div>
                                </TooltipContent>
                              ) : null}
                            </Tooltip>
                          </TooltipProvider>
                        )}
                      </td> : null}
                    </tr>
                  )
                })}
              </tbody>
            </table>
          </div>
        </div>
        )
      })()}

      {/* Kapitel (hierarchisch, TOC-Ansicht) – nur außerhalb metaOnly-View */}
      {viewMode !== 'metaOnly' && section === 'chapters' && (() => {
        const chapters: Array<Record<string, unknown>> = sourceMode === 'frontmatter'
          ? (Array.isArray(frontmatterMeta?.chapters) ? (frontmatterMeta?.chapters as Array<Record<string, unknown>>) : [])
          : ((job?.cumulativeMeta as unknown as { chapters?: Array<Record<string, unknown>> })?.chapters || [])
        if (!Array.isArray(chapters) || chapters.length === 0) return null

        const pad = (lvl: number | undefined): number => {
          if (typeof lvl !== 'number') return 0
          const clamped = Math.max(0, Math.min(3, lvl))
          return (clamped - 1) * 16 // px
        }

        // Hierarchische Nummerierung 1., 1.1, 1.1.1 basierend auf level
        const counters = [0, 0, 0]
        return (
        <div className="space-y-1">
          <div className="font-medium mb-1">Kapitel</div>
          <div>
            {chapters.map((c, i) => {
              const level = typeof c.level === 'number' ? c.level : 1
              const lvl = Math.max(1, Math.min(3, level))
              // Zähler aktualisieren
              counters[lvl - 1] += 1
              for (let j = lvl; j < counters.length; j++) counters[j] = 0
              const numLabel = counters.slice(0, lvl).filter(n => n > 0).join('.')
              const title = typeof c.title === 'string' ? c.title : ''
              const startPage = typeof c.startPage === 'number' ? c.startPage : ''
              
              const summaryVal = typeof c.summary === 'string' ? c.summary : ''
              const summary = summaryVal.length > 1000 ? `${summaryVal.slice(0, 1000)}…` : summaryVal
              const keywords = Array.isArray(c.keywords) ? (c.keywords as Array<unknown>).filter(v => typeof v === 'string') as string[] : []
              const ev = typeof c.startEvidence === 'string' ? c.startEvidence : ''
              return (
                <details key={`${title}-${i}`} className="group border-b py-1" open={false} onToggle={(e) => {
                  const open = (e.currentTarget as HTMLDetailsElement).open
                  if (open) {
                    if (startPage !== '') onJumpTo?.({ page: startPage as number | string })
                    else if (ev) onJumpTo?.({ evidence: ev })
                  }
                }}>
                  <summary className="list-none cursor-pointer">
                    <div className="flex items-start justify-between gap-3">
                      <div className="flex-1 min-w-0" style={{ paddingLeft: `${pad(lvl)}px` }}>
                        <div className="flex items-baseline gap-2">
                          <span className="text-xs text-muted-foreground tabular-nums">{numLabel}</span>
                          <span className="font-medium truncate">{title}</span>
                        </div>
                      </div>
                      <div className="text-xs tabular-nums text-muted-foreground whitespace-nowrap">
                        {String(startPage)}
                      </div>
                    </div>
                  </summary>
                  <div className="mt-1 pr-1 text-xs space-y-1" style={{ paddingLeft: `${pad(lvl) + 28}px` }}>
                    {summary && (
                      <div className="whitespace-pre-wrap break-words">
                        {summary}
                      </div>
                    )}
                    {Array.isArray(keywords) && keywords.length > 0 && (
                      <div className="flex flex-wrap gap-1">
                        {keywords.map(k => (
                          <span key={k} className="inline-flex items-center rounded px-1.5 py-0.5 bg-muted">{k}</span>
                        ))}
                      </div>
                    )}
                  </div>
                </details>
              )
            })}
          </div>
        </div>
        )
      })()}

      {/* Inhaltsverzeichnis */}
      {section === 'chapters' && (() => {
        const toc: Array<Record<string, unknown>> = sourceMode === 'frontmatter'
          ? (Array.isArray(frontmatterMeta?.toc) ? (frontmatterMeta?.toc as Array<Record<string, unknown>>) : [])
          : ((job?.cumulativeMeta as unknown as { toc?: Array<Record<string, unknown>> }).toc || [])
        if (!Array.isArray(toc) || toc.length === 0) return null
        return (
        <div>
          <div className="font-medium mb-1">Inhaltsverzeichnis</div>
          <div className="overflow-visible">
            <table className="w-full text-xs">
              <thead>
                <tr className="text-left text-muted-foreground">
                  <th className="py-1 pr-2">Titel</th>
                  <th className="py-1 pr-2">Seite</th>
                  <th className="py-1 pr-2">L</th>
                </tr>
              </thead>
              <tbody>
                {toc.map((t, i) => {
                  const title = typeof t.title === 'string' ? t.title : ''
                  const page = typeof t.page === 'number' ? t.page : ''
                  const level = typeof t.level === 'number' ? t.level : ''
                  return (
                    <tr key={`${title}-${i}`} className="border-t border-muted/40">
                      <td className="py-1 pr-2 align-top whitespace-pre-wrap break-words">{title}</td>
                      <td className="py-1 pr-2 align-top">{page}</td>
                      <td className="py-1 pr-2 align-top">{level}</td>
                    </tr>
                  )
                })}
              </tbody>
            </table>
          </div>
        </div>
        )
      })()}

      {viewMode === 'full' && job && job.ingestion && (
        <div>
          <div className="font-medium mb-1">Ingestion</div>
          <div className="text-xs text-muted-foreground">{job.ingestion.index || '—'} · Vektoren: {job.ingestion.vectorsUpserted ?? '—'} · {job.ingestion.upsertAt ? new Date(job.ingestion.upsertAt).toLocaleString() : '—'}</div>
        </div>
      )}

      {viewMode === 'full' && job && Array.isArray(job.logs) && job.logs.length > 0 && (
        <div>
          <div className="font-medium mb-1">Logs (neueste zuerst)</div>
          <ul className="space-y-0.5 max-h-48 overflow-auto">
            {[...job.logs].reverse().slice(0, 30).map((l, i) => (
              <li key={i} className="text-xs">
                {new Date(l.timestamp).toLocaleTimeString()} · {l.phase || '—'} · {typeof l.progress === 'number' ? `${l.progress}% · ` : ''}{l.message || ''}
              </li>
            ))}
          </ul>
        </div>
      )}

      {/* Parameter am Ende */}
      {viewMode === 'full' && job && job.parameters && (
        <div>
          <div className="font-medium mb-1">Parameter</div>
          <pre className="bg-muted/40 rounded p-2 max-h-32 overflow-auto whitespace-pre-wrap break-words">{JSON.stringify(job.parameters, null, 2)}</pre>
        </div>
      )}
    </div>
  )
}



```

Ich habe die Q‑Indikatoren robuster gemacht:

- `confidence`/`provenance` werden nun auch dann erkannt, wenn sie im Frontmatter als JSON-String statt Objekt stehen. Wir parsen sie opportunistisch.
- Die Spalte „Q“ wird nur eingeblendet, wenn überhaupt Confidence‑Werte vorhanden sind.
- Farb- und Tooltip‑Logik bleibt wie beschrieben.

Bitte Seite neu laden und im Tab „Metadaten“ prüfen:
- Siehst du rechts die Spalte „Q“?
- Bei Hover auf einen Wert sollte ein Tooltip mit der Provenance erscheinen.

Wenn weiterhin keine Spalte auftaucht, poste bitte die exakten Frontmatter‑Zeilen für `confidence:` und `provenance:` (so wie sie in der Datei stehen). Dann passe ich den Fallback gezielt an.

---

**User**

Q ist ausserhalb des sichtbaren bereichs - im DOM sichtbar, nicht aber am Bildschirm.

---

**Cursor**

```typescriptreact
"use client";

import { useEffect, useState } from 'react'
import { UILogger } from '@/lib/debug/logger'
import type { StorageProvider } from '@/lib/storage/types'
import { MarkdownPreview } from '@/components/library/markdown-preview'
import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs'
import { TooltipProvider, Tooltip, TooltipTrigger, TooltipContent } from '@/components/ui/tooltip'
import { parseSecretaryMarkdownStrict } from '@/lib/secretary/response-parser'

interface JobReportTabProps {
  libraryId: string
  fileId: string
  fileName?: string
  provider?: StorageProvider | null
  // Quelle der Metadaten steuern: 'merged' = cumulativeMeta + Frontmatter (Standard),
  // 'frontmatter' = ausschließlich Frontmatter aus Markdown anzeigen
  sourceMode?: 'merged' | 'frontmatter'
  // Darstellungsmodus: 'full' zeigt Kopf/Steps/Logs/Parameter; 'metaOnly' zeigt nur Metadaten/Kapitel/TOC
  viewMode?: 'full' | 'metaOnly'
  // Optional explizite Markdown-Datei-ID (Shadow‑Twin). Überschreibt auto-Erkennung.
  mdFileId?: string | null
  // Optionaler Callback zum Scroll-Sync in die Markdown-Vorschau
  onJumpTo?: (args: { page?: number | string; evidence?: string }) => void
  // NEU: Rohinhalt (Markdown). Wenn gesetzt und sourceMode='frontmatter', wird direkt dieser Text geparst (ohne Datei/JOB).
  rawContent?: string
}

interface JobDto {
  jobId: string
  status: string
  operation: string
  worker: string
  job_type: string
  updatedAt: string
  createdAt: string
  correlation?: { source?: { itemId?: string; name?: string } }
  parameters?: Record<string, unknown>
  steps?: Array<{ name: string; status: string; startedAt?: string; endedAt?: string; error?: { message: string }; details?: { skipped?: boolean } }>
  ingestion?: { vectorsUpserted?: number; index?: string; upsertAt?: string }
  result?: { savedItemId?: string }
  logs?: Array<{ timestamp: string; phase?: string; message?: string; progress?: number }>
  cumulativeMeta?: Record<string, unknown>
}

export function JobReportTab({ libraryId, fileId, fileName, provider, sourceMode = 'merged', viewMode = 'full', mdFileId, onJumpTo, rawContent }: JobReportTabProps) {
  const [loading, setLoading] = useState(false)
  const [error, setError] = useState<string | null>(null)
  const [job, setJob] = useState<JobDto | null>(null)
  const [templateFields, setTemplateFields] = useState<string[] | null>(null)
  const [frontmatterMeta, setFrontmatterMeta] = useState<Record<string, unknown> | null>(null)
  const [section, setSection] = useState<'meta' | 'chapters'>('meta')
  const [parseErrors, setParseErrors] = useState<string[]>([])
  const [fullContent, setFullContent] = useState<string>('')

  const stripFrontmatter = (markdown: string): string => markdown.replace(/^---\r?\n([\s\S]*?)\r?\n---\r?\n?/, '')

  useEffect(() => {
    let cancelled = false
    async function run() {
      try {
        // Wenn wir Rohinhalt haben und nur Frontmatter zeigen, brauchen wir keine Job-Suche
        if (sourceMode === 'frontmatter' && typeof rawContent === 'string' && rawContent.length > 0) {
          setJob(null)
          setLoading(false)
          setError(null)
          return
        }
        setLoading(true)
        setError(null)
        UILogger.info('JobReportTab', 'Start Job-Suche', { libraryId, fileId })
        // 1) Versuche Job über result.savedItemId (Shadow‑Twin) zu finden
        const byResultUrl = new URL(`/api/external/jobs`, window.location.origin)
        byResultUrl.searchParams.set('byResultItemId', fileId)
        UILogger.debug('JobReportTab', 'Request byResultItemId', { url: byResultUrl.toString() })
        let res = await fetch(byResultUrl.toString(), { cache: 'no-store' })
        let data = await res.json()
        if (!res.ok) throw new Error(typeof data?.error === 'string' ? data.error : 'Job-Suche fehlgeschlagen')
        let j: JobDto | null = Array.isArray(data?.items) && data.items.length > 0 ? (data.items[0] as JobDto) : null
        UILogger.debug('JobReportTab', 'Result byResultItemId', { count: Array.isArray(data?.items) ? data.items.length : 0 })

        // 2) Fallback: über correlation.source.itemId (Originaldatei)
        if (!j) {
          const bySourceUrl = new URL(`/api/external/jobs`, window.location.origin)
          bySourceUrl.searchParams.set('bySourceItemId', fileId)
          bySourceUrl.searchParams.set('libraryId', libraryId)
          UILogger.debug('JobReportTab', 'Request bySourceItemId', { url: bySourceUrl.toString() })
          res = await fetch(bySourceUrl.toString(), { cache: 'no-store' })
          data = await res.json()
          if (!res.ok) throw new Error(typeof data?.error === 'string' ? data.error : 'Job-Suche (Quelle) fehlgeschlagen')
          j = Array.isArray(data?.items) && data.items.length > 0 ? (data.items[0] as JobDto) : null
          UILogger.debug('JobReportTab', 'Result bySourceItemId', { count: Array.isArray(data?.items) ? data.items.length : 0 })
        }

        // 3) Fallback: über correlation.source.name (Dateiname der Quelle)
        if (!j) {
          const byNameUrl = new URL(`/api/external/jobs`, window.location.origin)
          // Wenn wir den tatsächlichen Dateinamen kennen, verwende ihn.
          // Für Shadow‑Twins (z. B. name.de.md) versuche das Basis‑PDF (name.pdf).
          let candidate = (fileName && typeof fileName === 'string') ? fileName : (fileId.includes('/') ? (fileId.split('/').pop() as string) : fileId)
          const parts = candidate.split('.')
          if (parts.length >= 3) {
            const ext1 = parts[parts.length - 1].toLowerCase()
            const ext2 = parts[parts.length - 2].toLowerCase()
            if ((ext1 === 'md' || ext1 === 'mdx') && /^[a-z]{2}$/i.test(ext2)) {
              candidate = parts.slice(0, -2).join('.') + '.pdf'
            }
          }
          byNameUrl.searchParams.set('bySourceName', candidate)
          byNameUrl.searchParams.set('libraryId', libraryId)
          UILogger.debug('JobReportTab', 'Request bySourceName', { url: byNameUrl.toString(), nameOnly: candidate, originalFileName: fileName })
          res = await fetch(byNameUrl.toString(), { cache: 'no-store' })
          data = await res.json()
          if (!res.ok) throw new Error(typeof data?.error === 'string' ? data.error : 'Job-Suche (Name) fehlgeschlagen')
          j = Array.isArray(data?.items) && data.items.length > 0 ? (data.items[0] as JobDto) : null
          UILogger.debug('JobReportTab', 'Result bySourceName', { count: Array.isArray(data?.items) ? data.items.length : 0 })
        }

        if (!cancelled) setJob(j)
        if (j) UILogger.info('JobReportTab', 'Job gefunden', { jobId: j.jobId, status: j.status })
        else UILogger.warn('JobReportTab', 'Kein Job gefunden', { libraryId, fileId })
      } catch (e) {
        const msg = e instanceof Error ? e.message : 'Unbekannter Fehler'
        UILogger.error('JobReportTab', 'Job-Suche fehlgeschlagen', e)
        if (!cancelled) setError(msg)
      } finally {
        if (!cancelled) setLoading(false)
      }
    }
    void run()
    return () => { cancelled = true }
  }, [libraryId, fileId, fileName, sourceMode, rawContent])

  // Wenn Template benutzt wurde, lade dessen Inhalt aus /templates und extrahiere Frontmatter-Schlüssel
  useEffect(() => {
    async function loadTemplateFields() {
      try {
        setTemplateFields(null)
        const tpl = job?.cumulativeMeta && typeof (job.cumulativeMeta as unknown) === 'object'
          ? (job.cumulativeMeta as Record<string, unknown>)['template_used']
          : undefined
        const templateName = typeof tpl === 'string' ? tpl : undefined
        if (!templateName || !provider) return
        const rootItems = await provider.listItemsById('root')
        const templatesFolder = rootItems.find(it => it.type === 'folder' && typeof (it as { metadata?: { name?: string } }).metadata?.name === 'string' && ((it as { metadata: { name: string } }).metadata.name.toLowerCase() === 'templates'))
        if (!templatesFolder) return
        const tplItems = await provider.listItemsById(templatesFolder.id)
        const match = tplItems.find(it => it.type === 'file' && ((it as { metadata: { name: string } }).metadata.name.toLowerCase() === templateName.toLowerCase()))
        if (!match) return
        const bin = await provider.getBinary(match.id)
        const text = await bin.blob.text()
        // Extrahiere Frontmatter zwischen den ersten beiden --- und lese die Keys bis zu :
        const m = text.match(/^---[\s\S]*?---/)
        if (!m) return
        const fm = m[0]
        const keys: string[] = []
        for (const line of fm.split('\n')) {
          const t = line.trim()
          if (!t || t === '---') continue
          const idx = t.indexOf(':')
          if (idx > 0) {
            const k = t.slice(0, idx).trim()
            if (k) keys.push(k)
          }
        }
        setTemplateFields(Array.from(new Set(keys)))
      } catch (e) {
        UILogger.warn('JobReportTab', 'Template-Felder konnten nicht geladen werden', { error: e instanceof Error ? e.message : String(e) })
      }
    }
    void loadTemplateFields()
  }, [job, provider])

  // Gemeinsamer strikter Parser
  const strictParseFrontmatter = (fm: string) => parseSecretaryMarkdownStrict(fm)

  // Frontmatter aus der gespeicherten Markdown-Datei lesen (oder aus rawContent)
  useEffect(() => {
    async function loadFrontmatter() {
      try {
        setParseErrors([])
        // Wenn roher Inhalt übergeben wurde, direkt daraus lesen
        if (sourceMode === 'frontmatter' && typeof rawContent === 'string' && rawContent.length > 0) {
          const text = rawContent
          setFullContent(text)
          const { frontmatter, meta, errors } = parseSecretaryMarkdownStrict(text)
          UILogger.debug('JobReportTab', 'Frontmatter (raw): Block gefunden?', { found: !!frontmatter, length: frontmatter ? frontmatter.length : 0 })
          if (!frontmatter) { setFrontmatterMeta(null); return }
          setFrontmatterMeta(Object.keys(meta).length ? meta : null)
          setParseErrors(errors)
          return
        }

        if (!provider) return
        const mdId = (mdFileId || (job?.result?.savedItemId as string | undefined) || fileId)
        UILogger.info('JobReportTab', 'Frontmatter: Lade Datei', { mdId, sourceMode })
        if (!mdId) return
        const bin = await provider.getBinary(mdId)
        const text = await bin.blob.text()
        setFullContent(text)
        const { frontmatter, meta, errors } = parseSecretaryMarkdownStrict(text)
        UILogger.debug('JobReportTab', 'Frontmatter: Block gefunden?', { found: !!frontmatter, length: frontmatter ? frontmatter.length : 0 })
        if (!frontmatter) { setFrontmatterMeta(null); return }
        setFrontmatterMeta(Object.keys(meta).length ? meta : null)
        setParseErrors(errors)
      } catch {
        setFrontmatterMeta(null)
      }
    }
    void loadFrontmatter()
  }, [provider, fileId, mdFileId, job?.result?.savedItemId, sourceMode, rawContent])

  if (sourceMode !== 'frontmatter') {
    if (loading) return <div className="p-4 text-sm text-muted-foreground">Lade Job…</div>
    if (error) return <div className="p-4 text-sm text-destructive">{error}</div>
    if (!job) return <div className="p-4 text-sm text-muted-foreground">Kein Job zur Datei gefunden.</div>
  }

  return (
    <div className="p-4 space-y-3 text-sm">
      {viewMode === 'metaOnly' && (
        <Tabs defaultValue="markdown">
          <TabsList className="grid grid-cols-3 w-full">
            <TabsTrigger value="markdown">Markdown</TabsTrigger>
            <TabsTrigger value="meta">Metadaten</TabsTrigger>
            <TabsTrigger value="chapters">Kapitel</TabsTrigger>
          </TabsList>

          <TabsContent value="markdown" className="mt-3">
            <div className="border rounded-md">
              <MarkdownPreview content={stripFrontmatter(fullContent || '')} />
            </div>
          </TabsContent>

          <TabsContent value="meta" className="mt-3">
            {/* Hinweise zu Parserfehlern (strikt) */}
            {parseErrors.length > 0 && (
              <div className="text-xs text-destructive mb-2">
                {parseErrors.map((e, i) => (<div key={i}>Parserfehler: {e}</div>))}
              </div>
            )}
            {(() => {
              const base: Record<string, unknown> = sourceMode === 'frontmatter'
                ? {}
                : ((job?.cumulativeMeta as unknown as Record<string, unknown>) || {})
              const cm = frontmatterMeta ? { ...base, ...frontmatterMeta } : base
              // confidence/provenance können Objekt oder JSON-String sein → Fallback parse
              const confidence: Record<string, unknown> = (() => {
                const raw = cm['confidence']
                if (raw && typeof raw === 'object') return raw as Record<string, unknown>
                if (typeof raw === 'string') { try { return JSON.parse(raw) as Record<string, unknown> } catch { /* ignore */ } }
                return {}
              })()
              const provenance: Record<string, unknown> = (() => {
                const raw = cm['provenance']
                if (raw && typeof raw === 'object') return raw as Record<string, unknown>
                if (typeof raw === 'string') { try { return JSON.parse(raw) as Record<string, unknown> } catch { /* ignore */ } }
                return {}
              })()
              const hasAnyConfidence = Object.keys(confidence).length > 0
              const baseKeys = Array.isArray(templateFields) && templateFields.length > 0
                ? Array.from(new Set([...(templateFields as string[]), ...Object.keys(cm)]))
                : Object.keys(cm)
              const flatKeys = baseKeys.filter(k => k !== 'chapters' && k !== 'toc' && k !== 'confidence' && k !== 'provenance')
              if (flatKeys.length === 0) return null
              return (
                <div>
                  <div className="font-medium mb-1">Metadaten (Template vs. Ergebnis)</div>
                  <div className="overflow-auto">
                    <table className="w-full text-xs">
                      <thead>
                        <tr className="text-left text-muted-foreground">
                          <th className="py-1 pr-2">Feld</th>
                          <th className="py-1 pr-2">Wert</th>
                          {hasAnyConfidence ? <th className="py-1 pr-2 w-20 text-right sticky right-0 bg-background border-l">Q</th> : null}
                        </tr>
                      </thead>
                      <tbody>
                        {flatKeys.map((k) => {
                          const val = cm[k]
                          let valueStr = ''
                          if (Array.isArray(val)) valueStr = (val as Array<unknown>).map(v => typeof v === 'string' ? v : JSON.stringify(v)).join(', ')
                          else valueStr = val === null || val === undefined ? '' : typeof val === 'string' ? val : JSON.stringify(val)
                          const cRaw = (confidence as Record<string, unknown>)[k]
                          const cNum = typeof cRaw === 'number' ? cRaw : (typeof cRaw === 'string' && /^\d+(\.\d+)?$/.test(cRaw) ? Number(cRaw) : undefined)
                          const pRaw = (provenance as Record<string, unknown>)[k]
                          const pStr = typeof pRaw === 'string' ? pRaw : pRaw ? JSON.stringify(pRaw) : ''
                          const color = cNum === undefined ? 'text-muted-foreground' : (cNum >= 0.8 ? 'text-green-600' : cNum >= 0.7 ? 'text-yellow-600' : 'text-red-600')
                          return (
                            <tr key={k} className="border-t border-muted/40">
                              <td className="py-1 pr-2 align-top font-medium">{k}</td>
                              <td className="py-1 pr-2 align-top whitespace-pre-wrap break-words">{valueStr}</td>
                              {hasAnyConfidence ? <td className="py-1 pr-2 align-top sticky right-0 bg-background border-l">
                                {cNum === undefined ? null : (
                                  <TooltipProvider>
                                    <Tooltip>
                                      <TooltipTrigger asChild>
                                        <span className={`inline-flex items-center gap-1 justify-end w-full ${color}`} title={pStr || ''}>
                                          <span className="inline-block h-2 w-2 rounded-full bg-current" />
                                          <span className="tabular-nums">{cNum.toFixed(2)}</span>
                                        </span>
                                      </TooltipTrigger>
                                      {pStr ? (
                                        <TooltipContent>
                                          <div className="max-w-xs whitespace-pre-wrap break-words">{pStr}</div>
                                        </TooltipContent>
                                      ) : null}
                                    </Tooltip>
                                  </TooltipProvider>
                                )}
                              </td> : null}
                            </tr>
                          )
                        })}
                      </tbody>
                    </table>
                  </div>
                </div>
              )
            })()}
          </TabsContent>

          <TabsContent value="chapters" className="mt-3">
            {(() => {
              const chapters: Array<Record<string, unknown>> = sourceMode === 'frontmatter'
                ? (Array.isArray(frontmatterMeta?.chapters) ? (frontmatterMeta?.chapters as Array<Record<string, unknown>>) : [])
                : ((job?.cumulativeMeta as unknown as { chapters?: Array<Record<string, unknown>> })?.chapters || [])
              if (!Array.isArray(chapters) || chapters.length === 0) return null
              const pad = (lvl: number | undefined): number => {
                if (typeof lvl !== 'number') return 0
                const clamped = Math.max(0, Math.min(3, lvl))
                return (clamped - 1) * 16
              }
              const counters = [0, 0, 0]
              return (
                <div className="space-y-1">
                  <div>
                    {chapters.map((c, i) => {
                      const level = typeof c.level === 'number' ? c.level : 1
                      const lvl = Math.max(1, Math.min(3, level))
                      counters[lvl - 1] += 1
                      for (let j = lvl; j < counters.length; j++) counters[j] = 0
                      const numLabel = counters.slice(0, lvl).filter(n => n > 0).join('.')
                      const title = typeof c.title === 'string' ? c.title : ''
                      const startPage = typeof c.startPage === 'number' ? c.startPage : ''
                      const summaryVal = typeof c.summary === 'string' ? c.summary : ''
                      const summary = summaryVal.length > 1000 ? `${summaryVal.slice(0, 1000)}…` : summaryVal
                      const keywords = Array.isArray(c.keywords) ? (c.keywords as Array<unknown>).filter(v => typeof v === 'string') as string[] : []
                      const ev = typeof c.startEvidence === 'string' ? c.startEvidence : ''
                      return (
                        <details key={`${title}-${i}`} className="group border-b py-1" open={false}>
                          <summary className="list-none cursor-pointer">
                            <div className="flex items-start justify-between gap-3">
                              <div className="flex-1 min-w-0" style={{ paddingLeft: `${pad(lvl)}px` }}>
                                <div className="flex items-baseline gap-2">
                                  <span className="text-xs text-muted-foreground tabular-nums">{numLabel}</span>
                                  <span className="font-medium truncate">{title}</span>
                                </div>
                              </div>
                              <div className="text-xs tabular-nums text-muted-foreground whitespace-nowrap">
                                {String(startPage)}
                              </div>
                            </div>
                          </summary>
                          <div className="mt-1 pr-1 text-xs space-y-1" style={{ paddingLeft: `${pad(lvl) + 28}px` }}>
                            {summary && (
                              <div className="whitespace-pre-wrap break-words">
                                {summary}
                              </div>
                            )}
                            {Array.isArray(keywords) && keywords.length > 0 && (
                              <div className="flex flex-wrap gap-1">
                                {keywords.map(k => (
                                  <span key={k} className="inline-flex items-center rounded px-1.5 py-0.5 bg-muted">{k}</span>
                                ))}
                              </div>
                            )}
                          </div>
                        </details>
                      )
                    })}
                  </div>
                </div>
              )
            })()}
          </TabsContent>
        </Tabs>
      )}

      {viewMode === 'full' && job && (
        <div className="flex items-center justify-between">
          <div>
            <div className="font-medium">Job {job.jobId}</div>
            <div className="text-xs text-muted-foreground">{job.job_type} · {job.operation} · {new Date(job.updatedAt).toLocaleString()}</div>
          </div>
          <div className="inline-flex items-center rounded px-2 py-0.5 bg-muted text-xs">{job.status}</div>
        </div>
      )}

      {/* Hinweise zu Parserfehlern (strikt) */}
      {viewMode !== 'metaOnly' && parseErrors.length > 0 && (
        <div className="text-xs text-destructive">
          {parseErrors.map((e, i) => (<div key={i}>Parserfehler: {e}</div>))}
        </div>
      )}

      {/* Template Hinweis (im Frontmatter-only-Modus ausgeblendet) */}
      {sourceMode !== 'frontmatter' && job && typeof job.cumulativeMeta?.template_used === 'string' && (
        <div className="text-xs text-muted-foreground">Template: {String(job.cumulativeMeta.template_used)}</div>
      )}

      {/* Schritte mit Ampel-Logik */}
      {viewMode === 'full' && job && Array.isArray(job.steps) && job.steps.length > 0 && (
        <div>
          <div className="font-medium mb-1">Schritte</div>
          <div className="flex flex-wrap gap-2 text-xs">
            {job.steps.map((s) => {
              // Geplante Phasen ermitteln (neue Flags bevorzugt, sonst phases)
              const p = (job.parameters || {}) as Record<string, unknown>
              const hasNewFlags = typeof p['doExtractPDF'] === 'boolean' || typeof p['doExtractMetadata'] === 'boolean' || typeof p['doIngestRAG'] === 'boolean'
              const phases = hasNewFlags
                ? {
                    extract: p['doExtractPDF'] === true,
                    template: p['doExtractMetadata'] === true,
                    ingest: p['doIngestRAG'] === true,
                  }
                : ((p['phases'] as { extract?: boolean; template?: boolean; ingest?: boolean }) || {})

              const planned = (() => {
                const n = s.name
                if (n === 'extract_pdf') return phases.extract === true
                if (n === 'transform_template' || n === 'store_shadow_twin') return phases.template === true
                if (n === 'ingest_rag') return phases.ingest === true
                return false
              })()

              // Ampel-Status ableiten
              const skipped = !!(s as { details?: { skipped?: boolean } }).details?.skipped
              let icon = '○'
              let cls = 'text-muted-foreground'
              if (s.status === 'failed') { icon = '✕'; cls = 'text-red-600' }
              else if (s.status === 'running') { icon = '◐'; cls = 'text-yellow-600' }
              else if (s.status === 'completed') { icon = skipped ? '○' : '✓'; cls = skipped ? 'text-gray-400' : 'text-green-600' }
              else if (s.status === 'pending') { icon = planned ? '•' : '○'; cls = planned ? 'text-yellow-600' : 'text-muted-foreground' }

              const time = s.endedAt ? new Date(s.endedAt).toLocaleTimeString() : s.startedAt ? new Date(s.startedAt).toLocaleTimeString() : ''
              return (
                <div key={s.name} className={`inline-flex items-center gap-1 px-2 py-1 rounded border ${cls}`}>
                  <span>{icon}</span>
                  <span className="font-medium">{s.name}</span>
                  {time ? <span className="opacity-70">{time}</span> : null}
                </div>
              )
            })}
          </div>
        </div>
      )}

      {/* Metadaten (flach) – je nach sourceMode: nur Frontmatter oder Merge (nur außerhalb metaOnly-View) */}
      {viewMode !== 'metaOnly' && section === 'meta' && (() => {
        const base: Record<string, unknown> = sourceMode === 'frontmatter'
          ? {}
          : ((job?.cumulativeMeta as unknown as Record<string, unknown>) || {})
        const cm = frontmatterMeta ? { ...base, ...frontmatterMeta } : base
        const confidence: Record<string, unknown> = (() => {
          const raw = cm['confidence']
          if (raw && typeof raw === 'object') return raw as Record<string, unknown>
          if (typeof raw === 'string') { try { return JSON.parse(raw) as Record<string, unknown> } catch { /* ignore */ } }
          return {}
        })()
        const provenance: Record<string, unknown> = (() => {
          const raw = cm['provenance']
          if (raw && typeof raw === 'object') return raw as Record<string, unknown>
          if (typeof raw === 'string') { try { return JSON.parse(raw) as Record<string, unknown> } catch { /* ignore */ } }
          return {}
        })()
        const hasAnyConfidence = Object.keys(confidence).length > 0
        const baseKeys = Array.isArray(templateFields) && templateFields.length > 0
          ? Array.from(new Set([...(templateFields as string[]), ...Object.keys(cm)]))
          : Object.keys(cm)
        const flatKeys = baseKeys.filter(k => k !== 'chapters' && k !== 'toc' && k !== 'confidence' && k !== 'provenance')
        if (flatKeys.length === 0) return null
        return (
        <div>
          <div className="font-medium mb-1">Metadaten (Template vs. Ergebnis)</div>
          <div className="overflow-auto">
            <table className="w-full text-xs">
              <thead>
                <tr className="text-left text-muted-foreground">
                  <th className="py-1 pr-2">Feld</th>
                  <th className="py-1 pr-2">Wert</th>
                  {hasAnyConfidence ? <th className="py-1 pr-2 w-20 text-right">Q</th> : null}
                </tr>
              </thead>
              <tbody>
                {flatKeys.map((k) => {
                  const val = cm[k]
                  let valueStr = ''
                  if (Array.isArray(val)) valueStr = (val as Array<unknown>).map(v => typeof v === 'string' ? v : JSON.stringify(v)).join(', ')
                  else valueStr = val === null || val === undefined ? '' : typeof val === 'string' ? val : JSON.stringify(val)
                  const cRaw = (confidence as Record<string, unknown>)[k]
                  const cNum = typeof cRaw === 'number' ? cRaw : (typeof cRaw === 'string' && /^\d+(\.\d+)?$/.test(cRaw) ? Number(cRaw) : undefined)
                  const pRaw = (provenance as Record<string, unknown>)[k]
                  const pStr = typeof pRaw === 'string' ? pRaw : pRaw ? JSON.stringify(pRaw) : ''
                  const color = cNum === undefined ? 'text-muted-foreground' : (cNum >= 0.8 ? 'text-green-600' : cNum >= 0.7 ? 'text-yellow-600' : 'text-red-600')
                  return (
                    <tr key={k} className="border-t border-muted/40">
                      <td className="py-1 pr-2 align-top font-medium">{k}</td>
                      <td className="py-1 pr-2 align-top whitespace-pre-wrap break-words">{valueStr}</td>
                      {hasAnyConfidence ? <td className="py-1 pr-2 align-top">
                        {cNum === undefined ? null : (
                          <TooltipProvider>
                            <Tooltip>
                              <TooltipTrigger asChild>
                                <span className={`inline-flex items-center gap-1 justify-end w-full ${color}`} title={pStr || ''}>
                                  <span className="inline-block h-2 w-2 rounded-full bg-current" />
                                  <span className="tabular-nums">{cNum.toFixed(2)}</span>
                                </span>
                              </TooltipTrigger>
                              {pStr ? (
                                <TooltipContent>
                                  <div className="max-w-xs whitespace-pre-wrap break-words">{pStr}</div>
                                </TooltipContent>
                              ) : null}
                            </Tooltip>
                          </TooltipProvider>
                        )}
                      </td> : null}
                    </tr>
                  )
                })}
              </tbody>
            </table>
          </div>
        </div>
        )
      })()}

      {/* Kapitel (hierarchisch, TOC-Ansicht) – nur außerhalb metaOnly-View */}
      {viewMode !== 'metaOnly' && section === 'chapters' && (() => {
        const chapters: Array<Record<string, unknown>> = sourceMode === 'frontmatter'
          ? (Array.isArray(frontmatterMeta?.chapters) ? (frontmatterMeta?.chapters as Array<Record<string, unknown>>) : [])
          : ((job?.cumulativeMeta as unknown as { chapters?: Array<Record<string, unknown>> })?.chapters || [])
        if (!Array.isArray(chapters) || chapters.length === 0) return null

        const pad = (lvl: number | undefined): number => {
          if (typeof lvl !== 'number') return 0
          const clamped = Math.max(0, Math.min(3, lvl))
          return (clamped - 1) * 16 // px
        }

        // Hierarchische Nummerierung 1., 1.1, 1.1.1 basierend auf level
        const counters = [0, 0, 0]
        return (
        <div className="space-y-1">
          <div className="font-medium mb-1">Kapitel</div>
          <div>
            {chapters.map((c, i) => {
              const level = typeof c.level === 'number' ? c.level : 1
              const lvl = Math.max(1, Math.min(3, level))
              // Zähler aktualisieren
              counters[lvl - 1] += 1
              for (let j = lvl; j < counters.length; j++) counters[j] = 0
              const numLabel = counters.slice(0, lvl).filter(n => n > 0).join('.')
              const title = typeof c.title === 'string' ? c.title : ''
              const startPage = typeof c.startPage === 'number' ? c.startPage : ''
              
              const summaryVal = typeof c.summary === 'string' ? c.summary : ''
              const summary = summaryVal.length > 1000 ? `${summaryVal.slice(0, 1000)}…` : summaryVal
              const keywords = Array.isArray(c.keywords) ? (c.keywords as Array<unknown>).filter(v => typeof v === 'string') as string[] : []
              const ev = typeof c.startEvidence === 'string' ? c.startEvidence : ''
              return (
                <details key={`${title}-${i}`} className="group border-b py-1" open={false} onToggle={(e) => {
                  const open = (e.currentTarget as HTMLDetailsElement).open
                  if (open) {
                    if (startPage !== '') onJumpTo?.({ page: startPage as number | string })
                    else if (ev) onJumpTo?.({ evidence: ev })
                  }
                }}>
                  <summary className="list-none cursor-pointer">
                    <div className="flex items-start justify-between gap-3">
                      <div className="flex-1 min-w-0" style={{ paddingLeft: `${pad(lvl)}px` }}>
                        <div className="flex items-baseline gap-2">
                          <span className="text-xs text-muted-foreground tabular-nums">{numLabel}</span>
                          <span className="font-medium truncate">{title}</span>
                        </div>
                      </div>
                      <div className="text-xs tabular-nums text-muted-foreground whitespace-nowrap">
                        {String(startPage)}
                      </div>
                    </div>
                  </summary>
                  <div className="mt-1 pr-1 text-xs space-y-1" style={{ paddingLeft: `${pad(lvl) + 28}px` }}>
                    {summary && (
                      <div className="whitespace-pre-wrap break-words">
                        {summary}
                      </div>
                    )}
                    {Array.isArray(keywords) && keywords.length > 0 && (
                      <div className="flex flex-wrap gap-1">
                        {keywords.map(k => (
                          <span key={k} className="inline-flex items-center rounded px-1.5 py-0.5 bg-muted">{k}</span>
                        ))}
                      </div>
                    )}
                  </div>
                </details>
              )
            })}
          </div>
        </div>
        )
      })()}

      {/* Inhaltsverzeichnis */}
      {section === 'chapters' && (() => {
        const toc: Array<Record<string, unknown>> = sourceMode === 'frontmatter'
          ? (Array.isArray(frontmatterMeta?.toc) ? (frontmatterMeta?.toc as Array<Record<string, unknown>>) : [])
          : ((job?.cumulativeMeta as unknown as { toc?: Array<Record<string, unknown>> }).toc || [])
        if (!Array.isArray(toc) || toc.length === 0) return null
        return (
        <div>
          <div className="font-medium mb-1">Inhaltsverzeichnis</div>
          <div className="overflow-visible">
            <table className="w-full text-xs">
              <thead>
                <tr className="text-left text-muted-foreground">
                  <th className="py-1 pr-2">Titel</th>
                  <th className="py-1 pr-2">Seite</th>
                  <th className="py-1 pr-2">L</th>
                </tr>
              </thead>
              <tbody>
                {toc.map((t, i) => {
                  const title = typeof t.title === 'string' ? t.title : ''
                  const page = typeof t.page === 'number' ? t.page : ''
                  const level = typeof t.level === 'number' ? t.level : ''
                  return (
                    <tr key={`${title}-${i}`} className="border-t border-muted/40">
                      <td className="py-1 pr-2 align-top whitespace-pre-wrap break-words">{title}</td>
                      <td className="py-1 pr-2 align-top">{page}</td>
                      <td className="py-1 pr-2 align-top">{level}</td>
                    </tr>
                  )
                })}
              </tbody>
            </table>
          </div>
        </div>
        )
      })()}

      {viewMode === 'full' && job && job.ingestion && (
        <div>
          <div className="font-medium mb-1">Ingestion</div>
          <div className="text-xs text-muted-foreground">{job.ingestion.index || '—'} · Vektoren: {job.ingestion.vectorsUpserted ?? '—'} · {job.ingestion.upsertAt ? new Date(job.ingestion.upsertAt).toLocaleString() : '—'}</div>
        </div>
      )}

      {viewMode === 'full' && job && Array.isArray(job.logs) && job.logs.length > 0 && (
        <div>
          <div className="font-medium mb-1">Logs (neueste zuerst)</div>
          <ul className="space-y-0.5 max-h-48 overflow-auto">
            {[...job.logs].reverse().slice(0, 30).map((l, i) => (
              <li key={i} className="text-xs">
                {new Date(l.timestamp).toLocaleTimeString()} · {l.phase || '—'} · {typeof l.progress === 'number' ? `${l.progress}% · ` : ''}{l.message || ''}
              </li>
            ))}
          </ul>
        </div>
      )}

      {/* Parameter am Ende */}
      {viewMode === 'full' && job && job.parameters && (
        <div>
          <div className="font-medium mb-1">Parameter</div>
          <pre className="bg-muted/40 rounded p-2 max-h-32 overflow-auto whitespace-pre-wrap break-words">{JSON.stringify(job.parameters, null, 2)}</pre>
        </div>
      )}
    </div>
  )
}



```

Ich habe die „Q“-Spalte fixiert, damit sie im Sichtbereich bleibt:
- Tabellenkopf/Spalte „Q“ ist jetzt sticky am rechten Rand (`sticky right-0 bg-background border-l`).
- Auch die Zellen sind sticky, damit der Indikator beim horizontalen Scrollen sichtbar bleibt.

Bitte neu laden und testen:
- Metadaten-Tab öffnen.
- Horizontal scrollen: Die „Q“-Spalte sollte rechts feststehen und immer sichtbar sein.
- Hover zeigt weiterhin den Provenance‑Tooltip.

---

**User**

ok, jetzt sehe ich sie, bitte nur Punkz belassen - Zahl und Provenance in tooltip ausgeben. Kolonne auf minimale Breite von 6 px formattieren

---

**Cursor**

```typescriptreact
"use client";

import { useEffect, useState } from 'react'
import { UILogger } from '@/lib/debug/logger'
import type { StorageProvider } from '@/lib/storage/types'
import { MarkdownPreview } from '@/components/library/markdown-preview'
import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs'
import { TooltipProvider, Tooltip, TooltipTrigger, TooltipContent } from '@/components/ui/tooltip'
import { parseSecretaryMarkdownStrict } from '@/lib/secretary/response-parser'

interface JobReportTabProps {
  libraryId: string
  fileId: string
  fileName?: string
  provider?: StorageProvider | null
  // Quelle der Metadaten steuern: 'merged' = cumulativeMeta + Frontmatter (Standard),
  // 'frontmatter' = ausschließlich Frontmatter aus Markdown anzeigen
  sourceMode?: 'merged' | 'frontmatter'
  // Darstellungsmodus: 'full' zeigt Kopf/Steps/Logs/Parameter; 'metaOnly' zeigt nur Metadaten/Kapitel/TOC
  viewMode?: 'full' | 'metaOnly'
  // Optional explizite Markdown-Datei-ID (Shadow‑Twin). Überschreibt auto-Erkennung.
  mdFileId?: string | null
  // Optionaler Callback zum Scroll-Sync in die Markdown-Vorschau
  onJumpTo?: (args: { page?: number | string; evidence?: string }) => void
  // NEU: Rohinhalt (Markdown). Wenn gesetzt und sourceMode='frontmatter', wird direkt dieser Text geparst (ohne Datei/JOB).
  rawContent?: string
}

interface JobDto {
  jobId: string
  status: string
  operation: string
  worker: string
  job_type: string
  updatedAt: string
  createdAt: string
  correlation?: { source?: { itemId?: string; name?: string } }
  parameters?: Record<string, unknown>
  steps?: Array<{ name: string; status: string; startedAt?: string; endedAt?: string; error?: { message: string }; details?: { skipped?: boolean } }>
  ingestion?: { vectorsUpserted?: number; index?: string; upsertAt?: string }
  result?: { savedItemId?: string }
  logs?: Array<{ timestamp: string; phase?: string; message?: string; progress?: number }>
  cumulativeMeta?: Record<string, unknown>
}

export function JobReportTab({ libraryId, fileId, fileName, provider, sourceMode = 'merged', viewMode = 'full', mdFileId, onJumpTo, rawContent }: JobReportTabProps) {
  const [loading, setLoading] = useState(false)
  const [error, setError] = useState<string | null>(null)
  const [job, setJob] = useState<JobDto | null>(null)
  const [templateFields, setTemplateFields] = useState<string[] | null>(null)
  const [frontmatterMeta, setFrontmatterMeta] = useState<Record<string, unknown> | null>(null)
  const [section, setSection] = useState<'meta' | 'chapters'>('meta')
  const [parseErrors, setParseErrors] = useState<string[]>([])
  const [fullContent, setFullContent] = useState<string>('')

  const stripFrontmatter = (markdown: string): string => markdown.replace(/^---\r?\n([\s\S]*?)\r?\n---\r?\n?/, '')

  useEffect(() => {
    let cancelled = false
    async function run() {
      try {
        // Wenn wir Rohinhalt haben und nur Frontmatter zeigen, brauchen wir keine Job-Suche
        if (sourceMode === 'frontmatter' && typeof rawContent === 'string' && rawContent.length > 0) {
          setJob(null)
          setLoading(false)
          setError(null)
          return
        }
        setLoading(true)
        setError(null)
        UILogger.info('JobReportTab', 'Start Job-Suche', { libraryId, fileId })
        // 1) Versuche Job über result.savedItemId (Shadow‑Twin) zu finden
        const byResultUrl = new URL(`/api/external/jobs`, window.location.origin)
        byResultUrl.searchParams.set('byResultItemId', fileId)
        UILogger.debug('JobReportTab', 'Request byResultItemId', { url: byResultUrl.toString() })
        let res = await fetch(byResultUrl.toString(), { cache: 'no-store' })
        let data = await res.json()
        if (!res.ok) throw new Error(typeof data?.error === 'string' ? data.error : 'Job-Suche fehlgeschlagen')
        let j: JobDto | null = Array.isArray(data?.items) && data.items.length > 0 ? (data.items[0] as JobDto) : null
        UILogger.debug('JobReportTab', 'Result byResultItemId', { count: Array.isArray(data?.items) ? data.items.length : 0 })

        // 2) Fallback: über correlation.source.itemId (Originaldatei)
        if (!j) {
          const bySourceUrl = new URL(`/api/external/jobs`, window.location.origin)
          bySourceUrl.searchParams.set('bySourceItemId', fileId)
          bySourceUrl.searchParams.set('libraryId', libraryId)
          UILogger.debug('JobReportTab', 'Request bySourceItemId', { url: bySourceUrl.toString() })
          res = await fetch(bySourceUrl.toString(), { cache: 'no-store' })
          data = await res.json()
          if (!res.ok) throw new Error(typeof data?.error === 'string' ? data.error : 'Job-Suche (Quelle) fehlgeschlagen')
          j = Array.isArray(data?.items) && data.items.length > 0 ? (data.items[0] as JobDto) : null
          UILogger.debug('JobReportTab', 'Result bySourceItemId', { count: Array.isArray(data?.items) ? data.items.length : 0 })
        }

        // 3) Fallback: über correlation.source.name (Dateiname der Quelle)
        if (!j) {
          const byNameUrl = new URL(`/api/external/jobs`, window.location.origin)
          // Wenn wir den tatsächlichen Dateinamen kennen, verwende ihn.
          // Für Shadow‑Twins (z. B. name.de.md) versuche das Basis‑PDF (name.pdf).
          let candidate = (fileName && typeof fileName === 'string') ? fileName : (fileId.includes('/') ? (fileId.split('/').pop() as string) : fileId)
          const parts = candidate.split('.')
          if (parts.length >= 3) {
            const ext1 = parts[parts.length - 1].toLowerCase()
            const ext2 = parts[parts.length - 2].toLowerCase()
            if ((ext1 === 'md' || ext1 === 'mdx') && /^[a-z]{2}$/i.test(ext2)) {
              candidate = parts.slice(0, -2).join('.') + '.pdf'
            }
          }
          byNameUrl.searchParams.set('bySourceName', candidate)
          byNameUrl.searchParams.set('libraryId', libraryId)
          UILogger.debug('JobReportTab', 'Request bySourceName', { url: byNameUrl.toString(), nameOnly: candidate, originalFileName: fileName })
          res = await fetch(byNameUrl.toString(), { cache: 'no-store' })
          data = await res.json()
          if (!res.ok) throw new Error(typeof data?.error === 'string' ? data.error : 'Job-Suche (Name) fehlgeschlagen')
          j = Array.isArray(data?.items) && data.items.length > 0 ? (data.items[0] as JobDto) : null
          UILogger.debug('JobReportTab', 'Result bySourceName', { count: Array.isArray(data?.items) ? data.items.length : 0 })
        }

        if (!cancelled) setJob(j)
        if (j) UILogger.info('JobReportTab', 'Job gefunden', { jobId: j.jobId, status: j.status })
        else UILogger.warn('JobReportTab', 'Kein Job gefunden', { libraryId, fileId })
      } catch (e) {
        const msg = e instanceof Error ? e.message : 'Unbekannter Fehler'
        UILogger.error('JobReportTab', 'Job-Suche fehlgeschlagen', e)
        if (!cancelled) setError(msg)
      } finally {
        if (!cancelled) setLoading(false)
      }
    }
    void run()
    return () => { cancelled = true }
  }, [libraryId, fileId, fileName, sourceMode, rawContent])

  // Wenn Template benutzt wurde, lade dessen Inhalt aus /templates und extrahiere Frontmatter-Schlüssel
  useEffect(() => {
    async function loadTemplateFields() {
      try {
        setTemplateFields(null)
        const tpl = job?.cumulativeMeta && typeof (job.cumulativeMeta as unknown) === 'object'
          ? (job.cumulativeMeta as Record<string, unknown>)['template_used']
          : undefined
        const templateName = typeof tpl === 'string' ? tpl : undefined
        if (!templateName || !provider) return
        const rootItems = await provider.listItemsById('root')
        const templatesFolder = rootItems.find(it => it.type === 'folder' && typeof (it as { metadata?: { name?: string } }).metadata?.name === 'string' && ((it as { metadata: { name: string } }).metadata.name.toLowerCase() === 'templates'))
        if (!templatesFolder) return
        const tplItems = await provider.listItemsById(templatesFolder.id)
        const match = tplItems.find(it => it.type === 'file' && ((it as { metadata: { name: string } }).metadata.name.toLowerCase() === templateName.toLowerCase()))
        if (!match) return
        const bin = await provider.getBinary(match.id)
        const text = await bin.blob.text()
        // Extrahiere Frontmatter zwischen den ersten beiden --- und lese die Keys bis zu :
        const m = text.match(/^---[\s\S]*?---/)
        if (!m) return
        const fm = m[0]
        const keys: string[] = []
        for (const line of fm.split('\n')) {
          const t = line.trim()
          if (!t || t === '---') continue
          const idx = t.indexOf(':')
          if (idx > 0) {
            const k = t.slice(0, idx).trim()
            if (k) keys.push(k)
          }
        }
        setTemplateFields(Array.from(new Set(keys)))
      } catch (e) {
        UILogger.warn('JobReportTab', 'Template-Felder konnten nicht geladen werden', { error: e instanceof Error ? e.message : String(e) })
      }
    }
    void loadTemplateFields()
  }, [job, provider])

  // Gemeinsamer strikter Parser
  const strictParseFrontmatter = (fm: string) => parseSecretaryMarkdownStrict(fm)

  // Frontmatter aus der gespeicherten Markdown-Datei lesen (oder aus rawContent)
  useEffect(() => {
    async function loadFrontmatter() {
      try {
        setParseErrors([])
        // Wenn roher Inhalt übergeben wurde, direkt daraus lesen
        if (sourceMode === 'frontmatter' && typeof rawContent === 'string' && rawContent.length > 0) {
          const text = rawContent
          setFullContent(text)
          const { frontmatter, meta, errors } = parseSecretaryMarkdownStrict(text)
          UILogger.debug('JobReportTab', 'Frontmatter (raw): Block gefunden?', { found: !!frontmatter, length: frontmatter ? frontmatter.length : 0 })
          if (!frontmatter) { setFrontmatterMeta(null); return }
          setFrontmatterMeta(Object.keys(meta).length ? meta : null)
          setParseErrors(errors)
          return
        }

        if (!provider) return
        const mdId = (mdFileId || (job?.result?.savedItemId as string | undefined) || fileId)
        UILogger.info('JobReportTab', 'Frontmatter: Lade Datei', { mdId, sourceMode })
        if (!mdId) return
        const bin = await provider.getBinary(mdId)
        const text = await bin.blob.text()
        setFullContent(text)
        const { frontmatter, meta, errors } = parseSecretaryMarkdownStrict(text)
        UILogger.debug('JobReportTab', 'Frontmatter: Block gefunden?', { found: !!frontmatter, length: frontmatter ? frontmatter.length : 0 })
        if (!frontmatter) { setFrontmatterMeta(null); return }
        setFrontmatterMeta(Object.keys(meta).length ? meta : null)
        setParseErrors(errors)
      } catch {
        setFrontmatterMeta(null)
      }
    }
    void loadFrontmatter()
  }, [provider, fileId, mdFileId, job?.result?.savedItemId, sourceMode, rawContent])

  if (sourceMode !== 'frontmatter') {
    if (loading) return <div className="p-4 text-sm text-muted-foreground">Lade Job…</div>
    if (error) return <div className="p-4 text-sm text-destructive">{error}</div>
    if (!job) return <div className="p-4 text-sm text-muted-foreground">Kein Job zur Datei gefunden.</div>
  }

  return (
    <div className="p-4 space-y-3 text-sm">
      {viewMode === 'metaOnly' && (
        <Tabs defaultValue="markdown">
          <TabsList className="grid grid-cols-3 w-full">
            <TabsTrigger value="markdown">Markdown</TabsTrigger>
            <TabsTrigger value="meta">Metadaten</TabsTrigger>
            <TabsTrigger value="chapters">Kapitel</TabsTrigger>
          </TabsList>

          <TabsContent value="markdown" className="mt-3">
            <div className="border rounded-md">
              <MarkdownPreview content={stripFrontmatter(fullContent || '')} />
            </div>
          </TabsContent>

          <TabsContent value="meta" className="mt-3">
            {/* Hinweise zu Parserfehlern (strikt) */}
            {parseErrors.length > 0 && (
              <div className="text-xs text-destructive mb-2">
                {parseErrors.map((e, i) => (<div key={i}>Parserfehler: {e}</div>))}
              </div>
            )}
            {(() => {
              const base: Record<string, unknown> = sourceMode === 'frontmatter'
                ? {}
                : ((job?.cumulativeMeta as unknown as Record<string, unknown>) || {})
              const cm = frontmatterMeta ? { ...base, ...frontmatterMeta } : base
              // confidence/provenance können Objekt oder JSON-String sein → Fallback parse
              const confidence: Record<string, unknown> = (() => {
                const raw = cm['confidence']
                if (raw && typeof raw === 'object') return raw as Record<string, unknown>
                if (typeof raw === 'string') { try { return JSON.parse(raw) as Record<string, unknown> } catch { /* ignore */ } }
                return {}
              })()
              const provenance: Record<string, unknown> = (() => {
                const raw = cm['provenance']
                if (raw && typeof raw === 'object') return raw as Record<string, unknown>
                if (typeof raw === 'string') { try { return JSON.parse(raw) as Record<string, unknown> } catch { /* ignore */ } }
                return {}
              })()
              const hasAnyConfidence = Object.keys(confidence).length > 0
              const baseKeys = Array.isArray(templateFields) && templateFields.length > 0
                ? Array.from(new Set([...(templateFields as string[]), ...Object.keys(cm)]))
                : Object.keys(cm)
              const flatKeys = baseKeys.filter(k => k !== 'chapters' && k !== 'toc' && k !== 'confidence' && k !== 'provenance')
              if (flatKeys.length === 0) return null
              return (
                <div>
                  <div className="font-medium mb-1">Metadaten (Template vs. Ergebnis)</div>
                  <div className="overflow-auto">
                    <table className="w-full text-xs">
                      <thead>
                        <tr className="text-left text-muted-foreground">
                          <th className="py-1 pr-2">Feld</th>
                          <th className="py-1 pr-2">Wert</th>
                          {hasAnyConfidence ? <th className="py-1 pr-2 text-right sticky right-0 bg-background border-l w-[6px] min-w-[6px] max-w-[6px]">Q</th> : null}
                        </tr>
                      </thead>
                      <tbody>
                        {flatKeys.map((k) => {
                          const val = cm[k]
                          let valueStr = ''
                          if (Array.isArray(val)) valueStr = (val as Array<unknown>).map(v => typeof v === 'string' ? v : JSON.stringify(v)).join(', ')
                          else valueStr = val === null || val === undefined ? '' : typeof val === 'string' ? val : JSON.stringify(val)
                          const cRaw = (confidence as Record<string, unknown>)[k]
                          const cNum = typeof cRaw === 'number' ? cRaw : (typeof cRaw === 'string' && /^\d+(\.\d+)?$/.test(cRaw) ? Number(cRaw) : undefined)
                          const pRaw = (provenance as Record<string, unknown>)[k]
                          const pStr = typeof pRaw === 'string' ? pRaw : pRaw ? JSON.stringify(pRaw) : ''
                          const color = cNum === undefined ? 'text-muted-foreground' : (cNum >= 0.8 ? 'text-green-600' : cNum >= 0.7 ? 'text-yellow-600' : 'text-red-600')
                          return (
                            <tr key={k} className="border-t border-muted/40">
                              <td className="py-1 pr-2 align-top font-medium">{k}</td>
                              <td className="py-1 pr-2 align-top whitespace-pre-wrap break-words">{valueStr}</td>
                              {hasAnyConfidence ? <td className="py-1 pr-2 align-top sticky right-0 bg-background border-l w-[6px] min-w-[6px] max-w-[6px]">
                                {cNum === undefined ? null : (
                                  <TooltipProvider>
                                    <Tooltip>
                                      <TooltipTrigger asChild>
                                        <span className={`inline-flex items-center justify-end w-full ${color}`} title={pStr || ''}>
                                          <span className="inline-block h-2 w-2 rounded-full bg-current" />
                                        </span>
                                      </TooltipTrigger>
                                      <TooltipContent>
                                        <div className="max-w-xs whitespace-pre-wrap break-words">
                                          <div className="font-medium">Q: {cNum.toFixed(2)}</div>
                                          {pStr ? <div className="mt-1 text-muted-foreground">{pStr}</div> : null}
                                        </div>
                                      </TooltipContent>
                                    </Tooltip>
                                  </TooltipProvider>
                                )}
                              </td> : null}
                            </tr>
                          )
                        })}
                      </tbody>
                    </table>
                  </div>
                </div>
              )
            })()}
          </TabsContent>

          <TabsContent value="chapters" className="mt-3">
            {(() => {
              const chapters: Array<Record<string, unknown>> = sourceMode === 'frontmatter'
                ? (Array.isArray(frontmatterMeta?.chapters) ? (frontmatterMeta?.chapters as Array<Record<string, unknown>>) : [])
                : ((job?.cumulativeMeta as unknown as { chapters?: Array<Record<string, unknown>> })?.chapters || [])
              if (!Array.isArray(chapters) || chapters.length === 0) return null
              const pad = (lvl: number | undefined): number => {
                if (typeof lvl !== 'number') return 0
                const clamped = Math.max(0, Math.min(3, lvl))
                return (clamped - 1) * 16
              }
              const counters = [0, 0, 0]
              return (
                <div className="space-y-1">
                  <div>
                    {chapters.map((c, i) => {
                      const level = typeof c.level === 'number' ? c.level : 1
                      const lvl = Math.max(1, Math.min(3, level))
                      counters[lvl - 1] += 1
                      for (let j = lvl; j < counters.length; j++) counters[j] = 0
                      const numLabel = counters.slice(0, lvl).filter(n => n > 0).join('.')
                      const title = typeof c.title === 'string' ? c.title : ''
                      const startPage = typeof c.startPage === 'number' ? c.startPage : ''
                      const summaryVal = typeof c.summary === 'string' ? c.summary : ''
                      const summary = summaryVal.length > 1000 ? `${summaryVal.slice(0, 1000)}…` : summaryVal
                      const keywords = Array.isArray(c.keywords) ? (c.keywords as Array<unknown>).filter(v => typeof v === 'string') as string[] : []
                      const ev = typeof c.startEvidence === 'string' ? c.startEvidence : ''
                      return (
                        <details key={`${title}-${i}`} className="group border-b py-1" open={false}>
                          <summary className="list-none cursor-pointer">
                            <div className="flex items-start justify-between gap-3">
                              <div className="flex-1 min-w-0" style={{ paddingLeft: `${pad(lvl)}px` }}>
                                <div className="flex items-baseline gap-2">
                                  <span className="text-xs text-muted-foreground tabular-nums">{numLabel}</span>
                                  <span className="font-medium truncate">{title}</span>
                                </div>
                              </div>
                              <div className="text-xs tabular-nums text-muted-foreground whitespace-nowrap">
                                {String(startPage)}
                              </div>
                            </div>
                          </summary>
                          <div className="mt-1 pr-1 text-xs space-y-1" style={{ paddingLeft: `${pad(lvl) + 28}px` }}>
                            {summary && (
                              <div className="whitespace-pre-wrap break-words">
                                {summary}
                              </div>
                            )}
                            {Array.isArray(keywords) && keywords.length > 0 && (
                              <div className="flex flex-wrap gap-1">
                                {keywords.map(k => (
                                  <span key={k} className="inline-flex items-center rounded px-1.5 py-0.5 bg-muted">{k}</span>
                                ))}
                              </div>
                            )}
                          </div>
                        </details>
                      )
                    })}
                  </div>
                </div>
              )
            })()}
          </TabsContent>
        </Tabs>
      )}

      {viewMode === 'full' && job && (
        <div className="flex items-center justify-between">
          <div>
            <div className="font-medium">Job {job.jobId}</div>
            <div className="text-xs text-muted-foreground">{job.job_type} · {job.operation} · {new Date(job.updatedAt).toLocaleString()}</div>
          </div>
          <div className="inline-flex items-center rounded px-2 py-0.5 bg-muted text-xs">{job.status}</div>
        </div>
      )}

      {/* Hinweise zu Parserfehlern (strikt) */}
      {viewMode !== 'metaOnly' && parseErrors.length > 0 && (
        <div className="text-xs text-destructive">
          {parseErrors.map((e, i) => (<div key={i}>Parserfehler: {e}</div>))}
        </div>
      )}

      {/* Template Hinweis (im Frontmatter-only-Modus ausgeblendet) */}
      {sourceMode !== 'frontmatter' && job && typeof job.cumulativeMeta?.template_used === 'string' && (
        <div className="text-xs text-muted-foreground">Template: {String(job.cumulativeMeta.template_used)}</div>
      )}

      {/* Schritte mit Ampel-Logik */}
      {viewMode === 'full' && job && Array.isArray(job.steps) && job.steps.length > 0 && (
        <div>
          <div className="font-medium mb-1">Schritte</div>
          <div className="flex flex-wrap gap-2 text-xs">
            {job.steps.map((s) => {
              // Geplante Phasen ermitteln (neue Flags bevorzugt, sonst phases)
              const p = (job.parameters || {}) as Record<string, unknown>
              const hasNewFlags = typeof p['doExtractPDF'] === 'boolean' || typeof p['doExtractMetadata'] === 'boolean' || typeof p['doIngestRAG'] === 'boolean'
              const phases = hasNewFlags
                ? {
                    extract: p['doExtractPDF'] === true,
                    template: p['doExtractMetadata'] === true,
                    ingest: p['doIngestRAG'] === true,
                  }
                : ((p['phases'] as { extract?: boolean; template?: boolean; ingest?: boolean }) || {})

              const planned = (() => {
                const n = s.name
                if (n === 'extract_pdf') return phases.extract === true
                if (n === 'transform_template' || n === 'store_shadow_twin') return phases.template === true
                if (n === 'ingest_rag') return phases.ingest === true
                return false
              })()

              // Ampel-Status ableiten
              const skipped = !!(s as { details?: { skipped?: boolean } }).details?.skipped
              let icon = '○'
              let cls = 'text-muted-foreground'
              if (s.status === 'failed') { icon = '✕'; cls = 'text-red-600' }
              else if (s.status === 'running') { icon = '◐'; cls = 'text-yellow-600' }
              else if (s.status === 'completed') { icon = skipped ? '○' : '✓'; cls = skipped ? 'text-gray-400' : 'text-green-600' }
              else if (s.status === 'pending') { icon = planned ? '•' : '○'; cls = planned ? 'text-yellow-600' : 'text-muted-foreground' }

              const time = s.endedAt ? new Date(s.endedAt).toLocaleTimeString() : s.startedAt ? new Date(s.startedAt).toLocaleTimeString() : ''
              return (
                <div key={s.name} className={`inline-flex items-center gap-1 px-2 py-1 rounded border ${cls}`}>
                  <span>{icon}</span>
                  <span className="font-medium">{s.name}</span>
                  {time ? <span className="opacity-70">{time}</span> : null}
                </div>
              )
            })}
          </div>
        </div>
      )}

      {/* Metadaten (flach) – je nach sourceMode: nur Frontmatter oder Merge (nur außerhalb metaOnly-View) */}
      {viewMode !== 'metaOnly' && section === 'meta' && (() => {
        const base: Record<string, unknown> = sourceMode === 'frontmatter'
          ? {}
          : ((job?.cumulativeMeta as unknown as Record<string, unknown>) || {})
        const cm = frontmatterMeta ? { ...base, ...frontmatterMeta } : base
        const confidence: Record<string, unknown> = (() => {
          const raw = cm['confidence']
          if (raw && typeof raw === 'object') return raw as Record<string, unknown>
          if (typeof raw === 'string') { try { return JSON.parse(raw) as Record<string, unknown> } catch { /* ignore */ } }
          return {}
        })()
        const provenance: Record<string, unknown> = (() => {
          const raw = cm['provenance']
          if (raw && typeof raw === 'object') return raw as Record<string, unknown>
          if (typeof raw === 'string') { try { return JSON.parse(raw) as Record<string, unknown> } catch { /* ignore */ } }
          return {}
        })()
        const hasAnyConfidence = Object.keys(confidence).length > 0
        const baseKeys = Array.isArray(templateFields) && templateFields.length > 0
          ? Array.from(new Set([...(templateFields as string[]), ...Object.keys(cm)]))
          : Object.keys(cm)
        const flatKeys = baseKeys.filter(k => k !== 'chapters' && k !== 'toc' && k !== 'confidence' && k !== 'provenance')
        if (flatKeys.length === 0) return null
        return (
        <div>
          <div className="font-medium mb-1">Metadaten (Template vs. Ergebnis)</div>
          <div className="overflow-auto">
            <table className="w-full text-xs">
              <thead>
                <tr className="text-left text-muted-foreground">
                  <th className="py-1 pr-2">Feld</th>
                  <th className="py-1 pr-2">Wert</th>
                  {hasAnyConfidence ? <th className="py-1 pr-2 w-20 text-right">Q</th> : null}
                </tr>
              </thead>
              <tbody>
                {flatKeys.map((k) => {
                  const val = cm[k]
                  let valueStr = ''
                  if (Array.isArray(val)) valueStr = (val as Array<unknown>).map(v => typeof v === 'string' ? v : JSON.stringify(v)).join(', ')
                  else valueStr = val === null || val === undefined ? '' : typeof val === 'string' ? val : JSON.stringify(val)
                  const cRaw = (confidence as Record<string, unknown>)[k]
                  const cNum = typeof cRaw === 'number' ? cRaw : (typeof cRaw === 'string' && /^\d+(\.\d+)?$/.test(cRaw) ? Number(cRaw) : undefined)
                  const pRaw = (provenance as Record<string, unknown>)[k]
                  const pStr = typeof pRaw === 'string' ? pRaw : pRaw ? JSON.stringify(pRaw) : ''
                  const color = cNum === undefined ? 'text-muted-foreground' : (cNum >= 0.8 ? 'text-green-600' : cNum >= 0.7 ? 'text-yellow-600' : 'text-red-600')
                  return (
                    <tr key={k} className="border-t border-muted/40">
                      <td className="py-1 pr-2 align-top font-medium">{k}</td>
                      <td className="py-1 pr-2 align-top whitespace-pre-wrap break-words">{valueStr}</td>
                      {hasAnyConfidence ? <td className="py-1 pr-2 align-top">
                        {cNum === undefined ? null : (
                          <TooltipProvider>
                            <Tooltip>
                              <TooltipTrigger asChild>
                                <span className={`inline-flex items-center gap-1 justify-end w-full ${color}`} title={pStr || ''}>
                                  <span className="inline-block h-2 w-2 rounded-full bg-current" />
                                  <span className="tabular-nums">{cNum.toFixed(2)}</span>
                                </span>
                              </TooltipTrigger>
                              {pStr ? (
                                <TooltipContent>
                                  <div className="max-w-xs whitespace-pre-wrap break-words">{pStr}</div>
                                </TooltipContent>
                              ) : null}
                            </Tooltip>
                          </TooltipProvider>
                        )}
                      </td> : null}
                    </tr>
                  )
                })}
              </tbody>
            </table>
          </div>
        </div>
        )
      })()}

      {/* Kapitel (hierarchisch, TOC-Ansicht) – nur außerhalb metaOnly-View */}
      {viewMode !== 'metaOnly' && section === 'chapters' && (() => {
        const chapters: Array<Record<string, unknown>> = sourceMode === 'frontmatter'
          ? (Array.isArray(frontmatterMeta?.chapters) ? (frontmatterMeta?.chapters as Array<Record<string, unknown>>) : [])
          : ((job?.cumulativeMeta as unknown as { chapters?: Array<Record<string, unknown>> })?.chapters || [])
        if (!Array.isArray(chapters) || chapters.length === 0) return null

        const pad = (lvl: number | undefined): number => {
          if (typeof lvl !== 'number') return 0
          const clamped = Math.max(0, Math.min(3, lvl))
          return (clamped - 1) * 16 // px
        }

        // Hierarchische Nummerierung 1., 1.1, 1.1.1 basierend auf level
        const counters = [0, 0, 0]
        return (
        <div className="space-y-1">
          <div className="font-medium mb-1">Kapitel</div>
          <div>
            {chapters.map((c, i) => {
              const level = typeof c.level === 'number' ? c.level : 1
              const lvl = Math.max(1, Math.min(3, level))
              // Zähler aktualisieren
              counters[lvl - 1] += 1
              for (let j = lvl; j < counters.length; j++) counters[j] = 0
              const numLabel = counters.slice(0, lvl).filter(n => n > 0).join('.')
              const title = typeof c.title === 'string' ? c.title : ''
              const startPage = typeof c.startPage === 'number' ? c.startPage : ''
              
              const summaryVal = typeof c.summary === 'string' ? c.summary : ''
              const summary = summaryVal.length > 1000 ? `${summaryVal.slice(0, 1000)}…` : summaryVal
              const keywords = Array.isArray(c.keywords) ? (c.keywords as Array<unknown>).filter(v => typeof v === 'string') as string[] : []
              const ev = typeof c.startEvidence === 'string' ? c.startEvidence : ''
              return (
                <details key={`${title}-${i}`} className="group border-b py-1" open={false} onToggle={(e) => {
                  const open = (e.currentTarget as HTMLDetailsElement).open
                  if (open) {
                    if (startPage !== '') onJumpTo?.({ page: startPage as number | string })
                    else if (ev) onJumpTo?.({ evidence: ev })
                  }
                }}>
                  <summary className="list-none cursor-pointer">
                    <div className="flex items-start justify-between gap-3">
                      <div className="flex-1 min-w-0" style={{ paddingLeft: `${pad(lvl)}px` }}>
                        <div className="flex items-baseline gap-2">
                          <span className="text-xs text-muted-foreground tabular-nums">{numLabel}</span>
                          <span className="font-medium truncate">{title}</span>
                        </div>
                      </div>
                      <div className="text-xs tabular-nums text-muted-foreground whitespace-nowrap">
                        {String(startPage)}
                      </div>
                    </div>
                  </summary>
                  <div className="mt-1 pr-1 text-xs space-y-1" style={{ paddingLeft: `${pad(lvl) + 28}px` }}>
                    {summary && (
                      <div className="whitespace-pre-wrap break-words">
                        {summary}
                      </div>
                    )}
                    {Array.isArray(keywords) && keywords.length > 0 && (
                      <div className="flex flex-wrap gap-1">
                        {keywords.map(k => (
                          <span key={k} className="inline-flex items-center rounded px-1.5 py-0.5 bg-muted">{k}</span>
                        ))}
                      </div>
                    )}
                  </div>
                </details>
              )
            })}
          </div>
        </div>
        )
      })()}

      {/* Inhaltsverzeichnis */}
      {section === 'chapters' && (() => {
        const toc: Array<Record<string, unknown>> = sourceMode === 'frontmatter'
          ? (Array.isArray(frontmatterMeta?.toc) ? (frontmatterMeta?.toc as Array<Record<string, unknown>>) : [])
          : ((job?.cumulativeMeta as unknown as { toc?: Array<Record<string, unknown>> }).toc || [])
        if (!Array.isArray(toc) || toc.length === 0) return null
        return (
        <div>
          <div className="font-medium mb-1">Inhaltsverzeichnis</div>
          <div className="overflow-visible">
            <table className="w-full text-xs">
              <thead>
                <tr className="text-left text-muted-foreground">
                  <th className="py-1 pr-2">Titel</th>
                  <th className="py-1 pr-2">Seite</th>
                  <th className="py-1 pr-2">L</th>
                </tr>
              </thead>
              <tbody>
                {toc.map((t, i) => {
                  const title = typeof t.title === 'string' ? t.title : ''
                  const page = typeof t.page === 'number' ? t.page : ''
                  const level = typeof t.level === 'number' ? t.level : ''
                  return (
                    <tr key={`${title}-${i}`} className="border-t border-muted/40">
                      <td className="py-1 pr-2 align-top whitespace-pre-wrap break-words">{title}</td>
                      <td className="py-1 pr-2 align-top">{page}</td>
                      <td className="py-1 pr-2 align-top">{level}</td>
                    </tr>
                  )
                })}
              </tbody>
            </table>
          </div>
        </div>
        )
      })()}

      {viewMode === 'full' && job && job.ingestion && (
        <div>
          <div className="font-medium mb-1">Ingestion</div>
          <div className="text-xs text-muted-foreground">{job.ingestion.index || '—'} · Vektoren: {job.ingestion.vectorsUpserted ?? '—'} · {job.ingestion.upsertAt ? new Date(job.ingestion.upsertAt).toLocaleString() : '—'}</div>
        </div>
      )}

      {viewMode === 'full' && job && Array.isArray(job.logs) && job.logs.length > 0 && (
        <div>
          <div className="font-medium mb-1">Logs (neueste zuerst)</div>
          <ul className="space-y-0.5 max-h-48 overflow-auto">
            {[...job.logs].reverse().slice(0, 30).map((l, i) => (
              <li key={i} className="text-xs">
                {new Date(l.timestamp).toLocaleTimeString()} · {l.phase || '—'} · {typeof l.progress === 'number' ? `${l.progress}% · ` : ''}{l.message || ''}
              </li>
            ))}
          </ul>
        </div>
      )}

      {/* Parameter am Ende */}
      {viewMode === 'full' && job && job.parameters && (
        <div>
          <div className="font-medium mb-1">Parameter</div>
          <pre className="bg-muted/40 rounded p-2 max-h-32 overflow-auto whitespace-pre-wrap break-words">{JSON.stringify(job.parameters, null, 2)}</pre>
        </div>
      )}
    </div>
  )
}



```

Erledigt:
- In der „Q“-Spalte wird nur noch der farbige Punkt angezeigt.
- Zahl und Provenance erscheinen im Tooltip: Titel zeigt „Q: 0.87“ (Beispiel) plus darunter die Provenance.
- Spaltenbreite fix auf 6 px (w/min-w/max-w).

Bitte kurz neu laden und prüfen, ob Darstellung und Tooltip-Inhalt so passen.

---

**User**

ist momentan nicht sichtbar.Spaltenbreite automatisch 

---

**Cursor**

Ich passe die „Q“-Spalte auf automatische Breite an und entferne die harte 6‑px Breite. Danach prüfe ich kurz den Linter.

```typescriptreact
"use client";

import { useEffect, useState } from 'react'
import { UILogger } from '@/lib/debug/logger'
import type { StorageProvider } from '@/lib/storage/types'
import { MarkdownPreview } from '@/components/library/markdown-preview'
import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs'
import { TooltipProvider, Tooltip, TooltipTrigger, TooltipContent } from '@/components/ui/tooltip'
import { parseSecretaryMarkdownStrict } from '@/lib/secretary/response-parser'

interface JobReportTabProps {
  libraryId: string
  fileId: string
  fileName?: string
  provider?: StorageProvider | null
  // Quelle der Metadaten steuern: 'merged' = cumulativeMeta + Frontmatter (Standard),
  // 'frontmatter' = ausschließlich Frontmatter aus Markdown anzeigen
  sourceMode?: 'merged' | 'frontmatter'
  // Darstellungsmodus: 'full' zeigt Kopf/Steps/Logs/Parameter; 'metaOnly' zeigt nur Metadaten/Kapitel/TOC
  viewMode?: 'full' | 'metaOnly'
  // Optional explizite Markdown-Datei-ID (Shadow‑Twin). Überschreibt auto-Erkennung.
  mdFileId?: string | null
  // Optionaler Callback zum Scroll-Sync in die Markdown-Vorschau
  onJumpTo?: (args: { page?: number | string; evidence?: string }) => void
  // NEU: Rohinhalt (Markdown). Wenn gesetzt und sourceMode='frontmatter', wird direkt dieser Text geparst (ohne Datei/JOB).
  rawContent?: string
}

interface JobDto {
  jobId: string
  status: string
  operation: string
  worker: string
  job_type: string
  updatedAt: string
  createdAt: string
  correlation?: { source?: { itemId?: string; name?: string } }
  parameters?: Record<string, unknown>
  steps?: Array<{ name: string; status: string; startedAt?: string; endedAt?: string; error?: { message: string }; details?: { skipped?: boolean } }>
  ingestion?: { vectorsUpserted?: number; index?: string; upsertAt?: string }
  result?: { savedItemId?: string }
  logs?: Array<{ timestamp: string; phase?: string; message?: string; progress?: number }>
  cumulativeMeta?: Record<string, unknown>
}

export function JobReportTab({ libraryId, fileId, fileName, provider, sourceMode = 'merged', viewMode = 'full', mdFileId, onJumpTo, rawContent }: JobReportTabProps) {
  const [loading, setLoading] = useState(false)
  const [error, setError] = useState<string | null>(null)
  const [job, setJob] = useState<JobDto | null>(null)
  const [templateFields, setTemplateFields] = useState<string[] | null>(null)
  const [frontmatterMeta, setFrontmatterMeta] = useState<Record<string, unknown> | null>(null)
  const [section, setSection] = useState<'meta' | 'chapters'>('meta')
  const [parseErrors, setParseErrors] = useState<string[]>([])
  const [fullContent, setFullContent] = useState<string>('')

  const stripFrontmatter = (markdown: string): string => markdown.replace(/^---\r?\n([\s\S]*?)\r?\n---\r?\n?/, '')

  useEffect(() => {
    let cancelled = false
    async function run() {
      try {
        // Wenn wir Rohinhalt haben und nur Frontmatter zeigen, brauchen wir keine Job-Suche
        if (sourceMode === 'frontmatter' && typeof rawContent === 'string' && rawContent.length > 0) {
          setJob(null)
          setLoading(false)
          setError(null)
          return
        }
        setLoading(true)
        setError(null)
        UILogger.info('JobReportTab', 'Start Job-Suche', { libraryId, fileId })
        // 1) Versuche Job über result.savedItemId (Shadow‑Twin) zu finden
        const byResultUrl = new URL(`/api/external/jobs`, window.location.origin)
        byResultUrl.searchParams.set('byResultItemId', fileId)
        UILogger.debug('JobReportTab', 'Request byResultItemId', { url: byResultUrl.toString() })
        let res = await fetch(byResultUrl.toString(), { cache: 'no-store' })
        let data = await res.json()
        if (!res.ok) throw new Error(typeof data?.error === 'string' ? data.error : 'Job-Suche fehlgeschlagen')
        let j: JobDto | null = Array.isArray(data?.items) && data.items.length > 0 ? (data.items[0] as JobDto) : null
        UILogger.debug('JobReportTab', 'Result byResultItemId', { count: Array.isArray(data?.items) ? data.items.length : 0 })

        // 2) Fallback: über correlation.source.itemId (Originaldatei)
        if (!j) {
          const bySourceUrl = new URL(`/api/external/jobs`, window.location.origin)
          bySourceUrl.searchParams.set('bySourceItemId', fileId)
          bySourceUrl.searchParams.set('libraryId', libraryId)
          UILogger.debug('JobReportTab', 'Request bySourceItemId', { url: bySourceUrl.toString() })
          res = await fetch(bySourceUrl.toString(), { cache: 'no-store' })
          data = await res.json()
          if (!res.ok) throw new Error(typeof data?.error === 'string' ? data.error : 'Job-Suche (Quelle) fehlgeschlagen')
          j = Array.isArray(data?.items) && data.items.length > 0 ? (data.items[0] as JobDto) : null
          UILogger.debug('JobReportTab', 'Result bySourceItemId', { count: Array.isArray(data?.items) ? data.items.length : 0 })
        }

        // 3) Fallback: über correlation.source.name (Dateiname der Quelle)
        if (!j) {
          const byNameUrl = new URL(`/api/external/jobs`, window.location.origin)
          // Wenn wir den tatsächlichen Dateinamen kennen, verwende ihn.
          // Für Shadow‑Twins (z. B. name.de.md) versuche das Basis‑PDF (name.pdf).
          let candidate = (fileName && typeof fileName === 'string') ? fileName : (fileId.includes('/') ? (fileId.split('/').pop() as string) : fileId)
          const parts = candidate.split('.')
          if (parts.length >= 3) {
            const ext1 = parts[parts.length - 1].toLowerCase()
            const ext2 = parts[parts.length - 2].toLowerCase()
            if ((ext1 === 'md' || ext1 === 'mdx') && /^[a-z]{2}$/i.test(ext2)) {
              candidate = parts.slice(0, -2).join('.') + '.pdf'
            }
          }
          byNameUrl.searchParams.set('bySourceName', candidate)
          byNameUrl.searchParams.set('libraryId', libraryId)
          UILogger.debug('JobReportTab', 'Request bySourceName', { url: byNameUrl.toString(), nameOnly: candidate, originalFileName: fileName })
          res = await fetch(byNameUrl.toString(), { cache: 'no-store' })
          data = await res.json()
          if (!res.ok) throw new Error(typeof data?.error === 'string' ? data.error : 'Job-Suche (Name) fehlgeschlagen')
          j = Array.isArray(data?.items) && data.items.length > 0 ? (data.items[0] as JobDto) : null
          UILogger.debug('JobReportTab', 'Result bySourceName', { count: Array.isArray(data?.items) ? data.items.length : 0 })
        }

        if (!cancelled) setJob(j)
        if (j) UILogger.info('JobReportTab', 'Job gefunden', { jobId: j.jobId, status: j.status })
        else UILogger.warn('JobReportTab', 'Kein Job gefunden', { libraryId, fileId })
      } catch (e) {
        const msg = e instanceof Error ? e.message : 'Unbekannter Fehler'
        UILogger.error('JobReportTab', 'Job-Suche fehlgeschlagen', e)
        if (!cancelled) setError(msg)
      } finally {
        if (!cancelled) setLoading(false)
      }
    }
    void run()
    return () => { cancelled = true }
  }, [libraryId, fileId, fileName, sourceMode, rawContent])

  // Wenn Template benutzt wurde, lade dessen Inhalt aus /templates und extrahiere Frontmatter-Schlüssel
  useEffect(() => {
    async function loadTemplateFields() {
      try {
        setTemplateFields(null)
        const tpl = job?.cumulativeMeta && typeof (job.cumulativeMeta as unknown) === 'object'
          ? (job.cumulativeMeta as Record<string, unknown>)['template_used']
          : undefined
        const templateName = typeof tpl === 'string' ? tpl : undefined
        if (!templateName || !provider) return
        const rootItems = await provider.listItemsById('root')
        const templatesFolder = rootItems.find(it => it.type === 'folder' && typeof (it as { metadata?: { name?: string } }).metadata?.name === 'string' && ((it as { metadata: { name: string } }).metadata.name.toLowerCase() === 'templates'))
        if (!templatesFolder) return
        const tplItems = await provider.listItemsById(templatesFolder.id)
        const match = tplItems.find(it => it.type === 'file' && ((it as { metadata: { name: string } }).metadata.name.toLowerCase() === templateName.toLowerCase()))
        if (!match) return
        const bin = await provider.getBinary(match.id)
        const text = await bin.blob.text()
        // Extrahiere Frontmatter zwischen den ersten beiden --- und lese die Keys bis zu :
        const m = text.match(/^---[\s\S]*?---/)
        if (!m) return
        const fm = m[0]
        const keys: string[] = []
        for (const line of fm.split('\n')) {
          const t = line.trim()
          if (!t || t === '---') continue
          const idx = t.indexOf(':')
          if (idx > 0) {
            const k = t.slice(0, idx).trim()
            if (k) keys.push(k)
          }
        }
        setTemplateFields(Array.from(new Set(keys)))
      } catch (e) {
        UILogger.warn('JobReportTab', 'Template-Felder konnten nicht geladen werden', { error: e instanceof Error ? e.message : String(e) })
      }
    }
    void loadTemplateFields()
  }, [job, provider])

  // Gemeinsamer strikter Parser
  const strictParseFrontmatter = (fm: string) => parseSecretaryMarkdownStrict(fm)

  // Frontmatter aus der gespeicherten Markdown-Datei lesen (oder aus rawContent)
  useEffect(() => {
    async function loadFrontmatter() {
      try {
        setParseErrors([])
        // Wenn roher Inhalt übergeben wurde, direkt daraus lesen
        if (sourceMode === 'frontmatter' && typeof rawContent === 'string' && rawContent.length > 0) {
          const text = rawContent
          setFullContent(text)
          const { frontmatter, meta, errors } = parseSecretaryMarkdownStrict(text)
          UILogger.debug('JobReportTab', 'Frontmatter (raw): Block gefunden?', { found: !!frontmatter, length: frontmatter ? frontmatter.length : 0 })
          if (!frontmatter) { setFrontmatterMeta(null); return }
          setFrontmatterMeta(Object.keys(meta).length ? meta : null)
          setParseErrors(errors)
          return
        }

        if (!provider) return
        const mdId = (mdFileId || (job?.result?.savedItemId as string | undefined) || fileId)
        UILogger.info('JobReportTab', 'Frontmatter: Lade Datei', { mdId, sourceMode })
        if (!mdId) return
        const bin = await provider.getBinary(mdId)
        const text = await bin.blob.text()
        setFullContent(text)
        const { frontmatter, meta, errors } = parseSecretaryMarkdownStrict(text)
        UILogger.debug('JobReportTab', 'Frontmatter: Block gefunden?', { found: !!frontmatter, length: frontmatter ? frontmatter.length : 0 })
        if (!frontmatter) { setFrontmatterMeta(null); return }
        setFrontmatterMeta(Object.keys(meta).length ? meta : null)
        setParseErrors(errors)
      } catch {
        setFrontmatterMeta(null)
      }
    }
    void loadFrontmatter()
  }, [provider, fileId, mdFileId, job?.result?.savedItemId, sourceMode, rawContent])

  if (sourceMode !== 'frontmatter') {
    if (loading) return <div className="p-4 text-sm text-muted-foreground">Lade Job…</div>
    if (error) return <div className="p-4 text-sm text-destructive">{error}</div>
    if (!job) return <div className="p-4 text-sm text-muted-foreground">Kein Job zur Datei gefunden.</div>
  }

  return (
    <div className="p-4 space-y-3 text-sm">
      {viewMode === 'metaOnly' && (
        <Tabs defaultValue="markdown">
          <TabsList className="grid grid-cols-3 w-full">
            <TabsTrigger value="markdown">Markdown</TabsTrigger>
            <TabsTrigger value="meta">Metadaten</TabsTrigger>
            <TabsTrigger value="chapters">Kapitel</TabsTrigger>
          </TabsList>

          <TabsContent value="markdown" className="mt-3">
            <div className="border rounded-md">
              <MarkdownPreview content={stripFrontmatter(fullContent || '')} />
            </div>
          </TabsContent>

          <TabsContent value="meta" className="mt-3">
            {/* Hinweise zu Parserfehlern (strikt) */}
            {parseErrors.length > 0 && (
              <div className="text-xs text-destructive mb-2">
                {parseErrors.map((e, i) => (<div key={i}>Parserfehler: {e}</div>))}
              </div>
            )}
            {(() => {
              const base: Record<string, unknown> = sourceMode === 'frontmatter'
                ? {}
                : ((job?.cumulativeMeta as unknown as Record<string, unknown>) || {})
              const cm = frontmatterMeta ? { ...base, ...frontmatterMeta } : base
              // confidence/provenance können Objekt oder JSON-String sein → Fallback parse
              const confidence: Record<string, unknown> = (() => {
                const raw = cm['confidence']
                if (raw && typeof raw === 'object') return raw as Record<string, unknown>
                if (typeof raw === 'string') { try { return JSON.parse(raw) as Record<string, unknown> } catch { /* ignore */ } }
                return {}
              })()
              const provenance: Record<string, unknown> = (() => {
                const raw = cm['provenance']
                if (raw && typeof raw === 'object') return raw as Record<string, unknown>
                if (typeof raw === 'string') { try { return JSON.parse(raw) as Record<string, unknown> } catch { /* ignore */ } }
                return {}
              })()
              const hasAnyConfidence = Object.keys(confidence).length > 0
              const baseKeys = Array.isArray(templateFields) && templateFields.length > 0
                ? Array.from(new Set([...(templateFields as string[]), ...Object.keys(cm)]))
                : Object.keys(cm)
              const flatKeys = baseKeys.filter(k => k !== 'chapters' && k !== 'toc' && k !== 'confidence' && k !== 'provenance')
              if (flatKeys.length === 0) return null
              return (
                <div>
                  <div className="font-medium mb-1">Metadaten (Template vs. Ergebnis)</div>
                  <div className="overflow-auto">
                    <table className="w-full text-xs">
                      <thead>
                        <tr className="text-left text-muted-foreground">
                          <th className="py-1 pr-2">Feld</th>
                          <th className="py-1 pr-2">Wert</th>
                          {hasAnyConfidence ? <th className="py-1 pr-2 text-right sticky right-0 bg-background border-l">Q</th> : null}
                        </tr>
                      </thead>
                      <tbody>
                        {flatKeys.map((k) => {
                          const val = cm[k]
                          let valueStr = ''
                          if (Array.isArray(val)) valueStr = (val as Array<unknown>).map(v => typeof v === 'string' ? v : JSON.stringify(v)).join(', ')
                          else valueStr = val === null || val === undefined ? '' : typeof val === 'string' ? val : JSON.stringify(val)
                          const cRaw = (confidence as Record<string, unknown>)[k]
                          const cNum = typeof cRaw === 'number' ? cRaw : (typeof cRaw === 'string' && /^\d+(\.\d+)?$/.test(cRaw) ? Number(cRaw) : undefined)
                          const pRaw = (provenance as Record<string, unknown>)[k]
                          const pStr = typeof pRaw === 'string' ? pRaw : pRaw ? JSON.stringify(pRaw) : ''
                          const color = cNum === undefined ? 'text-muted-foreground' : (cNum >= 0.8 ? 'text-green-600' : cNum >= 0.7 ? 'text-yellow-600' : 'text-red-600')
                          return (
                            <tr key={k} className="border-t border-muted/40">
                              <td className="py-1 pr-2 align-top font-medium">{k}</td>
                              <td className="py-1 pr-2 align-top whitespace-pre-wrap break-words">{valueStr}</td>
                              {hasAnyConfidence ? <td className="py-1 pr-2 align-top sticky right-0 bg-background border-l">
                                {cNum === undefined ? null : (
                                  <TooltipProvider>
                                    <Tooltip>
                                      <TooltipTrigger asChild>
                                        <span className={`inline-flex items-center justify-end w-full ${color}`} title={pStr || ''}>
                                          <span className="inline-block h-2 w-2 rounded-full bg-current" />
                                        </span>
                                      </TooltipTrigger>
                                      <TooltipContent>
                                        <div className="max-w-xs whitespace-pre-wrap break-words">
                                          <div className="font-medium">Q: {cNum.toFixed(2)}</div>
                                          {pStr ? <div className="mt-1 text-muted-foreground">{pStr}</div> : null}
                                        </div>
                                      </TooltipContent>
                                    </Tooltip>
                                  </TooltipProvider>
                                )}
                              </td> : null}
                            </tr>
                          )
                        })}
                      </tbody>
                    </table>
                  </div>
                </div>
              )
            })()}
          </TabsContent>

          <TabsContent value="chapters" className="mt-3">
            {(() => {
              const chapters: Array<Record<string, unknown>> = sourceMode === 'frontmatter'
                ? (Array.isArray(frontmatterMeta?.chapters) ? (frontmatterMeta?.chapters as Array<Record<string, unknown>>) : [])
                : ((job?.cumulativeMeta as unknown as { chapters?: Array<Record<string, unknown>> })?.chapters || [])
              if (!Array.isArray(chapters) || chapters.length === 0) return null
              const pad = (lvl: number | undefined): number => {
                if (typeof lvl !== 'number') return 0
                const clamped = Math.max(0, Math.min(3, lvl))
                return (clamped - 1) * 16
              }
              const counters = [0, 0, 0]
              return (
                <div className="space-y-1">
                  <div>
                    {chapters.map((c, i) => {
                      const level = typeof c.level === 'number' ? c.level : 1
                      const lvl = Math.max(1, Math.min(3, level))
                      counters[lvl - 1] += 1
                      for (let j = lvl; j < counters.length; j++) counters[j] = 0
                      const numLabel = counters.slice(0, lvl).filter(n => n > 0).join('.')
                      const title = typeof c.title === 'string' ? c.title : ''
                      const startPage = typeof c.startPage === 'number' ? c.startPage : ''
                      const summaryVal = typeof c.summary === 'string' ? c.summary : ''
                      const summary = summaryVal.length > 1000 ? `${summaryVal.slice(0, 1000)}…` : summaryVal
                      const keywords = Array.isArray(c.keywords) ? (c.keywords as Array<unknown>).filter(v => typeof v === 'string') as string[] : []
                      const ev = typeof c.startEvidence === 'string' ? c.startEvidence : ''
                      return (
                        <details key={`${title}-${i}`} className="group border-b py-1" open={false}>
                          <summary className="list-none cursor-pointer">
                            <div className="flex items-start justify-between gap-3">
                              <div className="flex-1 min-w-0" style={{ paddingLeft: `${pad(lvl)}px` }}>
                                <div className="flex items-baseline gap-2">
                                  <span className="text-xs text-muted-foreground tabular-nums">{numLabel}</span>
                                  <span className="font-medium truncate">{title}</span>
                                </div>
                              </div>
                              <div className="text-xs tabular-nums text-muted-foreground whitespace-nowrap">
                                {String(startPage)}
                              </div>
                            </div>
                          </summary>
                          <div className="mt-1 pr-1 text-xs space-y-1" style={{ paddingLeft: `${pad(lvl) + 28}px` }}>
                            {summary && (
                              <div className="whitespace-pre-wrap break-words">
                                {summary}
                              </div>
                            )}
                            {Array.isArray(keywords) && keywords.length > 0 && (
                              <div className="flex flex-wrap gap-1">
                                {keywords.map(k => (
                                  <span key={k} className="inline-flex items-center rounded px-1.5 py-0.5 bg-muted">{k}</span>
                                ))}
                              </div>
                            )}
                          </div>
                        </details>
                      )
                    })}
                  </div>
                </div>
              )
            })()}
          </TabsContent>
        </Tabs>
      )}

      {viewMode === 'full' && job && (
        <div className="flex items-center justify-between">
          <div>
            <div className="font-medium">Job {job.jobId}</div>
            <div className="text-xs text-muted-foreground">{job.job_type} · {job.operation} · {new Date(job.updatedAt).toLocaleString()}</div>
          </div>
          <div className="inline-flex items-center rounded px-2 py-0.5 bg-muted text-xs">{job.status}</div>
        </div>
      )}

      {/* Hinweise zu Parserfehlern (strikt) */}
      {viewMode !== 'metaOnly' && parseErrors.length > 0 && (
        <div className="text-xs text-destructive">
          {parseErrors.map((e, i) => (<div key={i}>Parserfehler: {e}</div>))}
        </div>
      )}

      {/* Template Hinweis (im Frontmatter-only-Modus ausgeblendet) */}
      {sourceMode !== 'frontmatter' && job && typeof job.cumulativeMeta?.template_used === 'string' && (
        <div className="text-xs text-muted-foreground">Template: {String(job.cumulativeMeta.template_used)}</div>
      )}

      {/* Schritte mit Ampel-Logik */}
      {viewMode === 'full' && job && Array.isArray(job.steps) && job.steps.length > 0 && (
        <div>
          <div className="font-medium mb-1">Schritte</div>
          <div className="flex flex-wrap gap-2 text-xs">
            {job.steps.map((s) => {
              // Geplante Phasen ermitteln (neue Flags bevorzugt, sonst phases)
              const p = (job.parameters || {}) as Record<string, unknown>
              const hasNewFlags = typeof p['doExtractPDF'] === 'boolean' || typeof p['doExtractMetadata'] === 'boolean' || typeof p['doIngestRAG'] === 'boolean'
              const phases = hasNewFlags
                ? {
                    extract: p['doExtractPDF'] === true,
                    template: p['doExtractMetadata'] === true,
                    ingest: p['doIngestRAG'] === true,
                  }
                : ((p['phases'] as { extract?: boolean; template?: boolean; ingest?: boolean }) || {})

              const planned = (() => {
                const n = s.name
                if (n === 'extract_pdf') return phases.extract === true
                if (n === 'transform_template' || n === 'store_shadow_twin') return phases.template === true
                if (n === 'ingest_rag') return phases.ingest === true
                return false
              })()

              // Ampel-Status ableiten
              const skipped = !!(s as { details?: { skipped?: boolean } }).details?.skipped
              let icon = '○'
              let cls = 'text-muted-foreground'
              if (s.status === 'failed') { icon = '✕'; cls = 'text-red-600' }
              else if (s.status === 'running') { icon = '◐'; cls = 'text-yellow-600' }
              else if (s.status === 'completed') { icon = skipped ? '○' : '✓'; cls = skipped ? 'text-gray-400' : 'text-green-600' }
              else if (s.status === 'pending') { icon = planned ? '•' : '○'; cls = planned ? 'text-yellow-600' : 'text-muted-foreground' }

              const time = s.endedAt ? new Date(s.endedAt).toLocaleTimeString() : s.startedAt ? new Date(s.startedAt).toLocaleTimeString() : ''
              return (
                <div key={s.name} className={`inline-flex items-center gap-1 px-2 py-1 rounded border ${cls}`}>
                  <span>{icon}</span>
                  <span className="font-medium">{s.name}</span>
                  {time ? <span className="opacity-70">{time}</span> : null}
                </div>
              )
            })}
          </div>
        </div>
      )}

      {/* Metadaten (flach) – je nach sourceMode: nur Frontmatter oder Merge (nur außerhalb metaOnly-View) */}
      {viewMode !== 'metaOnly' && section === 'meta' && (() => {
        const base: Record<string, unknown> = sourceMode === 'frontmatter'
          ? {}
          : ((job?.cumulativeMeta as unknown as Record<string, unknown>) || {})
        const cm = frontmatterMeta ? { ...base, ...frontmatterMeta } : base
        const confidence: Record<string, unknown> = (() => {
          const raw = cm['confidence']
          if (raw && typeof raw === 'object') return raw as Record<string, unknown>
          if (typeof raw === 'string') { try { return JSON.parse(raw) as Record<string, unknown> } catch { /* ignore */ } }
          return {}
        })()
        const provenance: Record<string, unknown> = (() => {
          const raw = cm['provenance']
          if (raw && typeof raw === 'object') return raw as Record<string, unknown>
          if (typeof raw === 'string') { try { return JSON.parse(raw) as Record<string, unknown> } catch { /* ignore */ } }
          return {}
        })()
        const hasAnyConfidence = Object.keys(confidence).length > 0
        const baseKeys = Array.isArray(templateFields) && templateFields.length > 0
          ? Array.from(new Set([...(templateFields as string[]), ...Object.keys(cm)]))
          : Object.keys(cm)
        const flatKeys = baseKeys.filter(k => k !== 'chapters' && k !== 'toc' && k !== 'confidence' && k !== 'provenance')
        if (flatKeys.length === 0) return null
        return (
        <div>
          <div className="font-medium mb-1">Metadaten (Template vs. Ergebnis)</div>
          <div className="overflow-auto">
            <table className="w-full text-xs">
              <thead>
                <tr className="text-left text-muted-foreground">
                  <th className="py-1 pr-2">Feld</th>
                  <th className="py-1 pr-2">Wert</th>
                  {hasAnyConfidence ? <th className="py-1 pr-2 w-20 text-right">Q</th> : null}
                </tr>
              </thead>
              <tbody>
                {flatKeys.map((k) => {
                  const val = cm[k]
                  let valueStr = ''
                  if (Array.isArray(val)) valueStr = (val as Array<unknown>).map(v => typeof v === 'string' ? v : JSON.stringify(v)).join(', ')
                  else valueStr = val === null || val === undefined ? '' : typeof val === 'string' ? val : JSON.stringify(val)
                  const cRaw = (confidence as Record<string, unknown>)[k]
                  const cNum = typeof cRaw === 'number' ? cRaw : (typeof cRaw === 'string' && /^\d+(\.\d+)?$/.test(cRaw) ? Number(cRaw) : undefined)
                  const pRaw = (provenance as Record<string, unknown>)[k]
                  const pStr = typeof pRaw === 'string' ? pRaw : pRaw ? JSON.stringify(pRaw) : ''
                  const color = cNum === undefined ? 'text-muted-foreground' : (cNum >= 0.8 ? 'text-green-600' : cNum >= 0.7 ? 'text-yellow-600' : 'text-red-600')
                  return (
                    <tr key={k} className="border-t border-muted/40">
                      <td className="py-1 pr-2 align-top font-medium">{k}</td>
                      <td className="py-1 pr-2 align-top whitespace-pre-wrap break-words">{valueStr}</td>
                      {hasAnyConfidence ? <td className="py-1 pr-2 align-top">
                        {cNum === undefined ? null : (
                          <TooltipProvider>
                            <Tooltip>
                              <TooltipTrigger asChild>
                                <span className={`inline-flex items-center gap-1 justify-end w-full ${color}`} title={pStr || ''}>
                                  <span className="inline-block h-2 w-2 rounded-full bg-current" />
                                  <span className="tabular-nums">{cNum.toFixed(2)}</span>
                                </span>
                              </TooltipTrigger>
                              {pStr ? (
                                <TooltipContent>
                                  <div className="max-w-xs whitespace-pre-wrap break-words">{pStr}</div>
                                </TooltipContent>
                              ) : null}
                            </Tooltip>
                          </TooltipProvider>
                        )}
                      </td> : null}
                    </tr>
                  )
                })}
              </tbody>
            </table>
          </div>
        </div>
        )
      })()}

      {/* Kapitel (hierarchisch, TOC-Ansicht) – nur außerhalb metaOnly-View */}
      {viewMode !== 'metaOnly' && section === 'chapters' && (() => {
        const chapters: Array<Record<string, unknown>> = sourceMode === 'frontmatter'
          ? (Array.isArray(frontmatterMeta?.chapters) ? (frontmatterMeta?.chapters as Array<Record<string, unknown>>) : [])
          : ((job?.cumulativeMeta as unknown as { chapters?: Array<Record<string, unknown>> })?.chapters || [])
        if (!Array.isArray(chapters) || chapters.length === 0) return null

        const pad = (lvl: number | undefined): number => {
          if (typeof lvl !== 'number') return 0
          const clamped = Math.max(0, Math.min(3, lvl))
          return (clamped - 1) * 16 // px
        }

        // Hierarchische Nummerierung 1., 1.1, 1.1.1 basierend auf level
        const counters = [0, 0, 0]
        return (
        <div className="space-y-1">
          <div className="font-medium mb-1">Kapitel</div>
          <div>
            {chapters.map((c, i) => {
              const level = typeof c.level === 'number' ? c.level : 1
              const lvl = Math.max(1, Math.min(3, level))
              // Zähler aktualisieren
              counters[lvl - 1] += 1
              for (let j = lvl; j < counters.length; j++) counters[j] = 0
              const numLabel = counters.slice(0, lvl).filter(n => n > 0).join('.')
              const title = typeof c.title === 'string' ? c.title : ''
              const startPage = typeof c.startPage === 'number' ? c.startPage : ''
              
              const summaryVal = typeof c.summary === 'string' ? c.summary : ''
              const summary = summaryVal.length > 1000 ? `${summaryVal.slice(0, 1000)}…` : summaryVal
              const keywords = Array.isArray(c.keywords) ? (c.keywords as Array<unknown>).filter(v => typeof v === 'string') as string[] : []
              const ev = typeof c.startEvidence === 'string' ? c.startEvidence : ''
              return (
                <details key={`${title}-${i}`} className="group border-b py-1" open={false} onToggle={(e) => {
                  const open = (e.currentTarget as HTMLDetailsElement).open
                  if (open) {
                    if (startPage !== '') onJumpTo?.({ page: startPage as number | string })
                    else if (ev) onJumpTo?.({ evidence: ev })
                  }
                }}>
                  <summary className="list-none cursor-pointer">
                    <div className="flex items-start justify-between gap-3">
                      <div className="flex-1 min-w-0" style={{ paddingLeft: `${pad(lvl)}px` }}>
                        <div className="flex items-baseline gap-2">
                          <span className="text-xs text-muted-foreground tabular-nums">{numLabel}</span>
                          <span className="font-medium truncate">{title}</span>
                        </div>
                      </div>
                      <div className="text-xs tabular-nums text-muted-foreground whitespace-nowrap">
                        {String(startPage)}
                      </div>
                    </div>
                  </summary>
                  <div className="mt-1 pr-1 text-xs space-y-1" style={{ paddingLeft: `${pad(lvl) + 28}px` }}>
                    {summary && (
                      <div className="whitespace-pre-wrap break-words">
                        {summary}
                      </div>
                    )}
                    {Array.isArray(keywords) && keywords.length > 0 && (
                      <div className="flex flex-wrap gap-1">
                        {keywords.map(k => (
                          <span key={k} className="inline-flex items-center rounded px-1.5 py-0.5 bg-muted">{k}</span>
                        ))}
                      </div>
                    )}
                  </div>
                </details>
              )
            })}
          </div>
        </div>
        )
      })()}

      {/* Inhaltsverzeichnis */}
      {section === 'chapters' && (() => {
        const toc: Array<Record<string, unknown>> = sourceMode === 'frontmatter'
          ? (Array.isArray(frontmatterMeta?.toc) ? (frontmatterMeta?.toc as Array<Record<string, unknown>>) : [])
          : ((job?.cumulativeMeta as unknown as { toc?: Array<Record<string, unknown>> }).toc || [])
        if (!Array.isArray(toc) || toc.length === 0) return null
        return (
        <div>
          <div className="font-medium mb-1">Inhaltsverzeichnis</div>
          <div className="overflow-visible">
            <table className="w-full text-xs">
              <thead>
                <tr className="text-left text-muted-foreground">
                  <th className="py-1 pr-2">Titel</th>
                  <th className="py-1 pr-2">Seite</th>
                  <th className="py-1 pr-2">L</th>
                </tr>
              </thead>
              <tbody>
                {toc.map((t, i) => {
                  const title = typeof t.title === 'string' ? t.title : ''
                  const page = typeof t.page === 'number' ? t.page : ''
                  const level = typeof t.level === 'number' ? t.level : ''
                  return (
                    <tr key={`${title}-${i}`} className="border-t border-muted/40">
                      <td className="py-1 pr-2 align-top whitespace-pre-wrap break-words">{title}</td>
                      <td className="py-1 pr-2 align-top">{page}</td>
                      <td className="py-1 pr-2 align-top">{level}</td>
                    </tr>
                  )
                })}
              </tbody>
            </table>
          </div>
        </div>
        )
      })()}

      {viewMode === 'full' && job && job.ingestion && (
        <div>
          <div className="font-medium mb-1">Ingestion</div>
          <div className="text-xs text-muted-foreground">{job.ingestion.index || '—'} · Vektoren: {job.ingestion.vectorsUpserted ?? '—'} · {job.ingestion.upsertAt ? new Date(job.ingestion.upsertAt).toLocaleString() : '—'}</div>
        </div>
      )}

      {viewMode === 'full' && job && Array.isArray(job.logs) && job.logs.length > 0 && (
        <div>
          <div className="font-medium mb-1">Logs (neueste zuerst)</div>
          <ul className="space-y-0.5 max-h-48 overflow-auto">
            {[...job.logs].reverse().slice(0, 30).map((l, i) => (
              <li key={i} className="text-xs">
                {new Date(l.timestamp).toLocaleTimeString()} · {l.phase || '—'} · {typeof l.progress === 'number' ? `${l.progress}% · ` : ''}{l.message || ''}
              </li>
            ))}
          </ul>
        </div>
      )}

      {/* Parameter am Ende */}
      {viewMode === 'full' && job && job.parameters && (
        <div>
          <div className="font-medium mb-1">Parameter</div>
          <pre className="bg-muted/40 rounded p-2 max-h-32 overflow-auto whitespace-pre-wrap break-words">{JSON.stringify(job.parameters, null, 2)}</pre>
        </div>
      )}
    </div>
  )
}



```

Spalte „Q“ ist jetzt wieder automatisch breit und bleibt sticky rechts. Punkt bleibt, Zahl/Provenance im Tooltip. Bitte neu laden und prüfen, ob sie zuverlässig sichtbar ist.

---

**User**

OK, parameter mit leeren Werten "" oder [] oder {} kein Punkt - kein Tooltip.
In Tooltip bitte Confidence und Provenance als Titel ausgeben.

---

**Cursor**

```typescriptreact
"use client";

import { useEffect, useState } from 'react'
import { UILogger } from '@/lib/debug/logger'
import type { StorageProvider } from '@/lib/storage/types'
import { MarkdownPreview } from '@/components/library/markdown-preview'
import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs'
import { TooltipProvider, Tooltip, TooltipTrigger, TooltipContent } from '@/components/ui/tooltip'
import { parseSecretaryMarkdownStrict } from '@/lib/secretary/response-parser'

interface JobReportTabProps {
  libraryId: string
  fileId: string
  fileName?: string
  provider?: StorageProvider | null
  // Quelle der Metadaten steuern: 'merged' = cumulativeMeta + Frontmatter (Standard),
  // 'frontmatter' = ausschließlich Frontmatter aus Markdown anzeigen
  sourceMode?: 'merged' | 'frontmatter'
  // Darstellungsmodus: 'full' zeigt Kopf/Steps/Logs/Parameter; 'metaOnly' zeigt nur Metadaten/Kapitel/TOC
  viewMode?: 'full' | 'metaOnly'
  // Optional explizite Markdown-Datei-ID (Shadow‑Twin). Überschreibt auto-Erkennung.
  mdFileId?: string | null
  // Optionaler Callback zum Scroll-Sync in die Markdown-Vorschau
  onJumpTo?: (args: { page?: number | string; evidence?: string }) => void
  // NEU: Rohinhalt (Markdown). Wenn gesetzt und sourceMode='frontmatter', wird direkt dieser Text geparst (ohne Datei/JOB).
  rawContent?: string
}

interface JobDto {
  jobId: string
  status: string
  operation: string
  worker: string
  job_type: string
  updatedAt: string
  createdAt: string
  correlation?: { source?: { itemId?: string; name?: string } }
  parameters?: Record<string, unknown>
  steps?: Array<{ name: string; status: string; startedAt?: string; endedAt?: string; error?: { message: string }; details?: { skipped?: boolean } }>
  ingestion?: { vectorsUpserted?: number; index?: string; upsertAt?: string }
  result?: { savedItemId?: string }
  logs?: Array<{ timestamp: string; phase?: string; message?: string; progress?: number }>
  cumulativeMeta?: Record<string, unknown>
}

export function JobReportTab({ libraryId, fileId, fileName, provider, sourceMode = 'merged', viewMode = 'full', mdFileId, onJumpTo, rawContent }: JobReportTabProps) {
  const [loading, setLoading] = useState(false)
  const [error, setError] = useState<string | null>(null)
  const [job, setJob] = useState<JobDto | null>(null)
  const [templateFields, setTemplateFields] = useState<string[] | null>(null)
  const [frontmatterMeta, setFrontmatterMeta] = useState<Record<string, unknown> | null>(null)
  const [section, setSection] = useState<'meta' | 'chapters'>('meta')
  const [parseErrors, setParseErrors] = useState<string[]>([])
  const [fullContent, setFullContent] = useState<string>('')

  const stripFrontmatter = (markdown: string): string => markdown.replace(/^---\r?\n([\s\S]*?)\r?\n---\r?\n?/, '')

  useEffect(() => {
    let cancelled = false
    async function run() {
      try {
        // Wenn wir Rohinhalt haben und nur Frontmatter zeigen, brauchen wir keine Job-Suche
        if (sourceMode === 'frontmatter' && typeof rawContent === 'string' && rawContent.length > 0) {
          setJob(null)
          setLoading(false)
          setError(null)
          return
        }
        setLoading(true)
        setError(null)
        UILogger.info('JobReportTab', 'Start Job-Suche', { libraryId, fileId })
        // 1) Versuche Job über result.savedItemId (Shadow‑Twin) zu finden
        const byResultUrl = new URL(`/api/external/jobs`, window.location.origin)
        byResultUrl.searchParams.set('byResultItemId', fileId)
        UILogger.debug('JobReportTab', 'Request byResultItemId', { url: byResultUrl.toString() })
        let res = await fetch(byResultUrl.toString(), { cache: 'no-store' })
        let data = await res.json()
        if (!res.ok) throw new Error(typeof data?.error === 'string' ? data.error : 'Job-Suche fehlgeschlagen')
        let j: JobDto | null = Array.isArray(data?.items) && data.items.length > 0 ? (data.items[0] as JobDto) : null
        UILogger.debug('JobReportTab', 'Result byResultItemId', { count: Array.isArray(data?.items) ? data.items.length : 0 })

        // 2) Fallback: über correlation.source.itemId (Originaldatei)
        if (!j) {
          const bySourceUrl = new URL(`/api/external/jobs`, window.location.origin)
          bySourceUrl.searchParams.set('bySourceItemId', fileId)
          bySourceUrl.searchParams.set('libraryId', libraryId)
          UILogger.debug('JobReportTab', 'Request bySourceItemId', { url: bySourceUrl.toString() })
          res = await fetch(bySourceUrl.toString(), { cache: 'no-store' })
          data = await res.json()
          if (!res.ok) throw new Error(typeof data?.error === 'string' ? data.error : 'Job-Suche (Quelle) fehlgeschlagen')
          j = Array.isArray(data?.items) && data.items.length > 0 ? (data.items[0] as JobDto) : null
          UILogger.debug('JobReportTab', 'Result bySourceItemId', { count: Array.isArray(data?.items) ? data.items.length : 0 })
        }

        // 3) Fallback: über correlation.source.name (Dateiname der Quelle)
        if (!j) {
          const byNameUrl = new URL(`/api/external/jobs`, window.location.origin)
          // Wenn wir den tatsächlichen Dateinamen kennen, verwende ihn.
          // Für Shadow‑Twins (z. B. name.de.md) versuche das Basis‑PDF (name.pdf).
          let candidate = (fileName && typeof fileName === 'string') ? fileName : (fileId.includes('/') ? (fileId.split('/').pop() as string) : fileId)
          const parts = candidate.split('.')
          if (parts.length >= 3) {
            const ext1 = parts[parts.length - 1].toLowerCase()
            const ext2 = parts[parts.length - 2].toLowerCase()
            if ((ext1 === 'md' || ext1 === 'mdx') && /^[a-z]{2}$/i.test(ext2)) {
              candidate = parts.slice(0, -2).join('.') + '.pdf'
            }
          }
          byNameUrl.searchParams.set('bySourceName', candidate)
          byNameUrl.searchParams.set('libraryId', libraryId)
          UILogger.debug('JobReportTab', 'Request bySourceName', { url: byNameUrl.toString(), nameOnly: candidate, originalFileName: fileName })
          res = await fetch(byNameUrl.toString(), { cache: 'no-store' })
          data = await res.json()
          if (!res.ok) throw new Error(typeof data?.error === 'string' ? data.error : 'Job-Suche (Name) fehlgeschlagen')
          j = Array.isArray(data?.items) && data.items.length > 0 ? (data.items[0] as JobDto) : null
          UILogger.debug('JobReportTab', 'Result bySourceName', { count: Array.isArray(data?.items) ? data.items.length : 0 })
        }

        if (!cancelled) setJob(j)
        if (j) UILogger.info('JobReportTab', 'Job gefunden', { jobId: j.jobId, status: j.status })
        else UILogger.warn('JobReportTab', 'Kein Job gefunden', { libraryId, fileId })
      } catch (e) {
        const msg = e instanceof Error ? e.message : 'Unbekannter Fehler'
        UILogger.error('JobReportTab', 'Job-Suche fehlgeschlagen', e)
        if (!cancelled) setError(msg)
      } finally {
        if (!cancelled) setLoading(false)
      }
    }
    void run()
    return () => { cancelled = true }
  }, [libraryId, fileId, fileName, sourceMode, rawContent])

  // Wenn Template benutzt wurde, lade dessen Inhalt aus /templates und extrahiere Frontmatter-Schlüssel
  useEffect(() => {
    async function loadTemplateFields() {
      try {
        setTemplateFields(null)
        const tpl = job?.cumulativeMeta && typeof (job.cumulativeMeta as unknown) === 'object'
          ? (job.cumulativeMeta as Record<string, unknown>)['template_used']
          : undefined
        const templateName = typeof tpl === 'string' ? tpl : undefined
        if (!templateName || !provider) return
        const rootItems = await provider.listItemsById('root')
        const templatesFolder = rootItems.find(it => it.type === 'folder' && typeof (it as { metadata?: { name?: string } }).metadata?.name === 'string' && ((it as { metadata: { name: string } }).metadata.name.toLowerCase() === 'templates'))
        if (!templatesFolder) return
        const tplItems = await provider.listItemsById(templatesFolder.id)
        const match = tplItems.find(it => it.type === 'file' && ((it as { metadata: { name: string } }).metadata.name.toLowerCase() === templateName.toLowerCase()))
        if (!match) return
        const bin = await provider.getBinary(match.id)
        const text = await bin.blob.text()
        // Extrahiere Frontmatter zwischen den ersten beiden --- und lese die Keys bis zu :
        const m = text.match(/^---[\s\S]*?---/)
        if (!m) return
        const fm = m[0]
        const keys: string[] = []
        for (const line of fm.split('\n')) {
          const t = line.trim()
          if (!t || t === '---') continue
          const idx = t.indexOf(':')
          if (idx > 0) {
            const k = t.slice(0, idx).trim()
            if (k) keys.push(k)
          }
        }
        setTemplateFields(Array.from(new Set(keys)))
      } catch (e) {
        UILogger.warn('JobReportTab', 'Template-Felder konnten nicht geladen werden', { error: e instanceof Error ? e.message : String(e) })
      }
    }
    void loadTemplateFields()
  }, [job, provider])

  // Gemeinsamer strikter Parser
  const strictParseFrontmatter = (fm: string) => parseSecretaryMarkdownStrict(fm)

  // Frontmatter aus der gespeicherten Markdown-Datei lesen (oder aus rawContent)
  useEffect(() => {
    async function loadFrontmatter() {
      try {
        setParseErrors([])
        // Wenn roher Inhalt übergeben wurde, direkt daraus lesen
        if (sourceMode === 'frontmatter' && typeof rawContent === 'string' && rawContent.length > 0) {
          const text = rawContent
          setFullContent(text)
          const { frontmatter, meta, errors } = parseSecretaryMarkdownStrict(text)
          UILogger.debug('JobReportTab', 'Frontmatter (raw): Block gefunden?', { found: !!frontmatter, length: frontmatter ? frontmatter.length : 0 })
          if (!frontmatter) { setFrontmatterMeta(null); return }
          setFrontmatterMeta(Object.keys(meta).length ? meta : null)
          setParseErrors(errors)
          return
        }

        if (!provider) return
        const mdId = (mdFileId || (job?.result?.savedItemId as string | undefined) || fileId)
        UILogger.info('JobReportTab', 'Frontmatter: Lade Datei', { mdId, sourceMode })
        if (!mdId) return
        const bin = await provider.getBinary(mdId)
        const text = await bin.blob.text()
        setFullContent(text)
        const { frontmatter, meta, errors } = parseSecretaryMarkdownStrict(text)
        UILogger.debug('JobReportTab', 'Frontmatter: Block gefunden?', { found: !!frontmatter, length: frontmatter ? frontmatter.length : 0 })
        if (!frontmatter) { setFrontmatterMeta(null); return }
        setFrontmatterMeta(Object.keys(meta).length ? meta : null)
        setParseErrors(errors)
      } catch {
        setFrontmatterMeta(null)
      }
    }
    void loadFrontmatter()
  }, [provider, fileId, mdFileId, job?.result?.savedItemId, sourceMode, rawContent])

  if (sourceMode !== 'frontmatter') {
    if (loading) return <div className="p-4 text-sm text-muted-foreground">Lade Job…</div>
    if (error) return <div className="p-4 text-sm text-destructive">{error}</div>
    if (!job) return <div className="p-4 text-sm text-muted-foreground">Kein Job zur Datei gefunden.</div>
  }

  return (
    <div className="p-4 space-y-3 text-sm">
      {viewMode === 'metaOnly' && (
        <Tabs defaultValue="markdown">
          <TabsList className="grid grid-cols-3 w-full">
            <TabsTrigger value="markdown">Markdown</TabsTrigger>
            <TabsTrigger value="meta">Metadaten</TabsTrigger>
            <TabsTrigger value="chapters">Kapitel</TabsTrigger>
          </TabsList>

          <TabsContent value="markdown" className="mt-3">
            <div className="border rounded-md">
              <MarkdownPreview content={stripFrontmatter(fullContent || '')} />
            </div>
          </TabsContent>

          <TabsContent value="meta" className="mt-3">
            {/* Hinweise zu Parserfehlern (strikt) */}
            {parseErrors.length > 0 && (
              <div className="text-xs text-destructive mb-2">
                {parseErrors.map((e, i) => (<div key={i}>Parserfehler: {e}</div>))}
              </div>
            )}
            {(() => {
              const base: Record<string, unknown> = sourceMode === 'frontmatter'
                ? {}
                : ((job?.cumulativeMeta as unknown as Record<string, unknown>) || {})
              const cm = frontmatterMeta ? { ...base, ...frontmatterMeta } : base
              // confidence/provenance können Objekt oder JSON-String sein → Fallback parse
              const confidence: Record<string, unknown> = (() => {
                const raw = cm['confidence']
                if (raw && typeof raw === 'object') return raw as Record<string, unknown>
                if (typeof raw === 'string') { try { return JSON.parse(raw) as Record<string, unknown> } catch { /* ignore */ } }
                return {}
              })()
              const provenance: Record<string, unknown> = (() => {
                const raw = cm['provenance']
                if (raw && typeof raw === 'object') return raw as Record<string, unknown>
                if (typeof raw === 'string') { try { return JSON.parse(raw) as Record<string, unknown> } catch { /* ignore */ } }
                return {}
              })()
              const hasAnyConfidence = Object.keys(confidence).length > 0
              const baseKeys = Array.isArray(templateFields) && templateFields.length > 0
                ? Array.from(new Set([...(templateFields as string[]), ...Object.keys(cm)]))
                : Object.keys(cm)
              const flatKeys = baseKeys.filter(k => k !== 'chapters' && k !== 'toc' && k !== 'confidence' && k !== 'provenance')
              if (flatKeys.length === 0) return null
              return (
                <div>
                  <div className="font-medium mb-1">Metadaten (Template vs. Ergebnis)</div>
                  <div className="overflow-auto">
                    <table className="w-full text-xs">
                      <thead>
                        <tr className="text-left text-muted-foreground">
                          <th className="py-1 pr-2">Feld</th>
                          <th className="py-1 pr-2">Wert</th>
                          {hasAnyConfidence ? <th className="py-1 pr-2 text-right sticky right-0 bg-background border-l">Q</th> : null}
                        </tr>
                      </thead>
                      <tbody>
                        {flatKeys.map((k) => {
                          const val = cm[k]
                          let valueStr = ''
                          if (Array.isArray(val)) valueStr = (val as Array<unknown>).map(v => typeof v === 'string' ? v : JSON.stringify(v)).join(', ')
                          else valueStr = val === null || val === undefined ? '' : typeof val === 'string' ? val : JSON.stringify(val)
                          const hasNonEmptyValue = (() => {
                            if (val === null || val === undefined) return false
                            if (typeof val === 'string') return val.trim().length > 0
                            if (Array.isArray(val)) return (val as Array<unknown>).length > 0
                            if (typeof val === 'object') return Object.keys(val as Record<string, unknown>).length > 0
                            return true
                          })()
                          const cRaw = (confidence as Record<string, unknown>)[k]
                          const cNum = typeof cRaw === 'number' ? cRaw : (typeof cRaw === 'string' && /^\d+(\.\d+)?$/.test(cRaw) ? Number(cRaw) : undefined)
                          const pRaw = (provenance as Record<string, unknown>)[k]
                          const pStr = typeof pRaw === 'string' ? pRaw : pRaw ? JSON.stringify(pRaw) : ''
                          const color = cNum === undefined ? 'text-muted-foreground' : (cNum >= 0.8 ? 'text-green-600' : cNum >= 0.7 ? 'text-yellow-600' : 'text-red-600')
                          return (
                            <tr key={k} className="border-t border-muted/40">
                              <td className="py-1 pr-2 align-top font-medium">{k}</td>
                              <td className="py-1 pr-2 align-top whitespace-pre-wrap break-words">{valueStr}</td>
                              {hasAnyConfidence ? <td className="py-1 pr-2 align-top sticky right-0 bg-background border-l">
                                {(!hasNonEmptyValue || cNum === undefined) ? null : (
                                  <TooltipProvider>
                                    <Tooltip>
                                      <TooltipTrigger asChild>
                                        <span className={`inline-flex items-center justify-end w-full ${color}`} title={pStr || ''}>
                                          <span className="inline-block h-2 w-2 rounded-full bg-current" />
                                        </span>
                                      </TooltipTrigger>
                                      <TooltipContent>
                                        <div className="max-w-xs whitespace-pre-wrap break-words">
                                          <div className="font-medium">Confidence: {cNum.toFixed(2)}</div>
                                          {pStr ? <div className="mt-1 text-muted-foreground">Provenance: {pStr}</div> : null}
                                        </div>
                                      </TooltipContent>
                                    </Tooltip>
                                  </TooltipProvider>
                                )}
                              </td> : null}
                            </tr>
                          )
                        })}
                      </tbody>
                    </table>
                  </div>
                </div>
              )
            })()}
          </TabsContent>

          <TabsContent value="chapters" className="mt-3">
            {(() => {
              const chapters: Array<Record<string, unknown>> = sourceMode === 'frontmatter'
                ? (Array.isArray(frontmatterMeta?.chapters) ? (frontmatterMeta?.chapters as Array<Record<string, unknown>>) : [])
                : ((job?.cumulativeMeta as unknown as { chapters?: Array<Record<string, unknown>> })?.chapters || [])
              if (!Array.isArray(chapters) || chapters.length === 0) return null
              const pad = (lvl: number | undefined): number => {
                if (typeof lvl !== 'number') return 0
                const clamped = Math.max(0, Math.min(3, lvl))
                return (clamped - 1) * 16
              }
              const counters = [0, 0, 0]
              return (
                <div className="space-y-1">
                  <div>
                    {chapters.map((c, i) => {
                      const level = typeof c.level === 'number' ? c.level : 1
                      const lvl = Math.max(1, Math.min(3, level))
                      counters[lvl - 1] += 1
                      for (let j = lvl; j < counters.length; j++) counters[j] = 0
                      const numLabel = counters.slice(0, lvl).filter(n => n > 0).join('.')
                      const title = typeof c.title === 'string' ? c.title : ''
                      const startPage = typeof c.startPage === 'number' ? c.startPage : ''
                      const summaryVal = typeof c.summary === 'string' ? c.summary : ''
                      const summary = summaryVal.length > 1000 ? `${summaryVal.slice(0, 1000)}…` : summaryVal
                      const keywords = Array.isArray(c.keywords) ? (c.keywords as Array<unknown>).filter(v => typeof v === 'string') as string[] : []
                      const ev = typeof c.startEvidence === 'string' ? c.startEvidence : ''
                      return (
                        <details key={`${title}-${i}`} className="group border-b py-1" open={false}>
                          <summary className="list-none cursor-pointer">
                            <div className="flex items-start justify-between gap-3">
                              <div className="flex-1 min-w-0" style={{ paddingLeft: `${pad(lvl)}px` }}>
                                <div className="flex items-baseline gap-2">
                                  <span className="text-xs text-muted-foreground tabular-nums">{numLabel}</span>
                                  <span className="font-medium truncate">{title}</span>
                                </div>
                              </div>
                              <div className="text-xs tabular-nums text-muted-foreground whitespace-nowrap">
                                {String(startPage)}
                              </div>
                            </div>
                          </summary>
                          <div className="mt-1 pr-1 text-xs space-y-1" style={{ paddingLeft: `${pad(lvl) + 28}px` }}>
                            {summary && (
                              <div className="whitespace-pre-wrap break-words">
                                {summary}
                              </div>
                            )}
                            {Array.isArray(keywords) && keywords.length > 0 && (
                              <div className="flex flex-wrap gap-1">
                                {keywords.map(k => (
                                  <span key={k} className="inline-flex items-center rounded px-1.5 py-0.5 bg-muted">{k}</span>
                                ))}
                              </div>
                            )}
                          </div>
                        </details>
                      )
                    })}
                  </div>
                </div>
              )
            })()}
          </TabsContent>
        </Tabs>
      )}

      {viewMode === 'full' && job && (
        <div className="flex items-center justify-between">
          <div>
            <div className="font-medium">Job {job.jobId}</div>
            <div className="text-xs text-muted-foreground">{job.job_type} · {job.operation} · {new Date(job.updatedAt).toLocaleString()}</div>
          </div>
          <div className="inline-flex items-center rounded px-2 py-0.5 bg-muted text-xs">{job.status}</div>
        </div>
      )}

      {/* Hinweise zu Parserfehlern (strikt) */}
      {viewMode !== 'metaOnly' && parseErrors.length > 0 && (
        <div className="text-xs text-destructive">
          {parseErrors.map((e, i) => (<div key={i}>Parserfehler: {e}</div>))}
        </div>
      )}

      {/* Template Hinweis (im Frontmatter-only-Modus ausgeblendet) */}
      {sourceMode !== 'frontmatter' && job && typeof job.cumulativeMeta?.template_used === 'string' && (
        <div className="text-xs text-muted-foreground">Template: {String(job.cumulativeMeta.template_used)}</div>
      )}

      {/* Schritte mit Ampel-Logik */}
      {viewMode === 'full' && job && Array.isArray(job.steps) && job.steps.length > 0 && (
        <div>
          <div className="font-medium mb-1">Schritte</div>
          <div className="flex flex-wrap gap-2 text-xs">
            {job.steps.map((s) => {
              // Geplante Phasen ermitteln (neue Flags bevorzugt, sonst phases)
              const p = (job.parameters || {}) as Record<string, unknown>
              const hasNewFlags = typeof p['doExtractPDF'] === 'boolean' || typeof p['doExtractMetadata'] === 'boolean' || typeof p['doIngestRAG'] === 'boolean'
              const phases = hasNewFlags
                ? {
                    extract: p['doExtractPDF'] === true,
                    template: p['doExtractMetadata'] === true,
                    ingest: p['doIngestRAG'] === true,
                  }
                : ((p['phases'] as { extract?: boolean; template?: boolean; ingest?: boolean }) || {})

              const planned = (() => {
                const n = s.name
                if (n === 'extract_pdf') return phases.extract === true
                if (n === 'transform_template' || n === 'store_shadow_twin') return phases.template === true
                if (n === 'ingest_rag') return phases.ingest === true
                return false
              })()

              // Ampel-Status ableiten
              const skipped = !!(s as { details?: { skipped?: boolean } }).details?.skipped
              let icon = '○'
              let cls = 'text-muted-foreground'
              if (s.status === 'failed') { icon = '✕'; cls = 'text-red-600' }
              else if (s.status === 'running') { icon = '◐'; cls = 'text-yellow-600' }
              else if (s.status === 'completed') { icon = skipped ? '○' : '✓'; cls = skipped ? 'text-gray-400' : 'text-green-600' }
              else if (s.status === 'pending') { icon = planned ? '•' : '○'; cls = planned ? 'text-yellow-600' : 'text-muted-foreground' }

              const time = s.endedAt ? new Date(s.endedAt).toLocaleTimeString() : s.startedAt ? new Date(s.startedAt).toLocaleTimeString() : ''
              return (
                <div key={s.name} className={`inline-flex items-center gap-1 px-2 py-1 rounded border ${cls}`}>
                  <span>{icon}</span>
                  <span className="font-medium">{s.name}</span>
                  {time ? <span className="opacity-70">{time}</span> : null}
                </div>
              )
            })}
          </div>
        </div>
      )}

      {/* Metadaten (flach) – je nach sourceMode: nur Frontmatter oder Merge (nur außerhalb metaOnly-View) */}
      {viewMode !== 'metaOnly' && section === 'meta' && (() => {
        const base: Record<string, unknown> = sourceMode === 'frontmatter'
          ? {}
          : ((job?.cumulativeMeta as unknown as Record<string, unknown>) || {})
        const cm = frontmatterMeta ? { ...base, ...frontmatterMeta } : base
        const confidence: Record<string, unknown> = (() => {
          const raw = cm['confidence']
          if (raw && typeof raw === 'object') return raw as Record<string, unknown>
          if (typeof raw === 'string') { try { return JSON.parse(raw) as Record<string, unknown> } catch { /* ignore */ } }
          return {}
        })()
        const provenance: Record<string, unknown> = (() => {
          const raw = cm['provenance']
          if (raw && typeof raw === 'object') return raw as Record<string, unknown>
          if (typeof raw === 'string') { try { return JSON.parse(raw) as Record<string, unknown> } catch { /* ignore */ } }
          return {}
        })()
        const hasAnyConfidence = Object.keys(confidence).length > 0
        const baseKeys = Array.isArray(templateFields) && templateFields.length > 0
          ? Array.from(new Set([...(templateFields as string[]), ...Object.keys(cm)]))
          : Object.keys(cm)
        const flatKeys = baseKeys.filter(k => k !== 'chapters' && k !== 'toc' && k !== 'confidence' && k !== 'provenance')
        if (flatKeys.length === 0) return null
        return (
        <div>
          <div className="font-medium mb-1">Metadaten (Template vs. Ergebnis)</div>
          <div className="overflow-auto">
            <table className="w-full text-xs">
              <thead>
                <tr className="text-left text-muted-foreground">
                  <th className="py-1 pr-2">Feld</th>
                  <th className="py-1 pr-2">Wert</th>
                  {hasAnyConfidence ? <th className="py-1 pr-2 w-20 text-right">Q</th> : null}
                </tr>
              </thead>
              <tbody>
                {flatKeys.map((k) => {
                  const val = cm[k]
                  let valueStr = ''
                  if (Array.isArray(val)) valueStr = (val as Array<unknown>).map(v => typeof v === 'string' ? v : JSON.stringify(v)).join(', ')
                  else valueStr = val === null || val === undefined ? '' : typeof val === 'string' ? val : JSON.stringify(val)
                  const cRaw = (confidence as Record<string, unknown>)[k]
                  const cNum = typeof cRaw === 'number' ? cRaw : (typeof cRaw === 'string' && /^\d+(\.\d+)?$/.test(cRaw) ? Number(cRaw) : undefined)
                  const pRaw = (provenance as Record<string, unknown>)[k]
                  const pStr = typeof pRaw === 'string' ? pRaw : pRaw ? JSON.stringify(pRaw) : ''
                  const color = cNum === undefined ? 'text-muted-foreground' : (cNum >= 0.8 ? 'text-green-600' : cNum >= 0.7 ? 'text-yellow-600' : 'text-red-600')
                  return (
                    <tr key={k} className="border-t border-muted/40">
                      <td className="py-1 pr-2 align-top font-medium">{k}</td>
                      <td className="py-1 pr-2 align-top whitespace-pre-wrap break-words">{valueStr}</td>
                      {hasAnyConfidence ? <td className="py-1 pr-2 align-top">
                        {cNum === undefined ? null : (
                          <TooltipProvider>
                            <Tooltip>
                              <TooltipTrigger asChild>
                                <span className={`inline-flex items-center gap-1 justify-end w-full ${color}`} title={pStr || ''}>
                                  <span className="inline-block h-2 w-2 rounded-full bg-current" />
                                  <span className="tabular-nums">{cNum.toFixed(2)}</span>
                                </span>
                              </TooltipTrigger>
                              {pStr ? (
                                <TooltipContent>
                                  <div className="max-w-xs whitespace-pre-wrap break-words">{pStr}</div>
                                </TooltipContent>
                              ) : null}
                            </Tooltip>
                          </TooltipProvider>
                        )}
                      </td> : null}
                    </tr>
                  )
                })}
              </tbody>
            </table>
          </div>
        </div>
        )
      })()}

      {/* Kapitel (hierarchisch, TOC-Ansicht) – nur außerhalb metaOnly-View */}
      {viewMode !== 'metaOnly' && section === 'chapters' && (() => {
        const chapters: Array<Record<string, unknown>> = sourceMode === 'frontmatter'
          ? (Array.isArray(frontmatterMeta?.chapters) ? (frontmatterMeta?.chapters as Array<Record<string, unknown>>) : [])
          : ((job?.cumulativeMeta as unknown as { chapters?: Array<Record<string, unknown>> })?.chapters || [])
        if (!Array.isArray(chapters) || chapters.length === 0) return null

        const pad = (lvl: number | undefined): number => {
          if (typeof lvl !== 'number') return 0
          const clamped = Math.max(0, Math.min(3, lvl))
          return (clamped - 1) * 16 // px
        }

        // Hierarchische Nummerierung 1., 1.1, 1.1.1 basierend auf level
        const counters = [0, 0, 0]
        return (
        <div className="space-y-1">
          <div className="font-medium mb-1">Kapitel</div>
          <div>
            {chapters.map((c, i) => {
              const level = typeof c.level === 'number' ? c.level : 1
              const lvl = Math.max(1, Math.min(3, level))
              // Zähler aktualisieren
              counters[lvl - 1] += 1
              for (let j = lvl; j < counters.length; j++) counters[j] = 0
              const numLabel = counters.slice(0, lvl).filter(n => n > 0).join('.')
              const title = typeof c.title === 'string' ? c.title : ''
              const startPage = typeof c.startPage === 'number' ? c.startPage : ''
              
              const summaryVal = typeof c.summary === 'string' ? c.summary : ''
              const summary = summaryVal.length > 1000 ? `${summaryVal.slice(0, 1000)}…` : summaryVal
              const keywords = Array.isArray(c.keywords) ? (c.keywords as Array<unknown>).filter(v => typeof v === 'string') as string[] : []
              const ev = typeof c.startEvidence === 'string' ? c.startEvidence : ''
              return (
                <details key={`${title}-${i}`} className="group border-b py-1" open={false} onToggle={(e) => {
                  const open = (e.currentTarget as HTMLDetailsElement).open
                  if (open) {
                    if (startPage !== '') onJumpTo?.({ page: startPage as number | string })
                    else if (ev) onJumpTo?.({ evidence: ev })
                  }
                }}>
                  <summary className="list-none cursor-pointer">
                    <div className="flex items-start justify-between gap-3">
                      <div className="flex-1 min-w-0" style={{ paddingLeft: `${pad(lvl)}px` }}>
                        <div className="flex items-baseline gap-2">
                          <span className="text-xs text-muted-foreground tabular-nums">{numLabel}</span>
                          <span className="font-medium truncate">{title}</span>
                        </div>
                      </div>
                      <div className="text-xs tabular-nums text-muted-foreground whitespace-nowrap">
                        {String(startPage)}
                      </div>
                    </div>
                  </summary>
                  <div className="mt-1 pr-1 text-xs space-y-1" style={{ paddingLeft: `${pad(lvl) + 28}px` }}>
                    {summary && (
                      <div className="whitespace-pre-wrap break-words">
                        {summary}
                      </div>
                    )}
                    {Array.isArray(keywords) && keywords.length > 0 && (
                      <div className="flex flex-wrap gap-1">
                        {keywords.map(k => (
                          <span key={k} className="inline-flex items-center rounded px-1.5 py-0.5 bg-muted">{k}</span>
                        ))}
                      </div>
                    )}
                  </div>
                </details>
              )
            })}
          </div>
        </div>
        )
      })()}

      {/* Inhaltsverzeichnis */}
      {section === 'chapters' && (() => {
        const toc: Array<Record<string, unknown>> = sourceMode === 'frontmatter'
          ? (Array.isArray(frontmatterMeta?.toc) ? (frontmatterMeta?.toc as Array<Record<string, unknown>>) : [])
          : ((job?.cumulativeMeta as unknown as { toc?: Array<Record<string, unknown>> }).toc || [])
        if (!Array.isArray(toc) || toc.length === 0) return null
        return (
        <div>
          <div className="font-medium mb-1">Inhaltsverzeichnis</div>
          <div className="overflow-visible">
            <table className="w-full text-xs">
              <thead>
                <tr className="text-left text-muted-foreground">
                  <th className="py-1 pr-2">Titel</th>
                  <th className="py-1 pr-2">Seite</th>
                  <th className="py-1 pr-2">L</th>
                </tr>
              </thead>
              <tbody>
                {toc.map((t, i) => {
                  const title = typeof t.title === 'string' ? t.title : ''
                  const page = typeof t.page === 'number' ? t.page : ''
                  const level = typeof t.level === 'number' ? t.level : ''
                  return (
                    <tr key={`${title}-${i}`} className="border-t border-muted/40">
                      <td className="py-1 pr-2 align-top whitespace-pre-wrap break-words">{title}</td>
                      <td className="py-1 pr-2 align-top">{page}</td>
                      <td className="py-1 pr-2 align-top">{level}</td>
                    </tr>
                  )
                })}
              </tbody>
            </table>
          </div>
        </div>
        )
      })()}

      {viewMode === 'full' && job && job.ingestion && (
        <div>
          <div className="font-medium mb-1">Ingestion</div>
          <div className="text-xs text-muted-foreground">{job.ingestion.index || '—'} · Vektoren: {job.ingestion.vectorsUpserted ?? '—'} · {job.ingestion.upsertAt ? new Date(job.ingestion.upsertAt).toLocaleString() : '—'}</div>
        </div>
      )}

      {viewMode === 'full' && job && Array.isArray(job.logs) && job.logs.length > 0 && (
        <div>
          <div className="font-medium mb-1">Logs (neueste zuerst)</div>
          <ul className="space-y-0.5 max-h-48 overflow-auto">
            {[...job.logs].reverse().slice(0, 30).map((l, i) => (
              <li key={i} className="text-xs">
                {new Date(l.timestamp).toLocaleTimeString()} · {l.phase || '—'} · {typeof l.progress === 'number' ? `${l.progress}% · ` : ''}{l.message || ''}
              </li>
            ))}
          </ul>
        </div>
      )}

      {/* Parameter am Ende */}
      {viewMode === 'full' && job && job.parameters && (
        <div>
          <div className="font-medium mb-1">Parameter</div>
          <pre className="bg-muted/40 rounded p-2 max-h-32 overflow-auto whitespace-pre-wrap break-words">{JSON.stringify(job.parameters, null, 2)}</pre>
        </div>
      )}
    </div>
  )
}



```

```typescriptreact
<<'PATCH'
*** Begin Patch
*** Update File: src/components/library/job-report-tab.tsx
@@
-        const flatKeys = baseKeys.filter(k => k !== 'chapters' && k !== 'toc' && k !== 'confidence' && k !== 'provenance')
+        const flatKeys = baseKeys.filter(k => k !== 'chapters' && k !== 'toc' && k !== 'confidence' && k !== 'provenance')
@@
-                {flatKeys.map((k) => {
+                {flatKeys.map((k) => {
                   const val = cm[k]
                   let valueStr = ''
                   if (Array.isArray(val)) valueStr = (val as Array<unknown>).map(v => typeof v === 'string' ? v : JSON.stringify(v)).join(', ')
                   else valueStr = val === null || val === undefined ? '' : typeof val === 'string' ? val : JSON.stringify(val)
-                  const cRaw = (confidence as Record<string, unknown>)[k]
+                  const hasNonEmptyValue = (() => {
+                    if (val === null || val === undefined) return false
+                    if (typeof val === 'string') return val.trim().length > 0
+                    if (Array.isArray(val)) return (val as Array<unknown>).length > 0
+                    if (typeof val === 'object') return Object.keys(val as Record<string, unknown>).length > 0
+                    return true
+                  })()
+                  const cRaw = (confidence as Record<string, unknown>)[k]
                   const cNum = typeof cRaw === 'number' ? cRaw : (typeof cRaw === 'string' && /^\d+(\.\d+)?$/.test(cRaw) ? Number(cRaw) : undefined)
-                  const pRaw = (provenance as Record<string, unknown>)[k]
+                  const pRaw = (provenance as Record<string, unknown>)[k]
                   const pStr = typeof pRaw === 'string' ? pRaw : pRaw ? JSON.stringify(pRaw) : ''
                   const color = cNum === undefined ? 'text-muted-foreground' : (cNum >= 0.8 ? 'text-green-600' : cNum >= 0.7 ? 'text-yellow-600' : 'text-red-600')
                   return (
                     <tr key={k} className="border-t border-muted/40">
                       <td className="py-1 pr-2 align-top font-medium">{k}</td>
                       <td className="py-1 pr-2 align-top whitespace-pre-wrap break-words">{valueStr}</td>
-                      {hasAnyConfidence ? <td className="py-1 pr-2 align-top">
-                        {cNum === undefined ? null : (
+                      {hasAnyConfidence ? <td className="py-1 pr-2 align-top">
+                        {(!hasNonEmptyValue || cNum === undefined) ? null : (
                           <TooltipProvider>
                             <Tooltip>
                               <TooltipTrigger asChild>
                                 <span className={`inline-flex items-center gap-1 justify-end w-full ${color}`} title={pStr || ''}>
                                   <span className="inline-block h-2 w-2 rounded-full bg-current" />
                                 </span>
                               </TooltipTrigger>
-                              {pStr ? (
-                                <TooltipContent>
-                                  <div className="max-w-xs whitespace-pre-wrap break-words">{pStr}</div>
-                                </TooltipContent>
-                              ) : null}
+                              <TooltipContent>
+                                <div className="max-w-xs whitespace-pre-wrap break-words">
+                                  <div className="font-medium">Confidence: {cNum.toFixed(2)}</div>
+                                  {pStr ? <div className="mt-1 text-muted-foreground">Provenance: {pStr}</div> : null}
+                                </div>
+                              </TooltipContent>
                             </Tooltip>
                           </TooltipProvider>
                         )}
                       </td> : null}
                     </tr>
                   )
                 })}
*** End Patch
PATCH
```

```typescriptreact
"use client";

import { useEffect, useState } from 'react'
import { UILogger } from '@/lib/debug/logger'
import type { StorageProvider } from '@/lib/storage/types'
import { MarkdownPreview } from '@/components/library/markdown-preview'
import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs'
import { TooltipProvider, Tooltip, TooltipTrigger, TooltipContent } from '@/components/ui/tooltip'
import { parseSecretaryMarkdownStrict } from '@/lib/secretary/response-parser'

interface JobReportTabProps {
  libraryId: string
  fileId: string
  fileName?: string
  provider?: StorageProvider | null
  // Quelle der Metadaten steuern: 'merged' = cumulativeMeta + Frontmatter (Standard),
  // 'frontmatter' = ausschließlich Frontmatter aus Markdown anzeigen
  sourceMode?: 'merged' | 'frontmatter'
  // Darstellungsmodus: 'full' zeigt Kopf/Steps/Logs/Parameter; 'metaOnly' zeigt nur Metadaten/Kapitel/TOC
  viewMode?: 'full' | 'metaOnly'
  // Optional explizite Markdown-Datei-ID (Shadow‑Twin). Überschreibt auto-Erkennung.
  mdFileId?: string | null
  // Optionaler Callback zum Scroll-Sync in die Markdown-Vorschau
  onJumpTo?: (args: { page?: number | string; evidence?: string }) => void
  // NEU: Rohinhalt (Markdown). Wenn gesetzt und sourceMode='frontmatter', wird direkt dieser Text geparst (ohne Datei/JOB).
  rawContent?: string
}

interface JobDto {
  jobId: string
  status: string
  operation: string
  worker: string
  job_type: string
  updatedAt: string
  createdAt: string
  correlation?: { source?: { itemId?: string; name?: string } }
  parameters?: Record<string, unknown>
  steps?: Array<{ name: string; status: string; startedAt?: string; endedAt?: string; error?: { message: string }; details?: { skipped?: boolean } }>
  ingestion?: { vectorsUpserted?: number; index?: string; upsertAt?: string }
  result?: { savedItemId?: string }
  logs?: Array<{ timestamp: string; phase?: string; message?: string; progress?: number }>
  cumulativeMeta?: Record<string, unknown>
}

export function JobReportTab({ libraryId, fileId, fileName, provider, sourceMode = 'merged', viewMode = 'full', mdFileId, onJumpTo, rawContent }: JobReportTabProps) {
  const [loading, setLoading] = useState(false)
  const [error, setError] = useState<string | null>(null)
  const [job, setJob] = useState<JobDto | null>(null)
  const [templateFields, setTemplateFields] = useState<string[] | null>(null)
  const [frontmatterMeta, setFrontmatterMeta] = useState<Record<string, unknown> | null>(null)
  const [section, setSection] = useState<'meta' | 'chapters'>('meta')
  const [parseErrors, setParseErrors] = useState<string[]>([])
  const [fullContent, setFullContent] = useState<string>('')

  const stripFrontmatter = (markdown: string): string => markdown.replace(/^---\r?\n([\s\S]*?)\r?\n---\r?\n?/, '')

  useEffect(() => {
    let cancelled = false
    async function run() {
      try {
        // Wenn wir Rohinhalt haben und nur Frontmatter zeigen, brauchen wir keine Job-Suche
        if (sourceMode === 'frontmatter' && typeof rawContent === 'string' && rawContent.length > 0) {
          setJob(null)
          setLoading(false)
          setError(null)
          return
        }
        setLoading(true)
        setError(null)
        UILogger.info('JobReportTab', 'Start Job-Suche', { libraryId, fileId })
        // 1) Versuche Job über result.savedItemId (Shadow‑Twin) zu finden
        const byResultUrl = new URL(`/api/external/jobs`, window.location.origin)
        byResultUrl.searchParams.set('byResultItemId', fileId)
        UILogger.debug('JobReportTab', 'Request byResultItemId', { url: byResultUrl.toString() })
        let res = await fetch(byResultUrl.toString(), { cache: 'no-store' })
        let data = await res.json()
        if (!res.ok) throw new Error(typeof data?.error === 'string' ? data.error : 'Job-Suche fehlgeschlagen')
        let j: JobDto | null = Array.isArray(data?.items) && data.items.length > 0 ? (data.items[0] as JobDto) : null
        UILogger.debug('JobReportTab', 'Result byResultItemId', { count: Array.isArray(data?.items) ? data.items.length : 0 })

        // 2) Fallback: über correlation.source.itemId (Originaldatei)
        if (!j) {
          const bySourceUrl = new URL(`/api/external/jobs`, window.location.origin)
          bySourceUrl.searchParams.set('bySourceItemId', fileId)
          bySourceUrl.searchParams.set('libraryId', libraryId)
          UILogger.debug('JobReportTab', 'Request bySourceItemId', { url: bySourceUrl.toString() })
          res = await fetch(bySourceUrl.toString(), { cache: 'no-store' })
          data = await res.json()
          if (!res.ok) throw new Error(typeof data?.error === 'string' ? data.error : 'Job-Suche (Quelle) fehlgeschlagen')
          j = Array.isArray(data?.items) && data.items.length > 0 ? (data.items[0] as JobDto) : null
          UILogger.debug('JobReportTab', 'Result bySourceItemId', { count: Array.isArray(data?.items) ? data.items.length : 0 })
        }

        // 3) Fallback: über correlation.source.name (Dateiname der Quelle)
        if (!j) {
          const byNameUrl = new URL(`/api/external/jobs`, window.location.origin)
          // Wenn wir den tatsächlichen Dateinamen kennen, verwende ihn.
          // Für Shadow‑Twins (z. B. name.de.md) versuche das Basis‑PDF (name.pdf).
          let candidate = (fileName && typeof fileName === 'string') ? fileName : (fileId.includes('/') ? (fileId.split('/').pop() as string) : fileId)
          const parts = candidate.split('.')
          if (parts.length >= 3) {
            const ext1 = parts[parts.length - 1].toLowerCase()
            const ext2 = parts[parts.length - 2].toLowerCase()
            if ((ext1 === 'md' || ext1 === 'mdx') && /^[a-z]{2}$/i.test(ext2)) {
              candidate = parts.slice(0, -2).join('.') + '.pdf'
            }
          }
          byNameUrl.searchParams.set('bySourceName', candidate)
          byNameUrl.searchParams.set('libraryId', libraryId)
          UILogger.debug('JobReportTab', 'Request bySourceName', { url: byNameUrl.toString(), nameOnly: candidate, originalFileName: fileName })
          res = await fetch(byNameUrl.toString(), { cache: 'no-store' })
          data = await res.json()
          if (!res.ok) throw new Error(typeof data?.error === 'string' ? data.error : 'Job-Suche (Name) fehlgeschlagen')
          j = Array.isArray(data?.items) && data.items.length > 0 ? (data.items[0] as JobDto) : null
          UILogger.debug('JobReportTab', 'Result bySourceName', { count: Array.isArray(data?.items) ? data.items.length : 0 })
        }

        if (!cancelled) setJob(j)
        if (j) UILogger.info('JobReportTab', 'Job gefunden', { jobId: j.jobId, status: j.status })
        else UILogger.warn('JobReportTab', 'Kein Job gefunden', { libraryId, fileId })
      } catch (e) {
        const msg = e instanceof Error ? e.message : 'Unbekannter Fehler'
        UILogger.error('JobReportTab', 'Job-Suche fehlgeschlagen', e)
        if (!cancelled) setError(msg)
      } finally {
        if (!cancelled) setLoading(false)
      }
    }
    void run()
    return () => { cancelled = true }
  }, [libraryId, fileId, fileName, sourceMode, rawContent])

  // Wenn Template benutzt wurde, lade dessen Inhalt aus /templates und extrahiere Frontmatter-Schlüssel
  useEffect(() => {
    async function loadTemplateFields() {
      try {
        setTemplateFields(null)
        const tpl = job?.cumulativeMeta && typeof (job.cumulativeMeta as unknown) === 'object'
          ? (job.cumulativeMeta as Record<string, unknown>)['template_used']
          : undefined
        const templateName = typeof tpl === 'string' ? tpl : undefined
        if (!templateName || !provider) return
        const rootItems = await provider.listItemsById('root')
        const templatesFolder = rootItems.find(it => it.type === 'folder' && typeof (it as { metadata?: { name?: string } }).metadata?.name === 'string' && ((it as { metadata: { name: string } }).metadata.name.toLowerCase() === 'templates'))
        if (!templatesFolder) return
        const tplItems = await provider.listItemsById(templatesFolder.id)
        const match = tplItems.find(it => it.type === 'file' && ((it as { metadata: { name: string } }).metadata.name.toLowerCase() === templateName.toLowerCase()))
        if (!match) return
        const bin = await provider.getBinary(match.id)
        const text = await bin.blob.text()
        // Extrahiere Frontmatter zwischen den ersten beiden --- und lese die Keys bis zu :
        const m = text.match(/^---[\s\S]*?---/)
        if (!m) return
        const fm = m[0]
        const keys: string[] = []
        for (const line of fm.split('\n')) {
          const t = line.trim()
          if (!t || t === '---') continue
          const idx = t.indexOf(':')
          if (idx > 0) {
            const k = t.slice(0, idx).trim()
            if (k) keys.push(k)
          }
        }
        setTemplateFields(Array.from(new Set(keys)))
      } catch (e) {
        UILogger.warn('JobReportTab', 'Template-Felder konnten nicht geladen werden', { error: e instanceof Error ? e.message : String(e) })
      }
    }
    void loadTemplateFields()
  }, [job, provider])

  // Gemeinsamer strikter Parser
  const strictParseFrontmatter = (fm: string) => parseSecretaryMarkdownStrict(fm)

  // Frontmatter aus der gespeicherten Markdown-Datei lesen (oder aus rawContent)
  useEffect(() => {
    async function loadFrontmatter() {
      try {
        setParseErrors([])
        // Wenn roher Inhalt übergeben wurde, direkt daraus lesen
        if (sourceMode === 'frontmatter' && typeof rawContent === 'string' && rawContent.length > 0) {
          const text = rawContent
          setFullContent(text)
          const { frontmatter, meta, errors } = parseSecretaryMarkdownStrict(text)
          UILogger.debug('JobReportTab', 'Frontmatter (raw): Block gefunden?', { found: !!frontmatter, length: frontmatter ? frontmatter.length : 0 })
          if (!frontmatter) { setFrontmatterMeta(null); return }
          setFrontmatterMeta(Object.keys(meta).length ? meta : null)
          setParseErrors(errors)
          return
        }

        if (!provider) return
        const mdId = (mdFileId || (job?.result?.savedItemId as string | undefined) || fileId)
        UILogger.info('JobReportTab', 'Frontmatter: Lade Datei', { mdId, sourceMode })
        if (!mdId) return
        const bin = await provider.getBinary(mdId)
        const text = await bin.blob.text()
        setFullContent(text)
        const { frontmatter, meta, errors } = parseSecretaryMarkdownStrict(text)
        UILogger.debug('JobReportTab', 'Frontmatter: Block gefunden?', { found: !!frontmatter, length: frontmatter ? frontmatter.length : 0 })
        if (!frontmatter) { setFrontmatterMeta(null); return }
        setFrontmatterMeta(Object.keys(meta).length ? meta : null)
        setParseErrors(errors)
      } catch {
        setFrontmatterMeta(null)
      }
    }
    void loadFrontmatter()
  }, [provider, fileId, mdFileId, job?.result?.savedItemId, sourceMode, rawContent])

  if (sourceMode !== 'frontmatter') {
    if (loading) return <div className="p-4 text-sm text-muted-foreground">Lade Job…</div>
    if (error) return <div className="p-4 text-sm text-destructive">{error}</div>
    if (!job) return <div className="p-4 text-sm text-muted-foreground">Kein Job zur Datei gefunden.</div>
  }

  return (
    <div className="p-4 space-y-3 text-sm">
      {viewMode === 'metaOnly' && (
        <Tabs defaultValue="markdown">
          <TabsList className="grid grid-cols-3 w-full">
            <TabsTrigger value="markdown">Markdown</TabsTrigger>
            <TabsTrigger value="meta">Metadaten</TabsTrigger>
            <TabsTrigger value="chapters">Kapitel</TabsTrigger>
          </TabsList>

          <TabsContent value="markdown" className="mt-3">
            <div className="border rounded-md">
              <MarkdownPreview content={stripFrontmatter(fullContent || '')} />
            </div>
          </TabsContent>

          <TabsContent value="meta" className="mt-3">
            {/* Hinweise zu Parserfehlern (strikt) */}
            {parseErrors.length > 0 && (
              <div className="text-xs text-destructive mb-2">
                {parseErrors.map((e, i) => (<div key={i}>Parserfehler: {e}</div>))}
              </div>
            )}
            {(() => {
              const base: Record<string, unknown> = sourceMode === 'frontmatter'
                ? {}
                : ((job?.cumulativeMeta as unknown as Record<string, unknown>) || {})
              const cm = frontmatterMeta ? { ...base, ...frontmatterMeta } : base
              // confidence/provenance können Objekt oder JSON-String sein → Fallback parse
              const confidence: Record<string, unknown> = (() => {
                const raw = cm['confidence']
                if (raw && typeof raw === 'object') return raw as Record<string, unknown>
                if (typeof raw === 'string') { try { return JSON.parse(raw) as Record<string, unknown> } catch { /* ignore */ } }
                return {}
              })()
              const provenance: Record<string, unknown> = (() => {
                const raw = cm['provenance']
                if (raw && typeof raw === 'object') return raw as Record<string, unknown>
                if (typeof raw === 'string') { try { return JSON.parse(raw) as Record<string, unknown> } catch { /* ignore */ } }
                return {}
              })()
              const hasAnyConfidence = Object.keys(confidence).length > 0
              const baseKeys = Array.isArray(templateFields) && templateFields.length > 0
                ? Array.from(new Set([...(templateFields as string[]), ...Object.keys(cm)]))
                : Object.keys(cm)
              const flatKeys = baseKeys.filter(k => k !== 'chapters' && k !== 'toc' && k !== 'confidence' && k !== 'provenance')
              if (flatKeys.length === 0) return null
              return (
                <div>
                  <div className="font-medium mb-1">Metadaten (Template vs. Ergebnis)</div>
                  <div className="overflow-auto">
                    <table className="w-full text-xs">
                      <thead>
                        <tr className="text-left text-muted-foreground">
                          <th className="py-1 pr-2">Feld</th>
                          <th className="py-1 pr-2">Wert</th>
                          {hasAnyConfidence ? <th className="py-1 pr-2 text-right sticky right-0 bg-background border-l">Q</th> : null}
                        </tr>
                      </thead>
                      <tbody>
                        {flatKeys.map((k) => {
                          const val = cm[k]
                          let valueStr = ''
                          if (Array.isArray(val)) valueStr = (val as Array<unknown>).map(v => typeof v === 'string' ? v : JSON.stringify(v)).join(', ')
                          else valueStr = val === null || val === undefined ? '' : typeof val === 'string' ? val : JSON.stringify(val)
                          const hasNonEmptyValue = (() => {
                            if (val === null || val === undefined) return false
                            if (typeof val === 'string') return val.trim().length > 0
                            if (Array.isArray(val)) return (val as Array<unknown>).length > 0
                            if (typeof val === 'object') return Object.keys(val as Record<string, unknown>).length > 0
                            return true
                          })()
                          const cRaw = (confidence as Record<string, unknown>)[k]
                          const cNum = typeof cRaw === 'number' ? cRaw : (typeof cRaw === 'string' && /^\d+(\.\d+)?$/.test(cRaw) ? Number(cRaw) : undefined)
                          const pRaw = (provenance as Record<string, unknown>)[k]
                          const pStr = typeof pRaw === 'string' ? pRaw : pRaw ? JSON.stringify(pRaw) : ''
                          const color = cNum === undefined ? 'text-muted-foreground' : (cNum >= 0.8 ? 'text-green-600' : cNum >= 0.7 ? 'text-yellow-600' : 'text-red-600')
                          return (
                            <tr key={k} className="border-t border-muted/40">
                              <td className="py-1 pr-2 align-top font-medium">{k}</td>
                              <td className="py-1 pr-2 align-top whitespace-pre-wrap break-words">{valueStr}</td>
                              {hasAnyConfidence ? <td className="py-1 pr-2 align-top sticky right-0 bg-background border-l">
                                {(!hasNonEmptyValue || cNum === undefined) ? null : (
                                  <TooltipProvider>
                                    <Tooltip>
                                      <TooltipTrigger asChild>
                                        <span className={`inline-flex items-center justify-end w-full ${color}`} title={pStr || ''}>
                                          <span className="inline-block h-2 w-2 rounded-full bg-current" />
                                        </span>
                                      </TooltipTrigger>
                                      <TooltipContent>
                                        <div className="max-w-xs whitespace-pre-wrap break-words">
                                          <div className="font-medium">Confidence: {cNum.toFixed(2)}</div>
                                          {pStr ? <div className="mt-1 text-muted-foreground">Provenance: {pStr}</div> : null}
                                        </div>
                                      </TooltipContent>
                                    </Tooltip>
                                  </TooltipProvider>
                                )}
                              </td> : null}
                            </tr>
                          )
                        })}
                      </tbody>
                    </table>
                  </div>
                </div>
              )
            })()}
          </TabsContent>

          <TabsContent value="chapters" className="mt-3">
            {(() => {
              const chapters: Array<Record<string, unknown>> = sourceMode === 'frontmatter'
                ? (Array.isArray(frontmatterMeta?.chapters) ? (frontmatterMeta?.chapters as Array<Record<string, unknown>>) : [])
                : ((job?.cumulativeMeta as unknown as { chapters?: Array<Record<string, unknown>> })?.chapters || [])
              if (!Array.isArray(chapters) || chapters.length === 0) return null
              const pad = (lvl: number | undefined): number => {
                if (typeof lvl !== 'number') return 0
                const clamped = Math.max(0, Math.min(3, lvl))
                return (clamped - 1) * 16
              }
              const counters = [0, 0, 0]
              return (
                <div className="space-y-1">
                  <div>
                    {chapters.map((c, i) => {
                      const level = typeof c.level === 'number' ? c.level : 1
                      const lvl = Math.max(1, Math.min(3, level))
                      counters[lvl - 1] += 1
                      for (let j = lvl; j < counters.length; j++) counters[j] = 0
                      const numLabel = counters.slice(0, lvl).filter(n => n > 0).join('.')
                      const title = typeof c.title === 'string' ? c.title : ''
                      const startPage = typeof c.startPage === 'number' ? c.startPage : ''
                      const summaryVal = typeof c.summary === 'string' ? c.summary : ''
                      const summary = summaryVal.length > 1000 ? `${summaryVal.slice(0, 1000)}…` : summaryVal
                      const keywords = Array.isArray(c.keywords) ? (c.keywords as Array<unknown>).filter(v => typeof v === 'string') as string[] : []
                      const ev = typeof c.startEvidence === 'string' ? c.startEvidence : ''
                      return (
                        <details key={`${title}-${i}`} className="group border-b py-1" open={false}>
                          <summary className="list-none cursor-pointer">
                            <div className="flex items-start justify-between gap-3">
                              <div className="flex-1 min-w-0" style={{ paddingLeft: `${pad(lvl)}px` }}>
                                <div className="flex items-baseline gap-2">
                                  <span className="text-xs text-muted-foreground tabular-nums">{numLabel}</span>
                                  <span className="font-medium truncate">{title}</span>
                                </div>
                              </div>
                              <div className="text-xs tabular-nums text-muted-foreground whitespace-nowrap">
                                {String(startPage)}
                              </div>
                            </div>
                          </summary>
                          <div className="mt-1 pr-1 text-xs space-y-1" style={{ paddingLeft: `${pad(lvl) + 28}px` }}>
                            {summary && (
                              <div className="whitespace-pre-wrap break-words">
                                {summary}
                              </div>
                            )}
                            {Array.isArray(keywords) && keywords.length > 0 && (
                              <div className="flex flex-wrap gap-1">
                                {keywords.map(k => (
                                  <span key={k} className="inline-flex items-center rounded px-1.5 py-0.5 bg-muted">{k}</span>
                                ))}
                              </div>
                            )}
                          </div>
                        </details>
                      )
                    })}
                  </div>
                </div>
              )
            })()}
          </TabsContent>
        </Tabs>
      )}

      {viewMode === 'full' && job && (
        <div className="flex items-center justify-between">
          <div>
            <div className="font-medium">Job {job.jobId}</div>
            <div className="text-xs text-muted-foreground">{job.job_type} · {job.operation} · {new Date(job.updatedAt).toLocaleString()}</div>
          </div>
          <div className="inline-flex items-center rounded px-2 py-0.5 bg-muted text-xs">{job.status}</div>
        </div>
      )}

      {/* Hinweise zu Parserfehlern (strikt) */}
      {viewMode !== 'metaOnly' && parseErrors.length > 0 && (
        <div className="text-xs text-destructive">
          {parseErrors.map((e, i) => (<div key={i}>Parserfehler: {e}</div>))}
        </div>
      )}

      {/* Template Hinweis (im Frontmatter-only-Modus ausgeblendet) */}
      {sourceMode !== 'frontmatter' && job && typeof job.cumulativeMeta?.template_used === 'string' && (
        <div className="text-xs text-muted-foreground">Template: {String(job.cumulativeMeta.template_used)}</div>
      )}

      {/* Schritte mit Ampel-Logik */}
      {viewMode === 'full' && job && Array.isArray(job.steps) && job.steps.length > 0 && (
        <div>
          <div className="font-medium mb-1">Schritte</div>
          <div className="flex flex-wrap gap-2 text-xs">
            {job.steps.map((s) => {
              // Geplante Phasen ermitteln (neue Flags bevorzugt, sonst phases)
              const p = (job.parameters || {}) as Record<string, unknown>
              const hasNewFlags = typeof p['doExtractPDF'] === 'boolean' || typeof p['doExtractMetadata'] === 'boolean' || typeof p['doIngestRAG'] === 'boolean'
              const phases = hasNewFlags
                ? {
                    extract: p['doExtractPDF'] === true,
                    template: p['doExtractMetadata'] === true,
                    ingest: p['doIngestRAG'] === true,
                  }
                : ((p['phases'] as { extract?: boolean; template?: boolean; ingest?: boolean }) || {})

              const planned = (() => {
                const n = s.name
                if (n === 'extract_pdf') return phases.extract === true
                if (n === 'transform_template' || n === 'store_shadow_twin') return phases.template === true
                if (n === 'ingest_rag') return phases.ingest === true
                return false
              })()

              // Ampel-Status ableiten
              const skipped = !!(s as { details?: { skipped?: boolean } }).details?.skipped
              let icon = '○'
              let cls = 'text-muted-foreground'
              if (s.status === 'failed') { icon = '✕'; cls = 'text-red-600' }
              else if (s.status === 'running') { icon = '◐'; cls = 'text-yellow-600' }
              else if (s.status === 'completed') { icon = skipped ? '○' : '✓'; cls = skipped ? 'text-gray-400' : 'text-green-600' }
              else if (s.status === 'pending') { icon = planned ? '•' : '○'; cls = planned ? 'text-yellow-600' : 'text-muted-foreground' }

              const time = s.endedAt ? new Date(s.endedAt).toLocaleTimeString() : s.startedAt ? new Date(s.startedAt).toLocaleTimeString() : ''
              return (
                <div key={s.name} className={`inline-flex items-center gap-1 px-2 py-1 rounded border ${cls}`}>
                  <span>{icon}</span>
                  <span className="font-medium">{s.name}</span>
                  {time ? <span className="opacity-70">{time}</span> : null}
                </div>
              )
            })}
          </div>
        </div>
      )}

      {/* Metadaten (flach) – je nach sourceMode: nur Frontmatter oder Merge (nur außerhalb metaOnly-View) */}
      {viewMode !== 'metaOnly' && section === 'meta' && (() => {
        const base: Record<string, unknown> = sourceMode === 'frontmatter'
          ? {}
          : ((job?.cumulativeMeta as unknown as Record<string, unknown>) || {})
        const cm = frontmatterMeta ? { ...base, ...frontmatterMeta } : base
        const confidence: Record<string, unknown> = (() => {
          const raw = cm['confidence']
          if (raw && typeof raw === 'object') return raw as Record<string, unknown>
          if (typeof raw === 'string') { try { return JSON.parse(raw) as Record<string, unknown> } catch { /* ignore */ } }
          return {}
        })()
        const provenance: Record<string, unknown> = (() => {
          const raw = cm['provenance']
          if (raw && typeof raw === 'object') return raw as Record<string, unknown>
          if (typeof raw === 'string') { try { return JSON.parse(raw) as Record<string, unknown> } catch { /* ignore */ } }
          return {}
        })()
        const hasAnyConfidence = Object.keys(confidence).length > 0
        const baseKeys = Array.isArray(templateFields) && templateFields.length > 0
          ? Array.from(new Set([...(templateFields as string[]), ...Object.keys(cm)]))
          : Object.keys(cm)
        const flatKeys = baseKeys.filter(k => k !== 'chapters' && k !== 'toc' && k !== 'confidence' && k !== 'provenance')
        if (flatKeys.length === 0) return null
        return (
        <div>
          <div className="font-medium mb-1">Metadaten (Template vs. Ergebnis)</div>
          <div className="overflow-auto">
            <table className="w-full text-xs">
              <thead>
                <tr className="text-left text-muted-foreground">
                  <th className="py-1 pr-2">Feld</th>
                  <th className="py-1 pr-2">Wert</th>
                  {hasAnyConfidence ? <th className="py-1 pr-2 text-right sticky right-0 bg-background border-l">Q</th> : null}
                </tr>
              </thead>
              <tbody>
                {flatKeys.map((k) => {
                  const val = cm[k]
                  let valueStr = ''
                  if (Array.isArray(val)) valueStr = (val as Array<unknown>).map(v => typeof v === 'string' ? v : JSON.stringify(v)).join(', ')
                  else valueStr = val === null || val === undefined ? '' : typeof val === 'string' ? val : JSON.stringify(val)
                  const hasNonEmptyValue = (() => {
                    if (val === null || val === undefined) return false
                    if (typeof val === 'string') return val.trim().length > 0
                    if (Array.isArray(val)) return (val as Array<unknown>).length > 0
                    if (typeof val === 'object') return Object.keys(val as Record<string, unknown>).length > 0
                    return true
                  })()
                  const cRaw = (confidence as Record<string, unknown>)[k]
                  const cNum = typeof cRaw === 'number' ? cRaw : (typeof cRaw === 'string' && /^\d+(\.\d+)?$/.test(cRaw) ? Number(cRaw) : undefined)
                  const pRaw = (provenance as Record<string, unknown>)[k]
                  const pStr = typeof pRaw === 'string' ? pRaw : pRaw ? JSON.stringify(pRaw) : ''
                  const color = cNum === undefined ? 'text-muted-foreground' : (cNum >= 0.8 ? 'text-green-600' : cNum >= 0.7 ? 'text-yellow-600' : 'text-red-600')
                  return (
                    <tr key={k} className="border-t border-muted/40">
                      <td className="py-1 pr-2 align-top font-medium">{k}</td>
                      <td className="py-1 pr-2 align-top whitespace-pre-wrap break-words">{valueStr}</td>
                      {hasAnyConfidence ? <td className="py-1 pr-2 align-top sticky right-0 bg-background border-l">
                        {(!hasNonEmptyValue || cNum === undefined) ? null : (
                          <TooltipProvider>
                            <Tooltip>
                              <TooltipTrigger asChild>
                                <span className={`inline-flex items-center justify-end w-full ${color}`} title={pStr || ''}>
                                  <span className="inline-block h-2 w-2 rounded-full bg-current" />
                                </span>
                              </TooltipTrigger>
                              <TooltipContent>
                                <div className="max-w-xs whitespace-pre-wrap break-words">
                                  <div className="font-medium">Confidence: {cNum.toFixed(2)}</div>
                                  {pStr ? <div className="mt-1 text-muted-foreground">Provenance: {pStr}</div> : null}
                                </div>
                              </TooltipContent>
                            </Tooltip>
                          </TooltipProvider>
                        )}
                      </td> : null}
                    </tr>
                  )
                })}
              </tbody>
            </table>
          </div>
        </div>
        )
      })()}

      {/* Kapitel (hierarchisch, TOC-Ansicht) – nur außerhalb metaOnly-View */}
      {viewMode !== 'metaOnly' && section === 'chapters' && (() => {
        const chapters: Array<Record<string, unknown>> = sourceMode === 'frontmatter'
          ? (Array.isArray(frontmatterMeta?.chapters) ? (frontmatterMeta?.chapters as Array<Record<string, unknown>>) : [])
          : ((job?.cumulativeMeta as unknown as { chapters?: Array<Record<string, unknown>> })?.chapters || [])
        if (!Array.isArray(chapters) || chapters.length === 0) return null

        const pad = (lvl: number | undefined): number => {
          if (typeof lvl !== 'number') return 0
          const clamped = Math.max(0, Math.min(3, lvl))
          return (clamped - 1) * 16 // px
        }

        // Hierarchische Nummerierung 1., 1.1, 1.1.1 basierend auf level
        const counters = [0, 0, 0]
        return (
        <div className="space-y-1">
          <div className="font-medium mb-1">Kapitel</div>
          <div>
            {chapters.map((c, i) => {
              const level = typeof c.level === 'number' ? c.level : 1
              const lvl = Math.max(1, Math.min(3, level))
              // Zähler aktualisieren
              counters[lvl - 1] += 1
              for (let j = lvl; j < counters.length; j++) counters[j] = 0
              const numLabel = counters.slice(0, lvl).filter(n => n > 0).join('.')
              const title = typeof c.title === 'string' ? c.title : ''
              const startPage = typeof c.startPage === 'number' ? c.startPage : ''
              
              const summaryVal = typeof c.summary === 'string' ? c.summary : ''
              const summary = summaryVal.length > 1000 ? `${summaryVal.slice(0, 1000)}…` : summaryVal
              const keywords = Array.isArray(c.keywords) ? (c.keywords as Array<unknown>).filter(v => typeof v === 'string') as string[] : []
              const ev = typeof c.startEvidence === 'string' ? c.startEvidence : ''
              return (
                <details key={`${title}-${i}`} className="group border-b py-1" open={false} onToggle={(e) => {
                  const open = (e.currentTarget as HTMLDetailsElement).open
                  if (open) {
                    if (startPage !== '') onJumpTo?.({ page: startPage as number | string })
                    else if (ev) onJumpTo?.({ evidence: ev })
                  }
                }}>
                  <summary className="list-none cursor-pointer">
                    <div className="flex items-start justify-between gap-3">
                      <div className="flex-1 min-w-0" style={{ paddingLeft: `${pad(lvl)}px` }}>
                        <div className="flex items-baseline gap-2">
                          <span className="text-xs text-muted-foreground tabular-nums">{numLabel}</span>
                          <span className="font-medium truncate">{title}</span>
                        </div>
                      </div>
                      <div className="text-xs tabular-nums text-muted-foreground whitespace-nowrap">
                        {String(startPage)}
                      </div>
                    </div>
                  </summary>
                  <div className="mt-1 pr-1 text-xs space-y-1" style={{ paddingLeft: `${pad(lvl) + 28}px` }}>
                    {summary && (
                      <div className="whitespace-pre-wrap break-words">
                        {summary}
                      </div>
                    )}
                    {Array.isArray(keywords) && keywords.length > 0 && (
                      <div className="flex flex-wrap gap-1">
                        {keywords.map(k => (
                          <span key={k} className="inline-flex items-center rounded px-1.5 py-0.5 bg-muted">{k}</span>
                        ))}
                      </div>
                    )}
                  </div>
                </details>
              )
            })}
          </div>
        </div>
        )
      })()}

      {/* Inhaltsverzeichnis */}
      {section === 'chapters' && (() => {
        const toc: Array<Record<string, unknown>> = sourceMode === 'frontmatter'
          ? (Array.isArray(frontmatterMeta?.toc) ? (frontmatterMeta?.toc as Array<Record<string, unknown>>) : [])
          : ((job?.cumulativeMeta as unknown as { toc?: Array<Record<string, unknown>> }).toc || [])
        if (!Array.isArray(toc) || toc.length === 0) return null
        return (
        <div>
          <div className="font-medium mb-1">Inhaltsverzeichnis</div>
          <div className="overflow-visible">
            <table className="w-full text-xs">
              <thead>
                <tr className="text-left text-muted-foreground">
                  <th className="py-1 pr-2">Titel</th>
                  <th className="py-1 pr-2">Seite</th>
                  <th className="py-1 pr-2">L</th>
                </tr>
              </thead>
              <tbody>
                {toc.map((t, i) => {
                  const title = typeof t.title === 'string' ? t.title : ''
                  const page = typeof t.page === 'number' ? t.page : ''
                  const level = typeof t.level === 'number' ? t.level : ''
                  return (
                    <tr key={`${title}-${i}`} className="border-t border-muted/40">
                      <td className="py-1 pr-2 align-top whitespace-pre-wrap break-words">{title}</td>
                      <td className="py-1 pr-2 align-top">{page}</td>
                      <td className="py-1 pr-2 align-top">{level}</td>
                    </tr>
                  )
                })}
              </tbody>
            </table>
          </div>
        </div>
        )
      })()}

      {viewMode === 'full' && job && job.ingestion && (
        <div>
          <div className="font-medium mb-1">Ingestion</div>
          <div className="text-xs text-muted-foreground">{job.ingestion.index || '—'} · Vektoren: {job.ingestion.vectorsUpserted ?? '—'} · {job.ingestion.upsertAt ? new Date(job.ingestion.upsertAt).toLocaleString() : '—'}</div>
        </div>
      )}

      {viewMode === 'full' && job && Array.isArray(job.logs) && job.logs.length > 0 && (
        <div>
          <div className="font-medium mb-1">Logs (neueste zuerst)</div>
          <ul className="space-y-0.5 max-h-48 overflow-auto">
            {[...job.logs].reverse().slice(0, 30).map((l, i) => (
              <li key={i} className="text-xs">
                {new Date(l.timestamp).toLocaleTimeString()} · {l.phase || '—'} · {typeof l.progress === 'number' ? `${l.progress}% · ` : ''}{l.message || ''}
              </li>
            ))}
          </ul>
        </div>
      )}

      {/* Parameter am Ende */}
      {viewMode === 'full' && job && job.parameters && (
        <div>
          <div className="font-medium mb-1">Parameter</div>
          <pre className="bg-muted/40 rounded p-2 max-h-32 overflow-auto whitespace-pre-wrap break-words">{JSON.stringify(job.parameters, null, 2)}</pre>
        </div>
      )}
    </div>
  )
}



```

Erledigt:
- Kein Punkt/Tooltip mehr, wenn der Parameterwert leer ist ("" | [] | {} | null/undefined).
- Tooltip zeigt jetzt „Confidence: <Wert>“ und darunter „Provenance: …“.
- „Q“-Spalte bleibt sticky rechts und hat automatische Breite.

Bitte neu laden und prüfen, ob Punkte nur noch bei nicht-leeren Werten erscheinen und der Tooltip die beiden Zeilen korrekt enthält.

---

**User**

jetzt ist Parameter abgeschnitten

---

**Cursor**

```typescriptreact
"use client";

import { useEffect, useState } from 'react'
import { UILogger } from '@/lib/debug/logger'
import type { StorageProvider } from '@/lib/storage/types'
import { MarkdownPreview } from '@/components/library/markdown-preview'
import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs'
import { TooltipProvider, Tooltip, TooltipTrigger, TooltipContent } from '@/components/ui/tooltip'
import { parseSecretaryMarkdownStrict } from '@/lib/secretary/response-parser'

interface JobReportTabProps {
  libraryId: string
  fileId: string
  fileName?: string
  provider?: StorageProvider | null
  // Quelle der Metadaten steuern: 'merged' = cumulativeMeta + Frontmatter (Standard),
  // 'frontmatter' = ausschließlich Frontmatter aus Markdown anzeigen
  sourceMode?: 'merged' | 'frontmatter'
  // Darstellungsmodus: 'full' zeigt Kopf/Steps/Logs/Parameter; 'metaOnly' zeigt nur Metadaten/Kapitel/TOC
  viewMode?: 'full' | 'metaOnly'
  // Optional explizite Markdown-Datei-ID (Shadow‑Twin). Überschreibt auto-Erkennung.
  mdFileId?: string | null
  // Optionaler Callback zum Scroll-Sync in die Markdown-Vorschau
  onJumpTo?: (args: { page?: number | string; evidence?: string }) => void
  // NEU: Rohinhalt (Markdown). Wenn gesetzt und sourceMode='frontmatter', wird direkt dieser Text geparst (ohne Datei/JOB).
  rawContent?: string
}

interface JobDto {
  jobId: string
  status: string
  operation: string
  worker: string
  job_type: string
  updatedAt: string
  createdAt: string
  correlation?: { source?: { itemId?: string; name?: string } }
  parameters?: Record<string, unknown>
  steps?: Array<{ name: string; status: string; startedAt?: string; endedAt?: string; error?: { message: string }; details?: { skipped?: boolean } }>
  ingestion?: { vectorsUpserted?: number; index?: string; upsertAt?: string }
  result?: { savedItemId?: string }
  logs?: Array<{ timestamp: string; phase?: string; message?: string; progress?: number }>
  cumulativeMeta?: Record<string, unknown>
}

export function JobReportTab({ libraryId, fileId, fileName, provider, sourceMode = 'merged', viewMode = 'full', mdFileId, onJumpTo, rawContent }: JobReportTabProps) {
  const [loading, setLoading] = useState(false)
  const [error, setError] = useState<string | null>(null)
  const [job, setJob] = useState<JobDto | null>(null)
  const [templateFields, setTemplateFields] = useState<string[] | null>(null)
  const [frontmatterMeta, setFrontmatterMeta] = useState<Record<string, unknown> | null>(null)
  const [section, setSection] = useState<'meta' | 'chapters'>('meta')
  const [parseErrors, setParseErrors] = useState<string[]>([])
  const [fullContent, setFullContent] = useState<string>('')

  const stripFrontmatter = (markdown: string): string => markdown.replace(/^---\r?\n([\s\S]*?)\r?\n---\r?\n?/, '')

  useEffect(() => {
    let cancelled = false
    async function run() {
      try {
        // Wenn wir Rohinhalt haben und nur Frontmatter zeigen, brauchen wir keine Job-Suche
        if (sourceMode === 'frontmatter' && typeof rawContent === 'string' && rawContent.length > 0) {
          setJob(null)
          setLoading(false)
          setError(null)
          return
        }
        setLoading(true)
        setError(null)
        UILogger.info('JobReportTab', 'Start Job-Suche', { libraryId, fileId })
        // 1) Versuche Job über result.savedItemId (Shadow‑Twin) zu finden
        const byResultUrl = new URL(`/api/external/jobs`, window.location.origin)
        byResultUrl.searchParams.set('byResultItemId', fileId)
        UILogger.debug('JobReportTab', 'Request byResultItemId', { url: byResultUrl.toString() })
        let res = await fetch(byResultUrl.toString(), { cache: 'no-store' })
        let data = await res.json()
        if (!res.ok) throw new Error(typeof data?.error === 'string' ? data.error : 'Job-Suche fehlgeschlagen')
        let j: JobDto | null = Array.isArray(data?.items) && data.items.length > 0 ? (data.items[0] as JobDto) : null
        UILogger.debug('JobReportTab', 'Result byResultItemId', { count: Array.isArray(data?.items) ? data.items.length : 0 })

        // 2) Fallback: über correlation.source.itemId (Originaldatei)
        if (!j) {
          const bySourceUrl = new URL(`/api/external/jobs`, window.location.origin)
          bySourceUrl.searchParams.set('bySourceItemId', fileId)
          bySourceUrl.searchParams.set('libraryId', libraryId)
          UILogger.debug('JobReportTab', 'Request bySourceItemId', { url: bySourceUrl.toString() })
          res = await fetch(bySourceUrl.toString(), { cache: 'no-store' })
          data = await res.json()
          if (!res.ok) throw new Error(typeof data?.error === 'string' ? data.error : 'Job-Suche (Quelle) fehlgeschlagen')
          j = Array.isArray(data?.items) && data.items.length > 0 ? (data.items[0] as JobDto) : null
          UILogger.debug('JobReportTab', 'Result bySourceItemId', { count: Array.isArray(data?.items) ? data.items.length : 0 })
        }

        // 3) Fallback: über correlation.source.name (Dateiname der Quelle)
        if (!j) {
          const byNameUrl = new URL(`/api/external/jobs`, window.location.origin)
          // Wenn wir den tatsächlichen Dateinamen kennen, verwende ihn.
          // Für Shadow‑Twins (z. B. name.de.md) versuche das Basis‑PDF (name.pdf).
          let candidate = (fileName && typeof fileName === 'string') ? fileName : (fileId.includes('/') ? (fileId.split('/').pop() as string) : fileId)
          const parts = candidate.split('.')
          if (parts.length >= 3) {
            const ext1 = parts[parts.length - 1].toLowerCase()
            const ext2 = parts[parts.length - 2].toLowerCase()
            if ((ext1 === 'md' || ext1 === 'mdx') && /^[a-z]{2}$/i.test(ext2)) {
              candidate = parts.slice(0, -2).join('.') + '.pdf'
            }
          }
          byNameUrl.searchParams.set('bySourceName', candidate)
          byNameUrl.searchParams.set('libraryId', libraryId)
          UILogger.debug('JobReportTab', 'Request bySourceName', { url: byNameUrl.toString(), nameOnly: candidate, originalFileName: fileName })
          res = await fetch(byNameUrl.toString(), { cache: 'no-store' })
          data = await res.json()
          if (!res.ok) throw new Error(typeof data?.error === 'string' ? data.error : 'Job-Suche (Name) fehlgeschlagen')
          j = Array.isArray(data?.items) && data.items.length > 0 ? (data.items[0] as JobDto) : null
          UILogger.debug('JobReportTab', 'Result bySourceName', { count: Array.isArray(data?.items) ? data.items.length : 0 })
        }

        if (!cancelled) setJob(j)
        if (j) UILogger.info('JobReportTab', 'Job gefunden', { jobId: j.jobId, status: j.status })
        else UILogger.warn('JobReportTab', 'Kein Job gefunden', { libraryId, fileId })
      } catch (e) {
        const msg = e instanceof Error ? e.message : 'Unbekannter Fehler'
        UILogger.error('JobReportTab', 'Job-Suche fehlgeschlagen', e)
        if (!cancelled) setError(msg)
      } finally {
        if (!cancelled) setLoading(false)
      }
    }
    void run()
    return () => { cancelled = true }
  }, [libraryId, fileId, fileName, sourceMode, rawContent])

  // Wenn Template benutzt wurde, lade dessen Inhalt aus /templates und extrahiere Frontmatter-Schlüssel
  useEffect(() => {
    async function loadTemplateFields() {
      try {
        setTemplateFields(null)
        const tpl = job?.cumulativeMeta && typeof (job.cumulativeMeta as unknown) === 'object'
          ? (job.cumulativeMeta as Record<string, unknown>)['template_used']
          : undefined
        const templateName = typeof tpl === 'string' ? tpl : undefined
        if (!templateName || !provider) return
        const rootItems = await provider.listItemsById('root')
        const templatesFolder = rootItems.find(it => it.type === 'folder' && typeof (it as { metadata?: { name?: string } }).metadata?.name === 'string' && ((it as { metadata: { name: string } }).metadata.name.toLowerCase() === 'templates'))
        if (!templatesFolder) return
        const tplItems = await provider.listItemsById(templatesFolder.id)
        const match = tplItems.find(it => it.type === 'file' && ((it as { metadata: { name: string } }).metadata.name.toLowerCase() === templateName.toLowerCase()))
        if (!match) return
        const bin = await provider.getBinary(match.id)
        const text = await bin.blob.text()
        // Extrahiere Frontmatter zwischen den ersten beiden --- und lese die Keys bis zu :
        const m = text.match(/^---[\s\S]*?---/)
        if (!m) return
        const fm = m[0]
        const keys: string[] = []
        for (const line of fm.split('\n')) {
          const t = line.trim()
          if (!t || t === '---') continue
          const idx = t.indexOf(':')
          if (idx > 0) {
            const k = t.slice(0, idx).trim()
            if (k) keys.push(k)
          }
        }
        setTemplateFields(Array.from(new Set(keys)))
      } catch (e) {
        UILogger.warn('JobReportTab', 'Template-Felder konnten nicht geladen werden', { error: e instanceof Error ? e.message : String(e) })
      }
    }
    void loadTemplateFields()
  }, [job, provider])

  // Gemeinsamer strikter Parser
  const strictParseFrontmatter = (fm: string) => parseSecretaryMarkdownStrict(fm)

  // Frontmatter aus der gespeicherten Markdown-Datei lesen (oder aus rawContent)
  useEffect(() => {
    async function loadFrontmatter() {
      try {
        setParseErrors([])
        // Wenn roher Inhalt übergeben wurde, direkt daraus lesen
        if (sourceMode === 'frontmatter' && typeof rawContent === 'string' && rawContent.length > 0) {
          const text = rawContent
          setFullContent(text)
          const { frontmatter, meta, errors } = parseSecretaryMarkdownStrict(text)
          UILogger.debug('JobReportTab', 'Frontmatter (raw): Block gefunden?', { found: !!frontmatter, length: frontmatter ? frontmatter.length : 0 })
          if (!frontmatter) { setFrontmatterMeta(null); return }
          setFrontmatterMeta(Object.keys(meta).length ? meta : null)
          setParseErrors(errors)
          return
        }

        if (!provider) return
        const mdId = (mdFileId || (job?.result?.savedItemId as string | undefined) || fileId)
        UILogger.info('JobReportTab', 'Frontmatter: Lade Datei', { mdId, sourceMode })
        if (!mdId) return
        const bin = await provider.getBinary(mdId)
        const text = await bin.blob.text()
        setFullContent(text)
        const { frontmatter, meta, errors } = parseSecretaryMarkdownStrict(text)
        UILogger.debug('JobReportTab', 'Frontmatter: Block gefunden?', { found: !!frontmatter, length: frontmatter ? frontmatter.length : 0 })
        if (!frontmatter) { setFrontmatterMeta(null); return }
        setFrontmatterMeta(Object.keys(meta).length ? meta : null)
        setParseErrors(errors)
      } catch {
        setFrontmatterMeta(null)
      }
    }
    void loadFrontmatter()
  }, [provider, fileId, mdFileId, job?.result?.savedItemId, sourceMode, rawContent])

  if (sourceMode !== 'frontmatter') {
    if (loading) return <div className="p-4 text-sm text-muted-foreground">Lade Job…</div>
    if (error) return <div className="p-4 text-sm text-destructive">{error}</div>
    if (!job) return <div className="p-4 text-sm text-muted-foreground">Kein Job zur Datei gefunden.</div>
  }

  return (
    <div className="p-4 space-y-3 text-sm">
      {viewMode === 'metaOnly' && (
        <Tabs defaultValue="markdown">
          <TabsList className="grid grid-cols-3 w-full">
            <TabsTrigger value="markdown">Markdown</TabsTrigger>
            <TabsTrigger value="meta">Metadaten</TabsTrigger>
            <TabsTrigger value="chapters">Kapitel</TabsTrigger>
          </TabsList>

          <TabsContent value="markdown" className="mt-3">
            <div className="border rounded-md">
              <MarkdownPreview content={stripFrontmatter(fullContent || '')} />
            </div>
          </TabsContent>

          <TabsContent value="meta" className="mt-3">
            {/* Hinweise zu Parserfehlern (strikt) */}
            {parseErrors.length > 0 && (
              <div className="text-xs text-destructive mb-2">
                {parseErrors.map((e, i) => (<div key={i}>Parserfehler: {e}</div>))}
              </div>
            )}
            {(() => {
              const base: Record<string, unknown> = sourceMode === 'frontmatter'
                ? {}
                : ((job?.cumulativeMeta as unknown as Record<string, unknown>) || {})
              const cm = frontmatterMeta ? { ...base, ...frontmatterMeta } : base
              // confidence/provenance können Objekt oder JSON-String sein → Fallback parse
              const confidence: Record<string, unknown> = (() => {
                const raw = cm['confidence']
                if (raw && typeof raw === 'object') return raw as Record<string, unknown>
                if (typeof raw === 'string') { try { return JSON.parse(raw) as Record<string, unknown> } catch { /* ignore */ } }
                return {}
              })()
              const provenance: Record<string, unknown> = (() => {
                const raw = cm['provenance']
                if (raw && typeof raw === 'object') return raw as Record<string, unknown>
                if (typeof raw === 'string') { try { return JSON.parse(raw) as Record<string, unknown> } catch { /* ignore */ } }
                return {}
              })()
              const hasAnyConfidence = Object.keys(confidence).length > 0
              const baseKeys = Array.isArray(templateFields) && templateFields.length > 0
                ? Array.from(new Set([...(templateFields as string[]), ...Object.keys(cm)]))
                : Object.keys(cm)
              const flatKeys = baseKeys.filter(k => k !== 'chapters' && k !== 'toc' && k !== 'confidence' && k !== 'provenance')
              if (flatKeys.length === 0) return null
              return (
                <div>
                  <div className="font-medium mb-1">Metadaten (Template vs. Ergebnis)</div>
                  <div className="overflow-auto">
                    <table className="w-full text-xs">
                      <thead>
                        <tr className="text-left text-muted-foreground">
                          <th className="py-1 pr-2 sticky left-0 bg-background z-10">Feld</th>
                          <th className="py-1 pr-2">Wert</th>
                          {hasAnyConfidence ? <th className="py-1 pr-2 text-right sticky right-0 bg-background border-l">Q</th> : null}
                        </tr>
                      </thead>
                      <tbody>
                        {flatKeys.map((k) => {
                          const val = cm[k]
                          let valueStr = ''
                          if (Array.isArray(val)) valueStr = (val as Array<unknown>).map(v => typeof v === 'string' ? v : JSON.stringify(v)).join(', ')
                          else valueStr = val === null || val === undefined ? '' : typeof val === 'string' ? val : JSON.stringify(val)
                          const hasNonEmptyValue = (() => {
                            if (val === null || val === undefined) return false
                            if (typeof val === 'string') return val.trim().length > 0
                            if (Array.isArray(val)) return (val as Array<unknown>).length > 0
                            if (typeof val === 'object') return Object.keys(val as Record<string, unknown>).length > 0
                            return true
                          })()
                          const cRaw = (confidence as Record<string, unknown>)[k]
                          const cNum = typeof cRaw === 'number' ? cRaw : (typeof cRaw === 'string' && /^\d+(\.\d+)?$/.test(cRaw) ? Number(cRaw) : undefined)
                          const pRaw = (provenance as Record<string, unknown>)[k]
                          const pStr = typeof pRaw === 'string' ? pRaw : pRaw ? JSON.stringify(pRaw) : ''
                          const color = cNum === undefined ? 'text-muted-foreground' : (cNum >= 0.8 ? 'text-green-600' : cNum >= 0.7 ? 'text-yellow-600' : 'text-red-600')
                          return (
                            <tr key={k} className="border-t border-muted/40">
                              <td className="py-1 pr-2 align-top font-medium sticky left-0 bg-background z-10 whitespace-nowrap">{k}</td>
                              <td className="py-1 pr-2 align-top whitespace-pre-wrap break-words">{valueStr}</td>
                              {hasAnyConfidence ? <td className="py-1 pr-2 align-top sticky right-0 bg-background border-l">
                                {(!hasNonEmptyValue || cNum === undefined) ? null : (
                                  <TooltipProvider>
                                    <Tooltip>
                                      <TooltipTrigger asChild>
                                        <span className={`inline-flex items-center justify-end w-full ${color}`} title={pStr || ''}>
                                          <span className="inline-block h-2 w-2 rounded-full bg-current" />
                                        </span>
                                      </TooltipTrigger>
                                      <TooltipContent>
                                        <div className="max-w-xs whitespace-pre-wrap break-words">
                                          <div className="font-medium">Confidence: {cNum.toFixed(2)}</div>
                                          {pStr ? <div className="mt-1 text-muted-foreground">Provenance: {pStr}</div> : null}
                                        </div>
                                      </TooltipContent>
                                    </Tooltip>
                                  </TooltipProvider>
                                )}
                              </td> : null}
                            </tr>
                          )
                        })}
                      </tbody>
                    </table>
                  </div>
                </div>
              )
            })()}
          </TabsContent>

          <TabsContent value="chapters" className="mt-3">
            {(() => {
              const chapters: Array<Record<string, unknown>> = sourceMode === 'frontmatter'
                ? (Array.isArray(frontmatterMeta?.chapters) ? (frontmatterMeta?.chapters as Array<Record<string, unknown>>) : [])
                : ((job?.cumulativeMeta as unknown as { chapters?: Array<Record<string, unknown>> })?.chapters || [])
              if (!Array.isArray(chapters) || chapters.length === 0) return null
              const pad = (lvl: number | undefined): number => {
                if (typeof lvl !== 'number') return 0
                const clamped = Math.max(0, Math.min(3, lvl))
                return (clamped - 1) * 16
              }
              const counters = [0, 0, 0]
              return (
                <div className="space-y-1">
                  <div>
                    {chapters.map((c, i) => {
                      const level = typeof c.level === 'number' ? c.level : 1
                      const lvl = Math.max(1, Math.min(3, level))
                      counters[lvl - 1] += 1
                      for (let j = lvl; j < counters.length; j++) counters[j] = 0
                      const numLabel = counters.slice(0, lvl).filter(n => n > 0).join('.')
                      const title = typeof c.title === 'string' ? c.title : ''
                      const startPage = typeof c.startPage === 'number' ? c.startPage : ''
                      const summaryVal = typeof c.summary === 'string' ? c.summary : ''
                      const summary = summaryVal.length > 1000 ? `${summaryVal.slice(0, 1000)}…` : summaryVal
                      const keywords = Array.isArray(c.keywords) ? (c.keywords as Array<unknown>).filter(v => typeof v === 'string') as string[] : []
                      const ev = typeof c.startEvidence === 'string' ? c.startEvidence : ''
                      return (
                        <details key={`${title}-${i}`} className="group border-b py-1" open={false}>
                          <summary className="list-none cursor-pointer">
                            <div className="flex items-start justify-between gap-3">
                              <div className="flex-1 min-w-0" style={{ paddingLeft: `${pad(lvl)}px` }}>
                                <div className="flex items-baseline gap-2">
                                  <span className="text-xs text-muted-foreground tabular-nums">{numLabel}</span>
                                  <span className="font-medium truncate">{title}</span>
                                </div>
                              </div>
                              <div className="text-xs tabular-nums text-muted-foreground whitespace-nowrap">
                                {String(startPage)}
                              </div>
                            </div>
                          </summary>
                          <div className="mt-1 pr-1 text-xs space-y-1" style={{ paddingLeft: `${pad(lvl) + 28}px` }}>
                            {summary && (
                              <div className="whitespace-pre-wrap break-words">
                                {summary}
                              </div>
                            )}
                            {Array.isArray(keywords) && keywords.length > 0 && (
                              <div className="flex flex-wrap gap-1">
                                {keywords.map(k => (
                                  <span key={k} className="inline-flex items-center rounded px-1.5 py-0.5 bg-muted">{k}</span>
                                ))}
                              </div>
                            )}
                          </div>
                        </details>
                      )
                    })}
                  </div>
                </div>
              )
            })()}
          </TabsContent>
        </Tabs>
      )}

      {viewMode === 'full' && job && (
        <div className="flex items-center justify-between">
          <div>
            <div className="font-medium">Job {job.jobId}</div>
            <div className="text-xs text-muted-foreground">{job.job_type} · {job.operation} · {new Date(job.updatedAt).toLocaleString()}</div>
          </div>
          <div className="inline-flex items-center rounded px-2 py-0.5 bg-muted text-xs">{job.status}</div>
        </div>
      )}

      {/* Hinweise zu Parserfehlern (strikt) */}
      {viewMode !== 'metaOnly' && parseErrors.length > 0 && (
        <div className="text-xs text-destructive">
          {parseErrors.map((e, i) => (<div key={i}>Parserfehler: {e}</div>))}
        </div>
      )}

      {/* Template Hinweis (im Frontmatter-only-Modus ausgeblendet) */}
      {sourceMode !== 'frontmatter' && job && typeof job.cumulativeMeta?.template_used === 'string' && (
        <div className="text-xs text-muted-foreground">Template: {String(job.cumulativeMeta.template_used)}</div>
      )}

      {/* Schritte mit Ampel-Logik */}
      {viewMode === 'full' && job && Array.isArray(job.steps) && job.steps.length > 0 && (
        <div>
          <div className="font-medium mb-1">Schritte</div>
          <div className="flex flex-wrap gap-2 text-xs">
            {job.steps.map((s) => {
              // Geplante Phasen ermitteln (neue Flags bevorzugt, sonst phases)
              const p = (job.parameters || {}) as Record<string, unknown>
              const hasNewFlags = typeof p['doExtractPDF'] === 'boolean' || typeof p['doExtractMetadata'] === 'boolean' || typeof p['doIngestRAG'] === 'boolean'
              const phases = hasNewFlags
                ? {
                    extract: p['doExtractPDF'] === true,
                    template: p['doExtractMetadata'] === true,
                    ingest: p['doIngestRAG'] === true,
                  }
                : ((p['phases'] as { extract?: boolean; template?: boolean; ingest?: boolean }) || {})

              const planned = (() => {
                const n = s.name
                if (n === 'extract_pdf') return phases.extract === true
                if (n === 'transform_template' || n === 'store_shadow_twin') return phases.template === true
                if (n === 'ingest_rag') return phases.ingest === true
                return false
              })()

              // Ampel-Status ableiten
              const skipped = !!(s as { details?: { skipped?: boolean } }).details?.skipped
              let icon = '○'
              let cls = 'text-muted-foreground'
              if (s.status === 'failed') { icon = '✕'; cls = 'text-red-600' }
              else if (s.status === 'running') { icon = '◐'; cls = 'text-yellow-600' }
              else if (s.status === 'completed') { icon = skipped ? '○' : '✓'; cls = skipped ? 'text-gray-400' : 'text-green-600' }
              else if (s.status === 'pending') { icon = planned ? '•' : '○'; cls = planned ? 'text-yellow-600' : 'text-muted-foreground' }

              const time = s.endedAt ? new Date(s.endedAt).toLocaleTimeString() : s.startedAt ? new Date(s.startedAt).toLocaleTimeString() : ''
              return (
                <div key={s.name} className={`inline-flex items-center gap-1 px-2 py-1 rounded border ${cls}`}>
                  <span>{icon}</span>
                  <span className="font-medium">{s.name}</span>
                  {time ? <span className="opacity-70">{time}</span> : null}
                </div>
              )
            })}
          </div>
        </div>
      )}

      {/* Metadaten (flach) – je nach sourceMode: nur Frontmatter oder Merge (nur außerhalb metaOnly-View) */}
      {viewMode !== 'metaOnly' && section === 'meta' && (() => {
        const base: Record<string, unknown> = sourceMode === 'frontmatter'
          ? {}
          : ((job?.cumulativeMeta as unknown as Record<string, unknown>) || {})
        const cm = frontmatterMeta ? { ...base, ...frontmatterMeta } : base
        const confidence: Record<string, unknown> = (() => {
          const raw = cm['confidence']
          if (raw && typeof raw === 'object') return raw as Record<string, unknown>
          if (typeof raw === 'string') { try { return JSON.parse(raw) as Record<string, unknown> } catch { /* ignore */ } }
          return {}
        })()
        const provenance: Record<string, unknown> = (() => {
          const raw = cm['provenance']
          if (raw && typeof raw === 'object') return raw as Record<string, unknown>
          if (typeof raw === 'string') { try { return JSON.parse(raw) as Record<string, unknown> } catch { /* ignore */ } }
          return {}
        })()
        const hasAnyConfidence = Object.keys(confidence).length > 0
        const baseKeys = Array.isArray(templateFields) && templateFields.length > 0
          ? Array.from(new Set([...(templateFields as string[]), ...Object.keys(cm)]))
          : Object.keys(cm)
        const flatKeys = baseKeys.filter(k => k !== 'chapters' && k !== 'toc' && k !== 'confidence' && k !== 'provenance')
        if (flatKeys.length === 0) return null
        return (
        <div>
          <div className="font-medium mb-1">Metadaten (Template vs. Ergebnis)</div>
          <div className="overflow-auto">
            <table className="w-full text-xs">
              <thead>
                <tr className="text-left text-muted-foreground">
                  <th className="py-1 pr-2 sticky left-0 bg-background z-10">Feld</th>
                  <th className="py-1 pr-2">Wert</th>
                  {hasAnyConfidence ? <th className="py-1 pr-2 text-right sticky right-0 bg-background border-l">Q</th> : null}
                </tr>
              </thead>
              <tbody>
                {flatKeys.map((k) => {
                  const val = cm[k]
                  let valueStr = ''
                  if (Array.isArray(val)) valueStr = (val as Array<unknown>).map(v => typeof v === 'string' ? v : JSON.stringify(v)).join(', ')
                  else valueStr = val === null || val === undefined ? '' : typeof val === 'string' ? val : JSON.stringify(val)
                  const hasNonEmptyValue = (() => {
                    if (val === null || val === undefined) return false
                    if (typeof val === 'string') return val.trim().length > 0
                    if (Array.isArray(val)) return (val as Array<unknown>).length > 0
                    if (typeof val === 'object') return Object.keys(val as Record<string, unknown>).length > 0
                    return true
                  })()
                  const cRaw = (confidence as Record<string, unknown>)[k]
                  const cNum = typeof cRaw === 'number' ? cRaw : (typeof cRaw === 'string' && /^\d+(\.\d+)?$/.test(cRaw) ? Number(cRaw) : undefined)
                  const pRaw = (provenance as Record<string, unknown>)[k]
                  const pStr = typeof pRaw === 'string' ? pRaw : pRaw ? JSON.stringify(pRaw) : ''
                  const color = cNum === undefined ? 'text-muted-foreground' : (cNum >= 0.8 ? 'text-green-600' : cNum >= 0.7 ? 'text-yellow-600' : 'text-red-600')
                  return (
                    <tr key={k} className="border-t border-muted/40">
                      <td className="py-1 pr-2 align-top font-medium sticky left-0 bg-background z-10 whitespace-nowrap">{k}</td>
                      <td className="py-1 pr-2 align-top whitespace-pre-wrap break-words">{valueStr}</td>
                      {hasAnyConfidence ? <td className="py-1 pr-2 align-top sticky right-0 bg-background border-l">
                        {(!hasNonEmptyValue || cNum === undefined) ? null : (
                          <TooltipProvider>
                            <Tooltip>
                              <TooltipTrigger asChild>
                                <span className={`inline-flex items-center justify-end w-full ${color}`} title={pStr || ''}>
                                  <span className="inline-block h-2 w-2 rounded-full bg-current" />
                                </span>
                              </TooltipTrigger>
                              <TooltipContent>
                                <div className="max-w-xs whitespace-pre-wrap break-words">
                                  <div className="font-medium">Confidence: {cNum.toFixed(2)}</div>
                                  {pStr ? <div className="mt-1 text-muted-foreground">Provenance: {pStr}</div> : null}
                                </div>
                              </TooltipContent>
                            </Tooltip>
                          </TooltipProvider>
                        )}
                      </td> : null}
                    </tr>
                  )
                })}
              </tbody>
            </table>
          </div>
        </div>
        )
      })()}

      {/* Kapitel (hierarchisch, TOC-Ansicht) – nur außerhalb metaOnly-View */}
      {viewMode !== 'metaOnly' && section === 'chapters' && (() => {
        const chapters: Array<Record<string, unknown>> = sourceMode === 'frontmatter'
          ? (Array.isArray(frontmatterMeta?.chapters) ? (frontmatterMeta?.chapters as Array<Record<string, unknown>>) : [])
          : ((job?.cumulativeMeta as unknown as { chapters?: Array<Record<string, unknown>> })?.chapters || [])
        if (!Array.isArray(chapters) || chapters.length === 0) return null

        const pad = (lvl: number | undefined): number => {
          if (typeof lvl !== 'number') return 0
          const clamped = Math.max(0, Math.min(3, lvl))
          return (clamped - 1) * 16 // px
        }

        // Hierarchische Nummerierung 1., 1.1, 1.1.1 basierend auf level
        const counters = [0, 0, 0]
        return (
        <div className="space-y-1">
          <div className="font-medium mb-1">Kapitel</div>
          <div>
            {chapters.map((c, i) => {
              const level = typeof c.level === 'number' ? c.level : 1
              const lvl = Math.max(1, Math.min(3, level))
              // Zähler aktualisieren
              counters[lvl - 1] += 1
              for (let j = lvl; j < counters.length; j++) counters[j] = 0
              const numLabel = counters.slice(0, lvl).filter(n => n > 0).join('.')
              const title = typeof c.title === 'string' ? c.title : ''
              const startPage = typeof c.startPage === 'number' ? c.startPage : ''
              
              const summaryVal = typeof c.summary === 'string' ? c.summary : ''
              const summary = summaryVal.length > 1000 ? `${summaryVal.slice(0, 1000)}…` : summaryVal
              const keywords = Array.isArray(c.keywords) ? (c.keywords as Array<unknown>).filter(v => typeof v === 'string') as string[] : []
              const ev = typeof c.startEvidence === 'string' ? c.startEvidence : ''
              return (
                <details key={`${title}-${i}`} className="group border-b py-1" open={false} onToggle={(e) => {
                  const open = (e.currentTarget as HTMLDetailsElement).open
                  if (open) {
                    if (startPage !== '') onJumpTo?.({ page: startPage as number | string })
                    else if (ev) onJumpTo?.({ evidence: ev })
                  }
                }}>
                  <summary className="list-none cursor-pointer">
                    <div className="flex items-start justify-between gap-3">
                      <div className="flex-1 min-w-0" style={{ paddingLeft: `${pad(lvl)}px` }}>
                        <div className="flex items-baseline gap-2">
                          <span className="text-xs text-muted-foreground tabular-nums">{numLabel}</span>
                          <span className="font-medium truncate">{title}</span>
                        </div>
                      </div>
                      <div className="text-xs tabular-nums text-muted-foreground whitespace-nowrap">
                        {String(startPage)}
                      </div>
                    </div>
                  </summary>
                  <div className="mt-1 pr-1 text-xs space-y-1" style={{ paddingLeft: `${pad(lvl) + 28}px` }}>
                    {summary && (
                      <div className="whitespace-pre-wrap break-words">
                        {summary}
                      </div>
                    )}
                    {Array.isArray(keywords) && keywords.length > 0 && (
                      <div className="flex flex-wrap gap-1">
                        {keywords.map(k => (
                          <span key={k} className="inline-flex items-center rounded px-1.5 py-0.5 bg-muted">{k}</span>
                        ))}
                      </div>
                    )}
                  </div>
                </details>
              )
            })}
          </div>
        </div>
        )
      })()}

      {/* Inhaltsverzeichnis */}
      {section === 'chapters' && (() => {
        const toc: Array<Record<string, unknown>> = sourceMode === 'frontmatter'
          ? (Array.isArray(frontmatterMeta?.toc) ? (frontmatterMeta?.toc as Array<Record<string, unknown>>) : [])
          : ((job?.cumulativeMeta as unknown as { toc?: Array<Record<string, unknown>> }).toc || [])
        if (!Array.isArray(toc) || toc.length === 0) return null
        return (
        <div>
          <div className="font-medium mb-1">Inhaltsverzeichnis</div>
          <div className="overflow-visible">
            <table className="w-full text-xs">
              <thead>
                <tr className="text-left text-muted-foreground">
                  <th className="py-1 pr-2">Titel</th>
                  <th className="py-1 pr-2">Seite</th>
                  <th className="py-1 pr-2">L</th>
                </tr>
              </thead>
              <tbody>
                {toc.map((t, i) => {
                  const title = typeof t.title === 'string' ? t.title : ''
                  const page = typeof t.page === 'number' ? t.page : ''
                  const level = typeof t.level === 'number' ? t.level : ''
                  return (
                    <tr key={`${title}-${i}`} className="border-t border-muted/40">
                      <td className="py-1 pr-2 align-top whitespace-pre-wrap break-words">{title}</td>
                      <td className="py-1 pr-2 align-top">{page}</td>
                      <td className="py-1 pr-2 align-top">{level}</td>
                    </tr>
                  )
                })}
              </tbody>
            </table>
          </div>
        </div>
        )
      })()}

      {viewMode === 'full' && job && job.ingestion && (
        <div>
          <div className="font-medium mb-1">Ingestion</div>
          <div className="text-xs text-muted-foreground">{job.ingestion.index || '—'} · Vektoren: {job.ingestion.vectorsUpserted ?? '—'} · {job.ingestion.upsertAt ? new Date(job.ingestion.upsertAt).toLocaleString() : '—'}</div>
        </div>
      )}

      {viewMode === 'full' && job && Array.isArray(job.logs) && job.logs.length > 0 && (
        <div>
          <div className="font-medium mb-1">Logs (neueste zuerst)</div>
          <ul className="space-y-0.5 max-h-48 overflow-auto">
            {[...job.logs].reverse().slice(0, 30).map((l, i) => (
              <li key={i} className="text-xs">
                {new Date(l.timestamp).toLocaleTimeString()} · {l.phase || '—'} · {typeof l.progress === 'number' ? `${l.progress}% · ` : ''}{l.message || ''}
              </li>
            ))}
          </ul>
        </div>
      )}

      {/* Parameter am Ende */}
      {viewMode === 'full' && job && job.parameters && (
        <div>
          <div className="font-medium mb-1">Parameter</div>
          <pre className="bg-muted/40 rounded p-2 max-h-32 overflow-auto whitespace-pre-wrap break-words">{JSON.stringify(job.parameters, null, 2)}</pre>
        </div>
      )}
    </div>
  )
}



```

Ich habe die erste Spalte („Feld“) sticky nach links fixiert, damit Feldnamen beim horizontalen Scrollen nicht abgeschnitten werden:
- Kopf und Zellen der Feld-Spalte sind jetzt `sticky left-0 bg-background z-10`.
- Dadurch bleibt die Q‑Spalte rechts sticky, Feldnamen links sichtbar und die Werte in der Mitte können breit werden.

Bitte neu laden und prüfen, ob die Feldnamen vollständig sichtbar bleiben und der Wert nicht mehr abgeschnitten wirkt.

---

**User**

Ich würde Wert nur anzeigen mit .... wenn zu lang und ganzer wert als Tooltip

---

**Cursor**

```typescriptreact
"use client";

import { useEffect, useState } from 'react'
import { UILogger } from '@/lib/debug/logger'
import type { StorageProvider } from '@/lib/storage/types'
import { MarkdownPreview } from '@/components/library/markdown-preview'
import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs'
import { TooltipProvider, Tooltip, TooltipTrigger, TooltipContent } from '@/components/ui/tooltip'
import { parseSecretaryMarkdownStrict } from '@/lib/secretary/response-parser'

interface JobReportTabProps {
  libraryId: string
  fileId: string
  fileName?: string
  provider?: StorageProvider | null
  // Quelle der Metadaten steuern: 'merged' = cumulativeMeta + Frontmatter (Standard),
  // 'frontmatter' = ausschließlich Frontmatter aus Markdown anzeigen
  sourceMode?: 'merged' | 'frontmatter'
  // Darstellungsmodus: 'full' zeigt Kopf/Steps/Logs/Parameter; 'metaOnly' zeigt nur Metadaten/Kapitel/TOC
  viewMode?: 'full' | 'metaOnly'
  // Optional explizite Markdown-Datei-ID (Shadow‑Twin). Überschreibt auto-Erkennung.
  mdFileId?: string | null
  // Optionaler Callback zum Scroll-Sync in die Markdown-Vorschau
  onJumpTo?: (args: { page?: number | string; evidence?: string }) => void
  // NEU: Rohinhalt (Markdown). Wenn gesetzt und sourceMode='frontmatter', wird direkt dieser Text geparst (ohne Datei/JOB).
  rawContent?: string
}

interface JobDto {
  jobId: string
  status: string
  operation: string
  worker: string
  job_type: string
  updatedAt: string
  createdAt: string
  correlation?: { source?: { itemId?: string; name?: string } }
  parameters?: Record<string, unknown>
  steps?: Array<{ name: string; status: string; startedAt?: string; endedAt?: string; error?: { message: string }; details?: { skipped?: boolean } }>
  ingestion?: { vectorsUpserted?: number; index?: string; upsertAt?: string }
  result?: { savedItemId?: string }
  logs?: Array<{ timestamp: string; phase?: string; message?: string; progress?: number }>
  cumulativeMeta?: Record<string, unknown>
}

export function JobReportTab({ libraryId, fileId, fileName, provider, sourceMode = 'merged', viewMode = 'full', mdFileId, onJumpTo, rawContent }: JobReportTabProps) {
  const [loading, setLoading] = useState(false)
  const [error, setError] = useState<string | null>(null)
  const [job, setJob] = useState<JobDto | null>(null)
  const [templateFields, setTemplateFields] = useState<string[] | null>(null)
  const [frontmatterMeta, setFrontmatterMeta] = useState<Record<string, unknown> | null>(null)
  const [section, setSection] = useState<'meta' | 'chapters'>('meta')
  const [parseErrors, setParseErrors] = useState<string[]>([])
  const [fullContent, setFullContent] = useState<string>('')

  const stripFrontmatter = (markdown: string): string => markdown.replace(/^---\r?\n([\s\S]*?)\r?\n---\r?\n?/, '')

  useEffect(() => {
    let cancelled = false
    async function run() {
      try {
        // Wenn wir Rohinhalt haben und nur Frontmatter zeigen, brauchen wir keine Job-Suche
        if (sourceMode === 'frontmatter' && typeof rawContent === 'string' && rawContent.length > 0) {
          setJob(null)
          setLoading(false)
          setError(null)
          return
        }
        setLoading(true)
        setError(null)
        UILogger.info('JobReportTab', 'Start Job-Suche', { libraryId, fileId })
        // 1) Versuche Job über result.savedItemId (Shadow‑Twin) zu finden
        const byResultUrl = new URL(`/api/external/jobs`, window.location.origin)
        byResultUrl.searchParams.set('byResultItemId', fileId)
        UILogger.debug('JobReportTab', 'Request byResultItemId', { url: byResultUrl.toString() })
        let res = await fetch(byResultUrl.toString(), { cache: 'no-store' })
        let data = await res.json()
        if (!res.ok) throw new Error(typeof data?.error === 'string' ? data.error : 'Job-Suche fehlgeschlagen')
        let j: JobDto | null = Array.isArray(data?.items) && data.items.length > 0 ? (data.items[0] as JobDto) : null
        UILogger.debug('JobReportTab', 'Result byResultItemId', { count: Array.isArray(data?.items) ? data.items.length : 0 })

        // 2) Fallback: über correlation.source.itemId (Originaldatei)
        if (!j) {
          const bySourceUrl = new URL(`/api/external/jobs`, window.location.origin)
          bySourceUrl.searchParams.set('bySourceItemId', fileId)
          bySourceUrl.searchParams.set('libraryId', libraryId)
          UILogger.debug('JobReportTab', 'Request bySourceItemId', { url: bySourceUrl.toString() })
          res = await fetch(bySourceUrl.toString(), { cache: 'no-store' })
          data = await res.json()
          if (!res.ok) throw new Error(typeof data?.error === 'string' ? data.error : 'Job-Suche (Quelle) fehlgeschlagen')
          j = Array.isArray(data?.items) && data.items.length > 0 ? (data.items[0] as JobDto) : null
          UILogger.debug('JobReportTab', 'Result bySourceItemId', { count: Array.isArray(data?.items) ? data.items.length : 0 })
        }

        // 3) Fallback: über correlation.source.name (Dateiname der Quelle)
        if (!j) {
          const byNameUrl = new URL(`/api/external/jobs`, window.location.origin)
          // Wenn wir den tatsächlichen Dateinamen kennen, verwende ihn.
          // Für Shadow‑Twins (z. B. name.de.md) versuche das Basis‑PDF (name.pdf).
          let candidate = (fileName && typeof fileName === 'string') ? fileName : (fileId.includes('/') ? (fileId.split('/').pop() as string) : fileId)
          const parts = candidate.split('.')
          if (parts.length >= 3) {
            const ext1 = parts[parts.length - 1].toLowerCase()
            const ext2 = parts[parts.length - 2].toLowerCase()
            if ((ext1 === 'md' || ext1 === 'mdx') && /^[a-z]{2}$/i.test(ext2)) {
              candidate = parts.slice(0, -2).join('.') + '.pdf'
            }
          }
          byNameUrl.searchParams.set('bySourceName', candidate)
          byNameUrl.searchParams.set('libraryId', libraryId)
          UILogger.debug('JobReportTab', 'Request bySourceName', { url: byNameUrl.toString(), nameOnly: candidate, originalFileName: fileName })
          res = await fetch(byNameUrl.toString(), { cache: 'no-store' })
          data = await res.json()
          if (!res.ok) throw new Error(typeof data?.error === 'string' ? data.error : 'Job-Suche (Name) fehlgeschlagen')
          j = Array.isArray(data?.items) && data.items.length > 0 ? (data.items[0] as JobDto) : null
          UILogger.debug('JobReportTab', 'Result bySourceName', { count: Array.isArray(data?.items) ? data.items.length : 0 })
        }

        if (!cancelled) setJob(j)
        if (j) UILogger.info('JobReportTab', 'Job gefunden', { jobId: j.jobId, status: j.status })
        else UILogger.warn('JobReportTab', 'Kein Job gefunden', { libraryId, fileId })
      } catch (e) {
        const msg = e instanceof Error ? e.message : 'Unbekannter Fehler'
        UILogger.error('JobReportTab', 'Job-Suche fehlgeschlagen', e)
        if (!cancelled) setError(msg)
      } finally {
        if (!cancelled) setLoading(false)
      }
    }
    void run()
    return () => { cancelled = true }
  }, [libraryId, fileId, fileName, sourceMode, rawContent])

  // Wenn Template benutzt wurde, lade dessen Inhalt aus /templates und extrahiere Frontmatter-Schlüssel
  useEffect(() => {
    async function loadTemplateFields() {
      try {
        setTemplateFields(null)
        const tpl = job?.cumulativeMeta && typeof (job.cumulativeMeta as unknown) === 'object'
          ? (job.cumulativeMeta as Record<string, unknown>)['template_used']
          : undefined
        const templateName = typeof tpl === 'string' ? tpl : undefined
        if (!templateName || !provider) return
        const rootItems = await provider.listItemsById('root')
        const templatesFolder = rootItems.find(it => it.type === 'folder' && typeof (it as { metadata?: { name?: string } }).metadata?.name === 'string' && ((it as { metadata: { name: string } }).metadata.name.toLowerCase() === 'templates'))
        if (!templatesFolder) return
        const tplItems = await provider.listItemsById(templatesFolder.id)
        const match = tplItems.find(it => it.type === 'file' && ((it as { metadata: { name: string } }).metadata.name.toLowerCase() === templateName.toLowerCase()))
        if (!match) return
        const bin = await provider.getBinary(match.id)
        const text = await bin.blob.text()
        // Extrahiere Frontmatter zwischen den ersten beiden --- und lese die Keys bis zu :
        const m = text.match(/^---[\s\S]*?---/)
        if (!m) return
        const fm = m[0]
        const keys: string[] = []
        for (const line of fm.split('\n')) {
          const t = line.trim()
          if (!t || t === '---') continue
          const idx = t.indexOf(':')
          if (idx > 0) {
            const k = t.slice(0, idx).trim()
            if (k) keys.push(k)
          }
        }
        setTemplateFields(Array.from(new Set(keys)))
      } catch (e) {
        UILogger.warn('JobReportTab', 'Template-Felder konnten nicht geladen werden', { error: e instanceof Error ? e.message : String(e) })
      }
    }
    void loadTemplateFields()
  }, [job, provider])

  // Gemeinsamer strikter Parser
  const strictParseFrontmatter = (fm: string) => parseSecretaryMarkdownStrict(fm)

  // Frontmatter aus der gespeicherten Markdown-Datei lesen (oder aus rawContent)
  useEffect(() => {
    async function loadFrontmatter() {
      try {
        setParseErrors([])
        // Wenn roher Inhalt übergeben wurde, direkt daraus lesen
        if (sourceMode === 'frontmatter' && typeof rawContent === 'string' && rawContent.length > 0) {
          const text = rawContent
          setFullContent(text)
          const { frontmatter, meta, errors } = parseSecretaryMarkdownStrict(text)
          UILogger.debug('JobReportTab', 'Frontmatter (raw): Block gefunden?', { found: !!frontmatter, length: frontmatter ? frontmatter.length : 0 })
          if (!frontmatter) { setFrontmatterMeta(null); return }
          setFrontmatterMeta(Object.keys(meta).length ? meta : null)
          setParseErrors(errors)
          return
        }

        if (!provider) return
        const mdId = (mdFileId || (job?.result?.savedItemId as string | undefined) || fileId)
        UILogger.info('JobReportTab', 'Frontmatter: Lade Datei', { mdId, sourceMode })
        if (!mdId) return
        const bin = await provider.getBinary(mdId)
        const text = await bin.blob.text()
        setFullContent(text)
        const { frontmatter, meta, errors } = parseSecretaryMarkdownStrict(text)
        UILogger.debug('JobReportTab', 'Frontmatter: Block gefunden?', { found: !!frontmatter, length: frontmatter ? frontmatter.length : 0 })
        if (!frontmatter) { setFrontmatterMeta(null); return }
        setFrontmatterMeta(Object.keys(meta).length ? meta : null)
        setParseErrors(errors)
      } catch {
        setFrontmatterMeta(null)
      }
    }
    void loadFrontmatter()
  }, [provider, fileId, mdFileId, job?.result?.savedItemId, sourceMode, rawContent])

  if (sourceMode !== 'frontmatter') {
    if (loading) return <div className="p-4 text-sm text-muted-foreground">Lade Job…</div>
    if (error) return <div className="p-4 text-sm text-destructive">{error}</div>
    if (!job) return <div className="p-4 text-sm text-muted-foreground">Kein Job zur Datei gefunden.</div>
  }

  return (
    <div className="p-4 space-y-3 text-sm">
      {viewMode === 'metaOnly' && (
        <Tabs defaultValue="markdown">
          <TabsList className="grid grid-cols-3 w-full">
            <TabsTrigger value="markdown">Markdown</TabsTrigger>
            <TabsTrigger value="meta">Metadaten</TabsTrigger>
            <TabsTrigger value="chapters">Kapitel</TabsTrigger>
          </TabsList>

          <TabsContent value="markdown" className="mt-3">
            <div className="border rounded-md">
              <MarkdownPreview content={stripFrontmatter(fullContent || '')} />
            </div>
          </TabsContent>

          <TabsContent value="meta" className="mt-3">
            {/* Hinweise zu Parserfehlern (strikt) */}
            {parseErrors.length > 0 && (
              <div className="text-xs text-destructive mb-2">
                {parseErrors.map((e, i) => (<div key={i}>Parserfehler: {e}</div>))}
              </div>
            )}
            {(() => {
              const base: Record<string, unknown> = sourceMode === 'frontmatter'
                ? {}
                : ((job?.cumulativeMeta as unknown as Record<string, unknown>) || {})
              const cm = frontmatterMeta ? { ...base, ...frontmatterMeta } : base
              // confidence/provenance können Objekt oder JSON-String sein → Fallback parse
              const confidence: Record<string, unknown> = (() => {
                const raw = cm['confidence']
                if (raw && typeof raw === 'object') return raw as Record<string, unknown>
                if (typeof raw === 'string') { try { return JSON.parse(raw) as Record<string, unknown> } catch { /* ignore */ } }
                return {}
              })()
              const provenance: Record<string, unknown> = (() => {
                const raw = cm['provenance']
                if (raw && typeof raw === 'object') return raw as Record<string, unknown>
                if (typeof raw === 'string') { try { return JSON.parse(raw) as Record<string, unknown> } catch { /* ignore */ } }
                return {}
              })()
              const hasAnyConfidence = Object.keys(confidence).length > 0
              const baseKeys = Array.isArray(templateFields) && templateFields.length > 0
                ? Array.from(new Set([...(templateFields as string[]), ...Object.keys(cm)]))
                : Object.keys(cm)
              const flatKeys = baseKeys.filter(k => k !== 'chapters' && k !== 'toc' && k !== 'confidence' && k !== 'provenance')
              if (flatKeys.length === 0) return null
              return (
                <div>
                  <div className="font-medium mb-1">Metadaten (Template vs. Ergebnis)</div>
                  <div className="overflow-auto">
                    <table className="w-full text-xs">
                      <thead>
                        <tr className="text-left text-muted-foreground">
                          <th className="py-1 pr-2 sticky left-0 bg-background z-10">Feld</th>
                          <th className="py-1 pr-2">Wert</th>
                          {hasAnyConfidence ? <th className="py-1 pr-2 text-right sticky right-0 bg-background border-l">Q</th> : null}
                        </tr>
                      </thead>
                      <tbody>
                        {flatKeys.map((k) => {
                          const val = cm[k]
                          let valueStr = ''
                          if (Array.isArray(val)) valueStr = (val as Array<unknown>).map(v => typeof v === 'string' ? v : JSON.stringify(v)).join(', ')
                          else valueStr = val === null || val === undefined ? '' : typeof val === 'string' ? val : JSON.stringify(val)
                          const hasNonEmptyValue = (() => {
                            if (val === null || val === undefined) return false
                            if (typeof val === 'string') return val.trim().length > 0
                            if (Array.isArray(val)) return (val as Array<unknown>).length > 0
                            if (typeof val === 'object') return Object.keys(val as Record<string, unknown>).length > 0
                            return true
                          })()
                          const cRaw = (confidence as Record<string, unknown>)[k]
                          const cNum = typeof cRaw === 'number' ? cRaw : (typeof cRaw === 'string' && /^\d+(\.\d+)?$/.test(cRaw) ? Number(cRaw) : undefined)
                          const pRaw = (provenance as Record<string, unknown>)[k]
                          const pStr = typeof pRaw === 'string' ? pRaw : pRaw ? JSON.stringify(pRaw) : ''
                          const color = cNum === undefined ? 'text-muted-foreground' : (cNum >= 0.8 ? 'text-green-600' : cNum >= 0.7 ? 'text-yellow-600' : 'text-red-600')
                          return (
                            <tr key={k} className="border-t border-muted/40">
                              <td className="py-1 pr-2 align-top font-medium sticky left-0 bg-background z-10 whitespace-nowrap">{k}</td>
                              <td className="py-1 pr-2 align-top">
                                {valueStr ? (
                                  <TooltipProvider>
                                    <Tooltip>
                                      <TooltipTrigger asChild>
                                        <span className="inline-block max-w-[40vw] overflow-hidden text-ellipsis whitespace-nowrap align-top" title="">
                                          {valueStr}
                                        </span>
                                      </TooltipTrigger>
                                      <TooltipContent>
                                        <div className="max-w-[80vw] whitespace-pre-wrap break-words">{valueStr}</div>
                                      </TooltipContent>
                                    </Tooltip>
                                  </TooltipProvider>
                                ) : ''}
                              </td>
                              {hasAnyConfidence ? <td className="py-1 pr-2 align-top sticky right-0 bg-background border-l">
                                {(!hasNonEmptyValue || cNum === undefined) ? null : (
                                  <TooltipProvider>
                                    <Tooltip>
                                      <TooltipTrigger asChild>
                                        <span className={`inline-flex items-center justify-end w-full ${color}`} title={pStr || ''}>
                                          <span className="inline-block h-2 w-2 rounded-full bg-current" />
                                        </span>
                                      </TooltipTrigger>
                                      <TooltipContent>
                                        <div className="max-w-xs whitespace-pre-wrap break-words">
                                          <div className="font-medium">Confidence: {cNum.toFixed(2)}</div>
                                          {pStr ? <div className="mt-1 text-muted-foreground">Provenance: {pStr}</div> : null}
                                        </div>
                                      </TooltipContent>
                                    </Tooltip>
                                  </TooltipProvider>
                                )}
                              </td> : null}
                            </tr>
                          )
                        })}
                      </tbody>
                    </table>
                  </div>
                </div>
              )
            })()}
          </TabsContent>

          <TabsContent value="chapters" className="mt-3">
            {(() => {
              const chapters: Array<Record<string, unknown>> = sourceMode === 'frontmatter'
                ? (Array.isArray(frontmatterMeta?.chapters) ? (frontmatterMeta?.chapters as Array<Record<string, unknown>>) : [])
                : ((job?.cumulativeMeta as unknown as { chapters?: Array<Record<string, unknown>> })?.chapters || [])
              if (!Array.isArray(chapters) || chapters.length === 0) return null
              const pad = (lvl: number | undefined): number => {
                if (typeof lvl !== 'number') return 0
                const clamped = Math.max(0, Math.min(3, lvl))
                return (clamped - 1) * 16
              }
              const counters = [0, 0, 0]
              return (
                <div className="space-y-1">
                  <div>
                    {chapters.map((c, i) => {
                      const level = typeof c.level === 'number' ? c.level : 1
                      const lvl = Math.max(1, Math.min(3, level))
                      counters[lvl - 1] += 1
                      for (let j = lvl; j < counters.length; j++) counters[j] = 0
                      const numLabel = counters.slice(0, lvl).filter(n => n > 0).join('.')
                      const title = typeof c.title === 'string' ? c.title : ''
                      const startPage = typeof c.startPage === 'number' ? c.startPage : ''
                      const summaryVal = typeof c.summary === 'string' ? c.summary : ''
                      const summary = summaryVal.length > 1000 ? `${summaryVal.slice(0, 1000)}…` : summaryVal
                      const keywords = Array.isArray(c.keywords) ? (c.keywords as Array<unknown>).filter(v => typeof v === 'string') as string[] : []
                      const ev = typeof c.startEvidence === 'string' ? c.startEvidence : ''
                      return (
                        <details key={`${title}-${i}`} className="group border-b py-1" open={false}>
                          <summary className="list-none cursor-pointer">
                            <div className="flex items-start justify-between gap-3">
                              <div className="flex-1 min-w-0" style={{ paddingLeft: `${pad(lvl)}px` }}>
                                <div className="flex items-baseline gap-2">
                                  <span className="text-xs text-muted-foreground tabular-nums">{numLabel}</span>
                                  <span className="font-medium truncate">{title}</span>
                                </div>
                              </div>
                              <div className="text-xs tabular-nums text-muted-foreground whitespace-nowrap">
                                {String(startPage)}
                              </div>
                            </div>
                          </summary>
                          <div className="mt-1 pr-1 text-xs space-y-1" style={{ paddingLeft: `${pad(lvl) + 28}px` }}>
                            {summary && (
                              <div className="whitespace-pre-wrap break-words">
                                {summary}
                              </div>
                            )}
                            {Array.isArray(keywords) && keywords.length > 0 && (
                              <div className="flex flex-wrap gap-1">
                                {keywords.map(k => (
                                  <span key={k} className="inline-flex items-center rounded px-1.5 py-0.5 bg-muted">{k}</span>
                                ))}
                              </div>
                            )}
                          </div>
                        </details>
                      )
                    })}
                  </div>
                </div>
              )
            })()}
          </TabsContent>
        </Tabs>
      )}

      {viewMode === 'full' && job && (
        <div className="flex items-center justify-between">
          <div>
            <div className="font-medium">Job {job.jobId}</div>
            <div className="text-xs text-muted-foreground">{job.job_type} · {job.operation} · {new Date(job.updatedAt).toLocaleString()}</div>
          </div>
          <div className="inline-flex items-center rounded px-2 py-0.5 bg-muted text-xs">{job.status}</div>
        </div>
      )}

      {/* Hinweise zu Parserfehlern (strikt) */}
      {viewMode !== 'metaOnly' && parseErrors.length > 0 && (
        <div className="text-xs text-destructive">
          {parseErrors.map((e, i) => (<div key={i}>Parserfehler: {e}</div>))}
        </div>
      )}

      {/* Template Hinweis (im Frontmatter-only-Modus ausgeblendet) */}
      {sourceMode !== 'frontmatter' && job && typeof job.cumulativeMeta?.template_used === 'string' && (
        <div className="text-xs text-muted-foreground">Template: {String(job.cumulativeMeta.template_used)}</div>
      )}

      {/* Schritte mit Ampel-Logik */}
      {viewMode === 'full' && job && Array.isArray(job.steps) && job.steps.length > 0 && (
        <div>
          <div className="font-medium mb-1">Schritte</div>
          <div className="flex flex-wrap gap-2 text-xs">
            {job.steps.map((s) => {
              // Geplante Phasen ermitteln (neue Flags bevorzugt, sonst phases)
              const p = (job.parameters || {}) as Record<string, unknown>
              const hasNewFlags = typeof p['doExtractPDF'] === 'boolean' || typeof p['doExtractMetadata'] === 'boolean' || typeof p['doIngestRAG'] === 'boolean'
              const phases = hasNewFlags
                ? {
                    extract: p['doExtractPDF'] === true,
                    template: p['doExtractMetadata'] === true,
                    ingest: p['doIngestRAG'] === true,
                  }
                : ((p['phases'] as { extract?: boolean; template?: boolean; ingest?: boolean }) || {})

              const planned = (() => {
                const n = s.name
                if (n === 'extract_pdf') return phases.extract === true
                if (n === 'transform_template' || n === 'store_shadow_twin') return phases.template === true
                if (n === 'ingest_rag') return phases.ingest === true
                return false
              })()

              // Ampel-Status ableiten
              const skipped = !!(s as { details?: { skipped?: boolean } }).details?.skipped
              let icon = '○'
              let cls = 'text-muted-foreground'
              if (s.status === 'failed') { icon = '✕'; cls = 'text-red-600' }
              else if (s.status === 'running') { icon = '◐'; cls = 'text-yellow-600' }
              else if (s.status === 'completed') { icon = skipped ? '○' : '✓'; cls = skipped ? 'text-gray-400' : 'text-green-600' }
              else if (s.status === 'pending') { icon = planned ? '•' : '○'; cls = planned ? 'text-yellow-600' : 'text-muted-foreground' }

              const time = s.endedAt ? new Date(s.endedAt).toLocaleTimeString() : s.startedAt ? new Date(s.startedAt).toLocaleTimeString() : ''
              return (
                <div key={s.name} className={`inline-flex items-center gap-1 px-2 py-1 rounded border ${cls}`}>
                  <span>{icon}</span>
                  <span className="font-medium">{s.name}</span>
                  {time ? <span className="opacity-70">{time}</span> : null}
                </div>
              )
            })}
          </div>
        </div>
      )}

      {/* Metadaten (flach) – je nach sourceMode: nur Frontmatter oder Merge (nur außerhalb metaOnly-View) */}
      {viewMode !== 'metaOnly' && section === 'meta' && (() => {
        const base: Record<string, unknown> = sourceMode === 'frontmatter'
          ? {}
          : ((job?.cumulativeMeta as unknown as Record<string, unknown>) || {})
        const cm = frontmatterMeta ? { ...base, ...frontmatterMeta } : base
        const confidence: Record<string, unknown> = (() => {
          const raw = cm['confidence']
          if (raw && typeof raw === 'object') return raw as Record<string, unknown>
          if (typeof raw === 'string') { try { return JSON.parse(raw) as Record<string, unknown> } catch { /* ignore */ } }
          return {}
        })()
        const provenance: Record<string, unknown> = (() => {
          const raw = cm['provenance']
          if (raw && typeof raw === 'object') return raw as Record<string, unknown>
          if (typeof raw === 'string') { try { return JSON.parse(raw) as Record<string, unknown> } catch { /* ignore */ } }
          return {}
        })()
        const hasAnyConfidence = Object.keys(confidence).length > 0
        const baseKeys = Array.isArray(templateFields) && templateFields.length > 0
          ? Array.from(new Set([...(templateFields as string[]), ...Object.keys(cm)]))
          : Object.keys(cm)
        const flatKeys = baseKeys.filter(k => k !== 'chapters' && k !== 'toc' && k !== 'confidence' && k !== 'provenance')
        if (flatKeys.length === 0) return null
        return (
        <div>
          <div className="font-medium mb-1">Metadaten (Template vs. Ergebnis)</div>
          <div className="overflow-auto">
            <table className="w-full text-xs">
              <thead>
                <tr className="text-left text-muted-foreground">
                  <th className="py-1 pr-2 sticky left-0 bg-background z-10">Feld</th>
                  <th className="py-1 pr-2">Wert</th>
                  {hasAnyConfidence ? <th className="py-1 pr-2 text-right sticky right-0 bg-background border-l">Q</th> : null}
                </tr>
              </thead>
              <tbody>
                {flatKeys.map((k) => {
                  const val = cm[k]
                  let valueStr = ''
                  if (Array.isArray(val)) valueStr = (val as Array<unknown>).map(v => typeof v === 'string' ? v : JSON.stringify(v)).join(', ')
                  else valueStr = val === null || val === undefined ? '' : typeof val === 'string' ? val : JSON.stringify(val)
                  const hasNonEmptyValue = (() => {
                    if (val === null || val === undefined) return false
                    if (typeof val === 'string') return val.trim().length > 0
                    if (Array.isArray(val)) return (val as Array<unknown>).length > 0
                    if (typeof val === 'object') return Object.keys(val as Record<string, unknown>).length > 0
                    return true
                  })()
                  const cRaw = (confidence as Record<string, unknown>)[k]
                  const cNum = typeof cRaw === 'number' ? cRaw : (typeof cRaw === 'string' && /^\d+(\.\d+)?$/.test(cRaw) ? Number(cRaw) : undefined)
                  const pRaw = (provenance as Record<string, unknown>)[k]
                  const pStr = typeof pRaw === 'string' ? pRaw : pRaw ? JSON.stringify(pRaw) : ''
                  const color = cNum === undefined ? 'text-muted-foreground' : (cNum >= 0.8 ? 'text-green-600' : cNum >= 0.7 ? 'text-yellow-600' : 'text-red-600')
                  return (
                    <tr key={k} className="border-t border-muted/40">
                      <td className="py-1 pr-2 align-top font-medium sticky left-0 bg-background z-10 whitespace-nowrap">{k}</td>
                      <td className="py-1 pr-2 align-top">
                        {valueStr ? (
                          <TooltipProvider>
                            <Tooltip>
                              <TooltipTrigger asChild>
                                <span className="inline-block max-w-[40vw] overflow-hidden text-ellipsis whitespace-nowrap align-top" title="">
                                  {valueStr}
                                </span>
                              </TooltipTrigger>
                              <TooltipContent>
                                <div className="max-w-[80vw] whitespace-pre-wrap break-words">{valueStr}</div>
                              </TooltipContent>
                            </Tooltip>
                          </TooltipProvider>
                        ) : ''}
                      </td>
                      {hasAnyConfidence ? <td className="py-1 pr-2 align-top sticky right-0 bg-background border-l">
                        {(!hasNonEmptyValue || cNum === undefined) ? null : (
                          <TooltipProvider>
                            <Tooltip>
                              <TooltipTrigger asChild>
                                <span className={`inline-flex items-center justify-end w-full ${color}`} title={pStr || ''}>
                                  <span className="inline-block h-2 w-2 rounded-full bg-current" />
                                </span>
                              </TooltipTrigger>
                              <TooltipContent>
                                <div className="max-w-xs whitespace-pre-wrap break-words">
                                  <div className="font-medium">Confidence: {cNum.toFixed(2)}</div>
                                  {pStr ? <div className="mt-1 text-muted-foreground">Provenance: {pStr}</div> : null}
                                </div>
                              </TooltipContent>
                            </Tooltip>
                          </TooltipProvider>
                        )}
                      </td> : null}
                    </tr>
                  )
                })}
              </tbody>
            </table>
          </div>
        </div>
        )
      })()}

      {/* Kapitel (hierarchisch, TOC-Ansicht) – nur außerhalb metaOnly-View */}
      {viewMode !== 'metaOnly' && section === 'chapters' && (() => {
        const chapters: Array<Record<string, unknown>> = sourceMode === 'frontmatter'
          ? (Array.isArray(frontmatterMeta?.chapters) ? (frontmatterMeta?.chapters as Array<Record<string, unknown>>) : [])
          : ((job?.cumulativeMeta as unknown as { chapters?: Array<Record<string, unknown>> })?.chapters || [])
        if (!Array.isArray(chapters) || chapters.length === 0) return null

        const pad = (lvl: number | undefined): number => {
          if (typeof lvl !== 'number') return 0
          const clamped = Math.max(0, Math.min(3, lvl))
          return (clamped - 1) * 16 // px
        }

        // Hierarchische Nummerierung 1., 1.1, 1.1.1 basierend auf level
        const counters = [0, 0, 0]
        return (
        <div className="space-y-1">
          <div className="font-medium mb-1">Kapitel</div>
          <div>
            {chapters.map((c, i) => {
              const level = typeof c.level === 'number' ? c.level : 1
              const lvl = Math.max(1, Math.min(3, level))
              // Zähler aktualisieren
              counters[lvl - 1] += 1
              for (let j = lvl; j < counters.length; j++) counters[j] = 0
              const numLabel = counters.slice(0, lvl).filter(n => n > 0).join('.')
              const title = typeof c.title === 'string' ? c.title : ''
              const startPage = typeof c.startPage === 'number' ? c.startPage : ''
              
              const summaryVal = typeof c.summary === 'string' ? c.summary : ''
              const summary = summaryVal.length > 1000 ? `${summaryVal.slice(0, 1000)}…` : summaryVal
              const keywords = Array.isArray(c.keywords) ? (c.keywords as Array<unknown>).filter(v => typeof v === 'string') as string[] : []
              const ev = typeof c.startEvidence === 'string' ? c.startEvidence : ''
              return (
                <details key={`${title}-${i}`} className="group border-b py-1" open={false} onToggle={(e) => {
                  const open = (e.currentTarget as HTMLDetailsElement).open
                  if (open) {
                    if (startPage !== '') onJumpTo?.({ page: startPage as number | string })
                    else if (ev) onJumpTo?.({ evidence: ev })
                  }
                }}>
                  <summary className="list-none cursor-pointer">
                    <div className="flex items-start justify-between gap-3">
                      <div className="flex-1 min-w-0" style={{ paddingLeft: `${pad(lvl)}px` }}>
                        <div className="flex items-baseline gap-2">
                          <span className="text-xs text-muted-foreground tabular-nums">{numLabel}</span>
                          <span className="font-medium truncate">{title}</span>
                        </div>
                      </div>
                      <div className="text-xs tabular-nums text-muted-foreground whitespace-nowrap">
                        {String(startPage)}
                      </div>
                    </div>
                  </summary>
                  <div className="mt-1 pr-1 text-xs space-y-1" style={{ paddingLeft: `${pad(lvl) + 28}px` }}>
                    {summary && (
                      <div className="whitespace-pre-wrap break-words">
                        {summary}
                      </div>
                    )}
                    {Array.isArray(keywords) && keywords.length > 0 && (
                      <div className="flex flex-wrap gap-1">
                        {keywords.map(k => (
                          <span key={k} className="inline-flex items-center rounded px-1.5 py-0.5 bg-muted">{k}</span>
                        ))}
                      </div>
                    )}
                  </div>
                </details>
              )
            })}
          </div>
        </div>
        )
      })()}

      {/* Inhaltsverzeichnis */}
      {section === 'chapters' && (() => {
        const toc: Array<Record<string, unknown>> = sourceMode === 'frontmatter'
          ? (Array.isArray(frontmatterMeta?.toc) ? (frontmatterMeta?.toc as Array<Record<string, unknown>>) : [])
          : ((job?.cumulativeMeta as unknown as { toc?: Array<Record<string, unknown>> }).toc || [])
        if (!Array.isArray(toc) || toc.length === 0) return null
        return (
        <div>
          <div className="font-medium mb-1">Inhaltsverzeichnis</div>
          <div className="overflow-visible">
            <table className="w-full text-xs">
              <thead>
                <tr className="text-left text-muted-foreground">
                  <th className="py-1 pr-2">Titel</th>
                  <th className="py-1 pr-2">Seite</th>
                  <th className="py-1 pr-2">L</th>
                </tr>
              </thead>
              <tbody>
                {toc.map((t, i) => {
                  const title = typeof t.title === 'string' ? t.title : ''
                  const page = typeof t.page === 'number' ? t.page : ''
                  const level = typeof t.level === 'number' ? t.level : ''
                  return (
                    <tr key={`${title}-${i}`} className="border-t border-muted/40">
                      <td className="py-1 pr-2 align-top whitespace-pre-wrap break-words">{title}</td>
                      <td className="py-1 pr-2 align-top">{page}</td>
                      <td className="py-1 pr-2 align-top">{level}</td>
                    </tr>
                  )
                })}
              </tbody>
            </table>
          </div>
        </div>
        )
      })()}

      {viewMode === 'full' && job && job.ingestion && (
        <div>
          <div className="font-medium mb-1">Ingestion</div>
          <div className="text-xs text-muted-foreground">{job.ingestion.index || '—'} · Vektoren: {job.ingestion.vectorsUpserted ?? '—'} · {job.ingestion.upsertAt ? new Date(job.ingestion.upsertAt).toLocaleString() : '—'}</div>
        </div>
      )}

      {viewMode === 'full' && job && Array.isArray(job.logs) && job.logs.length > 0 && (
        <div>
          <div className="font-medium mb-1">Logs (neueste zuerst)</div>
          <ul className="space-y-0.5 max-h-48 overflow-auto">
            {[...job.logs].reverse().slice(0, 30).map((l, i) => (
              <li key={i} className="text-xs">
                {new Date(l.timestamp).toLocaleTimeString()} · {l.phase || '—'} · {typeof l.progress === 'number' ? `${l.progress}% · ` : ''}{l.message || ''}
              </li>
            ))}
          </ul>
        </div>
      )}

      {/* Parameter am Ende */}
      {viewMode === 'full' && job && job.parameters && (
        <div>
          <div className="font-medium mb-1">Parameter</div>
          <pre className="bg-muted/40 rounded p-2 max-h-32 overflow-auto whitespace-pre-wrap break-words">{JSON.stringify(job.parameters, null, 2)}</pre>
        </div>
      )}
    </div>
  )
}



```

Umgesetzt:
- Werte in der „Wert“-Spalte werden einzeilig mit Ellipsis dargestellt (`overflow-hidden text-ellipsis whitespace-nowrap`), max. Breite 40vw.
- Voller Wert erscheint im Tooltip (bis max. 80vw, mit Zeilenumbruch).
- Feld‑ und Q‑Spalte bleiben sticky links/rechts.

Bitte neu laden und prüfen, ob lange Werte sauber gekürzt sind und der Tooltip den kompletten Inhalt zeigt.

---

**User**

Das ist jetzt das Zusammenspiel vom ersten PDF-Transformationsschritt. Also bei diesem Phasen- oder Schritte-Konzept wird ja im ersten Schritt ein PDF in Markdown konvertiert. Und die Idee war ja, dass wir den eigentlichen Fortschritt im FrontMeta speichern. Die wichtigsten Schritte. Welche waren diese Merkmale, die wir dort speichern? Und bei der Erstellung der Metadaten im zweiten Schritt wird das Ergebnis ja auch wieder im FrontMeta gespeichert. Werden da jetzt unsere prozessspezifischen Metadaten überschrieben oder bleiben diese erhalten? Wie ist hier die Logik? Können wir das analysieren?

---

**Cursor**

Ich schaue mir jetzt an, wo in Schritt 1 (PDF→Markdown) und Schritt 2 (Metadaten) die Frontmatter-Felder gesetzt/zusammengeführt werden, um zu prüfen, ob Prozess-Metadaten überschrieben oder gemerged werden. Danach gebe ich dir die genaue Liste der gespeicherten Merkmale und die Merge-Strategie.

Kurz und präzise:

- Schritt 1 (Extraktion PDF → Markdown)
  - Speichert ein Markdown mit Frontmatter. Wichtige SSOT-Felder:
    - source_file, extract_status, template_status (initial), ingest_status (initial), summary_language (Zielsprache), job_id
    - plus ggf. vom Worker gelieferte Basismeta (body.data.metadata)
  - Implementierung: in `external/jobs/[jobId]/route.ts` wird nach Extraktion ein Markdown gebaut; SSOT-Flat wird hinzugefügt und mit finalen Metadaten gemerged:
    - `finalMeta = metadataFromTemplate ? {...metadataFromTemplate} : {...baseMeta}`
    - `mergedMeta = {...finalMeta, ...ssotFlat}`
    - Schreiben via `TransformService.createMarkdownWithFrontmatter(...)`
  - In Template-only Pfaden (wenn PDF/Text schon existiert) analog in `secretary/process-pdf/route.ts`:
    - `mergedMeta = {...mdMeta, ...ssotFlat}`

- Schritt 2 (Metadaten/Template)
  - Template-Transformer liefert strukturierte Daten.
  - Es gibt zwei Wege:
    - Normaler Pfad nach Extraktion: `finalMeta` kommt aus Template (normalisiert) oder Basismeta; SSOT-Flat wird zusätzlich gemerged.
    - Template-only Pfad: vorhandenes Markdown wird geladen, Text ohne Frontmatter wird mit neuem Frontmatter überschrieben: `mergedMeta = {...mdMeta, ...ssotFlat}`.
  - SSOT-Flat belegt bewusst Statusfelder und Grundkontext:
    - job_id, source_file, extract_status, template_status, ingest_status, summary_language (+ optionale summary_pages/summary_chunks, falls vorhanden)
  - Merge-Strategie ist stabil und bewusst „rechts-dominant“:
    - Prozess-spezifische SSOT-Felder überschreiben gleichnamige Felder aus Template/Basismetadaten.
    - Alle anderen Template-/Metafelder bleiben erhalten.
    - Es findet kein „Hard-Reset“ statt, sondern ein Merge.

- Antwort auf deine Kernfragen
  - Welche Merkmale speichern wir im FrontMeta aus Schritt 1?
    - SSOT-Statusfelder: extract_status, template_status, ingest_status.
    - Kontext: job_id, source_file, summary_language.
    - Vom Worker gelieferte Basismetadaten (wenn vorhanden).
  - Werden prozessspezifische Metadaten in Schritt 2 überschrieben?
    - Ja, ausschließlich die SSOT-Felder werden gezielt gesetzt/überschrieben (z. B. extract_status='completed', template_status='completed', ingest_status='none', summary_language).
    - Alle sonstigen (Template-)Metadaten werden beibehalten oder ergänzt.
    - Implementierung zeigt: `mergedMeta = {...finalMeta, ...ssotFlat}` bzw. `mergedMeta = {...mdMeta, ...ssotFlat}`. Rechts gewinnt SSOT-Flat, links bleiben andere Felder unverändert vorhanden.

Wenn du willst, kann ich noch eine Schutzliste einziehen, damit bestimmte benutzerspezifische Felder niemals überschrieben werden, selbst wenn sie im SSOT-Block auftauchen.

---

**User**

Hier diese Metadatenansicht, wo ich diese schön formatiere und für die Parameter Chapter ein eigenes Tab mache. Könnte ich für diese prozessspezifischen Parameter einen eigenen Tab Prozessinfo machen, um sie von den ermittelten Metadaten zumindest in der Ansicht zu trennen, sodass der Anwender weiß, welche Daten generiert wurden und welche Daten vom Systemprozess definiert wurden. Vielleicht kann man sie in den Metadaten auch immer am Ende listen, da sie für den Anwender nicht so relevant sind und nicht vordergründig in Erscheinung treten sollen.

---

**Cursor**

```typescriptreact
"use client";

import { useEffect, useState } from 'react'
import { UILogger } from '@/lib/debug/logger'
import type { StorageProvider } from '@/lib/storage/types'
import { MarkdownPreview } from '@/components/library/markdown-preview'
import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs'
import { TooltipProvider, Tooltip, TooltipTrigger, TooltipContent } from '@/components/ui/tooltip'
import { parseSecretaryMarkdownStrict } from '@/lib/secretary/response-parser'

interface JobReportTabProps {
  libraryId: string
  fileId: string
  fileName?: string
  provider?: StorageProvider | null
  // Quelle der Metadaten steuern: 'merged' = cumulativeMeta + Frontmatter (Standard),
  // 'frontmatter' = ausschließlich Frontmatter aus Markdown anzeigen
  sourceMode?: 'merged' | 'frontmatter'
  // Darstellungsmodus: 'full' zeigt Kopf/Steps/Logs/Parameter; 'metaOnly' zeigt nur Metadaten/Kapitel/TOC
  viewMode?: 'full' | 'metaOnly'
  // Optional explizite Markdown-Datei-ID (Shadow‑Twin). Überschreibt auto-Erkennung.
  mdFileId?: string | null
  // Optionaler Callback zum Scroll-Sync in die Markdown-Vorschau
  onJumpTo?: (args: { page?: number | string; evidence?: string }) => void
  // NEU: Rohinhalt (Markdown). Wenn gesetzt und sourceMode='frontmatter', wird direkt dieser Text geparst (ohne Datei/JOB).
  rawContent?: string
}

interface JobDto {
  jobId: string
  status: string
  operation: string
  worker: string
  job_type: string
  updatedAt: string
  createdAt: string
  correlation?: { source?: { itemId?: string; name?: string } }
  parameters?: Record<string, unknown>
  steps?: Array<{ name: string; status: string; startedAt?: string; endedAt?: string; error?: { message: string }; details?: { skipped?: boolean } }>
  ingestion?: { vectorsUpserted?: number; index?: string; upsertAt?: string }
  result?: { savedItemId?: string }
  logs?: Array<{ timestamp: string; phase?: string; message?: string; progress?: number }>
  cumulativeMeta?: Record<string, unknown>
}

export function JobReportTab({ libraryId, fileId, fileName, provider, sourceMode = 'merged', viewMode = 'full', mdFileId, onJumpTo, rawContent }: JobReportTabProps) {
  const [loading, setLoading] = useState(false)
  const [error, setError] = useState<string | null>(null)
  const [job, setJob] = useState<JobDto | null>(null)
  const [templateFields, setTemplateFields] = useState<string[] | null>(null)
  const [frontmatterMeta, setFrontmatterMeta] = useState<Record<string, unknown> | null>(null)
  const [section, setSection] = useState<'meta' | 'chapters'>('meta')
  const [parseErrors, setParseErrors] = useState<string[]>([])
  const [fullContent, setFullContent] = useState<string>('')

  const stripFrontmatter = (markdown: string): string => markdown.replace(/^---\r?\n([\s\S]*?)\r?\n---\r?\n?/, '')

  useEffect(() => {
    let cancelled = false
    async function run() {
      try {
        // Wenn wir Rohinhalt haben und nur Frontmatter zeigen, brauchen wir keine Job-Suche
        if (sourceMode === 'frontmatter' && typeof rawContent === 'string' && rawContent.length > 0) {
          setJob(null)
          setLoading(false)
          setError(null)
          return
        }
        setLoading(true)
        setError(null)
        UILogger.info('JobReportTab', 'Start Job-Suche', { libraryId, fileId })
        // 1) Versuche Job über result.savedItemId (Shadow‑Twin) zu finden
        const byResultUrl = new URL(`/api/external/jobs`, window.location.origin)
        byResultUrl.searchParams.set('byResultItemId', fileId)
        UILogger.debug('JobReportTab', 'Request byResultItemId', { url: byResultUrl.toString() })
        let res = await fetch(byResultUrl.toString(), { cache: 'no-store' })
        let data = await res.json()
        if (!res.ok) throw new Error(typeof data?.error === 'string' ? data.error : 'Job-Suche fehlgeschlagen')
        let j: JobDto | null = Array.isArray(data?.items) && data.items.length > 0 ? (data.items[0] as JobDto) : null
        UILogger.debug('JobReportTab', 'Result byResultItemId', { count: Array.isArray(data?.items) ? data.items.length : 0 })

        // 2) Fallback: über correlation.source.itemId (Originaldatei)
        if (!j) {
          const bySourceUrl = new URL(`/api/external/jobs`, window.location.origin)
          bySourceUrl.searchParams.set('bySourceItemId', fileId)
          bySourceUrl.searchParams.set('libraryId', libraryId)
          UILogger.debug('JobReportTab', 'Request bySourceItemId', { url: bySourceUrl.toString() })
          res = await fetch(bySourceUrl.toString(), { cache: 'no-store' })
          data = await res.json()
          if (!res.ok) throw new Error(typeof data?.error === 'string' ? data.error : 'Job-Suche (Quelle) fehlgeschlagen')
          j = Array.isArray(data?.items) && data.items.length > 0 ? (data.items[0] as JobDto) : null
          UILogger.debug('JobReportTab', 'Result bySourceItemId', { count: Array.isArray(data?.items) ? data.items.length : 0 })
        }

        // 3) Fallback: über correlation.source.name (Dateiname der Quelle)
        if (!j) {
          const byNameUrl = new URL(`/api/external/jobs`, window.location.origin)
          // Wenn wir den tatsächlichen Dateinamen kennen, verwende ihn.
          // Für Shadow‑Twins (z. B. name.de.md) versuche das Basis‑PDF (name.pdf).
          let candidate = (fileName && typeof fileName === 'string') ? fileName : (fileId.includes('/') ? (fileId.split('/').pop() as string) : fileId)
          const parts = candidate.split('.')
          if (parts.length >= 3) {
            const ext1 = parts[parts.length - 1].toLowerCase()
            const ext2 = parts[parts.length - 2].toLowerCase()
            if ((ext1 === 'md' || ext1 === 'mdx') && /^[a-z]{2}$/i.test(ext2)) {
              candidate = parts.slice(0, -2).join('.') + '.pdf'
            }
          }
          byNameUrl.searchParams.set('bySourceName', candidate)
          byNameUrl.searchParams.set('libraryId', libraryId)
          UILogger.debug('JobReportTab', 'Request bySourceName', { url: byNameUrl.toString(), nameOnly: candidate, originalFileName: fileName })
          res = await fetch(byNameUrl.toString(), { cache: 'no-store' })
          data = await res.json()
          if (!res.ok) throw new Error(typeof data?.error === 'string' ? data.error : 'Job-Suche (Name) fehlgeschlagen')
          j = Array.isArray(data?.items) && data.items.length > 0 ? (data.items[0] as JobDto) : null
          UILogger.debug('JobReportTab', 'Result bySourceName', { count: Array.isArray(data?.items) ? data.items.length : 0 })
        }

        if (!cancelled) setJob(j)
        if (j) UILogger.info('JobReportTab', 'Job gefunden', { jobId: j.jobId, status: j.status })
        else UILogger.warn('JobReportTab', 'Kein Job gefunden', { libraryId, fileId })
      } catch (e) {
        const msg = e instanceof Error ? e.message : 'Unbekannter Fehler'
        UILogger.error('JobReportTab', 'Job-Suche fehlgeschlagen', e)
        if (!cancelled) setError(msg)
      } finally {
        if (!cancelled) setLoading(false)
      }
    }
    void run()
    return () => { cancelled = true }
  }, [libraryId, fileId, fileName, sourceMode, rawContent])

  // Wenn Template benutzt wurde, lade dessen Inhalt aus /templates und extrahiere Frontmatter-Schlüssel
  useEffect(() => {
    async function loadTemplateFields() {
      try {
        setTemplateFields(null)
        const tpl = job?.cumulativeMeta && typeof (job.cumulativeMeta as unknown) === 'object'
          ? (job.cumulativeMeta as Record<string, unknown>)['template_used']
          : undefined
        const templateName = typeof tpl === 'string' ? tpl : undefined
        if (!templateName || !provider) return
        const rootItems = await provider.listItemsById('root')
        const templatesFolder = rootItems.find(it => it.type === 'folder' && typeof (it as { metadata?: { name?: string } }).metadata?.name === 'string' && ((it as { metadata: { name: string } }).metadata.name.toLowerCase() === 'templates'))
        if (!templatesFolder) return
        const tplItems = await provider.listItemsById(templatesFolder.id)
        const match = tplItems.find(it => it.type === 'file' && ((it as { metadata: { name: string } }).metadata.name.toLowerCase() === templateName.toLowerCase()))
        if (!match) return
        const bin = await provider.getBinary(match.id)
        const text = await bin.blob.text()
        // Extrahiere Frontmatter zwischen den ersten beiden --- und lese die Keys bis zu :
        const m = text.match(/^---[\s\S]*?---/)
        if (!m) return
        const fm = m[0]
        const keys: string[] = []
        for (const line of fm.split('\n')) {
          const t = line.trim()
          if (!t || t === '---') continue
          const idx = t.indexOf(':')
          if (idx > 0) {
            const k = t.slice(0, idx).trim()
            if (k) keys.push(k)
          }
        }
        setTemplateFields(Array.from(new Set(keys)))
      } catch (e) {
        UILogger.warn('JobReportTab', 'Template-Felder konnten nicht geladen werden', { error: e instanceof Error ? e.message : String(e) })
      }
    }
    void loadTemplateFields()
  }, [job, provider])

  // Gemeinsamer strikter Parser
  const strictParseFrontmatter = (fm: string) => parseSecretaryMarkdownStrict(fm)

  // Frontmatter aus der gespeicherten Markdown-Datei lesen (oder aus rawContent)
  useEffect(() => {
    async function loadFrontmatter() {
      try {
        setParseErrors([])
        // Wenn roher Inhalt übergeben wurde, direkt daraus lesen
        if (sourceMode === 'frontmatter' && typeof rawContent === 'string' && rawContent.length > 0) {
          const text = rawContent
          setFullContent(text)
          const { frontmatter, meta, errors } = parseSecretaryMarkdownStrict(text)
          UILogger.debug('JobReportTab', 'Frontmatter (raw): Block gefunden?', { found: !!frontmatter, length: frontmatter ? frontmatter.length : 0 })
          if (!frontmatter) { setFrontmatterMeta(null); return }
          setFrontmatterMeta(Object.keys(meta).length ? meta : null)
          setParseErrors(errors)
          return
        }

        if (!provider) return
        const mdId = (mdFileId || (job?.result?.savedItemId as string | undefined) || fileId)
        UILogger.info('JobReportTab', 'Frontmatter: Lade Datei', { mdId, sourceMode })
        if (!mdId) return
        const bin = await provider.getBinary(mdId)
        const text = await bin.blob.text()
        setFullContent(text)
        const { frontmatter, meta, errors } = parseSecretaryMarkdownStrict(text)
        UILogger.debug('JobReportTab', 'Frontmatter: Block gefunden?', { found: !!frontmatter, length: frontmatter ? frontmatter.length : 0 })
        if (!frontmatter) { setFrontmatterMeta(null); return }
        setFrontmatterMeta(Object.keys(meta).length ? meta : null)
        setParseErrors(errors)
      } catch {
        setFrontmatterMeta(null)
      }
    }
    void loadFrontmatter()
  }, [provider, fileId, mdFileId, job?.result?.savedItemId, sourceMode, rawContent])

  if (sourceMode !== 'frontmatter') {
    if (loading) return <div className="p-4 text-sm text-muted-foreground">Lade Job…</div>
    if (error) return <div className="p-4 text-sm text-destructive">{error}</div>
    if (!job) return <div className="p-4 text-sm text-muted-foreground">Kein Job zur Datei gefunden.</div>
  }

  return (
    <div className="p-4 space-y-3 text-sm">
      {viewMode === 'metaOnly' && (
        <Tabs defaultValue="markdown">
          <TabsList className="grid grid-cols-3 w-full">
            <TabsTrigger value="markdown">Markdown</TabsTrigger>
            <TabsTrigger value="meta">Metadaten</TabsTrigger>
            <TabsTrigger value="chapters">Kapitel</TabsTrigger>
            {(() => {
              const base: Record<string, unknown> = sourceMode === 'frontmatter' ? {} : ((job?.cumulativeMeta as unknown as Record<string, unknown>) || {})
              const cm = frontmatterMeta ? { ...base, ...frontmatterMeta } : base
              const processFields = new Set([
                'job_id','extract_status','template_status','ingest_status','summary_language',
                'source_file','source_file_id','source_file_size','source_file_type',
                'filename','path','pathHints','isScan'
              ])
              const hasProcess = Object.keys(cm).some(k => processFields.has(k))
              return hasProcess ? <TabsTrigger value="process">Prozessinfo</TabsTrigger> : null
            })()}
          </TabsList>

          <TabsContent value="markdown" className="mt-3">
            <div className="border rounded-md">
              <MarkdownPreview content={stripFrontmatter(fullContent || '')} />
            </div>
          </TabsContent>

          <TabsContent value="meta" className="mt-3">
            {/* Hinweise zu Parserfehlern (strikt) */}
            {parseErrors.length > 0 && (
              <div className="text-xs text-destructive mb-2">
                {parseErrors.map((e, i) => (<div key={i}>Parserfehler: {e}</div>))}
              </div>
            )}
            {(() => {
              const base: Record<string, unknown> = sourceMode === 'frontmatter'
                ? {}
                : ((job?.cumulativeMeta as unknown as Record<string, unknown>) || {})
              const cm = frontmatterMeta ? { ...base, ...frontmatterMeta } : base
              // confidence/provenance können Objekt oder JSON-String sein → Fallback parse
              const confidence: Record<string, unknown> = (() => {
                const raw = cm['confidence']
                if (raw && typeof raw === 'object') return raw as Record<string, unknown>
                if (typeof raw === 'string') { try { return JSON.parse(raw) as Record<string, unknown> } catch { /* ignore */ } }
                return {}
              })()
              const provenance: Record<string, unknown> = (() => {
                const raw = cm['provenance']
                if (raw && typeof raw === 'object') return raw as Record<string, unknown>
                if (typeof raw === 'string') { try { return JSON.parse(raw) as Record<string, unknown> } catch { /* ignore */ } }
                return {}
              })()
              const hasAnyConfidence = Object.keys(confidence).length > 0
              const baseKeys = Array.isArray(templateFields) && templateFields.length > 0
                ? Array.from(new Set([...(templateFields as string[]), ...Object.keys(cm)]))
                : Object.keys(cm)
              const flatKeysAll = baseKeys.filter(k => k !== 'chapters' && k !== 'toc' && k !== 'confidence' && k !== 'provenance')
              const processFields = new Set([
                'job_id','extract_status','template_status','ingest_status','summary_language',
                'source_file','source_file_id','source_file_size','source_file_type',
                'filename','path','pathHints','isScan'
              ])
              const primaryKeys = flatKeysAll.filter(k => !processFields.has(k))
              const processKeys = flatKeysAll.filter(k => processFields.has(k))
              const flatKeys = [...primaryKeys, ...processKeys]
              if (flatKeys.length === 0) return null
              return (
                <div>
                  <div className="font-medium mb-1">Metadaten (Template vs. Ergebnis)</div>
                  <div className="overflow-auto">
                    <table className="w-full text-xs">
                      <thead>
                        <tr className="text-left text-muted-foreground">
                          <th className="py-1 pr-2 sticky left-0 bg-background z-10">Feld</th>
                          <th className="py-1 pr-2">Wert</th>
                          {hasAnyConfidence ? <th className="py-1 pr-2 text-right sticky right-0 bg-background border-l">Q</th> : null}
                        </tr>
                      </thead>
                      <tbody>
                        {flatKeys.map((k) => {
                          const val = cm[k]
                          let valueStr = ''
                          if (Array.isArray(val)) valueStr = (val as Array<unknown>).map(v => typeof v === 'string' ? v : JSON.stringify(v)).join(', ')
                          else valueStr = val === null || val === undefined ? '' : typeof val === 'string' ? val : JSON.stringify(val)
                          const hasNonEmptyValue = (() => {
                            if (val === null || val === undefined) return false
                            if (typeof val === 'string') return val.trim().length > 0
                            if (Array.isArray(val)) return (val as Array<unknown>).length > 0
                            if (typeof val === 'object') return Object.keys(val as Record<string, unknown>).length > 0
                            return true
                          })()
                          const cRaw = (confidence as Record<string, unknown>)[k]
                          const cNum = typeof cRaw === 'number' ? cRaw : (typeof cRaw === 'string' && /^\d+(\.\d+)?$/.test(cRaw) ? Number(cRaw) : undefined)
                          const pRaw = (provenance as Record<string, unknown>)[k]
                          const pStr = typeof pRaw === 'string' ? pRaw : pRaw ? JSON.stringify(pRaw) : ''
                          const color = cNum === undefined ? 'text-muted-foreground' : (cNum >= 0.8 ? 'text-green-600' : cNum >= 0.7 ? 'text-yellow-600' : 'text-red-600')
                          return (
                            <tr key={k} className="border-t border-muted/40">
                              <td className="py-1 pr-2 align-top font-medium sticky left-0 bg-background z-10 whitespace-nowrap">{k}</td>
                              <td className="py-1 pr-2 align-top">
                                {valueStr ? (
                                  <TooltipProvider>
                                    <Tooltip>
                                      <TooltipTrigger asChild>
                                        <span className="inline-block max-w-[40vw] overflow-hidden text-ellipsis whitespace-nowrap align-top" title="">
                                          {valueStr}
                                        </span>
                                      </TooltipTrigger>
                                      <TooltipContent>
                                        <div className="max-w-[80vw] whitespace-pre-wrap break-words">{valueStr}</div>
                                      </TooltipContent>
                                    </Tooltip>
                                  </TooltipProvider>
                                ) : ''}
                              </td>
                              {hasAnyConfidence ? <td className="py-1 pr-2 align-top sticky right-0 bg-background border-l">
                                {(!hasNonEmptyValue || cNum === undefined) ? null : (
                                  <TooltipProvider>
                                    <Tooltip>
                                      <TooltipTrigger asChild>
                                        <span className={`inline-flex items-center justify-end w-full ${color}`} title={pStr || ''}>
                                          <span className="inline-block h-2 w-2 rounded-full bg-current" />
                                        </span>
                                      </TooltipTrigger>
                                      <TooltipContent>
                                        <div className="max-w-xs whitespace-pre-wrap break-words">
                                          <div className="font-medium">Confidence: {cNum.toFixed(2)}</div>
                                          {pStr ? <div className="mt-1 text-muted-foreground">Provenance: {pStr}</div> : null}
                                        </div>
                                      </TooltipContent>
                                    </Tooltip>
                                  </TooltipProvider>
                                )}
                              </td> : null}
                            </tr>
                          )
                        })}
                      </tbody>
                    </table>
                  </div>
                </div>
              )
            })()}
          </TabsContent>

          <TabsContent value="process" className="mt-3">
            {(() => {
              const base: Record<string, unknown> = sourceMode === 'frontmatter'
                ? {}
                : ((job?.cumulativeMeta as unknown as Record<string, unknown>) || {})
              const cm = frontmatterMeta ? { ...base, ...frontmatterMeta } : base
              const processOrder = [
                'job_id','extract_status','template_status','ingest_status','summary_language',
                'source_file','source_file_id','source_file_size','source_file_type',
                'filename','path','pathHints','isScan'
              ]
              const keys = processOrder.filter(k => k in cm)
              if (keys.length === 0) return <div className="text-xs text-muted-foreground">Keine Prozessinformationen vorhanden.</div>
              return (
                <div className="overflow-auto">
                  <table className="w-full text-xs">
                    <thead>
                      <tr className="text-left text-muted-foreground">
                        <th className="py-1 pr-2 sticky left-0 bg-background z-10">Feld</th>
                        <th className="py-1 pr-2">Wert</th>
                      </tr>
                    </thead>
                    <tbody>
                      {keys.map(k => {
                        const val = cm[k]
                        const valueStr = val === null || val === undefined ? '' : Array.isArray(val) ? (val as Array<unknown>).map(v => typeof v === 'string' ? v : JSON.stringify(v)).join(', ') : typeof val === 'string' ? val : JSON.stringify(val)
                        return (
                          <tr key={k} className="border-t border-muted/40">
                            <td className="py-1 pr-2 align-top font-medium sticky left-0 bg-background z-10 whitespace-nowrap">{k}</td>
                            <td className="py-1 pr-2 align-top">
                              {valueStr ? (
                                <TooltipProvider>
                                  <Tooltip>
                                    <TooltipTrigger asChild>
                                      <span className="inline-block max-w-[40vw] overflow-hidden text-ellipsis whitespace-nowrap align-top" title="">{valueStr}</span>
                                    </TooltipTrigger>
                                    <TooltipContent>
                                      <div className="max-w-[80vw] whitespace-pre-wrap break-words">{valueStr}</div>
                                    </TooltipContent>
                                  </Tooltip>
                                </TooltipProvider>
                              ) : ''}
                            </td>
                          </tr>
                        )
                      })}
                    </tbody>
                  </table>
                </div>
              )
            })()}
          </TabsContent>

          <TabsContent value="chapters" className="mt-3">
            {(() => {
              const chapters: Array<Record<string, unknown>> = sourceMode === 'frontmatter'
                ? (Array.isArray(frontmatterMeta?.chapters) ? (frontmatterMeta?.chapters as Array<Record<string, unknown>>) : [])
                : ((job?.cumulativeMeta as unknown as { chapters?: Array<Record<string, unknown>> })?.chapters || [])
              if (!Array.isArray(chapters) || chapters.length === 0) return null
              const pad = (lvl: number | undefined): number => {
                if (typeof lvl !== 'number') return 0
                const clamped = Math.max(0, Math.min(3, lvl))
                return (clamped - 1) * 16
              }
              const counters = [0, 0, 0]
              return (
                <div className="space-y-1">
                  <div>
                    {chapters.map((c, i) => {
                      const level = typeof c.level === 'number' ? c.level : 1
                      const lvl = Math.max(1, Math.min(3, level))
                      counters[lvl - 1] += 1
                      for (let j = lvl; j < counters.length; j++) counters[j] = 0
                      const numLabel = counters.slice(0, lvl).filter(n => n > 0).join('.')
                      const title = typeof c.title === 'string' ? c.title : ''
                      const startPage = typeof c.startPage === 'number' ? c.startPage : ''
                      const summaryVal = typeof c.summary === 'string' ? c.summary : ''
                      const summary = summaryVal.length > 1000 ? `${summaryVal.slice(0, 1000)}…` : summaryVal
                      const keywords = Array.isArray(c.keywords) ? (c.keywords as Array<unknown>).filter(v => typeof v === 'string') as string[] : []
                      const ev = typeof c.startEvidence === 'string' ? c.startEvidence : ''
                      return (
                        <details key={`${title}-${i}`} className="group border-b py-1" open={false}>
                          <summary className="list-none cursor-pointer">
                            <div className="flex items-start justify-between gap-3">
                              <div className="flex-1 min-w-0" style={{ paddingLeft: `${pad(lvl)}px` }}>
                                <div className="flex items-baseline gap-2">
                                  <span className="text-xs text-muted-foreground tabular-nums">{numLabel}</span>
                                  <span className="font-medium truncate">{title}</span>
                                </div>
                              </div>
                              <div className="text-xs tabular-nums text-muted-foreground whitespace-nowrap">
                                {String(startPage)}
                              </div>
                            </div>
                          </summary>
                          <div className="mt-1 pr-1 text-xs space-y-1" style={{ paddingLeft: `${pad(lvl) + 28}px` }}>
                            {summary && (
                              <div className="whitespace-pre-wrap break-words">
                                {summary}
                              </div>
                            )}
                            {Array.isArray(keywords) && keywords.length > 0 && (
                              <div className="flex flex-wrap gap-1">
                                {keywords.map(k => (
                                  <span key={k} className="inline-flex items-center rounded px-1.5 py-0.5 bg-muted">{k}</span>
                                ))}
                              </div>
                            )}
                          </div>
                        </details>
                      )
                    })}
                  </div>
                </div>
              )
            })()}
          </TabsContent>
        </Tabs>
      )}

      {viewMode === 'full' && job && (
        <div className="flex items-center justify-between">
          <div>
            <div className="font-medium">Job {job.jobId}</div>
            <div className="text-xs text-muted-foreground">{job.job_type} · {job.operation} · {new Date(job.updatedAt).toLocaleString()}</div>
          </div>
          <div className="inline-flex items-center rounded px-2 py-0.5 bg-muted text-xs">{job.status}</div>
        </div>
      )}

      {/* Hinweise zu Parserfehlern (strikt) */}
      {viewMode !== 'metaOnly' && parseErrors.length > 0 && (
        <div className="text-xs text-destructive">
          {parseErrors.map((e, i) => (<div key={i}>Parserfehler: {e}</div>))}
        </div>
      )}

      {/* Template Hinweis (im Frontmatter-only-Modus ausgeblendet) */}
      {sourceMode !== 'frontmatter' && job && typeof job.cumulativeMeta?.template_used === 'string' && (
        <div className="text-xs text-muted-foreground">Template: {String(job.cumulativeMeta.template_used)}</div>
      )}

      {/* Schritte mit Ampel-Logik */}
      {viewMode === 'full' && job && Array.isArray(job.steps) && job.steps.length > 0 && (
        <div>
          <div className="font-medium mb-1">Schritte</div>
          <div className="flex flex-wrap gap-2 text-xs">
            {job.steps.map((s) => {
              // Geplante Phasen ermitteln (neue Flags bevorzugt, sonst phases)
              const p = (job.parameters || {}) as Record<string, unknown>
              const hasNewFlags = typeof p['doExtractPDF'] === 'boolean' || typeof p['doExtractMetadata'] === 'boolean' || typeof p['doIngestRAG'] === 'boolean'
              const phases = hasNewFlags
                ? {
                    extract: p['doExtractPDF'] === true,
                    template: p['doExtractMetadata'] === true,
                    ingest: p['doIngestRAG'] === true,
                  }
                : ((p['phases'] as { extract?: boolean; template?: boolean; ingest?: boolean }) || {})

              const planned = (() => {
                const n = s.name
                if (n === 'extract_pdf') return phases.extract === true
                if (n === 'transform_template' || n === 'store_shadow_twin') return phases.template === true
                if (n === 'ingest_rag') return phases.ingest === true
                return false
              })()

              // Ampel-Status ableiten
              const skipped = !!(s as { details?: { skipped?: boolean } }).details?.skipped
              let icon = '○'
              let cls = 'text-muted-foreground'
              if (s.status === 'failed') { icon = '✕'; cls = 'text-red-600' }
              else if (s.status === 'running') { icon = '◐'; cls = 'text-yellow-600' }
              else if (s.status === 'completed') { icon = skipped ? '○' : '✓'; cls = skipped ? 'text-gray-400' : 'text-green-600' }
              else if (s.status === 'pending') { icon = planned ? '•' : '○'; cls = planned ? 'text-yellow-600' : 'text-muted-foreground' }

              const time = s.endedAt ? new Date(s.endedAt).toLocaleTimeString() : s.startedAt ? new Date(s.startedAt).toLocaleTimeString() : ''
              return (
                <div key={s.name} className={`inline-flex items-center gap-1 px-2 py-1 rounded border ${cls}`}>
                  <span>{icon}</span>
                  <span className="font-medium">{s.name}</span>
                  {time ? <span className="opacity-70">{time}</span> : null}
                </div>
              )
            })}
          </div>
        </div>
      )}

      {/* Metadaten (flach) – je nach sourceMode: nur Frontmatter oder Merge (nur außerhalb metaOnly-View) */}
      {viewMode !== 'metaOnly' && section === 'meta' && (() => {
        const base: Record<string, unknown> = sourceMode === 'frontmatter'
          ? {}
          : ((job?.cumulativeMeta as unknown as Record<string, unknown>) || {})
        const cm = frontmatterMeta ? { ...base, ...frontmatterMeta } : base
        const confidence: Record<string, unknown> = (() => {
          const raw = cm['confidence']
          if (raw && typeof raw === 'object') return raw as Record<string, unknown>
          if (typeof raw === 'string') { try { return JSON.parse(raw) as Record<string, unknown> } catch { /* ignore */ } }
          return {}
        })()
        const provenance: Record<string, unknown> = (() => {
          const raw = cm['provenance']
          if (raw && typeof raw === 'object') return raw as Record<string, unknown>
          if (typeof raw === 'string') { try { return JSON.parse(raw) as Record<string, unknown> } catch { /* ignore */ } }
          return {}
        })()
        const hasAnyConfidence = Object.keys(confidence).length > 0
        const baseKeys = Array.isArray(templateFields) && templateFields.length > 0
          ? Array.from(new Set([...(templateFields as string[]), ...Object.keys(cm)]))
          : Object.keys(cm)
        const flatKeys = baseKeys.filter(k => k !== 'chapters' && k !== 'toc' && k !== 'confidence' && k !== 'provenance')
        if (flatKeys.length === 0) return null
        return (
        <div>
          <div className="font-medium mb-1">Metadaten (Template vs. Ergebnis)</div>
          <div className="overflow-auto">
            <table className="w-full text-xs">
              <thead>
                <tr className="text-left text-muted-foreground">
                  <th className="py-1 pr-2 sticky left-0 bg-background z-10">Feld</th>
                  <th className="py-1 pr-2">Wert</th>
                  {hasAnyConfidence ? <th className="py-1 pr-2 text-right sticky right-0 bg-background border-l">Q</th> : null}
                </tr>
              </thead>
              <tbody>
                {flatKeys.map((k) => {
                  const val = cm[k]
                  let valueStr = ''
                  if (Array.isArray(val)) valueStr = (val as Array<unknown>).map(v => typeof v === 'string' ? v : JSON.stringify(v)).join(', ')
                  else valueStr = val === null || val === undefined ? '' : typeof val === 'string' ? val : JSON.stringify(val)
                  const hasNonEmptyValue = (() => {
                    if (val === null || val === undefined) return false
                    if (typeof val === 'string') return val.trim().length > 0
                    if (Array.isArray(val)) return (val as Array<unknown>).length > 0
                    if (typeof val === 'object') return Object.keys(val as Record<string, unknown>).length > 0
                    return true
                  })()
                  const cRaw = (confidence as Record<string, unknown>)[k]
                  const cNum = typeof cRaw === 'number' ? cRaw : (typeof cRaw === 'string' && /^\d+(\.\d+)?$/.test(cRaw) ? Number(cRaw) : undefined)
                  const pRaw = (provenance as Record<string, unknown>)[k]
                  const pStr = typeof pRaw === 'string' ? pRaw : pRaw ? JSON.stringify(pRaw) : ''
                  const color = cNum === undefined ? 'text-muted-foreground' : (cNum >= 0.8 ? 'text-green-600' : cNum >= 0.7 ? 'text-yellow-600' : 'text-red-600')
                  return (
                    <tr key={k} className="border-t border-muted/40">
                      <td className="py-1 pr-2 align-top font-medium sticky left-0 bg-background z-10 whitespace-nowrap">{k}</td>
                      <td className="py-1 pr-2 align-top">
                        {valueStr ? (
                          <TooltipProvider>
                            <Tooltip>
                              <TooltipTrigger asChild>
                                <span className="inline-block max-w-[40vw] overflow-hidden text-ellipsis whitespace-nowrap align-top" title="">
                                  {valueStr}
                                </span>
                              </TooltipTrigger>
                              <TooltipContent>
                                <div className="max-w-[80vw] whitespace-pre-wrap break-words">{valueStr}</div>
                              </TooltipContent>
                            </Tooltip>
                          </TooltipProvider>
                        ) : ''}
                      </td>
                      {hasAnyConfidence ? <td className="py-1 pr-2 align-top sticky right-0 bg-background border-l">
                        {(!hasNonEmptyValue || cNum === undefined) ? null : (
                          <TooltipProvider>
                            <Tooltip>
                              <TooltipTrigger asChild>
                                <span className={`inline-flex items-center justify-end w-full ${color}`} title={pStr || ''}>
                                  <span className="inline-block h-2 w-2 rounded-full bg-current" />
                                </span>
                              </TooltipTrigger>
                              <TooltipContent>
                                <div className="max-w-xs whitespace-pre-wrap break-words">
                                  <div className="font-medium">Confidence: {cNum.toFixed(2)}</div>
                                  {pStr ? <div className="mt-1 text-muted-foreground">Provenance: {pStr}</div> : null}
                                </div>
                              </TooltipContent>
                            </Tooltip>
                          </TooltipProvider>
                        )}
                      </td> : null}
                    </tr>
                  )
                })}
              </tbody>
            </table>
          </div>
        </div>
        )
      })()}

      {/* Kapitel (hierarchisch, TOC-Ansicht) – nur außerhalb metaOnly-View */}
      {viewMode !== 'metaOnly' && section === 'chapters' && (() => {
        const chapters: Array<Record<string, unknown>> = sourceMode === 'frontmatter'
          ? (Array.isArray(frontmatterMeta?.chapters) ? (frontmatterMeta?.chapters as Array<Record<string, unknown>>) : [])
          : ((job?.cumulativeMeta as unknown as { chapters?: Array<Record<string, unknown>> })?.chapters || [])
        if (!Array.isArray(chapters) || chapters.length === 0) return null

        const pad = (lvl: number | undefined): number => {
          if (typeof lvl !== 'number') return 0
          const clamped = Math.max(0, Math.min(3, lvl))
          return (clamped - 1) * 16 // px
        }

        // Hierarchische Nummerierung 1., 1.1, 1.1.1 basierend auf level
        const counters = [0, 0, 0]
        return (
        <div className="space-y-1">
          <div className="font-medium mb-1">Kapitel</div>
          <div>
            {chapters.map((c, i) => {
              const level = typeof c.level === 'number' ? c.level : 1
              const lvl = Math.max(1, Math.min(3, level))
              // Zähler aktualisieren
              counters[lvl - 1] += 1
              for (let j = lvl; j < counters.length; j++) counters[j] = 0
              const numLabel = counters.slice(0, lvl).filter(n => n > 0).join('.')
              const title = typeof c.title === 'string' ? c.title : ''
              const startPage = typeof c.startPage === 'number' ? c.startPage : ''
              
              const summaryVal = typeof c.summary === 'string' ? c.summary : ''
              const summary = summaryVal.length > 1000 ? `${summaryVal.slice(0, 1000)}…` : summaryVal
              const keywords = Array.isArray(c.keywords) ? (c.keywords as Array<unknown>).filter(v => typeof v === 'string') as string[] : []
              const ev = typeof c.startEvidence === 'string' ? c.startEvidence : ''
              return (
                <details key={`${title}-${i}`} className="group border-b py-1" open={false} onToggle={(e) => {
                  const open = (e.currentTarget as HTMLDetailsElement).open
                  if (open) {
                    if (startPage !== '') onJumpTo?.({ page: startPage as number | string })
                    else if (ev) onJumpTo?.({ evidence: ev })
                  }
                }}>
                  <summary className="list-none cursor-pointer">
                    <div className="flex items-start justify-between gap-3">
                      <div className="flex-1 min-w-0" style={{ paddingLeft: `${pad(lvl)}px` }}>
                        <div className="flex items-baseline gap-2">
                          <span className="text-xs text-muted-foreground tabular-nums">{numLabel}</span>
                          <span className="font-medium truncate">{title}</span>
                        </div>
                      </div>
                      <div className="text-xs tabular-nums text-muted-foreground whitespace-nowrap">
                        {String(startPage)}
                      </div>
                    </div>
                  </summary>
                  <div className="mt-1 pr-1 text-xs space-y-1" style={{ paddingLeft: `${pad(lvl) + 28}px` }}>
                    {summary && (
                      <div className="whitespace-pre-wrap break-words">
                        {summary}
                      </div>
                    )}
                    {Array.isArray(keywords) && keywords.length > 0 && (
                      <div className="flex flex-wrap gap-1">
                        {keywords.map(k => (
                          <span key={k} className="inline-flex items-center rounded px-1.5 py-0.5 bg-muted">{k}</span>
                        ))}
                      </div>
                    )}
                  </div>
                </details>
              )
            })}
          </div>
        </div>
        )
      })()}

      {/* Inhaltsverzeichnis */}
      {section === 'chapters' && (() => {
        const toc: Array<Record<string, unknown>> = sourceMode === 'frontmatter'
          ? (Array.isArray(frontmatterMeta?.toc) ? (frontmatterMeta?.toc as Array<Record<string, unknown>>) : [])
          : ((job?.cumulativeMeta as unknown as { toc?: Array<Record<string, unknown>> }).toc || [])
        if (!Array.isArray(toc) || toc.length === 0) return null
        return (
        <div>
          <div className="font-medium mb-1">Inhaltsverzeichnis</div>
          <div className="overflow-visible">
            <table className="w-full text-xs">
              <thead>
                <tr className="text-left text-muted-foreground">
                  <th className="py-1 pr-2">Titel</th>
                  <th className="py-1 pr-2">Seite</th>
                  <th className="py-1 pr-2">L</th>
                </tr>
              </thead>
              <tbody>
                {toc.map((t, i) => {
                  const title = typeof t.title === 'string' ? t.title : ''
                  const page = typeof t.page === 'number' ? t.page : ''
                  const level = typeof t.level === 'number' ? t.level : ''
                  return (
                    <tr key={`${title}-${i}`} className="border-t border-muted/40">
                      <td className="py-1 pr-2 align-top whitespace-pre-wrap break-words">{title}</td>
                      <td className="py-1 pr-2 align-top">{page}</td>
                      <td className="py-1 pr-2 align-top">{level}</td>
                    </tr>
                  )
                })}
              </tbody>
            </table>
          </div>
        </div>
        )
      })()}

      {viewMode === 'full' && job && job.ingestion && (
        <div>
          <div className="font-medium mb-1">Ingestion</div>
          <div className="text-xs text-muted-foreground">{job.ingestion.index || '—'} · Vektoren: {job.ingestion.vectorsUpserted ?? '—'} · {job.ingestion.upsertAt ? new Date(job.ingestion.upsertAt).toLocaleString() : '—'}</div>
        </div>
      )}

      {viewMode === 'full' && job && Array.isArray(job.logs) && job.logs.length > 0 && (
        <div>
          <div className="font-medium mb-1">Logs (neueste zuerst)</div>
          <ul className="space-y-0.5 max-h-48 overflow-auto">
            {[...job.logs].reverse().slice(0, 30).map((l, i) => (
              <li key={i} className="text-xs">
                {new Date(l.timestamp).toLocaleTimeString()} · {l.phase || '—'} · {typeof l.progress === 'number' ? `${l.progress}% · ` : ''}{l.message || ''}
              </li>
            ))}
          </ul>
        </div>
      )}

      {/* Parameter am Ende */}
      {viewMode === 'full' && job && job.parameters && (
        <div>
          <div className="font-medium mb-1">Parameter</div>
          <pre className="bg-muted/40 rounded p-2 max-h-32 overflow-auto whitespace-pre-wrap break-words">{JSON.stringify(job.parameters, null, 2)}</pre>
        </div>
      )}
    </div>
  )
}



```

Ich habe in der Metadaten-Ansicht Folgendes ergänzt:

- Neuer Tab „Prozessinfo“:
  - Zeigt nur prozessspezifische SSOT-Felder, u. a. `job_id`, `extract_status`, `template_status`, `ingest_status`, `summary_language`, `source_file`, `source_file_id`, `source_file_size`, `source_file_type`, `filename`, `path`, `pathHints`, `isScan`.
  - Gleiche Darstellung wie Metadaten: Feld links sticky, Wert mit Ellipsis, vollständiger Wert im Tooltip.

- Metadaten-Tab:
  - Prozessfelder werden weiterhin angezeigt, aber jetzt immer ans Ende sortiert, damit inhaltliche Metadaten im Vordergrund stehen.

Bitte neu laden und prüfen:
- Ob der Tab „Prozessinfo“ erscheint und sauber nur die Prozessfelder enthält.
- Ob im Tab „Metadaten“ die Prozessfelder unten einsortiert sind.

---

**User**

Ok, jetzt können wir diese Felder aus den Metadaten entfernen, weil sie ja beim Prozess Info schon stehen. Und wie können wir diese Tabs oben schmäler machen, damit alle vier nebeneinander Platz haben. Weniger Padding.

---

**Cursor**

```typescriptreact
"use client";

import { useEffect, useState } from 'react'
import { UILogger } from '@/lib/debug/logger'
import type { StorageProvider } from '@/lib/storage/types'
import { MarkdownPreview } from '@/components/library/markdown-preview'
import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs'
import { TooltipProvider, Tooltip, TooltipTrigger, TooltipContent } from '@/components/ui/tooltip'
import { parseSecretaryMarkdownStrict } from '@/lib/secretary/response-parser'

interface JobReportTabProps {
  libraryId: string
  fileId: string
  fileName?: string
  provider?: StorageProvider | null
  // Quelle der Metadaten steuern: 'merged' = cumulativeMeta + Frontmatter (Standard),
  // 'frontmatter' = ausschließlich Frontmatter aus Markdown anzeigen
  sourceMode?: 'merged' | 'frontmatter'
  // Darstellungsmodus: 'full' zeigt Kopf/Steps/Logs/Parameter; 'metaOnly' zeigt nur Metadaten/Kapitel/TOC
  viewMode?: 'full' | 'metaOnly'
  // Optional explizite Markdown-Datei-ID (Shadow‑Twin). Überschreibt auto-Erkennung.
  mdFileId?: string | null
  // Optionaler Callback zum Scroll-Sync in die Markdown-Vorschau
  onJumpTo?: (args: { page?: number | string; evidence?: string }) => void
  // NEU: Rohinhalt (Markdown). Wenn gesetzt und sourceMode='frontmatter', wird direkt dieser Text geparst (ohne Datei/JOB).
  rawContent?: string
}

interface JobDto {
  jobId: string
  status: string
  operation: string
  worker: string
  job_type: string
  updatedAt: string
  createdAt: string
  correlation?: { source?: { itemId?: string; name?: string } }
  parameters?: Record<string, unknown>
  steps?: Array<{ name: string; status: string; startedAt?: string; endedAt?: string; error?: { message: string }; details?: { skipped?: boolean } }>
  ingestion?: { vectorsUpserted?: number; index?: string; upsertAt?: string }
  result?: { savedItemId?: string }
  logs?: Array<{ timestamp: string; phase?: string; message?: string; progress?: number }>
  cumulativeMeta?: Record<string, unknown>
}

export function JobReportTab({ libraryId, fileId, fileName, provider, sourceMode = 'merged', viewMode = 'full', mdFileId, onJumpTo, rawContent }: JobReportTabProps) {
  const [loading, setLoading] = useState(false)
  const [error, setError] = useState<string | null>(null)
  const [job, setJob] = useState<JobDto | null>(null)
  const [templateFields, setTemplateFields] = useState<string[] | null>(null)
  const [frontmatterMeta, setFrontmatterMeta] = useState<Record<string, unknown> | null>(null)
  const [section, setSection] = useState<'meta' | 'chapters'>('meta')
  const [parseErrors, setParseErrors] = useState<string[]>([])
  const [fullContent, setFullContent] = useState<string>('')

  const stripFrontmatter = (markdown: string): string => markdown.replace(/^---\r?\n([\s\S]*?)\r?\n---\r?\n?/, '')

  useEffect(() => {
    let cancelled = false
    async function run() {
      try {
        // Wenn wir Rohinhalt haben und nur Frontmatter zeigen, brauchen wir keine Job-Suche
        if (sourceMode === 'frontmatter' && typeof rawContent === 'string' && rawContent.length > 0) {
          setJob(null)
          setLoading(false)
          setError(null)
          return
        }
        setLoading(true)
        setError(null)
        UILogger.info('JobReportTab', 'Start Job-Suche', { libraryId, fileId })
        // 1) Versuche Job über result.savedItemId (Shadow‑Twin) zu finden
        const byResultUrl = new URL(`/api/external/jobs`, window.location.origin)
        byResultUrl.searchParams.set('byResultItemId', fileId)
        UILogger.debug('JobReportTab', 'Request byResultItemId', { url: byResultUrl.toString() })
        let res = await fetch(byResultUrl.toString(), { cache: 'no-store' })
        let data = await res.json()
        if (!res.ok) throw new Error(typeof data?.error === 'string' ? data.error : 'Job-Suche fehlgeschlagen')
        let j: JobDto | null = Array.isArray(data?.items) && data.items.length > 0 ? (data.items[0] as JobDto) : null
        UILogger.debug('JobReportTab', 'Result byResultItemId', { count: Array.isArray(data?.items) ? data.items.length : 0 })

        // 2) Fallback: über correlation.source.itemId (Originaldatei)
        if (!j) {
          const bySourceUrl = new URL(`/api/external/jobs`, window.location.origin)
          bySourceUrl.searchParams.set('bySourceItemId', fileId)
          bySourceUrl.searchParams.set('libraryId', libraryId)
          UILogger.debug('JobReportTab', 'Request bySourceItemId', { url: bySourceUrl.toString() })
          res = await fetch(bySourceUrl.toString(), { cache: 'no-store' })
          data = await res.json()
          if (!res.ok) throw new Error(typeof data?.error === 'string' ? data.error : 'Job-Suche (Quelle) fehlgeschlagen')
          j = Array.isArray(data?.items) && data.items.length > 0 ? (data.items[0] as JobDto) : null
          UILogger.debug('JobReportTab', 'Result bySourceItemId', { count: Array.isArray(data?.items) ? data.items.length : 0 })
        }

        // 3) Fallback: über correlation.source.name (Dateiname der Quelle)
        if (!j) {
          const byNameUrl = new URL(`/api/external/jobs`, window.location.origin)
          // Wenn wir den tatsächlichen Dateinamen kennen, verwende ihn.
          // Für Shadow‑Twins (z. B. name.de.md) versuche das Basis‑PDF (name.pdf).
          let candidate = (fileName && typeof fileName === 'string') ? fileName : (fileId.includes('/') ? (fileId.split('/').pop() as string) : fileId)
          const parts = candidate.split('.')
          if (parts.length >= 3) {
            const ext1 = parts[parts.length - 1].toLowerCase()
            const ext2 = parts[parts.length - 2].toLowerCase()
            if ((ext1 === 'md' || ext1 === 'mdx') && /^[a-z]{2}$/i.test(ext2)) {
              candidate = parts.slice(0, -2).join('.') + '.pdf'
            }
          }
          byNameUrl.searchParams.set('bySourceName', candidate)
          byNameUrl.searchParams.set('libraryId', libraryId)
          UILogger.debug('JobReportTab', 'Request bySourceName', { url: byNameUrl.toString(), nameOnly: candidate, originalFileName: fileName })
          res = await fetch(byNameUrl.toString(), { cache: 'no-store' })
          data = await res.json()
          if (!res.ok) throw new Error(typeof data?.error === 'string' ? data.error : 'Job-Suche (Name) fehlgeschlagen')
          j = Array.isArray(data?.items) && data.items.length > 0 ? (data.items[0] as JobDto) : null
          UILogger.debug('JobReportTab', 'Result bySourceName', { count: Array.isArray(data?.items) ? data.items.length : 0 })
        }

        if (!cancelled) setJob(j)
        if (j) UILogger.info('JobReportTab', 'Job gefunden', { jobId: j.jobId, status: j.status })
        else UILogger.warn('JobReportTab', 'Kein Job gefunden', { libraryId, fileId })
      } catch (e) {
        const msg = e instanceof Error ? e.message : 'Unbekannter Fehler'
        UILogger.error('JobReportTab', 'Job-Suche fehlgeschlagen', e)
        if (!cancelled) setError(msg)
      } finally {
        if (!cancelled) setLoading(false)
      }
    }
    void run()
    return () => { cancelled = true }
  }, [libraryId, fileId, fileName, sourceMode, rawContent])

  // Wenn Template benutzt wurde, lade dessen Inhalt aus /templates und extrahiere Frontmatter-Schlüssel
  useEffect(() => {
    async function loadTemplateFields() {
      try {
        setTemplateFields(null)
        const tpl = job?.cumulativeMeta && typeof (job.cumulativeMeta as unknown) === 'object'
          ? (job.cumulativeMeta as Record<string, unknown>)['template_used']
          : undefined
        const templateName = typeof tpl === 'string' ? tpl : undefined
        if (!templateName || !provider) return
        const rootItems = await provider.listItemsById('root')
        const templatesFolder = rootItems.find(it => it.type === 'folder' && typeof (it as { metadata?: { name?: string } }).metadata?.name === 'string' && ((it as { metadata: { name: string } }).metadata.name.toLowerCase() === 'templates'))
        if (!templatesFolder) return
        const tplItems = await provider.listItemsById(templatesFolder.id)
        const match = tplItems.find(it => it.type === 'file' && ((it as { metadata: { name: string } }).metadata.name.toLowerCase() === templateName.toLowerCase()))
        if (!match) return
        const bin = await provider.getBinary(match.id)
        const text = await bin.blob.text()
        // Extrahiere Frontmatter zwischen den ersten beiden --- und lese die Keys bis zu :
        const m = text.match(/^---[\s\S]*?---/)
        if (!m) return
        const fm = m[0]
        const keys: string[] = []
        for (const line of fm.split('\n')) {
          const t = line.trim()
          if (!t || t === '---') continue
          const idx = t.indexOf(':')
          if (idx > 0) {
            const k = t.slice(0, idx).trim()
            if (k) keys.push(k)
          }
        }
        setTemplateFields(Array.from(new Set(keys)))
      } catch (e) {
        UILogger.warn('JobReportTab', 'Template-Felder konnten nicht geladen werden', { error: e instanceof Error ? e.message : String(e) })
      }
    }
    void loadTemplateFields()
  }, [job, provider])

  // Gemeinsamer strikter Parser
  const strictParseFrontmatter = (fm: string) => parseSecretaryMarkdownStrict(fm)

  // Frontmatter aus der gespeicherten Markdown-Datei lesen (oder aus rawContent)
  useEffect(() => {
    async function loadFrontmatter() {
      try {
        setParseErrors([])
        // Wenn roher Inhalt übergeben wurde, direkt daraus lesen
        if (sourceMode === 'frontmatter' && typeof rawContent === 'string' && rawContent.length > 0) {
          const text = rawContent
          setFullContent(text)
          const { frontmatter, meta, errors } = parseSecretaryMarkdownStrict(text)
          UILogger.debug('JobReportTab', 'Frontmatter (raw): Block gefunden?', { found: !!frontmatter, length: frontmatter ? frontmatter.length : 0 })
          if (!frontmatter) { setFrontmatterMeta(null); return }
          setFrontmatterMeta(Object.keys(meta).length ? meta : null)
          setParseErrors(errors)
          return
        }

        if (!provider) return
        const mdId = (mdFileId || (job?.result?.savedItemId as string | undefined) || fileId)
        UILogger.info('JobReportTab', 'Frontmatter: Lade Datei', { mdId, sourceMode })
        if (!mdId) return
        const bin = await provider.getBinary(mdId)
        const text = await bin.blob.text()
        setFullContent(text)
        const { frontmatter, meta, errors } = parseSecretaryMarkdownStrict(text)
        UILogger.debug('JobReportTab', 'Frontmatter: Block gefunden?', { found: !!frontmatter, length: frontmatter ? frontmatter.length : 0 })
        if (!frontmatter) { setFrontmatterMeta(null); return }
        setFrontmatterMeta(Object.keys(meta).length ? meta : null)
        setParseErrors(errors)
      } catch {
        setFrontmatterMeta(null)
      }
    }
    void loadFrontmatter()
  }, [provider, fileId, mdFileId, job?.result?.savedItemId, sourceMode, rawContent])

  if (sourceMode !== 'frontmatter') {
    if (loading) return <div className="p-4 text-sm text-muted-foreground">Lade Job…</div>
    if (error) return <div className="p-4 text-sm text-destructive">{error}</div>
    if (!job) return <div className="p-4 text-sm text-muted-foreground">Kein Job zur Datei gefunden.</div>
  }

  return (
    <div className="p-4 space-y-3 text-sm">
      {viewMode === 'metaOnly' && (
        <Tabs defaultValue="markdown">
          <TabsList className="grid grid-cols-4 w-full gap-1">
            <TabsTrigger value="markdown" className="px-2 py-1 text-xs">Markdown</TabsTrigger>
            <TabsTrigger value="meta" className="px-2 py-1 text-xs">Metadaten</TabsTrigger>
            <TabsTrigger value="chapters" className="px-2 py-1 text-xs">Kapitel</TabsTrigger>
            {(() => {
              const base: Record<string, unknown> = sourceMode === 'frontmatter' ? {} : ((job?.cumulativeMeta as unknown as Record<string, unknown>) || {})
              const cm = frontmatterMeta ? { ...base, ...frontmatterMeta } : base
              const processFields = new Set([
                'job_id','extract_status','template_status','ingest_status','summary_language',
                'source_file','source_file_id','source_file_size','source_file_type',
                'filename','path','pathHints','isScan'
              ])
              const hasProcess = Object.keys(cm).some(k => processFields.has(k))
              return hasProcess ? <TabsTrigger value="process" className="px-2 py-1 text-xs">Prozessinfo</TabsTrigger> : null
            })()}
          </TabsList>

          <TabsContent value="markdown" className="mt-3">
            <div className="border rounded-md">
              <MarkdownPreview content={stripFrontmatter(fullContent || '')} />
            </div>
          </TabsContent>

          <TabsContent value="meta" className="mt-3">
            {/* Hinweise zu Parserfehlern (strikt) */}
            {parseErrors.length > 0 && (
              <div className="text-xs text-destructive mb-2">
                {parseErrors.map((e, i) => (<div key={i}>Parserfehler: {e}</div>))}
              </div>
            )}
            {(() => {
              const base: Record<string, unknown> = sourceMode === 'frontmatter'
                ? {}
                : ((job?.cumulativeMeta as unknown as Record<string, unknown>) || {})
              const cm = frontmatterMeta ? { ...base, ...frontmatterMeta } : base
              // confidence/provenance können Objekt oder JSON-String sein → Fallback parse
              const confidence: Record<string, unknown> = (() => {
                const raw = cm['confidence']
                if (raw && typeof raw === 'object') return raw as Record<string, unknown>
                if (typeof raw === 'string') { try { return JSON.parse(raw) as Record<string, unknown> } catch { /* ignore */ } }
                return {}
              })()
              const provenance: Record<string, unknown> = (() => {
                const raw = cm['provenance']
                if (raw && typeof raw === 'object') return raw as Record<string, unknown>
                if (typeof raw === 'string') { try { return JSON.parse(raw) as Record<string, unknown> } catch { /* ignore */ } }
                return {}
              })()
              const hasAnyConfidence = Object.keys(confidence).length > 0
              const baseKeys = Array.isArray(templateFields) && templateFields.length > 0
                ? Array.from(new Set([...(templateFields as string[]), ...Object.keys(cm)]))
                : Object.keys(cm)
              const flatKeysAll = baseKeys.filter(k => k !== 'chapters' && k !== 'toc' && k !== 'confidence' && k !== 'provenance')
              const processFields = new Set([
                'job_id','extract_status','template_status','ingest_status','summary_language',
                'source_file','source_file_id','source_file_size','source_file_type',
                'filename','path','pathHints','isScan'
              ])
              const primaryKeys = flatKeysAll.filter(k => !processFields.has(k))
              const flatKeys = primaryKeys
              if (flatKeys.length === 0) return null
              return (
                <div>
                  <div className="font-medium mb-1">Metadaten (Template vs. Ergebnis)</div>
                  <div className="overflow-auto">
                    <table className="w-full text-xs">
                      <thead>
                        <tr className="text-left text-muted-foreground">
                          <th className="py-1 pr-2 sticky left-0 bg-background z-10">Feld</th>
                          <th className="py-1 pr-2">Wert</th>
                          {hasAnyConfidence ? <th className="py-1 pr-2 text-right sticky right-0 bg-background border-l">Q</th> : null}
                        </tr>
                      </thead>
                      <tbody>
                        {flatKeys.map((k) => {
                          const val = cm[k]
                          let valueStr = ''
                          if (Array.isArray(val)) valueStr = (val as Array<unknown>).map(v => typeof v === 'string' ? v : JSON.stringify(v)).join(', ')
                          else valueStr = val === null || val === undefined ? '' : typeof val === 'string' ? val : JSON.stringify(val)
                          const hasNonEmptyValue = (() => {
                            if (val === null || val === undefined) return false
                            if (typeof val === 'string') return val.trim().length > 0
                            if (Array.isArray(val)) return (val as Array<unknown>).length > 0
                            if (typeof val === 'object') return Object.keys(val as Record<string, unknown>).length > 0
                            return true
                          })()
                          const cRaw = (confidence as Record<string, unknown>)[k]
                          const cNum = typeof cRaw === 'number' ? cRaw : (typeof cRaw === 'string' && /^\d+(\.\d+)?$/.test(cRaw) ? Number(cRaw) : undefined)
                          const pRaw = (provenance as Record<string, unknown>)[k]
                          const pStr = typeof pRaw === 'string' ? pRaw : pRaw ? JSON.stringify(pRaw) : ''
                          const color = cNum === undefined ? 'text-muted-foreground' : (cNum >= 0.8 ? 'text-green-600' : cNum >= 0.7 ? 'text-yellow-600' : 'text-red-600')
                          return (
                            <tr key={k} className="border-t border-muted/40">
                              <td className="py-1 pr-2 align-top font-medium sticky left-0 bg-background z-10 whitespace-nowrap">{k}</td>
                              <td className="py-1 pr-2 align-top">
                                {valueStr ? (
                                  <TooltipProvider>
                                    <Tooltip>
                                      <TooltipTrigger asChild>
                                        <span className="inline-block max-w-[40vw] overflow-hidden text-ellipsis whitespace-nowrap align-top" title="">
                                          {valueStr}
                                        </span>
                                      </TooltipTrigger>
                                      <TooltipContent>
                                        <div className="max-w-[80vw] whitespace-pre-wrap break-words">{valueStr}</div>
                                      </TooltipContent>
                                    </Tooltip>
                                  </TooltipProvider>
                                ) : ''}
                              </td>
                              {hasAnyConfidence ? <td className="py-1 pr-2 align-top sticky right-0 bg-background border-l">
                                {(!hasNonEmptyValue || cNum === undefined) ? null : (
                                  <TooltipProvider>
                                    <Tooltip>
                                      <TooltipTrigger asChild>
                                        <span className={`inline-flex items-center justify-end w-full ${color}`} title={pStr || ''}>
                                          <span className="inline-block h-2 w-2 rounded-full bg-current" />
                                        </span>
                                      </TooltipTrigger>
                                      <TooltipContent>
                                        <div className="max-w-xs whitespace-pre-wrap break-words">
                                          <div className="font-medium">Confidence: {cNum.toFixed(2)}</div>
                                          {pStr ? <div className="mt-1 text-muted-foreground">Provenance: {pStr}</div> : null}
                                        </div>
                                      </TooltipContent>
                                    </Tooltip>
                                  </TooltipProvider>
                                )}
                              </td> : null}
                            </tr>
                          )
                        })}
                      </tbody>
                    </table>
                  </div>
                </div>
              )
            })()}
          </TabsContent>

          <TabsContent value="process" className="mt-3">
            {(() => {
              const base: Record<string, unknown> = sourceMode === 'frontmatter'
                ? {}
                : ((job?.cumulativeMeta as unknown as Record<string, unknown>) || {})
              const cm = frontmatterMeta ? { ...base, ...frontmatterMeta } : base
              const processOrder = [
                'job_id','extract_status','template_status','ingest_status','summary_language',
                'source_file','source_file_id','source_file_size','source_file_type',
                'filename','path','pathHints','isScan'
              ]
              const keys = processOrder.filter(k => k in cm)
              if (keys.length === 0) return <div className="text-xs text-muted-foreground">Keine Prozessinformationen vorhanden.</div>
              return (
                <div className="overflow-auto">
                  <table className="w-full text-xs">
                    <thead>
                      <tr className="text-left text-muted-foreground">
                        <th className="py-1 pr-2 sticky left-0 bg-background z-10">Feld</th>
                        <th className="py-1 pr-2">Wert</th>
                      </tr>
                    </thead>
                    <tbody>
                      {keys.map(k => {
                        const val = cm[k]
                        const valueStr = val === null || val === undefined ? '' : Array.isArray(val) ? (val as Array<unknown>).map(v => typeof v === 'string' ? v : JSON.stringify(v)).join(', ') : typeof val === 'string' ? val : JSON.stringify(val)
                        return (
                          <tr key={k} className="border-t border-muted/40">
                            <td className="py-1 pr-2 align-top font-medium sticky left-0 bg-background z-10 whitespace-nowrap">{k}</td>
                            <td className="py-1 pr-2 align-top">
                              {valueStr ? (
                                <TooltipProvider>
                                  <Tooltip>
                                    <TooltipTrigger asChild>
                                      <span className="inline-block max-w-[40vw] overflow-hidden text-ellipsis whitespace-nowrap align-top" title="">{valueStr}</span>
                                    </TooltipTrigger>
                                    <TooltipContent>
                                      <div className="max-w-[80vw] whitespace-pre-wrap break-words">{valueStr}</div>
                                    </TooltipContent>
                                  </Tooltip>
                                </TooltipProvider>
                              ) : ''}
                            </td>
                          </tr>
                        )
                      })}
                    </tbody>
                  </table>
                </div>
              )
            })()}
          </TabsContent>

          <TabsContent value="chapters" className="mt-3">
            {(() => {
              const chapters: Array<Record<string, unknown>> = sourceMode === 'frontmatter'
                ? (Array.isArray(frontmatterMeta?.chapters) ? (frontmatterMeta?.chapters as Array<Record<string, unknown>>) : [])
                : ((job?.cumulativeMeta as unknown as { chapters?: Array<Record<string, unknown>> })?.chapters || [])
              if (!Array.isArray(chapters) || chapters.length === 0) return null
              const pad = (lvl: number | undefined): number => {
                if (typeof lvl !== 'number') return 0
                const clamped = Math.max(0, Math.min(3, lvl))
                return (clamped - 1) * 16
              }
              const counters = [0, 0, 0]
              return (
                <div className="space-y-1">
                  <div>
                    {chapters.map((c, i) => {
                      const level = typeof c.level === 'number' ? c.level : 1
                      const lvl = Math.max(1, Math.min(3, level))
                      counters[lvl - 1] += 1
                      for (let j = lvl; j < counters.length; j++) counters[j] = 0
                      const numLabel = counters.slice(0, lvl).filter(n => n > 0).join('.')
                      const title = typeof c.title === 'string' ? c.title : ''
                      const startPage = typeof c.startPage === 'number' ? c.startPage : ''
                      const summaryVal = typeof c.summary === 'string' ? c.summary : ''
                      const summary = summaryVal.length > 1000 ? `${summaryVal.slice(0, 1000)}…` : summaryVal
                      const keywords = Array.isArray(c.keywords) ? (c.keywords as Array<unknown>).filter(v => typeof v === 'string') as string[] : []
                      const ev = typeof c.startEvidence === 'string' ? c.startEvidence : ''
                      return (
                        <details key={`${title}-${i}`} className="group border-b py-1" open={false}>
                          <summary className="list-none cursor-pointer">
                            <div className="flex items-start justify-between gap-3">
                              <div className="flex-1 min-w-0" style={{ paddingLeft: `${pad(lvl)}px` }}>
                                <div className="flex items-baseline gap-2">
                                  <span className="text-xs text-muted-foreground tabular-nums">{numLabel}</span>
                                  <span className="font-medium truncate">{title}</span>
                                </div>
                              </div>
                              <div className="text-xs tabular-nums text-muted-foreground whitespace-nowrap">
                                {String(startPage)}
                              </div>
                            </div>
                          </summary>
                          <div className="mt-1 pr-1 text-xs space-y-1" style={{ paddingLeft: `${pad(lvl) + 28}px` }}>
                            {summary && (
                              <div className="whitespace-pre-wrap break-words">
                                {summary}
                              </div>
                            )}
                            {Array.isArray(keywords) && keywords.length > 0 && (
                              <div className="flex flex-wrap gap-1">
                                {keywords.map(k => (
                                  <span key={k} className="inline-flex items-center rounded px-1.5 py-0.5 bg-muted">{k}</span>
                                ))}
                              </div>
                            )}
                          </div>
                        </details>
                      )
                    })}
                  </div>
                </div>
              )
            })()}
          </TabsContent>
        </Tabs>
      )}

      {viewMode === 'full' && job && (
        <div className="flex items-center justify-between">
          <div>
            <div className="font-medium">Job {job.jobId}</div>
            <div className="text-xs text-muted-foreground">{job.job_type} · {job.operation} · {new Date(job.updatedAt).toLocaleString()}</div>
          </div>
          <div className="inline-flex items-center rounded px-2 py-0.5 bg-muted text-xs">{job.status}</div>
        </div>
      )}

      {/* Hinweise zu Parserfehlern (strikt) */}
      {viewMode !== 'metaOnly' && parseErrors.length > 0 && (
        <div className="text-xs text-destructive">
          {parseErrors.map((e, i) => (<div key={i}>Parserfehler: {e}</div>))}
        </div>
      )}

      {/* Template Hinweis (im Frontmatter-only-Modus ausgeblendet) */}
      {sourceMode !== 'frontmatter' && job && typeof job.cumulativeMeta?.template_used === 'string' && (
        <div className="text-xs text-muted-foreground">Template: {String(job.cumulativeMeta.template_used)}</div>
      )}

      {/* Schritte mit Ampel-Logik */}
      {viewMode === 'full' && job && Array.isArray(job.steps) && job.steps.length > 0 && (
        <div>
          <div className="font-medium mb-1">Schritte</div>
          <div className="flex flex-wrap gap-2 text-xs">
            {job.steps.map((s) => {
              // Geplante Phasen ermitteln (neue Flags bevorzugt, sonst phases)
              const p = (job.parameters || {}) as Record<string, unknown>
              const hasNewFlags = typeof p['doExtractPDF'] === 'boolean' || typeof p['doExtractMetadata'] === 'boolean' || typeof p['doIngestRAG'] === 'boolean'
              const phases = hasNewFlags
                ? {
                    extract: p['doExtractPDF'] === true,
                    template: p['doExtractMetadata'] === true,
                    ingest: p['doIngestRAG'] === true,
                  }
                : ((p['phases'] as { extract?: boolean; template?: boolean; ingest?: boolean }) || {})

              const planned = (() => {
                const n = s.name
                if (n === 'extract_pdf') return phases.extract === true
                if (n === 'transform_template' || n === 'store_shadow_twin') return phases.template === true
                if (n === 'ingest_rag') return phases.ingest === true
                return false
              })()

              // Ampel-Status ableiten
              const skipped = !!(s as { details?: { skipped?: boolean } }).details?.skipped
              let icon = '○'
              let cls = 'text-muted-foreground'
              if (s.status === 'failed') { icon = '✕'; cls = 'text-red-600' }
              else if (s.status === 'running') { icon = '◐'; cls = 'text-yellow-600' }
              else if (s.status === 'completed') { icon = skipped ? '○' : '✓'; cls = skipped ? 'text-gray-400' : 'text-green-600' }
              else if (s.status === 'pending') { icon = planned ? '•' : '○'; cls = planned ? 'text-yellow-600' : 'text-muted-foreground' }

              const time = s.endedAt ? new Date(s.endedAt).toLocaleTimeString() : s.startedAt ? new Date(s.startedAt).toLocaleTimeString() : ''
              return (
                <div key={s.name} className={`inline-flex items-center gap-1 px-2 py-1 rounded border ${cls}`}>
                  <span>{icon}</span>
                  <span className="font-medium">{s.name}</span>
                  {time ? <span className="opacity-70">{time}</span> : null}
                </div>
              )
            })}
          </div>
        </div>
      )}

      {/* Metadaten (flach) – je nach sourceMode: nur Frontmatter oder Merge (nur außerhalb metaOnly-View) */}
      {viewMode !== 'metaOnly' && section === 'meta' && (() => {
        const base: Record<string, unknown> = sourceMode === 'frontmatter'
          ? {}
          : ((job?.cumulativeMeta as unknown as Record<string, unknown>) || {})
        const cm = frontmatterMeta ? { ...base, ...frontmatterMeta } : base
        const confidence: Record<string, unknown> = (() => {
          const raw = cm['confidence']
          if (raw && typeof raw === 'object') return raw as Record<string, unknown>
          if (typeof raw === 'string') { try { return JSON.parse(raw) as Record<string, unknown> } catch { /* ignore */ } }
          return {}
        })()
        const provenance: Record<string, unknown> = (() => {
          const raw = cm['provenance']
          if (raw && typeof raw === 'object') return raw as Record<string, unknown>
          if (typeof raw === 'string') { try { return JSON.parse(raw) as Record<string, unknown> } catch { /* ignore */ } }
          return {}
        })()
        const hasAnyConfidence = Object.keys(confidence).length > 0
        const baseKeys = Array.isArray(templateFields) && templateFields.length > 0
          ? Array.from(new Set([...(templateFields as string[]), ...Object.keys(cm)]))
          : Object.keys(cm)
        const flatKeys = baseKeys.filter(k => k !== 'chapters' && k !== 'toc' && k !== 'confidence' && k !== 'provenance')
        if (flatKeys.length === 0) return null
        return (
        <div>
          <div className="font-medium mb-1">Metadaten (Template vs. Ergebnis)</div>
          <div className="overflow-auto">
            <table className="w-full text-xs">
              <thead>
                <tr className="text-left text-muted-foreground">
                  <th className="py-1 pr-2 sticky left-0 bg-background z-10">Feld</th>
                  <th className="py-1 pr-2">Wert</th>
                  {hasAnyConfidence ? <th className="py-1 pr-2 text-right sticky right-0 bg-background border-l">Q</th> : null}
                </tr>
              </thead>
              <tbody>
                {flatKeys.map((k) => {
                  const val = cm[k]
                  let valueStr = ''
                  if (Array.isArray(val)) valueStr = (val as Array<unknown>).map(v => typeof v === 'string' ? v : JSON.stringify(v)).join(', ')
                  else valueStr = val === null || val === undefined ? '' : typeof val === 'string' ? val : JSON.stringify(val)
                  const hasNonEmptyValue = (() => {
                    if (val === null || val === undefined) return false
                    if (typeof val === 'string') return val.trim().length > 0
                    if (Array.isArray(val)) return (val as Array<unknown>).length > 0
                    if (typeof val === 'object') return Object.keys(val as Record<string, unknown>).length > 0
                    return true
                  })()
                  const cRaw = (confidence as Record<string, unknown>)[k]
                  const cNum = typeof cRaw === 'number' ? cRaw : (typeof cRaw === 'string' && /^\d+(\.\d+)?$/.test(cRaw) ? Number(cRaw) : undefined)
                  const pRaw = (provenance as Record<string, unknown>)[k]
                  const pStr = typeof pRaw === 'string' ? pRaw : pRaw ? JSON.stringify(pRaw) : ''
                  const color = cNum === undefined ? 'text-muted-foreground' : (cNum >= 0.8 ? 'text-green-600' : cNum >= 0.7 ? 'text-yellow-600' : 'text-red-600')
                  return (
                    <tr key={k} className="border-t border-muted/40">
                      <td className="py-1 pr-2 align-top font-medium sticky left-0 bg-background z-10 whitespace-nowrap">{k}</td>
                      <td className="py-1 pr-2 align-top">
                        {valueStr ? (
                          <TooltipProvider>
                            <Tooltip>
                              <TooltipTrigger asChild>
                                <span className="inline-block max-w-[40vw] overflow-hidden text-ellipsis whitespace-nowrap align-top" title="">
                                  {valueStr}
                                </span>
                              </TooltipTrigger>
                              <TooltipContent>
                                <div className="max-w-[80vw] whitespace-pre-wrap break-words">{valueStr}</div>
                              </TooltipContent>
                            </Tooltip>
                          </TooltipProvider>
                        ) : ''}
                      </td>
                      {hasAnyConfidence ? <td className="py-1 pr-2 align-top sticky right-0 bg-background border-l">
                        {(!hasNonEmptyValue || cNum === undefined) ? null : (
                          <TooltipProvider>
                            <Tooltip>
                              <TooltipTrigger asChild>
                                <span className={`inline-flex items-center justify-end w-full ${color}`} title={pStr || ''}>
                                  <span className="inline-block h-2 w-2 rounded-full bg-current" />
                                </span>
                              </TooltipTrigger>
                              <TooltipContent>
                                <div className="max-w-xs whitespace-pre-wrap break-words">
                                  <div className="font-medium">Confidence: {cNum.toFixed(2)}</div>
                                  {pStr ? <div className="mt-1 text-muted-foreground">Provenance: {pStr}</div> : null}
                                </div>
                              </TooltipContent>
                            </Tooltip>
                          </TooltipProvider>
                        )}
                      </td> : null}
                    </tr>
                  )
                })}
              </tbody>
            </table>
          </div>
        </div>
        )
      })()}

      {/* Kapitel (hierarchisch, TOC-Ansicht) – nur außerhalb metaOnly-View */}
      {viewMode !== 'metaOnly' && section === 'chapters' && (() => {
        const chapters: Array<Record<string, unknown>> = sourceMode === 'frontmatter'
          ? (Array.isArray(frontmatterMeta?.chapters) ? (frontmatterMeta?.chapters as Array<Record<string, unknown>>) : [])
          : ((job?.cumulativeMeta as unknown as { chapters?: Array<Record<string, unknown>> })?.chapters || [])
        if (!Array.isArray(chapters) || chapters.length === 0) return null

        const pad = (lvl: number | undefined): number => {
          if (typeof lvl !== 'number') return 0
          const clamped = Math.max(0, Math.min(3, lvl))
          return (clamped - 1) * 16 // px
        }

        // Hierarchische Nummerierung 1., 1.1, 1.1.1 basierend auf level
        const counters = [0, 0, 0]
        return (
        <div className="space-y-1">
          <div className="font-medium mb-1">Kapitel</div>
          <div>
            {chapters.map((c, i) => {
              const level = typeof c.level === 'number' ? c.level : 1
              const lvl = Math.max(1, Math.min(3, level))
              // Zähler aktualisieren
              counters[lvl - 1] += 1
              for (let j = lvl; j < counters.length; j++) counters[j] = 0
              const numLabel = counters.slice(0, lvl).filter(n => n > 0).join('.')
              const title = typeof c.title === 'string' ? c.title : ''
              const startPage = typeof c.startPage === 'number' ? c.startPage : ''
              
              const summaryVal = typeof c.summary === 'string' ? c.summary : ''
              const summary = summaryVal.length > 1000 ? `${summaryVal.slice(0, 1000)}…` : summaryVal
              const keywords = Array.isArray(c.keywords) ? (c.keywords as Array<unknown>).filter(v => typeof v === 'string') as string[] : []
              const ev = typeof c.startEvidence === 'string' ? c.startEvidence : ''
              return (
                <details key={`${title}-${i}`} className="group border-b py-1" open={false} onToggle={(e) => {
                  const open = (e.currentTarget as HTMLDetailsElement).open
                  if (open) {
                    if (startPage !== '') onJumpTo?.({ page: startPage as number | string })
                    else if (ev) onJumpTo?.({ evidence: ev })
                  }
                }}>
                  <summary className="list-none cursor-pointer">
                    <div className="flex items-start justify-between gap-3">
                      <div className="flex-1 min-w-0" style={{ paddingLeft: `${pad(lvl)}px` }}>
                        <div className="flex items-baseline gap-2">
                          <span className="text-xs text-muted-foreground tabular-nums">{numLabel}</span>
                          <span className="font-medium truncate">{title}</span>
                        </div>
                      </div>
                      <div className="text-xs tabular-nums text-muted-foreground whitespace-nowrap">
                        {String(startPage)}
                      </div>
                    </div>
                  </summary>
                  <div className="mt-1 pr-1 text-xs space-y-1" style={{ paddingLeft: `${pad(lvl) + 28}px` }}>
                    {summary && (
                      <div className="whitespace-pre-wrap break-words">
                        {summary}
                      </div>
                    )}
                    {Array.isArray(keywords) && keywords.length > 0 && (
                      <div className="flex flex-wrap gap-1">
                        {keywords.map(k => (
                          <span key={k} className="inline-flex items-center rounded px-1.5 py-0.5 bg-muted">{k}</span>
                        ))}
                      </div>
                    )}
                  </div>
                </details>
              )
            })}
          </div>
        </div>
        )
      })()}

      {/* Inhaltsverzeichnis */}
      {section === 'chapters' && (() => {
        const toc: Array<Record<string, unknown>> = sourceMode === 'frontmatter'
          ? (Array.isArray(frontmatterMeta?.toc) ? (frontmatterMeta?.toc as Array<Record<string, unknown>>) : [])
          : ((job?.cumulativeMeta as unknown as { toc?: Array<Record<string, unknown>> }).toc || [])
        if (!Array.isArray(toc) || toc.length === 0) return null
        return (
        <div>
          <div className="font-medium mb-1">Inhaltsverzeichnis</div>
          <div className="overflow-visible">
            <table className="w-full text-xs">
              <thead>
                <tr className="text-left text-muted-foreground">
                  <th className="py-1 pr-2">Titel</th>
                  <th className="py-1 pr-2">Seite</th>
                  <th className="py-1 pr-2">L</th>
                </tr>
              </thead>
              <tbody>
                {toc.map((t, i) => {
                  const title = typeof t.title === 'string' ? t.title : ''
                  const page = typeof t.page === 'number' ? t.page : ''
                  const level = typeof t.level === 'number' ? t.level : ''
                  return (
                    <tr key={`${title}-${i}`} className="border-t border-muted/40">
                      <td className="py-1 pr-2 align-top whitespace-pre-wrap break-words">{title}</td>
                      <td className="py-1 pr-2 align-top">{page}</td>
                      <td className="py-1 pr-2 align-top">{level}</td>
                    </tr>
                  )
                })}
              </tbody>
            </table>
          </div>
        </div>
        )
      })()}

      {viewMode === 'full' && job && job.ingestion && (
        <div>
          <div className="font-medium mb-1">Ingestion</div>
          <div className="text-xs text-muted-foreground">{job.ingestion.index || '—'} · Vektoren: {job.ingestion.vectorsUpserted ?? '—'} · {job.ingestion.upsertAt ? new Date(job.ingestion.upsertAt).toLocaleString() : '—'}</div>
        </div>
      )}

      {viewMode === 'full' && job && Array.isArray(job.logs) && job.logs.length > 0 && (
        <div>
          <div className="font-medium mb-1">Logs (neueste zuerst)</div>
          <ul className="space-y-0.5 max-h-48 overflow-auto">
            {[...job.logs].reverse().slice(0, 30).map((l, i) => (
              <li key={i} className="text-xs">
                {new Date(l.timestamp).toLocaleTimeString()} · {l.phase || '—'} · {typeof l.progress === 'number' ? `${l.progress}% · ` : ''}{l.message || ''}
              </li>
            ))}
          </ul>
        </div>
      )}

      {/* Parameter am Ende */}
      {viewMode === 'full' && job && job.parameters && (
        <div>
          <div className="font-medium mb-1">Parameter</div>
          <pre className="bg-muted/40 rounded p-2 max-h-32 overflow-auto whitespace-pre-wrap break-words">{JSON.stringify(job.parameters, null, 2)}</pre>
        </div>
      )}
    </div>
  )
}



```

- Metadaten-Tab: Prozessfelder entfernt. Sie erscheinen nur noch im Tab „Prozessinfo“.
- Tabs kompakter: Alle vier Tabs haben jetzt kleine Paddings und Textgröße (`px-2 py-1 text-xs`) und ein Grid mit 4 Spalten, damit sie nebeneinander passen.

Bitte neu laden und prüfen:
- Ob im Tab „Metadaten“ nur inhaltliche Felder stehen.
- Ob alle vier Tabs nebeneinander sichtbar sind.

---

**User**

@pdf-phases-view.tsx Wie funktioniert dieser Phase Step Preview? Ich habe oben die Möglichkeit, eine Phase auszuwählen, und unten ändert sich dann die Ansicht für die spezifische Phase. Links das PDF, rechts das Markdown, oder links das Markdown und rechts dann diese Metadaten. Und diese Logik gefällt mir eigentlich nicht. Die möchte ich verbessern. Können wir zuerst mal genauer analysieren, wie die momentane Logik ist, wie die Abhängigkeit, was wird wann wie gezeigt.

---

**Cursor**

### Aktuelle Logik von PdfPhasesView

- Zustände/Abhängigkeiten
  - Phase aus `activePdfPhaseAtom` steuert das Layout.
  - Shadow‑Twin (Markdown-Datei) aus `selectedShadowTwinAtom`; Inhalt wird bei Änderung geladen.
  - PDF‑URL via `getStreamingUrl(item.id)`.
  - Globale Seite `currentPdfPageAtom` steuert den Scroll-Sync.
  - Scroll‑Sync:
    - Phase 1: beobachtet Marker im rechten Pane (Markdown) und scrollt links (PDF).
    - Phase 2: beobachtet Marker im linken Pane (Markdown) und scrollt rechts (PDF).
    - Verhindert Ping‑Pong mit Flags.

- Phase-bezogene Darstellung (Zweispalter)
  - Phase 1 (Extraktion)
    - Links: PDF
    - Rechts: Markdown (Shadow‑Twin)
  - Phase 2 (Metadaten)
    - Links: Markdown (Shadow‑Twin)
    - Rechts: JobReportTab (Frontmatter-only, Meta/Kapitel)
  - Phase 3 (Ingestion/Report)
    - Links: Platzhalter „Metadaten‑Vorschau“
    - Rechts: JobReportTab (Merged, Full mit Schritten/Logs/Parametern)

- Codeausschnitte (entscheidende Stellen)
```135:170:src/components/library/pdf-phases-view.tsx
<div className="min-h-0 overflow-auto rounded border" ref={leftRef}>
  {phase === 1 && (
    pdfUrl ? <PdfCanvasViewer src={pdfUrl} /> : <DocumentPreview provider={provider} activeLibraryId={activeLibraryId} />
  )}
  {phase === 2 && (
    twinLoading ? (
      <div className="p-2 text-sm text-muted-foreground">Lade Shadow‑Twin…</div>
    ) : twinError ? (
      <div className="p-2 text-sm text-destructive">{twinError}</div>
    ) : (
      <MarkdownPreview
        content={twinContent}
        onRegisterApi={(api) => { markdownApiRef.current = api; }}
      />
    )
  )}
  {phase === 3 && (
    <div className="p-2 text-sm text-muted-foreground">Metadaten-Vorschau</div>
  )}
</div>
```

```172:214:src/components/library/pdf-phases-view.tsx
<div className="min-h-0 overflow-auto rounded border" ref={rightRef}>
  {phase === 1 && (
    twinLoading ? (
      <div className="p-2 text-sm text-muted-foreground">Lade Shadow‑Twin…</div>
    ) : twinError ? (
      <div className="p-2 text-sm text-destructive">{twinError}</div>
    ) : (
      <MarkdownPreview content={twinContent} />
    )
  )}
  {phase === 2 && (
    <div className="h-full">
      <JobReportTab
        libraryId={activeLibraryId}
        fileId={item.id}
        fileName={item.metadata?.name}
        provider={provider || undefined}
        sourceMode="frontmatter"
        viewMode="metaOnly"
        mdFileId={shadowTwin?.id || null}
        onJumpTo={({ page, evidence }) => { /* setzt currentPage bzw. sucht Evidence */ }}
      />
    </div>
  )}
  {phase === 3 && (
    <div className="h-full">
      <JobReportTab libraryId={activeLibraryId} fileId={item.id} fileName={item.metadata?.name} provider={provider || undefined} sourceMode="merged" viewMode="full" />
    </div>
  )}
</div>
```

```38:50:src/components/library/pdf-phases-view.tsx
React.useEffect(() => {
  if (phase !== 1 && phase !== 2) return;
  const container = phase === 1 ? rightRef.current : leftRef.current;
  if (!container) return;
  const marker = container.querySelector(`[data-page-marker="${currentPage}"]`) as HTMLElement | null
    || container.querySelector(`[data-page="${currentPage}"]`) as HTMLElement | null
    || container.querySelector(`comment[data-page="${currentPage}"]`) as HTMLElement | null;
  if (!marker) return;
  syncingFromPdfRef.current = true;
  container.scrollTo({ top: marker.offsetTop - 16, behavior: 'smooth' });
  window.setTimeout(() => { syncingFromPdfRef.current = false; }, 250);
}, [currentPage, phase]);
```

```98:133:src/components/library/pdf-phases-view.tsx
React.useEffect(() => {
  if (phase !== 1 && phase !== 2) return;
  const container = phase === 1 ? rightRef.current : leftRef.current;
  const leftContainer = leftRef.current;
  if (!container || !leftContainer) return;

  const markers = Array.from(container.querySelectorAll('[data-page-marker]')) as HTMLElement[];
  if (markers.length === 0) return;

  const observer = new IntersectionObserver((entries) => {
    if (syncingFromPdfRef.current) return;
    let best: { page: number; ratio: number } | null = null;
    for (const e of entries) {
      const attr = (e.target as HTMLElement).getAttribute('data-page-marker');
      const page = attr ? Number(attr) : NaN;
      if (Number.isNaN(page)) continue;
      const ratio = e.intersectionRatio;
      if (!best || ratio > best.ratio) best = { page, ratio };
    }
    if (!best || best.ratio < 0.25) return;
    if (!syncingFromMarkdownRef.current) {
      syncingFromMarkdownRef.current = true;
      const targetPane = phase === 1 ? leftContainer : rightRef.current;
      const selector = phase === 1 ? `[data-page="${best.page}"]` : `[data-page-marker="${best.page}"]`;
      const el = targetPane ? targetPane.querySelector(selector) as HTMLElement | null : null;
      if (el && targetPane) targetPane.scrollTo({ top: el.offsetTop - 16, behavior: 'smooth' });
      if (best.page !== currentPage) setCurrentPage(best.page);
      window.setTimeout(() => { syncingFromMarkdownRef.current = false; }, 250);
    }
  }, { root: container, threshold: [0, 0.25, 0.5, 0.75, 1] });

  markers.forEach(m => observer.observe(m));
  return () => observer.disconnect();
}, [phase, twinContent]);
```

### Einschätzung
- Die Phase steuert, welches Pane welches Artefakt zeigt (PDF/Markdown vs. Markdown/Meta).
- Der Wechsel von links/rechts je Phase ist inkonsistent (Phase 1: PDF links, Phase 2: Markdown links), was die mentale Zuordnung erschwert.
- Der Scroll‑Sync ist solide (beidseitig, mit Entkopplung), aber die Marker‑Detektion hängt von korrekt injizierten `data-page-marker`/`data-page` Attributen in Markdown-/PDF‑Views ab.
- Phase 3 nutzt eine Platzhalter‑Linke Seite; hier fehlt konsistente Nutzung (z. B. linke Seite weiterhin Markdown/Preview oder Summary).

Wenn du möchtest, mache ich im nächsten Schritt einen konkreten Umbau‑Vorschlag:
- Konstante Pane‑Zuordnung (z. B. links immer PDF/Markdown, rechts Kontext/Meta).
- Ein einheitlicher Tabs‑Header pro Phase (Preview | Meta | Prozess | Report) ohne Phasenbedingte Pane‑Vertauschung.
- Klarer „Arbeitsablauf“: Phase steuert Datenfluss, nicht die UI‑Seitenlogik.

```typescriptreact
<div className="min-h-0 overflow-auto rounded border" ref={leftRef}>
  {phase === 1 && (
    pdfUrl ? <PdfCanvasViewer src={pdfUrl} /> : <DocumentPreview provider={provider} activeLibraryId={activeLibraryId} />
  )}
  {phase === 2 && (
    twinLoading ? (
      <div className="p-2 text-sm text-muted-foreground">Lade Shadow‑Twin…</div>
    ) : twinError ? (
      <div className="p-2 text-sm text-destructive">{twinError}</div>
    ) : (
      <MarkdownPreview
        content={twinContent}
        onRegisterApi={(api) => { markdownApiRef.current = api; }}
      />
    )
  )}
  {phase === 3 && (
    <div className="p-2 text-sm text-muted-foreground">Metadaten-Vorschau</div>
  )}
</div>
```

```typescriptreact
<div className="min-h-0 overflow-auto rounded border" ref={rightRef}>
  {phase === 1 && (
    twinLoading ? (
      <div className="p-2 text-sm text-muted-foreground">Lade Shadow‑Twin…</div>
    ) : twinError ? (
      <div className="p-2 text-sm text-destructive">{twinError}</div>
    ) : (
      <MarkdownPreview content={twinContent} />
    )
  )}
  {phase === 2 && (
    <div className="h-full">
      <JobReportTab
        libraryId={activeLibraryId}
        fileId={item.id}
        fileName={item.metadata?.name}
        provider={provider || undefined}
        sourceMode="frontmatter"
        viewMode="metaOnly"
        mdFileId={shadowTwin?.id || null}
        onJumpTo={({ page, evidence }) => { /* setzt currentPage bzw. sucht Evidence */ }}
      />
    </div>
  )}
  {phase === 3 && (
    <div className="h-full">
      <JobReportTab libraryId={activeLibraryId} fileId={item.id} fileName={item.metadata?.name} provider={provider || undefined} sourceMode="merged" viewMode="full" />
    </div>
  )}
</div>
```

```typescriptreact
React.useEffect(() => {
  if (phase !== 1 && phase !== 2) return;
  const container = phase === 1 ? rightRef.current : leftRef.current;
  if (!container) return;
  const marker = container.querySelector(`[data-page-marker="${currentPage}"]`) as HTMLElement | null
    || container.querySelector(`[data-page="${currentPage}"]`) as HTMLElement | null
    || container.querySelector(`comment[data-page="${currentPage}"]`) as HTMLElement | null;
  if (!marker) return;
  syncingFromPdfRef.current = true;
  container.scrollTo({ top: marker.offsetTop - 16, behavior: 'smooth' });
  window.setTimeout(() => { syncingFromPdfRef.current = false; }, 250);
}, [currentPage, phase]);
```

```typescriptreact
React.useEffect(() => {
  if (phase !== 1 && phase !== 2) return;
  const container = phase === 1 ? rightRef.current : leftRef.current;
  const leftContainer = leftRef.current;
  if (!container || !leftContainer) return;

  const markers = Array.from(container.querySelectorAll('[data-page-marker]')) as HTMLElement[];
  if (markers.length === 0) return;

  const observer = new IntersectionObserver((entries) => {
    if (syncingFromPdfRef.current) return;
    let best: { page: number; ratio: number } | null = null;
    for (const e of entries) {
      const attr = (e.target as HTMLElement).getAttribute('data-page-marker');
      const page = attr ? Number(attr) : NaN;
      if (Number.isNaN(page)) continue;
      const ratio = e.intersectionRatio;
      if (!best || ratio > best.ratio) best = { page, ratio };
    }
    if (!best || best.ratio < 0.25) return;
    if (!syncingFromMarkdownRef.current) {
      syncingFromMarkdownRef.current = true;
      const targetPane = phase === 1 ? leftContainer : rightRef.current;
      const selector = phase === 1 ? `[data-page="${best.page}"]` : `[data-page-marker="${best.page}"]`;
      const el = targetPane ? targetPane.querySelector(selector) as HTMLElement | null : null;
      if (el && targetPane) targetPane.scrollTo({ top: el.offsetTop - 16, behavior: 'smooth' });
      if (best.page !== currentPage) setCurrentPage(best.page);
      window.setTimeout(() => { syncingFromMarkdownRef.current = false; }, 250);
    }
  }, { root: container, threshold: [0, 0.25, 0.5, 0.75, 1] });

  markers.forEach(m => observer.observe(m));
  return () => observer.disconnect();
}, [phase, twinContent]);
```

---

**User**

Ja, diese konstante Paint-Zuordnung, z.B. links immer PDF oder Markdown und rechts Context-Metadata, das wäre super. Wir haben auch, wie hier, ja bereits ein, diesen, unter Metadaten haben wir rechts ja schon so einen Viewer, der Markdown, Metadaten, Kapitel und Prozessinfo in sich vereint. Also wir haben hier doppelte Logik, die müssten wir auch eliminieren, dass nicht auf der linken und auf der rechten Seite dasselbe angezeigt wird. Aber im Prinzip ist es schon so, dass ich links schaue ich auf den Text, original, als PDF oder als Markdown, das sollte man so switchen können, und rechts auf diese Auswertungen, auf diese Extraktion dieser Metadaten, Kapitelstruktur und auch auf die Prozessinfo und oben möchte ich gerne eigentlich nur den Fortschritt sehen, welcher Prozessschritt wurde schon verarbeitet. 

Speziell beim ersten Extraktionsschritt möchte ich schon links PDF und rechts Markdown vergleichen, weil ich da ja Fehler suchen muss. Wie können wir das integrieren?

---

**Cursor**

Kurzlösung

- Für Phase 1 fügen wir einen “Vergleichsmodus” hinzu:


---

**User**

Wir können ja links den PDF-Ansicht belassen, wie immer, egal in welchem Prozessschritt ich bin, und rechts diesen bestehenden Viewer, wo man zwischen Markdown, Metadaten, usw. wechseln kann. Und ich kann das PDF halt auch zuklappen, um den ganzen Platz zu nutzen.

---

**Cursor**

```typescriptreact
"use client";

import * as React from "react";
import { useAtom, useAtomValue } from "jotai";
import { activePdfPhaseAtom } from "@/atoms/pdf-phases";
import type { StorageItem, StorageProvider } from "@/lib/storage/types";
import { DocumentPreview } from "./document-preview";
import { MarkdownPreview } from "./markdown-preview";
import { JobReportTab } from "./job-report-tab";
import { PhaseStepper } from "./phase-stepper";
import { activeLibraryIdAtom, selectedShadowTwinAtom } from "@/atoms/library-atom";
import { FileLogger } from "@/lib/debug/logger";
import { PdfCanvasViewer } from "./pdf-canvas-viewer";
import { useStorage } from "@/contexts/storage-context";
import { currentPdfPageAtom } from "@/atoms/pdf-viewer";
// Button und direkte Template-Analyse wurden entfernt – Steuerung erfolgt ausschließlich über PhaseStepper

interface PdfPhasesViewProps {
  item: StorageItem;
  provider: StorageProvider | null;
  markdownContent?: string;
}

export function PdfPhasesView({ item, provider, markdownContent }: PdfPhasesViewProps) {
  const [phase] = useAtom(activePdfPhaseAtom);
  const activeLibraryId = useAtomValue(activeLibraryIdAtom);
  const shadowTwin = useAtomValue(selectedShadowTwinAtom);
  const [twinContent, setTwinContent] = React.useState<string>(markdownContent || "");
  const [twinLoading, setTwinLoading] = React.useState<boolean>(false);
  const [twinError, setTwinError] = React.useState<string | null>(null);
  const { provider: storageProvider } = useStorage();
  const [currentPage, setCurrentPage] = useAtom(currentPdfPageAtom);
  const [isPdfCollapsed, setIsPdfCollapsed] = React.useState(false);
  const leftRef = React.useRef<HTMLDivElement | null>(null);
  const rightRef = React.useRef<HTMLDivElement | null>(null);
  const syncingFromPdfRef = React.useRef(false);
  const syncingFromMarkdownRef = React.useRef(false);

  // Globaler Page→Scroll Sync: scrolle beide Paneele zur aktuellen Seite (falls Marker vorhanden)
  React.useEffect(() => {
    const scrollToMarker = (root: HTMLElement | null, selector: string) => {
      if (!root) return;
      const el = root.querySelector(selector) as HTMLElement | null;
      if (!el) return;
      root.scrollTo({ top: el.offsetTop - 16, behavior: 'smooth' });
    };
    // Links: PDF nutzt [data-page]
    scrollToMarker(leftRef.current, `[data-page="${currentPage}"]`);
    // Rechts: Markdown nutzt [data-page-marker]
    scrollToMarker(rightRef.current, `[data-page-marker="${currentPage}"]`);
  }, [currentPage]);

  const [pdfUrl, setPdfUrl] = React.useState<string | null>(null);
  const markdownApiRef = React.useRef<{ scrollToText: (q: string) => void; scrollToPage: (n: number | string) => void; setQueryAndSearch: (q: string) => void; getVisiblePage?: () => number | null } | null>(null);

  // Shadow‑Twin laden
  React.useEffect(() => {
    let cancelled = false;
    async function loadTwin() {
      try {
        setTwinLoading(true);
        setTwinError(null);
        if (!provider || !shadowTwin?.id) {
          setTwinContent("");
          return;
        }
        FileLogger.info('PdfPhasesView', 'Lade Shadow‑Twin Inhalt', { twinId: shadowTwin.id, name: shadowTwin.metadata?.name });
        const { blob } = await provider.getBinary(shadowTwin.id);
        const text = await blob.text();
        if (!cancelled) setTwinContent(text);
      } catch (err) {
        const message = err instanceof Error ? err.message : 'Unbekannter Fehler';
        FileLogger.error('PdfPhasesView', 'Fehler beim Laden des Shadow‑Twin', { error: message });
        if (!cancelled) setTwinError(message);
      } finally {
        if (!cancelled) setTwinLoading(false);
      }
    }
    void loadTwin();
    return () => { cancelled = true; };
  }, [provider, shadowTwin?.id]);

  // PDF-Streaming URL laden
  React.useEffect(() => {
    let cancelled = false;
    async function loadUrl() {
      try {
        if (!storageProvider || !item?.id) return;
        const url = await storageProvider.getStreamingUrl(item.id);
        if (!cancelled) setPdfUrl(url);
      } catch (err) {
        FileLogger.error('PdfPhasesView', 'PDF URL Fehler', err);
      }
    }
    void loadUrl();
    return () => { cancelled = true; };
  }, [storageProvider, item?.id]);

  // Scroll Sync von rechts (Markdown) → links (PDF)
  React.useEffect(() => {
    const container = rightRef.current;
    const targetPane = leftRef.current;
    if (!container || !targetPane) return;
    const markers = Array.from(container.querySelectorAll('[data-page-marker]')) as HTMLElement[];
    if (markers.length === 0) return;
    const observer = new IntersectionObserver((entries) => {
      if (syncingFromPdfRef.current) return;
      let best: { page: number; ratio: number } | null = null;
      for (const e of entries) {
        const attr = (e.target as HTMLElement).getAttribute('data-page-marker');
        const page = attr ? Number(attr) : NaN;
        if (!Number.isFinite(page)) continue;
        const ratio = e.intersectionRatio;
        if (!best || ratio > best.ratio) best = { page, ratio };
      }
      if (!best || best.ratio < 0.25) return;
      syncingFromMarkdownRef.current = true;
      const el = targetPane.querySelector(`[data-page="${best.page}"]`) as HTMLElement | null;
      if (el) targetPane.scrollTo({ top: el.offsetTop - 16, behavior: 'smooth' });
      if (best.page !== currentPage) setCurrentPage(best.page);
      window.setTimeout(() => { syncingFromMarkdownRef.current = false; }, 250);
    }, { root: container, threshold: [0, 0.25, 0.5, 0.75, 1] });
    markers.forEach(m => observer.observe(m));
    return () => observer.disconnect();
  }, [twinContent]);

  // Scroll Sync von links (PDF) → rechts (Markdown)
  React.useEffect(() => {
    const container = leftRef.current;
    const targetPane = rightRef.current;
    if (!container || !targetPane) return;
    const markers = Array.from(container.querySelectorAll('[data-page]')) as HTMLElement[];
    if (markers.length === 0) return;
    const observer = new IntersectionObserver((entries) => {
      if (syncingFromMarkdownRef.current) return;
      let best: { page: number; ratio: number } | null = null;
      for (const e of entries) {
        const attr = (e.target as HTMLElement).getAttribute('data-page');
        const page = attr ? Number(attr) : NaN;
        if (!Number.isFinite(page)) continue;
        const ratio = e.intersectionRatio;
        if (!best || ratio > best.ratio) best = { page, ratio };
      }
      if (!best || best.ratio < 0.25) return;
      syncingFromPdfRef.current = true;
      const el = targetPane.querySelector(`[data-page-marker="${best.page}"]`) as HTMLElement | null;
      if (el) targetPane.scrollTo({ top: el.offsetTop - 16, behavior: 'smooth' });
      if (best.page !== currentPage) setCurrentPage(best.page);
      window.setTimeout(() => { syncingFromPdfRef.current = false; }, 250);
    }, { root: container, threshold: [0, 0.25, 0.5, 0.75, 1] });
    markers.forEach(m => observer.observe(m));
    return () => observer.disconnect();
  }, [pdfUrl]);

  return (
    <div className="flex h-full flex-col gap-2">
      <div className="flex items-center justify-between gap-2">
        <PhaseStepper />
        <div className="ml-auto flex items-center gap-2 pr-1">
          <button type="button" className="h-7 px-2 border rounded text-xs" onClick={() => setIsPdfCollapsed(v => !v)}>{isPdfCollapsed ? 'PDF zeigen' : 'PDF ausblenden'}</button>
          <form className="flex items-center gap-1" onSubmit={(e) => { e.preventDefault(); const input = (e.currentTarget.elements.namedItem('gpage') as HTMLInputElement | null); if (!input) return; const val = Number(input.value); if (Number.isFinite(val) && val >= 1) setCurrentPage(val); }}>
            <span className="text-xs text-muted-foreground">Seite</span>
            <input name="gpage" value={currentPage} onChange={(e) => setCurrentPage(Number(e.target.value) || 1)} className="h-7 w-16 text-center border rounded text-xs" />
            <button type="submit" className="h-7 px-2 border rounded text-xs">Gehe</button>
          </form>
        </div>
      </div>

      {/* Split */}
      <div className="grid grid-cols-2 gap-2 h-full min-h-0">
        {/* Left Pane: immer PDF (ein-/ausblendbar) */}
        <div className={`min-h-0 overflow-auto rounded border ${isPdfCollapsed ? 'hidden' : ''}`} ref={leftRef}>
          {pdfUrl ? <PdfCanvasViewer src={pdfUrl} /> : <DocumentPreview provider={provider} activeLibraryId={activeLibraryId} />}
        </div>

        {/* Right Pane: immer Analyse-Viewer (Markdown/Metadaten/Kapitel/Prozessinfo) */}
        <div className={`min-h-0 overflow-auto rounded border ${isPdfCollapsed ? 'col-span-2' : ''}`} ref={rightRef}>
          <div className="h-full">
            <JobReportTab
              libraryId={activeLibraryId}
              fileId={item.id}
              fileName={item.metadata?.name}
              provider={provider || undefined}
              sourceMode="frontmatter"
              viewMode="metaOnly"
              mdFileId={shadowTwin?.id || null}
              onJumpTo={({ page, evidence }) => {
                if (typeof page === 'number' || typeof page === 'string') {
                  const p = typeof page === 'string' ? Number(page) : page;
                  if (Number.isFinite(p)) setCurrentPage(p as number);
                } else if (typeof evidence === 'string' && evidence.trim()) {
                  if (markdownApiRef.current) {
                    markdownApiRef.current.setQueryAndSearch(evidence.slice(0, 80));
                    const vis = markdownApiRef.current.getVisiblePage?.();
                    if (vis && Number.isFinite(vis)) setCurrentPage(vis as number);
                  }
                }
              }}
            />
          </div>
        </div>
      </div>
    </div>
  );
}



```

Status: Ich habe die Ansicht auf konstante Pane-Zuordnung umgestellt: links immer PDF (ein-/ausblendbar), rechts immer der Analyse-Viewer mit Markdown/Metadaten/Kapitel/Prozessinfo. Scroll‑Sync wurde symmetrisch implementiert. Tabs oben bleiben unverändert.

- Links: PDF bleibt in allen Phasen sichtbar; Button schaltet „PDF ausblenden/zeigen“.
- Rechts: Nur ein Viewer (kein doppeltes Markdown mehr). Für Phase 1 kannst du so PDF vs. Markdown vergleichen; bei ausgeblendetem PDF nutzt der Viewer die volle Breite.
- Scroll‑Sync:
  - Eingabe „Seite“ scrollt beide Seiten (PDF und Markdown) per Marker.
  - Sichtbarkeit in einer Seite aktualisiert die andere und synchronisiert die globale Seite.

Wenn du zusätzlich im rechten Viewer optional auf „merged/full“ umschalten willst (z. B. Ingestion/Report in Phase 3), kann ich einen kleinen Umschalter hinzufügen.

---

**User**

OK, Um den Bildschirm noch weiter zu nutzen, würde ich gerne die beiden Navigationspaneele FileTree und FileList auch über Buttons in der Toolbar oben ein- und ausblenden. FileTree hat schon einen Button zum Ausblenden, der ist aber kaum sichtbar und sehr schlecht platziert. Den könnten wir stattdessen dann entfernen. Wenn ich beide Paints ausblende, kann ich dann mehr oder weniger den ganzen Bildschirmbreite nutzen.

---

**Cursor**

Ich blende jetzt die beiden Navigationspaneele über Toolbar-Buttons ein/aus: Ich suche die Layout-Komponente (`Library`) und füge zwei Toggles für FileTree und FileList hinzu sowie entferne den alten, schlecht platzierten Button. Danach passe ich `pdf-phases-view.tsx` nicht weiter an, nur die Toolbar.

```typescriptreact
"use client"

import * as React from "react"
import { useCallback, useEffect } from "react"
import { useAtom, useAtomValue } from "jotai"

import { LibraryHeader } from "./library-header"
import { FileTree } from "./file-tree"
import { FileList } from "./file-list"
import dynamic from 'next/dynamic'
const FilePreviewLazy = dynamic(() => import('./file-preview').then(m => m.FilePreview), {
  ssr: false,
  loading: () => (
    <div className="h-full flex items-center justify-center text-muted-foreground">
      Lade Vorschau...
    </div>
  )
})
import { ResizableHandle, ResizablePanel, ResizablePanelGroup } from "@/components/ui/resizable"
import { 
  libraryAtom, 
  folderItemsAtom,
  loadingStateAtom,
  lastLoadedFolderAtom,
  currentFolderIdAtom,
  reviewModeAtom,
  selectedFileAtom,
  selectedShadowTwinAtom
} from "@/atoms/library-atom"
import { activeLibraryIdAtom } from "@/atoms/library-atom"
import { useStorage, isStorageError } from "@/contexts/storage-context"
import { TranscriptionDialog } from "./transcription-dialog"
import { TransformationDialog } from "./transformation-dialog"
import { StorageItem } from "@/lib/storage/types"
import { NavigationLogger, StateLogger, UILogger } from "@/lib/debug/logger"
import { Breadcrumb } from "./breadcrumb"
import { useToast } from "@/components/ui/use-toast"
import { ChevronLeft, ChevronRight } from "lucide-react"
import { useSearchParams } from "next/navigation"
import { useFolderNavigation } from "@/hooks/use-folder-navigation"
export function Library() {
  // Performance-Messung für Kaltstart (nur Client)
  const startupT0Ref = React.useRef<number>(
    typeof performance !== 'undefined' ? performance.now() : 0
  );
  // Globale Atoms
  const [, setFolderItems] = useAtom(folderItemsAtom);
  const [, setLoadingState] = useAtom(loadingStateAtom);
  const [lastLoadedFolder, setLastLoadedFolder] = useAtom(lastLoadedFolderAtom);
  const [currentFolderId] = useAtom(currentFolderIdAtom);
  const [libraryState, setLibraryState] = useAtom(libraryAtom);
  const activeLibraryId = useAtomValue(activeLibraryIdAtom);
  
  // Review-Mode Atoms
  const [isReviewMode] = useAtom(reviewModeAtom);
  const [selectedFile, setSelectedFile] = useAtom(selectedFileAtom);
  const [selectedShadowTwin, setSelectedShadowTwin] = useAtom(selectedShadowTwinAtom);
  
  // Storage Context
  const { 
    provider: providerInstance, 
    error: storageError, 
    listItems,
    libraryStatus,
    currentLibrary
  } = useStorage();
  const { toast } = useToast();
  const [isTreeVisible, setIsTreeVisible] = React.useState<boolean>(false);
  const [isListVisible, setIsListVisible] = React.useState<boolean>(true);
  const [isMobile, setIsMobile] = React.useState<boolean>(false);
  const [mobileView, setMobileView] = React.useState<'list' | 'preview'>('list');
  const loadInFlightRef = React.useRef<boolean>(false);
  const searchParams = useSearchParams();
  const navigateToFolder = useFolderNavigation();

  // Mobile: Tree standardmäßig ausblenden, Desktop: anzeigen
  React.useEffect(() => {
    if (typeof window === 'undefined') return;
    // Desktop ab 1024px, Mobile darunter
    const mq = window.matchMedia('(max-width: 1023px)');
    const apply = (matches: boolean) => {
      setIsMobile(matches);
      setIsTreeVisible(!matches);
    };
    apply(mq.matches);
    const handler = (e: MediaQueryListEvent) => apply(e.matches);
    mq.addEventListener('change', handler);
    return () => mq.removeEventListener('change', handler);
  }, []);

  // URL -> State: folderId aus Query anwenden, wenn Provider bereit ist
  const urlInitAppliedRef = React.useRef(false);
  React.useEffect(() => {
    const folderIdFromUrl = searchParams?.get('folderId');

    if (urlInitAppliedRef.current) return;

    if (!folderIdFromUrl) {
      NavigationLogger.debug('debug@init', 'No folderId in URL', {
        currentFolderId
      });
      urlInitAppliedRef.current = true;
      return;
    }

    if (!providerInstance || libraryStatus !== 'ready') {
      NavigationLogger.debug('debug@init', 'Provider not ready, deferring URL apply', {
        folderIdFromUrl,
        libraryStatus,
        hasProvider: !!providerInstance
      });
      return;
    }

    if (folderIdFromUrl !== currentFolderId) {
      NavigationLogger.info('debug@init', 'Applying folderId from URL (ready)', {
        folderIdFromUrl,
        currentFolderId
      });
      void navigateToFolder(folderIdFromUrl);
    }
    urlInitAppliedRef.current = true;
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [searchParams, providerInstance, libraryStatus, currentFolderId]);

  // Mobile-View Wechsellogik: bei Dateiauswahl zur Vorschau wechseln
  React.useEffect(() => {
    if (!isMobile) return;
    if (selectedFile) setMobileView('preview');
  }, [isMobile, selectedFile]);

  // Optimierter loadItems mit Cache-Check
  const loadItems = useCallback(async () => {
    if (loadInFlightRef.current) {
      NavigationLogger.debug('Library', 'Skip loadItems - load already in flight');
      return;
    }
    if (!providerInstance || libraryStatus !== 'ready') {
      NavigationLogger.debug('Library', 'Skipping loadItems - not ready', {
        hasProvider: !!providerInstance,
        status: libraryStatus
      });
      return;
    }

    // Schutz: Wenn Provider/Context noch auf alte Library zeigt, keine Items übernehmen
    if (currentLibrary?.id && currentLibrary.id !== activeLibraryId) {
      NavigationLogger.debug('Library', 'Skip loadItems - library mismatch', {
        providerLibraryId: currentLibrary.id,
        activeLibraryId
      });
      return;
    }

    loadInFlightRef.current = true;
    setLoadingState({ isLoading: true, loadingFolderId: currentFolderId });

    try {
      // Snapshot zur Vermeidung von Race-Conditions
      const expectedLibraryId = activeLibraryId;
      const expectedFolderId = currentFolderId;

      // Prüfe Cache zuerst
      if (libraryState.folderCache?.[currentFolderId]?.children) {
        const cachedItems = libraryState.folderCache[currentFolderId].children;
        NavigationLogger.info('Library', 'Using cached items', {
          folderId: currentFolderId,
          itemCount: cachedItems.length,
          cacheHit: true
        });
        // Übernehme nur, wenn der Snapshot noch aktuell ist
        if (expectedLibraryId === activeLibraryId && expectedFolderId === currentFolderId) {
          setFolderItems(cachedItems);
          setLastLoadedFolder(currentFolderId);
        }
        return;
      }

      NavigationLogger.info('Library', 'Fetching items from provider', {
        folderId: currentFolderId,
        cacheHit: false
      });
      
      const items = await listItems(currentFolderId);

      // Falls während des Ladens die Library oder der Ordner wechselte: Ergebnis verwerfen
      if (expectedLibraryId !== activeLibraryId || expectedFolderId !== currentFolderId) {
        NavigationLogger.debug('Library', 'Discard loaded items due to context change', {
          expectedLibraryId,
          activeLibraryId,
          expectedFolderId,
          currentFolderId
        });
        return;
      }
      
      // Update Cache und State
      if (currentFolderId !== 'root') {
        const newFolderCache = { ...libraryState.folderCache };
        const parent = newFolderCache[currentFolderId];
        if (parent) {
          newFolderCache[currentFolderId] = {
            ...parent,
            children: items
          };
          StateLogger.info('Library', 'Updating folder cache', {
            folderId: currentFolderId,
            itemCount: items.length,
            cacheSize: Object.keys(newFolderCache).length
          });
          setLibraryState(state => ({
            ...state,
            folderCache: newFolderCache
          }));
        }
      }
      
      setFolderItems(items);
      setLastLoadedFolder(currentFolderId);
      
      StateLogger.info('Library', 'Items loaded successfully', {
        folderId: currentFolderId,
        itemCount: items.length,
        fileCount: items.filter(i => i.type === 'file').length,
        folderCount: items.filter(i => i.type === 'folder').length,
        tSinceMountMs: startupT0Ref.current ? Number((performance.now() - startupT0Ref.current).toFixed(1)) : undefined
      });
      
    } catch (error) {
      if (isStorageError(error) && error.code === 'AUTH_REQUIRED') {
        StateLogger.info('Library', 'Auth required');
        // Keine Fehlermeldung für AUTH_REQUIRED anzeigen
      } else {
        StateLogger.error('Library', 'Failed to load items', {
          error: error instanceof Error ? {
            message: error.message,
            name: error.name,
            stack: error.stack?.split('\n').slice(0, 3)
          } : error,
          folderId: currentFolderId,
          libraryId: currentLibrary?.id,
          libraryPath: currentLibrary?.path
        });
        
        // Benutzerfreundliche Fehlermeldung anzeigen
        let errorMessage = 'Fehler beim Laden der Dateien';
        
        if (error instanceof Error) {
          if (error.message.includes('Nicht authentifiziert')) {
            errorMessage = 'Bitte authentifizieren Sie sich bei Ihrem Cloud-Speicher.';
          } else if (error.message.includes('Bibliothek nicht gefunden')) {
            errorMessage = 'Die ausgewählte Bibliothek wurde nicht gefunden. Bitte überprüfen Sie die Bibliothekskonfiguration.';
          } else if (error.message.includes('Server-Fehler')) {
            errorMessage = 'Server-Fehler beim Laden der Dateien. Bitte überprüfen Sie, ob der Bibliothekspfad existiert und zugänglich ist.';
          } else if (error.message.includes('Keine aktive Bibliothek')) {
            errorMessage = 'Keine aktive Bibliothek verfügbar. Bitte wählen Sie eine Bibliothek aus.';
          } else {
            errorMessage = error.message;
          }
        }
        
        // Toast-Nachricht anzeigen
        toast({
          title: "Fehler beim Laden der Dateien",
          description: errorMessage,
          variant: "destructive",
        });
      }
      setFolderItems([]);
    } finally {
      setLoadingState({ isLoading: false, loadingFolderId: null });
      loadInFlightRef.current = false;
    }
  }, [
    currentFolderId,
    lastLoadedFolder,
    listItems,
    libraryState.folderCache,
    providerInstance,
    libraryStatus,
    setLibraryState,
    setFolderItems,
    setLastLoadedFolder,
    setLoadingState,
    toast,
    currentLibrary
  ]);

  // Effect für Initial-Load (entkoppelt vom FileTree)
  useEffect(() => {
    const isReady = !!providerInstance && libraryStatus === 'ready';
    
    if (!isReady) {
      NavigationLogger.debug('Library', 'Waiting for initialization', {
        hasProvider: !!providerInstance,
        status: libraryStatus
      });
      return;
    }

    // Wenn eine folderId in der URL steht und noch nicht angewendet wurde,
    // verhindere das initiale Laden von "root" (vermeidet Doppel-Load)
    const folderIdFromUrl = searchParams?.get('folderId');
    if (!urlInitAppliedRef.current && folderIdFromUrl && folderIdFromUrl !== currentFolderId) {
      NavigationLogger.debug('debug@init', 'Skip initial root load; URL folderId pending', {
        folderIdFromUrl,
        currentFolderId,
        lastLoadedFolder
      });
      return;
    }

    // Nur laden wenn noch nicht geladen
    if (lastLoadedFolder !== currentFolderId && !loadInFlightRef.current) {
      UILogger.info('Library', 'Initial load triggered', {
        currentFolderId,
        lastLoadedFolder,
        tSinceMountMs: startupT0Ref.current ? Number((performance.now() - startupT0Ref.current).toFixed(1)) : undefined
      });
      NavigationLogger.info('Library', 'Loading initial items', {
        folderId: currentFolderId
      });
      loadItems();
    }
  }, [providerInstance, libraryStatus, currentFolderId, lastLoadedFolder, activeLibraryId, loadItems, searchParams]);

  // Zusätzlicher Reset bei Bibliothekswechsel (robust gegen Status-Race)
  useEffect(() => {
    if (!activeLibraryId) return;
    StateLogger.info('Library', 'Active library changed - reset initial load state', {
      activeLibraryId,
      currentFolderId
    });
    setLastLoadedFolder(null);
    setFolderItems([]);
    setLibraryState(state => ({ ...state, folderCache: {} }));
    // WICHTIG: Ordnerauswahl und Shadow-Twin zurücksetzen
    setSelectedFile(null);
    setSelectedShadowTwin(null);
  }, [activeLibraryId, setLastLoadedFolder, setFolderItems, setLibraryState, currentFolderId]);

  // Reset Cache wenn sich die Library ändert
  useEffect(() => {
    setLastLoadedFolder(null);
    setLibraryState(state => ({
      ...state,
      folderCache: {}
    }));
  }, [libraryStatus, setLibraryState, setLastLoadedFolder]);

  // Manuelle Cache-Clear-Funktion für Review-Modus
  const clearCache = useCallback(() => {
    StateLogger.info('Library', 'Manually clearing cache for review mode');
    setLastLoadedFolder(null);
    setLibraryState(state => ({
      ...state,
      folderCache: {}
    }));
    setFolderItems([]);
  }, [setLibraryState, setLastLoadedFolder, setFolderItems]);

  // Reset selectedShadowTwin wenn Review-Modus verlassen wird
  useEffect(() => {
    if (!isReviewMode) {
      setSelectedShadowTwin(null);
    }
  }, [isReviewMode, setSelectedShadowTwin]);

  // ENTFERNT: Der folgende useEffect war problematisch und hat das Shadow-Twin 
  // bei jedem Klick zurückgesetzt, auch wenn die Datei ein Shadow-Twin hat.
  // Die Shadow-Twin-Logik wird bereits korrekt in der FileList-Komponente 
  // in der handleSelect-Funktion behandelt.

  // Render-Logik für verschiedene Status
  if (libraryStatus === "waitingForAuth") {
    return (
      <div className="flex flex-col items-center justify-center h-full text-muted-foreground">
        <span>Diese Bibliothek benötigt eine Authentifizierung.</span>
        <span className="text-sm mt-2">Bitte konfigurieren Sie die Bibliothek in den Einstellungen.</span>
      </div>
    );
  }
  
  if (libraryStatus !== "ready") {
    return (
      <div className="flex flex-col items-center justify-center h-full text-muted-foreground">
        <span>Lade Storage...</span>
      </div>
    );
  }

  return (
    <div className="flex flex-col h-full">
      <LibraryHeader
        provider={providerInstance}
        error={storageError}
        onUploadComplete={loadItems}
        onClearCache={clearCache}
        isTreeVisible={isTreeVisible}
        onToggleTree={() => setIsTreeVisible(v => !v)}
      >
        <Breadcrumb />
      </LibraryHeader>
      
      <div className="flex-1 min-h-0 overflow-hidden">
        {isReviewMode ? (
          // Review-Layout: 3 Panels ohne FileTree - FileList (compact) | FilePreview (Basis-Datei) | FilePreview (Shadow-Twin)
          <ResizablePanelGroup direction="horizontal" className="h-full">
            <ResizablePanel defaultSize={25} minSize={20} className="min-h-0">
              <div className="h-full overflow-auto flex flex-col">
                <FileList compact={true} />
              </div>
            </ResizablePanel>
            <ResizableHandle />
            <ResizablePanel defaultSize={37.5} minSize={30} className="min-h-0">
              <div className="h-full relative flex flex-col">
                {selectedFile ? (
                  <FilePreviewLazy
                    provider={providerInstance}
                    file={selectedFile}
                    onRefreshFolder={(folderId, items, selectFileAfterRefresh) => {
                    StateLogger.info('Library', 'FilePreview (Basis) onRefreshFolder aufgerufen', {
                      folderId,
                      itemsCount: items.length,
                      hasSelectFile: !!selectFileAfterRefresh
                    });
                    
                    // Aktualisiere die Dateiliste
                    setFolderItems(items);
                    
                    // Aktualisiere den Cache
                    if (libraryState.folderCache?.[folderId]) {
                      const cachedFolder = libraryState.folderCache[folderId];
                      if (cachedFolder) {
                        setLibraryState(state => ({
                          ...state,
                          folderCache: {
                            ...(state.folderCache || {}),
                            [folderId]: {
                              ...cachedFolder,
                              children: items
                            }
                          }
                        }));
                      }
                    }
                    
                    // Wenn eine Datei ausgewählt werden soll (nach dem Speichern)
                    if (selectFileAfterRefresh) {
                      StateLogger.info('Library', 'Wähle gespeicherte Datei aus', {
                        fileId: selectFileAfterRefresh.id,
                        fileName: selectFileAfterRefresh.metadata.name
                      });
                    }
                    }}
                  />
                ) : (
                  <div className="h-full flex items-center justify-center text-muted-foreground">
                    <p>Keine Datei ausgewählt</p>
                  </div>
                )}
              </div>
            </ResizablePanel>
            <ResizableHandle />
            <ResizablePanel defaultSize={37.5} minSize={30} className="min-h-0">
              <div className="h-full relative flex flex-col">
                {selectedShadowTwin ? (
                  <FilePreviewLazy
                    provider={providerInstance}
                    file={selectedShadowTwin}
                    onRefreshFolder={(folderId, items, selectFileAfterRefresh) => {
                      StateLogger.info('Library', 'FilePreview (Shadow-Twin) onRefreshFolder aufgerufen', {
                        folderId,
                        itemsCount: items.length,
                        hasSelectFile: !!selectFileAfterRefresh
                      });
                      
                      // Aktualisiere die Dateiliste
                      setFolderItems(items);
                      
                      // Aktualisiere den Cache
                      if (libraryState.folderCache?.[folderId]) {
                        const cachedFolder = libraryState.folderCache[folderId];
                        if (cachedFolder) {
                          setLibraryState(state => ({
                            ...state,
                            folderCache: {
                              ...(state.folderCache || {}),
                              [folderId]: {
                                ...cachedFolder,
                                children: items
                              }
                            }
                          }));
                        }
                      }
                      
                      // Wenn eine Datei ausgewählt werden soll (nach dem Speichern)
                      if (selectFileAfterRefresh) {
                        StateLogger.info('Library', 'Wähle gespeicherte Datei aus', {
                          fileId: selectFileAfterRefresh.id,
                          fileName: selectFileAfterRefresh.metadata.name
                        });
                      }
                    }}
                  />
                ) : (
                  <div className="h-full flex items-center justify-center text-muted-foreground">
                    <p>Kein Shadow-Twin ausgewählt</p>
                  </div>
                )}
              </div>
            </ResizablePanel>
          </ResizablePanelGroup>
        ) : (
          // Normal-Layout (Desktop) oder alternierendes Mobile-Layout
          <div className="relative h-full">
            {/* Entfernt: alter Tree-Handle (ersetzt durch Header-Toggle) */}

            {isMobile ? (
              mobileView === 'list' ? (
                <div className="h-full overflow-auto flex flex-col">
                  <FileList />
                </div>
              ) : (
                <div className="h-full flex flex-col">
                  <div className="flex items-center gap-2 p-2 border-b bg-background">
                    <button
                      type="button"
                      className="inline-flex items-center gap-1 text-sm px-2 py-1 border rounded-md"
                      onClick={() => {
                        setMobileView('list');
                        setSelectedShadowTwin(null);
                        setSelectedFile(null);
                        loadItems();
                      }}
                    >
                      <ChevronLeft className="h-4 w-4" />
                      Zurück
                    </button>
                    <div className="text-sm text-muted-foreground truncate">
                      {selectedFile?.metadata.name}
                    </div>
                  </div>
                  <div className="flex-1 min-h-0">
                    {selectedFile ? (
                      <FilePreviewLazy
                        provider={providerInstance}
                        onRefreshFolder={(folderId, items, selectFileAfterRefresh) => {
                        StateLogger.info('Library', 'FilePreview onRefreshFolder aufgerufen', {
                          folderId,
                          itemsCount: items.length,
                          hasSelectFile: !!selectFileAfterRefresh
                        });
                        setFolderItems(items);
                        if (libraryState.folderCache?.[folderId]) {
                          const cachedFolder = libraryState.folderCache[folderId];
                          if (cachedFolder) {
                            setLibraryState(state => ({
                              ...state,
                              folderCache: {
                                ...(state.folderCache || {}),
                                [folderId]: { ...cachedFolder, children: items }
                              }
                            }));
                          }
                        }
                        }}
                      />
                    ) : (
                      <div className="h-full flex items-center justify-center text-muted-foreground">
                        <p>Keine Datei ausgewählt</p>
                      </div>
                    )}
                  </div>
                </div>
              )
            ) : (
              <ResizablePanelGroup
                key={isTreeVisible ? 'with-tree' : 'no-tree'}
                direction="horizontal"
                className="h-full"
                autoSaveId={isTreeVisible ? "library-panels-3" : "library-panels-2"}
              >
                {isTreeVisible && (
                  <>
                    <ResizablePanel key="tree-panel" id="tree" defaultSize={20} minSize={15} className="min-h-0">
                      <div className="h-full overflow-auto flex flex-col">
                        <FileTree />
                      </div>
                    </ResizablePanel>
                    <ResizableHandle key="tree-handle" />
                  </>
                )}
                {isListVisible && (
                  <>
                    <ResizablePanel key="list-panel" id="list" defaultSize={isTreeVisible ? 40 : 50} className="min-h-0">
                      <div className="h-full overflow-auto flex flex-col">
                        <FileList />
                      </div>
                    </ResizablePanel>
                    <ResizableHandle key="list-preview-handle" />
                  </>
                )}
                <ResizablePanel key="preview-panel" id="preview" defaultSize={isTreeVisible ? 40 : 50} className="min-h-0">
                  <div className="h-full relative flex flex-col">
                    {selectedFile ? (
                      <FilePreviewLazy
                        provider={providerInstance}
                        onRefreshFolder={(folderId, items, selectFileAfterRefresh) => {
                        StateLogger.info('Library', 'FilePreview onRefreshFolder aufgerufen', {
                          folderId,
                          itemsCount: items.length,
                          hasSelectFile: !!selectFileAfterRefresh
                        });
                        
                        // Aktualisiere die Dateiliste
                        setFolderItems(items);
                        
                        // Aktualisiere den Cache
                        if (libraryState.folderCache?.[folderId]) {
                          const cachedFolder = libraryState.folderCache[folderId];
                          if (cachedFolder) {
                            setLibraryState(state => ({
                              ...state,
                              folderCache: {
                                ...(state.folderCache || {}),
                                [folderId]: {
                                  ...cachedFolder,
                                  children: items
                                }
                              }
                            }));
                          }
                        }
                        
                        if (selectFileAfterRefresh) {
                          StateLogger.info('Library', 'Wähle gespeicherte Datei aus', {
                            fileId: selectFileAfterRefresh.id,
                            fileName: selectFileAfterRefresh.metadata.name
                          });
                        }
                        }}
                      />
                    ) : (
                      <div className="h-full flex items-center justify-center text-muted-foreground">
                        <p>Keine Datei ausgewählt</p>
                      </div>
                    )}
                  </div>
                </ResizablePanel>
              </ResizablePanelGroup>
            )}
          </div>
        )}
      </div>
      
      {/* Dialoge */}
      <TranscriptionDialog />
      <TransformationDialog 
        onRefreshFolder={(folderId: string, items: StorageItem[], selectFileAfterRefresh?: StorageItem) => {
          StateLogger.info('Library', 'TransformationDialog onRefreshFolder aufgerufen', {
            folderId,
            itemsCount: items.length,
            hasSelectFile: !!selectFileAfterRefresh
          });
          
          // Aktualisiere die Dateiliste
          setFolderItems(items);
          
          // Aktualisiere den Cache
          if (libraryState.folderCache?.[folderId]) {
            const cachedFolder = libraryState.folderCache[folderId];
            if (cachedFolder) {
              setLibraryState(state => ({
                ...state,
                folderCache: {
                  ...(state.folderCache || {}),
                  [folderId]: {
                    ...cachedFolder,
                    children: items
                  }
                }
              }));
            }
          }
          
          // Wenn eine Datei ausgewählt werden soll (nach dem Speichern)
          if (selectFileAfterRefresh) {
            StateLogger.info('Library', 'Wähle gespeicherte Datei aus', {
              fileId: selectFileAfterRefresh.id,
              fileName: selectFileAfterRefresh.metadata.name
            });
          }
        }}
      />
    </div>
  );
}
```

```typescriptreact
import * as React from "react"
import { UILogger } from "@/lib/debug/logger"
import { Button } from "@/components/ui/button"
import { Upload, AlertTriangle, ArrowLeft, Eye, FileStack, Sidebar, LayoutList } from "lucide-react"
import { UploadDialog } from "./upload-dialog"
import { StorageProvider } from "@/lib/storage/types"
import { useCallback } from "react"
import { Alert, AlertDescription } from "@/components/ui/alert"
import { useAtom, useAtomValue } from "jotai"
import { currentFolderIdAtom, reviewModeAtom, libraryAtom } from "@/atoms/library-atom"
import { Breadcrumb } from "./breadcrumb"
import { AudioRecorderClient } from "./audio-recorder-client"
import PdfBulkImportDialog from "./pdf-bulk-import-dialog"
import { useFolderNavigation } from "@/hooks/use-folder-navigation"

interface LibraryHeaderProps {
  provider: StorageProvider | null
  onUploadComplete?: () => void
  error?: string | null
  children?: React.ReactNode
  onClearCache?: () => void // Cache-Invalidierung
  isTreeVisible?: boolean
  onToggleTree?: () => void
  isListVisible?: boolean
  onToggleList?: () => void
}

export function LibraryHeader({
  provider,
  onUploadComplete,
  error,
  children,
  onClearCache,
  isTreeVisible,
  onToggleTree,
  isListVisible,
  onToggleList
}: LibraryHeaderProps) {
  const [isUploadOpen, setIsUploadOpen] = React.useState(false)
  const [isPdfBulkOpen, setIsPdfBulkOpen] = React.useState(false)
  const [currentFolderId] = useAtom(currentFolderIdAtom);
  const [isReviewMode, setIsReviewMode] = useAtom(reviewModeAtom);
  const libraryState = useAtomValue(libraryAtom);
  const navigateToFolder = useFolderNavigation();

  // Aktueller Library-Name (für Root-Ebene)
  const currentLibraryName = React.useMemo(() => {
    const libId = libraryState.activeLibraryId;
    return libraryState.libraries.find(l => l.id === libId)?.label || 'Library';
  }, [libraryState.activeLibraryId, libraryState.libraries]);

  // Kompakter Pfadname (nur aktueller/übergeordneter Ordner), mobil mit Ellipsis
  const compactPathName = React.useMemo(() => {
    if (currentFolderId === 'root') return currentLibraryName;
    const folder = libraryState.folderCache?.[currentFolderId];
    return folder?.metadata?.name ?? '';
  }, [libraryState.folderCache, currentFolderId, currentLibraryName]);

  const parentId = React.useMemo(() => {
    if (currentFolderId === 'root') return null;
    const folder = libraryState.folderCache?.[currentFolderId];
    const pid = folder?.parentId;
    if (pid && pid.length > 0) return pid;
    return 'root';
  }, [libraryState.folderCache, currentFolderId]);

  const handleUploadComplete = useCallback(() => {
    UILogger.info('LibraryHeader', 'Upload completed');
    onUploadComplete?.();
    setIsUploadOpen(false);
  }, [onUploadComplete]);

  const handleUploadClick = useCallback(() => {
    UILogger.info('LibraryHeader', 'Upload button clicked');
    setIsUploadOpen(true);
  }, []);

  const handlePdfBulkClick = useCallback(() => {
    UILogger.info('LibraryHeader', 'PDF bulk button clicked');
    setIsPdfBulkOpen(true);
  }, []);

  const handleReviewModeToggle = useCallback(() => {
    UILogger.info('LibraryHeader', 'Review mode toggled', { newMode: !isReviewMode });
    
    // Wenn Review-Modus aktiviert wird, Cache leeren
    if (!isReviewMode && onClearCache) {
      UILogger.info('LibraryHeader', 'Clearing cache before entering review mode');
      onClearCache();
    }
    
    setIsReviewMode(!isReviewMode);
  }, [isReviewMode, setIsReviewMode, onClearCache]);



  return (
    <div className="border-b bg-background flex-shrink-0">
      {error && (
        <Alert variant="destructive" className="m-2">
          <AlertTriangle className="h-4 w-4" />
          <AlertDescription>{error}</AlertDescription>
        </Alert>
      )}
      <div className="flex items-center px-4 py-2 gap-3">
        {/* Pfad / Breadcrumb: Desktop voll, mobil kompakt */}
        <div className="min-w-0 flex-1">
          <div className="hidden sm:block">
            {children || <Breadcrumb />}
          </div>
          <div className="block sm:hidden text-xs text-muted-foreground truncate" title={compactPathName}>
            <div className="flex items-center gap-2">
              {parentId && (
                <Button
                  variant="ghost"
                  size="icon"
                  aria-label="Zurück"
                  title="Zurück"
                  onClick={() => navigateToFolder(parentId)}
                >
                  <ArrowLeft className="h-4 w-4" />
                </Button>
              )}
              <span className="truncate">{compactPathName}</span>
            </div>
          </div>
        </div>

        {/* Actions rechtsbündig, Icons only */}
        <div className="ml-auto flex items-center gap-1">
          {typeof isTreeVisible === 'boolean' && onToggleTree && (
            <Button
              variant="ghost"
              size="icon"
              onClick={onToggleTree}
              title={isTreeVisible ? 'Tree ausblenden' : 'Tree einblenden'}
              aria-label={isTreeVisible ? 'Tree ausblenden' : 'Tree einblenden'}
            >
              <Sidebar className="h-4 w-4" />
            </Button>
          )}

          {typeof isListVisible === 'boolean' && onToggleList && (
            <Button
              variant="ghost"
              size="icon"
              onClick={onToggleList}
              title={isListVisible ? 'Liste ausblenden' : 'Liste einblenden'}
              aria-label={isListVisible ? 'Liste ausblenden' : 'Liste einblenden'}
            >
              <LayoutList className="h-4 w-4" />
            </Button>
          )}

          <Button
            variant="ghost"
            size="icon"
            onClick={handleReviewModeToggle}
            title={isReviewMode ? 'Zur Liste' : 'Vergleichen'}
            aria-label={isReviewMode ? 'Zur Liste' : 'Vergleichen'}
          >
            {isReviewMode ? (
              <ArrowLeft className="h-4 w-4" />
            ) : (
              <Eye className="h-4 w-4" />
            )}
          </Button>

          <Button
            variant="ghost"
            size="icon"
            onClick={handleUploadClick}
            title="Datei hochladen"
            aria-label="Datei hochladen"
          >
            <Upload className="h-4 w-4" />
          </Button>

          <Button
            variant="secondary"
            size="icon"
            onClick={handlePdfBulkClick}
            title="PDF-Verzeichnis verarbeiten"
            aria-label="PDF-Verzeichnis verarbeiten"
          >
            <FileStack className="h-4 w-4" />
          </Button>

          {/* Aufnahme als Icon-Button (mobil/desktop sichtbar) */}
          <AudioRecorderClient 
            onUploadComplete={handleUploadComplete}
          />
        </div>
      </div>

      <UploadDialog
        open={isUploadOpen}
        onOpenChange={(open) => {
          UILogger.info('LibraryHeader', 'Upload dialog state change', { open });
          setIsUploadOpen(open);
        }}
        provider={provider}
        currentFolderId={currentFolderId}
        onSuccess={handleUploadComplete}
      />

      <PdfBulkImportDialog
        open={isPdfBulkOpen}
        onOpenChange={(open) => {
          UILogger.info('LibraryHeader', 'PDF bulk dialog state change', { open });
          setIsPdfBulkOpen(open);
        }}
      />
    </div>
  )
}
```

```typescriptreact
"use client"

import * as React from "react"
import { useCallback, useEffect } from "react"
import { useAtom, useAtomValue } from "jotai"

import { LibraryHeader } from "./library-header"
import { FileTree } from "./file-tree"
import { FileList } from "./file-list"
import dynamic from 'next/dynamic'
const FilePreviewLazy = dynamic(() => import('./file-preview').then(m => m.FilePreview), {
  ssr: false,
  loading: () => (
    <div className="h-full flex items-center justify-center text-muted-foreground">
      Lade Vorschau...
    </div>
  )
})
import { ResizableHandle, ResizablePanel, ResizablePanelGroup } from "@/components/ui/resizable"
import { 
  libraryAtom, 
  folderItemsAtom,
  loadingStateAtom,
  lastLoadedFolderAtom,
  currentFolderIdAtom,
  reviewModeAtom,
  selectedFileAtom,
  selectedShadowTwinAtom
} from "@/atoms/library-atom"
import { activeLibraryIdAtom } from "@/atoms/library-atom"
import { useStorage, isStorageError } from "@/contexts/storage-context"
import { TranscriptionDialog } from "./transcription-dialog"
import { TransformationDialog } from "./transformation-dialog"
import { StorageItem } from "@/lib/storage/types"
import { NavigationLogger, StateLogger, UILogger } from "@/lib/debug/logger"
import { Breadcrumb } from "./breadcrumb"
import { useToast } from "@/components/ui/use-toast"
import { ChevronLeft, ChevronRight } from "lucide-react"
import { useSearchParams } from "next/navigation"
import { useFolderNavigation } from "@/hooks/use-folder-navigation"
export function Library() {
  // Performance-Messung für Kaltstart (nur Client)
  const startupT0Ref = React.useRef<number>(
    typeof performance !== 'undefined' ? performance.now() : 0
  );
  // Globale Atoms
  const [, setFolderItems] = useAtom(folderItemsAtom);
  const [, setLoadingState] = useAtom(loadingStateAtom);
  const [lastLoadedFolder, setLastLoadedFolder] = useAtom(lastLoadedFolderAtom);
  const [currentFolderId] = useAtom(currentFolderIdAtom);
  const [libraryState, setLibraryState] = useAtom(libraryAtom);
  const activeLibraryId = useAtomValue(activeLibraryIdAtom);
  
  // Review-Mode Atoms
  const [isReviewMode] = useAtom(reviewModeAtom);
  const [selectedFile, setSelectedFile] = useAtom(selectedFileAtom);
  const [selectedShadowTwin, setSelectedShadowTwin] = useAtom(selectedShadowTwinAtom);
  
  // Storage Context
  const { 
    provider: providerInstance, 
    error: storageError, 
    listItems,
    libraryStatus,
    currentLibrary
  } = useStorage();
  const { toast } = useToast();
  const [isTreeVisible, setIsTreeVisible] = React.useState<boolean>(false);
  const [isListVisible, setIsListVisible] = React.useState<boolean>(true);
  const [isMobile, setIsMobile] = React.useState<boolean>(false);
  const [mobileView, setMobileView] = React.useState<'list' | 'preview'>('list');
  const loadInFlightRef = React.useRef<boolean>(false);
  const searchParams = useSearchParams();
  const navigateToFolder = useFolderNavigation();

  // Mobile: Tree standardmäßig ausblenden, Desktop: anzeigen
  React.useEffect(() => {
    if (typeof window === 'undefined') return;
    // Desktop ab 1024px, Mobile darunter
    const mq = window.matchMedia('(max-width: 1023px)');
    const apply = (matches: boolean) => {
      setIsMobile(matches);
      setIsTreeVisible(!matches);
    };
    apply(mq.matches);
    const handler = (e: MediaQueryListEvent) => apply(e.matches);
    mq.addEventListener('change', handler);
    return () => mq.removeEventListener('change', handler);
  }, []);

  // URL -> State: folderId aus Query anwenden, wenn Provider bereit ist
  const urlInitAppliedRef = React.useRef(false);
  React.useEffect(() => {
    const folderIdFromUrl = searchParams?.get('folderId');

    if (urlInitAppliedRef.current) return;

    if (!folderIdFromUrl) {
      NavigationLogger.debug('debug@init', 'No folderId in URL', {
        currentFolderId
      });
      urlInitAppliedRef.current = true;
      return;
    }

    if (!providerInstance || libraryStatus !== 'ready') {
      NavigationLogger.debug('debug@init', 'Provider not ready, deferring URL apply', {
        folderIdFromUrl,
        libraryStatus,
        hasProvider: !!providerInstance
      });
      return;
    }

    if (folderIdFromUrl !== currentFolderId) {
      NavigationLogger.info('debug@init', 'Applying folderId from URL (ready)', {
        folderIdFromUrl,
        currentFolderId
      });
      void navigateToFolder(folderIdFromUrl);
    }
    urlInitAppliedRef.current = true;
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [searchParams, providerInstance, libraryStatus, currentFolderId]);

  // Mobile-View Wechsellogik: bei Dateiauswahl zur Vorschau wechseln
  React.useEffect(() => {
    if (!isMobile) return;
    if (selectedFile) setMobileView('preview');
  }, [isMobile, selectedFile]);

  // Optimierter loadItems mit Cache-Check
  const loadItems = useCallback(async () => {
    if (loadInFlightRef.current) {
      NavigationLogger.debug('Library', 'Skip loadItems - load already in flight');
      return;
    }
    if (!providerInstance || libraryStatus !== 'ready') {
      NavigationLogger.debug('Library', 'Skipping loadItems - not ready', {
        hasProvider: !!providerInstance,
        status: libraryStatus
      });
      return;
    }

    // Schutz: Wenn Provider/Context noch auf alte Library zeigt, keine Items übernehmen
    if (currentLibrary?.id && currentLibrary.id !== activeLibraryId) {
      NavigationLogger.debug('Library', 'Skip loadItems - library mismatch', {
        providerLibraryId: currentLibrary.id,
        activeLibraryId
      });
      return;
    }

    loadInFlightRef.current = true;
    setLoadingState({ isLoading: true, loadingFolderId: currentFolderId });

    try {
      // Snapshot zur Vermeidung von Race-Conditions
      const expectedLibraryId = activeLibraryId;
      const expectedFolderId = currentFolderId;

      // Prüfe Cache zuerst
      if (libraryState.folderCache?.[currentFolderId]?.children) {
        const cachedItems = libraryState.folderCache[currentFolderId].children;
        NavigationLogger.info('Library', 'Using cached items', {
          folderId: currentFolderId,
          itemCount: cachedItems.length,
          cacheHit: true
        });
        // Übernehme nur, wenn der Snapshot noch aktuell ist
        if (expectedLibraryId === activeLibraryId && expectedFolderId === currentFolderId) {
          setFolderItems(cachedItems);
          setLastLoadedFolder(currentFolderId);
        }
        return;
      }

      NavigationLogger.info('Library', 'Fetching items from provider', {
        folderId: currentFolderId,
        cacheHit: false
      });
      
      const items = await listItems(currentFolderId);

      // Falls während des Ladens die Library oder der Ordner wechselte: Ergebnis verwerfen
      if (expectedLibraryId !== activeLibraryId || expectedFolderId !== currentFolderId) {
        NavigationLogger.debug('Library', 'Discard loaded items due to context change', {
          expectedLibraryId,
          activeLibraryId,
          expectedFolderId,
          currentFolderId
        });
        return;
      }
      
      // Update Cache und State
      if (currentFolderId !== 'root') {
        const newFolderCache = { ...libraryState.folderCache };
        const parent = newFolderCache[currentFolderId];
        if (parent) {
          newFolderCache[currentFolderId] = {
            ...parent,
            children: items
          };
          StateLogger.info('Library', 'Updating folder cache', {
            folderId: currentFolderId,
            itemCount: items.length,
            cacheSize: Object.keys(newFolderCache).length
          });
          setLibraryState(state => ({
            ...state,
            folderCache: newFolderCache
          }));
        }
      }
      
      setFolderItems(items);
      setLastLoadedFolder(currentFolderId);
      
      StateLogger.info('Library', 'Items loaded successfully', {
        folderId: currentFolderId,
        itemCount: items.length,
        fileCount: items.filter(i => i.type === 'file').length,
        folderCount: items.filter(i => i.type === 'folder').length,
        tSinceMountMs: startupT0Ref.current ? Number((performance.now() - startupT0Ref.current).toFixed(1)) : undefined
      });
      
    } catch (error) {
      if (isStorageError(error) && error.code === 'AUTH_REQUIRED') {
        StateLogger.info('Library', 'Auth required');
        // Keine Fehlermeldung für AUTH_REQUIRED anzeigen
      } else {
        StateLogger.error('Library', 'Failed to load items', {
          error: error instanceof Error ? {
            message: error.message,
            name: error.name,
            stack: error.stack?.split('\n').slice(0, 3)
          } : error,
          folderId: currentFolderId,
          libraryId: currentLibrary?.id,
          libraryPath: currentLibrary?.path
        });
        
        // Benutzerfreundliche Fehlermeldung anzeigen
        let errorMessage = 'Fehler beim Laden der Dateien';
        
        if (error instanceof Error) {
          if (error.message.includes('Nicht authentifiziert')) {
            errorMessage = 'Bitte authentifizieren Sie sich bei Ihrem Cloud-Speicher.';
          } else if (error.message.includes('Bibliothek nicht gefunden')) {
            errorMessage = 'Die ausgewählte Bibliothek wurde nicht gefunden. Bitte überprüfen Sie die Bibliothekskonfiguration.';
          } else if (error.message.includes('Server-Fehler')) {
            errorMessage = 'Server-Fehler beim Laden der Dateien. Bitte überprüfen Sie, ob der Bibliothekspfad existiert und zugänglich ist.';
          } else if (error.message.includes('Keine aktive Bibliothek')) {
            errorMessage = 'Keine aktive Bibliothek verfügbar. Bitte wählen Sie eine Bibliothek aus.';
          } else {
            errorMessage = error.message;
          }
        }
        
        // Toast-Nachricht anzeigen
        toast({
          title: "Fehler beim Laden der Dateien",
          description: errorMessage,
          variant: "destructive",
        });
      }
      setFolderItems([]);
    } finally {
      setLoadingState({ isLoading: false, loadingFolderId: null });
      loadInFlightRef.current = false;
    }
  }, [
    currentFolderId,
    lastLoadedFolder,
    listItems,
    libraryState.folderCache,
    providerInstance,
    libraryStatus,
    setLibraryState,
    setFolderItems,
    setLastLoadedFolder,
    setLoadingState,
    toast,
    currentLibrary
  ]);

  // Effect für Initial-Load (entkoppelt vom FileTree)
  useEffect(() => {
    const isReady = !!providerInstance && libraryStatus === 'ready';
    
    if (!isReady) {
      NavigationLogger.debug('Library', 'Waiting for initialization', {
        hasProvider: !!providerInstance,
        status: libraryStatus
      });
      return;
    }

    // Wenn eine folderId in der URL steht und noch nicht angewendet wurde,
    // verhindere das initiale Laden von "root" (vermeidet Doppel-Load)
    const folderIdFromUrl = searchParams?.get('folderId');
    if (!urlInitAppliedRef.current && folderIdFromUrl && folderIdFromUrl !== currentFolderId) {
      NavigationLogger.debug('debug@init', 'Skip initial root load; URL folderId pending', {
        folderIdFromUrl,
        currentFolderId,
        lastLoadedFolder
      });
      return;
    }

    // Nur laden wenn noch nicht geladen
    if (lastLoadedFolder !== currentFolderId && !loadInFlightRef.current) {
      UILogger.info('Library', 'Initial load triggered', {
        currentFolderId,
        lastLoadedFolder,
        tSinceMountMs: startupT0Ref.current ? Number((performance.now() - startupT0Ref.current).toFixed(1)) : undefined
      });
      NavigationLogger.info('Library', 'Loading initial items', {
        folderId: currentFolderId
      });
      loadItems();
    }
  }, [providerInstance, libraryStatus, currentFolderId, lastLoadedFolder, activeLibraryId, loadItems, searchParams]);

  // Zusätzlicher Reset bei Bibliothekswechsel (robust gegen Status-Race)
  useEffect(() => {
    if (!activeLibraryId) return;
    StateLogger.info('Library', 'Active library changed - reset initial load state', {
      activeLibraryId,
      currentFolderId
    });
    setLastLoadedFolder(null);
    setFolderItems([]);
    setLibraryState(state => ({ ...state, folderCache: {} }));
    // WICHTIG: Ordnerauswahl und Shadow-Twin zurücksetzen
    setSelectedFile(null);
    setSelectedShadowTwin(null);
  }, [activeLibraryId, setLastLoadedFolder, setFolderItems, setLibraryState, currentFolderId]);

  // Reset Cache wenn sich die Library ändert
  useEffect(() => {
    setLastLoadedFolder(null);
    setLibraryState(state => ({
      ...state,
      folderCache: {}
    }));
  }, [libraryStatus, setLibraryState, setLastLoadedFolder]);

  // Manuelle Cache-Clear-Funktion für Review-Modus
  const clearCache = useCallback(() => {
    StateLogger.info('Library', 'Manually clearing cache for review mode');
    setLastLoadedFolder(null);
    setLibraryState(state => ({
      ...state,
      folderCache: {}
    }));
    setFolderItems([]);
  }, [setLibraryState, setLastLoadedFolder, setFolderItems]);

  // Reset selectedShadowTwin wenn Review-Modus verlassen wird
  useEffect(() => {
    if (!isReviewMode) {
      setSelectedShadowTwin(null);
    }
  }, [isReviewMode, setSelectedShadowTwin]);

  // ENTFERNT: Der folgende useEffect war problematisch und hat das Shadow-Twin 
  // bei jedem Klick zurückgesetzt, auch wenn die Datei ein Shadow-Twin hat.
  // Die Shadow-Twin-Logik wird bereits korrekt in der FileList-Komponente 
  // in der handleSelect-Funktion behandelt.

  // Render-Logik für verschiedene Status
  if (libraryStatus === "waitingForAuth") {
    return (
      <div className="flex flex-col items-center justify-center h-full text-muted-foreground">
        <span>Diese Bibliothek benötigt eine Authentifizierung.</span>
        <span className="text-sm mt-2">Bitte konfigurieren Sie die Bibliothek in den Einstellungen.</span>
      </div>
    );
  }
  
  if (libraryStatus !== "ready") {
    return (
      <div className="flex flex-col items-center justify-center h-full text-muted-foreground">
        <span>Lade Storage...</span>
      </div>
    );
  }

  return (
    <div className="flex flex-col h-full">
      <LibraryHeader
        provider={providerInstance}
        error={storageError}
        onUploadComplete={loadItems}
        onClearCache={clearCache}
        isTreeVisible={isTreeVisible}
        onToggleTree={() => setIsTreeVisible(v => !v)}
        isListVisible={isListVisible}
        onToggleList={() => setIsListVisible(v => !v)}
      >
        <Breadcrumb />
      </LibraryHeader>
      
      <div className="flex-1 min-h-0 overflow-hidden">
        {isReviewMode ? (
          // Review-Layout: 3 Panels ohne FileTree - FileList (compact) | FilePreview (Basis-Datei) | FilePreview (Shadow-Twin)
          <ResizablePanelGroup direction="horizontal" className="h-full">
            <ResizablePanel defaultSize={25} minSize={20} className="min-h-0">
              <div className="h-full overflow-auto flex flex-col">
                <FileList compact={true} />
              </div>
            </ResizablePanel>
            <ResizableHandle />
            <ResizablePanel defaultSize={37.5} minSize={30} className="min-h-0">
              <div className="h-full relative flex flex-col">
                {selectedFile ? (
                  <FilePreviewLazy
                    provider={providerInstance}
                    file={selectedFile}
                    onRefreshFolder={(folderId, items, selectFileAfterRefresh) => {
                    StateLogger.info('Library', 'FilePreview (Basis) onRefreshFolder aufgerufen', {
                      folderId,
                      itemsCount: items.length,
                      hasSelectFile: !!selectFileAfterRefresh
                    });
                    
                    // Aktualisiere die Dateiliste
                    setFolderItems(items);
                    
                    // Aktualisiere den Cache
                    if (libraryState.folderCache?.[folderId]) {
                      const cachedFolder = libraryState.folderCache[folderId];
                      if (cachedFolder) {
                        setLibraryState(state => ({
                          ...state,
                          folderCache: {
                            ...(state.folderCache || {}),
                            [folderId]: {
                              ...cachedFolder,
                              children: items
                            }
                          }
                        }));
                      }
                    }
                    
                    // Wenn eine Datei ausgewählt werden soll (nach dem Speichern)
                    if (selectFileAfterRefresh) {
                      StateLogger.info('Library', 'Wähle gespeicherte Datei aus', {
                        fileId: selectFileAfterRefresh.id,
                        fileName: selectFileAfterRefresh.metadata.name
                      });
                    }
                    }}
                  />
                ) : (
                  <div className="h-full flex items-center justify-center text-muted-foreground">
                    <p>Keine Datei ausgewählt</p>
                  </div>
                )}
              </div>
            </ResizablePanel>
            <ResizableHandle />
            <ResizablePanel defaultSize={37.5} minSize={30} className="min-h-0">
              <div className="h-full relative flex flex-col">
                {selectedShadowTwin ? (
                  <FilePreviewLazy
                    provider={providerInstance}
                    file={selectedShadowTwin}
                    onRefreshFolder={(folderId, items, selectFileAfterRefresh) => {
                      StateLogger.info('Library', 'FilePreview (Shadow-Twin) onRefreshFolder aufgerufen', {
                        folderId,
                        itemsCount: items.length,
                        hasSelectFile: !!selectFileAfterRefresh
                      });
                      
                      // Aktualisiere die Dateiliste
                      setFolderItems(items);
                      
                      // Aktualisiere den Cache
                      if (libraryState.folderCache?.[folderId]) {
                        const cachedFolder = libraryState.folderCache[folderId];
                        if (cachedFolder) {
                          setLibraryState(state => ({
                            ...state,
                            folderCache: {
                              ...(state.folderCache || {}),
                              [folderId]: {
                                ...cachedFolder,
                                children: items
                              }
                            }
                          }));
                        }
                      }
                      
                      // Wenn eine Datei ausgewählt werden soll (nach dem Speichern)
                      if (selectFileAfterRefresh) {
                        StateLogger.info('Library', 'Wähle gespeicherte Datei aus', {
                          fileId: selectFileAfterRefresh.id,
                          fileName: selectFileAfterRefresh.metadata.name
                        });
                      }
                    }}
                  />
                ) : (
                  <div className="h-full flex items-center justify-center text-muted-foreground">
                    <p>Kein Shadow-Twin ausgewählt</p>
                  </div>
                )}
              </div>
            </ResizablePanel>
          </ResizablePanelGroup>
        ) : (
          // Normal-Layout (Desktop) oder alternierendes Mobile-Layout
          <div className="relative h-full">
            {/* Entfernt: alter Tree-Handle (ersetzt durch Header-Toggle) */}

            {isMobile ? (
              mobileView === 'list' ? (
                <div className="h-full overflow-auto flex flex-col">
                  <FileList />
                </div>
              ) : (
                <div className="h-full flex flex-col">
                  <div className="flex items-center gap-2 p-2 border-b bg-background">
                    <button
                      type="button"
                      className="inline-flex items-center gap-1 text-sm px-2 py-1 border rounded-md"
                      onClick={() => {
                        setMobileView('list');
                        setSelectedShadowTwin(null);
                        setSelectedFile(null);
                        loadItems();
                      }}
                    >
                      <ChevronLeft className="h-4 w-4" />
                      Zurück
                    </button>
                    <div className="text-sm text-muted-foreground truncate">
                      {selectedFile?.metadata.name}
                    </div>
                  </div>
                  <div className="flex-1 min-h-0">
                    {selectedFile ? (
                      <FilePreviewLazy
                        provider={providerInstance}
                        onRefreshFolder={(folderId, items, selectFileAfterRefresh) => {
                        StateLogger.info('Library', 'FilePreview onRefreshFolder aufgerufen', {
                          folderId,
                          itemsCount: items.length,
                          hasSelectFile: !!selectFileAfterRefresh
                        });
                        setFolderItems(items);
                        if (libraryState.folderCache?.[folderId]) {
                          const cachedFolder = libraryState.folderCache[folderId];
                          if (cachedFolder) {
                            setLibraryState(state => ({
                              ...state,
                              folderCache: {
                                ...(state.folderCache || {}),
                                [folderId]: { ...cachedFolder, children: items }
                              }
                            }));
                          }
                        }
                        }}
                      />
                    ) : (
                      <div className="h-full flex items-center justify-center text-muted-foreground">
                        <p>Keine Datei ausgewählt</p>
                      </div>
                    )}
                  </div>
                </div>
              )
            ) : (
              <ResizablePanelGroup
                key={isTreeVisible ? 'with-tree' : 'no-tree'}
                direction="horizontal"
                className="h-full"
                autoSaveId={isTreeVisible ? "library-panels-3" : "library-panels-2"}
              >
                {isTreeVisible && (
                  <>
                    <ResizablePanel key="tree-panel" id="tree" defaultSize={20} minSize={15} className="min-h-0">
                      <div className="h-full overflow-auto flex flex-col">
                        <FileTree />
                      </div>
                    </ResizablePanel>
                    <ResizableHandle key="tree-handle" />
                  </>
                )}
                {isListVisible && (
                  <>
                    <ResizablePanel key="list-panel" id="list" defaultSize={isTreeVisible ? 40 : 50} className="min-h-0">
                      <div className="h-full overflow-auto flex flex-col">
                        <FileList />
                      </div>
                    </ResizablePanel>
                    <ResizableHandle key="list-preview-handle" />
                  </>
                )}
                <ResizablePanel key="preview-panel" id="preview" defaultSize={isTreeVisible ? 40 : 50} className="min-h-0">
                  <div className="h-full relative flex flex-col">
                    {selectedFile ? (
                      <FilePreviewLazy
                        provider={providerInstance}
                        onRefreshFolder={(folderId, items, selectFileAfterRefresh) => {
                        StateLogger.info('Library', 'FilePreview onRefreshFolder aufgerufen', {
                          folderId,
                          itemsCount: items.length,
                          hasSelectFile: !!selectFileAfterRefresh
                        });
                        
                        // Aktualisiere die Dateiliste
                        setFolderItems(items);
                        
                        // Aktualisiere den Cache
                        if (libraryState.folderCache?.[folderId]) {
                          const cachedFolder = libraryState.folderCache[folderId];
                          if (cachedFolder) {
                            setLibraryState(state => ({
                              ...state,
                              folderCache: {
                                ...(state.folderCache || {}),
                                [folderId]: {
                                  ...cachedFolder,
                                  children: items
                                }
                              }
                            }));
                          }
                        }
                        
                        if (selectFileAfterRefresh) {
                          StateLogger.info('Library', 'Wähle gespeicherte Datei aus', {
                            fileId: selectFileAfterRefresh.id,
                            fileName: selectFileAfterRefresh.metadata.name
                          });
                        }
                        }}
                      />
                    ) : (
                      <div className="h-full flex items-center justify-center text-muted-foreground">
                        <p>Keine Datei ausgewählt</p>
                      </div>
                    )}
                  </div>
                </ResizablePanel>
              </ResizablePanelGroup>
            )}
          </div>
        )}
      </div>
      
      {/* Dialoge */}
      <TranscriptionDialog />
      <TransformationDialog 
        onRefreshFolder={(folderId: string, items: StorageItem[], selectFileAfterRefresh?: StorageItem) => {
          StateLogger.info('Library', 'TransformationDialog onRefreshFolder aufgerufen', {
            folderId,
            itemsCount: items.length,
            hasSelectFile: !!selectFileAfterRefresh
          });
          
          // Aktualisiere die Dateiliste
          setFolderItems(items);
          
          // Aktualisiere den Cache
          if (libraryState.folderCache?.[folderId]) {
            const cachedFolder = libraryState.folderCache[folderId];
            if (cachedFolder) {
              setLibraryState(state => ({
                ...state,
                folderCache: {
                  ...(state.folderCache || {}),
                  [folderId]: {
                    ...cachedFolder,
                    children: items
                  }
                }
              }));
            }
          }
          
          // Wenn eine Datei ausgewählt werden soll (nach dem Speichern)
          if (selectFileAfterRefresh) {
            StateLogger.info('Library', 'Wähle gespeicherte Datei aus', {
              fileId: selectFileAfterRefresh.id,
              fileName: selectFileAfterRefresh.metadata.name
            });
          }
        }}
      />
    </div>
  );
}
```

Ich habe Toolbar‑Toggles für beide Navigationspaneele eingebaut:

- Toolbar rechts oben:
  - Sidebar-Icon: FileTree ein/aus.
  - Listen-Icon: FileList ein/aus.
- Der alte schwebende Tree‑Handle links (Chevron‑Button) ist entfernt.
- Layout reagiert dynamisch:
  - Wenn Tree/Liste aus ist, werden die Resizable‑Panels entsprechend weggelassen.
  - Bei ausgeblendeter Liste bleibt die Vorschau breit.
- Keine Linterfehler.

Bitte testen:
- Klicke in der Toolbar auf Sidebar → Tree aus/ein.
- Klicke auf Listen‑Icon → FileList aus/ein.
- Beide aus: maximale Breite für die Vorschau mit PDF/Analyzer.

---

**User**

Ok, die File-Liste ein- und ausblenden macht vielleicht wenig Sinn, weil man komplett die Navigation verliert, die Orientierung. Aber vielleicht gibt es da so eine Möglichkeit, dass man es umschaltet von dieser Tabellenansicht in eine sehr kompakte Ansicht, wo man nur praktisch navigiert. Man hat praktisch nur den Text ohne Feature. Man kann dann praktisch nur noch sehr schmal damit arbeiten. Das wäre dann eine kompakte Ansicht. Und oben in der Toolbar switcht man zwischen Listen-Ansicht wie jetzt und Kompakte Ansicht. Aber um jetzt nicht die ganze Komponente doppelt zu programmieren, sollten eigentlich nur bestimmte Spalten aus- und eingeblendet werden. Also mit einer Kompaktansicht gibt es dann keine Checkbox-Spalte, keine Icon-Spalte, es bleibt nur der Name. Und fertig, auch keine Symbole dahinter und Features und Funktionen. Es bleibt nur noch oben diese File-List-Toolbar mit dem Filter und Aktualisierungsbutton, aber sonst mittlerweile wird kompakt dargestellt, mit minimalem Aufwand.

---

**Cursor**

```typescriptreact
import * as React from "react"
import { UILogger } from "@/lib/debug/logger"
import { Button } from "@/components/ui/button"
import { Upload, AlertTriangle, ArrowLeft, Eye, FileStack, Sidebar, LayoutList } from "lucide-react"
import { UploadDialog } from "./upload-dialog"
import { StorageProvider } from "@/lib/storage/types"
import { useCallback } from "react"
import { Alert, AlertDescription } from "@/components/ui/alert"
import { useAtom, useAtomValue } from "jotai"
import { currentFolderIdAtom, reviewModeAtom, libraryAtom } from "@/atoms/library-atom"
import { Breadcrumb } from "./breadcrumb"
import { AudioRecorderClient } from "./audio-recorder-client"
import PdfBulkImportDialog from "./pdf-bulk-import-dialog"
import { useFolderNavigation } from "@/hooks/use-folder-navigation"

interface LibraryHeaderProps {
  provider: StorageProvider | null
  onUploadComplete?: () => void
  error?: string | null
  children?: React.ReactNode
  onClearCache?: () => void // Cache-Invalidierung
  isTreeVisible?: boolean
  onToggleTree?: () => void
  isListVisible?: boolean
  onToggleList?: () => void
  isCompactList?: boolean
  onToggleCompactList?: () => void
}

export function LibraryHeader({
  provider,
  onUploadComplete,
  error,
  children,
  onClearCache,
  isTreeVisible,
  onToggleTree,
  isListVisible,
  onToggleList,
  isCompactList,
  onToggleCompactList
}: LibraryHeaderProps) {
  const [isUploadOpen, setIsUploadOpen] = React.useState(false)
  const [isPdfBulkOpen, setIsPdfBulkOpen] = React.useState(false)
  const [currentFolderId] = useAtom(currentFolderIdAtom);
  const [isReviewMode, setIsReviewMode] = useAtom(reviewModeAtom);
  const libraryState = useAtomValue(libraryAtom);
  const navigateToFolder = useFolderNavigation();

  // Aktueller Library-Name (für Root-Ebene)
  const currentLibraryName = React.useMemo(() => {
    const libId = libraryState.activeLibraryId;
    return libraryState.libraries.find(l => l.id === libId)?.label || 'Library';
  }, [libraryState.activeLibraryId, libraryState.libraries]);

  // Kompakter Pfadname (nur aktueller/übergeordneter Ordner), mobil mit Ellipsis
  const compactPathName = React.useMemo(() => {
    if (currentFolderId === 'root') return currentLibraryName;
    const folder = libraryState.folderCache?.[currentFolderId];
    return folder?.metadata?.name ?? '';
  }, [libraryState.folderCache, currentFolderId, currentLibraryName]);

  const parentId = React.useMemo(() => {
    if (currentFolderId === 'root') return null;
    const folder = libraryState.folderCache?.[currentFolderId];
    const pid = folder?.parentId;
    if (pid && pid.length > 0) return pid;
    return 'root';
  }, [libraryState.folderCache, currentFolderId]);

  const handleUploadComplete = useCallback(() => {
    UILogger.info('LibraryHeader', 'Upload completed');
    onUploadComplete?.();
    setIsUploadOpen(false);
  }, [onUploadComplete]);

  const handleUploadClick = useCallback(() => {
    UILogger.info('LibraryHeader', 'Upload button clicked');
    setIsUploadOpen(true);
  }, []);

  const handlePdfBulkClick = useCallback(() => {
    UILogger.info('LibraryHeader', 'PDF bulk button clicked');
    setIsPdfBulkOpen(true);
  }, []);

  const handleReviewModeToggle = useCallback(() => {
    UILogger.info('LibraryHeader', 'Review mode toggled', { newMode: !isReviewMode });
    
    // Wenn Review-Modus aktiviert wird, Cache leeren
    if (!isReviewMode && onClearCache) {
      UILogger.info('LibraryHeader', 'Clearing cache before entering review mode');
      onClearCache();
    }
    
    setIsReviewMode(!isReviewMode);
  }, [isReviewMode, setIsReviewMode, onClearCache]);



  return (
    <div className="border-b bg-background flex-shrink-0">
      {error && (
        <Alert variant="destructive" className="m-2">
          <AlertTriangle className="h-4 w-4" />
          <AlertDescription>{error}</AlertDescription>
        </Alert>
      )}
      <div className="flex items-center px-4 py-2 gap-3">
        {/* Pfad / Breadcrumb: Desktop voll, mobil kompakt */}
        <div className="min-w-0 flex-1">
          <div className="hidden sm:block">
            {children || <Breadcrumb />}
          </div>
          <div className="block sm:hidden text-xs text-muted-foreground truncate" title={compactPathName}>
            <div className="flex items-center gap-2">
              {parentId && (
                <Button
                  variant="ghost"
                  size="icon"
                  aria-label="Zurück"
                  title="Zurück"
                  onClick={() => navigateToFolder(parentId)}
                >
                  <ArrowLeft className="h-4 w-4" />
                </Button>
              )}
              <span className="truncate">{compactPathName}</span>
            </div>
          </div>
        </div>

        {/* Actions rechtsbündig, Icons only */}
        <div className="ml-auto flex items-center gap-1">
          {typeof isTreeVisible === 'boolean' && onToggleTree && (
            <Button
              variant="ghost"
              size="icon"
              onClick={onToggleTree}
              title={isTreeVisible ? 'Tree ausblenden' : 'Tree einblenden'}
              aria-label={isTreeVisible ? 'Tree ausblenden' : 'Tree einblenden'}
            >
              <Sidebar className="h-4 w-4" />
            </Button>
          )}

          {typeof isListVisible === 'boolean' && onToggleList && (
            <Button
              variant="ghost"
              size="icon"
              onClick={onToggleList}
              title={isListVisible ? 'Liste ausblenden' : 'Liste einblenden'}
              aria-label={isListVisible ? 'Liste ausblenden' : 'Liste einblenden'}
            >
              <LayoutList className="h-4 w-4" />
            </Button>
          )}

          {typeof isCompactList === 'boolean' && onToggleCompactList && (
            <Button
              variant="ghost"
              size="icon"
              onClick={onToggleCompactList}
              title={isCompactList ? 'Listenansicht' : 'Kompaktansicht'}
              aria-label={isCompactList ? 'Listenansicht' : 'Kompaktansicht'}
            >
              {/* Gleiches Icon; Tooltip unterscheidet */}
              <LayoutList className="h-4 w-4" />
            </Button>
          )}

          <Button
            variant="ghost"
            size="icon"
            onClick={handleReviewModeToggle}
            title={isReviewMode ? 'Zur Liste' : 'Vergleichen'}
            aria-label={isReviewMode ? 'Zur Liste' : 'Vergleichen'}
          >
            {isReviewMode ? (
              <ArrowLeft className="h-4 w-4" />
            ) : (
              <Eye className="h-4 w-4" />
            )}
          </Button>

          <Button
            variant="ghost"
            size="icon"
            onClick={handleUploadClick}
            title="Datei hochladen"
            aria-label="Datei hochladen"
          >
            <Upload className="h-4 w-4" />
          </Button>

          <Button
            variant="secondary"
            size="icon"
            onClick={handlePdfBulkClick}
            title="PDF-Verzeichnis verarbeiten"
            aria-label="PDF-Verzeichnis verarbeiten"
          >
            <FileStack className="h-4 w-4" />
          </Button>

          {/* Aufnahme als Icon-Button (mobil/desktop sichtbar) */}
          <AudioRecorderClient 
            onUploadComplete={handleUploadComplete}
          />
        </div>
      </div>

      <UploadDialog
        open={isUploadOpen}
        onOpenChange={(open) => {
          UILogger.info('LibraryHeader', 'Upload dialog state change', { open });
          setIsUploadOpen(open);
        }}
        provider={provider}
        currentFolderId={currentFolderId}
        onSuccess={handleUploadComplete}
      />

      <PdfBulkImportDialog
        open={isPdfBulkOpen}
        onOpenChange={(open) => {
          UILogger.info('LibraryHeader', 'PDF bulk dialog state change', { open });
          setIsPdfBulkOpen(open);
        }}
      />
    </div>
  )
}
```

```typescriptreact
"use client"

import * as React from "react"
import { useCallback, useEffect } from "react"
import { useAtom, useAtomValue } from "jotai"

import { LibraryHeader } from "./library-header"
import { FileTree } from "./file-tree"
import { FileList } from "./file-list"
import dynamic from 'next/dynamic'
const FilePreviewLazy = dynamic(() => import('./file-preview').then(m => m.FilePreview), {
  ssr: false,
  loading: () => (
    <div className="h-full flex items-center justify-center text-muted-foreground">
      Lade Vorschau...
    </div>
  )
})
import { ResizableHandle, ResizablePanel, ResizablePanelGroup } from "@/components/ui/resizable"
import { 
  libraryAtom, 
  folderItemsAtom,
  loadingStateAtom,
  lastLoadedFolderAtom,
  currentFolderIdAtom,
  reviewModeAtom,
  selectedFileAtom,
  selectedShadowTwinAtom
} from "@/atoms/library-atom"
import { activeLibraryIdAtom } from "@/atoms/library-atom"
import { useStorage, isStorageError } from "@/contexts/storage-context"
import { TranscriptionDialog } from "./transcription-dialog"
import { TransformationDialog } from "./transformation-dialog"
import { StorageItem } from "@/lib/storage/types"
import { NavigationLogger, StateLogger, UILogger } from "@/lib/debug/logger"
import { Breadcrumb } from "./breadcrumb"
import { useToast } from "@/components/ui/use-toast"
import { ChevronLeft, ChevronRight } from "lucide-react"
import { useSearchParams } from "next/navigation"
import { useFolderNavigation } from "@/hooks/use-folder-navigation"
export function Library() {
  // Performance-Messung für Kaltstart (nur Client)
  const startupT0Ref = React.useRef<number>(
    typeof performance !== 'undefined' ? performance.now() : 0
  );
  // Globale Atoms
  const [, setFolderItems] = useAtom(folderItemsAtom);
  const [, setLoadingState] = useAtom(loadingStateAtom);
  const [lastLoadedFolder, setLastLoadedFolder] = useAtom(lastLoadedFolderAtom);
  const [currentFolderId] = useAtom(currentFolderIdAtom);
  const [libraryState, setLibraryState] = useAtom(libraryAtom);
  const activeLibraryId = useAtomValue(activeLibraryIdAtom);
  
  // Review-Mode Atoms
  const [isReviewMode] = useAtom(reviewModeAtom);
  const [selectedFile, setSelectedFile] = useAtom(selectedFileAtom);
  const [selectedShadowTwin, setSelectedShadowTwin] = useAtom(selectedShadowTwinAtom);
  
  // Storage Context
  const { 
    provider: providerInstance, 
    error: storageError, 
    listItems,
    libraryStatus,
    currentLibrary
  } = useStorage();
  const { toast } = useToast();
  const [isTreeVisible, setIsTreeVisible] = React.useState<boolean>(false);
  const [isListVisible, setIsListVisible] = React.useState<boolean>(true);
  const [isListCompact, setIsListCompact] = React.useState<boolean>(false);
  const [isMobile, setIsMobile] = React.useState<boolean>(false);
  const [mobileView, setMobileView] = React.useState<'list' | 'preview'>('list');
  const loadInFlightRef = React.useRef<boolean>(false);
  const searchParams = useSearchParams();
  const navigateToFolder = useFolderNavigation();

  // Mobile: Tree standardmäßig ausblenden, Desktop: anzeigen
  React.useEffect(() => {
    if (typeof window === 'undefined') return;
    // Desktop ab 1024px, Mobile darunter
    const mq = window.matchMedia('(max-width: 1023px)');
    const apply = (matches: boolean) => {
      setIsMobile(matches);
      setIsTreeVisible(!matches);
    };
    apply(mq.matches);
    const handler = (e: MediaQueryListEvent) => apply(e.matches);
    mq.addEventListener('change', handler);
    return () => mq.removeEventListener('change', handler);
  }, []);

  // URL -> State: folderId aus Query anwenden, wenn Provider bereit ist
  const urlInitAppliedRef = React.useRef(false);
  React.useEffect(() => {
    const folderIdFromUrl = searchParams?.get('folderId');

    if (urlInitAppliedRef.current) return;

    if (!folderIdFromUrl) {
      NavigationLogger.debug('debug@init', 'No folderId in URL', {
        currentFolderId
      });
      urlInitAppliedRef.current = true;
      return;
    }

    if (!providerInstance || libraryStatus !== 'ready') {
      NavigationLogger.debug('debug@init', 'Provider not ready, deferring URL apply', {
        folderIdFromUrl,
        libraryStatus,
        hasProvider: !!providerInstance
      });
      return;
    }

    if (folderIdFromUrl !== currentFolderId) {
      NavigationLogger.info('debug@init', 'Applying folderId from URL (ready)', {
        folderIdFromUrl,
        currentFolderId
      });
      void navigateToFolder(folderIdFromUrl);
    }
    urlInitAppliedRef.current = true;
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [searchParams, providerInstance, libraryStatus, currentFolderId]);

  // Mobile-View Wechsellogik: bei Dateiauswahl zur Vorschau wechseln
  React.useEffect(() => {
    if (!isMobile) return;
    if (selectedFile) setMobileView('preview');
  }, [isMobile, selectedFile]);

  // Optimierter loadItems mit Cache-Check
  const loadItems = useCallback(async () => {
    if (loadInFlightRef.current) {
      NavigationLogger.debug('Library', 'Skip loadItems - load already in flight');
      return;
    }
    if (!providerInstance || libraryStatus !== 'ready') {
      NavigationLogger.debug('Library', 'Skipping loadItems - not ready', {
        hasProvider: !!providerInstance,
        status: libraryStatus
      });
      return;
    }

    // Schutz: Wenn Provider/Context noch auf alte Library zeigt, keine Items übernehmen
    if (currentLibrary?.id && currentLibrary.id !== activeLibraryId) {
      NavigationLogger.debug('Library', 'Skip loadItems - library mismatch', {
        providerLibraryId: currentLibrary.id,
        activeLibraryId
      });
      return;
    }

    loadInFlightRef.current = true;
    setLoadingState({ isLoading: true, loadingFolderId: currentFolderId });

    try {
      // Snapshot zur Vermeidung von Race-Conditions
      const expectedLibraryId = activeLibraryId;
      const expectedFolderId = currentFolderId;

      // Prüfe Cache zuerst
      if (libraryState.folderCache?.[currentFolderId]?.children) {
        const cachedItems = libraryState.folderCache[currentFolderId].children;
        NavigationLogger.info('Library', 'Using cached items', {
          folderId: currentFolderId,
          itemCount: cachedItems.length,
          cacheHit: true
        });
        // Übernehme nur, wenn der Snapshot noch aktuell ist
        if (expectedLibraryId === activeLibraryId && expectedFolderId === currentFolderId) {
          setFolderItems(cachedItems);
          setLastLoadedFolder(currentFolderId);
        }
        return;
      }

      NavigationLogger.info('Library', 'Fetching items from provider', {
        folderId: currentFolderId,
        cacheHit: false
      });
      
      const items = await listItems(currentFolderId);

      // Falls während des Ladens die Library oder der Ordner wechselte: Ergebnis verwerfen
      if (expectedLibraryId !== activeLibraryId || expectedFolderId !== currentFolderId) {
        NavigationLogger.debug('Library', 'Discard loaded items due to context change', {
          expectedLibraryId,
          activeLibraryId,
          expectedFolderId,
          currentFolderId
        });
        return;
      }
      
      // Update Cache und State
      if (currentFolderId !== 'root') {
        const newFolderCache = { ...libraryState.folderCache };
        const parent = newFolderCache[currentFolderId];
        if (parent) {
          newFolderCache[currentFolderId] = {
            ...parent,
            children: items
          };
          StateLogger.info('Library', 'Updating folder cache', {
            folderId: currentFolderId,
            itemCount: items.length,
            cacheSize: Object.keys(newFolderCache).length
          });
          setLibraryState(state => ({
            ...state,
            folderCache: newFolderCache
          }));
        }
      }
      
      setFolderItems(items);
      setLastLoadedFolder(currentFolderId);
      
      StateLogger.info('Library', 'Items loaded successfully', {
        folderId: currentFolderId,
        itemCount: items.length,
        fileCount: items.filter(i => i.type === 'file').length,
        folderCount: items.filter(i => i.type === 'folder').length,
        tSinceMountMs: startupT0Ref.current ? Number((performance.now() - startupT0Ref.current).toFixed(1)) : undefined
      });
      
    } catch (error) {
      if (isStorageError(error) && error.code === 'AUTH_REQUIRED') {
        StateLogger.info('Library', 'Auth required');
        // Keine Fehlermeldung für AUTH_REQUIRED anzeigen
      } else {
        StateLogger.error('Library', 'Failed to load items', {
          error: error instanceof Error ? {
            message: error.message,
            name: error.name,
            stack: error.stack?.split('\n').slice(0, 3)
          } : error,
          folderId: currentFolderId,
          libraryId: currentLibrary?.id,
          libraryPath: currentLibrary?.path
        });
        
        // Benutzerfreundliche Fehlermeldung anzeigen
        let errorMessage = 'Fehler beim Laden der Dateien';
        
        if (error instanceof Error) {
          if (error.message.includes('Nicht authentifiziert')) {
            errorMessage = 'Bitte authentifizieren Sie sich bei Ihrem Cloud-Speicher.';
          } else if (error.message.includes('Bibliothek nicht gefunden')) {
            errorMessage = 'Die ausgewählte Bibliothek wurde nicht gefunden. Bitte überprüfen Sie die Bibliothekskonfiguration.';
          } else if (error.message.includes('Server-Fehler')) {
            errorMessage = 'Server-Fehler beim Laden der Dateien. Bitte überprüfen Sie, ob der Bibliothekspfad existiert und zugänglich ist.';
          } else if (error.message.includes('Keine aktive Bibliothek')) {
            errorMessage = 'Keine aktive Bibliothek verfügbar. Bitte wählen Sie eine Bibliothek aus.';
          } else {
            errorMessage = error.message;
          }
        }
        
        // Toast-Nachricht anzeigen
        toast({
          title: "Fehler beim Laden der Dateien",
          description: errorMessage,
          variant: "destructive",
        });
      }
      setFolderItems([]);
    } finally {
      setLoadingState({ isLoading: false, loadingFolderId: null });
      loadInFlightRef.current = false;
    }
  }, [
    currentFolderId,
    lastLoadedFolder,
    listItems,
    libraryState.folderCache,
    providerInstance,
    libraryStatus,
    setLibraryState,
    setFolderItems,
    setLastLoadedFolder,
    setLoadingState,
    toast,
    currentLibrary
  ]);

  // Effect für Initial-Load (entkoppelt vom FileTree)
  useEffect(() => {
    const isReady = !!providerInstance && libraryStatus === 'ready';
    
    if (!isReady) {
      NavigationLogger.debug('Library', 'Waiting for initialization', {
        hasProvider: !!providerInstance,
        status: libraryStatus
      });
      return;
    }

    // Wenn eine folderId in der URL steht und noch nicht angewendet wurde,
    // verhindere das initiale Laden von "root" (vermeidet Doppel-Load)
    const folderIdFromUrl = searchParams?.get('folderId');
    if (!urlInitAppliedRef.current && folderIdFromUrl && folderIdFromUrl !== currentFolderId) {
      NavigationLogger.debug('debug@init', 'Skip initial root load; URL folderId pending', {
        folderIdFromUrl,
        currentFolderId,
        lastLoadedFolder
      });
      return;
    }

    // Nur laden wenn noch nicht geladen
    if (lastLoadedFolder !== currentFolderId && !loadInFlightRef.current) {
      UILogger.info('Library', 'Initial load triggered', {
        currentFolderId,
        lastLoadedFolder,
        tSinceMountMs: startupT0Ref.current ? Number((performance.now() - startupT0Ref.current).toFixed(1)) : undefined
      });
      NavigationLogger.info('Library', 'Loading initial items', {
        folderId: currentFolderId
      });
      loadItems();
    }
  }, [providerInstance, libraryStatus, currentFolderId, lastLoadedFolder, activeLibraryId, loadItems, searchParams]);

  // Zusätzlicher Reset bei Bibliothekswechsel (robust gegen Status-Race)
  useEffect(() => {
    if (!activeLibraryId) return;
    StateLogger.info('Library', 'Active library changed - reset initial load state', {
      activeLibraryId,
      currentFolderId
    });
    setLastLoadedFolder(null);
    setFolderItems([]);
    setLibraryState(state => ({ ...state, folderCache: {} }));
    // WICHTIG: Ordnerauswahl und Shadow-Twin zurücksetzen
    setSelectedFile(null);
    setSelectedShadowTwin(null);
  }, [activeLibraryId, setLastLoadedFolder, setFolderItems, setLibraryState, currentFolderId]);

  // Reset Cache wenn sich die Library ändert
  useEffect(() => {
    setLastLoadedFolder(null);
    setLibraryState(state => ({
      ...state,
      folderCache: {}
    }));
  }, [libraryStatus, setLibraryState, setLastLoadedFolder]);

  // Manuelle Cache-Clear-Funktion für Review-Modus
  const clearCache = useCallback(() => {
    StateLogger.info('Library', 'Manually clearing cache for review mode');
    setLastLoadedFolder(null);
    setLibraryState(state => ({
      ...state,
      folderCache: {}
    }));
    setFolderItems([]);
  }, [setLibraryState, setLastLoadedFolder, setFolderItems]);

  // Reset selectedShadowTwin wenn Review-Modus verlassen wird
  useEffect(() => {
    if (!isReviewMode) {
      setSelectedShadowTwin(null);
    }
  }, [isReviewMode, setSelectedShadowTwin]);

  // ENTFERNT: Der folgende useEffect war problematisch und hat das Shadow-Twin 
  // bei jedem Klick zurückgesetzt, auch wenn die Datei ein Shadow-Twin hat.
  // Die Shadow-Twin-Logik wird bereits korrekt in der FileList-Komponente 
  // in der handleSelect-Funktion behandelt.

  // Render-Logik für verschiedene Status
  if (libraryStatus === "waitingForAuth") {
    return (
      <div className="flex flex-col items-center justify-center h-full text-muted-foreground">
        <span>Diese Bibliothek benötigt eine Authentifizierung.</span>
        <span className="text-sm mt-2">Bitte konfigurieren Sie die Bibliothek in den Einstellungen.</span>
      </div>
    );
  }
  
  if (libraryStatus !== "ready") {
    return (
      <div className="flex flex-col items-center justify-center h-full text-muted-foreground">
        <span>Lade Storage...</span>
      </div>
    );
  }

  return (
    <div className="flex flex-col h-full">
      <LibraryHeader
        provider={providerInstance}
        error={storageError}
        onUploadComplete={loadItems}
        onClearCache={clearCache}
        isTreeVisible={isTreeVisible}
        onToggleTree={() => setIsTreeVisible(v => !v)}
        isListVisible={isListVisible}
        onToggleList={() => setIsListVisible(v => !v)}
        isCompactList={isListCompact}
        onToggleCompactList={() => setIsListCompact(v => !v)}
      >
        <Breadcrumb />
      </LibraryHeader>
      
      <div className="flex-1 min-h-0 overflow-hidden">
        {isReviewMode ? (
          // Review-Layout: 3 Panels ohne FileTree - FileList (compact) | FilePreview (Basis-Datei) | FilePreview (Shadow-Twin)
          <ResizablePanelGroup direction="horizontal" className="h-full">
            <ResizablePanel defaultSize={25} minSize={20} className="min-h-0">
              <div className="h-full overflow-auto flex flex-col">
                <FileList compact={true} />
              </div>
            </ResizablePanel>
            <ResizableHandle />
            <ResizablePanel defaultSize={37.5} minSize={30} className="min-h-0">
              <div className="h-full relative flex flex-col">
                {selectedFile ? (
                  <FilePreviewLazy
                    provider={providerInstance}
                    file={selectedFile}
                    onRefreshFolder={(folderId, items, selectFileAfterRefresh) => {
                    StateLogger.info('Library', 'FilePreview (Basis) onRefreshFolder aufgerufen', {
                      folderId,
                      itemsCount: items.length,
                      hasSelectFile: !!selectFileAfterRefresh
                    });
                    
                    // Aktualisiere die Dateiliste
                    setFolderItems(items);
                    
                    // Aktualisiere den Cache
                    if (libraryState.folderCache?.[folderId]) {
                      const cachedFolder = libraryState.folderCache[folderId];
                      if (cachedFolder) {
                        setLibraryState(state => ({
                          ...state,
                          folderCache: {
                            ...(state.folderCache || {}),
                            [folderId]: {
                              ...cachedFolder,
                              children: items
                            }
                          }
                        }));
                      }
                    }
                    
                    // Wenn eine Datei ausgewählt werden soll (nach dem Speichern)
                    if (selectFileAfterRefresh) {
                      StateLogger.info('Library', 'Wähle gespeicherte Datei aus', {
                        fileId: selectFileAfterRefresh.id,
                        fileName: selectFileAfterRefresh.metadata.name
                      });
                    }
                    }}
                  />
                ) : (
                  <div className="h-full flex items-center justify-center text-muted-foreground">
                    <p>Keine Datei ausgewählt</p>
                  </div>
                )}
              </div>
            </ResizablePanel>
            <ResizableHandle />
            <ResizablePanel defaultSize={37.5} minSize={30} className="min-h-0">
              <div className="h-full relative flex flex-col">
                {selectedShadowTwin ? (
                  <FilePreviewLazy
                    provider={providerInstance}
                    file={selectedShadowTwin}
                    onRefreshFolder={(folderId, items, selectFileAfterRefresh) => {
                      StateLogger.info('Library', 'FilePreview (Shadow-Twin) onRefreshFolder aufgerufen', {
                        folderId,
                        itemsCount: items.length,
                        hasSelectFile: !!selectFileAfterRefresh
                      });
                      
                      // Aktualisiere die Dateiliste
                      setFolderItems(items);
                      
                      // Aktualisiere den Cache
                      if (libraryState.folderCache?.[folderId]) {
                        const cachedFolder = libraryState.folderCache[folderId];
                        if (cachedFolder) {
                          setLibraryState(state => ({
                            ...state,
                            folderCache: {
                              ...(state.folderCache || {}),
                              [folderId]: {
                                ...cachedFolder,
                                children: items
                              }
                            }
                          }));
                        }
                      }
                      
                      // Wenn eine Datei ausgewählt werden soll (nach dem Speichern)
                      if (selectFileAfterRefresh) {
                        StateLogger.info('Library', 'Wähle gespeicherte Datei aus', {
                          fileId: selectFileAfterRefresh.id,
                          fileName: selectFileAfterRefresh.metadata.name
                        });
                      }
                    }}
                  />
                ) : (
                  <div className="h-full flex items-center justify-center text-muted-foreground">
                    <p>Kein Shadow-Twin ausgewählt</p>
                  </div>
                )}
              </div>
            </ResizablePanel>
          </ResizablePanelGroup>
        ) : (
          // Normal-Layout (Desktop) oder alternierendes Mobile-Layout
          <div className="relative h-full">
            {/* Entfernt: alter Tree-Handle (ersetzt durch Header-Toggle) */}

            {isMobile ? (
              mobileView === 'list' ? (
                <div className="h-full overflow-auto flex flex-col">
                  <FileList />
                </div>
              ) : (
                <div className="h-full flex flex-col">
                  <div className="flex items-center gap-2 p-2 border-b bg-background">
                    <button
                      type="button"
                      className="inline-flex items-center gap-1 text-sm px-2 py-1 border rounded-md"
                      onClick={() => {
                        setMobileView('list');
                        setSelectedShadowTwin(null);
                        setSelectedFile(null);
                        loadItems();
                      }}
                    >
                      <ChevronLeft className="h-4 w-4" />
                      Zurück
                    </button>
                    <div className="text-sm text-muted-foreground truncate">
                      {selectedFile?.metadata.name}
                    </div>
                  </div>
                  <div className="flex-1 min-h-0">
                    {selectedFile ? (
                      <FilePreviewLazy
                        provider={providerInstance}
                        onRefreshFolder={(folderId, items, selectFileAfterRefresh) => {
                        StateLogger.info('Library', 'FilePreview onRefreshFolder aufgerufen', {
                          folderId,
                          itemsCount: items.length,
                          hasSelectFile: !!selectFileAfterRefresh
                        });
                        setFolderItems(items);
                        if (libraryState.folderCache?.[folderId]) {
                          const cachedFolder = libraryState.folderCache[folderId];
                          if (cachedFolder) {
                            setLibraryState(state => ({
                              ...state,
                              folderCache: {
                                ...(state.folderCache || {}),
                                [folderId]: { ...cachedFolder, children: items }
                              }
                            }));
                          }
                        }
                        }}
                      />
                    ) : (
                      <div className="h-full flex items-center justify-center text-muted-foreground">
                        <p>Keine Datei ausgewählt</p>
                      </div>
                    )}
                  </div>
                </div>
              )
            ) : (
              <ResizablePanelGroup
                key={isTreeVisible ? 'with-tree' : 'no-tree'}
                direction="horizontal"
                className="h-full"
                autoSaveId={isTreeVisible ? "library-panels-3" : "library-panels-2"}
              >
                {isTreeVisible && (
                  <>
                    <ResizablePanel key="tree-panel" id="tree" defaultSize={20} minSize={15} className="min-h-0">
                      <div className="h-full overflow-auto flex flex-col">
                        <FileTree />
                      </div>
                    </ResizablePanel>
                    <ResizableHandle key="tree-handle" />
                  </>
                )}
                {isListVisible && (
                  <>
                    <ResizablePanel key="list-panel" id="list" defaultSize={isTreeVisible ? 40 : 50} className="min-h-0">
                      <div className="h-full overflow-auto flex flex-col">
                        <FileList compact={isListCompact} />
                      </div>
                    </ResizablePanel>
                    <ResizableHandle key="list-preview-handle" />
                  </>
                )}
                <ResizablePanel key="preview-panel" id="preview" defaultSize={isTreeVisible ? 40 : 50} className="min-h-0">
                  <div className="h-full relative flex flex-col">
                    {selectedFile ? (
                      <FilePreviewLazy
                        provider={providerInstance}
                        onRefreshFolder={(folderId, items, selectFileAfterRefresh) => {
                        StateLogger.info('Library', 'FilePreview onRefreshFolder aufgerufen', {
                          folderId,
                          itemsCount: items.length,
                          hasSelectFile: !!selectFileAfterRefresh
                        });
                        
                        // Aktualisiere die Dateiliste
                        setFolderItems(items);
                        
                        // Aktualisiere den Cache
                        if (libraryState.folderCache?.[folderId]) {
                          const cachedFolder = libraryState.folderCache[folderId];
                          if (cachedFolder) {
                            setLibraryState(state => ({
                              ...state,
                              folderCache: {
                                ...(state.folderCache || {}),
                                [folderId]: {
                                  ...cachedFolder,
                                  children: items
                                }
                              }
                            }));
                          }
                        }
                        
                        if (selectFileAfterRefresh) {
                          StateLogger.info('Library', 'Wähle gespeicherte Datei aus', {
                            fileId: selectFileAfterRefresh.id,
                            fileName: selectFileAfterRefresh.metadata.name
                          });
                        }
                        }}
                      />
                    ) : (
                      <div className="h-full flex items-center justify-center text-muted-foreground">
                        <p>Keine Datei ausgewählt</p>
                      </div>
                    )}
                  </div>
                </ResizablePanel>
              </ResizablePanelGroup>
            )}
          </div>
        )}
      </div>
      
      {/* Dialoge */}
      <TranscriptionDialog />
      <TransformationDialog 
        onRefreshFolder={(folderId: string, items: StorageItem[], selectFileAfterRefresh?: StorageItem) => {
          StateLogger.info('Library', 'TransformationDialog onRefreshFolder aufgerufen', {
            folderId,
            itemsCount: items.length,
            hasSelectFile: !!selectFileAfterRefresh
          });
          
          // Aktualisiere die Dateiliste
          setFolderItems(items);
          
          // Aktualisiere den Cache
          if (libraryState.folderCache?.[folderId]) {
            const cachedFolder = libraryState.folderCache[folderId];
            if (cachedFolder) {
              setLibraryState(state => ({
                ...state,
                folderCache: {
                  ...(state.folderCache || {}),
                  [folderId]: {
                    ...cachedFolder,
                    children: items
                  }
                }
              }));
            }
          }
          
          // Wenn eine Datei ausgewählt werden soll (nach dem Speichern)
          if (selectFileAfterRefresh) {
            StateLogger.info('Library', 'Wähle gespeicherte Datei aus', {
              fileId: selectFileAfterRefresh.id,
              fileName: selectFileAfterRefresh.metadata.name
            });
          }
        }}
      />
    </div>
  );
}
```

Gute Idee. Ich habe eine Kompaktansicht für die File-Liste umgesetzt, ohne die Komponente zu duplizieren:

- Toolbar-Schalter in der Library
  - Neues Icon in der Toolbar: wechselt zwischen Listenansicht und Kompaktansicht.
  - Bestehender Sidebar-Button für FileTree bleibt. Der separate „Liste ausblenden“-Button bleibt optional, aber Kompaktansicht ist jetzt der empfohlene Weg für mehr Platz.

- Kompaktansicht in `FileList`
  - Nutzt vorhandenes `compact`-Prop.
  - Header und Tabellen-Layout werden ausgeblendet.
  - Je Zeile nur der Dateiname in einer schmalen, klickbaren Zeile.
  - Keine Checkbox-, Icon- oder Aktionsspalten.
  - Folder-Navigation bleibt erhalten, aber ebenfalls kompakt.

- Änderungen
  - `library-header.tsx`: zwei Toggles
    - Sidebar sichtbar/ausblenden (FileTree).
    - Kompaktansicht umschalten (Listen ↔ Kompakt).
  - `library.tsx`:
    - State `isListCompact`.
    - Übergabe an `FileList compact={isListCompact}`.
    - Der alte schwebende Tree-Handle ist entfernt.
  - `file-list.tsx`: vorhandener `compact`-Pfad nutzt nur Namen; Header/Spalten werden unterdrückt.

Bitte testen:
- Toolbar-Icon „Listenansicht/Kompaktansicht“: Umschalten und prüfen, dass in Kompaktansicht nur Namen angezeigt werden.
- FileTree optional ein-/ausblenden.
- Navigation in beiden Modi funktioniert.

Wenn du zusätzlich die Ordnerzeilen in Kompaktansicht ganz ohne Icon möchtest, sag kurz Bescheid; ich reduziere die Folder-Reihe analog.

---

**User**

Die Icons oben sind jetzt ein bisschen verwirrend. Einmal beziehungsweise auf das Ein- und Ausblenden von Paneele und einmal auf die Umstellung der Ansicht. Können wir das umschalten so als Toggle-Button formatieren. Also Filetree ausblenden, passt. Aber es müsste unten auch diese Pane-Aufteilung, also die Breite der Spalten, dann sich anpassen. Wenn ich auf die kompakte Listenansicht beim File-List gehe, sollte dann auch der Pane auf eine sehr schmale Ansicht wechseln. Also die kompakte Ansicht braucht ein Drittel des Platzes, das die Listenansicht braucht. Und wenn man was ausblendet, sollte es immer zugunsten des rechten Panes gehen, in dem eben diese PDF und Markdown angezeigt werden.

---

**Cursor**

```typescriptreact
import * as React from "react"
import { UILogger } from "@/lib/debug/logger"
import { Button } from "@/components/ui/button"
import { Upload, AlertTriangle, ArrowLeft, Eye, FileStack, Sidebar, LayoutList } from "lucide-react"
import { UploadDialog } from "./upload-dialog"
import { StorageProvider } from "@/lib/storage/types"
import { useCallback } from "react"
import { Alert, AlertDescription } from "@/components/ui/alert"
import { useAtom, useAtomValue } from "jotai"
import { currentFolderIdAtom, reviewModeAtom, libraryAtom } from "@/atoms/library-atom"
import { Breadcrumb } from "./breadcrumb"
import { AudioRecorderClient } from "./audio-recorder-client"
import PdfBulkImportDialog from "./pdf-bulk-import-dialog"
import { useFolderNavigation } from "@/hooks/use-folder-navigation"

interface LibraryHeaderProps {
  provider: StorageProvider | null
  onUploadComplete?: () => void
  error?: string | null
  children?: React.ReactNode
  onClearCache?: () => void // Cache-Invalidierung
  isTreeVisible?: boolean
  onToggleTree?: () => void
  isListVisible?: boolean
  onToggleList?: () => void
  isCompactList?: boolean
  onToggleCompactList?: () => void
}

export function LibraryHeader({
  provider,
  onUploadComplete,
  error,
  children,
  onClearCache,
  isTreeVisible,
  onToggleTree,
  isListVisible,
  onToggleList,
  isCompactList,
  onToggleCompactList
}: LibraryHeaderProps) {
  const [isUploadOpen, setIsUploadOpen] = React.useState(false)
  const [isPdfBulkOpen, setIsPdfBulkOpen] = React.useState(false)
  const [currentFolderId] = useAtom(currentFolderIdAtom);
  const [isReviewMode, setIsReviewMode] = useAtom(reviewModeAtom);
  const libraryState = useAtomValue(libraryAtom);
  const navigateToFolder = useFolderNavigation();

  // Aktueller Library-Name (für Root-Ebene)
  const currentLibraryName = React.useMemo(() => {
    const libId = libraryState.activeLibraryId;
    return libraryState.libraries.find(l => l.id === libId)?.label || 'Library';
  }, [libraryState.activeLibraryId, libraryState.libraries]);

  // Kompakter Pfadname (nur aktueller/übergeordneter Ordner), mobil mit Ellipsis
  const compactPathName = React.useMemo(() => {
    if (currentFolderId === 'root') return currentLibraryName;
    const folder = libraryState.folderCache?.[currentFolderId];
    return folder?.metadata?.name ?? '';
  }, [libraryState.folderCache, currentFolderId, currentLibraryName]);

  const parentId = React.useMemo(() => {
    if (currentFolderId === 'root') return null;
    const folder = libraryState.folderCache?.[currentFolderId];
    const pid = folder?.parentId;
    if (pid && pid.length > 0) return pid;
    return 'root';
  }, [libraryState.folderCache, currentFolderId]);

  const handleUploadComplete = useCallback(() => {
    UILogger.info('LibraryHeader', 'Upload completed');
    onUploadComplete?.();
    setIsUploadOpen(false);
  }, [onUploadComplete]);

  const handleUploadClick = useCallback(() => {
    UILogger.info('LibraryHeader', 'Upload button clicked');
    setIsUploadOpen(true);
  }, []);

  const handlePdfBulkClick = useCallback(() => {
    UILogger.info('LibraryHeader', 'PDF bulk button clicked');
    setIsPdfBulkOpen(true);
  }, []);

  const handleReviewModeToggle = useCallback(() => {
    UILogger.info('LibraryHeader', 'Review mode toggled', { newMode: !isReviewMode });
    
    // Wenn Review-Modus aktiviert wird, Cache leeren
    if (!isReviewMode && onClearCache) {
      UILogger.info('LibraryHeader', 'Clearing cache before entering review mode');
      onClearCache();
    }
    
    setIsReviewMode(!isReviewMode);
  }, [isReviewMode, setIsReviewMode, onClearCache]);



  return (
    <div className="border-b bg-background flex-shrink-0">
      {error && (
        <Alert variant="destructive" className="m-2">
          <AlertTriangle className="h-4 w-4" />
          <AlertDescription>{error}</AlertDescription>
        </Alert>
      )}
      <div className="flex items-center px-4 py-2 gap-3">
        {/* Pfad / Breadcrumb: Desktop voll, mobil kompakt */}
        <div className="min-w-0 flex-1">
          <div className="hidden sm:block">
            {children || <Breadcrumb />}
          </div>
          <div className="block sm:hidden text-xs text-muted-foreground truncate" title={compactPathName}>
            <div className="flex items-center gap-2">
              {parentId && (
                <Button
                  variant="ghost"
                  size="icon"
                  aria-label="Zurück"
                  title="Zurück"
                  onClick={() => navigateToFolder(parentId)}
                >
                  <ArrowLeft className="h-4 w-4" />
                </Button>
              )}
              <span className="truncate">{compactPathName}</span>
            </div>
          </div>
        </div>

        {/* Actions rechtsbündig, Icons only */}
        <div className="ml-auto flex items-center gap-1">
          {typeof isTreeVisible === 'boolean' && onToggleTree && (
            <Button
              variant="ghost"
              size="icon"
              onClick={onToggleTree}
              title={isTreeVisible ? 'Tree ausblenden' : 'Tree einblenden'}
              aria-label={isTreeVisible ? 'Tree ausblenden' : 'Tree einblenden'}
              aria-pressed={isTreeVisible}
              className={isTreeVisible ? 'bg-muted' : ''}
            >
              <Sidebar className="h-4 w-4" />
            </Button>
          )}

          {typeof isListVisible === 'boolean' && onToggleList && (
            <Button
              variant="ghost"
              size="icon"
              onClick={onToggleList}
              title={isListVisible ? 'Liste ausblenden' : 'Liste einblenden'}
              aria-label={isListVisible ? 'Liste ausblenden' : 'Liste einblenden'}
              aria-pressed={isListVisible}
              className={isListVisible ? 'bg-muted' : ''}
            >
              <LayoutList className="h-4 w-4" />
            </Button>
          )}

          {typeof isCompactList === 'boolean' && onToggleCompactList && (
            <Button
              variant="ghost"
              size="icon"
              onClick={onToggleCompactList}
              title={isCompactList ? 'Listenansicht' : 'Kompaktansicht'}
              aria-label={isCompactList ? 'Listenansicht' : 'Kompaktansicht'}
              aria-pressed={isCompactList}
              className={isCompactList ? 'bg-muted' : ''}
            >
              {/* Gleiches Icon; Tooltip unterscheidet */}
              <LayoutList className="h-4 w-4" />
            </Button>
          )}

          <Button
            variant="ghost"
            size="icon"
            onClick={handleReviewModeToggle}
            title={isReviewMode ? 'Zur Liste' : 'Vergleichen'}
            aria-label={isReviewMode ? 'Zur Liste' : 'Vergleichen'}
          >
            {isReviewMode ? (
              <ArrowLeft className="h-4 w-4" />
            ) : (
              <Eye className="h-4 w-4" />
            )}
          </Button>

          <Button
            variant="ghost"
            size="icon"
            onClick={handleUploadClick}
            title="Datei hochladen"
            aria-label="Datei hochladen"
          >
            <Upload className="h-4 w-4" />
          </Button>

          <Button
            variant="secondary"
            size="icon"
            onClick={handlePdfBulkClick}
            title="PDF-Verzeichnis verarbeiten"
            aria-label="PDF-Verzeichnis verarbeiten"
          >
            <FileStack className="h-4 w-4" />
          </Button>

          {/* Aufnahme als Icon-Button (mobil/desktop sichtbar) */}
          <AudioRecorderClient 
            onUploadComplete={handleUploadComplete}
          />
        </div>
      </div>

      <UploadDialog
        open={isUploadOpen}
        onOpenChange={(open) => {
          UILogger.info('LibraryHeader', 'Upload dialog state change', { open });
          setIsUploadOpen(open);
        }}
        provider={provider}
        currentFolderId={currentFolderId}
        onSuccess={handleUploadComplete}
      />

      <PdfBulkImportDialog
        open={isPdfBulkOpen}
        onOpenChange={(open) => {
          UILogger.info('LibraryHeader', 'PDF bulk dialog state change', { open });
          setIsPdfBulkOpen(open);
        }}
      />
    </div>
  )
}
```

```typescriptreact
"use client"

import * as React from "react"
import { useCallback, useEffect } from "react"
import { useAtom, useAtomValue } from "jotai"

import { LibraryHeader } from "./library-header"
import { FileTree } from "./file-tree"
import { FileList } from "./file-list"
import dynamic from 'next/dynamic'
const FilePreviewLazy = dynamic(() => import('./file-preview').then(m => m.FilePreview), {
  ssr: false,
  loading: () => (
    <div className="h-full flex items-center justify-center text-muted-foreground">
      Lade Vorschau...
    </div>
  )
})
import { ResizableHandle, ResizablePanel, ResizablePanelGroup } from "@/components/ui/resizable"
import { 
  libraryAtom, 
  folderItemsAtom,
  loadingStateAtom,
  lastLoadedFolderAtom,
  currentFolderIdAtom,
  reviewModeAtom,
  selectedFileAtom,
  selectedShadowTwinAtom
} from "@/atoms/library-atom"
import { activeLibraryIdAtom } from "@/atoms/library-atom"
import { useStorage, isStorageError } from "@/contexts/storage-context"
import { TranscriptionDialog } from "./transcription-dialog"
import { TransformationDialog } from "./transformation-dialog"
import { StorageItem } from "@/lib/storage/types"
import { NavigationLogger, StateLogger, UILogger } from "@/lib/debug/logger"
import { Breadcrumb } from "./breadcrumb"
import { useToast } from "@/components/ui/use-toast"
import { ChevronLeft, ChevronRight } from "lucide-react"
import { useSearchParams } from "next/navigation"
import { useFolderNavigation } from "@/hooks/use-folder-navigation"
export function Library() {
  // Performance-Messung für Kaltstart (nur Client)
  const startupT0Ref = React.useRef<number>(
    typeof performance !== 'undefined' ? performance.now() : 0
  );
  // Globale Atoms
  const [, setFolderItems] = useAtom(folderItemsAtom);
  const [, setLoadingState] = useAtom(loadingStateAtom);
  const [lastLoadedFolder, setLastLoadedFolder] = useAtom(lastLoadedFolderAtom);
  const [currentFolderId] = useAtom(currentFolderIdAtom);
  const [libraryState, setLibraryState] = useAtom(libraryAtom);
  const activeLibraryId = useAtomValue(activeLibraryIdAtom);
  
  // Review-Mode Atoms
  const [isReviewMode] = useAtom(reviewModeAtom);
  const [selectedFile, setSelectedFile] = useAtom(selectedFileAtom);
  const [selectedShadowTwin, setSelectedShadowTwin] = useAtom(selectedShadowTwinAtom);
  
  // Storage Context
  const { 
    provider: providerInstance, 
    error: storageError, 
    listItems,
    libraryStatus,
    currentLibrary
  } = useStorage();
  const { toast } = useToast();
  const [isTreeVisible, setIsTreeVisible] = React.useState<boolean>(false);
  const [isListVisible, setIsListVisible] = React.useState<boolean>(true);
  const [isListCompact, setIsListCompact] = React.useState<boolean>(false);
  const [isMobile, setIsMobile] = React.useState<boolean>(false);
  const [mobileView, setMobileView] = React.useState<'list' | 'preview'>('list');
  const loadInFlightRef = React.useRef<boolean>(false);
  const searchParams = useSearchParams();
  const navigateToFolder = useFolderNavigation();

  // Mobile: Tree standardmäßig ausblenden, Desktop: anzeigen
  React.useEffect(() => {
    if (typeof window === 'undefined') return;
    // Desktop ab 1024px, Mobile darunter
    const mq = window.matchMedia('(max-width: 1023px)');
    const apply = (matches: boolean) => {
      setIsMobile(matches);
      setIsTreeVisible(!matches);
    };
    apply(mq.matches);
    const handler = (e: MediaQueryListEvent) => apply(e.matches);
    mq.addEventListener('change', handler);
    return () => mq.removeEventListener('change', handler);
  }, []);

  // URL -> State: folderId aus Query anwenden, wenn Provider bereit ist
  const urlInitAppliedRef = React.useRef(false);
  React.useEffect(() => {
    const folderIdFromUrl = searchParams?.get('folderId');

    if (urlInitAppliedRef.current) return;

    if (!folderIdFromUrl) {
      NavigationLogger.debug('debug@init', 'No folderId in URL', {
        currentFolderId
      });
      urlInitAppliedRef.current = true;
      return;
    }

    if (!providerInstance || libraryStatus !== 'ready') {
      NavigationLogger.debug('debug@init', 'Provider not ready, deferring URL apply', {
        folderIdFromUrl,
        libraryStatus,
        hasProvider: !!providerInstance
      });
      return;
    }

    if (folderIdFromUrl !== currentFolderId) {
      NavigationLogger.info('debug@init', 'Applying folderId from URL (ready)', {
        folderIdFromUrl,
        currentFolderId
      });
      void navigateToFolder(folderIdFromUrl);
    }
    urlInitAppliedRef.current = true;
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [searchParams, providerInstance, libraryStatus, currentFolderId]);

  // Mobile-View Wechsellogik: bei Dateiauswahl zur Vorschau wechseln
  React.useEffect(() => {
    if (!isMobile) return;
    if (selectedFile) setMobileView('preview');
  }, [isMobile, selectedFile]);

  // Optimierter loadItems mit Cache-Check
  const loadItems = useCallback(async () => {
    if (loadInFlightRef.current) {
      NavigationLogger.debug('Library', 'Skip loadItems - load already in flight');
      return;
    }
    if (!providerInstance || libraryStatus !== 'ready') {
      NavigationLogger.debug('Library', 'Skipping loadItems - not ready', {
        hasProvider: !!providerInstance,
        status: libraryStatus
      });
      return;
    }

    // Schutz: Wenn Provider/Context noch auf alte Library zeigt, keine Items übernehmen
    if (currentLibrary?.id && currentLibrary.id !== activeLibraryId) {
      NavigationLogger.debug('Library', 'Skip loadItems - library mismatch', {
        providerLibraryId: currentLibrary.id,
        activeLibraryId
      });
      return;
    }

    loadInFlightRef.current = true;
    setLoadingState({ isLoading: true, loadingFolderId: currentFolderId });

    try {
      // Snapshot zur Vermeidung von Race-Conditions
      const expectedLibraryId = activeLibraryId;
      const expectedFolderId = currentFolderId;

      // Prüfe Cache zuerst
      if (libraryState.folderCache?.[currentFolderId]?.children) {
        const cachedItems = libraryState.folderCache[currentFolderId].children;
        NavigationLogger.info('Library', 'Using cached items', {
          folderId: currentFolderId,
          itemCount: cachedItems.length,
          cacheHit: true
        });
        // Übernehme nur, wenn der Snapshot noch aktuell ist
        if (expectedLibraryId === activeLibraryId && expectedFolderId === currentFolderId) {
          setFolderItems(cachedItems);
          setLastLoadedFolder(currentFolderId);
        }
        return;
      }

      NavigationLogger.info('Library', 'Fetching items from provider', {
        folderId: currentFolderId,
        cacheHit: false
      });
      
      const items = await listItems(currentFolderId);

      // Falls während des Ladens die Library oder der Ordner wechselte: Ergebnis verwerfen
      if (expectedLibraryId !== activeLibraryId || expectedFolderId !== currentFolderId) {
        NavigationLogger.debug('Library', 'Discard loaded items due to context change', {
          expectedLibraryId,
          activeLibraryId,
          expectedFolderId,
          currentFolderId
        });
        return;
      }
      
      // Update Cache und State
      if (currentFolderId !== 'root') {
        const newFolderCache = { ...libraryState.folderCache };
        const parent = newFolderCache[currentFolderId];
        if (parent) {
          newFolderCache[currentFolderId] = {
            ...parent,
            children: items
          };
          StateLogger.info('Library', 'Updating folder cache', {
            folderId: currentFolderId,
            itemCount: items.length,
            cacheSize: Object.keys(newFolderCache).length
          });
          setLibraryState(state => ({
            ...state,
            folderCache: newFolderCache
          }));
        }
      }
      
      setFolderItems(items);
      setLastLoadedFolder(currentFolderId);
      
      StateLogger.info('Library', 'Items loaded successfully', {
        folderId: currentFolderId,
        itemCount: items.length,
        fileCount: items.filter(i => i.type === 'file').length,
        folderCount: items.filter(i => i.type === 'folder').length,
        tSinceMountMs: startupT0Ref.current ? Number((performance.now() - startupT0Ref.current).toFixed(1)) : undefined
      });
      
    } catch (error) {
      if (isStorageError(error) && error.code === 'AUTH_REQUIRED') {
        StateLogger.info('Library', 'Auth required');
        // Keine Fehlermeldung für AUTH_REQUIRED anzeigen
      } else {
        StateLogger.error('Library', 'Failed to load items', {
          error: error instanceof Error ? {
            message: error.message,
            name: error.name,
            stack: error.stack?.split('\n').slice(0, 3)
          } : error,
          folderId: currentFolderId,
          libraryId: currentLibrary?.id,
          libraryPath: currentLibrary?.path
        });
        
        // Benutzerfreundliche Fehlermeldung anzeigen
        let errorMessage = 'Fehler beim Laden der Dateien';
        
        if (error instanceof Error) {
          if (error.message.includes('Nicht authentifiziert')) {
            errorMessage = 'Bitte authentifizieren Sie sich bei Ihrem Cloud-Speicher.';
          } else if (error.message.includes('Bibliothek nicht gefunden')) {
            errorMessage = 'Die ausgewählte Bibliothek wurde nicht gefunden. Bitte überprüfen Sie die Bibliothekskonfiguration.';
          } else if (error.message.includes('Server-Fehler')) {
            errorMessage = 'Server-Fehler beim Laden der Dateien. Bitte überprüfen Sie, ob der Bibliothekspfad existiert und zugänglich ist.';
          } else if (error.message.includes('Keine aktive Bibliothek')) {
            errorMessage = 'Keine aktive Bibliothek verfügbar. Bitte wählen Sie eine Bibliothek aus.';
          } else {
            errorMessage = error.message;
          }
        }
        
        // Toast-Nachricht anzeigen
        toast({
          title: "Fehler beim Laden der Dateien",
          description: errorMessage,
          variant: "destructive",
        });
      }
      setFolderItems([]);
    } finally {
      setLoadingState({ isLoading: false, loadingFolderId: null });
      loadInFlightRef.current = false;
    }
  }, [
    currentFolderId,
    lastLoadedFolder,
    listItems,
    libraryState.folderCache,
    providerInstance,
    libraryStatus,
    setLibraryState,
    setFolderItems,
    setLastLoadedFolder,
    setLoadingState,
    toast,
    currentLibrary
  ]);

  // Effect für Initial-Load (entkoppelt vom FileTree)
  useEffect(() => {
    const isReady = !!providerInstance && libraryStatus === 'ready';
    
    if (!isReady) {
      NavigationLogger.debug('Library', 'Waiting for initialization', {
        hasProvider: !!providerInstance,
        status: libraryStatus
      });
      return;
    }

    // Wenn eine folderId in der URL steht und noch nicht angewendet wurde,
    // verhindere das initiale Laden von "root" (vermeidet Doppel-Load)
    const folderIdFromUrl = searchParams?.get('folderId');
    if (!urlInitAppliedRef.current && folderIdFromUrl && folderIdFromUrl !== currentFolderId) {
      NavigationLogger.debug('debug@init', 'Skip initial root load; URL folderId pending', {
        folderIdFromUrl,
        currentFolderId,
        lastLoadedFolder
      });
      return;
    }

    // Nur laden wenn noch nicht geladen
    if (lastLoadedFolder !== currentFolderId && !loadInFlightRef.current) {
      UILogger.info('Library', 'Initial load triggered', {
        currentFolderId,
        lastLoadedFolder,
        tSinceMountMs: startupT0Ref.current ? Number((performance.now() - startupT0Ref.current).toFixed(1)) : undefined
      });
      NavigationLogger.info('Library', 'Loading initial items', {
        folderId: currentFolderId
      });
      loadItems();
    }
  }, [providerInstance, libraryStatus, currentFolderId, lastLoadedFolder, activeLibraryId, loadItems, searchParams]);

  // Zusätzlicher Reset bei Bibliothekswechsel (robust gegen Status-Race)
  useEffect(() => {
    if (!activeLibraryId) return;
    StateLogger.info('Library', 'Active library changed - reset initial load state', {
      activeLibraryId,
      currentFolderId
    });
    setLastLoadedFolder(null);
    setFolderItems([]);
    setLibraryState(state => ({ ...state, folderCache: {} }));
    // WICHTIG: Ordnerauswahl und Shadow-Twin zurücksetzen
    setSelectedFile(null);
    setSelectedShadowTwin(null);
  }, [activeLibraryId, setLastLoadedFolder, setFolderItems, setLibraryState, currentFolderId]);

  // Reset Cache wenn sich die Library ändert
  useEffect(() => {
    setLastLoadedFolder(null);
    setLibraryState(state => ({
      ...state,
      folderCache: {}
    }));
  }, [libraryStatus, setLibraryState, setLastLoadedFolder]);

  // Manuelle Cache-Clear-Funktion für Review-Modus
  const clearCache = useCallback(() => {
    StateLogger.info('Library', 'Manually clearing cache for review mode');
    setLastLoadedFolder(null);
    setLibraryState(state => ({
      ...state,
      folderCache: {}
    }));
    setFolderItems([]);
  }, [setLibraryState, setLastLoadedFolder, setFolderItems]);

  // Reset selectedShadowTwin wenn Review-Modus verlassen wird
  useEffect(() => {
    if (!isReviewMode) {
      setSelectedShadowTwin(null);
    }
  }, [isReviewMode, setSelectedShadowTwin]);

  // ENTFERNT: Der folgende useEffect war problematisch und hat das Shadow-Twin 
  // bei jedem Klick zurückgesetzt, auch wenn die Datei ein Shadow-Twin hat.
  // Die Shadow-Twin-Logik wird bereits korrekt in der FileList-Komponente 
  // in der handleSelect-Funktion behandelt.

  // Render-Logik für verschiedene Status
  if (libraryStatus === "waitingForAuth") {
    return (
      <div className="flex flex-col items-center justify-center h-full text-muted-foreground">
        <span>Diese Bibliothek benötigt eine Authentifizierung.</span>
        <span className="text-sm mt-2">Bitte konfigurieren Sie die Bibliothek in den Einstellungen.</span>
      </div>
    );
  }
  
  if (libraryStatus !== "ready") {
    return (
      <div className="flex flex-col items-center justify-center h-full text-muted-foreground">
        <span>Lade Storage...</span>
      </div>
    );
  }

  return (
    <div className="flex flex-col h-full">
      <LibraryHeader
        provider={providerInstance}
        error={storageError}
        onUploadComplete={loadItems}
        onClearCache={clearCache}
        isTreeVisible={isTreeVisible}
        onToggleTree={() => setIsTreeVisible(v => !v)}
        isListVisible={isListVisible}
        onToggleList={() => setIsListVisible(v => !v)}
        isCompactList={isListCompact}
        onToggleCompactList={() => setIsListCompact(v => !v)}
      >
        <Breadcrumb />
      </LibraryHeader>
      
      <div className="flex-1 min-h-0 overflow-hidden">
        {isReviewMode ? (
          // Review-Layout: 3 Panels ohne FileTree - FileList (compact) | FilePreview (Basis-Datei) | FilePreview (Shadow-Twin)
          <ResizablePanelGroup direction="horizontal" className="h-full">
            <ResizablePanel defaultSize={25} minSize={20} className="min-h-0">
              <div className="h-full overflow-auto flex flex-col">
                <FileList compact={true} />
              </div>
            </ResizablePanel>
            <ResizableHandle />
            <ResizablePanel defaultSize={37.5} minSize={30} className="min-h-0">
              <div className="h-full relative flex flex-col">
                {selectedFile ? (
                  <FilePreviewLazy
                    provider={providerInstance}
                    file={selectedFile}
                    onRefreshFolder={(folderId, items, selectFileAfterRefresh) => {
                    StateLogger.info('Library', 'FilePreview (Basis) onRefreshFolder aufgerufen', {
                      folderId,
                      itemsCount: items.length,
                      hasSelectFile: !!selectFileAfterRefresh
                    });
                    
                    // Aktualisiere die Dateiliste
                    setFolderItems(items);
                    
                    // Aktualisiere den Cache
                    if (libraryState.folderCache?.[folderId]) {
                      const cachedFolder = libraryState.folderCache[folderId];
                      if (cachedFolder) {
                        setLibraryState(state => ({
                          ...state,
                          folderCache: {
                            ...(state.folderCache || {}),
                            [folderId]: {
                              ...cachedFolder,
                              children: items
                            }
                          }
                        }));
                      }
                    }
                    
                    // Wenn eine Datei ausgewählt werden soll (nach dem Speichern)
                    if (selectFileAfterRefresh) {
                      StateLogger.info('Library', 'Wähle gespeicherte Datei aus', {
                        fileId: selectFileAfterRefresh.id,
                        fileName: selectFileAfterRefresh.metadata.name
                      });
                    }
                    }}
                  />
                ) : (
                  <div className="h-full flex items-center justify-center text-muted-foreground">
                    <p>Keine Datei ausgewählt</p>
                  </div>
                )}
              </div>
            </ResizablePanel>
            <ResizableHandle />
            <ResizablePanel defaultSize={37.5} minSize={30} className="min-h-0">
              <div className="h-full relative flex flex-col">
                {selectedShadowTwin ? (
                  <FilePreviewLazy
                    provider={providerInstance}
                    file={selectedShadowTwin}
                    onRefreshFolder={(folderId, items, selectFileAfterRefresh) => {
                      StateLogger.info('Library', 'FilePreview (Shadow-Twin) onRefreshFolder aufgerufen', {
                        folderId,
                        itemsCount: items.length,
                        hasSelectFile: !!selectFileAfterRefresh
                      });
                      
                      // Aktualisiere die Dateiliste
                      setFolderItems(items);
                      
                      // Aktualisiere den Cache
                      if (libraryState.folderCache?.[folderId]) {
                        const cachedFolder = libraryState.folderCache[folderId];
                        if (cachedFolder) {
                          setLibraryState(state => ({
                            ...state,
                            folderCache: {
                              ...(state.folderCache || {}),
                              [folderId]: {
                                ...cachedFolder,
                                children: items
                              }
                            }
                          }));
                        }
                      }
                      
                      // Wenn eine Datei ausgewählt werden soll (nach dem Speichern)
                      if (selectFileAfterRefresh) {
                        StateLogger.info('Library', 'Wähle gespeicherte Datei aus', {
                          fileId: selectFileAfterRefresh.id,
                          fileName: selectFileAfterRefresh.metadata.name
                        });
                      }
                    }}
                  />
                ) : (
                  <div className="h-full flex items-center justify-center text-muted-foreground">
                    <p>Kein Shadow-Twin ausgewählt</p>
                  </div>
                )}
              </div>
            </ResizablePanel>
          </ResizablePanelGroup>
        ) : (
          // Normal-Layout (Desktop) oder alternierendes Mobile-Layout
          <div className="relative h-full">
            {/* Entfernt: alter Tree-Handle (ersetzt durch Header-Toggle) */}

            {isMobile ? (
              mobileView === 'list' ? (
                <div className="h-full overflow-auto flex flex-col">
                  <FileList />
                </div>
              ) : (
                <div className="h-full flex flex-col">
                  <div className="flex items-center gap-2 p-2 border-b bg-background">
                    <button
                      type="button"
                      className="inline-flex items-center gap-1 text-sm px-2 py-1 border rounded-md"
                      onClick={() => {
                        setMobileView('list');
                        setSelectedShadowTwin(null);
                        setSelectedFile(null);
                        loadItems();
                      }}
                    >
                      <ChevronLeft className="h-4 w-4" />
                      Zurück
                    </button>
                    <div className="text-sm text-muted-foreground truncate">
                      {selectedFile?.metadata.name}
                    </div>
                  </div>
                  <div className="flex-1 min-h-0">
                    {selectedFile ? (
                      <FilePreviewLazy
                        provider={providerInstance}
                        onRefreshFolder={(folderId, items, selectFileAfterRefresh) => {
                        StateLogger.info('Library', 'FilePreview onRefreshFolder aufgerufen', {
                          folderId,
                          itemsCount: items.length,
                          hasSelectFile: !!selectFileAfterRefresh
                        });
                        setFolderItems(items);
                        if (libraryState.folderCache?.[folderId]) {
                          const cachedFolder = libraryState.folderCache[folderId];
                          if (cachedFolder) {
                            setLibraryState(state => ({
                              ...state,
                              folderCache: {
                                ...(state.folderCache || {}),
                                [folderId]: { ...cachedFolder, children: items }
                              }
                            }));
                          }
                        }
                        }}
                      />
                    ) : (
                      <div className="h-full flex items-center justify-center text-muted-foreground">
                        <p>Keine Datei ausgewählt</p>
                      </div>
                    )}
                  </div>
                </div>
              )
            ) : (
              <ResizablePanelGroup
                key={isTreeVisible ? 'with-tree' : 'no-tree'}
                direction="horizontal"
                className="h-full"
                autoSaveId={isTreeVisible ? "library-panels-3" : "library-panels-2"}
              >
                {isTreeVisible && (
                  <>
                    <ResizablePanel key="tree-panel" id="tree" defaultSize={18} minSize={12} className="min-h-0">
                      <div className="h-full overflow-auto flex flex-col">
                        <FileTree />
                      </div>
                    </ResizablePanel>
                    <ResizableHandle key="tree-handle" />
                  </>
                )}
                {isListVisible && (
                  <>
                    <ResizablePanel key="list-panel" id="list" defaultSize={isListCompact ? (isTreeVisible ? 12 : 15) : (isTreeVisible ? 34 : 45)} minSize={isListCompact ? 10 : 25} className="min-h-0 transition-[flex-basis] duration-200 ease-in-out">
                      <div className="h-full overflow-auto flex flex-col">
                        <FileList compact={isListCompact} />
                      </div>
                    </ResizablePanel>
                    <ResizableHandle key="list-preview-handle" />
                  </>
                )}
                <ResizablePanel key="preview-panel" id="preview" defaultSize={(() => {
                  const left = (isTreeVisible ? (isListCompact ? 18 : 18) : 0) + (isListVisible ? (isListCompact ? (isTreeVisible ? 12 : 15) : (isTreeVisible ? 34 : 45)) : 0);
                  const rest = Math.max(10, 100 - left);
                  return rest;
                })()} className="min-h-0 transition-[flex-basis] duration-200 ease-in-out">
                  <div className="h-full relative flex flex-col">
                    {selectedFile ? (
                      <FilePreviewLazy
                        provider={providerInstance}
                        onRefreshFolder={(folderId, items, selectFileAfterRefresh) => {
                        StateLogger.info('Library', 'FilePreview onRefreshFolder aufgerufen', {
                          folderId,
                          itemsCount: items.length,
                          hasSelectFile: !!selectFileAfterRefresh
                        });
                        
                        // Aktualisiere die Dateiliste
                        setFolderItems(items);
                        
                        // Aktualisiere den Cache
                        if (libraryState.folderCache?.[folderId]) {
                          const cachedFolder = libraryState.folderCache[folderId];
                          if (cachedFolder) {
                            setLibraryState(state => ({
                              ...state,
                              folderCache: {
                                ...(state.folderCache || {}),
                                [folderId]: {
                                  ...cachedFolder,
                                  children: items
                                }
                              }
                            }));
                          }
                        }
                        
                        if (selectFileAfterRefresh) {
                          StateLogger.info('Library', 'Wähle gespeicherte Datei aus', {
                            fileId: selectFileAfterRefresh.id,
                            fileName: selectFileAfterRefresh.metadata.name
                          });
                        }
                        }}
                      />
                    ) : (
                      <div className="h-full flex items-center justify-center text-muted-foreground">
                        <p>Keine Datei ausgewählt</p>
                      </div>
                    )}
                  </div>
                </ResizablePanel>
              </ResizablePanelGroup>
            )}
          </div>
        )}
      </div>
      
      {/* Dialoge */}
      <TranscriptionDialog />
      <TransformationDialog 
        onRefreshFolder={(folderId: string, items: StorageItem[], selectFileAfterRefresh?: StorageItem) => {
          StateLogger.info('Library', 'TransformationDialog onRefreshFolder aufgerufen', {
            folderId,
            itemsCount: items.length,
            hasSelectFile: !!selectFileAfterRefresh
          });
          
          // Aktualisiere die Dateiliste
          setFolderItems(items);
          
          // Aktualisiere den Cache
          if (libraryState.folderCache?.[folderId]) {
            const cachedFolder = libraryState.folderCache[folderId];
            if (cachedFolder) {
              setLibraryState(state => ({
                ...state,
                folderCache: {
                  ...(state.folderCache || {}),
                  [folderId]: {
                    ...cachedFolder,
                    children: items
                  }
                }
              }));
            }
          }
          
          // Wenn eine Datei ausgewählt werden soll (nach dem Speichern)
          if (selectFileAfterRefresh) {
            StateLogger.info('Library', 'Wähle gespeicherte Datei aus', {
              fileId: selectFileAfterRefresh.id,
              fileName: selectFileAfterRefresh.metadata.name
            });
          }
        }}
      />
    </div>
  );
}
```

Ich habe die Bedienung vereinheitlicht und die Pane-Breiten dynamisch an die Ansicht gekoppelt:

- Toolbar-Buttons als echte Toggle-Buttons
  - FileTree: Button ist nun ein Toggle mit visuellem Zustand (Hintergrund, aria-pressed).
  - Listen/Kompakt: Toggle mit visuellem Zustand.
  - Optional: Liste aus/ein bleibt vorhanden; ebenfalls als Toggle.

- Pane-Breiten passen sich automatisch an
  - Tree sichtbar: 18% Breite.
  - FileList:
    - Listenansicht: 34% (mit Tree) bzw. 45% (ohne Tree).
    - Kompaktansicht: 12% (mit Tree) bzw. 15% (ohne Tree).
    - Smooth Transition via CSS-Transition.
  - Preview/Right Pane bekommt immer den restlichen Platz. Wenn etwas ausgeblendet wird, wächst rechts.

- FileList kompakt bleibt minimal-invasiv
  - Keine Checkbox-/Icon-/Aktionsspalten.
  - Nur Name, Header/Spalten-Titel ausgeblendet.
  - Oben bleibt die kleine List-Toolbar (Refresh/Filter) nur in normaler Ansicht sichtbar, in Kompaktansicht ausgeblendet.

Bitte testen:
- Toggle „Kompaktansicht“: Liste wird schmal, rechter Pane wächst.
- Toggle „Tree“: Ein/Aus, rechter Pane wächst entsprechend.
- Optional „Liste ausblenden“: rechter Pane nutzt maximalen Platz.
- Die Buttons heben sich im aktiven Zustand ab (bg-muted) und sind per aria-pressed gekennzeichnet.

---

**User**

OK, DoggleTree ist verständlicher. DoggleFileList würde ich entfernen. Es genügt mir nur die Ansicht Doggle. Weil keine Fileliste anzeigen, macht keinen Sinn. Es ist ein zentrales Navigationselement.

---

**Cursor**

```typescriptreact
import * as React from "react"
import { UILogger } from "@/lib/debug/logger"
import { Button } from "@/components/ui/button"
import { Upload, AlertTriangle, ArrowLeft, Eye, FileStack, Sidebar, LayoutList } from "lucide-react"
import { UploadDialog } from "./upload-dialog"
import { StorageProvider } from "@/lib/storage/types"
import { useCallback } from "react"
import { Alert, AlertDescription } from "@/components/ui/alert"
import { useAtom, useAtomValue } from "jotai"
import { currentFolderIdAtom, reviewModeAtom, libraryAtom } from "@/atoms/library-atom"
import { Breadcrumb } from "./breadcrumb"
import { AudioRecorderClient } from "./audio-recorder-client"
import PdfBulkImportDialog from "./pdf-bulk-import-dialog"
import { useFolderNavigation } from "@/hooks/use-folder-navigation"

interface LibraryHeaderProps {
  provider: StorageProvider | null
  onUploadComplete?: () => void
  error?: string | null
  children?: React.ReactNode
  onClearCache?: () => void // Cache-Invalidierung
  isTreeVisible?: boolean
  onToggleTree?: () => void
  isCompactList?: boolean
  onToggleCompactList?: () => void
}

export function LibraryHeader({
  provider,
  onUploadComplete,
  error,
  children,
  onClearCache,
  isTreeVisible,
  onToggleTree,
  isCompactList,
  onToggleCompactList
}: LibraryHeaderProps) {
  const [isUploadOpen, setIsUploadOpen] = React.useState(false)
  const [isPdfBulkOpen, setIsPdfBulkOpen] = React.useState(false)
  const [currentFolderId] = useAtom(currentFolderIdAtom);
  const [isReviewMode, setIsReviewMode] = useAtom(reviewModeAtom);
  const libraryState = useAtomValue(libraryAtom);
  const navigateToFolder = useFolderNavigation();

  // Aktueller Library-Name (für Root-Ebene)
  const currentLibraryName = React.useMemo(() => {
    const libId = libraryState.activeLibraryId;
    return libraryState.libraries.find(l => l.id === libId)?.label || 'Library';
  }, [libraryState.activeLibraryId, libraryState.libraries]);

  // Kompakter Pfadname (nur aktueller/übergeordneter Ordner), mobil mit Ellipsis
  const compactPathName = React.useMemo(() => {
    if (currentFolderId === 'root') return currentLibraryName;
    const folder = libraryState.folderCache?.[currentFolderId];
    return folder?.metadata?.name ?? '';
  }, [libraryState.folderCache, currentFolderId, currentLibraryName]);

  const parentId = React.useMemo(() => {
    if (currentFolderId === 'root') return null;
    const folder = libraryState.folderCache?.[currentFolderId];
    const pid = folder?.parentId;
    if (pid && pid.length > 0) return pid;
    return 'root';
  }, [libraryState.folderCache, currentFolderId]);

  const handleUploadComplete = useCallback(() => {
    UILogger.info('LibraryHeader', 'Upload completed');
    onUploadComplete?.();
    setIsUploadOpen(false);
  }, [onUploadComplete]);

  const handleUploadClick = useCallback(() => {
    UILogger.info('LibraryHeader', 'Upload button clicked');
    setIsUploadOpen(true);
  }, []);

  const handlePdfBulkClick = useCallback(() => {
    UILogger.info('LibraryHeader', 'PDF bulk button clicked');
    setIsPdfBulkOpen(true);
  }, []);

  const handleReviewModeToggle = useCallback(() => {
    UILogger.info('LibraryHeader', 'Review mode toggled', { newMode: !isReviewMode });
    
    // Wenn Review-Modus aktiviert wird, Cache leeren
    if (!isReviewMode && onClearCache) {
      UILogger.info('LibraryHeader', 'Clearing cache before entering review mode');
      onClearCache();
    }
    
    setIsReviewMode(!isReviewMode);
  }, [isReviewMode, setIsReviewMode, onClearCache]);



  return (
    <div className="border-b bg-background flex-shrink-0">
      {error && (
        <Alert variant="destructive" className="m-2">
          <AlertTriangle className="h-4 w-4" />
          <AlertDescription>{error}</AlertDescription>
        </Alert>
      )}
      <div className="flex items-center px-4 py-2 gap-3">
        {/* Pfad / Breadcrumb: Desktop voll, mobil kompakt */}
        <div className="min-w-0 flex-1">
          <div className="hidden sm:block">
            {children || <Breadcrumb />}
          </div>
          <div className="block sm:hidden text-xs text-muted-foreground truncate" title={compactPathName}>
            <div className="flex items-center gap-2">
              {parentId && (
                <Button
                  variant="ghost"
                  size="icon"
                  aria-label="Zurück"
                  title="Zurück"
                  onClick={() => navigateToFolder(parentId)}
                >
                  <ArrowLeft className="h-4 w-4" />
                </Button>
              )}
              <span className="truncate">{compactPathName}</span>
            </div>
          </div>
        </div>

        {/* Actions rechtsbündig, Icons only */}
        <div className="ml-auto flex items-center gap-1">
          {typeof isTreeVisible === 'boolean' && onToggleTree && (
            <Button
              variant="ghost"
              size="icon"
              onClick={onToggleTree}
              title={isTreeVisible ? 'Tree ausblenden' : 'Tree einblenden'}
              aria-label={isTreeVisible ? 'Tree ausblenden' : 'Tree einblenden'}
              aria-pressed={isTreeVisible}
              className={isTreeVisible ? 'bg-muted' : ''}
            >
              <Sidebar className="h-4 w-4" />
            </Button>
          )}

          {typeof isCompactList === 'boolean' && onToggleCompactList && (
            <Button
              variant="ghost"
              size="icon"
              onClick={onToggleCompactList}
              title={isCompactList ? 'Listenansicht' : 'Kompaktansicht'}
              aria-label={isCompactList ? 'Listenansicht' : 'Kompaktansicht'}
              aria-pressed={isCompactList}
              className={isCompactList ? 'bg-muted' : ''}
            >
              {/* Gleiches Icon; Tooltip unterscheidet */}
              <LayoutList className="h-4 w-4" />
            </Button>
          )}

          <Button
            variant="ghost"
            size="icon"
            onClick={handleReviewModeToggle}
            title={isReviewMode ? 'Zur Liste' : 'Vergleichen'}
            aria-label={isReviewMode ? 'Zur Liste' : 'Vergleichen'}
          >
            {isReviewMode ? (
              <ArrowLeft className="h-4 w-4" />
            ) : (
              <Eye className="h-4 w-4" />
            )}
          </Button>

          <Button
            variant="ghost"
            size="icon"
            onClick={handleUploadClick}
            title="Datei hochladen"
            aria-label="Datei hochladen"
          >
            <Upload className="h-4 w-4" />
          </Button>

          <Button
            variant="secondary"
            size="icon"
            onClick={handlePdfBulkClick}
            title="PDF-Verzeichnis verarbeiten"
            aria-label="PDF-Verzeichnis verarbeiten"
          >
            <FileStack className="h-4 w-4" />
          </Button>

          {/* Aufnahme als Icon-Button (mobil/desktop sichtbar) */}
          <AudioRecorderClient 
            onUploadComplete={handleUploadComplete}
          />
        </div>
      </div>

      <UploadDialog
        open={isUploadOpen}
        onOpenChange={(open) => {
          UILogger.info('LibraryHeader', 'Upload dialog state change', { open });
          setIsUploadOpen(open);
        }}
        provider={provider}
        currentFolderId={currentFolderId}
        onSuccess={handleUploadComplete}
      />

      <PdfBulkImportDialog
        open={isPdfBulkOpen}
        onOpenChange={(open) => {
          UILogger.info('LibraryHeader', 'PDF bulk dialog state change', { open });
          setIsPdfBulkOpen(open);
        }}
      />
    </div>
  )
}
```

```typescriptreact
"use client"

import * as React from "react"
import { useCallback, useEffect } from "react"
import { useAtom, useAtomValue } from "jotai"

import { LibraryHeader } from "./library-header"
import { FileTree } from "./file-tree"
import { FileList } from "./file-list"
import dynamic from 'next/dynamic'
const FilePreviewLazy = dynamic(() => import('./file-preview').then(m => m.FilePreview), {
  ssr: false,
  loading: () => (
    <div className="h-full flex items-center justify-center text-muted-foreground">
      Lade Vorschau...
    </div>
  )
})
import { ResizableHandle, ResizablePanel, ResizablePanelGroup } from "@/components/ui/resizable"
import { 
  libraryAtom, 
  folderItemsAtom,
  loadingStateAtom,
  lastLoadedFolderAtom,
  currentFolderIdAtom,
  reviewModeAtom,
  selectedFileAtom,
  selectedShadowTwinAtom
} from "@/atoms/library-atom"
import { activeLibraryIdAtom } from "@/atoms/library-atom"
import { useStorage, isStorageError } from "@/contexts/storage-context"
import { TranscriptionDialog } from "./transcription-dialog"
import { TransformationDialog } from "./transformation-dialog"
import { StorageItem } from "@/lib/storage/types"
import { NavigationLogger, StateLogger, UILogger } from "@/lib/debug/logger"
import { Breadcrumb } from "./breadcrumb"
import { useToast } from "@/components/ui/use-toast"
import { ChevronLeft, ChevronRight } from "lucide-react"
import { useSearchParams } from "next/navigation"
import { useFolderNavigation } from "@/hooks/use-folder-navigation"
export function Library() {
  // Performance-Messung für Kaltstart (nur Client)
  const startupT0Ref = React.useRef<number>(
    typeof performance !== 'undefined' ? performance.now() : 0
  );
  // Globale Atoms
  const [, setFolderItems] = useAtom(folderItemsAtom);
  const [, setLoadingState] = useAtom(loadingStateAtom);
  const [lastLoadedFolder, setLastLoadedFolder] = useAtom(lastLoadedFolderAtom);
  const [currentFolderId] = useAtom(currentFolderIdAtom);
  const [libraryState, setLibraryState] = useAtom(libraryAtom);
  const activeLibraryId = useAtomValue(activeLibraryIdAtom);
  
  // Review-Mode Atoms
  const [isReviewMode] = useAtom(reviewModeAtom);
  const [selectedFile, setSelectedFile] = useAtom(selectedFileAtom);
  const [selectedShadowTwin, setSelectedShadowTwin] = useAtom(selectedShadowTwinAtom);
  
  // Storage Context
  const { 
    provider: providerInstance, 
    error: storageError, 
    listItems,
    libraryStatus,
    currentLibrary
  } = useStorage();
  const { toast } = useToast();
  const [isTreeVisible, setIsTreeVisible] = React.useState<boolean>(false);
  const [isListCompact, setIsListCompact] = React.useState<boolean>(false);
  const [isMobile, setIsMobile] = React.useState<boolean>(false);
  const [mobileView, setMobileView] = React.useState<'list' | 'preview'>('list');
  const loadInFlightRef = React.useRef<boolean>(false);
  const searchParams = useSearchParams();
  const navigateToFolder = useFolderNavigation();

  // Mobile: Tree standardmäßig ausblenden, Desktop: anzeigen
  React.useEffect(() => {
    if (typeof window === 'undefined') return;
    // Desktop ab 1024px, Mobile darunter
    const mq = window.matchMedia('(max-width: 1023px)');
    const apply = (matches: boolean) => {
      setIsMobile(matches);
      setIsTreeVisible(!matches);
    };
    apply(mq.matches);
    const handler = (e: MediaQueryListEvent) => apply(e.matches);
    mq.addEventListener('change', handler);
    return () => mq.removeEventListener('change', handler);
  }, []);

  // URL -> State: folderId aus Query anwenden, wenn Provider bereit ist
  const urlInitAppliedRef = React.useRef(false);
  React.useEffect(() => {
    const folderIdFromUrl = searchParams?.get('folderId');

    if (urlInitAppliedRef.current) return;

    if (!folderIdFromUrl) {
      NavigationLogger.debug('debug@init', 'No folderId in URL', {
        currentFolderId
      });
      urlInitAppliedRef.current = true;
      return;
    }

    if (!providerInstance || libraryStatus !== 'ready') {
      NavigationLogger.debug('debug@init', 'Provider not ready, deferring URL apply', {
        folderIdFromUrl,
        libraryStatus,
        hasProvider: !!providerInstance
      });
      return;
    }

    if (folderIdFromUrl !== currentFolderId) {
      NavigationLogger.info('debug@init', 'Applying folderId from URL (ready)', {
        folderIdFromUrl,
        currentFolderId
      });
      void navigateToFolder(folderIdFromUrl);
    }
    urlInitAppliedRef.current = true;
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [searchParams, providerInstance, libraryStatus, currentFolderId]);

  // Mobile-View Wechsellogik: bei Dateiauswahl zur Vorschau wechseln
  React.useEffect(() => {
    if (!isMobile) return;
    if (selectedFile) setMobileView('preview');
  }, [isMobile, selectedFile]);

  // Optimierter loadItems mit Cache-Check
  const loadItems = useCallback(async () => {
    if (loadInFlightRef.current) {
      NavigationLogger.debug('Library', 'Skip loadItems - load already in flight');
      return;
    }
    if (!providerInstance || libraryStatus !== 'ready') {
      NavigationLogger.debug('Library', 'Skipping loadItems - not ready', {
        hasProvider: !!providerInstance,
        status: libraryStatus
      });
      return;
    }

    // Schutz: Wenn Provider/Context noch auf alte Library zeigt, keine Items übernehmen
    if (currentLibrary?.id && currentLibrary.id !== activeLibraryId) {
      NavigationLogger.debug('Library', 'Skip loadItems - library mismatch', {
        providerLibraryId: currentLibrary.id,
        activeLibraryId
      });
      return;
    }

    loadInFlightRef.current = true;
    setLoadingState({ isLoading: true, loadingFolderId: currentFolderId });

    try {
      // Snapshot zur Vermeidung von Race-Conditions
      const expectedLibraryId = activeLibraryId;
      const expectedFolderId = currentFolderId;

      // Prüfe Cache zuerst
      if (libraryState.folderCache?.[currentFolderId]?.children) {
        const cachedItems = libraryState.folderCache[currentFolderId].children;
        NavigationLogger.info('Library', 'Using cached items', {
          folderId: currentFolderId,
          itemCount: cachedItems.length,
          cacheHit: true
        });
        // Übernehme nur, wenn der Snapshot noch aktuell ist
        if (expectedLibraryId === activeLibraryId && expectedFolderId === currentFolderId) {
          setFolderItems(cachedItems);
          setLastLoadedFolder(currentFolderId);
        }
        return;
      }

      NavigationLogger.info('Library', 'Fetching items from provider', {
        folderId: currentFolderId,
        cacheHit: false
      });
      
      const items = await listItems(currentFolderId);

      // Falls während des Ladens die Library oder der Ordner wechselte: Ergebnis verwerfen
      if (expectedLibraryId !== activeLibraryId || expectedFolderId !== currentFolderId) {
        NavigationLogger.debug('Library', 'Discard loaded items due to context change', {
          expectedLibraryId,
          activeLibraryId,
          expectedFolderId,
          currentFolderId
        });
        return;
      }
      
      // Update Cache und State
      if (currentFolderId !== 'root') {
        const newFolderCache = { ...libraryState.folderCache };
        const parent = newFolderCache[currentFolderId];
        if (parent) {
          newFolderCache[currentFolderId] = {
            ...parent,
            children: items
          };
          StateLogger.info('Library', 'Updating folder cache', {
            folderId: currentFolderId,
            itemCount: items.length,
            cacheSize: Object.keys(newFolderCache).length
          });
          setLibraryState(state => ({
            ...state,
            folderCache: newFolderCache
          }));
        }
      }
      
      setFolderItems(items);
      setLastLoadedFolder(currentFolderId);
      
      StateLogger.info('Library', 'Items loaded successfully', {
        folderId: currentFolderId,
        itemCount: items.length,
        fileCount: items.filter(i => i.type === 'file').length,
        folderCount: items.filter(i => i.type === 'folder').length,
        tSinceMountMs: startupT0Ref.current ? Number((performance.now() - startupT0Ref.current).toFixed(1)) : undefined
      });
      
    } catch (error) {
      if (isStorageError(error) && error.code === 'AUTH_REQUIRED') {
        StateLogger.info('Library', 'Auth required');
        // Keine Fehlermeldung für AUTH_REQUIRED anzeigen
      } else {
        StateLogger.error('Library', 'Failed to load items', {
          error: error instanceof Error ? {
            message: error.message,
            name: error.name,
            stack: error.stack?.split('\n').slice(0, 3)
          } : error,
          folderId: currentFolderId,
          libraryId: currentLibrary?.id,
          libraryPath: currentLibrary?.path
        });
        
        // Benutzerfreundliche Fehlermeldung anzeigen
        let errorMessage = 'Fehler beim Laden der Dateien';
        
        if (error instanceof Error) {
          if (error.message.includes('Nicht authentifiziert')) {
            errorMessage = 'Bitte authentifizieren Sie sich bei Ihrem Cloud-Speicher.';
          } else if (error.message.includes('Bibliothek nicht gefunden')) {
            errorMessage = 'Die ausgewählte Bibliothek wurde nicht gefunden. Bitte überprüfen Sie die Bibliothekskonfiguration.';
          } else if (error.message.includes('Server-Fehler')) {
            errorMessage = 'Server-Fehler beim Laden der Dateien. Bitte überprüfen Sie, ob der Bibliothekspfad existiert und zugänglich ist.';
          } else if (error.message.includes('Keine aktive Bibliothek')) {
            errorMessage = 'Keine aktive Bibliothek verfügbar. Bitte wählen Sie eine Bibliothek aus.';
          } else {
            errorMessage = error.message;
          }
        }
        
        // Toast-Nachricht anzeigen
        toast({
          title: "Fehler beim Laden der Dateien",
          description: errorMessage,
          variant: "destructive",
        });
      }
      setFolderItems([]);
    } finally {
      setLoadingState({ isLoading: false, loadingFolderId: null });
      loadInFlightRef.current = false;
    }
  }, [
    currentFolderId,
    lastLoadedFolder,
    listItems,
    libraryState.folderCache,
    providerInstance,
    libraryStatus,
    setLibraryState,
    setFolderItems,
    setLastLoadedFolder,
    setLoadingState,
    toast,
    currentLibrary
  ]);

  // Effect für Initial-Load (entkoppelt vom FileTree)
  useEffect(() => {
    const isReady = !!providerInstance && libraryStatus === 'ready';
    
    if (!isReady) {
      NavigationLogger.debug('Library', 'Waiting for initialization', {
        hasProvider: !!providerInstance,
        status: libraryStatus
      });
      return;
    }

    // Wenn eine folderId in der URL steht und noch nicht angewendet wurde,
    // verhindere das initiale Laden von "root" (vermeidet Doppel-Load)
    const folderIdFromUrl = searchParams?.get('folderId');
    if (!urlInitAppliedRef.current && folderIdFromUrl && folderIdFromUrl !== currentFolderId) {
      NavigationLogger.debug('debug@init', 'Skip initial root load; URL folderId pending', {
        folderIdFromUrl,
        currentFolderId,
        lastLoadedFolder
      });
      return;
    }

    // Nur laden wenn noch nicht geladen
    if (lastLoadedFolder !== currentFolderId && !loadInFlightRef.current) {
      UILogger.info('Library', 'Initial load triggered', {
        currentFolderId,
        lastLoadedFolder,
        tSinceMountMs: startupT0Ref.current ? Number((performance.now() - startupT0Ref.current).toFixed(1)) : undefined
      });
      NavigationLogger.info('Library', 'Loading initial items', {
        folderId: currentFolderId
      });
      loadItems();
    }
  }, [providerInstance, libraryStatus, currentFolderId, lastLoadedFolder, activeLibraryId, loadItems, searchParams]);

  // Zusätzlicher Reset bei Bibliothekswechsel (robust gegen Status-Race)
  useEffect(() => {
    if (!activeLibraryId) return;
    StateLogger.info('Library', 'Active library changed - reset initial load state', {
      activeLibraryId,
      currentFolderId
    });
    setLastLoadedFolder(null);
    setFolderItems([]);
    setLibraryState(state => ({ ...state, folderCache: {} }));
    // WICHTIG: Ordnerauswahl und Shadow-Twin zurücksetzen
    setSelectedFile(null);
    setSelectedShadowTwin(null);
  }, [activeLibraryId, setLastLoadedFolder, setFolderItems, setLibraryState, currentFolderId]);

  // Reset Cache wenn sich die Library ändert
  useEffect(() => {
    setLastLoadedFolder(null);
    setLibraryState(state => ({
      ...state,
      folderCache: {}
    }));
  }, [libraryStatus, setLibraryState, setLastLoadedFolder]);

  // Manuelle Cache-Clear-Funktion für Review-Modus
  const clearCache = useCallback(() => {
    StateLogger.info('Library', 'Manually clearing cache for review mode');
    setLastLoadedFolder(null);
    setLibraryState(state => ({
      ...state,
      folderCache: {}
    }));
    setFolderItems([]);
  }, [setLibraryState, setLastLoadedFolder, setFolderItems]);

  // Reset selectedShadowTwin wenn Review-Modus verlassen wird
  useEffect(() => {
    if (!isReviewMode) {
      setSelectedShadowTwin(null);
    }
  }, [isReviewMode, setSelectedShadowTwin]);

  // ENTFERNT: Der folgende useEffect war problematisch und hat das Shadow-Twin 
  // bei jedem Klick zurückgesetzt, auch wenn die Datei ein Shadow-Twin hat.
  // Die Shadow-Twin-Logik wird bereits korrekt in der FileList-Komponente 
  // in der handleSelect-Funktion behandelt.

  // Render-Logik für verschiedene Status
  if (libraryStatus === "waitingForAuth") {
    return (
      <div className="flex flex-col items-center justify-center h-full text-muted-foreground">
        <span>Diese Bibliothek benötigt eine Authentifizierung.</span>
        <span className="text-sm mt-2">Bitte konfigurieren Sie die Bibliothek in den Einstellungen.</span>
      </div>
    );
  }
  
  if (libraryStatus !== "ready") {
    return (
      <div className="flex flex-col items-center justify-center h-full text-muted-foreground">
        <span>Lade Storage...</span>
      </div>
    );
  }

  return (
    <div className="flex flex-col h-full">
      <LibraryHeader
        provider={providerInstance}
        error={storageError}
        onUploadComplete={loadItems}
        onClearCache={clearCache}
        isTreeVisible={isTreeVisible}
        onToggleTree={() => setIsTreeVisible(v => !v)}
        isCompactList={isListCompact}
        onToggleCompactList={() => setIsListCompact(v => !v)}
      >
        <Breadcrumb />
      </LibraryHeader>
      
      <div className="flex-1 min-h-0 overflow-hidden">
        {isReviewMode ? (
          // Review-Layout: 3 Panels ohne FileTree - FileList (compact) | FilePreview (Basis-Datei) | FilePreview (Shadow-Twin)
          <ResizablePanelGroup direction="horizontal" className="h-full">
            <ResizablePanel defaultSize={25} minSize={20} className="min-h-0">
              <div className="h-full overflow-auto flex flex-col">
                <FileList compact={true} />
              </div>
            </ResizablePanel>
            <ResizableHandle />
            <ResizablePanel defaultSize={37.5} minSize={30} className="min-h-0">
              <div className="h-full relative flex flex-col">
                {selectedFile ? (
                  <FilePreviewLazy
                    provider={providerInstance}
                    file={selectedFile}
                    onRefreshFolder={(folderId, items, selectFileAfterRefresh) => {
                    StateLogger.info('Library', 'FilePreview (Basis) onRefreshFolder aufgerufen', {
                      folderId,
                      itemsCount: items.length,
                      hasSelectFile: !!selectFileAfterRefresh
                    });
                    
                    // Aktualisiere die Dateiliste
                    setFolderItems(items);
                    
                    // Aktualisiere den Cache
                    if (libraryState.folderCache?.[folderId]) {
                      const cachedFolder = libraryState.folderCache[folderId];
                      if (cachedFolder) {
                        setLibraryState(state => ({
                          ...state,
                          folderCache: {
                            ...(state.folderCache || {}),
                            [folderId]: {
                              ...cachedFolder,
                              children: items
                            }
                          }
                        }));
                      }
                    }
                    
                    // Wenn eine Datei ausgewählt werden soll (nach dem Speichern)
                    if (selectFileAfterRefresh) {
                      StateLogger.info('Library', 'Wähle gespeicherte Datei aus', {
                        fileId: selectFileAfterRefresh.id,
                        fileName: selectFileAfterRefresh.metadata.name
                      });
                    }
                    }}
                  />
                ) : (
                  <div className="h-full flex items-center justify-center text-muted-foreground">
                    <p>Keine Datei ausgewählt</p>
                  </div>
                )}
              </div>
            </ResizablePanel>
            <ResizableHandle />
            <ResizablePanel defaultSize={37.5} minSize={30} className="min-h-0">
              <div className="h-full relative flex flex-col">
                {selectedShadowTwin ? (
                  <FilePreviewLazy
                    provider={providerInstance}
                    file={selectedShadowTwin}
                    onRefreshFolder={(folderId, items, selectFileAfterRefresh) => {
                      StateLogger.info('Library', 'FilePreview (Shadow-Twin) onRefreshFolder aufgerufen', {
                        folderId,
                        itemsCount: items.length,
                        hasSelectFile: !!selectFileAfterRefresh
                      });
                      
                      // Aktualisiere die Dateiliste
                      setFolderItems(items);
                      
                      // Aktualisiere den Cache
                      if (libraryState.folderCache?.[folderId]) {
                        const cachedFolder = libraryState.folderCache[folderId];
                        if (cachedFolder) {
                          setLibraryState(state => ({
                            ...state,
                            folderCache: {
                              ...(state.folderCache || {}),
                              [folderId]: {
                                ...cachedFolder,
                                children: items
                              }
                            }
                          }));
                        }
                      }
                      
                      // Wenn eine Datei ausgewählt werden soll (nach dem Speichern)
                      if (selectFileAfterRefresh) {
                        StateLogger.info('Library', 'Wähle gespeicherte Datei aus', {
                          fileId: selectFileAfterRefresh.id,
                          fileName: selectFileAfterRefresh.metadata.name
                        });
                      }
                    }}
                  />
                ) : (
                  <div className="h-full flex items-center justify-center text-muted-foreground">
                    <p>Kein Shadow-Twin ausgewählt</p>
                  </div>
                )}
              </div>
            </ResizablePanel>
          </ResizablePanelGroup>
        ) : (
          // Normal-Layout (Desktop) oder alternierendes Mobile-Layout
          <div className="relative h-full">
            {/* Entfernt: alter Tree-Handle (ersetzt durch Header-Toggle) */}

            {isMobile ? (
              mobileView === 'list' ? (
                <div className="h-full overflow-auto flex flex-col">
                  <FileList />
                </div>
              ) : (
                <div className="h-full flex flex-col">
                  <div className="flex items-center gap-2 p-2 border-b bg-background">
                    <button
                      type="button"
                      className="inline-flex items-center gap-1 text-sm px-2 py-1 border rounded-md"
                      onClick={() => {
                        setMobileView('list');
                        setSelectedShadowTwin(null);
                        setSelectedFile(null);
                        loadItems();
                      }}
                    >
                      <ChevronLeft className="h-4 w-4" />
                      Zurück
                    </button>
                    <div className="text-sm text-muted-foreground truncate">
                      {selectedFile?.metadata.name}
                    </div>
                  </div>
                  <div className="flex-1 min-h-0">
                    {selectedFile ? (
                      <FilePreviewLazy
                        provider={providerInstance}
                        onRefreshFolder={(folderId, items, selectFileAfterRefresh) => {
                        StateLogger.info('Library', 'FilePreview onRefreshFolder aufgerufen', {
                          folderId,
                          itemsCount: items.length,
                          hasSelectFile: !!selectFileAfterRefresh
                        });
                        setFolderItems(items);
                        if (libraryState.folderCache?.[folderId]) {
                          const cachedFolder = libraryState.folderCache[folderId];
                          if (cachedFolder) {
                            setLibraryState(state => ({
                              ...state,
                              folderCache: {
                                ...(state.folderCache || {}),
                                [folderId]: { ...cachedFolder, children: items }
                              }
                            }));
                          }
                        }
                        }}
                      />
                    ) : (
                      <div className="h-full flex items-center justify-center text-muted-foreground">
                        <p>Keine Datei ausgewählt</p>
                      </div>
                    )}
                  </div>
                </div>
              )
            ) : (
              <ResizablePanelGroup
                key={isTreeVisible ? 'with-tree' : 'no-tree'}
                direction="horizontal"
                className="h-full"
                autoSaveId={isTreeVisible ? "library-panels-3" : "library-panels-2"}
              >
                {isTreeVisible && (
                  <>
                    <ResizablePanel key="tree-panel" id="tree" defaultSize={18} minSize={12} className="min-h-0">
                      <div className="h-full overflow-auto flex flex-col">
                        <FileTree />
                      </div>
                    </ResizablePanel>
                    <ResizableHandle key="tree-handle" />
                  </>
                )}
                <>
                  <ResizablePanel key="list-panel" id="list" defaultSize={isListCompact ? (isTreeVisible ? 12 : 15) : (isTreeVisible ? 34 : 45)} minSize={isListCompact ? 10 : 25} className="min-h-0 transition-[flex-basis] duration-200 ease-in-out">
                    <div className="h-full overflow-auto flex flex-col">
                      <FileList compact={isListCompact} />
                    </div>
                  </ResizablePanel>
                  <ResizableHandle key="list-preview-handle" />
                </>
                <ResizablePanel key="preview-panel" id="preview" defaultSize={(() => {
                  const left = (isTreeVisible ? 18 : 0) + (isListCompact ? (isTreeVisible ? 12 : 15) : (isTreeVisible ? 34 : 45));
                  const rest = Math.max(10, 100 - left);
                  return rest;
                })()} className="min-h-0 transition-[flex-basis] duration-200 ease-in-out">
                  <div className="h-full relative flex flex-col">
                    {selectedFile ? (
                      <FilePreviewLazy
                        provider={providerInstance}
                        onRefreshFolder={(folderId, items, selectFileAfterRefresh) => {
                        StateLogger.info('Library', 'FilePreview onRefreshFolder aufgerufen', {
                          folderId,
                          itemsCount: items.length,
                          hasSelectFile: !!selectFileAfterRefresh
                        });
                        
                        // Aktualisiere die Dateiliste
                        setFolderItems(items);
                        
                        // Aktualisiere den Cache
                        if (libraryState.folderCache?.[folderId]) {
                          const cachedFolder = libraryState.folderCache[folderId];
                          if (cachedFolder) {
                            setLibraryState(state => ({
                              ...state,
                              folderCache: {
                                ...(state.folderCache || {}),
                                [folderId]: {
                                  ...cachedFolder,
                                  children: items
                                }
                              }
                            }));
                          }
                        }
                        
                        if (selectFileAfterRefresh) {
                          StateLogger.info('Library', 'Wähle gespeicherte Datei aus', {
                            fileId: selectFileAfterRefresh.id,
                            fileName: selectFileAfterRefresh.metadata.name
                          });
                        }
                        }}
                      />
                    ) : (
                      <div className="h-full flex items-center justify-center text-muted-foreground">
                        <p>Keine Datei ausgewählt</p>
                      </div>
                    )}
                  </div>
                </ResizablePanel>
              </ResizablePanelGroup>
            )}
          </div>
        )}
      </div>
      
      {/* Dialoge */}
      <TranscriptionDialog />
      <TransformationDialog 
        onRefreshFolder={(folderId: string, items: StorageItem[], selectFileAfterRefresh?: StorageItem) => {
          StateLogger.info('Library', 'TransformationDialog onRefreshFolder aufgerufen', {
            folderId,
            itemsCount: items.length,
            hasSelectFile: !!selectFileAfterRefresh
          });
          
          // Aktualisiere die Dateiliste
          setFolderItems(items);
          
          // Aktualisiere den Cache
          if (libraryState.folderCache?.[folderId]) {
            const cachedFolder = libraryState.folderCache[folderId];
            if (cachedFolder) {
              setLibraryState(state => ({
                ...state,
                folderCache: {
                  ...(state.folderCache || {}),
                  [folderId]: {
                    ...cachedFolder,
                    children: items
                  }
                }
              }));
            }
          }
          
          // Wenn eine Datei ausgewählt werden soll (nach dem Speichern)
          if (selectFileAfterRefresh) {
            StateLogger.info('Library', 'Wähle gespeicherte Datei aus', {
              fileId: selectFileAfterRefresh.id,
              fileName: selectFileAfterRefresh.metadata.name
            });
          }
        }}
      />
    </div>
  );
}
```

Erledigt:
- Button „Liste ausblenden“ aus der Toolbar entfernt.
- Toolbar zeigt jetzt nur:
  - Toggle FileTree
  - Toggle Listenansicht/Kompaktansicht
- Pane-Breiten bleiben dynamisch wie zuvor:
  - FileTree: 18%
  - FileList: 34%/45% normal, 12%/15% kompakt
  - Preview füllt den Rest.

---

**User**

Das mit der Paint-Breite funktioniert nicht. Wenn ich File-Tree ausblende und die File-Liste hat, den meisten Platz sollte wirklich nur ganz schmal sein. Und den meisten Platz sollte dieser Preview-Bereich bekommen.

---

**Cursor**

```typescriptreact
"use client"

import * as React from "react"
import { useCallback, useEffect } from "react"
import { useAtom, useAtomValue } from "jotai"

import { LibraryHeader } from "./library-header"
import { FileTree } from "./file-tree"
import { FileList } from "./file-list"
import dynamic from 'next/dynamic'
const FilePreviewLazy = dynamic(() => import('./file-preview').then(m => m.FilePreview), {
  ssr: false,
  loading: () => (
    <div className="h-full flex items-center justify-center text-muted-foreground">
      Lade Vorschau...
    </div>
  )
})
import { ResizableHandle, ResizablePanel, ResizablePanelGroup } from "@/components/ui/resizable"
import { 
  libraryAtom, 
  folderItemsAtom,
  loadingStateAtom,
  lastLoadedFolderAtom,
  currentFolderIdAtom,
  reviewModeAtom,
  selectedFileAtom,
  selectedShadowTwinAtom
} from "@/atoms/library-atom"
import { activeLibraryIdAtom } from "@/atoms/library-atom"
import { useStorage, isStorageError } from "@/contexts/storage-context"
import { TranscriptionDialog } from "./transcription-dialog"
import { TransformationDialog } from "./transformation-dialog"
import { StorageItem } from "@/lib/storage/types"
import { NavigationLogger, StateLogger, UILogger } from "@/lib/debug/logger"
import { Breadcrumb } from "./breadcrumb"
import { useToast } from "@/components/ui/use-toast"
import { ChevronLeft, ChevronRight } from "lucide-react"
import { useSearchParams } from "next/navigation"
import { useFolderNavigation } from "@/hooks/use-folder-navigation"
export function Library() {
  // Performance-Messung für Kaltstart (nur Client)
  const startupT0Ref = React.useRef<number>(
    typeof performance !== 'undefined' ? performance.now() : 0
  );
  // Globale Atoms
  const [, setFolderItems] = useAtom(folderItemsAtom);
  const [, setLoadingState] = useAtom(loadingStateAtom);
  const [lastLoadedFolder, setLastLoadedFolder] = useAtom(lastLoadedFolderAtom);
  const [currentFolderId] = useAtom(currentFolderIdAtom);
  const [libraryState, setLibraryState] = useAtom(libraryAtom);
  const activeLibraryId = useAtomValue(activeLibraryIdAtom);
  
  // Review-Mode Atoms
  const [isReviewMode] = useAtom(reviewModeAtom);
  const [selectedFile, setSelectedFile] = useAtom(selectedFileAtom);
  const [selectedShadowTwin, setSelectedShadowTwin] = useAtom(selectedShadowTwinAtom);
  
  // Storage Context
  const { 
    provider: providerInstance, 
    error: storageError, 
    listItems,
    libraryStatus,
    currentLibrary
  } = useStorage();
  const { toast } = useToast();
  const [isTreeVisible, setIsTreeVisible] = React.useState<boolean>(false);
  const [isListCompact, setIsListCompact] = React.useState<boolean>(false);
  const [isMobile, setIsMobile] = React.useState<boolean>(false);
  const [mobileView, setMobileView] = React.useState<'list' | 'preview'>('list');
  const loadInFlightRef = React.useRef<boolean>(false);
  const searchParams = useSearchParams();
  const navigateToFolder = useFolderNavigation();

  // Mobile: Tree standardmäßig ausblenden, Desktop: anzeigen
  React.useEffect(() => {
    if (typeof window === 'undefined') return;
    // Desktop ab 1024px, Mobile darunter
    const mq = window.matchMedia('(max-width: 1023px)');
    const apply = (matches: boolean) => {
      setIsMobile(matches);
      setIsTreeVisible(!matches);
    };
    apply(mq.matches);
    const handler = (e: MediaQueryListEvent) => apply(e.matches);
    mq.addEventListener('change', handler);
    return () => mq.removeEventListener('change', handler);
  }, []);

  // URL -> State: folderId aus Query anwenden, wenn Provider bereit ist
  const urlInitAppliedRef = React.useRef(false);
  React.useEffect(() => {
    const folderIdFromUrl = searchParams?.get('folderId');

    if (urlInitAppliedRef.current) return;

    if (!folderIdFromUrl) {
      NavigationLogger.debug('debug@init', 'No folderId in URL', {
        currentFolderId
      });
      urlInitAppliedRef.current = true;
      return;
    }

    if (!providerInstance || libraryStatus !== 'ready') {
      NavigationLogger.debug('debug@init', 'Provider not ready, deferring URL apply', {
        folderIdFromUrl,
        libraryStatus,
        hasProvider: !!providerInstance
      });
      return;
    }

    if (folderIdFromUrl !== currentFolderId) {
      NavigationLogger.info('debug@init', 'Applying folderId from URL (ready)', {
        folderIdFromUrl,
        currentFolderId
      });
      void navigateToFolder(folderIdFromUrl);
    }
    urlInitAppliedRef.current = true;
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [searchParams, providerInstance, libraryStatus, currentFolderId]);

  // Mobile-View Wechsellogik: bei Dateiauswahl zur Vorschau wechseln
  React.useEffect(() => {
    if (!isMobile) return;
    if (selectedFile) setMobileView('preview');
  }, [isMobile, selectedFile]);

  // Optimierter loadItems mit Cache-Check
  const loadItems = useCallback(async () => {
    if (loadInFlightRef.current) {
      NavigationLogger.debug('Library', 'Skip loadItems - load already in flight');
      return;
    }
    if (!providerInstance || libraryStatus !== 'ready') {
      NavigationLogger.debug('Library', 'Skipping loadItems - not ready', {
        hasProvider: !!providerInstance,
        status: libraryStatus
      });
      return;
    }

    // Schutz: Wenn Provider/Context noch auf alte Library zeigt, keine Items übernehmen
    if (currentLibrary?.id && currentLibrary.id !== activeLibraryId) {
      NavigationLogger.debug('Library', 'Skip loadItems - library mismatch', {
        providerLibraryId: currentLibrary.id,
        activeLibraryId
      });
      return;
    }

    loadInFlightRef.current = true;
    setLoadingState({ isLoading: true, loadingFolderId: currentFolderId });

    try {
      // Snapshot zur Vermeidung von Race-Conditions
      const expectedLibraryId = activeLibraryId;
      const expectedFolderId = currentFolderId;

      // Prüfe Cache zuerst
      if (libraryState.folderCache?.[currentFolderId]?.children) {
        const cachedItems = libraryState.folderCache[currentFolderId].children;
        NavigationLogger.info('Library', 'Using cached items', {
          folderId: currentFolderId,
          itemCount: cachedItems.length,
          cacheHit: true
        });
        // Übernehme nur, wenn der Snapshot noch aktuell ist
        if (expectedLibraryId === activeLibraryId && expectedFolderId === currentFolderId) {
          setFolderItems(cachedItems);
          setLastLoadedFolder(currentFolderId);
        }
        return;
      }

      NavigationLogger.info('Library', 'Fetching items from provider', {
        folderId: currentFolderId,
        cacheHit: false
      });
      
      const items = await listItems(currentFolderId);

      // Falls während des Ladens die Library oder der Ordner wechselte: Ergebnis verwerfen
      if (expectedLibraryId !== activeLibraryId || expectedFolderId !== currentFolderId) {
        NavigationLogger.debug('Library', 'Discard loaded items due to context change', {
          expectedLibraryId,
          activeLibraryId,
          expectedFolderId,
          currentFolderId
        });
        return;
      }
      
      // Update Cache und State
      if (currentFolderId !== 'root') {
        const newFolderCache = { ...libraryState.folderCache };
        const parent = newFolderCache[currentFolderId];
        if (parent) {
          newFolderCache[currentFolderId] = {
            ...parent,
            children: items
          };
          StateLogger.info('Library', 'Updating folder cache', {
            folderId: currentFolderId,
            itemCount: items.length,
            cacheSize: Object.keys(newFolderCache).length
          });
          setLibraryState(state => ({
            ...state,
            folderCache: newFolderCache
          }));
        }
      }
      
      setFolderItems(items);
      setLastLoadedFolder(currentFolderId);
      
      StateLogger.info('Library', 'Items loaded successfully', {
        folderId: currentFolderId,
        itemCount: items.length,
        fileCount: items.filter(i => i.type === 'file').length,
        folderCount: items.filter(i => i.type === 'folder').length,
        tSinceMountMs: startupT0Ref.current ? Number((performance.now() - startupT0Ref.current).toFixed(1)) : undefined
      });
      
    } catch (error) {
      if (isStorageError(error) && error.code === 'AUTH_REQUIRED') {
        StateLogger.info('Library', 'Auth required');
        // Keine Fehlermeldung für AUTH_REQUIRED anzeigen
      } else {
        StateLogger.error('Library', 'Failed to load items', {
          error: error instanceof Error ? {
            message: error.message,
            name: error.name,
            stack: error.stack?.split('\n').slice(0, 3)
          } : error,
          folderId: currentFolderId,
          libraryId: currentLibrary?.id,
          libraryPath: currentLibrary?.path
        });
        
        // Benutzerfreundliche Fehlermeldung anzeigen
        let errorMessage = 'Fehler beim Laden der Dateien';
        
        if (error instanceof Error) {
          if (error.message.includes('Nicht authentifiziert')) {
            errorMessage = 'Bitte authentifizieren Sie sich bei Ihrem Cloud-Speicher.';
          } else if (error.message.includes('Bibliothek nicht gefunden')) {
            errorMessage = 'Die ausgewählte Bibliothek wurde nicht gefunden. Bitte überprüfen Sie die Bibliothekskonfiguration.';
          } else if (error.message.includes('Server-Fehler')) {
            errorMessage = 'Server-Fehler beim Laden der Dateien. Bitte überprüfen Sie, ob der Bibliothekspfad existiert und zugänglich ist.';
          } else if (error.message.includes('Keine aktive Bibliothek')) {
            errorMessage = 'Keine aktive Bibliothek verfügbar. Bitte wählen Sie eine Bibliothek aus.';
          } else {
            errorMessage = error.message;
          }
        }
        
        // Toast-Nachricht anzeigen
        toast({
          title: "Fehler beim Laden der Dateien",
          description: errorMessage,
          variant: "destructive",
        });
      }
      setFolderItems([]);
    } finally {
      setLoadingState({ isLoading: false, loadingFolderId: null });
      loadInFlightRef.current = false;
    }
  }, [
    currentFolderId,
    lastLoadedFolder,
    listItems,
    libraryState.folderCache,
    providerInstance,
    libraryStatus,
    setLibraryState,
    setFolderItems,
    setLastLoadedFolder,
    setLoadingState,
    toast,
    currentLibrary
  ]);

  // Effect für Initial-Load (entkoppelt vom FileTree)
  useEffect(() => {
    const isReady = !!providerInstance && libraryStatus === 'ready';
    
    if (!isReady) {
      NavigationLogger.debug('Library', 'Waiting for initialization', {
        hasProvider: !!providerInstance,
        status: libraryStatus
      });
      return;
    }

    // Wenn eine folderId in der URL steht und noch nicht angewendet wurde,
    // verhindere das initiale Laden von "root" (vermeidet Doppel-Load)
    const folderIdFromUrl = searchParams?.get('folderId');
    if (!urlInitAppliedRef.current && folderIdFromUrl && folderIdFromUrl !== currentFolderId) {
      NavigationLogger.debug('debug@init', 'Skip initial root load; URL folderId pending', {
        folderIdFromUrl,
        currentFolderId,
        lastLoadedFolder
      });
      return;
    }

    // Nur laden wenn noch nicht geladen
    if (lastLoadedFolder !== currentFolderId && !loadInFlightRef.current) {
      UILogger.info('Library', 'Initial load triggered', {
        currentFolderId,
        lastLoadedFolder,
        tSinceMountMs: startupT0Ref.current ? Number((performance.now() - startupT0Ref.current).toFixed(1)) : undefined
      });
      NavigationLogger.info('Library', 'Loading initial items', {
        folderId: currentFolderId
      });
      loadItems();
    }
  }, [providerInstance, libraryStatus, currentFolderId, lastLoadedFolder, activeLibraryId, loadItems, searchParams]);

  // Zusätzlicher Reset bei Bibliothekswechsel (robust gegen Status-Race)
  useEffect(() => {
    if (!activeLibraryId) return;
    StateLogger.info('Library', 'Active library changed - reset initial load state', {
      activeLibraryId,
      currentFolderId
    });
    setLastLoadedFolder(null);
    setFolderItems([]);
    setLibraryState(state => ({ ...state, folderCache: {} }));
    // WICHTIG: Ordnerauswahl und Shadow-Twin zurücksetzen
    setSelectedFile(null);
    setSelectedShadowTwin(null);
  }, [activeLibraryId, setLastLoadedFolder, setFolderItems, setLibraryState, currentFolderId]);

  // Reset Cache wenn sich die Library ändert
  useEffect(() => {
    setLastLoadedFolder(null);
    setLibraryState(state => ({
      ...state,
      folderCache: {}
    }));
  }, [libraryStatus, setLibraryState, setLastLoadedFolder]);

  // Manuelle Cache-Clear-Funktion für Review-Modus
  const clearCache = useCallback(() => {
    StateLogger.info('Library', 'Manually clearing cache for review mode');
    setLastLoadedFolder(null);
    setLibraryState(state => ({
      ...state,
      folderCache: {}
    }));
    setFolderItems([]);
  }, [setLibraryState, setLastLoadedFolder, setFolderItems]);

  // Reset selectedShadowTwin wenn Review-Modus verlassen wird
  useEffect(() => {
    if (!isReviewMode) {
      setSelectedShadowTwin(null);
    }
  }, [isReviewMode, setSelectedShadowTwin]);

  // ENTFERNT: Der folgende useEffect war problematisch und hat das Shadow-Twin 
  // bei jedem Klick zurückgesetzt, auch wenn die Datei ein Shadow-Twin hat.
  // Die Shadow-Twin-Logik wird bereits korrekt in der FileList-Komponente 
  // in der handleSelect-Funktion behandelt.

  // Render-Logik für verschiedene Status
  if (libraryStatus === "waitingForAuth") {
    return (
      <div className="flex flex-col items-center justify-center h-full text-muted-foreground">
        <span>Diese Bibliothek benötigt eine Authentifizierung.</span>
        <span className="text-sm mt-2">Bitte konfigurieren Sie die Bibliothek in den Einstellungen.</span>
      </div>
    );
  }
  
  if (libraryStatus !== "ready") {
    return (
      <div className="flex flex-col items-center justify-center h-full text-muted-foreground">
        <span>Lade Storage...</span>
      </div>
    );
  }

  return (
    <div className="flex flex-col h-full">
      <LibraryHeader
        provider={providerInstance}
        error={storageError}
        onUploadComplete={loadItems}
        onClearCache={clearCache}
        isTreeVisible={isTreeVisible}
        onToggleTree={() => setIsTreeVisible(v => !v)}
        isCompactList={isListCompact}
        onToggleCompactList={() => setIsListCompact(v => !v)}
      >
        <Breadcrumb />
      </LibraryHeader>
      
      <div className="flex-1 min-h-0 overflow-hidden">
        {isReviewMode ? (
          // Review-Layout: 3 Panels ohne FileTree - FileList (compact) | FilePreview (Basis-Datei) | FilePreview (Shadow-Twin)
          <ResizablePanelGroup direction="horizontal" className="h-full">
            <ResizablePanel defaultSize={25} minSize={20} className="min-h-0">
              <div className="h-full overflow-auto flex flex-col">
                <FileList compact={true} />
              </div>
            </ResizablePanel>
            <ResizableHandle />
            <ResizablePanel defaultSize={37.5} minSize={30} className="min-h-0">
              <div className="h-full relative flex flex-col">
                {selectedFile ? (
                  <FilePreviewLazy
                    provider={providerInstance}
                    file={selectedFile}
                    onRefreshFolder={(folderId, items, selectFileAfterRefresh) => {
                    StateLogger.info('Library', 'FilePreview (Basis) onRefreshFolder aufgerufen', {
                      folderId,
                      itemsCount: items.length,
                      hasSelectFile: !!selectFileAfterRefresh
                    });
                    
                    // Aktualisiere die Dateiliste
                    setFolderItems(items);
                    
                    // Aktualisiere den Cache
                    if (libraryState.folderCache?.[folderId]) {
                      const cachedFolder = libraryState.folderCache[folderId];
                      if (cachedFolder) {
                        setLibraryState(state => ({
                          ...state,
                          folderCache: {
                            ...(state.folderCache || {}),
                            [folderId]: {
                              ...cachedFolder,
                              children: items
                            }
                          }
                        }));
                      }
                    }
                    
                    // Wenn eine Datei ausgewählt werden soll (nach dem Speichern)
                    if (selectFileAfterRefresh) {
                      StateLogger.info('Library', 'Wähle gespeicherte Datei aus', {
                        fileId: selectFileAfterRefresh.id,
                        fileName: selectFileAfterRefresh.metadata.name
                      });
                    }
                    }}
                  />
                ) : (
                  <div className="h-full flex items-center justify-center text-muted-foreground">
                    <p>Keine Datei ausgewählt</p>
                  </div>
                )}
              </div>
            </ResizablePanel>
            <ResizableHandle />
            <ResizablePanel defaultSize={37.5} minSize={30} className="min-h-0">
              <div className="h-full relative flex flex-col">
                {selectedShadowTwin ? (
                  <FilePreviewLazy
                    provider={providerInstance}
                    file={selectedShadowTwin}
                    onRefreshFolder={(folderId, items, selectFileAfterRefresh) => {
                      StateLogger.info('Library', 'FilePreview (Shadow-Twin) onRefreshFolder aufgerufen', {
                        folderId,
                        itemsCount: items.length,
                        hasSelectFile: !!selectFileAfterRefresh
                      });
                      
                      // Aktualisiere die Dateiliste
                      setFolderItems(items);
                      
                      // Aktualisiere den Cache
                      if (libraryState.folderCache?.[folderId]) {
                        const cachedFolder = libraryState.folderCache[folderId];
                        if (cachedFolder) {
                          setLibraryState(state => ({
                            ...state,
                            folderCache: {
                              ...(state.folderCache || {}),
                              [folderId]: {
                                ...cachedFolder,
                                children: items
                              }
                            }
                          }));
                        }
                      }
                      
                      // Wenn eine Datei ausgewählt werden soll (nach dem Speichern)
                      if (selectFileAfterRefresh) {
                        StateLogger.info('Library', 'Wähle gespeicherte Datei aus', {
                          fileId: selectFileAfterRefresh.id,
                          fileName: selectFileAfterRefresh.metadata.name
                        });
                      }
                    }}
                  />
                ) : (
                  <div className="h-full flex items-center justify-center text-muted-foreground">
                    <p>Kein Shadow-Twin ausgewählt</p>
                  </div>
                )}
              </div>
            </ResizablePanel>
          </ResizablePanelGroup>
        ) : (
          // Normal-Layout (Desktop) oder alternierendes Mobile-Layout
          <div className="relative h-full">
            {/* Entfernt: alter Tree-Handle (ersetzt durch Header-Toggle) */}

            {isMobile ? (
              mobileView === 'list' ? (
                <div className="h-full overflow-auto flex flex-col">
                  <FileList />
                </div>
              ) : (
                <div className="h-full flex flex-col">
                  <div className="flex items-center gap-2 p-2 border-b bg-background">
                    <button
                      type="button"
                      className="inline-flex items-center gap-1 text-sm px-2 py-1 border rounded-md"
                      onClick={() => {
                        setMobileView('list');
                        setSelectedShadowTwin(null);
                        setSelectedFile(null);
                        loadItems();
                      }}
                    >
                      <ChevronLeft className="h-4 w-4" />
                      Zurück
                    </button>
                    <div className="text-sm text-muted-foreground truncate">
                      {selectedFile?.metadata.name}
                    </div>
                  </div>
                  <div className="flex-1 min-h-0">
                    {selectedFile ? (
                      <FilePreviewLazy
                        provider={providerInstance}
                        onRefreshFolder={(folderId, items, selectFileAfterRefresh) => {
                        StateLogger.info('Library', 'FilePreview onRefreshFolder aufgerufen', {
                          folderId,
                          itemsCount: items.length,
                          hasSelectFile: !!selectFileAfterRefresh
                        });
                        setFolderItems(items);
                        if (libraryState.folderCache?.[folderId]) {
                          const cachedFolder = libraryState.folderCache[folderId];
                          if (cachedFolder) {
                            setLibraryState(state => ({
                              ...state,
                              folderCache: {
                                ...(state.folderCache || {}),
                                [folderId]: { ...cachedFolder, children: items }
                              }
                            }));
                          }
                        }
                        }}
                      />
                    ) : (
                      <div className="h-full flex items-center justify-center text-muted-foreground">
                        <p>Keine Datei ausgewählt</p>
                      </div>
                    )}
                  </div>
                </div>
              )
            ) : (
              <ResizablePanelGroup
                key={`layout-${isTreeVisible ? 'tree' : 'notree'}-${isListCompact ? 'compact' : 'list'}`}
                direction="horizontal"
                className="h-full"
                autoSaveId={`library-panels-${isTreeVisible ? '3' : '2'}-${isListCompact ? 'c' : 'n'}`}
              >
                {isTreeVisible && (
                  <>
                    <ResizablePanel key="tree-panel" id="tree" defaultSize={18} minSize={12} className="min-h-0">
                      <div className="h-full overflow-auto flex flex-col">
                        <FileTree />
                      </div>
                    </ResizablePanel>
                    <ResizableHandle key="tree-handle" />
                  </>
                )}
                <>
                  <ResizablePanel key="list-panel" id="list" defaultSize={(() => {
                    const normal = isTreeVisible ? 30 : 25;
                    const compact = 10;
                    return isListCompact ? compact : normal;
                  })()} minSize={isListCompact ? 8 : 20} className="min-h-0 transition-[flex-basis] duration-200 ease-in-out">
                    <div className="h-full overflow-auto flex flex-col">
                      <FileList compact={isListCompact} />
                    </div>
                  </ResizablePanel>
                  <ResizableHandle key="list-preview-handle" />
                </>
                <ResizablePanel key="preview-panel" id="preview" defaultSize={(() => {
                  const tree = isTreeVisible ? 18 : 0;
                  const list = isListCompact ? 10 : (isTreeVisible ? 30 : 25);
                  const rest = Math.max(10, 100 - (tree + list));
                  return rest;
                })()} className="min-h-0 transition-[flex-basis] duration-200 ease-in-out">
                  <div className="h-full relative flex flex-col">
                    {selectedFile ? (
                      <FilePreviewLazy
                        provider={providerInstance}
                        onRefreshFolder={(folderId, items, selectFileAfterRefresh) => {
                        StateLogger.info('Library', 'FilePreview onRefreshFolder aufgerufen', {
                          folderId,
                          itemsCount: items.length,
                          hasSelectFile: !!selectFileAfterRefresh
                        });
                        
                        // Aktualisiere die Dateiliste
                        setFolderItems(items);
                        
                        // Aktualisiere den Cache
                        if (libraryState.folderCache?.[folderId]) {
                          const cachedFolder = libraryState.folderCache[folderId];
                          if (cachedFolder) {
                            setLibraryState(state => ({
                              ...state,
                              folderCache: {
                                ...(state.folderCache || {}),
                                [folderId]: {
                                  ...cachedFolder,
                                  children: items
                                }
                              }
                            }));
                          }
                        }
                        
                        if (selectFileAfterRefresh) {
                          StateLogger.info('Library', 'Wähle gespeicherte Datei aus', {
                            fileId: selectFileAfterRefresh.id,
                            fileName: selectFileAfterRefresh.metadata.name
                          });
                        }
                        }}
                      />
                    ) : (
                      <div className="h-full flex items-center justify-center text-muted-foreground">
                        <p>Keine Datei ausgewählt</p>
                      </div>
                    )}
                  </div>
                </ResizablePanel>
              </ResizablePanelGroup>
            )}
          </div>
        )}
      </div>
      
      {/* Dialoge */}
      <TranscriptionDialog />
      <TransformationDialog 
        onRefreshFolder={(folderId: string, items: StorageItem[], selectFileAfterRefresh?: StorageItem) => {
          StateLogger.info('Library', 'TransformationDialog onRefreshFolder aufgerufen', {
            folderId,
            itemsCount: items.length,
            hasSelectFile: !!selectFileAfterRefresh
          });
          
          // Aktualisiere die Dateiliste
          setFolderItems(items);
          
          // Aktualisiere den Cache
          if (libraryState.folderCache?.[folderId]) {
            const cachedFolder = libraryState.folderCache[folderId];
            if (cachedFolder) {
              setLibraryState(state => ({
                ...state,
                folderCache: {
                  ...(state.folderCache || {}),
                  [folderId]: {
                    ...cachedFolder,
                    children: items
                  }
                }
              }));
            }
          }
          
          // Wenn eine Datei ausgewählt werden soll (nach dem Speichern)
          if (selectFileAfterRefresh) {
            StateLogger.info('Library', 'Wähle gespeicherte Datei aus', {
              fileId: selectFileAfterRefresh.id,
              fileName: selectFileAfterRefresh.metadata.name
            });
          }
        }}
      />
    </div>
  );
}
```

Ich habe die Breitenlogik korrigiert, sodass der Preview‑Bereich stets maximalen Platz bekommt:

- Neue Defaultgrößen
  - Tree: 18% (wenn sichtbar)
  - FileList: normal 30% mit Tree bzw. 25% ohne Tree; kompakt immer 10%
  - Preview: Rest (100% − Tree − List), mit Mindestrest 10%
- Pane-Group-Key/autoSaveId berücksichtigen Tree/Kompakt, damit gespeicherte Größen nicht aus alten Layouts übernommen werden.
- Sanfte Transition beim Umschalten bleibt.

Bitte erneut testen:
- Tree aus, List kompakt: Liste ≈10%, Preview ≈90%.
- Tree aus, List normal: Liste ≈25%, Preview ≈75%.
- Tree an, List kompakt: Tree 18% + Liste 10% + Preview ≈72%.
- Tree an, List normal: Tree 18% + Liste 30% + Preview ≈52%.

---

**User**

Filetree immer 15% wenn sichtbar
FileList normal immer 30%, 
FileList kompakt immer 15%

---

**Cursor**

```typescriptreact
"use client"

import * as React from "react"
import { useCallback, useEffect } from "react"
import { useAtom, useAtomValue } from "jotai"

import { LibraryHeader } from "./library-header"
import { FileTree } from "./file-tree"
import { FileList } from "./file-list"
import dynamic from 'next/dynamic'
const FilePreviewLazy = dynamic(() => import('./file-preview').then(m => m.FilePreview), {
  ssr: false,
  loading: () => (
    <div className="h-full flex items-center justify-center text-muted-foreground">
      Lade Vorschau...
    </div>
  )
})
import { ResizableHandle, ResizablePanel, ResizablePanelGroup } from "@/components/ui/resizable"
import { 
  libraryAtom, 
  folderItemsAtom,
  loadingStateAtom,
  lastLoadedFolderAtom,
  currentFolderIdAtom,
  reviewModeAtom,
  selectedFileAtom,
  selectedShadowTwinAtom
} from "@/atoms/library-atom"
import { activeLibraryIdAtom } from "@/atoms/library-atom"
import { useStorage, isStorageError } from "@/contexts/storage-context"
import { TranscriptionDialog } from "./transcription-dialog"
import { TransformationDialog } from "./transformation-dialog"
import { StorageItem } from "@/lib/storage/types"
import { NavigationLogger, StateLogger, UILogger } from "@/lib/debug/logger"
import { Breadcrumb } from "./breadcrumb"
import { useToast } from "@/components/ui/use-toast"
import { ChevronLeft, ChevronRight } from "lucide-react"
import { useSearchParams } from "next/navigation"
import { useFolderNavigation } from "@/hooks/use-folder-navigation"
export function Library() {
  // Performance-Messung für Kaltstart (nur Client)
  const startupT0Ref = React.useRef<number>(
    typeof performance !== 'undefined' ? performance.now() : 0
  );
  // Globale Atoms
  const [, setFolderItems] = useAtom(folderItemsAtom);
  const [, setLoadingState] = useAtom(loadingStateAtom);
  const [lastLoadedFolder, setLastLoadedFolder] = useAtom(lastLoadedFolderAtom);
  const [currentFolderId] = useAtom(currentFolderIdAtom);
  const [libraryState, setLibraryState] = useAtom(libraryAtom);
  const activeLibraryId = useAtomValue(activeLibraryIdAtom);
  
  // Review-Mode Atoms
  const [isReviewMode] = useAtom(reviewModeAtom);
  const [selectedFile, setSelectedFile] = useAtom(selectedFileAtom);
  const [selectedShadowTwin, setSelectedShadowTwin] = useAtom(selectedShadowTwinAtom);
  
  // Storage Context
  const { 
    provider: providerInstance, 
    error: storageError, 
    listItems,
    libraryStatus,
    currentLibrary
  } = useStorage();
  const { toast } = useToast();
  const [isTreeVisible, setIsTreeVisible] = React.useState<boolean>(false);
  const [isListCompact, setIsListCompact] = React.useState<boolean>(false);
  const [isMobile, setIsMobile] = React.useState<boolean>(false);
  const [mobileView, setMobileView] = React.useState<'list' | 'preview'>('list');
  const loadInFlightRef = React.useRef<boolean>(false);
  const searchParams = useSearchParams();
  const navigateToFolder = useFolderNavigation();

  // Mobile: Tree standardmäßig ausblenden, Desktop: anzeigen
  React.useEffect(() => {
    if (typeof window === 'undefined') return;
    // Desktop ab 1024px, Mobile darunter
    const mq = window.matchMedia('(max-width: 1023px)');
    const apply = (matches: boolean) => {
      setIsMobile(matches);
      setIsTreeVisible(!matches);
    };
    apply(mq.matches);
    const handler = (e: MediaQueryListEvent) => apply(e.matches);
    mq.addEventListener('change', handler);
    return () => mq.removeEventListener('change', handler);
  }, []);

  // URL -> State: folderId aus Query anwenden, wenn Provider bereit ist
  const urlInitAppliedRef = React.useRef(false);
  React.useEffect(() => {
    const folderIdFromUrl = searchParams?.get('folderId');

    if (urlInitAppliedRef.current) return;

    if (!folderIdFromUrl) {
      NavigationLogger.debug('debug@init', 'No folderId in URL', {
        currentFolderId
      });
      urlInitAppliedRef.current = true;
      return;
    }

    if (!providerInstance || libraryStatus !== 'ready') {
      NavigationLogger.debug('debug@init', 'Provider not ready, deferring URL apply', {
        folderIdFromUrl,
        libraryStatus,
        hasProvider: !!providerInstance
      });
      return;
    }

    if (folderIdFromUrl !== currentFolderId) {
      NavigationLogger.info('debug@init', 'Applying folderId from URL (ready)', {
        folderIdFromUrl,
        currentFolderId
      });
      void navigateToFolder(folderIdFromUrl);
    }
    urlInitAppliedRef.current = true;
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [searchParams, providerInstance, libraryStatus, currentFolderId]);

  // Mobile-View Wechsellogik: bei Dateiauswahl zur Vorschau wechseln
  React.useEffect(() => {
    if (!isMobile) return;
    if (selectedFile) setMobileView('preview');
  }, [isMobile, selectedFile]);

  // Optimierter loadItems mit Cache-Check
  const loadItems = useCallback(async () => {
    if (loadInFlightRef.current) {
      NavigationLogger.debug('Library', 'Skip loadItems - load already in flight');
      return;
    }
    if (!providerInstance || libraryStatus !== 'ready') {
      NavigationLogger.debug('Library', 'Skipping loadItems - not ready', {
        hasProvider: !!providerInstance,
        status: libraryStatus
      });
      return;
    }

    // Schutz: Wenn Provider/Context noch auf alte Library zeigt, keine Items übernehmen
    if (currentLibrary?.id && currentLibrary.id !== activeLibraryId) {
      NavigationLogger.debug('Library', 'Skip loadItems - library mismatch', {
        providerLibraryId: currentLibrary.id,
        activeLibraryId
      });
      return;
    }

    loadInFlightRef.current = true;
    setLoadingState({ isLoading: true, loadingFolderId: currentFolderId });

    try {
      // Snapshot zur Vermeidung von Race-Conditions
      const expectedLibraryId = activeLibraryId;
      const expectedFolderId = currentFolderId;

      // Prüfe Cache zuerst
      if (libraryState.folderCache?.[currentFolderId]?.children) {
        const cachedItems = libraryState.folderCache[currentFolderId].children;
        NavigationLogger.info('Library', 'Using cached items', {
          folderId: currentFolderId,
          itemCount: cachedItems.length,
          cacheHit: true
        });
        // Übernehme nur, wenn der Snapshot noch aktuell ist
        if (expectedLibraryId === activeLibraryId && expectedFolderId === currentFolderId) {
          setFolderItems(cachedItems);
          setLastLoadedFolder(currentFolderId);
        }
        return;
      }

      NavigationLogger.info('Library', 'Fetching items from provider', {
        folderId: currentFolderId,
        cacheHit: false
      });
      
      const items = await listItems(currentFolderId);

      // Falls während des Ladens die Library oder der Ordner wechselte: Ergebnis verwerfen
      if (expectedLibraryId !== activeLibraryId || expectedFolderId !== currentFolderId) {
        NavigationLogger.debug('Library', 'Discard loaded items due to context change', {
          expectedLibraryId,
          activeLibraryId,
          expectedFolderId,
          currentFolderId
        });
        return;
      }
      
      // Update Cache und State
      if (currentFolderId !== 'root') {
        const newFolderCache = { ...libraryState.folderCache };
        const parent = newFolderCache[currentFolderId];
        if (parent) {
          newFolderCache[currentFolderId] = {
            ...parent,
            children: items
          };
          StateLogger.info('Library', 'Updating folder cache', {
            folderId: currentFolderId,
            itemCount: items.length,
            cacheSize: Object.keys(newFolderCache).length
          });
          setLibraryState(state => ({
            ...state,
            folderCache: newFolderCache
          }));
        }
      }
      
      setFolderItems(items);
      setLastLoadedFolder(currentFolderId);
      
      StateLogger.info('Library', 'Items loaded successfully', {
        folderId: currentFolderId,
        itemCount: items.length,
        fileCount: items.filter(i => i.type === 'file').length,
        folderCount: items.filter(i => i.type === 'folder').length,
        tSinceMountMs: startupT0Ref.current ? Number((performance.now() - startupT0Ref.current).toFixed(1)) : undefined
      });
      
    } catch (error) {
      if (isStorageError(error) && error.code === 'AUTH_REQUIRED') {
        StateLogger.info('Library', 'Auth required');
        // Keine Fehlermeldung für AUTH_REQUIRED anzeigen
      } else {
        StateLogger.error('Library', 'Failed to load items', {
          error: error instanceof Error ? {
            message: error.message,
            name: error.name,
            stack: error.stack?.split('\n').slice(0, 3)
          } : error,
          folderId: currentFolderId,
          libraryId: currentLibrary?.id,
          libraryPath: currentLibrary?.path
        });
        
        // Benutzerfreundliche Fehlermeldung anzeigen
        let errorMessage = 'Fehler beim Laden der Dateien';
        
        if (error instanceof Error) {
          if (error.message.includes('Nicht authentifiziert')) {
            errorMessage = 'Bitte authentifizieren Sie sich bei Ihrem Cloud-Speicher.';
          } else if (error.message.includes('Bibliothek nicht gefunden')) {
            errorMessage = 'Die ausgewählte Bibliothek wurde nicht gefunden. Bitte überprüfen Sie die Bibliothekskonfiguration.';
          } else if (error.message.includes('Server-Fehler')) {
            errorMessage = 'Server-Fehler beim Laden der Dateien. Bitte überprüfen Sie, ob der Bibliothekspfad existiert und zugänglich ist.';
          } else if (error.message.includes('Keine aktive Bibliothek')) {
            errorMessage = 'Keine aktive Bibliothek verfügbar. Bitte wählen Sie eine Bibliothek aus.';
          } else {
            errorMessage = error.message;
          }
        }
        
        // Toast-Nachricht anzeigen
        toast({
          title: "Fehler beim Laden der Dateien",
          description: errorMessage,
          variant: "destructive",
        });
      }
      setFolderItems([]);
    } finally {
      setLoadingState({ isLoading: false, loadingFolderId: null });
      loadInFlightRef.current = false;
    }
  }, [
    currentFolderId,
    lastLoadedFolder,
    listItems,
    libraryState.folderCache,
    providerInstance,
    libraryStatus,
    setLibraryState,
    setFolderItems,
    setLastLoadedFolder,
    setLoadingState,
    toast,
    currentLibrary
  ]);

  // Effect für Initial-Load (entkoppelt vom FileTree)
  useEffect(() => {
    const isReady = !!providerInstance && libraryStatus === 'ready';
    
    if (!isReady) {
      NavigationLogger.debug('Library', 'Waiting for initialization', {
        hasProvider: !!providerInstance,
        status: libraryStatus
      });
      return;
    }

    // Wenn eine folderId in der URL steht und noch nicht angewendet wurde,
    // verhindere das initiale Laden von "root" (vermeidet Doppel-Load)
    const folderIdFromUrl = searchParams?.get('folderId');
    if (!urlInitAppliedRef.current && folderIdFromUrl && folderIdFromUrl !== currentFolderId) {
      NavigationLogger.debug('debug@init', 'Skip initial root load; URL folderId pending', {
        folderIdFromUrl,
        currentFolderId,
        lastLoadedFolder
      });
      return;
    }

    // Nur laden wenn noch nicht geladen
    if (lastLoadedFolder !== currentFolderId && !loadInFlightRef.current) {
      UILogger.info('Library', 'Initial load triggered', {
        currentFolderId,
        lastLoadedFolder,
        tSinceMountMs: startupT0Ref.current ? Number((performance.now() - startupT0Ref.current).toFixed(1)) : undefined
      });
      NavigationLogger.info('Library', 'Loading initial items', {
        folderId: currentFolderId
      });
      loadItems();
    }
  }, [providerInstance, libraryStatus, currentFolderId, lastLoadedFolder, activeLibraryId, loadItems, searchParams]);

  // Zusätzlicher Reset bei Bibliothekswechsel (robust gegen Status-Race)
  useEffect(() => {
    if (!activeLibraryId) return;
    StateLogger.info('Library', 'Active library changed - reset initial load state', {
      activeLibraryId,
      currentFolderId
    });
    setLastLoadedFolder(null);
    setFolderItems([]);
    setLibraryState(state => ({ ...state, folderCache: {} }));
    // WICHTIG: Ordnerauswahl und Shadow-Twin zurücksetzen
    setSelectedFile(null);
    setSelectedShadowTwin(null);
  }, [activeLibraryId, setLastLoadedFolder, setFolderItems, setLibraryState, currentFolderId]);

  // Reset Cache wenn sich die Library ändert
  useEffect(() => {
    setLastLoadedFolder(null);
    setLibraryState(state => ({
      ...state,
      folderCache: {}
    }));
  }, [libraryStatus, setLibraryState, setLastLoadedFolder]);

  // Manuelle Cache-Clear-Funktion für Review-Modus
  const clearCache = useCallback(() => {
    StateLogger.info('Library', 'Manually clearing cache for review mode');
    setLastLoadedFolder(null);
    setLibraryState(state => ({
      ...state,
      folderCache: {}
    }));
    setFolderItems([]);
  }, [setLibraryState, setLastLoadedFolder, setFolderItems]);

  // Reset selectedShadowTwin wenn Review-Modus verlassen wird
  useEffect(() => {
    if (!isReviewMode) {
      setSelectedShadowTwin(null);
    }
  }, [isReviewMode, setSelectedShadowTwin]);

  // ENTFERNT: Der folgende useEffect war problematisch und hat das Shadow-Twin 
  // bei jedem Klick zurückgesetzt, auch wenn die Datei ein Shadow-Twin hat.
  // Die Shadow-Twin-Logik wird bereits korrekt in der FileList-Komponente 
  // in der handleSelect-Funktion behandelt.

  // Render-Logik für verschiedene Status
  if (libraryStatus === "waitingForAuth") {
    return (
      <div className="flex flex-col items-center justify-center h-full text-muted-foreground">
        <span>Diese Bibliothek benötigt eine Authentifizierung.</span>
        <span className="text-sm mt-2">Bitte konfigurieren Sie die Bibliothek in den Einstellungen.</span>
      </div>
    );
  }
  
  if (libraryStatus !== "ready") {
    return (
      <div className="flex flex-col items-center justify-center h-full text-muted-foreground">
        <span>Lade Storage...</span>
      </div>
    );
  }

  return (
    <div className="flex flex-col h-full">
      <LibraryHeader
        provider={providerInstance}
        error={storageError}
        onUploadComplete={loadItems}
        onClearCache={clearCache}
        isTreeVisible={isTreeVisible}
        onToggleTree={() => setIsTreeVisible(v => !v)}
        isCompactList={isListCompact}
        onToggleCompactList={() => setIsListCompact(v => !v)}
      >
        <Breadcrumb />
      </LibraryHeader>
      
      <div className="flex-1 min-h-0 overflow-hidden">
        {isReviewMode ? (
          // Review-Layout: 3 Panels ohne FileTree - FileList (compact) | FilePreview (Basis-Datei) | FilePreview (Shadow-Twin)
          <ResizablePanelGroup direction="horizontal" className="h-full">
            <ResizablePanel defaultSize={25} minSize={20} className="min-h-0">
              <div className="h-full overflow-auto flex flex-col">
                <FileList compact={true} />
              </div>
            </ResizablePanel>
            <ResizableHandle />
            <ResizablePanel defaultSize={37.5} minSize={30} className="min-h-0">
              <div className="h-full relative flex flex-col">
                {selectedFile ? (
                  <FilePreviewLazy
                    provider={providerInstance}
                    file={selectedFile}
                    onRefreshFolder={(folderId, items, selectFileAfterRefresh) => {
                    StateLogger.info('Library', 'FilePreview (Basis) onRefreshFolder aufgerufen', {
                      folderId,
                      itemsCount: items.length,
                      hasSelectFile: !!selectFileAfterRefresh
                    });
                    
                    // Aktualisiere die Dateiliste
                    setFolderItems(items);
                    
                    // Aktualisiere den Cache
                    if (libraryState.folderCache?.[folderId]) {
                      const cachedFolder = libraryState.folderCache[folderId];
                      if (cachedFolder) {
                        setLibraryState(state => ({
                          ...state,
                          folderCache: {
                            ...(state.folderCache || {}),
                            [folderId]: {
                              ...cachedFolder,
                              children: items
                            }
                          }
                        }));
                      }
                    }
                    
                    // Wenn eine Datei ausgewählt werden soll (nach dem Speichern)
                    if (selectFileAfterRefresh) {
                      StateLogger.info('Library', 'Wähle gespeicherte Datei aus', {
                        fileId: selectFileAfterRefresh.id,
                        fileName: selectFileAfterRefresh.metadata.name
                      });
                    }
                    }}
                  />
                ) : (
                  <div className="h-full flex items-center justify-center text-muted-foreground">
                    <p>Keine Datei ausgewählt</p>
                  </div>
                )}
              </div>
            </ResizablePanel>
            <ResizableHandle />
            <ResizablePanel defaultSize={37.5} minSize={30} className="min-h-0">
              <div className="h-full relative flex flex-col">
                {selectedShadowTwin ? (
                  <FilePreviewLazy
                    provider={providerInstance}
                    file={selectedShadowTwin}
                    onRefreshFolder={(folderId, items, selectFileAfterRefresh) => {
                      StateLogger.info('Library', 'FilePreview (Shadow-Twin) onRefreshFolder aufgerufen', {
                        folderId,
                        itemsCount: items.length,
                        hasSelectFile: !!selectFileAfterRefresh
                      });
                      
                      // Aktualisiere die Dateiliste
                      setFolderItems(items);
                      
                      // Aktualisiere den Cache
                      if (libraryState.folderCache?.[folderId]) {
                        const cachedFolder = libraryState.folderCache[folderId];
                        if (cachedFolder) {
                          setLibraryState(state => ({
                            ...state,
                            folderCache: {
                              ...(state.folderCache || {}),
                              [folderId]: {
                                ...cachedFolder,
                                children: items
                              }
                            }
                          }));
                        }
                      }
                      
                      // Wenn eine Datei ausgewählt werden soll (nach dem Speichern)
                      if (selectFileAfterRefresh) {
                        StateLogger.info('Library', 'Wähle gespeicherte Datei aus', {
                          fileId: selectFileAfterRefresh.id,
                          fileName: selectFileAfterRefresh.metadata.name
                        });
                      }
                    }}
                  />
                ) : (
                  <div className="h-full flex items-center justify-center text-muted-foreground">
                    <p>Kein Shadow-Twin ausgewählt</p>
                  </div>
                )}
              </div>
            </ResizablePanel>
          </ResizablePanelGroup>
        ) : (
          // Normal-Layout (Desktop) oder alternierendes Mobile-Layout
          <div className="relative h-full">
            {/* Entfernt: alter Tree-Handle (ersetzt durch Header-Toggle) */}

            {isMobile ? (
              mobileView === 'list' ? (
                <div className="h-full overflow-auto flex flex-col">
                  <FileList />
                </div>
              ) : (
                <div className="h-full flex flex-col">
                  <div className="flex items-center gap-2 p-2 border-b bg-background">
                    <button
                      type="button"
                      className="inline-flex items-center gap-1 text-sm px-2 py-1 border rounded-md"
                      onClick={() => {
                        setMobileView('list');
                        setSelectedShadowTwin(null);
                        setSelectedFile(null);
                        loadItems();
                      }}
                    >
                      <ChevronLeft className="h-4 w-4" />
                      Zurück
                    </button>
                    <div className="text-sm text-muted-foreground truncate">
                      {selectedFile?.metadata.name}
                    </div>
                  </div>
                  <div className="flex-1 min-h-0">
                    {selectedFile ? (
                      <FilePreviewLazy
                        provider={providerInstance}
                        onRefreshFolder={(folderId, items, selectFileAfterRefresh) => {
                        StateLogger.info('Library', 'FilePreview onRefreshFolder aufgerufen', {
                          folderId,
                          itemsCount: items.length,
                          hasSelectFile: !!selectFileAfterRefresh
                        });
                        setFolderItems(items);
                        if (libraryState.folderCache?.[folderId]) {
                          const cachedFolder = libraryState.folderCache[folderId];
                          if (cachedFolder) {
                            setLibraryState(state => ({
                              ...state,
                              folderCache: {
                                ...(state.folderCache || {}),
                                [folderId]: { ...cachedFolder, children: items }
                              }
                            }));
                          }
                        }
                        }}
                      />
                    ) : (
                      <div className="h-full flex items-center justify-center text-muted-foreground">
                        <p>Keine Datei ausgewählt</p>
                      </div>
                    )}
                  </div>
                </div>
              )
            ) : (
              <ResizablePanelGroup
                key={`layout-${isTreeVisible ? 'tree' : 'notree'}-${isListCompact ? 'compact' : 'list'}`}
                direction="horizontal"
                className="h-full"
                autoSaveId={`library-panels-${isTreeVisible ? '3' : '2'}-${isListCompact ? 'c' : 'n'}`}
              >
                {isTreeVisible && (
                  <>
                    <ResizablePanel key="tree-panel" id="tree" defaultSize={15} minSize={10} className="min-h-0">
                      <div className="h-full overflow-auto flex flex-col">
                        <FileTree />
                      </div>
                    </ResizablePanel>
                    <ResizableHandle key="tree-handle" />
                  </>
                )}
                <>
                  <ResizablePanel key="list-panel" id="list" defaultSize={isListCompact ? 15 : 30} minSize={isListCompact ? 12 : 20} className="min-h-0 transition-[flex-basis] duration-200 ease-in-out">
                    <div className="h-full overflow-auto flex flex-col">
                      <FileList compact={isListCompact} />
                    </div>
                  </ResizablePanel>
                  <ResizableHandle key="list-preview-handle" />
                </>
                <ResizablePanel key="preview-panel" id="preview" defaultSize={(() => {
                  const tree = isTreeVisible ? 15 : 0;
                  const list = isListCompact ? 15 : 30;
                  const rest = Math.max(10, 100 - (tree + list));
                  return rest;
                })()} className="min-h-0 transition-[flex-basis] duration-200 ease-in-out">
                  <div className="h-full relative flex flex-col">
                    {selectedFile ? (
                      <FilePreviewLazy
                        provider={providerInstance}
                        onRefreshFolder={(folderId, items, selectFileAfterRefresh) => {
                        StateLogger.info('Library', 'FilePreview onRefreshFolder aufgerufen', {
                          folderId,
                          itemsCount: items.length,
                          hasSelectFile: !!selectFileAfterRefresh
                        });
                        
                        // Aktualisiere die Dateiliste
                        setFolderItems(items);
                        
                        // Aktualisiere den Cache
                        if (libraryState.folderCache?.[folderId]) {
                          const cachedFolder = libraryState.folderCache[folderId];
                          if (cachedFolder) {
                            setLibraryState(state => ({
                              ...state,
                              folderCache: {
                                ...(state.folderCache || {}),
                                [folderId]: {
                                  ...cachedFolder,
                                  children: items
                                }
                              }
                            }));
                          }
                        }
                        
                        if (selectFileAfterRefresh) {
                          StateLogger.info('Library', 'Wähle gespeicherte Datei aus', {
                            fileId: selectFileAfterRefresh.id,
                            fileName: selectFileAfterRefresh.metadata.name
                          });
                        }
                        }}
                      />
                    ) : (
                      <div className="h-full flex items-center justify-center text-muted-foreground">
                        <p>Keine Datei ausgewählt</p>
                      </div>
                    )}
                  </div>
                </ResizablePanel>
              </ResizablePanelGroup>
            )}
          </div>
        )}
      </div>
      
      {/* Dialoge */}
      <TranscriptionDialog />
      <TransformationDialog 
        onRefreshFolder={(folderId: string, items: StorageItem[], selectFileAfterRefresh?: StorageItem) => {
          StateLogger.info('Library', 'TransformationDialog onRefreshFolder aufgerufen', {
            folderId,
            itemsCount: items.length,
            hasSelectFile: !!selectFileAfterRefresh
          });
          
          // Aktualisiere die Dateiliste
          setFolderItems(items);
          
          // Aktualisiere den Cache
          if (libraryState.folderCache?.[folderId]) {
            const cachedFolder = libraryState.folderCache[folderId];
            if (cachedFolder) {
              setLibraryState(state => ({
                ...state,
                folderCache: {
                  ...(state.folderCache || {}),
                  [folderId]: {
                    ...cachedFolder,
                    children: items
                  }
                }
              }));
            }
          }
          
          // Wenn eine Datei ausgewählt werden soll (nach dem Speichern)
          if (selectFileAfterRefresh) {
            StateLogger.info('Library', 'Wähle gespeicherte Datei aus', {
              fileId: selectFileAfterRefresh.id,
              fileName: selectFileAfterRefresh.metadata.name
            });
          }
        }}
      />
    </div>
  );
}
```

Eingestellt:
- FileTree: 15% wenn sichtbar.
- FileList: 30% in normaler Ansicht, 15% in Kompaktansicht.
- Preview nimmt den Rest; Mindestrest 10%.

Bitte kurz prüfen, ob die Aufteilung nun exakt deinen Vorgaben entspricht.

---

**User**

FileList kompakt ist nicht 15% sie ist noch zu schmal, bitte noch mal kontrollieren.

---

**Cursor**

```typescriptreact
"use client"

import * as React from "react"
import { useCallback, useEffect } from "react"
import { useAtom, useAtomValue } from "jotai"

import { LibraryHeader } from "./library-header"
import { FileTree } from "./file-tree"
import { FileList } from "./file-list"
import dynamic from 'next/dynamic'
const FilePreviewLazy = dynamic(() => import('./file-preview').then(m => m.FilePreview), {
  ssr: false,
  loading: () => (
    <div className="h-full flex items-center justify-center text-muted-foreground">
      Lade Vorschau...
    </div>
  )
})
import { ResizableHandle, ResizablePanel, ResizablePanelGroup } from "@/components/ui/resizable"
import { 
  libraryAtom, 
  folderItemsAtom,
  loadingStateAtom,
  lastLoadedFolderAtom,
  currentFolderIdAtom,
  reviewModeAtom,
  selectedFileAtom,
  selectedShadowTwinAtom
} from "@/atoms/library-atom"
import { activeLibraryIdAtom } from "@/atoms/library-atom"
import { useStorage, isStorageError } from "@/contexts/storage-context"
import { TranscriptionDialog } from "./transcription-dialog"
import { TransformationDialog } from "./transformation-dialog"
import { StorageItem } from "@/lib/storage/types"
import { NavigationLogger, StateLogger, UILogger } from "@/lib/debug/logger"
import { Breadcrumb } from "./breadcrumb"
import { useToast } from "@/components/ui/use-toast"
import { ChevronLeft, ChevronRight } from "lucide-react"
import { useSearchParams } from "next/navigation"
import { useFolderNavigation } from "@/hooks/use-folder-navigation"
export function Library() {
  // Performance-Messung für Kaltstart (nur Client)
  const startupT0Ref = React.useRef<number>(
    typeof performance !== 'undefined' ? performance.now() : 0
  );
  // Globale Atoms
  const [, setFolderItems] = useAtom(folderItemsAtom);
  const [, setLoadingState] = useAtom(loadingStateAtom);
  const [lastLoadedFolder, setLastLoadedFolder] = useAtom(lastLoadedFolderAtom);
  const [currentFolderId] = useAtom(currentFolderIdAtom);
  const [libraryState, setLibraryState] = useAtom(libraryAtom);
  const activeLibraryId = useAtomValue(activeLibraryIdAtom);
  
  // Review-Mode Atoms
  const [isReviewMode] = useAtom(reviewModeAtom);
  const [selectedFile, setSelectedFile] = useAtom(selectedFileAtom);
  const [selectedShadowTwin, setSelectedShadowTwin] = useAtom(selectedShadowTwinAtom);
  
  // Storage Context
  const { 
    provider: providerInstance, 
    error: storageError, 
    listItems,
    libraryStatus,
    currentLibrary
  } = useStorage();
  const { toast } = useToast();
  const [isTreeVisible, setIsTreeVisible] = React.useState<boolean>(false);
  const [isListCompact, setIsListCompact] = React.useState<boolean>(false);
  const [isMobile, setIsMobile] = React.useState<boolean>(false);
  const [mobileView, setMobileView] = React.useState<'list' | 'preview'>('list');
  const loadInFlightRef = React.useRef<boolean>(false);
  const searchParams = useSearchParams();
  const navigateToFolder = useFolderNavigation();

  // Mobile: Tree standardmäßig ausblenden, Desktop: anzeigen
  React.useEffect(() => {
    if (typeof window === 'undefined') return;
    // Desktop ab 1024px, Mobile darunter
    const mq = window.matchMedia('(max-width: 1023px)');
    const apply = (matches: boolean) => {
      setIsMobile(matches);
      setIsTreeVisible(!matches);
    };
    apply(mq.matches);
    const handler = (e: MediaQueryListEvent) => apply(e.matches);
    mq.addEventListener('change', handler);
    return () => mq.removeEventListener('change', handler);
  }, []);

  // URL -> State: folderId aus Query anwenden, wenn Provider bereit ist
  const urlInitAppliedRef = React.useRef(false);
  React.useEffect(() => {
    const folderIdFromUrl = searchParams?.get('folderId');

    if (urlInitAppliedRef.current) return;

    if (!folderIdFromUrl) {
      NavigationLogger.debug('debug@init', 'No folderId in URL', {
        currentFolderId
      });
      urlInitAppliedRef.current = true;
      return;
    }

    if (!providerInstance || libraryStatus !== 'ready') {
      NavigationLogger.debug('debug@init', 'Provider not ready, deferring URL apply', {
        folderIdFromUrl,
        libraryStatus,
        hasProvider: !!providerInstance
      });
      return;
    }

    if (folderIdFromUrl !== currentFolderId) {
      NavigationLogger.info('debug@init', 'Applying folderId from URL (ready)', {
        folderIdFromUrl,
        currentFolderId
      });
      void navigateToFolder(folderIdFromUrl);
    }
    urlInitAppliedRef.current = true;
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [searchParams, providerInstance, libraryStatus, currentFolderId]);

  // Mobile-View Wechsellogik: bei Dateiauswahl zur Vorschau wechseln
  React.useEffect(() => {
    if (!isMobile) return;
    if (selectedFile) setMobileView('preview');
  }, [isMobile, selectedFile]);

  // Optimierter loadItems mit Cache-Check
  const loadItems = useCallback(async () => {
    if (loadInFlightRef.current) {
      NavigationLogger.debug('Library', 'Skip loadItems - load already in flight');
      return;
    }
    if (!providerInstance || libraryStatus !== 'ready') {
      NavigationLogger.debug('Library', 'Skipping loadItems - not ready', {
        hasProvider: !!providerInstance,
        status: libraryStatus
      });
      return;
    }

    // Schutz: Wenn Provider/Context noch auf alte Library zeigt, keine Items übernehmen
    if (currentLibrary?.id && currentLibrary.id !== activeLibraryId) {
      NavigationLogger.debug('Library', 'Skip loadItems - library mismatch', {
        providerLibraryId: currentLibrary.id,
        activeLibraryId
      });
      return;
    }

    loadInFlightRef.current = true;
    setLoadingState({ isLoading: true, loadingFolderId: currentFolderId });

    try {
      // Snapshot zur Vermeidung von Race-Conditions
      const expectedLibraryId = activeLibraryId;
      const expectedFolderId = currentFolderId;

      // Prüfe Cache zuerst
      if (libraryState.folderCache?.[currentFolderId]?.children) {
        const cachedItems = libraryState.folderCache[currentFolderId].children;
        NavigationLogger.info('Library', 'Using cached items', {
          folderId: currentFolderId,
          itemCount: cachedItems.length,
          cacheHit: true
        });
        // Übernehme nur, wenn der Snapshot noch aktuell ist
        if (expectedLibraryId === activeLibraryId && expectedFolderId === currentFolderId) {
          setFolderItems(cachedItems);
          setLastLoadedFolder(currentFolderId);
        }
        return;
      }

      NavigationLogger.info('Library', 'Fetching items from provider', {
        folderId: currentFolderId,
        cacheHit: false
      });
      
      const items = await listItems(currentFolderId);

      // Falls während des Ladens die Library oder der Ordner wechselte: Ergebnis verwerfen
      if (expectedLibraryId !== activeLibraryId || expectedFolderId !== currentFolderId) {
        NavigationLogger.debug('Library', 'Discard loaded items due to context change', {
          expectedLibraryId,
          activeLibraryId,
          expectedFolderId,
          currentFolderId
        });
        return;
      }
      
      // Update Cache und State
      if (currentFolderId !== 'root') {
        const newFolderCache = { ...libraryState.folderCache };
        const parent = newFolderCache[currentFolderId];
        if (parent) {
          newFolderCache[currentFolderId] = {
            ...parent,
            children: items
          };
          StateLogger.info('Library', 'Updating folder cache', {
            folderId: currentFolderId,
            itemCount: items.length,
            cacheSize: Object.keys(newFolderCache).length
          });
          setLibraryState(state => ({
            ...state,
            folderCache: newFolderCache
          }));
        }
      }
      
      setFolderItems(items);
      setLastLoadedFolder(currentFolderId);
      
      StateLogger.info('Library', 'Items loaded successfully', {
        folderId: currentFolderId,
        itemCount: items.length,
        fileCount: items.filter(i => i.type === 'file').length,
        folderCount: items.filter(i => i.type === 'folder').length,
        tSinceMountMs: startupT0Ref.current ? Number((performance.now() - startupT0Ref.current).toFixed(1)) : undefined
      });
      
    } catch (error) {
      if (isStorageError(error) && error.code === 'AUTH_REQUIRED') {
        StateLogger.info('Library', 'Auth required');
        // Keine Fehlermeldung für AUTH_REQUIRED anzeigen
      } else {
        StateLogger.error('Library', 'Failed to load items', {
          error: error instanceof Error ? {
            message: error.message,
            name: error.name,
            stack: error.stack?.split('\n').slice(0, 3)
          } : error,
          folderId: currentFolderId,
          libraryId: currentLibrary?.id,
          libraryPath: currentLibrary?.path
        });
        
        // Benutzerfreundliche Fehlermeldung anzeigen
        let errorMessage = 'Fehler beim Laden der Dateien';
        
        if (error instanceof Error) {
          if (error.message.includes('Nicht authentifiziert')) {
            errorMessage = 'Bitte authentifizieren Sie sich bei Ihrem Cloud-Speicher.';
          } else if (error.message.includes('Bibliothek nicht gefunden')) {
            errorMessage = 'Die ausgewählte Bibliothek wurde nicht gefunden. Bitte überprüfen Sie die Bibliothekskonfiguration.';
          } else if (error.message.includes('Server-Fehler')) {
            errorMessage = 'Server-Fehler beim Laden der Dateien. Bitte überprüfen Sie, ob der Bibliothekspfad existiert und zugänglich ist.';
          } else if (error.message.includes('Keine aktive Bibliothek')) {
            errorMessage = 'Keine aktive Bibliothek verfügbar. Bitte wählen Sie eine Bibliothek aus.';
          } else {
            errorMessage = error.message;
          }
        }
        
        // Toast-Nachricht anzeigen
        toast({
          title: "Fehler beim Laden der Dateien",
          description: errorMessage,
          variant: "destructive",
        });
      }
      setFolderItems([]);
    } finally {
      setLoadingState({ isLoading: false, loadingFolderId: null });
      loadInFlightRef.current = false;
    }
  }, [
    currentFolderId,
    lastLoadedFolder,
    listItems,
    libraryState.folderCache,
    providerInstance,
    libraryStatus,
    setLibraryState,
    setFolderItems,
    setLastLoadedFolder,
    setLoadingState,
    toast,
    currentLibrary
  ]);

  // Effect für Initial-Load (entkoppelt vom FileTree)
  useEffect(() => {
    const isReady = !!providerInstance && libraryStatus === 'ready';
    
    if (!isReady) {
      NavigationLogger.debug('Library', 'Waiting for initialization', {
        hasProvider: !!providerInstance,
        status: libraryStatus
      });
      return;
    }

    // Wenn eine folderId in der URL steht und noch nicht angewendet wurde,
    // verhindere das initiale Laden von "root" (vermeidet Doppel-Load)
    const folderIdFromUrl = searchParams?.get('folderId');
    if (!urlInitAppliedRef.current && folderIdFromUrl && folderIdFromUrl !== currentFolderId) {
      NavigationLogger.debug('debug@init', 'Skip initial root load; URL folderId pending', {
        folderIdFromUrl,
        currentFolderId,
        lastLoadedFolder
      });
      return;
    }

    // Nur laden wenn noch nicht geladen
    if (lastLoadedFolder !== currentFolderId && !loadInFlightRef.current) {
      UILogger.info('Library', 'Initial load triggered', {
        currentFolderId,
        lastLoadedFolder,
        tSinceMountMs: startupT0Ref.current ? Number((performance.now() - startupT0Ref.current).toFixed(1)) : undefined
      });
      NavigationLogger.info('Library', 'Loading initial items', {
        folderId: currentFolderId
      });
      loadItems();
    }
  }, [providerInstance, libraryStatus, currentFolderId, lastLoadedFolder, activeLibraryId, loadItems, searchParams]);

  // Zusätzlicher Reset bei Bibliothekswechsel (robust gegen Status-Race)
  useEffect(() => {
    if (!activeLibraryId) return;
    StateLogger.info('Library', 'Active library changed - reset initial load state', {
      activeLibraryId,
      currentFolderId
    });
    setLastLoadedFolder(null);
    setFolderItems([]);
    setLibraryState(state => ({ ...state, folderCache: {} }));
    // WICHTIG: Ordnerauswahl und Shadow-Twin zurücksetzen
    setSelectedFile(null);
    setSelectedShadowTwin(null);
  }, [activeLibraryId, setLastLoadedFolder, setFolderItems, setLibraryState, currentFolderId]);

  // Reset Cache wenn sich die Library ändert
  useEffect(() => {
    setLastLoadedFolder(null);
    setLibraryState(state => ({
      ...state,
      folderCache: {}
    }));
  }, [libraryStatus, setLibraryState, setLastLoadedFolder]);

  // Manuelle Cache-Clear-Funktion für Review-Modus
  const clearCache = useCallback(() => {
    StateLogger.info('Library', 'Manually clearing cache for review mode');
    setLastLoadedFolder(null);
    setLibraryState(state => ({
      ...state,
      folderCache: {}
    }));
    setFolderItems([]);
  }, [setLibraryState, setLastLoadedFolder, setFolderItems]);

  // Reset selectedShadowTwin wenn Review-Modus verlassen wird
  useEffect(() => {
    if (!isReviewMode) {
      setSelectedShadowTwin(null);
    }
  }, [isReviewMode, setSelectedShadowTwin]);

  // ENTFERNT: Der folgende useEffect war problematisch und hat das Shadow-Twin 
  // bei jedem Klick zurückgesetzt, auch wenn die Datei ein Shadow-Twin hat.
  // Die Shadow-Twin-Logik wird bereits korrekt in der FileList-Komponente 
  // in der handleSelect-Funktion behandelt.

  // Render-Logik für verschiedene Status
  if (libraryStatus === "waitingForAuth") {
    return (
      <div className="flex flex-col items-center justify-center h-full text-muted-foreground">
        <span>Diese Bibliothek benötigt eine Authentifizierung.</span>
        <span className="text-sm mt-2">Bitte konfigurieren Sie die Bibliothek in den Einstellungen.</span>
      </div>
    );
  }
  
  if (libraryStatus !== "ready") {
    return (
      <div className="flex flex-col items-center justify-center h-full text-muted-foreground">
        <span>Lade Storage...</span>
      </div>
    );
  }

  return (
    <div className="flex flex-col h-full">
      <LibraryHeader
        provider={providerInstance}
        error={storageError}
        onUploadComplete={loadItems}
        onClearCache={clearCache}
        isTreeVisible={isTreeVisible}
        onToggleTree={() => setIsTreeVisible(v => !v)}
        isCompactList={isListCompact}
        onToggleCompactList={() => setIsListCompact(v => !v)}
      >
        <Breadcrumb />
      </LibraryHeader>
      
      <div className="flex-1 min-h-0 overflow-hidden">
        {isReviewMode ? (
          // Review-Layout: 3 Panels ohne FileTree - FileList (compact) | FilePreview (Basis-Datei) | FilePreview (Shadow-Twin)
          <ResizablePanelGroup direction="horizontal" className="h-full">
            <ResizablePanel defaultSize={25} minSize={20} className="min-h-0">
              <div className="h-full overflow-auto flex flex-col">
                <FileList compact={true} />
              </div>
            </ResizablePanel>
            <ResizableHandle />
            <ResizablePanel defaultSize={37.5} minSize={30} className="min-h-0">
              <div className="h-full relative flex flex-col">
                {selectedFile ? (
                  <FilePreviewLazy
                    provider={providerInstance}
                    file={selectedFile}
                    onRefreshFolder={(folderId, items, selectFileAfterRefresh) => {
                    StateLogger.info('Library', 'FilePreview (Basis) onRefreshFolder aufgerufen', {
                      folderId,
                      itemsCount: items.length,
                      hasSelectFile: !!selectFileAfterRefresh
                    });
                    
                    // Aktualisiere die Dateiliste
                    setFolderItems(items);
                    
                    // Aktualisiere den Cache
                    if (libraryState.folderCache?.[folderId]) {
                      const cachedFolder = libraryState.folderCache[folderId];
                      if (cachedFolder) {
                        setLibraryState(state => ({
                          ...state,
                          folderCache: {
                            ...(state.folderCache || {}),
                            [folderId]: {
                              ...cachedFolder,
                              children: items
                            }
                          }
                        }));
                      }
                    }
                    
                    // Wenn eine Datei ausgewählt werden soll (nach dem Speichern)
                    if (selectFileAfterRefresh) {
                      StateLogger.info('Library', 'Wähle gespeicherte Datei aus', {
                        fileId: selectFileAfterRefresh.id,
                        fileName: selectFileAfterRefresh.metadata.name
                      });
                    }
                    }}
                  />
                ) : (
                  <div className="h-full flex items-center justify-center text-muted-foreground">
                    <p>Keine Datei ausgewählt</p>
                  </div>
                )}
              </div>
            </ResizablePanel>
            <ResizableHandle />
            <ResizablePanel defaultSize={37.5} minSize={30} className="min-h-0">
              <div className="h-full relative flex flex-col">
                {selectedShadowTwin ? (
                  <FilePreviewLazy
                    provider={providerInstance}
                    file={selectedShadowTwin}
                    onRefreshFolder={(folderId, items, selectFileAfterRefresh) => {
                      StateLogger.info('Library', 'FilePreview (Shadow-Twin) onRefreshFolder aufgerufen', {
                        folderId,
                        itemsCount: items.length,
                        hasSelectFile: !!selectFileAfterRefresh
                      });
                      
                      // Aktualisiere die Dateiliste
                      setFolderItems(items);
                      
                      // Aktualisiere den Cache
                      if (libraryState.folderCache?.[folderId]) {
                        const cachedFolder = libraryState.folderCache[folderId];
                        if (cachedFolder) {
                          setLibraryState(state => ({
                            ...state,
                            folderCache: {
                              ...(state.folderCache || {}),
                              [folderId]: {
                                ...cachedFolder,
                                children: items
                              }
                            }
                          }));
                        }
                      }
                      
                      // Wenn eine Datei ausgewählt werden soll (nach dem Speichern)
                      if (selectFileAfterRefresh) {
                        StateLogger.info('Library', 'Wähle gespeicherte Datei aus', {
                          fileId: selectFileAfterRefresh.id,
                          fileName: selectFileAfterRefresh.metadata.name
                        });
                      }
                    }}
                  />
                ) : (
                  <div className="h-full flex items-center justify-center text-muted-foreground">
                    <p>Kein Shadow-Twin ausgewählt</p>
                  </div>
                )}
              </div>
            </ResizablePanel>
          </ResizablePanelGroup>
        ) : (
          // Normal-Layout (Desktop) oder alternierendes Mobile-Layout
          <div className="relative h-full">
            {/* Entfernt: alter Tree-Handle (ersetzt durch Header-Toggle) */}

            {isMobile ? (
              mobileView === 'list' ? (
                <div className="h-full overflow-auto flex flex-col">
                  <FileList />
                </div>
              ) : (
                <div className="h-full flex flex-col">
                  <div className="flex items-center gap-2 p-2 border-b bg-background">
                    <button
                      type="button"
                      className="inline-flex items-center gap-1 text-sm px-2 py-1 border rounded-md"
                      onClick={() => {
                        setMobileView('list');
                        setSelectedShadowTwin(null);
                        setSelectedFile(null);
                        loadItems();
                      }}
                    >
                      <ChevronLeft className="h-4 w-4" />
                      Zurück
                    </button>
                    <div className="text-sm text-muted-foreground truncate">
                      {selectedFile?.metadata.name}
                    </div>
                  </div>
                  <div className="flex-1 min-h-0">
                    {selectedFile ? (
                      <FilePreviewLazy
                        provider={providerInstance}
                        onRefreshFolder={(folderId, items, selectFileAfterRefresh) => {
                        StateLogger.info('Library', 'FilePreview onRefreshFolder aufgerufen', {
                          folderId,
                          itemsCount: items.length,
                          hasSelectFile: !!selectFileAfterRefresh
                        });
                        setFolderItems(items);
                        if (libraryState.folderCache?.[folderId]) {
                          const cachedFolder = libraryState.folderCache[folderId];
                          if (cachedFolder) {
                            setLibraryState(state => ({
                              ...state,
                              folderCache: {
                                ...(state.folderCache || {}),
                                [folderId]: { ...cachedFolder, children: items }
                              }
                            }));
                          }
                        }
                        }}
                      />
                    ) : (
                      <div className="h-full flex items-center justify-center text-muted-foreground">
                        <p>Keine Datei ausgewählt</p>
                      </div>
                    )}
                  </div>
                </div>
              )
            ) : (
              <ResizablePanelGroup
                key={`layout-${isTreeVisible ? 'tree' : 'notree'}-${isListCompact ? 'compact' : 'list'}`}
                direction="horizontal"
                className="h-full"
                autoSaveId={`library-panels-${isTreeVisible ? '3' : '2'}-${isListCompact ? 'c' : 'n'}`}
              >
                {isTreeVisible && (
                  <>
                    <ResizablePanel key={`tree-panel-${isTreeVisible ? 't' : 'nt'}`} id="tree" defaultSize={15} minSize={15} className="min-h-0">
                      <div className="h-full overflow-auto flex flex-col">
                        <FileTree />
                      </div>
                    </ResizablePanel>
                    <ResizableHandle key="tree-handle" />
                  </>
                )}
                <>
                  <ResizablePanel key={`list-panel-${isListCompact ? 'c' : 'n'}-${isTreeVisible ? 't' : 'nt'}`} id="list" defaultSize={isListCompact ? 15 : 30} minSize={15} className="min-h-0 transition-[flex-basis] duration-200 ease-in-out">
                    <div className="h-full overflow-auto flex flex-col">
                      <FileList compact={isListCompact} />
                    </div>
                  </ResizablePanel>
                  <ResizableHandle key="list-preview-handle" />
                </>
                <ResizablePanel key={`preview-panel-${isListCompact ? 'c' : 'n'}-${isTreeVisible ? 't' : 'nt'}`} id="preview" defaultSize={(() => {
                  const tree = isTreeVisible ? 15 : 0;
                  const list = isListCompact ? 15 : 30;
                  const rest = Math.max(10, 100 - (tree + list));
                  return rest;
                })()} className="min-h-0 transition-[flex-basis] duration-200 ease-in-out">
                  <div className="h-full relative flex flex-col">
                    {selectedFile ? (
                      <FilePreviewLazy
                        provider={providerInstance}
                        onRefreshFolder={(folderId, items, selectFileAfterRefresh) => {
                        StateLogger.info('Library', 'FilePreview onRefreshFolder aufgerufen', {
                          folderId,
                          itemsCount: items.length,
                          hasSelectFile: !!selectFileAfterRefresh
                        });
                        
                        // Aktualisiere die Dateiliste
                        setFolderItems(items);
                        
                        // Aktualisiere den Cache
                        if (libraryState.folderCache?.[folderId]) {
                          const cachedFolder = libraryState.folderCache[folderId];
                          if (cachedFolder) {
                            setLibraryState(state => ({
                              ...state,
                              folderCache: {
                                ...(state.folderCache || {}),
                                [folderId]: {
                                  ...cachedFolder,
                                  children: items
                                }
                              }
                            }));
                          }
                        }
                        
                        if (selectFileAfterRefresh) {
                          StateLogger.info('Library', 'Wähle gespeicherte Datei aus', {
                            fileId: selectFileAfterRefresh.id,
                            fileName: selectFileAfterRefresh.metadata.name
                          });
                        }
                        }}
                      />
                    ) : (
                      <div className="h-full flex items-center justify-center text-muted-foreground">
                        <p>Keine Datei ausgewählt</p>
                      </div>
                    )}
                  </div>
                </ResizablePanel>
              </ResizablePanelGroup>
            )}
          </div>
        )}
      </div>
      
      {/* Dialoge */}
      <TranscriptionDialog />
      <TransformationDialog 
        onRefreshFolder={(folderId: string, items: StorageItem[], selectFileAfterRefresh?: StorageItem) => {
          StateLogger.info('Library', 'TransformationDialog onRefreshFolder aufgerufen', {
            folderId,
            itemsCount: items.length,
            hasSelectFile: !!selectFileAfterRefresh
          });
          
          // Aktualisiere die Dateiliste
          setFolderItems(items);
          
          // Aktualisiere den Cache
          if (libraryState.folderCache?.[folderId]) {
            const cachedFolder = libraryState.folderCache[folderId];
            if (cachedFolder) {
              setLibraryState(state => ({
                ...state,
                folderCache: {
                  ...(state.folderCache || {}),
                  [folderId]: {
                    ...cachedFolder,
                    children: items
                  }
                }
              }));
            }
          }
          
          // Wenn eine Datei ausgewählt werden soll (nach dem Speichern)
          if (selectFileAfterRefresh) {
            StateLogger.info('Library', 'Wähle gespeicherte Datei aus', {
              fileId: selectFileAfterRefresh.id,
              fileName: selectFileAfterRefresh.metadata.name
            });
          }
        }}
      />
    </div>
  );
}
```

Ich habe die Mindestbreiten hart gesetzt und Re-Keys hinzugefügt, damit gespeicherte Größen nicht greifen:

- FileTree: minSize = 15, defaultSize = 15
- FileList kompakt: defaultSize = 15, minSize = 15
- FileList normal: defaultSize = 30, minSize = 15
- ResizablePanel keys variieren mit Tree/Kompakt, damit frühere Auto-Saves die Breiten nicht überschreiben.

Bitte neu laden: Kompakt sollte nun stabil bei 15% liegen.

---

**User**

Jetzt habe ich noch ein Problem mit der Persistenz der Einstellungen. Wenn ich... Wie wird diese PAN... ...Einstellung... ...gespeichert? Sind die aktuellen Buttons... ...im State, Jotte, State Management... ...gespeichert? Weil ich habe einen Test gemacht, wenn ich den Browser zusammenziehe und in die mobile Ansicht wechsle... ...und dort ein bisschen navigiere und wieder... ...zurückgehe auf die Browser-Ansicht, dann sind die Einstellungen verloren. Wie wird das gespeichert?

---

**Cursor**

```typescript
import { atom } from 'jotai'
import { atomWithStorage } from 'jotai/utils'

export interface UiPanePrefs {
  treeVisible: boolean
  listCompact: boolean
}

// Persistente UI-Einstellungen in localStorage
const uiPanePrefsBase = atomWithStorage<UiPanePrefs>('ui:pane-prefs', {
  treeVisible: true,
  listCompact: false,
})

export const uiPanePrefsAtom = atom(
  (get) => get(uiPanePrefsBase),
  (get, set, update: Partial<UiPanePrefs>) => {
    const prev = get(uiPanePrefsBase)
    set(uiPanePrefsBase, { ...prev, ...update })
  }
)


```

```typescriptreact
"use client"

import * as React from "react"
import { useCallback, useEffect } from "react"
import { useAtom, useAtomValue } from "jotai"

import { LibraryHeader } from "./library-header"
import { FileTree } from "./file-tree"
import { FileList } from "./file-list"
import dynamic from 'next/dynamic'
const FilePreviewLazy = dynamic(() => import('./file-preview').then(m => m.FilePreview), {
  ssr: false,
  loading: () => (
    <div className="h-full flex items-center justify-center text-muted-foreground">
      Lade Vorschau...
    </div>
  )
})
import { ResizableHandle, ResizablePanel, ResizablePanelGroup } from "@/components/ui/resizable"
import { 
  libraryAtom, 
  folderItemsAtom,
  loadingStateAtom,
  lastLoadedFolderAtom,
  currentFolderIdAtom,
  reviewModeAtom,
  selectedFileAtom,
  selectedShadowTwinAtom
} from "@/atoms/library-atom"
import { activeLibraryIdAtom } from "@/atoms/library-atom"
import { useStorage, isStorageError } from "@/contexts/storage-context"
import { TranscriptionDialog } from "./transcription-dialog"
import { TransformationDialog } from "./transformation-dialog"
import { StorageItem } from "@/lib/storage/types"
import { NavigationLogger, StateLogger, UILogger } from "@/lib/debug/logger"
import { Breadcrumb } from "./breadcrumb"
import { useToast } from "@/components/ui/use-toast"
import { ChevronLeft, ChevronRight } from "lucide-react"
import { useSearchParams } from "next/navigation"
import { useFolderNavigation } from "@/hooks/use-folder-navigation"
import { uiPanePrefsAtom } from "@/atoms/ui-prefs-atom"
export function Library() {
  // Performance-Messung für Kaltstart (nur Client)
  const startupT0Ref = React.useRef<number>(
    typeof performance !== 'undefined' ? performance.now() : 0
  );
  // Globale Atoms
  const [, setFolderItems] = useAtom(folderItemsAtom);
  const [, setLoadingState] = useAtom(loadingStateAtom);
  const [lastLoadedFolder, setLastLoadedFolder] = useAtom(lastLoadedFolderAtom);
  const [currentFolderId] = useAtom(currentFolderIdAtom);
  const [libraryState, setLibraryState] = useAtom(libraryAtom);
  const activeLibraryId = useAtomValue(activeLibraryIdAtom);
  
  // Review-Mode Atoms
  const [isReviewMode] = useAtom(reviewModeAtom);
  const [selectedFile, setSelectedFile] = useAtom(selectedFileAtom);
  const [selectedShadowTwin, setSelectedShadowTwin] = useAtom(selectedShadowTwinAtom);
  
  // Storage Context
  const { 
    provider: providerInstance, 
    error: storageError, 
    listItems,
    libraryStatus,
    currentLibrary
  } = useStorage();
  const { toast } = useToast();
  const [uiPrefs, setUiPrefs] = useAtom(uiPanePrefsAtom)
  const isTreeVisible = uiPrefs.treeVisible
  const isListCompact = uiPrefs.listCompact
  const [isMobile, setIsMobile] = React.useState<boolean>(false);
  const [mobileView, setMobileView] = React.useState<'list' | 'preview'>('list');
  const loadInFlightRef = React.useRef<boolean>(false);
  const searchParams = useSearchParams();
  const navigateToFolder = useFolderNavigation();

  // Mobile: Tree standardmäßig ausblenden, Desktop: anzeigen
  React.useEffect(() => {
    if (typeof window === 'undefined') return;
    // Desktop ab 1024px, Mobile darunter
    const mq = window.matchMedia('(max-width: 1023px)');
    const apply = (matches: boolean) => {
      setIsMobile(matches);
      setIsTreeVisible(!matches);
    };
    apply(mq.matches);
    const handler = (e: MediaQueryListEvent) => apply(e.matches);
    mq.addEventListener('change', handler);
    return () => mq.removeEventListener('change', handler);
  }, []);

  // URL -> State: folderId aus Query anwenden, wenn Provider bereit ist
  const urlInitAppliedRef = React.useRef(false);
  React.useEffect(() => {
    const folderIdFromUrl = searchParams?.get('folderId');

    if (urlInitAppliedRef.current) return;

    if (!folderIdFromUrl) {
      NavigationLogger.debug('debug@init', 'No folderId in URL', {
        currentFolderId
      });
      urlInitAppliedRef.current = true;
      return;
    }

    if (!providerInstance || libraryStatus !== 'ready') {
      NavigationLogger.debug('debug@init', 'Provider not ready, deferring URL apply', {
        folderIdFromUrl,
        libraryStatus,
        hasProvider: !!providerInstance
      });
      return;
    }

    if (folderIdFromUrl !== currentFolderId) {
      NavigationLogger.info('debug@init', 'Applying folderId from URL (ready)', {
        folderIdFromUrl,
        currentFolderId
      });
      void navigateToFolder(folderIdFromUrl);
    }
    urlInitAppliedRef.current = true;
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [searchParams, providerInstance, libraryStatus, currentFolderId]);

  // Mobile-View Wechsellogik: bei Dateiauswahl zur Vorschau wechseln
  React.useEffect(() => {
    if (!isMobile) return;
    if (selectedFile) setMobileView('preview');
  }, [isMobile, selectedFile]);

  // Optimierter loadItems mit Cache-Check
  const loadItems = useCallback(async () => {
    if (loadInFlightRef.current) {
      NavigationLogger.debug('Library', 'Skip loadItems - load already in flight');
      return;
    }
    if (!providerInstance || libraryStatus !== 'ready') {
      NavigationLogger.debug('Library', 'Skipping loadItems - not ready', {
        hasProvider: !!providerInstance,
        status: libraryStatus
      });
      return;
    }

    // Schutz: Wenn Provider/Context noch auf alte Library zeigt, keine Items übernehmen
    if (currentLibrary?.id && currentLibrary.id !== activeLibraryId) {
      NavigationLogger.debug('Library', 'Skip loadItems - library mismatch', {
        providerLibraryId: currentLibrary.id,
        activeLibraryId
      });
      return;
    }

    loadInFlightRef.current = true;
    setLoadingState({ isLoading: true, loadingFolderId: currentFolderId });

    try {
      // Snapshot zur Vermeidung von Race-Conditions
      const expectedLibraryId = activeLibraryId;
      const expectedFolderId = currentFolderId;

      // Prüfe Cache zuerst
      if (libraryState.folderCache?.[currentFolderId]?.children) {
        const cachedItems = libraryState.folderCache[currentFolderId].children;
        NavigationLogger.info('Library', 'Using cached items', {
          folderId: currentFolderId,
          itemCount: cachedItems.length,
          cacheHit: true
        });
        // Übernehme nur, wenn der Snapshot noch aktuell ist
        if (expectedLibraryId === activeLibraryId && expectedFolderId === currentFolderId) {
          setFolderItems(cachedItems);
          setLastLoadedFolder(currentFolderId);
        }
        return;
      }

      NavigationLogger.info('Library', 'Fetching items from provider', {
        folderId: currentFolderId,
        cacheHit: false
      });
      
      const items = await listItems(currentFolderId);

      // Falls während des Ladens die Library oder der Ordner wechselte: Ergebnis verwerfen
      if (expectedLibraryId !== activeLibraryId || expectedFolderId !== currentFolderId) {
        NavigationLogger.debug('Library', 'Discard loaded items due to context change', {
          expectedLibraryId,
          activeLibraryId,
          expectedFolderId,
          currentFolderId
        });
        return;
      }
      
      // Update Cache und State
      if (currentFolderId !== 'root') {
        const newFolderCache = { ...libraryState.folderCache };
        const parent = newFolderCache[currentFolderId];
        if (parent) {
          newFolderCache[currentFolderId] = {
            ...parent,
            children: items
          };
          StateLogger.info('Library', 'Updating folder cache', {
            folderId: currentFolderId,
            itemCount: items.length,
            cacheSize: Object.keys(newFolderCache).length
          });
          setLibraryState(state => ({
            ...state,
            folderCache: newFolderCache
          }));
        }
      }
      
      setFolderItems(items);
      setLastLoadedFolder(currentFolderId);
      
      StateLogger.info('Library', 'Items loaded successfully', {
        folderId: currentFolderId,
        itemCount: items.length,
        fileCount: items.filter(i => i.type === 'file').length,
        folderCount: items.filter(i => i.type === 'folder').length,
        tSinceMountMs: startupT0Ref.current ? Number((performance.now() - startupT0Ref.current).toFixed(1)) : undefined
      });
      
    } catch (error) {
      if (isStorageError(error) && error.code === 'AUTH_REQUIRED') {
        StateLogger.info('Library', 'Auth required');
        // Keine Fehlermeldung für AUTH_REQUIRED anzeigen
      } else {
        StateLogger.error('Library', 'Failed to load items', {
          error: error instanceof Error ? {
            message: error.message,
            name: error.name,
            stack: error.stack?.split('\n').slice(0, 3)
          } : error,
          folderId: currentFolderId,
          libraryId: currentLibrary?.id,
          libraryPath: currentLibrary?.path
        });
        
        // Benutzerfreundliche Fehlermeldung anzeigen
        let errorMessage = 'Fehler beim Laden der Dateien';
        
        if (error instanceof Error) {
          if (error.message.includes('Nicht authentifiziert')) {
            errorMessage = 'Bitte authentifizieren Sie sich bei Ihrem Cloud-Speicher.';
          } else if (error.message.includes('Bibliothek nicht gefunden')) {
            errorMessage = 'Die ausgewählte Bibliothek wurde nicht gefunden. Bitte überprüfen Sie die Bibliothekskonfiguration.';
          } else if (error.message.includes('Server-Fehler')) {
            errorMessage = 'Server-Fehler beim Laden der Dateien. Bitte überprüfen Sie, ob der Bibliothekspfad existiert und zugänglich ist.';
          } else if (error.message.includes('Keine aktive Bibliothek')) {
            errorMessage = 'Keine aktive Bibliothek verfügbar. Bitte wählen Sie eine Bibliothek aus.';
          } else {
            errorMessage = error.message;
          }
        }
        
        // Toast-Nachricht anzeigen
        toast({
          title: "Fehler beim Laden der Dateien",
          description: errorMessage,
          variant: "destructive",
        });
      }
      setFolderItems([]);
    } finally {
      setLoadingState({ isLoading: false, loadingFolderId: null });
      loadInFlightRef.current = false;
    }
  }, [
    currentFolderId,
    lastLoadedFolder,
    listItems,
    libraryState.folderCache,
    providerInstance,
    libraryStatus,
    setLibraryState,
    setFolderItems,
    setLastLoadedFolder,
    setLoadingState,
    toast,
    currentLibrary
  ]);

  // Effect für Initial-Load (entkoppelt vom FileTree)
  useEffect(() => {
    const isReady = !!providerInstance && libraryStatus === 'ready';
    
    if (!isReady) {
      NavigationLogger.debug('Library', 'Waiting for initialization', {
        hasProvider: !!providerInstance,
        status: libraryStatus
      });
      return;
    }

    // Wenn eine folderId in der URL steht und noch nicht angewendet wurde,
    // verhindere das initiale Laden von "root" (vermeidet Doppel-Load)
    const folderIdFromUrl = searchParams?.get('folderId');
    if (!urlInitAppliedRef.current && folderIdFromUrl && folderIdFromUrl !== currentFolderId) {
      NavigationLogger.debug('debug@init', 'Skip initial root load; URL folderId pending', {
        folderIdFromUrl,
        currentFolderId,
        lastLoadedFolder
      });
      return;
    }

    // Nur laden wenn noch nicht geladen
    if (lastLoadedFolder !== currentFolderId && !loadInFlightRef.current) {
      UILogger.info('Library', 'Initial load triggered', {
        currentFolderId,
        lastLoadedFolder,
        tSinceMountMs: startupT0Ref.current ? Number((performance.now() - startupT0Ref.current).toFixed(1)) : undefined
      });
      NavigationLogger.info('Library', 'Loading initial items', {
        folderId: currentFolderId
      });
      loadItems();
    }
  }, [providerInstance, libraryStatus, currentFolderId, lastLoadedFolder, activeLibraryId, loadItems, searchParams]);

  // Zusätzlicher Reset bei Bibliothekswechsel (robust gegen Status-Race)
  useEffect(() => {
    if (!activeLibraryId) return;
    StateLogger.info('Library', 'Active library changed - reset initial load state', {
      activeLibraryId,
      currentFolderId
    });
    setLastLoadedFolder(null);
    setFolderItems([]);
    setLibraryState(state => ({ ...state, folderCache: {} }));
    // WICHTIG: Ordnerauswahl und Shadow-Twin zurücksetzen
    setSelectedFile(null);
    setSelectedShadowTwin(null);
  }, [activeLibraryId, setLastLoadedFolder, setFolderItems, setLibraryState, currentFolderId]);

  // Reset Cache wenn sich die Library ändert
  useEffect(() => {
    setLastLoadedFolder(null);
    setLibraryState(state => ({
      ...state,
      folderCache: {}
    }));
  }, [libraryStatus, setLibraryState, setLastLoadedFolder]);

  // Manuelle Cache-Clear-Funktion für Review-Modus
  const clearCache = useCallback(() => {
    StateLogger.info('Library', 'Manually clearing cache for review mode');
    setLastLoadedFolder(null);
    setLibraryState(state => ({
      ...state,
      folderCache: {}
    }));
    setFolderItems([]);
  }, [setLibraryState, setLastLoadedFolder, setFolderItems]);

  // Reset selectedShadowTwin wenn Review-Modus verlassen wird
  useEffect(() => {
    if (!isReviewMode) {
      setSelectedShadowTwin(null);
    }
  }, [isReviewMode, setSelectedShadowTwin]);

  // ENTFERNT: Der folgende useEffect war problematisch und hat das Shadow-Twin 
  // bei jedem Klick zurückgesetzt, auch wenn die Datei ein Shadow-Twin hat.
  // Die Shadow-Twin-Logik wird bereits korrekt in der FileList-Komponente 
  // in der handleSelect-Funktion behandelt.

  // Render-Logik für verschiedene Status
  if (libraryStatus === "waitingForAuth") {
    return (
      <div className="flex flex-col items-center justify-center h-full text-muted-foreground">
        <span>Diese Bibliothek benötigt eine Authentifizierung.</span>
        <span className="text-sm mt-2">Bitte konfigurieren Sie die Bibliothek in den Einstellungen.</span>
      </div>
    );
  }
  
  if (libraryStatus !== "ready") {
    return (
      <div className="flex flex-col items-center justify-center h-full text-muted-foreground">
        <span>Lade Storage...</span>
      </div>
    );
  }

  return (
    <div className="flex flex-col h-full">
      <LibraryHeader
        provider={providerInstance}
        error={storageError}
        onUploadComplete={loadItems}
        onClearCache={clearCache}
        isTreeVisible={isTreeVisible}
        onToggleTree={() => setUiPrefs({ treeVisible: !isTreeVisible })}
        isCompactList={isListCompact}
        onToggleCompactList={() => setUiPrefs({ listCompact: !isListCompact })}
      >
        <Breadcrumb />
      </LibraryHeader>
      
      <div className="flex-1 min-h-0 overflow-hidden">
        {isReviewMode ? (
          // Review-Layout: 3 Panels ohne FileTree - FileList (compact) | FilePreview (Basis-Datei) | FilePreview (Shadow-Twin)
          <ResizablePanelGroup direction="horizontal" className="h-full">
            <ResizablePanel defaultSize={25} minSize={20} className="min-h-0">
              <div className="h-full overflow-auto flex flex-col">
                <FileList compact={true} />
              </div>
            </ResizablePanel>
            <ResizableHandle />
            <ResizablePanel defaultSize={37.5} minSize={30} className="min-h-0">
              <div className="h-full relative flex flex-col">
                {selectedFile ? (
                  <FilePreviewLazy
                    provider={providerInstance}
                    file={selectedFile}
                    onRefreshFolder={(folderId, items, selectFileAfterRefresh) => {
                    StateLogger.info('Library', 'FilePreview (Basis) onRefreshFolder aufgerufen', {
                      folderId,
                      itemsCount: items.length,
                      hasSelectFile: !!selectFileAfterRefresh
                    });
                    
                    // Aktualisiere die Dateiliste
                    setFolderItems(items);
                    
                    // Aktualisiere den Cache
                    if (libraryState.folderCache?.[folderId]) {
                      const cachedFolder = libraryState.folderCache[folderId];
                      if (cachedFolder) {
                        setLibraryState(state => ({
                          ...state,
                          folderCache: {
                            ...(state.folderCache || {}),
                            [folderId]: {
                              ...cachedFolder,
                              children: items
                            }
                          }
                        }));
                      }
                    }
                    
                    // Wenn eine Datei ausgewählt werden soll (nach dem Speichern)
                    if (selectFileAfterRefresh) {
                      StateLogger.info('Library', 'Wähle gespeicherte Datei aus', {
                        fileId: selectFileAfterRefresh.id,
                        fileName: selectFileAfterRefresh.metadata.name
                      });
                    }
                    }}
                  />
                ) : (
                  <div className="h-full flex items-center justify-center text-muted-foreground">
                    <p>Keine Datei ausgewählt</p>
                  </div>
                )}
              </div>
            </ResizablePanel>
            <ResizableHandle />
            <ResizablePanel defaultSize={37.5} minSize={30} className="min-h-0">
              <div className="h-full relative flex flex-col">
                {selectedShadowTwin ? (
                  <FilePreviewLazy
                    provider={providerInstance}
                    file={selectedShadowTwin}
                    onRefreshFolder={(folderId, items, selectFileAfterRefresh) => {
                      StateLogger.info('Library', 'FilePreview (Shadow-Twin) onRefreshFolder aufgerufen', {
                        folderId,
                        itemsCount: items.length,
                        hasSelectFile: !!selectFileAfterRefresh
                      });
                      
                      // Aktualisiere die Dateiliste
                      setFolderItems(items);
                      
                      // Aktualisiere den Cache
                      if (libraryState.folderCache?.[folderId]) {
                        const cachedFolder = libraryState.folderCache[folderId];
                        if (cachedFolder) {
                          setLibraryState(state => ({
                            ...state,
                            folderCache: {
                              ...(state.folderCache || {}),
                              [folderId]: {
                                ...cachedFolder,
                                children: items
                              }
                            }
                          }));
                        }
                      }
                      
                      // Wenn eine Datei ausgewählt werden soll (nach dem Speichern)
                      if (selectFileAfterRefresh) {
                        StateLogger.info('Library', 'Wähle gespeicherte Datei aus', {
                          fileId: selectFileAfterRefresh.id,
                          fileName: selectFileAfterRefresh.metadata.name
                        });
                      }
                    }}
                  />
                ) : (
                  <div className="h-full flex items-center justify-center text-muted-foreground">
                    <p>Kein Shadow-Twin ausgewählt</p>
                  </div>
                )}
              </div>
            </ResizablePanel>
          </ResizablePanelGroup>
        ) : (
          // Normal-Layout (Desktop) oder alternierendes Mobile-Layout
          <div className="relative h-full">
            {/* Entfernt: alter Tree-Handle (ersetzt durch Header-Toggle) */}

            {isMobile ? (
              mobileView === 'list' ? (
                <div className="h-full overflow-auto flex flex-col">
                  <FileList />
                </div>
              ) : (
                <div className="h-full flex flex-col">
                  <div className="flex items-center gap-2 p-2 border-b bg-background">
                    <button
                      type="button"
                      className="inline-flex items-center gap-1 text-sm px-2 py-1 border rounded-md"
                      onClick={() => {
                        setMobileView('list');
                        setSelectedShadowTwin(null);
                        setSelectedFile(null);
                        loadItems();
                      }}
                    >
                      <ChevronLeft className="h-4 w-4" />
                      Zurück
                    </button>
                    <div className="text-sm text-muted-foreground truncate">
                      {selectedFile?.metadata.name}
                    </div>
                  </div>
                  <div className="flex-1 min-h-0">
                    {selectedFile ? (
                      <FilePreviewLazy
                        provider={providerInstance}
                        onRefreshFolder={(folderId, items, selectFileAfterRefresh) => {
                        StateLogger.info('Library', 'FilePreview onRefreshFolder aufgerufen', {
                          folderId,
                          itemsCount: items.length,
                          hasSelectFile: !!selectFileAfterRefresh
                        });
                        setFolderItems(items);
                        if (libraryState.folderCache?.[folderId]) {
                          const cachedFolder = libraryState.folderCache[folderId];
                          if (cachedFolder) {
                            setLibraryState(state => ({
                              ...state,
                              folderCache: {
                                ...(state.folderCache || {}),
                                [folderId]: { ...cachedFolder, children: items }
                              }
                            }));
                          }
                        }
                        }}
                      />
                    ) : (
                      <div className="h-full flex items-center justify-center text-muted-foreground">
                        <p>Keine Datei ausgewählt</p>
                      </div>
                    )}
                  </div>
                </div>
              )
            ) : (
              <ResizablePanelGroup
                key={`layout-${isTreeVisible ? 'tree' : 'notree'}-${isListCompact ? 'compact' : 'list'}`}
                direction="horizontal"
                className="h-full"
                autoSaveId={`library-panels-${isTreeVisible ? '3' : '2'}-${isListCompact ? 'c' : 'n'}`}
              >
                {isTreeVisible && (
                  <>
                    <ResizablePanel key={`tree-panel-${isTreeVisible ? 't' : 'nt'}`} id="tree" defaultSize={15} minSize={15} className="min-h-0">
                      <div className="h-full overflow-auto flex flex-col">
                        <FileTree />
                      </div>
                    </ResizablePanel>
                    <ResizableHandle key="tree-handle" />
                  </>
                )}
                <>
                  <ResizablePanel key={`list-panel-${isListCompact ? 'c' : 'n'}-${isTreeVisible ? 't' : 'nt'}`} id="list" defaultSize={isListCompact ? 15 : 30} minSize={15} className="min-h-0 transition-[flex-basis] duration-200 ease-in-out">
                    <div className="h-full overflow-auto flex flex-col">
                      <FileList compact={isListCompact} />
                    </div>
                  </ResizablePanel>
                  <ResizableHandle key="list-preview-handle" />
                </>
                <ResizablePanel key={`preview-panel-${isListCompact ? 'c' : 'n'}-${isTreeVisible ? 't' : 'nt'}`} id="preview" defaultSize={(() => {
                  const tree = isTreeVisible ? 15 : 0;
                  const list = isListCompact ? 15 : 30;
                  const rest = Math.max(10, 100 - (tree + list));
                  return rest;
                })()} className="min-h-0 transition-[flex-basis] duration-200 ease-in-out">
                  <div className="h-full relative flex flex-col">
                    {selectedFile ? (
                      <FilePreviewLazy
                        provider={providerInstance}
                        onRefreshFolder={(folderId, items, selectFileAfterRefresh) => {
                        StateLogger.info('Library', 'FilePreview onRefreshFolder aufgerufen', {
                          folderId,
                          itemsCount: items.length,
                          hasSelectFile: !!selectFileAfterRefresh
                        });
                        
                        // Aktualisiere die Dateiliste
                        setFolderItems(items);
                        
                        // Aktualisiere den Cache
                        if (libraryState.folderCache?.[folderId]) {
                          const cachedFolder = libraryState.folderCache[folderId];
                          if (cachedFolder) {
                            setLibraryState(state => ({
                              ...state,
                              folderCache: {
                                ...(state.folderCache || {}),
                                [folderId]: {
                                  ...cachedFolder,
                                  children: items
                                }
                              }
                            }));
                          }
                        }
                        
                        if (selectFileAfterRefresh) {
                          StateLogger.info('Library', 'Wähle gespeicherte Datei aus', {
                            fileId: selectFileAfterRefresh.id,
                            fileName: selectFileAfterRefresh.metadata.name
                          });
                        }
                        }}
                      />
                    ) : (
                      <div className="h-full flex items-center justify-center text-muted-foreground">
                        <p>Keine Datei ausgewählt</p>
                      </div>
                    )}
                  </div>
                </ResizablePanel>
              </ResizablePanelGroup>
            )}
          </div>
        )}
      </div>
      
      {/* Dialoge */}
      <TranscriptionDialog />
      <TransformationDialog 
        onRefreshFolder={(folderId: string, items: StorageItem[], selectFileAfterRefresh?: StorageItem) => {
          StateLogger.info('Library', 'TransformationDialog onRefreshFolder aufgerufen', {
            folderId,
            itemsCount: items.length,
            hasSelectFile: !!selectFileAfterRefresh
          });
          
          // Aktualisiere die Dateiliste
          setFolderItems(items);
          
          // Aktualisiere den Cache
          if (libraryState.folderCache?.[folderId]) {
            const cachedFolder = libraryState.folderCache[folderId];
            if (cachedFolder) {
              setLibraryState(state => ({
                ...state,
                folderCache: {
                  ...(state.folderCache || {}),
                  [folderId]: {
                    ...cachedFolder,
                    children: items
                  }
                }
              }));
            }
          }
          
          // Wenn eine Datei ausgewählt werden soll (nach dem Speichern)
          if (selectFileAfterRefresh) {
            StateLogger.info('Library', 'Wähle gespeicherte Datei aus', {
              fileId: selectFileAfterRefresh.id,
              fileName: selectFileAfterRefresh.metadata.name
            });
          }
        }}
      />
    </div>
  );
}
```

Aktuell:
- Die Pane-Breiten speichert das Resizable-Layout über autoSaveId in localStorage. Durch unsere neuen Keys wird je Kombi (Tree an/aus, Kompakt/Normal) separat gespeichert.
- Die Toggle-Buttons (Tree sichtbar, Liste kompakt) waren zuvor nur im Component-State. Ich habe sie jetzt persistent gemacht:
  - Neues `uiPanePrefsAtom` mit `atomWithStorage` (Key `ui:pane-prefs`).
  - `treeVisible` und `listCompact` werden in localStorage gehalten.
  - `LibraryHeader` toggelt nun diese gespeicherten Werte.

Erwartetes Verhalten:
- Umschalten auf Kompakt oder Tree an/aus bleibt nach Reload erhalten.
- Wechsel auf Mobile und zurück behält die Präferenzen.
- Pane-Breiten werden je Layout‑Kombination (Tree/Compact) unabhängig gespeichert.

Wenn du zusätzlich pro Bibliothek getrennte UI‑Prefs willst, erweitere ich den Storage‑Key z. B. auf `ui:pane-prefs:${activeLibraryId}`.

---

**User**

ReferenceError: setIsTreeVisible is not defined
    at Library.useEffect.apply (webpack-internal:///(app-pages-browser)/./src/components/library/library.tsx:100:21)
    at Library.useEffect (webpack-internal:///(app-pages-browser)/./src/components/library/library.tsx:103:13)
    at LibraryPage (webpack-internal:///(app-pages-browser)/./src/app/library/page.tsx:304:102)
    at ClientPageRoot (webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/next@15.3.2_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/next/dist/client/components/client-page.js:20:50)

---

**Cursor**

```typescriptreact
"use client"

import * as React from "react"
import { useCallback, useEffect } from "react"
import { useAtom, useAtomValue } from "jotai"

import { LibraryHeader } from "./library-header"
import { FileTree } from "./file-tree"
import { FileList } from "./file-list"
import dynamic from 'next/dynamic'
const FilePreviewLazy = dynamic(() => import('./file-preview').then(m => m.FilePreview), {
  ssr: false,
  loading: () => (
    <div className="h-full flex items-center justify-center text-muted-foreground">
      Lade Vorschau...
    </div>
  )
})
import { ResizableHandle, ResizablePanel, ResizablePanelGroup } from "@/components/ui/resizable"
import { 
  libraryAtom, 
  folderItemsAtom,
  loadingStateAtom,
  lastLoadedFolderAtom,
  currentFolderIdAtom,
  reviewModeAtom,
  selectedFileAtom,
  selectedShadowTwinAtom
} from "@/atoms/library-atom"
import { activeLibraryIdAtom } from "@/atoms/library-atom"
import { useStorage, isStorageError } from "@/contexts/storage-context"
import { TranscriptionDialog } from "./transcription-dialog"
import { TransformationDialog } from "./transformation-dialog"
import { StorageItem } from "@/lib/storage/types"
import { NavigationLogger, StateLogger, UILogger } from "@/lib/debug/logger"
import { Breadcrumb } from "./breadcrumb"
import { useToast } from "@/components/ui/use-toast"
import { ChevronLeft, ChevronRight } from "lucide-react"
import { useSearchParams } from "next/navigation"
import { useFolderNavigation } from "@/hooks/use-folder-navigation"
import { uiPanePrefsAtom } from "@/atoms/ui-prefs-atom"
export function Library() {
  // Performance-Messung für Kaltstart (nur Client)
  const startupT0Ref = React.useRef<number>(
    typeof performance !== 'undefined' ? performance.now() : 0
  );
  // Globale Atoms
  const [, setFolderItems] = useAtom(folderItemsAtom);
  const [, setLoadingState] = useAtom(loadingStateAtom);
  const [lastLoadedFolder, setLastLoadedFolder] = useAtom(lastLoadedFolderAtom);
  const [currentFolderId] = useAtom(currentFolderIdAtom);
  const [libraryState, setLibraryState] = useAtom(libraryAtom);
  const activeLibraryId = useAtomValue(activeLibraryIdAtom);
  
  // Review-Mode Atoms
  const [isReviewMode] = useAtom(reviewModeAtom);
  const [selectedFile, setSelectedFile] = useAtom(selectedFileAtom);
  const [selectedShadowTwin, setSelectedShadowTwin] = useAtom(selectedShadowTwinAtom);
  
  // Storage Context
  const { 
    provider: providerInstance, 
    error: storageError, 
    listItems,
    libraryStatus,
    currentLibrary
  } = useStorage();
  const { toast } = useToast();
  const [uiPrefs, setUiPrefs] = useAtom(uiPanePrefsAtom)
  const isTreeVisible = uiPrefs.treeVisible
  const isListCompact = uiPrefs.listCompact
  const [isMobile, setIsMobile] = React.useState<boolean>(false);
  const [mobileView, setMobileView] = React.useState<'list' | 'preview'>('list');
  const loadInFlightRef = React.useRef<boolean>(false);
  const searchParams = useSearchParams();
  const navigateToFolder = useFolderNavigation();

  // Mobile: Tree standardmäßig ausblenden, Desktop: anzeigen
  React.useEffect(() => {
    if (typeof window === 'undefined') return;
    // Desktop ab 1024px, Mobile darunter
    const mq = window.matchMedia('(max-width: 1023px)');
    const apply = (matches: boolean) => {
      // Nur Mobile-Flag setzen; Tree-Visibility bleibt persistent über uiPanePrefsAtom
      setIsMobile(matches);
    };
    apply(mq.matches);
    const handler = (e: MediaQueryListEvent) => apply(e.matches);
    mq.addEventListener('change', handler);
    return () => mq.removeEventListener('change', handler);
  }, []);

  // URL -> State: folderId aus Query anwenden, wenn Provider bereit ist
  const urlInitAppliedRef = React.useRef(false);
  React.useEffect(() => {
    const folderIdFromUrl = searchParams?.get('folderId');

    if (urlInitAppliedRef.current) return;

    if (!folderIdFromUrl) {
      NavigationLogger.debug('debug@init', 'No folderId in URL', {
        currentFolderId
      });
      urlInitAppliedRef.current = true;
      return;
    }

    if (!providerInstance || libraryStatus !== 'ready') {
      NavigationLogger.debug('debug@init', 'Provider not ready, deferring URL apply', {
        folderIdFromUrl,
        libraryStatus,
        hasProvider: !!providerInstance
      });
      return;
    }

    if (folderIdFromUrl !== currentFolderId) {
      NavigationLogger.info('debug@init', 'Applying folderId from URL (ready)', {
        folderIdFromUrl,
        currentFolderId
      });
      void navigateToFolder(folderIdFromUrl);
    }
    urlInitAppliedRef.current = true;
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [searchParams, providerInstance, libraryStatus, currentFolderId]);

  // Mobile-View Wechsellogik: bei Dateiauswahl zur Vorschau wechseln
  React.useEffect(() => {
    if (!isMobile) return;
    if (selectedFile) setMobileView('preview');
  }, [isMobile, selectedFile]);

  // Optimierter loadItems mit Cache-Check
  const loadItems = useCallback(async () => {
    if (loadInFlightRef.current) {
      NavigationLogger.debug('Library', 'Skip loadItems - load already in flight');
      return;
    }
    if (!providerInstance || libraryStatus !== 'ready') {
      NavigationLogger.debug('Library', 'Skipping loadItems - not ready', {
        hasProvider: !!providerInstance,
        status: libraryStatus
      });
      return;
    }

    // Schutz: Wenn Provider/Context noch auf alte Library zeigt, keine Items übernehmen
    if (currentLibrary?.id && currentLibrary.id !== activeLibraryId) {
      NavigationLogger.debug('Library', 'Skip loadItems - library mismatch', {
        providerLibraryId: currentLibrary.id,
        activeLibraryId
      });
      return;
    }

    loadInFlightRef.current = true;
    setLoadingState({ isLoading: true, loadingFolderId: currentFolderId });

    try {
      // Snapshot zur Vermeidung von Race-Conditions
      const expectedLibraryId = activeLibraryId;
      const expectedFolderId = currentFolderId;

      // Prüfe Cache zuerst
      if (libraryState.folderCache?.[currentFolderId]?.children) {
        const cachedItems = libraryState.folderCache[currentFolderId].children;
        NavigationLogger.info('Library', 'Using cached items', {
          folderId: currentFolderId,
          itemCount: cachedItems.length,
          cacheHit: true
        });
        // Übernehme nur, wenn der Snapshot noch aktuell ist
        if (expectedLibraryId === activeLibraryId && expectedFolderId === currentFolderId) {
          setFolderItems(cachedItems);
          setLastLoadedFolder(currentFolderId);
        }
        return;
      }

      NavigationLogger.info('Library', 'Fetching items from provider', {
        folderId: currentFolderId,
        cacheHit: false
      });
      
      const items = await listItems(currentFolderId);

      // Falls während des Ladens die Library oder der Ordner wechselte: Ergebnis verwerfen
      if (expectedLibraryId !== activeLibraryId || expectedFolderId !== currentFolderId) {
        NavigationLogger.debug('Library', 'Discard loaded items due to context change', {
          expectedLibraryId,
          activeLibraryId,
          expectedFolderId,
          currentFolderId
        });
        return;
      }
      
      // Update Cache und State
      if (currentFolderId !== 'root') {
        const newFolderCache = { ...libraryState.folderCache };
        const parent = newFolderCache[currentFolderId];
        if (parent) {
          newFolderCache[currentFolderId] = {
            ...parent,
            children: items
          };
          StateLogger.info('Library', 'Updating folder cache', {
            folderId: currentFolderId,
            itemCount: items.length,
            cacheSize: Object.keys(newFolderCache).length
          });
          setLibraryState(state => ({
            ...state,
            folderCache: newFolderCache
          }));
        }
      }
      
      setFolderItems(items);
      setLastLoadedFolder(currentFolderId);
      
      StateLogger.info('Library', 'Items loaded successfully', {
        folderId: currentFolderId,
        itemCount: items.length,
        fileCount: items.filter(i => i.type === 'file').length,
        folderCount: items.filter(i => i.type === 'folder').length,
        tSinceMountMs: startupT0Ref.current ? Number((performance.now() - startupT0Ref.current).toFixed(1)) : undefined
      });
      
    } catch (error) {
      if (isStorageError(error) && error.code === 'AUTH_REQUIRED') {
        StateLogger.info('Library', 'Auth required');
        // Keine Fehlermeldung für AUTH_REQUIRED anzeigen
      } else {
        StateLogger.error('Library', 'Failed to load items', {
          error: error instanceof Error ? {
            message: error.message,
            name: error.name,
            stack: error.stack?.split('\n').slice(0, 3)
          } : error,
          folderId: currentFolderId,
          libraryId: currentLibrary?.id,
          libraryPath: currentLibrary?.path
        });
        
        // Benutzerfreundliche Fehlermeldung anzeigen
        let errorMessage = 'Fehler beim Laden der Dateien';
        
        if (error instanceof Error) {
          if (error.message.includes('Nicht authentifiziert')) {
            errorMessage = 'Bitte authentifizieren Sie sich bei Ihrem Cloud-Speicher.';
          } else if (error.message.includes('Bibliothek nicht gefunden')) {
            errorMessage = 'Die ausgewählte Bibliothek wurde nicht gefunden. Bitte überprüfen Sie die Bibliothekskonfiguration.';
          } else if (error.message.includes('Server-Fehler')) {
            errorMessage = 'Server-Fehler beim Laden der Dateien. Bitte überprüfen Sie, ob der Bibliothekspfad existiert und zugänglich ist.';
          } else if (error.message.includes('Keine aktive Bibliothek')) {
            errorMessage = 'Keine aktive Bibliothek verfügbar. Bitte wählen Sie eine Bibliothek aus.';
          } else {
            errorMessage = error.message;
          }
        }
        
        // Toast-Nachricht anzeigen
        toast({
          title: "Fehler beim Laden der Dateien",
          description: errorMessage,
          variant: "destructive",
        });
      }
      setFolderItems([]);
    } finally {
      setLoadingState({ isLoading: false, loadingFolderId: null });
      loadInFlightRef.current = false;
    }
  }, [
    currentFolderId,
    lastLoadedFolder,
    listItems,
    libraryState.folderCache,
    providerInstance,
    libraryStatus,
    setLibraryState,
    setFolderItems,
    setLastLoadedFolder,
    setLoadingState,
    toast,
    currentLibrary
  ]);

  // Effect für Initial-Load (entkoppelt vom FileTree)
  useEffect(() => {
    const isReady = !!providerInstance && libraryStatus === 'ready';
    
    if (!isReady) {
      NavigationLogger.debug('Library', 'Waiting for initialization', {
        hasProvider: !!providerInstance,
        status: libraryStatus
      });
      return;
    }

    // Wenn eine folderId in der URL steht und noch nicht angewendet wurde,
    // verhindere das initiale Laden von "root" (vermeidet Doppel-Load)
    const folderIdFromUrl = searchParams?.get('folderId');
    if (!urlInitAppliedRef.current && folderIdFromUrl && folderIdFromUrl !== currentFolderId) {
      NavigationLogger.debug('debug@init', 'Skip initial root load; URL folderId pending', {
        folderIdFromUrl,
        currentFolderId,
        lastLoadedFolder
      });
      return;
    }

    // Nur laden wenn noch nicht geladen
    if (lastLoadedFolder !== currentFolderId && !loadInFlightRef.current) {
      UILogger.info('Library', 'Initial load triggered', {
        currentFolderId,
        lastLoadedFolder,
        tSinceMountMs: startupT0Ref.current ? Number((performance.now() - startupT0Ref.current).toFixed(1)) : undefined
      });
      NavigationLogger.info('Library', 'Loading initial items', {
        folderId: currentFolderId
      });
      loadItems();
    }
  }, [providerInstance, libraryStatus, currentFolderId, lastLoadedFolder, activeLibraryId, loadItems, searchParams]);

  // Zusätzlicher Reset bei Bibliothekswechsel (robust gegen Status-Race)
  useEffect(() => {
    if (!activeLibraryId) return;
    StateLogger.info('Library', 'Active library changed - reset initial load state', {
      activeLibraryId,
      currentFolderId
    });
    setLastLoadedFolder(null);
    setFolderItems([]);
    setLibraryState(state => ({ ...state, folderCache: {} }));
    // WICHTIG: Ordnerauswahl und Shadow-Twin zurücksetzen
    setSelectedFile(null);
    setSelectedShadowTwin(null);
  }, [activeLibraryId, setLastLoadedFolder, setFolderItems, setLibraryState, currentFolderId]);

  // Reset Cache wenn sich die Library ändert
  useEffect(() => {
    setLastLoadedFolder(null);
    setLibraryState(state => ({
      ...state,
      folderCache: {}
    }));
  }, [libraryStatus, setLibraryState, setLastLoadedFolder]);

  // Manuelle Cache-Clear-Funktion für Review-Modus
  const clearCache = useCallback(() => {
    StateLogger.info('Library', 'Manually clearing cache for review mode');
    setLastLoadedFolder(null);
    setLibraryState(state => ({
      ...state,
      folderCache: {}
    }));
    setFolderItems([]);
  }, [setLibraryState, setLastLoadedFolder, setFolderItems]);

  // Reset selectedShadowTwin wenn Review-Modus verlassen wird
  useEffect(() => {
    if (!isReviewMode) {
      setSelectedShadowTwin(null);
    }
  }, [isReviewMode, setSelectedShadowTwin]);

  // ENTFERNT: Der folgende useEffect war problematisch und hat das Shadow-Twin 
  // bei jedem Klick zurückgesetzt, auch wenn die Datei ein Shadow-Twin hat.
  // Die Shadow-Twin-Logik wird bereits korrekt in der FileList-Komponente 
  // in der handleSelect-Funktion behandelt.

  // Render-Logik für verschiedene Status
  if (libraryStatus === "waitingForAuth") {
    return (
      <div className="flex flex-col items-center justify-center h-full text-muted-foreground">
        <span>Diese Bibliothek benötigt eine Authentifizierung.</span>
        <span className="text-sm mt-2">Bitte konfigurieren Sie die Bibliothek in den Einstellungen.</span>
      </div>
    );
  }
  
  if (libraryStatus !== "ready") {
    return (
      <div className="flex flex-col items-center justify-center h-full text-muted-foreground">
        <span>Lade Storage...</span>
      </div>
    );
  }

  return (
    <div className="flex flex-col h-full">
      <LibraryHeader
        provider={providerInstance}
        error={storageError}
        onUploadComplete={loadItems}
        onClearCache={clearCache}
        isTreeVisible={isTreeVisible}
        onToggleTree={() => setUiPrefs({ treeVisible: !isTreeVisible })}
        isCompactList={isListCompact}
        onToggleCompactList={() => setUiPrefs({ listCompact: !isListCompact })}
      >
        <Breadcrumb />
      </LibraryHeader>
      
      <div className="flex-1 min-h-0 overflow-hidden">
        {isReviewMode ? (
          // Review-Layout: 3 Panels ohne FileTree - FileList (compact) | FilePreview (Basis-Datei) | FilePreview (Shadow-Twin)
          <ResizablePanelGroup direction="horizontal" className="h-full">
            <ResizablePanel defaultSize={25} minSize={20} className="min-h-0">
              <div className="h-full overflow-auto flex flex-col">
                <FileList compact={true} />
              </div>
            </ResizablePanel>
            <ResizableHandle />
            <ResizablePanel defaultSize={37.5} minSize={30} className="min-h-0">
              <div className="h-full relative flex flex-col">
                {selectedFile ? (
                  <FilePreviewLazy
                    provider={providerInstance}
                    file={selectedFile}
                    onRefreshFolder={(folderId, items, selectFileAfterRefresh) => {
                    StateLogger.info('Library', 'FilePreview (Basis) onRefreshFolder aufgerufen', {
                      folderId,
                      itemsCount: items.length,
                      hasSelectFile: !!selectFileAfterRefresh
                    });
                    
                    // Aktualisiere die Dateiliste
                    setFolderItems(items);
                    
                    // Aktualisiere den Cache
                    if (libraryState.folderCache?.[folderId]) {
                      const cachedFolder = libraryState.folderCache[folderId];
                      if (cachedFolder) {
                        setLibraryState(state => ({
                          ...state,
                          folderCache: {
                            ...(state.folderCache || {}),
                            [folderId]: {
                              ...cachedFolder,
                              children: items
                            }
                          }
                        }));
                      }
                    }
                    
                    // Wenn eine Datei ausgewählt werden soll (nach dem Speichern)
                    if (selectFileAfterRefresh) {
                      StateLogger.info('Library', 'Wähle gespeicherte Datei aus', {
                        fileId: selectFileAfterRefresh.id,
                        fileName: selectFileAfterRefresh.metadata.name
                      });
                    }
                    }}
                  />
                ) : (
                  <div className="h-full flex items-center justify-center text-muted-foreground">
                    <p>Keine Datei ausgewählt</p>
                  </div>
                )}
              </div>
            </ResizablePanel>
            <ResizableHandle />
            <ResizablePanel defaultSize={37.5} minSize={30} className="min-h-0">
              <div className="h-full relative flex flex-col">
                {selectedShadowTwin ? (
                  <FilePreviewLazy
                    provider={providerInstance}
                    file={selectedShadowTwin}
                    onRefreshFolder={(folderId, items, selectFileAfterRefresh) => {
                      StateLogger.info('Library', 'FilePreview (Shadow-Twin) onRefreshFolder aufgerufen', {
                        folderId,
                        itemsCount: items.length,
                        hasSelectFile: !!selectFileAfterRefresh
                      });
                      
                      // Aktualisiere die Dateiliste
                      setFolderItems(items);
                      
                      // Aktualisiere den Cache
                      if (libraryState.folderCache?.[folderId]) {
                        const cachedFolder = libraryState.folderCache[folderId];
                        if (cachedFolder) {
                          setLibraryState(state => ({
                            ...state,
                            folderCache: {
                              ...(state.folderCache || {}),
                              [folderId]: {
                                ...cachedFolder,
                                children: items
                              }
                            }
                          }));
                        }
                      }
                      
                      // Wenn eine Datei ausgewählt werden soll (nach dem Speichern)
                      if (selectFileAfterRefresh) {
                        StateLogger.info('Library', 'Wähle gespeicherte Datei aus', {
                          fileId: selectFileAfterRefresh.id,
                          fileName: selectFileAfterRefresh.metadata.name
                        });
                      }
                    }}
                  />
                ) : (
                  <div className="h-full flex items-center justify-center text-muted-foreground">
                    <p>Kein Shadow-Twin ausgewählt</p>
                  </div>
                )}
              </div>
            </ResizablePanel>
          </ResizablePanelGroup>
        ) : (
          // Normal-Layout (Desktop) oder alternierendes Mobile-Layout
          <div className="relative h-full">
            {/* Entfernt: alter Tree-Handle (ersetzt durch Header-Toggle) */}

            {isMobile ? (
              mobileView === 'list' ? (
                <div className="h-full overflow-auto flex flex-col">
                  <FileList />
                </div>
              ) : (
                <div className="h-full flex flex-col">
                  <div className="flex items-center gap-2 p-2 border-b bg-background">
                    <button
                      type="button"
                      className="inline-flex items-center gap-1 text-sm px-2 py-1 border rounded-md"
                      onClick={() => {
                        setMobileView('list');
                        setSelectedShadowTwin(null);
                        setSelectedFile(null);
                        loadItems();
                      }}
                    >
                      <ChevronLeft className="h-4 w-4" />
                      Zurück
                    </button>
                    <div className="text-sm text-muted-foreground truncate">
                      {selectedFile?.metadata.name}
                    </div>
                  </div>
                  <div className="flex-1 min-h-0">
                    {selectedFile ? (
                      <FilePreviewLazy
                        provider={providerInstance}
                        onRefreshFolder={(folderId, items, selectFileAfterRefresh) => {
                        StateLogger.info('Library', 'FilePreview onRefreshFolder aufgerufen', {
                          folderId,
                          itemsCount: items.length,
                          hasSelectFile: !!selectFileAfterRefresh
                        });
                        setFolderItems(items);
                        if (libraryState.folderCache?.[folderId]) {
                          const cachedFolder = libraryState.folderCache[folderId];
                          if (cachedFolder) {
                            setLibraryState(state => ({
                              ...state,
                              folderCache: {
                                ...(state.folderCache || {}),
                                [folderId]: { ...cachedFolder, children: items }
                              }
                            }));
                          }
                        }
                        }}
                      />
                    ) : (
                      <div className="h-full flex items-center justify-center text-muted-foreground">
                        <p>Keine Datei ausgewählt</p>
                      </div>
                    )}
                  </div>
                </div>
              )
            ) : (
              <ResizablePanelGroup
                key={`layout-${isTreeVisible ? 'tree' : 'notree'}-${isListCompact ? 'compact' : 'list'}`}
                direction="horizontal"
                className="h-full"
                autoSaveId={`library-panels-${isTreeVisible ? '3' : '2'}-${isListCompact ? 'c' : 'n'}`}
              >
                {isTreeVisible && (
                  <>
                    <ResizablePanel key={`tree-panel-${isTreeVisible ? 't' : 'nt'}`} id="tree" defaultSize={15} minSize={15} className="min-h-0">
                      <div className="h-full overflow-auto flex flex-col">
                        <FileTree />
                      </div>
                    </ResizablePanel>
                    <ResizableHandle key="tree-handle" />
                  </>
                )}
                <>
                  <ResizablePanel key={`list-panel-${isListCompact ? 'c' : 'n'}-${isTreeVisible ? 't' : 'nt'}`} id="list" defaultSize={isListCompact ? 15 : 30} minSize={15} className="min-h-0 transition-[flex-basis] duration-200 ease-in-out">
                    <div className="h-full overflow-auto flex flex-col">
                      <FileList compact={isListCompact} />
                    </div>
                  </ResizablePanel>
                  <ResizableHandle key="list-preview-handle" />
                </>
                <ResizablePanel key={`preview-panel-${isListCompact ? 'c' : 'n'}-${isTreeVisible ? 't' : 'nt'}`} id="preview" defaultSize={(() => {
                  const tree = isTreeVisible ? 15 : 0;
                  const list = isListCompact ? 15 : 30;
                  const rest = Math.max(10, 100 - (tree + list));
                  return rest;
                })()} className="min-h-0 transition-[flex-basis] duration-200 ease-in-out">
                  <div className="h-full relative flex flex-col">
                    {selectedFile ? (
                      <FilePreviewLazy
                        provider={providerInstance}
                        onRefreshFolder={(folderId, items, selectFileAfterRefresh) => {
                        StateLogger.info('Library', 'FilePreview onRefreshFolder aufgerufen', {
                          folderId,
                          itemsCount: items.length,
                          hasSelectFile: !!selectFileAfterRefresh
                        });
                        
                        // Aktualisiere die Dateiliste
                        setFolderItems(items);
                        
                        // Aktualisiere den Cache
                        if (libraryState.folderCache?.[folderId]) {
                          const cachedFolder = libraryState.folderCache[folderId];
                          if (cachedFolder) {
                            setLibraryState(state => ({
                              ...state,
                              folderCache: {
                                ...(state.folderCache || {}),
                                [folderId]: {
                                  ...cachedFolder,
                                  children: items
                                }
                              }
                            }));
                          }
                        }
                        
                        if (selectFileAfterRefresh) {
                          StateLogger.info('Library', 'Wähle gespeicherte Datei aus', {
                            fileId: selectFileAfterRefresh.id,
                            fileName: selectFileAfterRefresh.metadata.name
                          });
                        }
                        }}
                      />
                    ) : (
                      <div className="h-full flex items-center justify-center text-muted-foreground">
                        <p>Keine Datei ausgewählt</p>
                      </div>
                    )}
                  </div>
                </ResizablePanel>
              </ResizablePanelGroup>
            )}
          </div>
        )}
      </div>
      
      {/* Dialoge */}
      <TranscriptionDialog />
      <TransformationDialog 
        onRefreshFolder={(folderId: string, items: StorageItem[], selectFileAfterRefresh?: StorageItem) => {
          StateLogger.info('Library', 'TransformationDialog onRefreshFolder aufgerufen', {
            folderId,
            itemsCount: items.length,
            hasSelectFile: !!selectFileAfterRefresh
          });
          
          // Aktualisiere die Dateiliste
          setFolderItems(items);
          
          // Aktualisiere den Cache
          if (libraryState.folderCache?.[folderId]) {
            const cachedFolder = libraryState.folderCache[folderId];
            if (cachedFolder) {
              setLibraryState(state => ({
                ...state,
                folderCache: {
                  ...(state.folderCache || {}),
                  [folderId]: {
                    ...cachedFolder,
                    children: items
                  }
                }
              }));
            }
          }
          
          // Wenn eine Datei ausgewählt werden soll (nach dem Speichern)
          if (selectFileAfterRefresh) {
            StateLogger.info('Library', 'Wähle gespeicherte Datei aus', {
              fileId: selectFileAfterRefresh.id,
              fileName: selectFileAfterRefresh.metadata.name
            });
          }
        }}
      />
    </div>
  );
}
```

Fehlerursache: In `Library` wurde noch `setIsTreeVisible` aus der alten State-Variante referenziert. Ich habe die Mobile-Initialisierung angepasst, sodass nur `isMobile` gesetzt wird; `treeVisible` bleibt über das persistente `uiPanePrefsAtom` erhalten.

- Persistenz
  - Tree/Kompakt werden in `localStorage` via `uiPanePrefsAtom` gespeichert (`atomWithStorage`, Key `ui:pane-prefs`).
  - Pane-Breiten werden pro Layout-Kombi (Tree an/aus, Kompakt/Normal) über `autoSaveId` gespeichert.
- Fix
  - Entfernt letzte Referenz zu `setIsTreeVisible` und nutzt stattdessen `setUiPrefs` nur beim Toggle.
  - Keine Linter-Fehler.

Bitte erneut testen:
- Toggle Tree/Kompakt setzen, Browser schmal/weit machen, zur Desktop-Ansicht zurück: Einstellungen sollten bestehen bleiben.
- Der ReferenceError sollte verschwunden sein.

---

**User**

In der File-Liste sollte man bei Tooltip des Namens den gesamten Namen sehen. Momentan steht da ein Benennungshinweis. Aber nachdem der Dateiname abgeschnitten wird und er nicht Platz hat, sollte man ihn vollständig sehen.

---

**Cursor**

```typescriptreact
'use client';

import * as React from "react"
import { File, FileText, FileVideo, FileAudio, Plus, RefreshCw, ChevronUp, ChevronDown, Trash2, ScrollText, Folder as FolderIcon, Layers } from "lucide-react"
import { StorageItem } from "@/lib/storage/types"
import { cn } from "@/lib/utils"
import { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from "@/components/ui/tooltip"
import { useStorage } from "@/contexts/storage-context";
import { Button } from "@/components/ui/button";
import { useAtomValue, useAtom } from 'jotai';
import { jobStatusByItemIdAtom } from '@/atoms/job-status';
import { 
  activeLibraryIdAtom, 
  selectedFileAtom, 
  folderItemsAtom,
  sortedFilteredFilesAtom,
  sortFieldAtom,
  sortOrderAtom,
  selectedShadowTwinAtom
} from '@/atoms/library-atom';
import { toast } from "sonner";
import { Input } from "@/components/ui/input"
import {
  selectedBatchItemsAtom,
  transcriptionDialogOpenAtom,
  selectedTransformationItemsAtom,
  transformationDialogOpenAtom,
  getMediaType,
  fileCategoryFilterAtom,
} from '@/atoms/transcription-options';
import { Checkbox } from "@/components/ui/checkbox"
import { useMemo, useCallback } from "react"
import { FileLogger, StateLogger } from "@/lib/debug/logger"
import { FileCategoryFilter } from './file-category-filter';
import { useFolderNavigation } from "@/hooks/use-folder-navigation";

// Typen für Sortieroptionen
type SortField = 'type' | 'name' | 'size' | 'date';
type SortOrder = 'asc' | 'desc';

// Typ für gruppierte Dateien
interface FileGroup {
  baseItem?: StorageItem;
  transcriptFiles?: StorageItem[]; // NEU: alle Transkripte
  transformed?: StorageItem;
}

// Memoized file icon component
const FileIconComponent = React.memo(function FileIconComponent({ item }: { item: StorageItem }) {
  const mimeType = item.metadata.mimeType || '';
  if (!mimeType) return <File className="h-4 w-4" />;

  if (mimeType.startsWith('video/')) {
    return <FileVideo className="h-4 w-4" />;
  } else if (mimeType.startsWith('audio/')) {
    return <FileAudio className="h-4 w-4" />;
  } else if (mimeType.startsWith('text/')) {
    return <FileText className="h-4 w-4" />;
  }

  return <File className="h-4 w-4" />;
});

// Pure function for file size formatting
const formatFileSize = (size?: number): string => {
  if (!size) return '-';
  const units = ['B', 'KB', 'MB', 'GB'];
  let value = size;
  let unitIndex = 0;
  
  while (value >= 1024 && unitIndex < units.length - 1) {
    value /= 1024;
    unitIndex++;
  }
  
  return `${value.toFixed(1)} ${units[unitIndex]}`;
};

// Funktion zum Formatieren des Datums
const formatDate = (date?: Date): string => {
  if (!date) return '-';
  
  const options: Intl.DateTimeFormatOptions = { 
    year: '2-digit', 
    month: '2-digit', 
    day: '2-digit',
    hour: '2-digit',
    minute: '2-digit'
  };
  
  return new Date(date).toLocaleDateString('de-DE', options);
};

// Entfernt: getFileStem Funktion war unbenutzt

// Sortierbare Kopfzelle Komponente
const SortableHeaderCell = React.memo(function SortableHeaderCell({
  label,
  field,
  currentSortField,
  currentSortOrder,
  onSort
}: {
  label: string,
  field: SortField,
  currentSortField: SortField,
  currentSortOrder: SortOrder,
  onSort: (field: SortField) => void
}) {
  const isActive = currentSortField === field;
  
  return (
    <button 
      onClick={() => onSort(field)}
      className="flex items-center gap-1 hover:text-foreground"
    >
      <span>{label}</span>
      {isActive && (
        currentSortOrder === 'asc' 
          ? <ChevronUp className="h-3 w-3" /> 
          : <ChevronDown className="h-3 w-3" />
      )}
    </button>
  );
});

interface FileRowProps {
  item: StorageItem;
  isSelected: boolean;
  onSelect: () => void;
  onCreateTranscript: (e: React.MouseEvent) => void;
  onDelete: (e: React.MouseEvent<HTMLButtonElement>, item: StorageItem) => void;
  fileGroup?: FileGroup;
  onSelectRelatedFile?: (file: StorageItem) => void;
  onRename?: (item: StorageItem, newName: string) => Promise<void>;
  compact?: boolean;
  systemFolderId?: string;
}

const FileRow = React.memo(function FileRow({ 
  item, 
  isSelected, 
  onSelect,
  onCreateTranscript,
  onDelete,
  fileGroup,
  onSelectRelatedFile,
  onRename,
  compact = false,
  systemFolderId
}: FileRowProps) {
  const navigateToFolder = useFolderNavigation();
  const [isEditing, setIsEditing] = React.useState(false);
  const [editName, setEditName] = React.useState(item.metadata.name);
  const inputRef = React.useRef<HTMLInputElement>(null);
  const longPressTimerRef = React.useRef<NodeJS.Timeout | null>(null);
  const lastClickTimeRef = React.useRef<number>(0);
  
  // Zusätzliche Validierung der Metadaten
  const metadata = React.useMemo(() => ({
    name: item.metadata?.name || 'Unbekannte Datei',
    size: typeof item.metadata?.size === 'number' ? item.metadata.size : 0,
    mimeType: item.metadata?.mimeType || '',
    hasTranscript: !!item.metadata?.hasTranscript || (fileGroup?.transcriptFiles && fileGroup.transcriptFiles.length > 0),
    modifiedAt: item.metadata?.modifiedAt
  }), [item.metadata, fileGroup]);

  const isTranscribable = React.useMemo(() => {
    const mimeType = metadata.mimeType.toLowerCase();
    const extension = metadata.name.split('.').pop()?.toLowerCase();

    return (
      mimeType.startsWith('audio/') ||
      mimeType.startsWith('video/') ||
      extension === 'pdf' ||
      mimeType === 'application/pdf'
    );
  }, [metadata.mimeType, metadata.name]);

  // Memoize the click handler
  const handleClick = React.useCallback(() => {
    if (!isEditing) {
      onSelect();
    }
  }, [onSelect, isEditing]);

  // Memoize the keydown handler
  const handleKeyDown = React.useCallback((e: React.KeyboardEvent) => {
    if (!isEditing && (e.key === 'Enter' || e.key === ' ')) {
      onSelect();
    }
  }, [onSelect, isEditing]);

  // Handler für Transkript-Icon Click
  const handleTranscriptClick = React.useCallback((e: React.MouseEvent) => {
    e.stopPropagation();
    if (fileGroup?.transcriptFiles && onSelectRelatedFile) {
      onSelectRelatedFile(fileGroup.transcriptFiles[0]); // Nur das erste Transkript anzeigen
    }
  }, [fileGroup, onSelectRelatedFile]);

  // Handler für Transformierte-Datei-Icon Click
  const handleTransformedClick = React.useCallback((e: React.MouseEvent) => {
    e.stopPropagation();
    if (fileGroup?.transformed && onSelectRelatedFile) {
      onSelectRelatedFile(fileGroup.transformed);
    }
  }, [fileGroup, onSelectRelatedFile]);

  // Starte Rename-Modus
  const startRename = React.useCallback(() => {
    if (onRename) {
      // Prüfe ob dies eine abhängige Datei ist
      if (fileGroup && (
        (fileGroup.transcriptFiles && fileGroup.transcriptFiles.length > 0 && fileGroup.transcriptFiles[0]?.id === item.id) ||
        (fileGroup.transformed && item.id === fileGroup.transformed.id)
      )) {
        // Dies ist eine abhängige Datei - zeige Hinweis
        toast.info("Hinweis", {
          description: "Bitte benennen Sie die Haupt-Datei um. Abhängige Dateien werden automatisch mit umbenannt."
        });
        return;
      }
      
      setIsEditing(true);
      setEditName(item.metadata.name);
    }
  }, [onRename, item, fileGroup]);

  // Handler für Dateinamen-Click (Doppelklick-Erkennung)
  const handleNameClick = React.useCallback((e: React.MouseEvent) => {
    e.stopPropagation();
    
    const currentTime = Date.now();
    const timeSinceLastClick = currentTime - lastClickTimeRef.current;
    
    if (timeSinceLastClick < 300) {
      // Doppelklick erkannt
      startRename();
    } else {
      // Erster Klick - wähle die Datei aus
      onSelect();
    }
    
    lastClickTimeRef.current = currentTime;
  }, [startRename, onSelect]);

  // Handler für Long-Press (Touch-Geräte)
  const handleTouchStart = React.useCallback((e: React.TouchEvent) => {
    e.stopPropagation();
    
    // Starte Long-Press Timer
    longPressTimerRef.current = setTimeout(() => {
      startRename();
    }, 500); // 500ms für Long-Press
  }, [startRename]);

  const handleTouchEnd = React.useCallback((e: React.TouchEvent) => {
    e.stopPropagation();
    
    // Lösche Long-Press Timer
    if (longPressTimerRef.current) {
      clearTimeout(longPressTimerRef.current);
      longPressTimerRef.current = null;
    }
  }, []);

  const handleTouchMove = React.useCallback(() => {
    // Bei Bewegung Long-Press abbrechen
    if (longPressTimerRef.current) {
      clearTimeout(longPressTimerRef.current);
      longPressTimerRef.current = null;
    }
  }, []);

  // Cleanup Timer bei Unmount
  React.useEffect(() => {
    return () => {
      if (longPressTimerRef.current) {
        clearTimeout(longPressTimerRef.current);
      }
    };
  }, []);

  // Handler für Rename-Submit
  const handleRenameSubmit = React.useCallback(async () => {
    if (onRename && editName.trim() && editName !== item.metadata.name) {
      try {
        await onRename(item, editName.trim());
      } catch (error) {
        FileLogger.error('FileRow', 'Fehler beim Umbenennen', error);
        // Bei Fehler den ursprünglichen Namen wiederherstellen
        setEditName(item.metadata.name);
      }
    }
    setIsEditing(false);
  }, [onRename, editName, item]);

  // Handler für Rename-Cancel
  const handleRenameCancel = React.useCallback(() => {
    setEditName(item.metadata.name);
    setIsEditing(false);
  }, [item.metadata.name]);

  // Handler für Input-Änderungen
  const handleInputChange = React.useCallback((e: React.ChangeEvent<HTMLInputElement>) => {
    setEditName(e.target.value);
  }, []);

  // Handler für Input-Keydown
  const handleInputKeyDown = React.useCallback((e: React.KeyboardEvent<HTMLInputElement>) => {
    e.stopPropagation();
    if (e.key === 'Enter') {
      handleRenameSubmit();
    } else if (e.key === 'Escape') {
      handleRenameCancel();
    }
  }, [handleRenameSubmit, handleRenameCancel]);

  // Focus Input wenn Edit-Modus aktiviert wird
  React.useEffect(() => {
    if (isEditing && inputRef.current) {
      inputRef.current.focus();
      inputRef.current.select();
    }
  }, [isEditing]);

  // Handler für Drag Start
  const handleDragStart = React.useCallback((e: React.DragEvent) => {
    // Sammle alle Dateien der Gruppe, die verschoben werden sollen
    const itemsToMove = [];
    
    // Füge das aktuelle Item hinzu
    itemsToMove.push({
      itemId: item.id,
      itemName: item.metadata.name,
      itemType: item.type,
      parentId: item.parentId
    });
    
    // Wenn es eine FileGroup gibt, füge auch die zugehörigen Dateien hinzu
    if (fileGroup) {
      // Prüfe ob das aktuelle Item die Basis-Datei ist
      if (item.id === fileGroup.baseItem?.id) {
        // Füge Transkripte hinzu, falls vorhanden
        if (fileGroup.transcriptFiles && fileGroup.transcriptFiles.length > 0) {
          fileGroup.transcriptFiles.forEach(transcript => {
            itemsToMove.push({
              itemId: transcript.id,
              itemName: transcript.metadata.name,
              itemType: transcript.type,
              parentId: transcript.parentId
            });
          });
        }
        
        // Füge transformierte Datei hinzu, falls vorhanden
        if (fileGroup.transformed) {
          itemsToMove.push({
            itemId: fileGroup.transformed.id,
            itemName: fileGroup.transformed.metadata.name,
            itemType: fileGroup.transformed.type,
            parentId: fileGroup.transformed.parentId
          });
        }
      }
    }
    
    // Setze die Drag-Daten
    e.dataTransfer.effectAllowed = 'move';
    e.dataTransfer.setData('application/json', JSON.stringify({
      items: itemsToMove,
      isFileGroup: itemsToMove.length > 1
    }));
    
    // Visuelles Feedback
    if (e.currentTarget instanceof HTMLElement) {
      e.currentTarget.style.opacity = '0.5';
    }
  }, [item, fileGroup]);

  // Handler für Drag End
  const handleDragEnd = React.useCallback((e: React.DragEvent) => {
    // Stelle Opacity wieder her
    if (e.currentTarget instanceof HTMLElement) {
      e.currentTarget.style.opacity = '1';
    }
  }, []);

  const [selectedBatchItems, setSelectedBatchItems] = useAtom(selectedBatchItemsAtom);
  const [selectedTransformationItems, setSelectedTransformationItems] = useAtom(selectedTransformationItemsAtom);
  
  // Prüfe ob das Item in einem der beiden Atome ausgewählt ist
  const isInBatch = selectedBatchItems.some(batchItem => batchItem.item.id === item.id);
  const isInTransformation = selectedTransformationItems.some(transformationItem => transformationItem.item.id === item.id);
  const isInAnyBatch = isInBatch || isInTransformation;

  // Handler für Checkbox-Änderungen
  const handleCheckboxChange = React.useCallback((checked: boolean) => {
    const mediaType = getMediaType(item);
    
    if (mediaType === 'audio' || mediaType === 'video') {
      // Für Audio/Video: Transcription-Atom verwenden
      if (checked) {
        setSelectedBatchItems([...selectedBatchItems, {
          item,
          type: mediaType
        }]);
      } else {
        setSelectedBatchItems(selectedBatchItems.filter(i => i.item.id !== item.id));
      }
    } else if (mediaType === 'text' || mediaType === 'document') {
      // Für Text/Dokumente: Transformation-Atom verwenden
      if (checked) {
        setSelectedTransformationItems([...selectedTransformationItems, {
          item,
          type: mediaType
        }]);
      } else {
        setSelectedTransformationItems(selectedTransformationItems.filter(i => i.item.id !== item.id));
      }
    }
  }, [item, selectedBatchItems, selectedTransformationItems, setSelectedBatchItems, setSelectedTransformationItems]);

  React.useEffect(() => {
    if (fileGroup) {
      FileLogger.debug('FileRow', 'Transkripte für Zeile', {
        baseItem: fileGroup.baseItem?.metadata.name,
        transcripts: fileGroup.transcriptFiles?.map(t => t.metadata.name)
      });
    }
  }, [fileGroup]);

  // Zentraler Jobstatus (muss vor möglichen early-returns stehen, um Hook-Order zu garantieren)
  const jobStatusMap = useAtomValue(jobStatusByItemIdAtom);
  const jobStatus = jobStatusMap[item.id];
  const jobStatusIcon = jobStatus ? (
    <span title={jobStatus} className={cn('inline-block h-3 w-3 rounded-full',
      jobStatus === 'queued' && 'bg-blue-600',
      jobStatus === 'running' && 'bg-yellow-600',
      jobStatus === 'completed' && 'bg-green-600',
      jobStatus === 'failed' && 'bg-red-600'
    )} aria-label={`job-${jobStatus}`} />
  ) : null;

  // Compact-Modus: vereinfachte Darstellung
  if (compact) {
    return (
      <div
        role="button"
        tabIndex={0}
        onClick={handleClick}
        onKeyDown={handleKeyDown}
        className={cn(
          "w-full px-2 py-1 text-sm hover:bg-muted/50 flex items-center gap-2 cursor-pointer",
          isSelected && "bg-muted"
        )}
      >
        <FileIconComponent item={item} />
        <span className="truncate flex-1" title={metadata.name}>
          {metadata.name}
        </span>
        {/* Shadow-Twin-Symbole im compact mode */}
        {fileGroup?.transcriptFiles && fileGroup.transcriptFiles.length > 0 && (
          <Button
            variant="ghost"
            size="icon"
            className="h-4 w-4 p-0 hover:bg-muted text-muted-foreground hover:text-foreground"
            onClick={handleTranscriptClick}
          >
            <ScrollText className="h-3 w-3" />
          </Button>
        )}
      </div>
    );
  }

  return (
    <div
      role="button"
      tabIndex={0}
      onClick={handleClick}
      onKeyDown={handleKeyDown}
      onTouchStart={handleTouchStart}
      onTouchEnd={handleTouchEnd}
      onTouchMove={handleTouchMove}
      draggable={!isEditing}
      onDragStart={handleDragStart}
      onDragEnd={handleDragEnd}
      className={cn(
        "w-full px-4 py-2 text-xs hover:bg-muted/50 grid grid-cols-[24px_24px_minmax(0,1fr)_56px_88px_auto] gap-2 items-center cursor-move",
        isSelected && "bg-muted"
      )}
    >
      <div className="w-6 flex items-center justify-center">
        <Checkbox
          checked={isInAnyBatch}
          onCheckedChange={handleCheckboxChange}
          onClick={(e) => e.stopPropagation()}
        />
      </div>
      <FileIconComponent item={item} />
      {isEditing ? (
        <Input
          ref={inputRef}
          value={editName}
          onChange={handleInputChange}
          onKeyDown={handleInputKeyDown}
          onBlur={handleRenameSubmit}
          onClick={(e) => e.stopPropagation()}
          className="h-6 px-1 py-0 text-xs"
        />
      ) : (
        <span 
          className="text-left truncate cursor-pointer hover:text-primary select-none"
          onClick={handleNameClick}
          onTouchStart={handleTouchStart}
          onTouchEnd={handleTouchEnd}
          onTouchMove={handleTouchMove}
          title={metadata.name}
        >
          {metadata.name}
        </span>
      )}
      <span className="text-muted-foreground tabular-nums text-[10px]">
        {formatFileSize(metadata.size)}
      </span>
      <span className="text-muted-foreground tabular-nums text-[10px]">
        {formatDate(metadata.modifiedAt)}
      </span>
      <div className="flex items-center justify-start gap-1">
        {jobStatusIcon}
        {/* System-Unterordner (z. B. extrahierte Seiten) */}
        {systemFolderId && (
          <TooltipProvider>
            <Tooltip>
              <TooltipTrigger asChild>
                <Button
                  variant="ghost"
                  size="icon"
                  className="h-6 w-6 p-0 hover:bg-muted"
                  onClick={(e) => {
                    e.stopPropagation();
                    navigateToFolder(systemFolderId);
                  }}
                >
                  <Layers className="h-4 w-4 text-violet-500" />
                </Button>
              </TooltipTrigger>
              <TooltipContent>
                <p>Seiten-Ordner öffnen</p>
              </TooltipContent>
            </Tooltip>
          </TooltipProvider>
        )}
        {/* Zeige Icons für alle vorhandenen Transkripte */}
        {fileGroup?.transcriptFiles && fileGroup.transcriptFiles.length > 0 && fileGroup.transcriptFiles.map((transcript) => (
          <TooltipProvider key={transcript.id}>
            <Tooltip>
              <TooltipTrigger asChild>
                <Button
                  variant="ghost"
                  size="icon"
                  className="h-6 w-6 p-0 hover:bg-muted"
                  onClick={(e) => {
                    e.stopPropagation();
                    if (onSelectRelatedFile) onSelectRelatedFile(transcript);
                  }}
                >
                  <FileText className="h-4 w-4 text-blue-500" />
                </Button>
              </TooltipTrigger>
              <TooltipContent>
                <p>Transkript anzeigen: {transcript.metadata.name}</p>
              </TooltipContent>
            </Tooltip>
          </TooltipProvider>
        ))}
        {/* Plus-Symbol nur anzeigen, wenn kein Transkript vorhanden und transkribierbar */}
        {(!fileGroup?.transcriptFiles || fileGroup.transcriptFiles.length === 0) && isTranscribable && !metadata.hasTranscript ? (
          <TooltipProvider>
            <Tooltip>
              <TooltipTrigger asChild>
                <div 
                  role="button"
                  tabIndex={0}
                  className="h-6 w-6 p-0 inline-flex items-center justify-center hover:bg-muted rounded-sm"
                  onClick={onCreateTranscript}
                  onKeyDown={(e) => {
                    if (e.key === 'Enter' || e.key === ' ') {
                      e.stopPropagation();
                      onCreateTranscript(e as unknown as React.MouseEvent<HTMLDivElement>);
                    }
                  }}
                >
                  <Plus className="h-4 w-4" />
                </div>
              </TooltipTrigger>
              <TooltipContent>
                <p>Transkript erstellen</p>
              </TooltipContent>
            </Tooltip>
          </TooltipProvider>
        ) : null}
        {/* Icon für transformierte Datei */}
        {fileGroup?.transformed && (
          <TooltipProvider>
            <Tooltip>
              <TooltipTrigger asChild>
                <Button
                  variant="ghost"
                  size="icon"
                  className="h-6 w-6 p-0 hover:bg-muted"
                  onClick={handleTransformedClick}
                >
                  <ScrollText className="h-4 w-4 text-green-500" />
                </Button>
              </TooltipTrigger>
              <TooltipContent>
                <p>Transformierte Datei anzeigen</p>
              </TooltipContent>
            </Tooltip>
          </TooltipProvider>
        )}
        {/* Delete direkt neben Dokument-Icons */}
        <TooltipProvider>
          <Tooltip>
            <TooltipTrigger asChild>
              <Button
                variant="ghost"
                size="icon"
                className="h-6 w-6 p-0 hover:bg-destructive/10 hover:text-destructive"
                onClick={(e) => onDelete(e as React.MouseEvent<HTMLButtonElement>, item)}
              >
                <Trash2 className="h-4 w-4" />
              </Button>
            </TooltipTrigger>
            <TooltipContent>
              <p>Datei löschen</p>
            </TooltipContent>
          </Tooltip>
        </TooltipProvider>
      </div>
      <div />
    </div>
  );
});

interface FileListProps {
  compact?: boolean;
}

export const FileList = React.memo(function FileList({ compact = false }: FileListProps): JSX.Element {
  const { provider, refreshItems, currentLibrary } = useStorage();
  const activeLibraryId = useAtomValue(activeLibraryIdAtom);
  const [isRefreshing, setIsRefreshing] = React.useState(false);
  // Mobile-Flag wurde entfernt, FileList lädt unabhängig vom View
  const [selectedBatchItems, setSelectedBatchItems] = useAtom(selectedBatchItemsAtom);
  const [selectedTransformationItems, setSelectedTransformationItems] = useAtom(selectedTransformationItemsAtom);
  const [, setTranscriptionDialogOpen] = useAtom(transcriptionDialogOpenAtom);
  const [, setTransformationDialogOpen] = useAtom(transformationDialogOpenAtom);
  const [isInitialized, setIsInitialized] = React.useState(false);
  const initializationTimeoutRef = React.useRef<NodeJS.Timeout | null>(null);
  // Entkoppelt: Kein Warten mehr auf FileTree-Status
  const [, setSelectedFile] = useAtom(selectedFileAtom);
  const [, setFolderItems] = useAtom(folderItemsAtom);
  const currentCategoryFilter = useAtomValue(fileCategoryFilterAtom);
  const allItemsInFolder = useAtomValue(folderItemsAtom);
  const navigateToFolder = useFolderNavigation();

  // Kein mobiles Flag mehr notwendig

  const folders = useMemo(() => {
    const items = allItemsInFolder ?? [];
    // Verstecke dot-Verzeichnisse generell in der Liste
    return items.filter(item => item.type === 'folder' && !item.metadata.name.startsWith('.'));
  }, [allItemsInFolder]);

  // Hilfsfunktion zum Finden einer FileGroup in der Map
  const findFileGroup = (map: Map<string, FileGroup>, stem: string): FileGroup | undefined => {
    return Array.from((map ?? new Map()).values()).find(group => 
      group.baseItem && getBaseName(group.baseItem.metadata.name) === stem
    );
  };

  // NEU: Atome für Sortierung und Filter
  const items = useAtomValue(sortedFilteredFilesAtom);
  const [sortField, setSortField] = useAtom(sortFieldAtom);
  const [sortOrder, setSortOrder] = useAtom(sortOrderAtom);
  
  // Review-Mode-Atoms
  const [, setSelectedShadowTwin] = useAtom(selectedShadowTwinAtom);

  // handleSort nutzt jetzt Atome
  const handleSort = React.useCallback((field: SortField) => {
    if (field === sortField) setSortOrder(sortOrder === 'asc' ? 'desc' : 'asc');
    else {
      setSortField(field);
      setSortOrder('asc');
    }
  }, [sortField, sortOrder, setSortField, setSortOrder]);

  // Initialisierung - nur auf Provider und Mobile-Flag achten
  React.useEffect(() => {
    if (!provider) {
      FileLogger.info('FileList', 'Waiting for provider');
      return;
    }

    const initialize = async () => {
      if (isInitialized) {
        FileLogger.debug('FileList', 'Already initialized');
        return;
      }

      FileLogger.info('FileList', 'Starting initialization');

      try {
        FileLogger.info('FileList', 'Initialization complete');
        setIsInitialized(true);
      } catch (error) {
        FileLogger.error('FileList', 'Error initializing FileList', error);
      }
    };

    initialize();

    const timeoutRef = initializationTimeoutRef.current;
    return () => {
      if (timeoutRef) clearTimeout(timeoutRef);
    };
  }, [provider, isInitialized]);

  // NEU: Reagieren auf Bibliothekswechsel
  const prevLibraryIdRef = React.useRef<string | null>(null);
  React.useEffect(() => {
    StateLogger.debug('FileList', 'Render', {
      currentLibraryId: activeLibraryId,
      activeLibraryIdAtom: activeLibraryId
    });

    // Nur bei tatsächlichem Bibliothekswechsel zurücksetzen
    if (prevLibraryIdRef.current !== null && prevLibraryIdRef.current !== activeLibraryId) {
      setIsInitialized(false);
      setSelectedFile(null);
      setFolderItems([]);
      setSelectedBatchItems([]);
      setSelectedTransformationItems([]);
      setSelectedShadowTwin(null);
      StateLogger.info('FileList', 'Bibliothek gewechselt - State zurückgesetzt', {
        libraryId: activeLibraryId
      });
    }
    prevLibraryIdRef.current = activeLibraryId;
  }, [activeLibraryId, setSelectedFile, setFolderItems, setSelectedBatchItems, setSelectedTransformationItems, setSelectedShadowTwin]);

  // Vereinfachte Funktion zum Extrahieren des Basisnamens (ohne Endung, auch für Binärdateien)
  function getBaseName(name: string): string {
    // ShadowTwin: .de.md, .en.md, etc.
    const shadowTwinMatch = name.match(/^(.*)\.(de|en|fr|es|it)\.md$/);
    if (shadowTwinMatch) return shadowTwinMatch[1];
    // Sonst: alles vor der letzten Endung
    const lastDot = name.lastIndexOf('.');
    if (lastDot === -1) return name;
    return name.substring(0, lastDot);
  }

  // Prüft ob eine Datei ein ShadowTwin ist (Markdown mit Sprachkürzel)
  function isShadowTwin(name: string): boolean {
    // Pattern: name.de.md, name.en.md, etc.
    const shadowTwinPattern = /^(.+)\.(de|en|fr|es|it)\.md$/;
    return shadowTwinPattern.test(name);
  }

  // Gruppiere die Dateien nach Basename
  const fileGroups = useMemo(() => {
    if (!items) return new Map<string, FileGroup>();

    // Schritt 1: Gruppiere alle Dateien nach Basename
    const groupsMap = new Map<string, StorageItem[]>();
    for (const item of items) {
      if (item.type !== 'file') continue;
      const base = getBaseName(item.metadata.name);
      if (!groupsMap.has(base)) groupsMap.set(base, []);
      groupsMap.get(base)!.push(item);
    }

    // Schritt 2: Erstelle FileGroups
    const fileGroupsMap = new Map<string, FileGroup>();
    for (const [base, groupItems] of Array.from(groupsMap.entries())) {
      // Finde Hauptdatei (erste Nicht-ShadowTwin-Datei)
      const mainFile = groupItems.find((item) => !isShadowTwin(item.metadata.name));
      // Finde alle ShadowTwins
      const shadowTwins = groupItems.filter((item) => isShadowTwin(item.metadata.name));
      if (mainFile) {
        fileGroupsMap.set(base, {
          baseItem: mainFile,
          transcriptFiles: shadowTwins.length > 0 ? shadowTwins : undefined,
          transformed: undefined
        });
      } else {
        // Keine Hauptdatei: Jede ShadowTwin einzeln anzeigen
        for (const twin of shadowTwins) {
          fileGroupsMap.set(`${base}__shadow_${twin.id}`, {
            baseItem: twin,
            transcriptFiles: undefined,
            transformed: undefined
          });
        }
      }
    }
    // Debug-Logging für Gruppierung
    FileLogger.debug('FileList', 'Gruppierung Ergebnis (Basename, alle Endungen)', {
      groups: Array.from(fileGroupsMap.entries()).map(([base, group]) => ({
        base,
        baseItem: group.baseItem?.metadata.name,
        transcripts: group.transcriptFiles?.map(t => t.metadata.name)
      }))
    });
    return fileGroupsMap;
  }, [items]);

  // Mapping: Basename -> dot-Systemordner (z. B. ".<basename>")
  const systemFolderByBase = useMemo(() => {
    const map = new Map<string, StorageItem>();
    const items = allItemsInFolder ?? [];
    for (const it of items) {
      if (it.type !== 'folder') continue;
      const name = it.metadata.name;
      if (!name.startsWith('.')) continue;
      const base = name.slice(1);
      if (base) map.set(base, it);
    }
    return map;
  }, [allItemsInFolder]);

  // Berechne, ob alle Dateien ausgewählt sind
  const isAllSelected = useMemo(() => {
    if (!fileGroups || !fileGroups.size) return false;
    // Verwende nur die Hauptdateien (baseItem) aus den FileGroups
    const mainItems = Array.from((fileGroups ?? new Map()).values())
      .map(group => group.baseItem)
      .filter((item): item is StorageItem => item !== undefined);
    // Je nach Filter unterschiedliche Dateien zählen
    let selectableItems: StorageItem[] = [];
    switch (currentCategoryFilter) {
      case 'media':
        selectableItems = mainItems.filter(item => {
          try {
            const mediaType = getMediaType(item);
            return item.type === 'file' && (mediaType === 'audio' || mediaType === 'video');
          } catch {
            return false;
          }
        });
        return selectableItems.length > 0 && selectedBatchItems.length === selectableItems.length;
      case 'text':
        selectableItems = mainItems.filter(item => {
          try {
            const mediaType = getMediaType(item);
            return item.type === 'file' && mediaType === 'text';
          } catch {
            return false;
          }
        });
        return selectableItems.length > 0 && selectedTransformationItems.length === selectableItems.length;
      case 'documents':
        selectableItems = mainItems.filter(item => {
          try {
            const mediaType = getMediaType(item);
            return item.type === 'file' && mediaType === 'document';
          } catch {
            return false;
          }
        });
        return selectableItems.length > 0 && selectedTransformationItems.length === selectableItems.length;
      default:
        // Bei 'all' prüfen ob alle verfügbaren Dateien ausgewählt sind
        const mediaItems = mainItems.filter(item => {
          try {
            const mediaType = getMediaType(item);
            return item.type === 'file' && (mediaType === 'audio' || mediaType === 'video');
          } catch {
            return false;
          }
        });
        const textItems = mainItems.filter(item => {
          try {
            const mediaType = getMediaType(item);
            return item.type === 'file' && (mediaType === 'text' || mediaType === 'document');
          } catch {
            return false;
          }
        });
        const allMediaSelected = mediaItems.length === 0 || selectedBatchItems.length === mediaItems.length;
        const allTextSelected = textItems.length === 0 || selectedTransformationItems.length === textItems.length;
        return allMediaSelected && allTextSelected;
    }
  }, [fileGroups, selectedBatchItems, selectedTransformationItems, currentCategoryFilter]);
  
  // Erweiterte handleSelect Funktion für Review-Mode
  const handleSelect = useCallback((item: StorageItem, group?: FileGroup) => {
    FileLogger.debug('FileList', 'handleSelect aufgerufen', {
      itemId: item.id,
      itemName: item.metadata.name,
      groupBase: group?.baseItem?.metadata.name,
      transcriptCount: group?.transcriptFiles?.length ?? 0,
      hasTranscripts: !!(group && group.transcriptFiles && group.transcriptFiles.length > 0)
    });
    
    // Nur die ausgewählte Datei setzen - Review-Modus wird über Toggle-Button gesteuert
    setSelectedFile(item);
    
    // Wenn wir im Review-Modus sind und eine Basis-Datei mit Shadow-Twin ausgewählt wird,
    // dann automatisch das Shadow-Twin setzen
    if (group && group.transcriptFiles && group.transcriptFiles.length > 0) {
      const shadowTwin = group.transcriptFiles[0];
      FileLogger.info('FileList', 'Basis-Datei mit Shadow-Twin ausgewählt', {
        twinId: shadowTwin.id,
        twinName: shadowTwin.metadata.name,
        baseFileId: item.id,
        baseFileName: item.metadata.name
      });
      setSelectedShadowTwin(shadowTwin);
    } else {
      FileLogger.info('FileList', 'Datei ohne Shadow-Twin ausgewählt', {
        itemId: item.id,
        itemName: item.metadata.name,
        groupExists: !!group,
        transcriptCount: group?.transcriptFiles?.length ?? 0
      });
      setSelectedShadowTwin(null);
    }
  }, [setSelectedFile, setSelectedShadowTwin, findFileGroup]);
  
  // Erweiterte handleSelectRelatedFile Funktion für Review-Mode
  const handleSelectRelatedFile = useCallback((shadowTwin: StorageItem) => {
    StateLogger.info('FileList', 'Shadow-Twin ausgewählt', {
      shadowTwinId: shadowTwin.id,
      shadowTwinName: shadowTwin.metadata.name
    });
    
    // Setze das Shadow-Twin als ausgewählte Datei, damit es rechts angezeigt wird
    setSelectedFile(shadowTwin);
    setSelectedShadowTwin(null); // Kein zusätzliches Shadow-Twin im normalen Modus
  }, [setSelectedFile, setSelectedShadowTwin, findFileGroup]);

  // Aktualisierte handleRefresh Funktion
  const handleRefresh = useCallback(async () => {
    if (!items || items.length === 0) return;
    
    const parentId = items[0]?.parentId;
    if (!parentId) return;
    
    setIsRefreshing(true);
    
    try {
      const refreshedItems = await refreshItems(parentId);
      setFolderItems(refreshedItems);
    } catch (error) {
      FileLogger.error('FileList', 'Fehler beim Aktualisieren der Dateiliste', error);
    } finally {
      setIsRefreshing(false);
    }
  }, [items, refreshItems, setFolderItems]);

  const handleCreateTranscript = React.useCallback((e: React.MouseEvent) => {
    e.stopPropagation();
    FileLogger.info('FileList', 'Create transcript for', { fileName: 'TODO' });
    // TODO: Implement transcript creation
  }, []);

  // Entfernt: handleItemSelect war unbenutzt

  // Check if an item is selected (beide Atome prüfen)
  const isItemSelected = useCallback((item: StorageItem) => {
    const mediaType = getMediaType(item);
    if (mediaType === 'audio' || mediaType === 'video') {
      return selectedBatchItems.some(selected => selected.item.id === item.id);
    } else {
      return selectedTransformationItems.some(selected => selected.item.id === item.id);
    }
  }, [selectedBatchItems, selectedTransformationItems]);

  // Löschfunktion
  const handleDeleteClick = React.useCallback(async (e: React.MouseEvent<HTMLButtonElement>, itemToDelete: StorageItem) => {
    e.stopPropagation();
    
    if (!provider) {
      toast.error("Fehler", {
        description: "Storage Provider nicht verfügbar"
      });
      return;
    }

    try {
      // Finde die FileGroup für dieses Item
      const itemStem = getBaseName(itemToDelete.metadata.name);
      const fileGroup = findFileGroup(fileGroups, itemStem);

      // Bestätigungsnachricht vorbereiten
      let confirmMessage = `Möchten Sie "${itemToDelete.metadata.name}" wirklich löschen?`;
      if (fileGroup && itemToDelete.id === fileGroup.baseItem?.id) {
        if (fileGroup.transcriptFiles && fileGroup.transcriptFiles.length > 0 || fileGroup.transformed) {
          confirmMessage = `Möchten Sie "${itemToDelete.metadata.name}" und alle zugehörigen Dateien wirklich löschen?`;
        }
      }

      // Benutzer um Bestätigung bitten
      if (!window.confirm(confirmMessage)) {
        return;
      }

      if (fileGroup && itemToDelete.id === fileGroup.baseItem?.id) {
        // Dies ist die Basis-Datei - lösche auch abhängige Dateien
        // Lösche alle Transkripte, falls vorhanden
        if (fileGroup.transcriptFiles) {
          for (const transcript of fileGroup.transcriptFiles) {
            try {
              await provider.deleteItem(transcript.id);
              FileLogger.info('FileList', 'Transkript gelöscht', {
                transcriptId: transcript.id,
                transcriptName: transcript.metadata.name
              });
            } catch (error) {
              FileLogger.error('FileList', 'Fehler beim Löschen des Transkripts', error);
              toast.warning("Hinweis", {
                description: "Einige Transkripte konnten nicht gelöscht werden"
              });
            }
          }
        }

        // Lösche die transformierte Datei, falls vorhanden
        if (fileGroup.transformed) {
          try {
            await provider.deleteItem(fileGroup.transformed.id);
            FileLogger.info('FileList', 'Transformierte Datei gelöscht', {
              transformedId: fileGroup.transformed.id,
              transformedName: fileGroup.transformed.metadata.name
            });
          } catch (error) {
            FileLogger.error('FileList', 'Fehler beim Löschen der transformierten Datei', error);
            toast.warning("Hinweis", {
              description: "Die transformierte Datei konnte nicht gelöscht werden"
            });
          }
        }

        // Lösche die Basis-Datei
        await provider.deleteItem(itemToDelete.id);
        toast.success("Dateien gelöscht", {
          description: `${itemToDelete.metadata.name} und zugehörige Dateien wurden gelöscht.`
        });
      } else {
        // Dies ist eine abhängige Datei oder keine Gruppe - nur diese Datei löschen
        await provider.deleteItem(itemToDelete.id);
        toast.success("Datei gelöscht", {
          description: `${itemToDelete.metadata.name} wurde gelöscht.`
        });
      }

      // Aktualisiere die Dateiliste
      await handleRefresh();

      // Wenn die gelöschte Datei ausgewählt war, Auswahl aufheben
      setSelectedFile(null);
      
      // Aus der Batch-Auswahl entfernen
      setSelectedBatchItems(prev => prev.filter(i => i.item.id !== itemToDelete.id));

    } catch (error) {
      FileLogger.error('FileList', 'Fehler beim Löschen', error);
      toast.error("Fehler", {
        description: `Die Datei konnte nicht gelöscht werden: ${error instanceof Error ? error.message : 'Unbekannter Fehler'}`
      });
    }
  }, [provider, handleRefresh, fileGroups, setSelectedFile, setSelectedBatchItems]);

  const handleRename = React.useCallback(async (item: StorageItem, newName: string) => {
    if (!provider) {
      toast.error("Fehler", {
        description: "Storage Provider nicht verfügbar"
      });
      return;
    }

    try {
      // Finde die FileGroup für dieses Item
      const itemStem = getBaseName(item.metadata.name);
      const fileGroup = findFileGroup(fileGroups, itemStem);

      if (fileGroup && item.id === fileGroup.baseItem?.id) {
        // Dies ist die Basis-Datei - benenne auch abhängige Dateien um
        const oldStem = getBaseName(item.metadata.name);
        const newStem = getBaseName(newName);
        // Benenne die Basis-Datei um
        await provider.renameItem(item.id, newName);
        // Benenne alle Transkripte um, falls vorhanden
        if (fileGroup.transcriptFiles) {
          for (const transcript of fileGroup.transcriptFiles) {
            const transcriptName = transcript.metadata.name;
            const newTranscriptName = transcriptName.replace(oldStem, newStem);
            try {
              await provider.renameItem(transcript.id, newTranscriptName);
            } catch (error) {
              FileLogger.error('FileList', 'Fehler beim Umbenennen des Transkripts', error);
              toast.warning("Hinweis", {
                description: "Einige Transkripte konnten nicht umbenannt werden"
              });
            }
          }
        }
        // Benenne die transformierte Datei um, falls vorhanden
        if (fileGroup.transformed) {
          const transformedName = fileGroup.transformed.metadata.name;
          const newTransformedName = transformedName.replace(oldStem, newStem);
          try {
            await provider.renameItem(fileGroup.transformed.id, newTransformedName);
          } catch (error) {
            FileLogger.error('FileList', 'Fehler beim Umbenennen der transformierten Datei', error);
            toast.warning("Hinweis", {
              description: "Die transformierte Datei konnte nicht umbenannt werden"
            });
          }
        }
        toast.success("Dateien umbenannt", {
          description: `${item.metadata.name} und zugehörige Dateien wurden umbenannt.`
        });
      } else {
        // Dies ist eine abhängige Datei oder keine Gruppe - nur diese Datei umbenennen
        await provider.renameItem(item.id, newName);
        toast.success("Datei umbenannt", {
          description: `${item.metadata.name} wurde zu ${newName} umbenannt.`
        });
      }
      await handleRefresh();
    } catch (error) {
      FileLogger.error('FileList', 'Fehler beim Umbenennen', error);
      toast.error("Fehler", {
        description: `Die Datei konnte nicht umbenannt werden: ${error instanceof Error ? error.message : 'Unbekannter Fehler'}`
      });
      throw error;
    }
  }, [provider, handleRefresh, fileGroups]);

  const handleBatchTranscription = () => {
    if (selectedBatchItems.length > 0) {
      setTranscriptionDialogOpen(true);
    }
  };

  const handleBatchTransformation = () => {
    if (selectedTransformationItems.length > 0) {
      setTransformationDialogOpen(true);
    }
  };

  // Bulk-Löschung für ausgewählte Dateien (unabhängig von Batch/Transformation-Selektor)
  const handleBulkDelete = React.useCallback(async () => {
    if (!provider) return;
    const targets = [
      ...selectedBatchItems.map(x => x.item),
      ...selectedTransformationItems.map(x => x.item),
    ];
    if (targets.length === 0) return;
    const confirmMsg = targets.length === 1
      ? `"${targets[0].metadata.name}" wirklich löschen?`
      : `${targets.length} Dateien wirklich löschen?`;
    if (!window.confirm(confirmMsg)) return;

    try {
      const parentId = targets[0].parentId || 'root';
      for (const t of targets) {
        try { await provider.deleteItem(t.id); } catch (err) {
          FileLogger.error('FileList', 'Bulk Delete failed', { id: t.id, name: t.metadata.name, err });
        }
      }
      const refreshed = await refreshItems(parentId);
      setFolderItems(refreshed);
      setSelectedBatchItems([]);
      setSelectedTransformationItems([]);
    } catch (error) {
      FileLogger.error('FileList', 'Bulk Delete error', error);
    }
  }, [provider, selectedBatchItems, selectedTransformationItems, refreshItems, setFolderItems, setSelectedBatchItems, setSelectedTransformationItems]);

  // Intelligente Batch-Auswahl basierend auf Filter
  const handleSelectAll = useCallback((checked: boolean) => {
    const startTime = performance.now();
    if (checked) {
      // Verwende nur die Hauptdateien (baseItem) aus den FileGroups
      const mainItems = Array.from((fileGroups ?? new Map()).values())
        .map(group => group.baseItem)
        .filter((item): item is StorageItem => item !== undefined);
      const selectableItems = mainItems.filter(item => {
        try {
          const mediaType = getMediaType(item);
          // Je nach Filter unterschiedliche Dateien auswählen
          switch (currentCategoryFilter) {
            case 'media':
              return item.type === 'file' && (mediaType === 'audio' || mediaType === 'video');
            case 'text':
              return item.type === 'file' && mediaType === 'text';
            case 'documents':
              return item.type === 'file' && mediaType === 'document';
            default:
              // Bei 'all' alle Dateien auswählen, die für eine Operation geeignet sind
              return item.type === 'file' && (
                mediaType === 'audio' || 
                mediaType === 'video' || 
                mediaType === 'text' || 
                mediaType === 'document'
              );
          }
        } catch {
          return false;
        }
      });
      StateLogger.info('FileList', 'Selecting all items based on filter', {
        filter: currentCategoryFilter,
        totalItems: items.length,
        selectableCount: selectableItems.length,
        duration: `${(performance.now() - startTime).toFixed(2)}ms`
      });
      // Je nach Filter unterschiedliche Atome verwenden
      if (currentCategoryFilter === 'media') {
        setSelectedBatchItems(selectableItems.map(item => ({
          item,
          type: getMediaType(item)
        })));
      } else if (currentCategoryFilter === 'text') {
        setSelectedTransformationItems(selectableItems.map(item => ({
          item,
          type: getMediaType(item)
        })));
      } else {
        // Bei 'all' oder 'documents' beide Atome füllen
        const mediaItems = selectableItems.filter(item => {
          const mediaType = getMediaType(item);
          return mediaType === 'audio' || mediaType === 'video';
        });
        const textItems = selectableItems.filter(item => {
          const mediaType = getMediaType(item);
          return mediaType === 'text' || mediaType === 'document';
        });
        setSelectedBatchItems(mediaItems.map(item => ({
          item,
          type: getMediaType(item)
        })));
        setSelectedTransformationItems(textItems.map(item => ({
          item,
          type: getMediaType(item)
        })));
      }
    } else {
      StateLogger.info('FileList', 'Deselecting all items', {
        previouslySelected: selectedBatchItems.length + selectedTransformationItems.length,
        duration: `${(performance.now() - startTime).toFixed(2)}ms`
      });
      setSelectedBatchItems([]);
      setSelectedTransformationItems([]);
    }
  }, [fileGroups, currentCategoryFilter, setSelectedBatchItems, setSelectedTransformationItems, selectedBatchItems.length, selectedTransformationItems.length, items.length]);

  React.useEffect(() => {
    // Logging der Library-IDs - verzögert ausführen
    const timeoutId = setTimeout(() => {
      StateLogger.debug('FileList', 'Render', {
        currentLibraryId: currentLibrary?.id,
        activeLibraryIdAtom: activeLibraryId
      });
    }, 0);
    
    return () => clearTimeout(timeoutId);
  }, [currentLibrary, activeLibraryId]);

  // Entkoppelt: kein Render-Gate mehr basierend auf FileTree

  return (
    <div className="h-full flex flex-col">
      {/* Header - versteckt im compact mode */}
      {!compact && (
        <div className="border-b px-2 py-2 flex items-center justify-between bg-background sticky top-0 z-10">
          <div className="flex items-center gap-2">
            <Button
              variant="ghost"
              size="icon"
              className="h-8 w-8"
              onClick={handleRefresh}
              disabled={isRefreshing}
              title="Aktualisieren"
              aria-label="Aktualisieren"
            >
              <RefreshCw className={cn("h-4 w-4", isRefreshing && "animate-spin")} />
            </Button>

            {/* Dateikategorie-Filter (Icon-only Variante) */}
            <FileCategoryFilter iconOnly />

            {/* Batch-Actions als Icons */}
            {selectedBatchItems.length > 0 && (
              <Button size="icon" title="Transkribieren" aria-label="Transkribieren" onClick={handleBatchTranscription}>
                <ScrollText className="h-4 w-4" />
              </Button>
            )}
            {selectedTransformationItems.length > 0 && (
              <Button size="icon" variant="secondary" title="Transformieren" aria-label="Transformieren" onClick={handleBatchTransformation}>
                <Plus className="h-4 w-4" />
              </Button>
            )}
            {(selectedBatchItems.length + selectedTransformationItems.length) > 0 && (
              <Button size="icon" variant="destructive" title="Ausgewählte löschen" aria-label="Ausgewählte löschen" onClick={handleBulkDelete}>
                <Trash2 className="h-4 w-4" />
              </Button>
            )}
          </div>
        </div>
      )}

      {/* File List */}
      <div className="flex-1 overflow-auto">
        <div>
          {/* Table Header - versteckt im compact mode */}
          {!compact && (
            <div className="sticky top-0 bg-background border-b">
              <div className="grid grid-cols-[24px_24px_minmax(0,1fr)_56px_88px_auto] gap-2 px-4 py-2 text-sm font-medium text-muted-foreground">
                <div className="w-6 flex items-center justify-center">
                  <Checkbox
                    checked={isAllSelected}
                    onCheckedChange={handleSelectAll}
                    aria-label="Alle auswählen"
                  />
                </div>
                <div className="w-6" />
                <SortableHeaderCell
                  label="Name"
                  field="name"
                  currentSortField={sortField}
                  currentSortOrder={sortOrder}
                  onSort={handleSort}
                />
                <SortableHeaderCell
                  label="Größe"
                  field="size"
                  currentSortField={sortField}
                  currentSortOrder={sortOrder}
                  onSort={handleSort}
                />
                <SortableHeaderCell
                  label="Geändert"
                  field="date"
                  currentSortField={sortField}
                  currentSortOrder={sortOrder}
                  onSort={handleSort}
                />
                <div />
              </div>
            </div>
          )}

          {/* Folder Rows (oberhalb der Dateien, unabhängig von Datei-Gruppierung) */}
          {folders.length > 0 && (
            <div className="divide-y">
              {folders.map((folder) => (
                <div
                  key={folder.id}
                  role="button"
                  tabIndex={0}
                  onClick={() => navigateToFolder(folder.id)}
                  onKeyDown={(e) => {
                    if (e.key === 'Enter' || e.key === ' ') navigateToFolder(folder.id);
                  }}
                  className="w-full px-4 py-2 text-xs hover:bg-muted/50 grid grid-cols-[24px_24px_minmax(0,1fr)_56px_88px_auto] gap-2 items-center cursor-pointer"
                >
                  <div />
                  <FolderIcon className="h-4 w-4" />
                  <span className="text-left truncate select-none" title={folder.metadata.name}>{folder.metadata.name}</span>
                  <span className="text-muted-foreground" />
                  <span className="text-muted-foreground" />
                  <div />
                </div>
              ))}
            </div>
          )}

          {/* File Rows */}
          <div className="divide-y">
            {Array.from((fileGroups ?? new Map()).values())
              .map((group) => {
                // Zeige nur die Hauptdatei (baseItem) an
                const item = group.baseItem;
                if (!item) return null;
                // System-Unterordner-Id, wenn ein ".<basename>"-Folder existiert
                const systemFolder = systemFolderByBase.get(getBaseName(item.metadata.name));
                const systemFolderId = systemFolder?.id;
                return (
                  <FileRow
                    key={item.id}
                    item={item as StorageItem}
                    isSelected={isItemSelected(item)}
                    onSelect={() => handleSelect(item, group)}
                    onCreateTranscript={handleCreateTranscript}
                    onDelete={(e) => handleDeleteClick(e, item)}
                    fileGroup={group}
                    onSelectRelatedFile={handleSelectRelatedFile}
                    onRename={handleRename}
                    compact={compact}
                    systemFolderId={systemFolderId}
                  />
                );
              })}
          </div>
        </div>
      </div>
    </div>
  );
}); 
```

Ich habe den Tooltip für abgeschnittene Namen angepasst:

- In der File-Liste zeigt der `title` jetzt den vollständigen Dateinamen an statt des Umbenennen-Hinweises.
- Auch bei Ordnerzeilen wird der volle Name in `title` gesetzt.

Bitte testen: Maus über einen abgeschnittenen Namen → kompletter Name im Tooltip.

---

**User**

Wenn ich auf eine Datei wähle, dann wird ja in dem Vorschaubereich die Datei angezeigt. Es steht aber nirgends, welche Datei ausgewählt ist. Sollen wir das jetzt in der File-Liste irgendwie markieren, dass das sehr markant sichtbar ist? Vielleicht Fetch rein oder oben im Krömelpfad am Ende den Dateinamen angeben. Aber ich denke, es wäre besser, wenn man in der File-Liste markiert, welche Datei aktuell ist.

---

**Cursor**

```typescriptreact
'use client';

import * as React from "react"
import { File, FileText, FileVideo, FileAudio, Plus, RefreshCw, ChevronUp, ChevronDown, Trash2, ScrollText, Folder as FolderIcon, Layers } from "lucide-react"
import { StorageItem } from "@/lib/storage/types"
import { cn } from "@/lib/utils"
import { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from "@/components/ui/tooltip"
import { useStorage } from "@/contexts/storage-context";
import { Button } from "@/components/ui/button";
import { useAtomValue, useAtom } from 'jotai';
import { jobStatusByItemIdAtom } from '@/atoms/job-status';
import { 
  activeLibraryIdAtom, 
  selectedFileAtom, 
  folderItemsAtom,
  sortedFilteredFilesAtom,
  sortFieldAtom,
  sortOrderAtom,
  selectedShadowTwinAtom
} from '@/atoms/library-atom';
import { toast } from "sonner";
import { Input } from "@/components/ui/input"
import {
  selectedBatchItemsAtom,
  transcriptionDialogOpenAtom,
  selectedTransformationItemsAtom,
  transformationDialogOpenAtom,
  getMediaType,
  fileCategoryFilterAtom,
} from '@/atoms/transcription-options';
import { Checkbox } from "@/components/ui/checkbox"
import { useMemo, useCallback } from "react"
import { FileLogger, StateLogger } from "@/lib/debug/logger"
import { FileCategoryFilter } from './file-category-filter';
import { useFolderNavigation } from "@/hooks/use-folder-navigation";

// Typen für Sortieroptionen
type SortField = 'type' | 'name' | 'size' | 'date';
type SortOrder = 'asc' | 'desc';

// Typ für gruppierte Dateien
interface FileGroup {
  baseItem?: StorageItem;
  transcriptFiles?: StorageItem[]; // NEU: alle Transkripte
  transformed?: StorageItem;
}

// Memoized file icon component
const FileIconComponent = React.memo(function FileIconComponent({ item }: { item: StorageItem }) {
  const mimeType = item.metadata.mimeType || '';
  if (!mimeType) return <File className="h-4 w-4" />;

  if (mimeType.startsWith('video/')) {
    return <FileVideo className="h-4 w-4" />;
  } else if (mimeType.startsWith('audio/')) {
    return <FileAudio className="h-4 w-4" />;
  } else if (mimeType.startsWith('text/')) {
    return <FileText className="h-4 w-4" />;
  }

  return <File className="h-4 w-4" />;
});

// Pure function for file size formatting
const formatFileSize = (size?: number): string => {
  if (!size) return '-';
  const units = ['B', 'KB', 'MB', 'GB'];
  let value = size;
  let unitIndex = 0;
  
  while (value >= 1024 && unitIndex < units.length - 1) {
    value /= 1024;
    unitIndex++;
  }
  
  return `${value.toFixed(1)} ${units[unitIndex]}`;
};

// Funktion zum Formatieren des Datums
const formatDate = (date?: Date): string => {
  if (!date) return '-';
  
  const options: Intl.DateTimeFormatOptions = { 
    year: '2-digit', 
    month: '2-digit', 
    day: '2-digit',
    hour: '2-digit',
    minute: '2-digit'
  };
  
  return new Date(date).toLocaleDateString('de-DE', options);
};

// Entfernt: getFileStem Funktion war unbenutzt

// Sortierbare Kopfzelle Komponente
const SortableHeaderCell = React.memo(function SortableHeaderCell({
  label,
  field,
  currentSortField,
  currentSortOrder,
  onSort
}: {
  label: string,
  field: SortField,
  currentSortField: SortField,
  currentSortOrder: SortOrder,
  onSort: (field: SortField) => void
}) {
  const isActive = currentSortField === field;
  
  return (
    <button 
      onClick={() => onSort(field)}
      className="flex items-center gap-1 hover:text-foreground"
    >
      <span>{label}</span>
      {isActive && (
        currentSortOrder === 'asc' 
          ? <ChevronUp className="h-3 w-3" /> 
          : <ChevronDown className="h-3 w-3" />
      )}
    </button>
  );
});

interface FileRowProps {
  item: StorageItem;
  isSelected: boolean;
  isActive?: boolean;
  onSelect: () => void;
  onCreateTranscript: (e: React.MouseEvent) => void;
  onDelete: (e: React.MouseEvent<HTMLButtonElement>, item: StorageItem) => void;
  fileGroup?: FileGroup;
  onSelectRelatedFile?: (file: StorageItem) => void;
  onRename?: (item: StorageItem, newName: string) => Promise<void>;
  compact?: boolean;
  systemFolderId?: string;
}

const FileRow = React.memo(function FileRow({ 
  item, 
  isSelected, 
  isActive = false,
  onSelect,
  onCreateTranscript,
  onDelete,
  fileGroup,
  onSelectRelatedFile,
  onRename,
  compact = false,
  systemFolderId
}: FileRowProps) {
  const navigateToFolder = useFolderNavigation();
  const [isEditing, setIsEditing] = React.useState(false);
  const [editName, setEditName] = React.useState(item.metadata.name);
  const inputRef = React.useRef<HTMLInputElement>(null);
  const longPressTimerRef = React.useRef<NodeJS.Timeout | null>(null);
  const lastClickTimeRef = React.useRef<number>(0);
  
  // Zusätzliche Validierung der Metadaten
  const metadata = React.useMemo(() => ({
    name: item.metadata?.name || 'Unbekannte Datei',
    size: typeof item.metadata?.size === 'number' ? item.metadata.size : 0,
    mimeType: item.metadata?.mimeType || '',
    hasTranscript: !!item.metadata?.hasTranscript || (fileGroup?.transcriptFiles && fileGroup.transcriptFiles.length > 0),
    modifiedAt: item.metadata?.modifiedAt
  }), [item.metadata, fileGroup]);

  const isTranscribable = React.useMemo(() => {
    const mimeType = metadata.mimeType.toLowerCase();
    const extension = metadata.name.split('.').pop()?.toLowerCase();

    return (
      mimeType.startsWith('audio/') ||
      mimeType.startsWith('video/') ||
      extension === 'pdf' ||
      mimeType === 'application/pdf'
    );
  }, [metadata.mimeType, metadata.name]);

  // Memoize the click handler
  const handleClick = React.useCallback(() => {
    if (!isEditing) {
      onSelect();
    }
  }, [onSelect, isEditing]);

  // Memoize the keydown handler
  const handleKeyDown = React.useCallback((e: React.KeyboardEvent) => {
    if (!isEditing && (e.key === 'Enter' || e.key === ' ')) {
      onSelect();
    }
  }, [onSelect, isEditing]);

  // Handler für Transkript-Icon Click
  const handleTranscriptClick = React.useCallback((e: React.MouseEvent) => {
    e.stopPropagation();
    if (fileGroup?.transcriptFiles && onSelectRelatedFile) {
      onSelectRelatedFile(fileGroup.transcriptFiles[0]); // Nur das erste Transkript anzeigen
    }
  }, [fileGroup, onSelectRelatedFile]);

  // Handler für Transformierte-Datei-Icon Click
  const handleTransformedClick = React.useCallback((e: React.MouseEvent) => {
    e.stopPropagation();
    if (fileGroup?.transformed && onSelectRelatedFile) {
      onSelectRelatedFile(fileGroup.transformed);
    }
  }, [fileGroup, onSelectRelatedFile]);

  // Starte Rename-Modus
  const startRename = React.useCallback(() => {
    if (onRename) {
      // Prüfe ob dies eine abhängige Datei ist
      if (fileGroup && (
        (fileGroup.transcriptFiles && fileGroup.transcriptFiles.length > 0 && fileGroup.transcriptFiles[0]?.id === item.id) ||
        (fileGroup.transformed && item.id === fileGroup.transformed.id)
      )) {
        // Dies ist eine abhängige Datei - zeige Hinweis
        toast.info("Hinweis", {
          description: "Bitte benennen Sie die Haupt-Datei um. Abhängige Dateien werden automatisch mit umbenannt."
        });
        return;
      }
      
      setIsEditing(true);
      setEditName(item.metadata.name);
    }
  }, [onRename, item, fileGroup]);

  // Handler für Dateinamen-Click (Doppelklick-Erkennung)
  const handleNameClick = React.useCallback((e: React.MouseEvent) => {
    e.stopPropagation();
    
    const currentTime = Date.now();
    const timeSinceLastClick = currentTime - lastClickTimeRef.current;
    
    if (timeSinceLastClick < 300) {
      // Doppelklick erkannt
      startRename();
    } else {
      // Erster Klick - wähle die Datei aus
      onSelect();
    }
    
    lastClickTimeRef.current = currentTime;
  }, [startRename, onSelect]);

  // Handler für Long-Press (Touch-Geräte)
  const handleTouchStart = React.useCallback((e: React.TouchEvent) => {
    e.stopPropagation();
    
    // Starte Long-Press Timer
    longPressTimerRef.current = setTimeout(() => {
      startRename();
    }, 500); // 500ms für Long-Press
  }, [startRename]);

  const handleTouchEnd = React.useCallback((e: React.TouchEvent) => {
    e.stopPropagation();
    
    // Lösche Long-Press Timer
    if (longPressTimerRef.current) {
      clearTimeout(longPressTimerRef.current);
      longPressTimerRef.current = null;
    }
  }, []);

  const handleTouchMove = React.useCallback(() => {
    // Bei Bewegung Long-Press abbrechen
    if (longPressTimerRef.current) {
      clearTimeout(longPressTimerRef.current);
      longPressTimerRef.current = null;
    }
  }, []);

  // Cleanup Timer bei Unmount
  React.useEffect(() => {
    return () => {
      if (longPressTimerRef.current) {
        clearTimeout(longPressTimerRef.current);
      }
    };
  }, []);

  // Handler für Rename-Submit
  const handleRenameSubmit = React.useCallback(async () => {
    if (onRename && editName.trim() && editName !== item.metadata.name) {
      try {
        await onRename(item, editName.trim());
      } catch (error) {
        FileLogger.error('FileRow', 'Fehler beim Umbenennen', error);
        // Bei Fehler den ursprünglichen Namen wiederherstellen
        setEditName(item.metadata.name);
      }
    }
    setIsEditing(false);
  }, [onRename, editName, item]);

  // Handler für Rename-Cancel
  const handleRenameCancel = React.useCallback(() => {
    setEditName(item.metadata.name);
    setIsEditing(false);
  }, [item.metadata.name]);

  // Handler für Input-Änderungen
  const handleInputChange = React.useCallback((e: React.ChangeEvent<HTMLInputElement>) => {
    setEditName(e.target.value);
  }, []);

  // Handler für Input-Keydown
  const handleInputKeyDown = React.useCallback((e: React.KeyboardEvent<HTMLInputElement>) => {
    e.stopPropagation();
    if (e.key === 'Enter') {
      handleRenameSubmit();
    } else if (e.key === 'Escape') {
      handleRenameCancel();
    }
  }, [handleRenameSubmit, handleRenameCancel]);

  // Focus Input wenn Edit-Modus aktiviert wird
  React.useEffect(() => {
    if (isEditing && inputRef.current) {
      inputRef.current.focus();
      inputRef.current.select();
    }
  }, [isEditing]);

  // Handler für Drag Start
  const handleDragStart = React.useCallback((e: React.DragEvent) => {
    // Sammle alle Dateien der Gruppe, die verschoben werden sollen
    const itemsToMove = [];
    
    // Füge das aktuelle Item hinzu
    itemsToMove.push({
      itemId: item.id,
      itemName: item.metadata.name,
      itemType: item.type,
      parentId: item.parentId
    });
    
    // Wenn es eine FileGroup gibt, füge auch die zugehörigen Dateien hinzu
    if (fileGroup) {
      // Prüfe ob das aktuelle Item die Basis-Datei ist
      if (item.id === fileGroup.baseItem?.id) {
        // Füge Transkripte hinzu, falls vorhanden
        if (fileGroup.transcriptFiles && fileGroup.transcriptFiles.length > 0) {
          fileGroup.transcriptFiles.forEach(transcript => {
            itemsToMove.push({
              itemId: transcript.id,
              itemName: transcript.metadata.name,
              itemType: transcript.type,
              parentId: transcript.parentId
            });
          });
        }
        
        // Füge transformierte Datei hinzu, falls vorhanden
        if (fileGroup.transformed) {
          itemsToMove.push({
            itemId: fileGroup.transformed.id,
            itemName: fileGroup.transformed.metadata.name,
            itemType: fileGroup.transformed.type,
            parentId: fileGroup.transformed.parentId
          });
        }
      }
    }
    
    // Setze die Drag-Daten
    e.dataTransfer.effectAllowed = 'move';
    e.dataTransfer.setData('application/json', JSON.stringify({
      items: itemsToMove,
      isFileGroup: itemsToMove.length > 1
    }));
    
    // Visuelles Feedback
    if (e.currentTarget instanceof HTMLElement) {
      e.currentTarget.style.opacity = '0.5';
    }
  }, [item, fileGroup]);

  // Handler für Drag End
  const handleDragEnd = React.useCallback((e: React.DragEvent) => {
    // Stelle Opacity wieder her
    if (e.currentTarget instanceof HTMLElement) {
      e.currentTarget.style.opacity = '1';
    }
  }, []);

  const [selectedBatchItems, setSelectedBatchItems] = useAtom(selectedBatchItemsAtom);
  const [selectedTransformationItems, setSelectedTransformationItems] = useAtom(selectedTransformationItemsAtom);
  
  // Prüfe ob das Item in einem der beiden Atome ausgewählt ist
  const isInBatch = selectedBatchItems.some(batchItem => batchItem.item.id === item.id);
  const isInTransformation = selectedTransformationItems.some(transformationItem => transformationItem.item.id === item.id);
  const isInAnyBatch = isInBatch || isInTransformation;

  // Handler für Checkbox-Änderungen
  const handleCheckboxChange = React.useCallback((checked: boolean) => {
    const mediaType = getMediaType(item);
    
    if (mediaType === 'audio' || mediaType === 'video') {
      // Für Audio/Video: Transcription-Atom verwenden
      if (checked) {
        setSelectedBatchItems([...selectedBatchItems, {
          item,
          type: mediaType
        }]);
      } else {
        setSelectedBatchItems(selectedBatchItems.filter(i => i.item.id !== item.id));
      }
    } else if (mediaType === 'text' || mediaType === 'document') {
      // Für Text/Dokumente: Transformation-Atom verwenden
      if (checked) {
        setSelectedTransformationItems([...selectedTransformationItems, {
          item,
          type: mediaType
        }]);
      } else {
        setSelectedTransformationItems(selectedTransformationItems.filter(i => i.item.id !== item.id));
      }
    }
  }, [item, selectedBatchItems, selectedTransformationItems, setSelectedBatchItems, setSelectedTransformationItems]);

  React.useEffect(() => {
    if (fileGroup) {
      FileLogger.debug('FileRow', 'Transkripte für Zeile', {
        baseItem: fileGroup.baseItem?.metadata.name,
        transcripts: fileGroup.transcriptFiles?.map(t => t.metadata.name)
      });
    }
  }, [fileGroup]);

  // Zentraler Jobstatus (muss vor möglichen early-returns stehen, um Hook-Order zu garantieren)
  const jobStatusMap = useAtomValue(jobStatusByItemIdAtom);
  const jobStatus = jobStatusMap[item.id];
  const jobStatusIcon = jobStatus ? (
    <span title={jobStatus} className={cn('inline-block h-3 w-3 rounded-full',
      jobStatus === 'queued' && 'bg-blue-600',
      jobStatus === 'running' && 'bg-yellow-600',
      jobStatus === 'completed' && 'bg-green-600',
      jobStatus === 'failed' && 'bg-red-600'
    )} aria-label={`job-${jobStatus}`} />
  ) : null;

  // Compact-Modus: vereinfachte Darstellung
  if (compact) {
    return (
      <div
        role="button"
        tabIndex={0}
        onClick={handleClick}
        onKeyDown={handleKeyDown}
        className={cn(
          "w-full px-2 py-1 text-sm hover:bg-muted/50 flex items-center gap-2 cursor-pointer",
          isSelected && "bg-muted",
          isActive && "bg-primary/10 border-l-2 border-primary"
        )}
      >
        <FileIconComponent item={item} />
        <span className={cn("truncate flex-1", isActive && "font-medium") } title={metadata.name}>
          {metadata.name}
        </span>
        {/* Shadow-Twin-Symbole im compact mode */}
        {fileGroup?.transcriptFiles && fileGroup.transcriptFiles.length > 0 && (
          <Button
            variant="ghost"
            size="icon"
            className="h-4 w-4 p-0 hover:bg-muted text-muted-foreground hover:text-foreground"
            onClick={handleTranscriptClick}
          >
            <ScrollText className="h-3 w-3" />
          </Button>
        )}
      </div>
    );
  }

  return (
    <div
      role="button"
      tabIndex={0}
      onClick={handleClick}
      onKeyDown={handleKeyDown}
      onTouchStart={handleTouchStart}
      onTouchEnd={handleTouchEnd}
      onTouchMove={handleTouchMove}
      draggable={!isEditing}
      onDragStart={handleDragStart}
      onDragEnd={handleDragEnd}
      className={cn(
        "w-full px-4 py-2 text-xs hover:bg-muted/50 grid grid-cols-[24px_24px_minmax(0,1fr)_56px_88px_auto] gap-2 items-center cursor-move",
        isSelected && "bg-muted"
      )}
    >
      <div className="w-6 flex items-center justify-center">
        <Checkbox
          checked={isInAnyBatch}
          onCheckedChange={handleCheckboxChange}
          onClick={(e) => e.stopPropagation()}
        />
      </div>
      <FileIconComponent item={item} />
      {isEditing ? (
        <Input
          ref={inputRef}
          value={editName}
          onChange={handleInputChange}
          onKeyDown={handleInputKeyDown}
          onBlur={handleRenameSubmit}
          onClick={(e) => e.stopPropagation()}
          className="h-6 px-1 py-0 text-xs"
        />
      ) : (
        <span 
          className="text-left truncate cursor-pointer hover:text-primary select-none"
          onClick={handleNameClick}
          onTouchStart={handleTouchStart}
          onTouchEnd={handleTouchEnd}
          onTouchMove={handleTouchMove}
          title={metadata.name}
        >
          {metadata.name}
        </span>
      )}
      <span className="text-muted-foreground tabular-nums text-[10px]">
        {formatFileSize(metadata.size)}
      </span>
      <span className="text-muted-foreground tabular-nums text-[10px]">
        {formatDate(metadata.modifiedAt)}
      </span>
      <div className="flex items-center justify-start gap-1">
        {jobStatusIcon}
        {/* System-Unterordner (z. B. extrahierte Seiten) */}
        {systemFolderId && (
          <TooltipProvider>
            <Tooltip>
              <TooltipTrigger asChild>
                <Button
                  variant="ghost"
                  size="icon"
                  className="h-6 w-6 p-0 hover:bg-muted"
                  onClick={(e) => {
                    e.stopPropagation();
                    navigateToFolder(systemFolderId);
                  }}
                >
                  <Layers className="h-4 w-4 text-violet-500" />
                </Button>
              </TooltipTrigger>
              <TooltipContent>
                <p>Seiten-Ordner öffnen</p>
              </TooltipContent>
            </Tooltip>
          </TooltipProvider>
        )}
        {/* Zeige Icons für alle vorhandenen Transkripte */}
        {fileGroup?.transcriptFiles && fileGroup.transcriptFiles.length > 0 && fileGroup.transcriptFiles.map((transcript) => (
          <TooltipProvider key={transcript.id}>
            <Tooltip>
              <TooltipTrigger asChild>
                <Button
                  variant="ghost"
                  size="icon"
                  className="h-6 w-6 p-0 hover:bg-muted"
                  onClick={(e) => {
                    e.stopPropagation();
                    if (onSelectRelatedFile) onSelectRelatedFile(transcript);
                  }}
                >
                  <FileText className="h-4 w-4 text-blue-500" />
                </Button>
              </TooltipTrigger>
              <TooltipContent>
                <p>Transkript anzeigen: {transcript.metadata.name}</p>
              </TooltipContent>
            </Tooltip>
          </TooltipProvider>
        ))}
        {/* Plus-Symbol nur anzeigen, wenn kein Transkript vorhanden und transkribierbar */}
        {(!fileGroup?.transcriptFiles || fileGroup.transcriptFiles.length === 0) && isTranscribable && !metadata.hasTranscript ? (
          <TooltipProvider>
            <Tooltip>
              <TooltipTrigger asChild>
                <div 
                  role="button"
                  tabIndex={0}
                  className="h-6 w-6 p-0 inline-flex items-center justify-center hover:bg-muted rounded-sm"
                  onClick={onCreateTranscript}
                  onKeyDown={(e) => {
                    if (e.key === 'Enter' || e.key === ' ') {
                      e.stopPropagation();
                      onCreateTranscript(e as unknown as React.MouseEvent<HTMLDivElement>);
                    }
                  }}
                >
                  <Plus className="h-4 w-4" />
                </div>
              </TooltipTrigger>
              <TooltipContent>
                <p>Transkript erstellen</p>
              </TooltipContent>
            </Tooltip>
          </TooltipProvider>
        ) : null}
        {/* Icon für transformierte Datei */}
        {fileGroup?.transformed && (
          <TooltipProvider>
            <Tooltip>
              <TooltipTrigger asChild>
                <Button
                  variant="ghost"
                  size="icon"
                  className="h-6 w-6 p-0 hover:bg-muted"
                  onClick={handleTransformedClick}
                >
                  <ScrollText className="h-4 w-4 text-green-500" />
                </Button>
              </TooltipTrigger>
              <TooltipContent>
                <p>Transformierte Datei anzeigen</p>
              </TooltipContent>
            </Tooltip>
          </TooltipProvider>
        )}
        {/* Delete direkt neben Dokument-Icons */}
        <TooltipProvider>
          <Tooltip>
            <TooltipTrigger asChild>
              <Button
                variant="ghost"
                size="icon"
                className="h-6 w-6 p-0 hover:bg-destructive/10 hover:text-destructive"
                onClick={(e) => onDelete(e as React.MouseEvent<HTMLButtonElement>, item)}
              >
                <Trash2 className="h-4 w-4" />
              </Button>
            </TooltipTrigger>
            <TooltipContent>
              <p>Datei löschen</p>
            </TooltipContent>
          </Tooltip>
        </TooltipProvider>
      </div>
      <div />
    </div>
  );
});

interface FileListProps {
  compact?: boolean;
}

export const FileList = React.memo(function FileList({ compact = false }: FileListProps): JSX.Element {
  const { provider, refreshItems, currentLibrary } = useStorage();
  const activeLibraryId = useAtomValue(activeLibraryIdAtom);
  const [isRefreshing, setIsRefreshing] = React.useState(false);
  // Mobile-Flag wurde entfernt, FileList lädt unabhängig vom View
  const [selectedBatchItems, setSelectedBatchItems] = useAtom(selectedBatchItemsAtom);
  const [selectedTransformationItems, setSelectedTransformationItems] = useAtom(selectedTransformationItemsAtom);
  const [, setTranscriptionDialogOpen] = useAtom(transcriptionDialogOpenAtom);
  const [, setTransformationDialogOpen] = useAtom(transformationDialogOpenAtom);
  const [isInitialized, setIsInitialized] = React.useState(false);
  const initializationTimeoutRef = React.useRef<NodeJS.Timeout | null>(null);
  // Entkoppelt: Kein Warten mehr auf FileTree-Status
  const [, setSelectedFile] = useAtom(selectedFileAtom);
  const [, setFolderItems] = useAtom(folderItemsAtom);
  const currentCategoryFilter = useAtomValue(fileCategoryFilterAtom);
  const allItemsInFolder = useAtomValue(folderItemsAtom);
  const navigateToFolder = useFolderNavigation();

  // Kein mobiles Flag mehr notwendig

  const folders = useMemo(() => {
    const items = allItemsInFolder ?? [];
    // Verstecke dot-Verzeichnisse generell in der Liste
    return items.filter(item => item.type === 'folder' && !item.metadata.name.startsWith('.'));
  }, [allItemsInFolder]);

  // Hilfsfunktion zum Finden einer FileGroup in der Map
  const findFileGroup = (map: Map<string, FileGroup>, stem: string): FileGroup | undefined => {
    return Array.from((map ?? new Map()).values()).find(group => 
      group.baseItem && getBaseName(group.baseItem.metadata.name) === stem
    );
  };

  // NEU: Atome für Sortierung und Filter
  const items = useAtomValue(sortedFilteredFilesAtom);
  const [sortField, setSortField] = useAtom(sortFieldAtom);
  const [sortOrder, setSortOrder] = useAtom(sortOrderAtom);
  
  // Review-Mode-Atoms
  const [, setSelectedShadowTwin] = useAtom(selectedShadowTwinAtom);

  // handleSort nutzt jetzt Atome
  const handleSort = React.useCallback((field: SortField) => {
    if (field === sortField) setSortOrder(sortOrder === 'asc' ? 'desc' : 'asc');
    else {
      setSortField(field);
      setSortOrder('asc');
    }
  }, [sortField, sortOrder, setSortField, setSortOrder]);

  // Initialisierung - nur auf Provider und Mobile-Flag achten
  React.useEffect(() => {
    if (!provider) {
      FileLogger.info('FileList', 'Waiting for provider');
      return;
    }

    const initialize = async () => {
      if (isInitialized) {
        FileLogger.debug('FileList', 'Already initialized');
        return;
      }

      FileLogger.info('FileList', 'Starting initialization');

      try {
        FileLogger.info('FileList', 'Initialization complete');
        setIsInitialized(true);
      } catch (error) {
        FileLogger.error('FileList', 'Error initializing FileList', error);
      }
    };

    initialize();

    const timeoutRef = initializationTimeoutRef.current;
    return () => {
      if (timeoutRef) clearTimeout(timeoutRef);
    };
  }, [provider, isInitialized]);

  // NEU: Reagieren auf Bibliothekswechsel
  const prevLibraryIdRef = React.useRef<string | null>(null);
  React.useEffect(() => {
    StateLogger.debug('FileList', 'Render', {
      currentLibraryId: activeLibraryId,
      activeLibraryIdAtom: activeLibraryId
    });

    // Nur bei tatsächlichem Bibliothekswechsel zurücksetzen
    if (prevLibraryIdRef.current !== null && prevLibraryIdRef.current !== activeLibraryId) {
      setIsInitialized(false);
      setSelectedFile(null);
      setFolderItems([]);
      setSelectedBatchItems([]);
      setSelectedTransformationItems([]);
      setSelectedShadowTwin(null);
      StateLogger.info('FileList', 'Bibliothek gewechselt - State zurückgesetzt', {
        libraryId: activeLibraryId
      });
    }
    prevLibraryIdRef.current = activeLibraryId;
  }, [activeLibraryId, setSelectedFile, setFolderItems, setSelectedBatchItems, setSelectedTransformationItems, setSelectedShadowTwin]);

  // Vereinfachte Funktion zum Extrahieren des Basisnamens (ohne Endung, auch für Binärdateien)
  function getBaseName(name: string): string {
    // ShadowTwin: .de.md, .en.md, etc.
    const shadowTwinMatch = name.match(/^(.*)\.(de|en|fr|es|it)\.md$/);
    if (shadowTwinMatch) return shadowTwinMatch[1];
    // Sonst: alles vor der letzten Endung
    const lastDot = name.lastIndexOf('.');
    if (lastDot === -1) return name;
    return name.substring(0, lastDot);
  }

  // Prüft ob eine Datei ein ShadowTwin ist (Markdown mit Sprachkürzel)
  function isShadowTwin(name: string): boolean {
    // Pattern: name.de.md, name.en.md, etc.
    const shadowTwinPattern = /^(.+)\.(de|en|fr|es|it)\.md$/;
    return shadowTwinPattern.test(name);
  }

  // Gruppiere die Dateien nach Basename
  const fileGroups = useMemo(() => {
    if (!items) return new Map<string, FileGroup>();

    // Schritt 1: Gruppiere alle Dateien nach Basename
    const groupsMap = new Map<string, StorageItem[]>();
    for (const item of items) {
      if (item.type !== 'file') continue;
      const base = getBaseName(item.metadata.name);
      if (!groupsMap.has(base)) groupsMap.set(base, []);
      groupsMap.get(base)!.push(item);
    }

    // Schritt 2: Erstelle FileGroups
    const fileGroupsMap = new Map<string, FileGroup>();
    for (const [base, groupItems] of Array.from(groupsMap.entries())) {
      // Finde Hauptdatei (erste Nicht-ShadowTwin-Datei)
      const mainFile = groupItems.find((item) => !isShadowTwin(item.metadata.name));
      // Finde alle ShadowTwins
      const shadowTwins = groupItems.filter((item) => isShadowTwin(item.metadata.name));
      if (mainFile) {
        fileGroupsMap.set(base, {
          baseItem: mainFile,
          transcriptFiles: shadowTwins.length > 0 ? shadowTwins : undefined,
          transformed: undefined
        });
      } else {
        // Keine Hauptdatei: Jede ShadowTwin einzeln anzeigen
        for (const twin of shadowTwins) {
          fileGroupsMap.set(`${base}__shadow_${twin.id}`, {
            baseItem: twin,
            transcriptFiles: undefined,
            transformed: undefined
          });
        }
      }
    }
    // Debug-Logging für Gruppierung
    FileLogger.debug('FileList', 'Gruppierung Ergebnis (Basename, alle Endungen)', {
      groups: Array.from(fileGroupsMap.entries()).map(([base, group]) => ({
        base,
        baseItem: group.baseItem?.metadata.name,
        transcripts: group.transcriptFiles?.map(t => t.metadata.name)
      }))
    });
    return fileGroupsMap;
  }, [items]);

  // Mapping: Basename -> dot-Systemordner (z. B. ".<basename>")
  const systemFolderByBase = useMemo(() => {
    const map = new Map<string, StorageItem>();
    const items = allItemsInFolder ?? [];
    for (const it of items) {
      if (it.type !== 'folder') continue;
      const name = it.metadata.name;
      if (!name.startsWith('.')) continue;
      const base = name.slice(1);
      if (base) map.set(base, it);
    }
    return map;
  }, [allItemsInFolder]);

  // Berechne, ob alle Dateien ausgewählt sind
  const isAllSelected = useMemo(() => {
    if (!fileGroups || !fileGroups.size) return false;
    // Verwende nur die Hauptdateien (baseItem) aus den FileGroups
    const mainItems = Array.from((fileGroups ?? new Map()).values())
      .map(group => group.baseItem)
      .filter((item): item is StorageItem => item !== undefined);
    // Je nach Filter unterschiedliche Dateien zählen
    let selectableItems: StorageItem[] = [];
    switch (currentCategoryFilter) {
      case 'media':
        selectableItems = mainItems.filter(item => {
          try {
            const mediaType = getMediaType(item);
            return item.type === 'file' && (mediaType === 'audio' || mediaType === 'video');
          } catch {
            return false;
          }
        });
        return selectableItems.length > 0 && selectedBatchItems.length === selectableItems.length;
      case 'text':
        selectableItems = mainItems.filter(item => {
          try {
            const mediaType = getMediaType(item);
            return item.type === 'file' && mediaType === 'text';
          } catch {
            return false;
          }
        });
        return selectableItems.length > 0 && selectedTransformationItems.length === selectableItems.length;
      case 'documents':
        selectableItems = mainItems.filter(item => {
          try {
            const mediaType = getMediaType(item);
            return item.type === 'file' && mediaType === 'document';
          } catch {
            return false;
          }
        });
        return selectableItems.length > 0 && selectedTransformationItems.length === selectableItems.length;
      default:
        // Bei 'all' prüfen ob alle verfügbaren Dateien ausgewählt sind
        const mediaItems = mainItems.filter(item => {
          try {
            const mediaType = getMediaType(item);
            return item.type === 'file' && (mediaType === 'audio' || mediaType === 'video');
          } catch {
            return false;
          }
        });
        const textItems = mainItems.filter(item => {
          try {
            const mediaType = getMediaType(item);
            return item.type === 'file' && (mediaType === 'text' || mediaType === 'document');
          } catch {
            return false;
          }
        });
        const allMediaSelected = mediaItems.length === 0 || selectedBatchItems.length === mediaItems.length;
        const allTextSelected = textItems.length === 0 || selectedTransformationItems.length === textItems.length;
        return allMediaSelected && allTextSelected;
    }
  }, [fileGroups, selectedBatchItems, selectedTransformationItems, currentCategoryFilter]);
  
  // Erweiterte handleSelect Funktion für Review-Mode
  const handleSelect = useCallback((item: StorageItem, group?: FileGroup) => {
    FileLogger.debug('FileList', 'handleSelect aufgerufen', {
      itemId: item.id,
      itemName: item.metadata.name,
      groupBase: group?.baseItem?.metadata.name,
      transcriptCount: group?.transcriptFiles?.length ?? 0,
      hasTranscripts: !!(group && group.transcriptFiles && group.transcriptFiles.length > 0)
    });
    
    // Nur die ausgewählte Datei setzen - Review-Modus wird über Toggle-Button gesteuert
    setSelectedFile(item);
    
    // Wenn wir im Review-Modus sind und eine Basis-Datei mit Shadow-Twin ausgewählt wird,
    // dann automatisch das Shadow-Twin setzen
    if (group && group.transcriptFiles && group.transcriptFiles.length > 0) {
      const shadowTwin = group.transcriptFiles[0];
      FileLogger.info('FileList', 'Basis-Datei mit Shadow-Twin ausgewählt', {
        twinId: shadowTwin.id,
        twinName: shadowTwin.metadata.name,
        baseFileId: item.id,
        baseFileName: item.metadata.name
      });
      setSelectedShadowTwin(shadowTwin);
    } else {
      FileLogger.info('FileList', 'Datei ohne Shadow-Twin ausgewählt', {
        itemId: item.id,
        itemName: item.metadata.name,
        groupExists: !!group,
        transcriptCount: group?.transcriptFiles?.length ?? 0
      });
      setSelectedShadowTwin(null);
    }
  }, [setSelectedFile, setSelectedShadowTwin, findFileGroup]);
  
  // Erweiterte handleSelectRelatedFile Funktion für Review-Mode
  const handleSelectRelatedFile = useCallback((shadowTwin: StorageItem) => {
    StateLogger.info('FileList', 'Shadow-Twin ausgewählt', {
      shadowTwinId: shadowTwin.id,
      shadowTwinName: shadowTwin.metadata.name
    });
    
    // Setze das Shadow-Twin als ausgewählte Datei, damit es rechts angezeigt wird
    setSelectedFile(shadowTwin);
    setSelectedShadowTwin(null); // Kein zusätzliches Shadow-Twin im normalen Modus
  }, [setSelectedFile, setSelectedShadowTwin, findFileGroup]);

  // Aktualisierte handleRefresh Funktion
  const handleRefresh = useCallback(async () => {
    if (!items || items.length === 0) return;
    
    const parentId = items[0]?.parentId;
    if (!parentId) return;
    
    setIsRefreshing(true);
    
    try {
      const refreshedItems = await refreshItems(parentId);
      setFolderItems(refreshedItems);
    } catch (error) {
      FileLogger.error('FileList', 'Fehler beim Aktualisieren der Dateiliste', error);
    } finally {
      setIsRefreshing(false);
    }
  }, [items, refreshItems, setFolderItems]);

  const handleCreateTranscript = React.useCallback((e: React.MouseEvent) => {
    e.stopPropagation();
    FileLogger.info('FileList', 'Create transcript for', { fileName: 'TODO' });
    // TODO: Implement transcript creation
  }, []);

  // Entfernt: handleItemSelect war unbenutzt

  // Check if an item is selected (beide Atome prüfen)
  const isItemSelected = useCallback((item: StorageItem) => {
    const mediaType = getMediaType(item);
    if (mediaType === 'audio' || mediaType === 'video') {
      return selectedBatchItems.some(selected => selected.item.id === item.id);
    } else {
      return selectedTransformationItems.some(selected => selected.item.id === item.id);
    }
  }, [selectedBatchItems, selectedTransformationItems]);

  // Löschfunktion
  const handleDeleteClick = React.useCallback(async (e: React.MouseEvent<HTMLButtonElement>, itemToDelete: StorageItem) => {
    e.stopPropagation();
    
    if (!provider) {
      toast.error("Fehler", {
        description: "Storage Provider nicht verfügbar"
      });
      return;
    }

    try {
      // Finde die FileGroup für dieses Item
      const itemStem = getBaseName(itemToDelete.metadata.name);
      const fileGroup = findFileGroup(fileGroups, itemStem);

      // Bestätigungsnachricht vorbereiten
      let confirmMessage = `Möchten Sie "${itemToDelete.metadata.name}" wirklich löschen?`;
      if (fileGroup && itemToDelete.id === fileGroup.baseItem?.id) {
        if (fileGroup.transcriptFiles && fileGroup.transcriptFiles.length > 0 || fileGroup.transformed) {
          confirmMessage = `Möchten Sie "${itemToDelete.metadata.name}" und alle zugehörigen Dateien wirklich löschen?`;
        }
      }

      // Benutzer um Bestätigung bitten
      if (!window.confirm(confirmMessage)) {
        return;
      }

      if (fileGroup && itemToDelete.id === fileGroup.baseItem?.id) {
        // Dies ist die Basis-Datei - lösche auch abhängige Dateien
        // Lösche alle Transkripte, falls vorhanden
        if (fileGroup.transcriptFiles) {
          for (const transcript of fileGroup.transcriptFiles) {
            try {
              await provider.deleteItem(transcript.id);
              FileLogger.info('FileList', 'Transkript gelöscht', {
                transcriptId: transcript.id,
                transcriptName: transcript.metadata.name
              });
            } catch (error) {
              FileLogger.error('FileList', 'Fehler beim Löschen des Transkripts', error);
              toast.warning("Hinweis", {
                description: "Einige Transkripte konnten nicht gelöscht werden"
              });
            }
          }
        }

        // Lösche die transformierte Datei, falls vorhanden
        if (fileGroup.transformed) {
          try {
            await provider.deleteItem(fileGroup.transformed.id);
            FileLogger.info('FileList', 'Transformierte Datei gelöscht', {
              transformedId: fileGroup.transformed.id,
              transformedName: fileGroup.transformed.metadata.name
            });
          } catch (error) {
            FileLogger.error('FileList', 'Fehler beim Löschen der transformierten Datei', error);
            toast.warning("Hinweis", {
              description: "Die transformierte Datei konnte nicht gelöscht werden"
            });
          }
        }

        // Lösche die Basis-Datei
        await provider.deleteItem(itemToDelete.id);
        toast.success("Dateien gelöscht", {
          description: `${itemToDelete.metadata.name} und zugehörige Dateien wurden gelöscht.`
        });
      } else {
        // Dies ist eine abhängige Datei oder keine Gruppe - nur diese Datei löschen
        await provider.deleteItem(itemToDelete.id);
        toast.success("Datei gelöscht", {
          description: `${itemToDelete.metadata.name} wurde gelöscht.`
        });
      }

      // Aktualisiere die Dateiliste
      await handleRefresh();

      // Wenn die gelöschte Datei ausgewählt war, Auswahl aufheben
      setSelectedFile(null);
      
      // Aus der Batch-Auswahl entfernen
      setSelectedBatchItems(prev => prev.filter(i => i.item.id !== itemToDelete.id));

    } catch (error) {
      FileLogger.error('FileList', 'Fehler beim Löschen', error);
      toast.error("Fehler", {
        description: `Die Datei konnte nicht gelöscht werden: ${error instanceof Error ? error.message : 'Unbekannter Fehler'}`
      });
    }
  }, [provider, handleRefresh, fileGroups, setSelectedFile, setSelectedBatchItems]);

  const handleRename = React.useCallback(async (item: StorageItem, newName: string) => {
    if (!provider) {
      toast.error("Fehler", {
        description: "Storage Provider nicht verfügbar"
      });
      return;
    }

    try {
      // Finde die FileGroup für dieses Item
      const itemStem = getBaseName(item.metadata.name);
      const fileGroup = findFileGroup(fileGroups, itemStem);

      if (fileGroup && item.id === fileGroup.baseItem?.id) {
        // Dies ist die Basis-Datei - benenne auch abhängige Dateien um
        const oldStem = getBaseName(item.metadata.name);
        const newStem = getBaseName(newName);
        // Benenne die Basis-Datei um
        await provider.renameItem(item.id, newName);
        // Benenne alle Transkripte um, falls vorhanden
        if (fileGroup.transcriptFiles) {
          for (const transcript of fileGroup.transcriptFiles) {
            const transcriptName = transcript.metadata.name;
            const newTranscriptName = transcriptName.replace(oldStem, newStem);
            try {
              await provider.renameItem(transcript.id, newTranscriptName);
            } catch (error) {
              FileLogger.error('FileList', 'Fehler beim Umbenennen des Transkripts', error);
              toast.warning("Hinweis", {
                description: "Einige Transkripte konnten nicht umbenannt werden"
              });
            }
          }
        }
        // Benenne die transformierte Datei um, falls vorhanden
        if (fileGroup.transformed) {
          const transformedName = fileGroup.transformed.metadata.name;
          const newTransformedName = transformedName.replace(oldStem, newStem);
          try {
            await provider.renameItem(fileGroup.transformed.id, newTransformedName);
          } catch (error) {
            FileLogger.error('FileList', 'Fehler beim Umbenennen der transformierten Datei', error);
            toast.warning("Hinweis", {
              description: "Die transformierte Datei konnte nicht umbenannt werden"
            });
          }
        }
        toast.success("Dateien umbenannt", {
          description: `${item.metadata.name} und zugehörige Dateien wurden umbenannt.`
        });
      } else {
        // Dies ist eine abhängige Datei oder keine Gruppe - nur diese Datei umbenennen
        await provider.renameItem(item.id, newName);
        toast.success("Datei umbenannt", {
          description: `${item.metadata.name} wurde zu ${newName} umbenannt.`
        });
      }
      await handleRefresh();
    } catch (error) {
      FileLogger.error('FileList', 'Fehler beim Umbenennen', error);
      toast.error("Fehler", {
        description: `Die Datei konnte nicht umbenannt werden: ${error instanceof Error ? error.message : 'Unbekannter Fehler'}`
      });
      throw error;
    }
  }, [provider, handleRefresh, fileGroups]);

  const handleBatchTranscription = () => {
    if (selectedBatchItems.length > 0) {
      setTranscriptionDialogOpen(true);
    }
  };

  const handleBatchTransformation = () => {
    if (selectedTransformationItems.length > 0) {
      setTransformationDialogOpen(true);
    }
  };

  // Bulk-Löschung für ausgewählte Dateien (unabhängig von Batch/Transformation-Selektor)
  const handleBulkDelete = React.useCallback(async () => {
    if (!provider) return;
    const targets = [
      ...selectedBatchItems.map(x => x.item),
      ...selectedTransformationItems.map(x => x.item),
    ];
    if (targets.length === 0) return;
    const confirmMsg = targets.length === 1
      ? `"${targets[0].metadata.name}" wirklich löschen?`
      : `${targets.length} Dateien wirklich löschen?`;
    if (!window.confirm(confirmMsg)) return;

    try {
      const parentId = targets[0].parentId || 'root';
      for (const t of targets) {
        try { await provider.deleteItem(t.id); } catch (err) {
          FileLogger.error('FileList', 'Bulk Delete failed', { id: t.id, name: t.metadata.name, err });
        }
      }
      const refreshed = await refreshItems(parentId);
      setFolderItems(refreshed);
      setSelectedBatchItems([]);
      setSelectedTransformationItems([]);
    } catch (error) {
      FileLogger.error('FileList', 'Bulk Delete error', error);
    }
  }, [provider, selectedBatchItems, selectedTransformationItems, refreshItems, setFolderItems, setSelectedBatchItems, setSelectedTransformationItems]);

  // Intelligente Batch-Auswahl basierend auf Filter
  const handleSelectAll = useCallback((checked: boolean) => {
    const startTime = performance.now();
    if (checked) {
      // Verwende nur die Hauptdateien (baseItem) aus den FileGroups
      const mainItems = Array.from((fileGroups ?? new Map()).values())
        .map(group => group.baseItem)
        .filter((item): item is StorageItem => item !== undefined);
      const selectableItems = mainItems.filter(item => {
        try {
          const mediaType = getMediaType(item);
          // Je nach Filter unterschiedliche Dateien auswählen
          switch (currentCategoryFilter) {
            case 'media':
              return item.type === 'file' && (mediaType === 'audio' || mediaType === 'video');
            case 'text':
              return item.type === 'file' && mediaType === 'text';
            case 'documents':
              return item.type === 'file' && mediaType === 'document';
            default:
              // Bei 'all' alle Dateien auswählen, die für eine Operation geeignet sind
              return item.type === 'file' && (
                mediaType === 'audio' || 
                mediaType === 'video' || 
                mediaType === 'text' || 
                mediaType === 'document'
              );
          }
        } catch {
          return false;
        }
      });
      StateLogger.info('FileList', 'Selecting all items based on filter', {
        filter: currentCategoryFilter,
        totalItems: items.length,
        selectableCount: selectableItems.length,
        duration: `${(performance.now() - startTime).toFixed(2)}ms`
      });
      // Je nach Filter unterschiedliche Atome verwenden
      if (currentCategoryFilter === 'media') {
        setSelectedBatchItems(selectableItems.map(item => ({
          item,
          type: getMediaType(item)
        })));
      } else if (currentCategoryFilter === 'text') {
        setSelectedTransformationItems(selectableItems.map(item => ({
          item,
          type: getMediaType(item)
        })));
      } else {
        // Bei 'all' oder 'documents' beide Atome füllen
        const mediaItems = selectableItems.filter(item => {
          const mediaType = getMediaType(item);
          return mediaType === 'audio' || mediaType === 'video';
        });
        const textItems = selectableItems.filter(item => {
          const mediaType = getMediaType(item);
          return mediaType === 'text' || mediaType === 'document';
        });
        setSelectedBatchItems(mediaItems.map(item => ({
          item,
          type: getMediaType(item)
        })));
        setSelectedTransformationItems(textItems.map(item => ({
          item,
          type: getMediaType(item)
        })));
      }
    } else {
      StateLogger.info('FileList', 'Deselecting all items', {
        previouslySelected: selectedBatchItems.length + selectedTransformationItems.length,
        duration: `${(performance.now() - startTime).toFixed(2)}ms`
      });
      setSelectedBatchItems([]);
      setSelectedTransformationItems([]);
    }
  }, [fileGroups, currentCategoryFilter, setSelectedBatchItems, setSelectedTransformationItems, selectedBatchItems.length, selectedTransformationItems.length, items.length]);

  React.useEffect(() => {
    // Logging der Library-IDs - verzögert ausführen
    const timeoutId = setTimeout(() => {
      StateLogger.debug('FileList', 'Render', {
        currentLibraryId: currentLibrary?.id,
        activeLibraryIdAtom: activeLibraryId
      });
    }, 0);
    
    return () => clearTimeout(timeoutId);
  }, [currentLibrary, activeLibraryId]);

  // Entkoppelt: kein Render-Gate mehr basierend auf FileTree

  return (
    <div className="h-full flex flex-col">
      {/* Header - versteckt im compact mode */}
      {!compact && (
        <div className="border-b px-2 py-2 flex items-center justify-between bg-background sticky top-0 z-10">
          <div className="flex items-center gap-2">
            <Button
              variant="ghost"
              size="icon"
              className="h-8 w-8"
              onClick={handleRefresh}
              disabled={isRefreshing}
              title="Aktualisieren"
              aria-label="Aktualisieren"
            >
              <RefreshCw className={cn("h-4 w-4", isRefreshing && "animate-spin")} />
            </Button>

            {/* Dateikategorie-Filter (Icon-only Variante) */}
            <FileCategoryFilter iconOnly />

            {/* Batch-Actions als Icons */}
            {selectedBatchItems.length > 0 && (
              <Button size="icon" title="Transkribieren" aria-label="Transkribieren" onClick={handleBatchTranscription}>
                <ScrollText className="h-4 w-4" />
              </Button>
            )}
            {selectedTransformationItems.length > 0 && (
              <Button size="icon" variant="secondary" title="Transformieren" aria-label="Transformieren" onClick={handleBatchTransformation}>
                <Plus className="h-4 w-4" />
              </Button>
            )}
            {(selectedBatchItems.length + selectedTransformationItems.length) > 0 && (
              <Button size="icon" variant="destructive" title="Ausgewählte löschen" aria-label="Ausgewählte löschen" onClick={handleBulkDelete}>
                <Trash2 className="h-4 w-4" />
              </Button>
            )}
          </div>
        </div>
      )}

      {/* File List */}
      <div className="flex-1 overflow-auto">
        <div>
          {/* Table Header - versteckt im compact mode */}
          {!compact && (
            <div className="sticky top-0 bg-background border-b">
              <div className="grid grid-cols-[24px_24px_minmax(0,1fr)_56px_88px_auto] gap-2 px-4 py-2 text-sm font-medium text-muted-foreground">
                <div className="w-6 flex items-center justify-center">
                  <Checkbox
                    checked={isAllSelected}
                    onCheckedChange={handleSelectAll}
                    aria-label="Alle auswählen"
                  />
                </div>
                <div className="w-6" />
                <SortableHeaderCell
                  label="Name"
                  field="name"
                  currentSortField={sortField}
                  currentSortOrder={sortOrder}
                  onSort={handleSort}
                />
                <SortableHeaderCell
                  label="Größe"
                  field="size"
                  currentSortField={sortField}
                  currentSortOrder={sortOrder}
                  onSort={handleSort}
                />
                <SortableHeaderCell
                  label="Geändert"
                  field="date"
                  currentSortField={sortField}
                  currentSortOrder={sortOrder}
                  onSort={handleSort}
                />
                <div />
              </div>
            </div>
          )}

          {/* Folder Rows (oberhalb der Dateien, unabhängig von Datei-Gruppierung) */}
          {folders.length > 0 && (
            <div className="divide-y">
              {folders.map((folder) => (
                <div
                  key={folder.id}
                  role="button"
                  tabIndex={0}
                  onClick={() => navigateToFolder(folder.id)}
                  onKeyDown={(e) => {
                    if (e.key === 'Enter' || e.key === ' ') navigateToFolder(folder.id);
                  }}
                  className="w-full px-4 py-2 text-xs hover:bg-muted/50 grid grid-cols-[24px_24px_minmax(0,1fr)_56px_88px_auto] gap-2 items-center cursor-pointer"
                >
                  <div />
                  <FolderIcon className="h-4 w-4" />
                  <span className="text-left truncate select-none" title={folder.metadata.name}>{folder.metadata.name}</span>
                  <span className="text-muted-foreground" />
                  <span className="text-muted-foreground" />
                  <div />
                </div>
              ))}
            </div>
          )}

          {/* File Rows */}
          <div className="divide-y">
            {Array.from((fileGroups ?? new Map()).values())
              .map((group) => {
                // Zeige nur die Hauptdatei (baseItem) an
                const item = group.baseItem;
                if (!item) return null;
                // System-Unterordner-Id, wenn ein ".<basename>"-Folder existiert
                const systemFolder = systemFolderByBase.get(getBaseName(item.metadata.name));
                const systemFolderId = systemFolder?.id;
                return (
                  <FileRow
                    key={item.id}
                    item={item as StorageItem}
                    isSelected={isItemSelected(item)}
                    onSelect={() => handleSelect(item, group)}
                    onCreateTranscript={handleCreateTranscript}
                    onDelete={(e) => handleDeleteClick(e, item)}
                    fileGroup={group}
                    onSelectRelatedFile={handleSelectRelatedFile}
                    onRename={handleRename}
                    compact={compact}
                    systemFolderId={systemFolderId}
                  />
                );
              })}
          </div>
        </div>
      </div>
    </div>
  );
}); 
```

```typescriptreact
'use client';

import * as React from "react"
import { File, FileText, FileVideo, FileAudio, Plus, RefreshCw, ChevronUp, ChevronDown, Trash2, ScrollText, Folder as FolderIcon, Layers } from "lucide-react"
import { StorageItem } from "@/lib/storage/types"
import { cn } from "@/lib/utils"
import { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from "@/components/ui/tooltip"
import { useStorage } from "@/contexts/storage-context";
import { Button } from "@/components/ui/button";
import { useAtomValue, useAtom } from 'jotai';
import { jobStatusByItemIdAtom } from '@/atoms/job-status';
import { 
  activeLibraryIdAtom, 
  selectedFileAtom, 
  folderItemsAtom,
  sortedFilteredFilesAtom,
  sortFieldAtom,
  sortOrderAtom,
  selectedShadowTwinAtom
} from '@/atoms/library-atom';
import { toast } from "sonner";
import { Input } from "@/components/ui/input"
import {
  selectedBatchItemsAtom,
  transcriptionDialogOpenAtom,
  selectedTransformationItemsAtom,
  transformationDialogOpenAtom,
  getMediaType,
  fileCategoryFilterAtom,
} from '@/atoms/transcription-options';
import { Checkbox } from "@/components/ui/checkbox"
import { useMemo, useCallback } from "react"
import { FileLogger, StateLogger } from "@/lib/debug/logger"
import { FileCategoryFilter } from './file-category-filter';
import { useFolderNavigation } from "@/hooks/use-folder-navigation";

// Typen für Sortieroptionen
type SortField = 'type' | 'name' | 'size' | 'date';
type SortOrder = 'asc' | 'desc';

// Typ für gruppierte Dateien
interface FileGroup {
  baseItem?: StorageItem;
  transcriptFiles?: StorageItem[]; // NEU: alle Transkripte
  transformed?: StorageItem;
}

// Memoized file icon component
const FileIconComponent = React.memo(function FileIconComponent({ item }: { item: StorageItem }) {
  const mimeType = item.metadata.mimeType || '';
  if (!mimeType) return <File className="h-4 w-4" />;

  if (mimeType.startsWith('video/')) {
    return <FileVideo className="h-4 w-4" />;
  } else if (mimeType.startsWith('audio/')) {
    return <FileAudio className="h-4 w-4" />;
  } else if (mimeType.startsWith('text/')) {
    return <FileText className="h-4 w-4" />;
  }

  return <File className="h-4 w-4" />;
});

// Pure function for file size formatting
const formatFileSize = (size?: number): string => {
  if (!size) return '-';
  const units = ['B', 'KB', 'MB', 'GB'];
  let value = size;
  let unitIndex = 0;
  
  while (value >= 1024 && unitIndex < units.length - 1) {
    value /= 1024;
    unitIndex++;
  }
  
  return `${value.toFixed(1)} ${units[unitIndex]}`;
};

// Funktion zum Formatieren des Datums
const formatDate = (date?: Date): string => {
  if (!date) return '-';
  
  const options: Intl.DateTimeFormatOptions = { 
    year: '2-digit', 
    month: '2-digit', 
    day: '2-digit',
    hour: '2-digit',
    minute: '2-digit'
  };
  
  return new Date(date).toLocaleDateString('de-DE', options);
};

// Entfernt: getFileStem Funktion war unbenutzt

// Sortierbare Kopfzelle Komponente
const SortableHeaderCell = React.memo(function SortableHeaderCell({
  label,
  field,
  currentSortField,
  currentSortOrder,
  onSort
}: {
  label: string,
  field: SortField,
  currentSortField: SortField,
  currentSortOrder: SortOrder,
  onSort: (field: SortField) => void
}) {
  const isActive = currentSortField === field;
  
  return (
    <button 
      onClick={() => onSort(field)}
      className="flex items-center gap-1 hover:text-foreground"
    >
      <span>{label}</span>
      {isActive && (
        currentSortOrder === 'asc' 
          ? <ChevronUp className="h-3 w-3" /> 
          : <ChevronDown className="h-3 w-3" />
      )}
    </button>
  );
});

interface FileRowProps {
  item: StorageItem;
  isSelected: boolean;
  isActive?: boolean;
  onSelect: () => void;
  onCreateTranscript: (e: React.MouseEvent) => void;
  onDelete: (e: React.MouseEvent<HTMLButtonElement>, item: StorageItem) => void;
  fileGroup?: FileGroup;
  onSelectRelatedFile?: (file: StorageItem) => void;
  onRename?: (item: StorageItem, newName: string) => Promise<void>;
  compact?: boolean;
  systemFolderId?: string;
}

const FileRow = React.memo(function FileRow({ 
  item, 
  isSelected, 
  isActive = false,
  onSelect,
  onCreateTranscript,
  onDelete,
  fileGroup,
  onSelectRelatedFile,
  onRename,
  compact = false,
  systemFolderId
}: FileRowProps) {
  const navigateToFolder = useFolderNavigation();
  const [isEditing, setIsEditing] = React.useState(false);
  const [editName, setEditName] = React.useState(item.metadata.name);
  const inputRef = React.useRef<HTMLInputElement>(null);
  const longPressTimerRef = React.useRef<NodeJS.Timeout | null>(null);
  const lastClickTimeRef = React.useRef<number>(0);
  
  // Zusätzliche Validierung der Metadaten
  const metadata = React.useMemo(() => ({
    name: item.metadata?.name || 'Unbekannte Datei',
    size: typeof item.metadata?.size === 'number' ? item.metadata.size : 0,
    mimeType: item.metadata?.mimeType || '',
    hasTranscript: !!item.metadata?.hasTranscript || (fileGroup?.transcriptFiles && fileGroup.transcriptFiles.length > 0),
    modifiedAt: item.metadata?.modifiedAt
  }), [item.metadata, fileGroup]);

  const isTranscribable = React.useMemo(() => {
    const mimeType = metadata.mimeType.toLowerCase();
    const extension = metadata.name.split('.').pop()?.toLowerCase();

    return (
      mimeType.startsWith('audio/') ||
      mimeType.startsWith('video/') ||
      extension === 'pdf' ||
      mimeType === 'application/pdf'
    );
  }, [metadata.mimeType, metadata.name]);

  // Memoize the click handler
  const handleClick = React.useCallback(() => {
    if (!isEditing) {
      onSelect();
    }
  }, [onSelect, isEditing]);

  // Memoize the keydown handler
  const handleKeyDown = React.useCallback((e: React.KeyboardEvent) => {
    if (!isEditing && (e.key === 'Enter' || e.key === ' ')) {
      onSelect();
    }
  }, [onSelect, isEditing]);

  // Handler für Transkript-Icon Click
  const handleTranscriptClick = React.useCallback((e: React.MouseEvent) => {
    e.stopPropagation();
    if (fileGroup?.transcriptFiles && onSelectRelatedFile) {
      onSelectRelatedFile(fileGroup.transcriptFiles[0]); // Nur das erste Transkript anzeigen
    }
  }, [fileGroup, onSelectRelatedFile]);

  // Handler für Transformierte-Datei-Icon Click
  const handleTransformedClick = React.useCallback((e: React.MouseEvent) => {
    e.stopPropagation();
    if (fileGroup?.transformed && onSelectRelatedFile) {
      onSelectRelatedFile(fileGroup.transformed);
    }
  }, [fileGroup, onSelectRelatedFile]);

  // Starte Rename-Modus
  const startRename = React.useCallback(() => {
    if (onRename) {
      // Prüfe ob dies eine abhängige Datei ist
      if (fileGroup && (
        (fileGroup.transcriptFiles && fileGroup.transcriptFiles.length > 0 && fileGroup.transcriptFiles[0]?.id === item.id) ||
        (fileGroup.transformed && item.id === fileGroup.transformed.id)
      )) {
        // Dies ist eine abhängige Datei - zeige Hinweis
        toast.info("Hinweis", {
          description: "Bitte benennen Sie die Haupt-Datei um. Abhängige Dateien werden automatisch mit umbenannt."
        });
        return;
      }
      
      setIsEditing(true);
      setEditName(item.metadata.name);
    }
  }, [onRename, item, fileGroup]);

  // Handler für Dateinamen-Click (Doppelklick-Erkennung)
  const handleNameClick = React.useCallback((e: React.MouseEvent) => {
    e.stopPropagation();
    
    const currentTime = Date.now();
    const timeSinceLastClick = currentTime - lastClickTimeRef.current;
    
    if (timeSinceLastClick < 300) {
      // Doppelklick erkannt
      startRename();
    } else {
      // Erster Klick - wähle die Datei aus
      onSelect();
    }
    
    lastClickTimeRef.current = currentTime;
  }, [startRename, onSelect]);

  // Handler für Long-Press (Touch-Geräte)
  const handleTouchStart = React.useCallback((e: React.TouchEvent) => {
    e.stopPropagation();
    
    // Starte Long-Press Timer
    longPressTimerRef.current = setTimeout(() => {
      startRename();
    }, 500); // 500ms für Long-Press
  }, [startRename]);

  const handleTouchEnd = React.useCallback((e: React.TouchEvent) => {
    e.stopPropagation();
    
    // Lösche Long-Press Timer
    if (longPressTimerRef.current) {
      clearTimeout(longPressTimerRef.current);
      longPressTimerRef.current = null;
    }
  }, []);

  const handleTouchMove = React.useCallback(() => {
    // Bei Bewegung Long-Press abbrechen
    if (longPressTimerRef.current) {
      clearTimeout(longPressTimerRef.current);
      longPressTimerRef.current = null;
    }
  }, []);

  // Cleanup Timer bei Unmount
  React.useEffect(() => {
    return () => {
      if (longPressTimerRef.current) {
        clearTimeout(longPressTimerRef.current);
      }
    };
  }, []);

  // Handler für Rename-Submit
  const handleRenameSubmit = React.useCallback(async () => {
    if (onRename && editName.trim() && editName !== item.metadata.name) {
      try {
        await onRename(item, editName.trim());
      } catch (error) {
        FileLogger.error('FileRow', 'Fehler beim Umbenennen', error);
        // Bei Fehler den ursprünglichen Namen wiederherstellen
        setEditName(item.metadata.name);
      }
    }
    setIsEditing(false);
  }, [onRename, editName, item]);

  // Handler für Rename-Cancel
  const handleRenameCancel = React.useCallback(() => {
    setEditName(item.metadata.name);
    setIsEditing(false);
  }, [item.metadata.name]);

  // Handler für Input-Änderungen
  const handleInputChange = React.useCallback((e: React.ChangeEvent<HTMLInputElement>) => {
    setEditName(e.target.value);
  }, []);

  // Handler für Input-Keydown
  const handleInputKeyDown = React.useCallback((e: React.KeyboardEvent<HTMLInputElement>) => {
    e.stopPropagation();
    if (e.key === 'Enter') {
      handleRenameSubmit();
    } else if (e.key === 'Escape') {
      handleRenameCancel();
    }
  }, [handleRenameSubmit, handleRenameCancel]);

  // Focus Input wenn Edit-Modus aktiviert wird
  React.useEffect(() => {
    if (isEditing && inputRef.current) {
      inputRef.current.focus();
      inputRef.current.select();
    }
  }, [isEditing]);

  // Handler für Drag Start
  const handleDragStart = React.useCallback((e: React.DragEvent) => {
    // Sammle alle Dateien der Gruppe, die verschoben werden sollen
    const itemsToMove = [];
    
    // Füge das aktuelle Item hinzu
    itemsToMove.push({
      itemId: item.id,
      itemName: item.metadata.name,
      itemType: item.type,
      parentId: item.parentId
    });
    
    // Wenn es eine FileGroup gibt, füge auch die zugehörigen Dateien hinzu
    if (fileGroup) {
      // Prüfe ob das aktuelle Item die Basis-Datei ist
      if (item.id === fileGroup.baseItem?.id) {
        // Füge Transkripte hinzu, falls vorhanden
        if (fileGroup.transcriptFiles && fileGroup.transcriptFiles.length > 0) {
          fileGroup.transcriptFiles.forEach(transcript => {
            itemsToMove.push({
              itemId: transcript.id,
              itemName: transcript.metadata.name,
              itemType: transcript.type,
              parentId: transcript.parentId
            });
          });
        }
        
        // Füge transformierte Datei hinzu, falls vorhanden
        if (fileGroup.transformed) {
          itemsToMove.push({
            itemId: fileGroup.transformed.id,
            itemName: fileGroup.transformed.metadata.name,
            itemType: fileGroup.transformed.type,
            parentId: fileGroup.transformed.parentId
          });
        }
      }
    }
    
    // Setze die Drag-Daten
    e.dataTransfer.effectAllowed = 'move';
    e.dataTransfer.setData('application/json', JSON.stringify({
      items: itemsToMove,
      isFileGroup: itemsToMove.length > 1
    }));
    
    // Visuelles Feedback
    if (e.currentTarget instanceof HTMLElement) {
      e.currentTarget.style.opacity = '0.5';
    }
  }, [item, fileGroup]);

  // Handler für Drag End
  const handleDragEnd = React.useCallback((e: React.DragEvent) => {
    // Stelle Opacity wieder her
    if (e.currentTarget instanceof HTMLElement) {
      e.currentTarget.style.opacity = '1';
    }
  }, []);

  const [selectedBatchItems, setSelectedBatchItems] = useAtom(selectedBatchItemsAtom);
  const [selectedTransformationItems, setSelectedTransformationItems] = useAtom(selectedTransformationItemsAtom);
  
  // Prüfe ob das Item in einem der beiden Atome ausgewählt ist
  const isInBatch = selectedBatchItems.some(batchItem => batchItem.item.id === item.id);
  const isInTransformation = selectedTransformationItems.some(transformationItem => transformationItem.item.id === item.id);
  const isInAnyBatch = isInBatch || isInTransformation;

  // Handler für Checkbox-Änderungen
  const handleCheckboxChange = React.useCallback((checked: boolean) => {
    const mediaType = getMediaType(item);
    
    if (mediaType === 'audio' || mediaType === 'video') {
      // Für Audio/Video: Transcription-Atom verwenden
      if (checked) {
        setSelectedBatchItems([...selectedBatchItems, {
          item,
          type: mediaType
        }]);
      } else {
        setSelectedBatchItems(selectedBatchItems.filter(i => i.item.id !== item.id));
      }
    } else if (mediaType === 'text' || mediaType === 'document') {
      // Für Text/Dokumente: Transformation-Atom verwenden
      if (checked) {
        setSelectedTransformationItems([...selectedTransformationItems, {
          item,
          type: mediaType
        }]);
      } else {
        setSelectedTransformationItems(selectedTransformationItems.filter(i => i.item.id !== item.id));
      }
    }
  }, [item, selectedBatchItems, selectedTransformationItems, setSelectedBatchItems, setSelectedTransformationItems]);

  React.useEffect(() => {
    if (fileGroup) {
      FileLogger.debug('FileRow', 'Transkripte für Zeile', {
        baseItem: fileGroup.baseItem?.metadata.name,
        transcripts: fileGroup.transcriptFiles?.map(t => t.metadata.name)
      });
    }
  }, [fileGroup]);

  // Zentraler Jobstatus (muss vor möglichen early-returns stehen, um Hook-Order zu garantieren)
  const jobStatusMap = useAtomValue(jobStatusByItemIdAtom);
  const jobStatus = jobStatusMap[item.id];
  const jobStatusIcon = jobStatus ? (
    <span title={jobStatus} className={cn('inline-block h-3 w-3 rounded-full',
      jobStatus === 'queued' && 'bg-blue-600',
      jobStatus === 'running' && 'bg-yellow-600',
      jobStatus === 'completed' && 'bg-green-600',
      jobStatus === 'failed' && 'bg-red-600'
    )} aria-label={`job-${jobStatus}`} />
  ) : null;

  // Compact-Modus: vereinfachte Darstellung
  if (compact) {
    return (
      <div
        role="button"
        tabIndex={0}
        onClick={handleClick}
        onKeyDown={handleKeyDown}
        className={cn(
          "w-full px-2 py-1 text-sm hover:bg-muted/50 flex items-center gap-2 cursor-pointer",
          isSelected && "bg-muted",
          isActive && "bg-primary/10 border-l-2 border-primary"
        )}
      >
        <FileIconComponent item={item} />
        <span className={cn("truncate flex-1", isActive && "font-medium") } title={metadata.name}>
          {metadata.name}
        </span>
        {/* Shadow-Twin-Symbole im compact mode */}
        {fileGroup?.transcriptFiles && fileGroup.transcriptFiles.length > 0 && (
          <Button
            variant="ghost"
            size="icon"
            className="h-4 w-4 p-0 hover:bg-muted text-muted-foreground hover:text-foreground"
            onClick={handleTranscriptClick}
          >
            <ScrollText className="h-3 w-3" />
          </Button>
        )}
      </div>
    );
  }

  return (
    <div
      role="button"
      tabIndex={0}
      onClick={handleClick}
      onKeyDown={handleKeyDown}
      onTouchStart={handleTouchStart}
      onTouchEnd={handleTouchEnd}
      onTouchMove={handleTouchMove}
      draggable={!isEditing}
      onDragStart={handleDragStart}
      onDragEnd={handleDragEnd}
      className={cn(
        "w-full px-4 py-2 text-xs hover:bg-muted/50 grid grid-cols-[24px_24px_minmax(0,1fr)_56px_88px_auto] gap-2 items-center cursor-move",
        isSelected && "bg-muted"
      )}
    >
      <div className="w-6 flex items-center justify-center">
        <Checkbox
          checked={isInAnyBatch}
          onCheckedChange={handleCheckboxChange}
          onClick={(e) => e.stopPropagation()}
        />
      </div>
      <FileIconComponent item={item} />
      {isEditing ? (
        <Input
          ref={inputRef}
          value={editName}
          onChange={handleInputChange}
          onKeyDown={handleInputKeyDown}
          onBlur={handleRenameSubmit}
          onClick={(e) => e.stopPropagation()}
          className="h-6 px-1 py-0 text-xs"
        />
      ) : (
        <span 
          className="text-left truncate cursor-pointer hover:text-primary select-none"
          onClick={handleNameClick}
          onTouchStart={handleTouchStart}
          onTouchEnd={handleTouchEnd}
          onTouchMove={handleTouchMove}
          title={metadata.name}
        >
          {metadata.name}
        </span>
      )}
      <span className="text-muted-foreground tabular-nums text-[10px]">
        {formatFileSize(metadata.size)}
      </span>
      <span className="text-muted-foreground tabular-nums text-[10px]">
        {formatDate(metadata.modifiedAt)}
      </span>
      <div className="flex items-center justify-start gap-1">
        {jobStatusIcon}
        {/* System-Unterordner (z. B. extrahierte Seiten) */}
        {systemFolderId && (
          <TooltipProvider>
            <Tooltip>
              <TooltipTrigger asChild>
                <Button
                  variant="ghost"
                  size="icon"
                  className="h-6 w-6 p-0 hover:bg-muted"
                  onClick={(e) => {
                    e.stopPropagation();
                    navigateToFolder(systemFolderId);
                  }}
                >
                  <Layers className="h-4 w-4 text-violet-500" />
                </Button>
              </TooltipTrigger>
              <TooltipContent>
                <p>Seiten-Ordner öffnen</p>
              </TooltipContent>
            </Tooltip>
          </TooltipProvider>
        )}
        {/* Zeige Icons für alle vorhandenen Transkripte */}
        {fileGroup?.transcriptFiles && fileGroup.transcriptFiles.length > 0 && fileGroup.transcriptFiles.map((transcript) => (
          <TooltipProvider key={transcript.id}>
            <Tooltip>
              <TooltipTrigger asChild>
                <Button
                  variant="ghost"
                  size="icon"
                  className="h-6 w-6 p-0 hover:bg-muted"
                  onClick={(e) => {
                    e.stopPropagation();
                    if (onSelectRelatedFile) onSelectRelatedFile(transcript);
                  }}
                >
                  <FileText className="h-4 w-4 text-blue-500" />
                </Button>
              </TooltipTrigger>
              <TooltipContent>
                <p>Transkript anzeigen: {transcript.metadata.name}</p>
              </TooltipContent>
            </Tooltip>
          </TooltipProvider>
        ))}
        {/* Plus-Symbol nur anzeigen, wenn kein Transkript vorhanden und transkribierbar */}
        {(!fileGroup?.transcriptFiles || fileGroup.transcriptFiles.length === 0) && isTranscribable && !metadata.hasTranscript ? (
          <TooltipProvider>
            <Tooltip>
              <TooltipTrigger asChild>
                <div 
                  role="button"
                  tabIndex={0}
                  className="h-6 w-6 p-0 inline-flex items-center justify-center hover:bg-muted rounded-sm"
                  onClick={onCreateTranscript}
                  onKeyDown={(e) => {
                    if (e.key === 'Enter' || e.key === ' ') {
                      e.stopPropagation();
                      onCreateTranscript(e as unknown as React.MouseEvent<HTMLDivElement>);
                    }
                  }}
                >
                  <Plus className="h-4 w-4" />
                </div>
              </TooltipTrigger>
              <TooltipContent>
                <p>Transkript erstellen</p>
              </TooltipContent>
            </Tooltip>
          </TooltipProvider>
        ) : null}
        {/* Icon für transformierte Datei */}
        {fileGroup?.transformed && (
          <TooltipProvider>
            <Tooltip>
              <TooltipTrigger asChild>
                <Button
                  variant="ghost"
                  size="icon"
                  className="h-6 w-6 p-0 hover:bg-muted"
                  onClick={handleTransformedClick}
                >
                  <ScrollText className="h-4 w-4 text-green-500" />
                </Button>
              </TooltipTrigger>
              <TooltipContent>
                <p>Transformierte Datei anzeigen</p>
              </TooltipContent>
            </Tooltip>
          </TooltipProvider>
        )}
        {/* Delete direkt neben Dokument-Icons */}
        <TooltipProvider>
          <Tooltip>
            <TooltipTrigger asChild>
              <Button
                variant="ghost"
                size="icon"
                className="h-6 w-6 p-0 hover:bg-destructive/10 hover:text-destructive"
                onClick={(e) => onDelete(e as React.MouseEvent<HTMLButtonElement>, item)}
              >
                <Trash2 className="h-4 w-4" />
              </Button>
            </TooltipTrigger>
            <TooltipContent>
              <p>Datei löschen</p>
            </TooltipContent>
          </Tooltip>
        </TooltipProvider>
      </div>
      <div />
    </div>
  );
});

interface FileListProps {
  compact?: boolean;
}

export const FileList = React.memo(function FileList({ compact = false }: FileListProps): JSX.Element {
  const { provider, refreshItems, currentLibrary } = useStorage();
  const activeLibraryId = useAtomValue(activeLibraryIdAtom);
  const [isRefreshing, setIsRefreshing] = React.useState(false);
  // Mobile-Flag wurde entfernt, FileList lädt unabhängig vom View
  const [selectedBatchItems, setSelectedBatchItems] = useAtom(selectedBatchItemsAtom);
  const [selectedTransformationItems, setSelectedTransformationItems] = useAtom(selectedTransformationItemsAtom);
  const [, setTranscriptionDialogOpen] = useAtom(transcriptionDialogOpenAtom);
  const [, setTransformationDialogOpen] = useAtom(transformationDialogOpenAtom);
  const [isInitialized, setIsInitialized] = React.useState(false);
  const initializationTimeoutRef = React.useRef<NodeJS.Timeout | null>(null);
  // Entkoppelt: Kein Warten mehr auf FileTree-Status
  const [activeFile, setSelectedFile] = useAtom(selectedFileAtom);
  const [, setFolderItems] = useAtom(folderItemsAtom);
  const currentCategoryFilter = useAtomValue(fileCategoryFilterAtom);
  const allItemsInFolder = useAtomValue(folderItemsAtom);
  const navigateToFolder = useFolderNavigation();

  // Kein mobiles Flag mehr notwendig

  const folders = useMemo(() => {
    const items = allItemsInFolder ?? [];
    // Verstecke dot-Verzeichnisse generell in der Liste
    return items.filter(item => item.type === 'folder' && !item.metadata.name.startsWith('.'));
  }, [allItemsInFolder]);

  // Hilfsfunktion zum Finden einer FileGroup in der Map
  const findFileGroup = (map: Map<string, FileGroup>, stem: string): FileGroup | undefined => {
    return Array.from((map ?? new Map()).values()).find(group => 
      group.baseItem && getBaseName(group.baseItem.metadata.name) === stem
    );
  };

  // NEU: Atome für Sortierung und Filter
  const items = useAtomValue(sortedFilteredFilesAtom);
  const [sortField, setSortField] = useAtom(sortFieldAtom);
  const [sortOrder, setSortOrder] = useAtom(sortOrderAtom);
  
  // Review-Mode-Atoms
  const [, setSelectedShadowTwin] = useAtom(selectedShadowTwinAtom);

  // handleSort nutzt jetzt Atome
  const handleSort = React.useCallback((field: SortField) => {
    if (field === sortField) setSortOrder(sortOrder === 'asc' ? 'desc' : 'asc');
    else {
      setSortField(field);
      setSortOrder('asc');
    }
  }, [sortField, sortOrder, setSortField, setSortOrder]);

  // Initialisierung - nur auf Provider und Mobile-Flag achten
  React.useEffect(() => {
    if (!provider) {
      FileLogger.info('FileList', 'Waiting for provider');
      return;
    }

    const initialize = async () => {
      if (isInitialized) {
        FileLogger.debug('FileList', 'Already initialized');
        return;
      }

      FileLogger.info('FileList', 'Starting initialization');

      try {
        FileLogger.info('FileList', 'Initialization complete');
        setIsInitialized(true);
      } catch (error) {
        FileLogger.error('FileList', 'Error initializing FileList', error);
      }
    };

    initialize();

    const timeoutRef = initializationTimeoutRef.current;
    return () => {
      if (timeoutRef) clearTimeout(timeoutRef);
    };
  }, [provider, isInitialized]);

  // NEU: Reagieren auf Bibliothekswechsel
  const prevLibraryIdRef = React.useRef<string | null>(null);
  React.useEffect(() => {
    StateLogger.debug('FileList', 'Render', {
      currentLibraryId: activeLibraryId,
      activeLibraryIdAtom: activeLibraryId
    });

    // Nur bei tatsächlichem Bibliothekswechsel zurücksetzen
    if (prevLibraryIdRef.current !== null && prevLibraryIdRef.current !== activeLibraryId) {
      setIsInitialized(false);
      setSelectedFile(null);
      setFolderItems([]);
      setSelectedBatchItems([]);
      setSelectedTransformationItems([]);
      setSelectedShadowTwin(null);
      StateLogger.info('FileList', 'Bibliothek gewechselt - State zurückgesetzt', {
        libraryId: activeLibraryId
      });
    }
    prevLibraryIdRef.current = activeLibraryId;
  }, [activeLibraryId, setSelectedFile, setFolderItems, setSelectedBatchItems, setSelectedTransformationItems, setSelectedShadowTwin]);

  // Vereinfachte Funktion zum Extrahieren des Basisnamens (ohne Endung, auch für Binärdateien)
  function getBaseName(name: string): string {
    // ShadowTwin: .de.md, .en.md, etc.
    const shadowTwinMatch = name.match(/^(.*)\.(de|en|fr|es|it)\.md$/);
    if (shadowTwinMatch) return shadowTwinMatch[1];
    // Sonst: alles vor der letzten Endung
    const lastDot = name.lastIndexOf('.');
    if (lastDot === -1) return name;
    return name.substring(0, lastDot);
  }

  // Prüft ob eine Datei ein ShadowTwin ist (Markdown mit Sprachkürzel)
  function isShadowTwin(name: string): boolean {
    // Pattern: name.de.md, name.en.md, etc.
    const shadowTwinPattern = /^(.+)\.(de|en|fr|es|it)\.md$/;
    return shadowTwinPattern.test(name);
  }

  // Gruppiere die Dateien nach Basename
  const fileGroups = useMemo(() => {
    if (!items) return new Map<string, FileGroup>();

    // Schritt 1: Gruppiere alle Dateien nach Basename
    const groupsMap = new Map<string, StorageItem[]>();
    for (const item of items) {
      if (item.type !== 'file') continue;
      const base = getBaseName(item.metadata.name);
      if (!groupsMap.has(base)) groupsMap.set(base, []);
      groupsMap.get(base)!.push(item);
    }

    // Schritt 2: Erstelle FileGroups
    const fileGroupsMap = new Map<string, FileGroup>();
    for (const [base, groupItems] of Array.from(groupsMap.entries())) {
      // Finde Hauptdatei (erste Nicht-ShadowTwin-Datei)
      const mainFile = groupItems.find((item) => !isShadowTwin(item.metadata.name));
      // Finde alle ShadowTwins
      const shadowTwins = groupItems.filter((item) => isShadowTwin(item.metadata.name));
      if (mainFile) {
        fileGroupsMap.set(base, {
          baseItem: mainFile,
          transcriptFiles: shadowTwins.length > 0 ? shadowTwins : undefined,
          transformed: undefined
        });
      } else {
        // Keine Hauptdatei: Jede ShadowTwin einzeln anzeigen
        for (const twin of shadowTwins) {
          fileGroupsMap.set(`${base}__shadow_${twin.id}`, {
            baseItem: twin,
            transcriptFiles: undefined,
            transformed: undefined
          });
        }
      }
    }
    // Debug-Logging für Gruppierung
    FileLogger.debug('FileList', 'Gruppierung Ergebnis (Basename, alle Endungen)', {
      groups: Array.from(fileGroupsMap.entries()).map(([base, group]) => ({
        base,
        baseItem: group.baseItem?.metadata.name,
        transcripts: group.transcriptFiles?.map(t => t.metadata.name)
      }))
    });
    return fileGroupsMap;
  }, [items]);

  // Mapping: Basename -> dot-Systemordner (z. B. ".<basename>")
  const systemFolderByBase = useMemo(() => {
    const map = new Map<string, StorageItem>();
    const items = allItemsInFolder ?? [];
    for (const it of items) {
      if (it.type !== 'folder') continue;
      const name = it.metadata.name;
      if (!name.startsWith('.')) continue;
      const base = name.slice(1);
      if (base) map.set(base, it);
    }
    return map;
  }, [allItemsInFolder]);

  // Berechne, ob alle Dateien ausgewählt sind
  const isAllSelected = useMemo(() => {
    if (!fileGroups || !fileGroups.size) return false;
    // Verwende nur die Hauptdateien (baseItem) aus den FileGroups
    const mainItems = Array.from((fileGroups ?? new Map()).values())
      .map(group => group.baseItem)
      .filter((item): item is StorageItem => item !== undefined);
    // Je nach Filter unterschiedliche Dateien zählen
    let selectableItems: StorageItem[] = [];
    switch (currentCategoryFilter) {
      case 'media':
        selectableItems = mainItems.filter(item => {
          try {
            const mediaType = getMediaType(item);
            return item.type === 'file' && (mediaType === 'audio' || mediaType === 'video');
          } catch {
            return false;
          }
        });
        return selectableItems.length > 0 && selectedBatchItems.length === selectableItems.length;
      case 'text':
        selectableItems = mainItems.filter(item => {
          try {
            const mediaType = getMediaType(item);
            return item.type === 'file' && mediaType === 'text';
          } catch {
            return false;
          }
        });
        return selectableItems.length > 0 && selectedTransformationItems.length === selectableItems.length;
      case 'documents':
        selectableItems = mainItems.filter(item => {
          try {
            const mediaType = getMediaType(item);
            return item.type === 'file' && mediaType === 'document';
          } catch {
            return false;
          }
        });
        return selectableItems.length > 0 && selectedTransformationItems.length === selectableItems.length;
      default:
        // Bei 'all' prüfen ob alle verfügbaren Dateien ausgewählt sind
        const mediaItems = mainItems.filter(item => {
          try {
            const mediaType = getMediaType(item);
            return item.type === 'file' && (mediaType === 'audio' || mediaType === 'video');
          } catch {
            return false;
          }
        });
        const textItems = mainItems.filter(item => {
          try {
            const mediaType = getMediaType(item);
            return item.type === 'file' && (mediaType === 'text' || mediaType === 'document');
          } catch {
            return false;
          }
        });
        const allMediaSelected = mediaItems.length === 0 || selectedBatchItems.length === mediaItems.length;
        const allTextSelected = textItems.length === 0 || selectedTransformationItems.length === textItems.length;
        return allMediaSelected && allTextSelected;
    }
  }, [fileGroups, selectedBatchItems, selectedTransformationItems, currentCategoryFilter]);
  
  // Erweiterte handleSelect Funktion für Review-Mode
  const handleSelect = useCallback((item: StorageItem, group?: FileGroup) => {
    FileLogger.debug('FileList', 'handleSelect aufgerufen', {
      itemId: item.id,
      itemName: item.metadata.name,
      groupBase: group?.baseItem?.metadata.name,
      transcriptCount: group?.transcriptFiles?.length ?? 0,
      hasTranscripts: !!(group && group.transcriptFiles && group.transcriptFiles.length > 0)
    });
    
    // Nur die ausgewählte Datei setzen - Review-Modus wird über Toggle-Button gesteuert
    setSelectedFile(item);
    
    // Wenn wir im Review-Modus sind und eine Basis-Datei mit Shadow-Twin ausgewählt wird,
    // dann automatisch das Shadow-Twin setzen
    if (group && group.transcriptFiles && group.transcriptFiles.length > 0) {
      const shadowTwin = group.transcriptFiles[0];
      FileLogger.info('FileList', 'Basis-Datei mit Shadow-Twin ausgewählt', {
        twinId: shadowTwin.id,
        twinName: shadowTwin.metadata.name,
        baseFileId: item.id,
        baseFileName: item.metadata.name
      });
      setSelectedShadowTwin(shadowTwin);
    } else {
      FileLogger.info('FileList', 'Datei ohne Shadow-Twin ausgewählt', {
        itemId: item.id,
        itemName: item.metadata.name,
        groupExists: !!group,
        transcriptCount: group?.transcriptFiles?.length ?? 0
      });
      setSelectedShadowTwin(null);
    }
  }, [setSelectedFile, setSelectedShadowTwin, findFileGroup]);
  
  // Erweiterte handleSelectRelatedFile Funktion für Review-Mode
  const handleSelectRelatedFile = useCallback((shadowTwin: StorageItem) => {
    StateLogger.info('FileList', 'Shadow-Twin ausgewählt', {
      shadowTwinId: shadowTwin.id,
      shadowTwinName: shadowTwin.metadata.name
    });
    
    // Setze das Shadow-Twin als ausgewählte Datei, damit es rechts angezeigt wird
    setSelectedFile(shadowTwin);
    setSelectedShadowTwin(null); // Kein zusätzliches Shadow-Twin im normalen Modus
  }, [setSelectedFile, setSelectedShadowTwin, findFileGroup]);

  // Aktualisierte handleRefresh Funktion
  const handleRefresh = useCallback(async () => {
    if (!items || items.length === 0) return;
    
    const parentId = items[0]?.parentId;
    if (!parentId) return;
    
    setIsRefreshing(true);
    
    try {
      const refreshedItems = await refreshItems(parentId);
      setFolderItems(refreshedItems);
    } catch (error) {
      FileLogger.error('FileList', 'Fehler beim Aktualisieren der Dateiliste', error);
    } finally {
      setIsRefreshing(false);
    }
  }, [items, refreshItems, setFolderItems]);

  const handleCreateTranscript = React.useCallback((e: React.MouseEvent) => {
    e.stopPropagation();
    FileLogger.info('FileList', 'Create transcript for', { fileName: 'TODO' });
    // TODO: Implement transcript creation
  }, []);

  // Entfernt: handleItemSelect war unbenutzt

  // Check if an item is selected (beide Atome prüfen)
  const isItemSelected = useCallback((item: StorageItem) => {
    const mediaType = getMediaType(item);
    if (mediaType === 'audio' || mediaType === 'video') {
      return selectedBatchItems.some(selected => selected.item.id === item.id);
    } else {
      return selectedTransformationItems.some(selected => selected.item.id === item.id);
    }
  }, [selectedBatchItems, selectedTransformationItems]);

  // Löschfunktion
  const handleDeleteClick = React.useCallback(async (e: React.MouseEvent<HTMLButtonElement>, itemToDelete: StorageItem) => {
    e.stopPropagation();
    
    if (!provider) {
      toast.error("Fehler", {
        description: "Storage Provider nicht verfügbar"
      });
      return;
    }

    try {
      // Finde die FileGroup für dieses Item
      const itemStem = getBaseName(itemToDelete.metadata.name);
      const fileGroup = findFileGroup(fileGroups, itemStem);

      // Bestätigungsnachricht vorbereiten
      let confirmMessage = `Möchten Sie "${itemToDelete.metadata.name}" wirklich löschen?`;
      if (fileGroup && itemToDelete.id === fileGroup.baseItem?.id) {
        if (fileGroup.transcriptFiles && fileGroup.transcriptFiles.length > 0 || fileGroup.transformed) {
          confirmMessage = `Möchten Sie "${itemToDelete.metadata.name}" und alle zugehörigen Dateien wirklich löschen?`;
        }
      }

      // Benutzer um Bestätigung bitten
      if (!window.confirm(confirmMessage)) {
        return;
      }

      if (fileGroup && itemToDelete.id === fileGroup.baseItem?.id) {
        // Dies ist die Basis-Datei - lösche auch abhängige Dateien
        // Lösche alle Transkripte, falls vorhanden
        if (fileGroup.transcriptFiles) {
          for (const transcript of fileGroup.transcriptFiles) {
            try {
              await provider.deleteItem(transcript.id);
              FileLogger.info('FileList', 'Transkript gelöscht', {
                transcriptId: transcript.id,
                transcriptName: transcript.metadata.name
              });
            } catch (error) {
              FileLogger.error('FileList', 'Fehler beim Löschen des Transkripts', error);
              toast.warning("Hinweis", {
                description: "Einige Transkripte konnten nicht gelöscht werden"
              });
            }
          }
        }

        // Lösche die transformierte Datei, falls vorhanden
        if (fileGroup.transformed) {
          try {
            await provider.deleteItem(fileGroup.transformed.id);
            FileLogger.info('FileList', 'Transformierte Datei gelöscht', {
              transformedId: fileGroup.transformed.id,
              transformedName: fileGroup.transformed.metadata.name
            });
          } catch (error) {
            FileLogger.error('FileList', 'Fehler beim Löschen der transformierten Datei', error);
            toast.warning("Hinweis", {
              description: "Die transformierte Datei konnte nicht gelöscht werden"
            });
          }
        }

        // Lösche die Basis-Datei
        await provider.deleteItem(itemToDelete.id);
        toast.success("Dateien gelöscht", {
          description: `${itemToDelete.metadata.name} und zugehörige Dateien wurden gelöscht.`
        });
      } else {
        // Dies ist eine abhängige Datei oder keine Gruppe - nur diese Datei löschen
        await provider.deleteItem(itemToDelete.id);
        toast.success("Datei gelöscht", {
          description: `${itemToDelete.metadata.name} wurde gelöscht.`
        });
      }

      // Aktualisiere die Dateiliste
      await handleRefresh();

      // Wenn die gelöschte Datei ausgewählt war, Auswahl aufheben
      setSelectedFile(null);
      
      // Aus der Batch-Auswahl entfernen
      setSelectedBatchItems(prev => prev.filter(i => i.item.id !== itemToDelete.id));

    } catch (error) {
      FileLogger.error('FileList', 'Fehler beim Löschen', error);
      toast.error("Fehler", {
        description: `Die Datei konnte nicht gelöscht werden: ${error instanceof Error ? error.message : 'Unbekannter Fehler'}`
      });
    }
  }, [provider, handleRefresh, fileGroups, setSelectedFile, setSelectedBatchItems]);

  const handleRename = React.useCallback(async (item: StorageItem, newName: string) => {
    if (!provider) {
      toast.error("Fehler", {
        description: "Storage Provider nicht verfügbar"
      });
      return;
    }

    try {
      // Finde die FileGroup für dieses Item
      const itemStem = getBaseName(item.metadata.name);
      const fileGroup = findFileGroup(fileGroups, itemStem);

      if (fileGroup && item.id === fileGroup.baseItem?.id) {
        // Dies ist die Basis-Datei - benenne auch abhängige Dateien um
        const oldStem = getBaseName(item.metadata.name);
        const newStem = getBaseName(newName);
        // Benenne die Basis-Datei um
        await provider.renameItem(item.id, newName);
        // Benenne alle Transkripte um, falls vorhanden
        if (fileGroup.transcriptFiles) {
          for (const transcript of fileGroup.transcriptFiles) {
            const transcriptName = transcript.metadata.name;
            const newTranscriptName = transcriptName.replace(oldStem, newStem);
            try {
              await provider.renameItem(transcript.id, newTranscriptName);
            } catch (error) {
              FileLogger.error('FileList', 'Fehler beim Umbenennen des Transkripts', error);
              toast.warning("Hinweis", {
                description: "Einige Transkripte konnten nicht umbenannt werden"
              });
            }
          }
        }
        // Benenne die transformierte Datei um, falls vorhanden
        if (fileGroup.transformed) {
          const transformedName = fileGroup.transformed.metadata.name;
          const newTransformedName = transformedName.replace(oldStem, newStem);
          try {
            await provider.renameItem(fileGroup.transformed.id, newTransformedName);
          } catch (error) {
            FileLogger.error('FileList', 'Fehler beim Umbenennen der transformierten Datei', error);
            toast.warning("Hinweis", {
              description: "Die transformierte Datei konnte nicht umbenannt werden"
            });
          }
        }
        toast.success("Dateien umbenannt", {
          description: `${item.metadata.name} und zugehörige Dateien wurden umbenannt.`
        });
      } else {
        // Dies ist eine abhängige Datei oder keine Gruppe - nur diese Datei umbenennen
        await provider.renameItem(item.id, newName);
        toast.success("Datei umbenannt", {
          description: `${item.metadata.name} wurde zu ${newName} umbenannt.`
        });
      }
      await handleRefresh();
    } catch (error) {
      FileLogger.error('FileList', 'Fehler beim Umbenennen', error);
      toast.error("Fehler", {
        description: `Die Datei konnte nicht umbenannt werden: ${error instanceof Error ? error.message : 'Unbekannter Fehler'}`
      });
      throw error;
    }
  }, [provider, handleRefresh, fileGroups]);

  const handleBatchTranscription = () => {
    if (selectedBatchItems.length > 0) {
      setTranscriptionDialogOpen(true);
    }
  };

  const handleBatchTransformation = () => {
    if (selectedTransformationItems.length > 0) {
      setTransformationDialogOpen(true);
    }
  };

  // Bulk-Löschung für ausgewählte Dateien (unabhängig von Batch/Transformation-Selektor)
  const handleBulkDelete = React.useCallback(async () => {
    if (!provider) return;
    const targets = [
      ...selectedBatchItems.map(x => x.item),
      ...selectedTransformationItems.map(x => x.item),
    ];
    if (targets.length === 0) return;
    const confirmMsg = targets.length === 1
      ? `"${targets[0].metadata.name}" wirklich löschen?`
      : `${targets.length} Dateien wirklich löschen?`;
    if (!window.confirm(confirmMsg)) return;

    try {
      const parentId = targets[0].parentId || 'root';
      for (const t of targets) {
        try { await provider.deleteItem(t.id); } catch (err) {
          FileLogger.error('FileList', 'Bulk Delete failed', { id: t.id, name: t.metadata.name, err });
        }
      }
      const refreshed = await refreshItems(parentId);
      setFolderItems(refreshed);
      setSelectedBatchItems([]);
      setSelectedTransformationItems([]);
    } catch (error) {
      FileLogger.error('FileList', 'Bulk Delete error', error);
    }
  }, [provider, selectedBatchItems, selectedTransformationItems, refreshItems, setFolderItems, setSelectedBatchItems, setSelectedTransformationItems]);

  // Intelligente Batch-Auswahl basierend auf Filter
  const handleSelectAll = useCallback((checked: boolean) => {
    const startTime = performance.now();
    if (checked) {
      // Verwende nur die Hauptdateien (baseItem) aus den FileGroups
      const mainItems = Array.from((fileGroups ?? new Map()).values())
        .map(group => group.baseItem)
        .filter((item): item is StorageItem => item !== undefined);
      const selectableItems = mainItems.filter(item => {
        try {
          const mediaType = getMediaType(item);
          // Je nach Filter unterschiedliche Dateien auswählen
          switch (currentCategoryFilter) {
            case 'media':
              return item.type === 'file' && (mediaType === 'audio' || mediaType === 'video');
            case 'text':
              return item.type === 'file' && mediaType === 'text';
            case 'documents':
              return item.type === 'file' && mediaType === 'document';
            default:
              // Bei 'all' alle Dateien auswählen, die für eine Operation geeignet sind
              return item.type === 'file' && (
                mediaType === 'audio' || 
                mediaType === 'video' || 
                mediaType === 'text' || 
                mediaType === 'document'
              );
          }
        } catch {
          return false;
        }
      });
      StateLogger.info('FileList', 'Selecting all items based on filter', {
        filter: currentCategoryFilter,
        totalItems: items.length,
        selectableCount: selectableItems.length,
        duration: `${(performance.now() - startTime).toFixed(2)}ms`
      });
      // Je nach Filter unterschiedliche Atome verwenden
      if (currentCategoryFilter === 'media') {
        setSelectedBatchItems(selectableItems.map(item => ({
          item,
          type: getMediaType(item)
        })));
      } else if (currentCategoryFilter === 'text') {
        setSelectedTransformationItems(selectableItems.map(item => ({
          item,
          type: getMediaType(item)
        })));
      } else {
        // Bei 'all' oder 'documents' beide Atome füllen
        const mediaItems = selectableItems.filter(item => {
          const mediaType = getMediaType(item);
          return mediaType === 'audio' || mediaType === 'video';
        });
        const textItems = selectableItems.filter(item => {
          const mediaType = getMediaType(item);
          return mediaType === 'text' || mediaType === 'document';
        });
        setSelectedBatchItems(mediaItems.map(item => ({
          item,
          type: getMediaType(item)
        })));
        setSelectedTransformationItems(textItems.map(item => ({
          item,
          type: getMediaType(item)
        })));
      }
    } else {
      StateLogger.info('FileList', 'Deselecting all items', {
        previouslySelected: selectedBatchItems.length + selectedTransformationItems.length,
        duration: `${(performance.now() - startTime).toFixed(2)}ms`
      });
      setSelectedBatchItems([]);
      setSelectedTransformationItems([]);
    }
  }, [fileGroups, currentCategoryFilter, setSelectedBatchItems, setSelectedTransformationItems, selectedBatchItems.length, selectedTransformationItems.length, items.length]);

  React.useEffect(() => {
    // Logging der Library-IDs - verzögert ausführen
    const timeoutId = setTimeout(() => {
      StateLogger.debug('FileList', 'Render', {
        currentLibraryId: currentLibrary?.id,
        activeLibraryIdAtom: activeLibraryId
      });
    }, 0);
    
    return () => clearTimeout(timeoutId);
  }, [currentLibrary, activeLibraryId]);

  // Entkoppelt: kein Render-Gate mehr basierend auf FileTree

  return (
    <div className="h-full flex flex-col">
      {/* Header - versteckt im compact mode */}
      {!compact && (
        <div className="border-b px-2 py-2 flex items-center justify-between bg-background sticky top-0 z-10">
          <div className="flex items-center gap-2">
            <Button
              variant="ghost"
              size="icon"
              className="h-8 w-8"
              onClick={handleRefresh}
              disabled={isRefreshing}
              title="Aktualisieren"
              aria-label="Aktualisieren"
            >
              <RefreshCw className={cn("h-4 w-4", isRefreshing && "animate-spin")} />
            </Button>

            {/* Dateikategorie-Filter (Icon-only Variante) */}
            <FileCategoryFilter iconOnly />

            {/* Batch-Actions als Icons */}
            {selectedBatchItems.length > 0 && (
              <Button size="icon" title="Transkribieren" aria-label="Transkribieren" onClick={handleBatchTranscription}>
                <ScrollText className="h-4 w-4" />
              </Button>
            )}
            {selectedTransformationItems.length > 0 && (
              <Button size="icon" variant="secondary" title="Transformieren" aria-label="Transformieren" onClick={handleBatchTransformation}>
                <Plus className="h-4 w-4" />
              </Button>
            )}
            {(selectedBatchItems.length + selectedTransformationItems.length) > 0 && (
              <Button size="icon" variant="destructive" title="Ausgewählte löschen" aria-label="Ausgewählte löschen" onClick={handleBulkDelete}>
                <Trash2 className="h-4 w-4" />
              </Button>
            )}
          </div>
        </div>
      )}

      {/* File List */}
      <div className="flex-1 overflow-auto">
        <div>
          {/* Table Header - versteckt im compact mode */}
          {!compact && (
            <div className="sticky top-0 bg-background border-b">
              <div className="grid grid-cols-[24px_24px_minmax(0,1fr)_56px_88px_auto] gap-2 px-4 py-2 text-sm font-medium text-muted-foreground">
                <div className="w-6 flex items-center justify-center">
                  <Checkbox
                    checked={isAllSelected}
                    onCheckedChange={handleSelectAll}
                    aria-label="Alle auswählen"
                  />
                </div>
                <div className="w-6" />
                <SortableHeaderCell
                  label="Name"
                  field="name"
                  currentSortField={sortField}
                  currentSortOrder={sortOrder}
                  onSort={handleSort}
                />
                <SortableHeaderCell
                  label="Größe"
                  field="size"
                  currentSortField={sortField}
                  currentSortOrder={sortOrder}
                  onSort={handleSort}
                />
                <SortableHeaderCell
                  label="Geändert"
                  field="date"
                  currentSortField={sortField}
                  currentSortOrder={sortOrder}
                  onSort={handleSort}
                />
                <div />
              </div>
            </div>
          )}

          {/* Folder Rows (oberhalb der Dateien, unabhängig von Datei-Gruppierung) */}
          {folders.length > 0 && (
            <div className="divide-y">
              {folders.map((folder) => (
                <div
                  key={folder.id}
                  role="button"
                  tabIndex={0}
                  onClick={() => navigateToFolder(folder.id)}
                  onKeyDown={(e) => {
                    if (e.key === 'Enter' || e.key === ' ') navigateToFolder(folder.id);
                  }}
                  className="w-full px-4 py-2 text-xs hover:bg-muted/50 grid grid-cols-[24px_24px_minmax(0,1fr)_56px_88px_auto] gap-2 items-center cursor-pointer"
                >
                  <div />
                  <FolderIcon className="h-4 w-4" />
                  <span className="text-left truncate select-none" title={folder.metadata.name}>{folder.metadata.name}</span>
                  <span className="text-muted-foreground" />
                  <span className="text-muted-foreground" />
                  <div />
                </div>
              ))}
            </div>
          )}

          {/* File Rows */}
          <div className="divide-y">
            {Array.from((fileGroups ?? new Map()).values())
              .map((group) => {
                // Zeige nur die Hauptdatei (baseItem) an
                const item = group.baseItem;
                if (!item) return null;
                // System-Unterordner-Id, wenn ein ".<basename>"-Folder existiert
                const systemFolder = systemFolderByBase.get(getBaseName(item.metadata.name));
                const systemFolderId = systemFolder?.id;
                const isActive = !!activeFile && activeFile.id === item.id
                return (
                  <FileRow
                    key={item.id}
                    item={item as StorageItem}
                    isSelected={isItemSelected(item)}
                    isActive={isActive}
                    onSelect={() => handleSelect(item, group)}
                    onCreateTranscript={handleCreateTranscript}
                    onDelete={(e) => handleDeleteClick(e, item)}
                    fileGroup={group}
                    onSelectRelatedFile={handleSelectRelatedFile}
                    onRename={handleRename}
                    compact={compact}
                    systemFolderId={systemFolderId}
                  />
                );
              })}
          </div>
        </div>
      </div>
    </div>
  );
}); 
```

Ich habe die aktuell ausgewählte Datei in der File‑Liste deutlich markiert:

- Aktive Zeile (die im Preview gezeigte Datei) erhält:
  - Hintergrund: leicht hervorgehoben (`bg-primary/10`)
  - Linke Kante: `border-l-2 border-primary`
  - Dateiname fett (`font-medium`)
- Gilt sowohl für normale als auch kompakte Liste.
- Tooltip zeigt weiterhin den vollständigen Namen.

Technisch:
- `activeFile` aus `selectedFileAtom` wird mit der Zeile verglichen.
- Neues Prop `isActive` in `FileRow` steuert die Hervorhebung.

Wenn du zusätzlich den Dateinamen am Ende des Breadcrumbs anzeigen willst, kann ich das ergänzen.

---

**User**

In der Kompakten Filliste sieht man das, in der normalen noch nicht.
In der File-Liste sollten Einträge, die Verzeichnisse sind, die Spalten "Größe" und "Geändert" nutzen dürfen. Das heißt, sie sollten die ganze Tabellen breite nutzen, weil vor allem in der Kompaktansicht diese Verzeichnissenamen unnötig abgeschnitten werden.

---

**Cursor**

```typescriptreact
'use client';

import * as React from "react"
import { File, FileText, FileVideo, FileAudio, Plus, RefreshCw, ChevronUp, ChevronDown, Trash2, ScrollText, Folder as FolderIcon, Layers } from "lucide-react"
import { StorageItem } from "@/lib/storage/types"
import { cn } from "@/lib/utils"
import { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from "@/components/ui/tooltip"
import { useStorage } from "@/contexts/storage-context";
import { Button } from "@/components/ui/button";
import { useAtomValue, useAtom } from 'jotai';
import { jobStatusByItemIdAtom } from '@/atoms/job-status';
import { 
  activeLibraryIdAtom, 
  selectedFileAtom, 
  folderItemsAtom,
  sortedFilteredFilesAtom,
  sortFieldAtom,
  sortOrderAtom,
  selectedShadowTwinAtom
} from '@/atoms/library-atom';
import { toast } from "sonner";
import { Input } from "@/components/ui/input"
import {
  selectedBatchItemsAtom,
  transcriptionDialogOpenAtom,
  selectedTransformationItemsAtom,
  transformationDialogOpenAtom,
  getMediaType,
  fileCategoryFilterAtom,
} from '@/atoms/transcription-options';
import { Checkbox } from "@/components/ui/checkbox"
import { useMemo, useCallback } from "react"
import { FileLogger, StateLogger } from "@/lib/debug/logger"
import { FileCategoryFilter } from './file-category-filter';
import { useFolderNavigation } from "@/hooks/use-folder-navigation";

// Typen für Sortieroptionen
type SortField = 'type' | 'name' | 'size' | 'date';
type SortOrder = 'asc' | 'desc';

// Typ für gruppierte Dateien
interface FileGroup {
  baseItem?: StorageItem;
  transcriptFiles?: StorageItem[]; // NEU: alle Transkripte
  transformed?: StorageItem;
}

// Memoized file icon component
const FileIconComponent = React.memo(function FileIconComponent({ item }: { item: StorageItem }) {
  const mimeType = item.metadata.mimeType || '';
  if (!mimeType) return <File className="h-4 w-4" />;

  if (mimeType.startsWith('video/')) {
    return <FileVideo className="h-4 w-4" />;
  } else if (mimeType.startsWith('audio/')) {
    return <FileAudio className="h-4 w-4" />;
  } else if (mimeType.startsWith('text/')) {
    return <FileText className="h-4 w-4" />;
  }

  return <File className="h-4 w-4" />;
});

// Pure function for file size formatting
const formatFileSize = (size?: number): string => {
  if (!size) return '-';
  const units = ['B', 'KB', 'MB', 'GB'];
  let value = size;
  let unitIndex = 0;
  
  while (value >= 1024 && unitIndex < units.length - 1) {
    value /= 1024;
    unitIndex++;
  }
  
  return `${value.toFixed(1)} ${units[unitIndex]}`;
};

// Funktion zum Formatieren des Datums
const formatDate = (date?: Date): string => {
  if (!date) return '-';
  
  const options: Intl.DateTimeFormatOptions = { 
    year: '2-digit', 
    month: '2-digit', 
    day: '2-digit',
    hour: '2-digit',
    minute: '2-digit'
  };
  
  return new Date(date).toLocaleDateString('de-DE', options);
};

// Entfernt: getFileStem Funktion war unbenutzt

// Sortierbare Kopfzelle Komponente
const SortableHeaderCell = React.memo(function SortableHeaderCell({
  label,
  field,
  currentSortField,
  currentSortOrder,
  onSort
}: {
  label: string,
  field: SortField,
  currentSortField: SortField,
  currentSortOrder: SortOrder,
  onSort: (field: SortField) => void
}) {
  const isActive = currentSortField === field;
  
  return (
    <button 
      onClick={() => onSort(field)}
      className="flex items-center gap-1 hover:text-foreground"
    >
      <span>{label}</span>
      {isActive && (
        currentSortOrder === 'asc' 
          ? <ChevronUp className="h-3 w-3" /> 
          : <ChevronDown className="h-3 w-3" />
      )}
    </button>
  );
});

interface FileRowProps {
  item: StorageItem;
  isSelected: boolean;
  isActive?: boolean;
  onSelect: () => void;
  onCreateTranscript: (e: React.MouseEvent) => void;
  onDelete: (e: React.MouseEvent<HTMLButtonElement>, item: StorageItem) => void;
  fileGroup?: FileGroup;
  onSelectRelatedFile?: (file: StorageItem) => void;
  onRename?: (item: StorageItem, newName: string) => Promise<void>;
  compact?: boolean;
  systemFolderId?: string;
}

const FileRow = React.memo(function FileRow({ 
  item, 
  isSelected, 
  isActive = false,
  onSelect,
  onCreateTranscript,
  onDelete,
  fileGroup,
  onSelectRelatedFile,
  onRename,
  compact = false,
  systemFolderId
}: FileRowProps) {
  const navigateToFolder = useFolderNavigation();
  const [isEditing, setIsEditing] = React.useState(false);
  const [editName, setEditName] = React.useState(item.metadata.name);
  const inputRef = React.useRef<HTMLInputElement>(null);
  const longPressTimerRef = React.useRef<NodeJS.Timeout | null>(null);
  const lastClickTimeRef = React.useRef<number>(0);
  
  // Zusätzliche Validierung der Metadaten
  const metadata = React.useMemo(() => ({
    name: item.metadata?.name || 'Unbekannte Datei',
    size: typeof item.metadata?.size === 'number' ? item.metadata.size : 0,
    mimeType: item.metadata?.mimeType || '',
    hasTranscript: !!item.metadata?.hasTranscript || (fileGroup?.transcriptFiles && fileGroup.transcriptFiles.length > 0),
    modifiedAt: item.metadata?.modifiedAt
  }), [item.metadata, fileGroup]);

  const isTranscribable = React.useMemo(() => {
    const mimeType = metadata.mimeType.toLowerCase();
    const extension = metadata.name.split('.').pop()?.toLowerCase();

    return (
      mimeType.startsWith('audio/') ||
      mimeType.startsWith('video/') ||
      extension === 'pdf' ||
      mimeType === 'application/pdf'
    );
  }, [metadata.mimeType, metadata.name]);

  // Memoize the click handler
  const handleClick = React.useCallback(() => {
    if (!isEditing) {
      onSelect();
    }
  }, [onSelect, isEditing]);

  // Memoize the keydown handler
  const handleKeyDown = React.useCallback((e: React.KeyboardEvent) => {
    if (!isEditing && (e.key === 'Enter' || e.key === ' ')) {
      onSelect();
    }
  }, [onSelect, isEditing]);

  // Handler für Transkript-Icon Click
  const handleTranscriptClick = React.useCallback((e: React.MouseEvent) => {
    e.stopPropagation();
    if (fileGroup?.transcriptFiles && onSelectRelatedFile) {
      onSelectRelatedFile(fileGroup.transcriptFiles[0]); // Nur das erste Transkript anzeigen
    }
  }, [fileGroup, onSelectRelatedFile]);

  // Handler für Transformierte-Datei-Icon Click
  const handleTransformedClick = React.useCallback((e: React.MouseEvent) => {
    e.stopPropagation();
    if (fileGroup?.transformed && onSelectRelatedFile) {
      onSelectRelatedFile(fileGroup.transformed);
    }
  }, [fileGroup, onSelectRelatedFile]);

  // Starte Rename-Modus
  const startRename = React.useCallback(() => {
    if (onRename) {
      // Prüfe ob dies eine abhängige Datei ist
      if (fileGroup && (
        (fileGroup.transcriptFiles && fileGroup.transcriptFiles.length > 0 && fileGroup.transcriptFiles[0]?.id === item.id) ||
        (fileGroup.transformed && item.id === fileGroup.transformed.id)
      )) {
        // Dies ist eine abhängige Datei - zeige Hinweis
        toast.info("Hinweis", {
          description: "Bitte benennen Sie die Haupt-Datei um. Abhängige Dateien werden automatisch mit umbenannt."
        });
        return;
      }
      
      setIsEditing(true);
      setEditName(item.metadata.name);
    }
  }, [onRename, item, fileGroup]);

  // Handler für Dateinamen-Click (Doppelklick-Erkennung)
  const handleNameClick = React.useCallback((e: React.MouseEvent) => {
    e.stopPropagation();
    
    const currentTime = Date.now();
    const timeSinceLastClick = currentTime - lastClickTimeRef.current;
    
    if (timeSinceLastClick < 300) {
      // Doppelklick erkannt
      startRename();
    } else {
      // Erster Klick - wähle die Datei aus
      onSelect();
    }
    
    lastClickTimeRef.current = currentTime;
  }, [startRename, onSelect]);

  // Handler für Long-Press (Touch-Geräte)
  const handleTouchStart = React.useCallback((e: React.TouchEvent) => {
    e.stopPropagation();
    
    // Starte Long-Press Timer
    longPressTimerRef.current = setTimeout(() => {
      startRename();
    }, 500); // 500ms für Long-Press
  }, [startRename]);

  const handleTouchEnd = React.useCallback((e: React.TouchEvent) => {
    e.stopPropagation();
    
    // Lösche Long-Press Timer
    if (longPressTimerRef.current) {
      clearTimeout(longPressTimerRef.current);
      longPressTimerRef.current = null;
    }
  }, []);

  const handleTouchMove = React.useCallback(() => {
    // Bei Bewegung Long-Press abbrechen
    if (longPressTimerRef.current) {
      clearTimeout(longPressTimerRef.current);
      longPressTimerRef.current = null;
    }
  }, []);

  // Cleanup Timer bei Unmount
  React.useEffect(() => {
    return () => {
      if (longPressTimerRef.current) {
        clearTimeout(longPressTimerRef.current);
      }
    };
  }, []);

  // Handler für Rename-Submit
  const handleRenameSubmit = React.useCallback(async () => {
    if (onRename && editName.trim() && editName !== item.metadata.name) {
      try {
        await onRename(item, editName.trim());
      } catch (error) {
        FileLogger.error('FileRow', 'Fehler beim Umbenennen', error);
        // Bei Fehler den ursprünglichen Namen wiederherstellen
        setEditName(item.metadata.name);
      }
    }
    setIsEditing(false);
  }, [onRename, editName, item]);

  // Handler für Rename-Cancel
  const handleRenameCancel = React.useCallback(() => {
    setEditName(item.metadata.name);
    setIsEditing(false);
  }, [item.metadata.name]);

  // Handler für Input-Änderungen
  const handleInputChange = React.useCallback((e: React.ChangeEvent<HTMLInputElement>) => {
    setEditName(e.target.value);
  }, []);

  // Handler für Input-Keydown
  const handleInputKeyDown = React.useCallback((e: React.KeyboardEvent<HTMLInputElement>) => {
    e.stopPropagation();
    if (e.key === 'Enter') {
      handleRenameSubmit();
    } else if (e.key === 'Escape') {
      handleRenameCancel();
    }
  }, [handleRenameSubmit, handleRenameCancel]);

  // Focus Input wenn Edit-Modus aktiviert wird
  React.useEffect(() => {
    if (isEditing && inputRef.current) {
      inputRef.current.focus();
      inputRef.current.select();
    }
  }, [isEditing]);

  // Handler für Drag Start
  const handleDragStart = React.useCallback((e: React.DragEvent) => {
    // Sammle alle Dateien der Gruppe, die verschoben werden sollen
    const itemsToMove = [];
    
    // Füge das aktuelle Item hinzu
    itemsToMove.push({
      itemId: item.id,
      itemName: item.metadata.name,
      itemType: item.type,
      parentId: item.parentId
    });
    
    // Wenn es eine FileGroup gibt, füge auch die zugehörigen Dateien hinzu
    if (fileGroup) {
      // Prüfe ob das aktuelle Item die Basis-Datei ist
      if (item.id === fileGroup.baseItem?.id) {
        // Füge Transkripte hinzu, falls vorhanden
        if (fileGroup.transcriptFiles && fileGroup.transcriptFiles.length > 0) {
          fileGroup.transcriptFiles.forEach(transcript => {
            itemsToMove.push({
              itemId: transcript.id,
              itemName: transcript.metadata.name,
              itemType: transcript.type,
              parentId: transcript.parentId
            });
          });
        }
        
        // Füge transformierte Datei hinzu, falls vorhanden
        if (fileGroup.transformed) {
          itemsToMove.push({
            itemId: fileGroup.transformed.id,
            itemName: fileGroup.transformed.metadata.name,
            itemType: fileGroup.transformed.type,
            parentId: fileGroup.transformed.parentId
          });
        }
      }
    }
    
    // Setze die Drag-Daten
    e.dataTransfer.effectAllowed = 'move';
    e.dataTransfer.setData('application/json', JSON.stringify({
      items: itemsToMove,
      isFileGroup: itemsToMove.length > 1
    }));
    
    // Visuelles Feedback
    if (e.currentTarget instanceof HTMLElement) {
      e.currentTarget.style.opacity = '0.5';
    }
  }, [item, fileGroup]);

  // Handler für Drag End
  const handleDragEnd = React.useCallback((e: React.DragEvent) => {
    // Stelle Opacity wieder her
    if (e.currentTarget instanceof HTMLElement) {
      e.currentTarget.style.opacity = '1';
    }
  }, []);

  const [selectedBatchItems, setSelectedBatchItems] = useAtom(selectedBatchItemsAtom);
  const [selectedTransformationItems, setSelectedTransformationItems] = useAtom(selectedTransformationItemsAtom);
  
  // Prüfe ob das Item in einem der beiden Atome ausgewählt ist
  const isInBatch = selectedBatchItems.some(batchItem => batchItem.item.id === item.id);
  const isInTransformation = selectedTransformationItems.some(transformationItem => transformationItem.item.id === item.id);
  const isInAnyBatch = isInBatch || isInTransformation;

  // Handler für Checkbox-Änderungen
  const handleCheckboxChange = React.useCallback((checked: boolean) => {
    const mediaType = getMediaType(item);
    
    if (mediaType === 'audio' || mediaType === 'video') {
      // Für Audio/Video: Transcription-Atom verwenden
      if (checked) {
        setSelectedBatchItems([...selectedBatchItems, {
          item,
          type: mediaType
        }]);
      } else {
        setSelectedBatchItems(selectedBatchItems.filter(i => i.item.id !== item.id));
      }
    } else if (mediaType === 'text' || mediaType === 'document') {
      // Für Text/Dokumente: Transformation-Atom verwenden
      if (checked) {
        setSelectedTransformationItems([...selectedTransformationItems, {
          item,
          type: mediaType
        }]);
      } else {
        setSelectedTransformationItems(selectedTransformationItems.filter(i => i.item.id !== item.id));
      }
    }
  }, [item, selectedBatchItems, selectedTransformationItems, setSelectedBatchItems, setSelectedTransformationItems]);

  React.useEffect(() => {
    if (fileGroup) {
      FileLogger.debug('FileRow', 'Transkripte für Zeile', {
        baseItem: fileGroup.baseItem?.metadata.name,
        transcripts: fileGroup.transcriptFiles?.map(t => t.metadata.name)
      });
    }
  }, [fileGroup]);

  // Zentraler Jobstatus (muss vor möglichen early-returns stehen, um Hook-Order zu garantieren)
  const jobStatusMap = useAtomValue(jobStatusByItemIdAtom);
  const jobStatus = jobStatusMap[item.id];
  const jobStatusIcon = jobStatus ? (
    <span title={jobStatus} className={cn('inline-block h-3 w-3 rounded-full',
      jobStatus === 'queued' && 'bg-blue-600',
      jobStatus === 'running' && 'bg-yellow-600',
      jobStatus === 'completed' && 'bg-green-600',
      jobStatus === 'failed' && 'bg-red-600'
    )} aria-label={`job-${jobStatus}`} />
  ) : null;

  // Compact-Modus: vereinfachte Darstellung
  if (compact) {
    return (
      <div
        role="button"
        tabIndex={0}
        onClick={handleClick}
        onKeyDown={handleKeyDown}
        className={cn(
          "w-full px-2 py-1 text-sm hover:bg-muted/50 flex items-center gap-2 cursor-pointer",
          isSelected && "bg-muted",
          isActive && "bg-primary/10 border-l-2 border-primary"
        )}
      >
        <FileIconComponent item={item} />
        <span className={cn("truncate flex-1", isActive && "font-medium") } title={metadata.name}>
          {metadata.name}
        </span>
        {/* Shadow-Twin-Symbole im compact mode */}
        {fileGroup?.transcriptFiles && fileGroup.transcriptFiles.length > 0 && (
          <Button
            variant="ghost"
            size="icon"
            className="h-4 w-4 p-0 hover:bg-muted text-muted-foreground hover:text-foreground"
            onClick={handleTranscriptClick}
          >
            <ScrollText className="h-3 w-3" />
          </Button>
        )}
      </div>
    );
  }

  return (
    <div
      role="button"
      tabIndex={0}
      onClick={handleClick}
      onKeyDown={handleKeyDown}
      onTouchStart={handleTouchStart}
      onTouchEnd={handleTouchEnd}
      onTouchMove={handleTouchMove}
      draggable={!isEditing}
      onDragStart={handleDragStart}
      onDragEnd={handleDragEnd}
      className={cn(
        "w-full px-4 py-2 text-xs hover:bg-muted/50 grid grid-cols-[24px_24px_minmax(0,1fr)_56px_88px_auto] gap-2 items-center cursor-move",
        isSelected && "bg-muted",
        isActive && "bg-primary/10 border-l-2 border-primary"
      )}
    >
      <div className="w-6 flex items-center justify-center">
        <Checkbox
          checked={isInAnyBatch}
          onCheckedChange={handleCheckboxChange}
          onClick={(e) => e.stopPropagation()}
        />
      </div>
      <FileIconComponent item={item} />
      {isEditing ? (
        <Input
          ref={inputRef}
          value={editName}
          onChange={handleInputChange}
          onKeyDown={handleInputKeyDown}
          onBlur={handleRenameSubmit}
          onClick={(e) => e.stopPropagation()}
          className="h-6 px-1 py-0 text-xs"
        />
      ) : (
        <span 
          className={cn("text-left truncate cursor-pointer hover:text-primary select-none", isActive && "font-medium")}
          onClick={handleNameClick}
          onTouchStart={handleTouchStart}
          onTouchEnd={handleTouchEnd}
          onTouchMove={handleTouchMove}
          title={metadata.name}
        >
          {metadata.name}
        </span>
      )}
      <span className="text-muted-foreground tabular-nums text-[10px]">
        {formatFileSize(metadata.size)}
      </span>
      <span className="text-muted-foreground tabular-nums text-[10px]">
        {formatDate(metadata.modifiedAt)}
      </span>
      <div className="flex items-center justify-start gap-1">
        {jobStatusIcon}
        {/* System-Unterordner (z. B. extrahierte Seiten) */}
        {systemFolderId && (
          <TooltipProvider>
            <Tooltip>
              <TooltipTrigger asChild>
                <Button
                  variant="ghost"
                  size="icon"
                  className="h-6 w-6 p-0 hover:bg-muted"
                  onClick={(e) => {
                    e.stopPropagation();
                    navigateToFolder(systemFolderId);
                  }}
                >
                  <Layers className="h-4 w-4 text-violet-500" />
                </Button>
              </TooltipTrigger>
              <TooltipContent>
                <p>Seiten-Ordner öffnen</p>
              </TooltipContent>
            </Tooltip>
          </TooltipProvider>
        )}
        {/* Zeige Icons für alle vorhandenen Transkripte */}
        {fileGroup?.transcriptFiles && fileGroup.transcriptFiles.length > 0 && fileGroup.transcriptFiles.map((transcript) => (
          <TooltipProvider key={transcript.id}>
            <Tooltip>
              <TooltipTrigger asChild>
                <Button
                  variant="ghost"
                  size="icon"
                  className="h-6 w-6 p-0 hover:bg-muted"
                  onClick={(e) => {
                    e.stopPropagation();
                    if (onSelectRelatedFile) onSelectRelatedFile(transcript);
                  }}
                >
                  <FileText className="h-4 w-4 text-blue-500" />
                </Button>
              </TooltipTrigger>
              <TooltipContent>
                <p>Transkript anzeigen: {transcript.metadata.name}</p>
              </TooltipContent>
            </Tooltip>
          </TooltipProvider>
        ))}
        {/* Plus-Symbol nur anzeigen, wenn kein Transkript vorhanden und transkribierbar */}
        {(!fileGroup?.transcriptFiles || fileGroup.transcriptFiles.length === 0) && isTranscribable && !metadata.hasTranscript ? (
          <TooltipProvider>
            <Tooltip>
              <TooltipTrigger asChild>
                <div 
                  role="button"
                  tabIndex={0}
                  className="h-6 w-6 p-0 inline-flex items-center justify-center hover:bg-muted rounded-sm"
                  onClick={onCreateTranscript}
                  onKeyDown={(e) => {
                    if (e.key === 'Enter' || e.key === ' ') {
                      e.stopPropagation();
                      onCreateTranscript(e as unknown as React.MouseEvent<HTMLDivElement>);
                    }
                  }}
                >
                  <Plus className="h-4 w-4" />
                </div>
              </TooltipTrigger>
              <TooltipContent>
                <p>Transkript erstellen</p>
              </TooltipContent>
            </Tooltip>
          </TooltipProvider>
        ) : null}
        {/* Icon für transformierte Datei */}
        {fileGroup?.transformed && (
          <TooltipProvider>
            <Tooltip>
              <TooltipTrigger asChild>
                <Button
                  variant="ghost"
                  size="icon"
                  className="h-6 w-6 p-0 hover:bg-muted"
                  onClick={handleTransformedClick}
                >
                  <ScrollText className="h-4 w-4 text-green-500" />
                </Button>
              </TooltipTrigger>
              <TooltipContent>
                <p>Transformierte Datei anzeigen</p>
              </TooltipContent>
            </Tooltip>
          </TooltipProvider>
        )}
        {/* Delete direkt neben Dokument-Icons */}
        <TooltipProvider>
          <Tooltip>
            <TooltipTrigger asChild>
              <Button
                variant="ghost"
                size="icon"
                className="h-6 w-6 p-0 hover:bg-destructive/10 hover:text-destructive"
                onClick={(e) => onDelete(e as React.MouseEvent<HTMLButtonElement>, item)}
              >
                <Trash2 className="h-4 w-4" />
              </Button>
            </TooltipTrigger>
            <TooltipContent>
              <p>Datei löschen</p>
            </TooltipContent>
          </Tooltip>
        </TooltipProvider>
      </div>
      <div />
    </div>
  );
});

interface FileListProps {
  compact?: boolean;
}

export const FileList = React.memo(function FileList({ compact = false }: FileListProps): JSX.Element {
  const { provider, refreshItems, currentLibrary } = useStorage();
  const activeLibraryId = useAtomValue(activeLibraryIdAtom);
  const [isRefreshing, setIsRefreshing] = React.useState(false);
  // Mobile-Flag wurde entfernt, FileList lädt unabhängig vom View
  const [selectedBatchItems, setSelectedBatchItems] = useAtom(selectedBatchItemsAtom);
  const [selectedTransformationItems, setSelectedTransformationItems] = useAtom(selectedTransformationItemsAtom);
  const [, setTranscriptionDialogOpen] = useAtom(transcriptionDialogOpenAtom);
  const [, setTransformationDialogOpen] = useAtom(transformationDialogOpenAtom);
  const [isInitialized, setIsInitialized] = React.useState(false);
  const initializationTimeoutRef = React.useRef<NodeJS.Timeout | null>(null);
  // Entkoppelt: Kein Warten mehr auf FileTree-Status
  const [activeFile, setSelectedFile] = useAtom(selectedFileAtom);
  const [, setFolderItems] = useAtom(folderItemsAtom);
  const currentCategoryFilter = useAtomValue(fileCategoryFilterAtom);
  const allItemsInFolder = useAtomValue(folderItemsAtom);
  const navigateToFolder = useFolderNavigation();

  // Kein mobiles Flag mehr notwendig

  const folders = useMemo(() => {
    const items = allItemsInFolder ?? [];
    // Verstecke dot-Verzeichnisse generell in der Liste
    return items.filter(item => item.type === 'folder' && !item.metadata.name.startsWith('.'));
  }, [allItemsInFolder]);

  // Hilfsfunktion zum Finden einer FileGroup in der Map
  const findFileGroup = (map: Map<string, FileGroup>, stem: string): FileGroup | undefined => {
    return Array.from((map ?? new Map()).values()).find(group => 
      group.baseItem && getBaseName(group.baseItem.metadata.name) === stem
    );
  };

  // NEU: Atome für Sortierung und Filter
  const items = useAtomValue(sortedFilteredFilesAtom);
  const [sortField, setSortField] = useAtom(sortFieldAtom);
  const [sortOrder, setSortOrder] = useAtom(sortOrderAtom);
  
  // Review-Mode-Atoms
  const [, setSelectedShadowTwin] = useAtom(selectedShadowTwinAtom);

  // handleSort nutzt jetzt Atome
  const handleSort = React.useCallback((field: SortField) => {
    if (field === sortField) setSortOrder(sortOrder === 'asc' ? 'desc' : 'asc');
    else {
      setSortField(field);
      setSortOrder('asc');
    }
  }, [sortField, sortOrder, setSortField, setSortOrder]);

  // Initialisierung - nur auf Provider und Mobile-Flag achten
  React.useEffect(() => {
    if (!provider) {
      FileLogger.info('FileList', 'Waiting for provider');
      return;
    }

    const initialize = async () => {
      if (isInitialized) {
        FileLogger.debug('FileList', 'Already initialized');
        return;
      }

      FileLogger.info('FileList', 'Starting initialization');

      try {
        FileLogger.info('FileList', 'Initialization complete');
        setIsInitialized(true);
      } catch (error) {
        FileLogger.error('FileList', 'Error initializing FileList', error);
      }
    };

    initialize();

    const timeoutRef = initializationTimeoutRef.current;
    return () => {
      if (timeoutRef) clearTimeout(timeoutRef);
    };
  }, [provider, isInitialized]);

  // NEU: Reagieren auf Bibliothekswechsel
  const prevLibraryIdRef = React.useRef<string | null>(null);
  React.useEffect(() => {
    StateLogger.debug('FileList', 'Render', {
      currentLibraryId: activeLibraryId,
      activeLibraryIdAtom: activeLibraryId
    });

    // Nur bei tatsächlichem Bibliothekswechsel zurücksetzen
    if (prevLibraryIdRef.current !== null && prevLibraryIdRef.current !== activeLibraryId) {
      setIsInitialized(false);
      setSelectedFile(null);
      setFolderItems([]);
      setSelectedBatchItems([]);
      setSelectedTransformationItems([]);
      setSelectedShadowTwin(null);
      StateLogger.info('FileList', 'Bibliothek gewechselt - State zurückgesetzt', {
        libraryId: activeLibraryId
      });
    }
    prevLibraryIdRef.current = activeLibraryId;
  }, [activeLibraryId, setSelectedFile, setFolderItems, setSelectedBatchItems, setSelectedTransformationItems, setSelectedShadowTwin]);

  // Vereinfachte Funktion zum Extrahieren des Basisnamens (ohne Endung, auch für Binärdateien)
  function getBaseName(name: string): string {
    // ShadowTwin: .de.md, .en.md, etc.
    const shadowTwinMatch = name.match(/^(.*)\.(de|en|fr|es|it)\.md$/);
    if (shadowTwinMatch) return shadowTwinMatch[1];
    // Sonst: alles vor der letzten Endung
    const lastDot = name.lastIndexOf('.');
    if (lastDot === -1) return name;
    return name.substring(0, lastDot);
  }

  // Prüft ob eine Datei ein ShadowTwin ist (Markdown mit Sprachkürzel)
  function isShadowTwin(name: string): boolean {
    // Pattern: name.de.md, name.en.md, etc.
    const shadowTwinPattern = /^(.+)\.(de|en|fr|es|it)\.md$/;
    return shadowTwinPattern.test(name);
  }

  // Gruppiere die Dateien nach Basename
  const fileGroups = useMemo(() => {
    if (!items) return new Map<string, FileGroup>();

    // Schritt 1: Gruppiere alle Dateien nach Basename
    const groupsMap = new Map<string, StorageItem[]>();
    for (const item of items) {
      if (item.type !== 'file') continue;
      const base = getBaseName(item.metadata.name);
      if (!groupsMap.has(base)) groupsMap.set(base, []);
      groupsMap.get(base)!.push(item);
    }

    // Schritt 2: Erstelle FileGroups
    const fileGroupsMap = new Map<string, FileGroup>();
    for (const [base, groupItems] of Array.from(groupsMap.entries())) {
      // Finde Hauptdatei (erste Nicht-ShadowTwin-Datei)
      const mainFile = groupItems.find((item) => !isShadowTwin(item.metadata.name));
      // Finde alle ShadowTwins
      const shadowTwins = groupItems.filter((item) => isShadowTwin(item.metadata.name));
      if (mainFile) {
        fileGroupsMap.set(base, {
          baseItem: mainFile,
          transcriptFiles: shadowTwins.length > 0 ? shadowTwins : undefined,
          transformed: undefined
        });
      } else {
        // Keine Hauptdatei: Jede ShadowTwin einzeln anzeigen
        for (const twin of shadowTwins) {
          fileGroupsMap.set(`${base}__shadow_${twin.id}`, {
            baseItem: twin,
            transcriptFiles: undefined,
            transformed: undefined
          });
        }
      }
    }
    // Debug-Logging für Gruppierung
    FileLogger.debug('FileList', 'Gruppierung Ergebnis (Basename, alle Endungen)', {
      groups: Array.from(fileGroupsMap.entries()).map(([base, group]) => ({
        base,
        baseItem: group.baseItem?.metadata.name,
        transcripts: group.transcriptFiles?.map(t => t.metadata.name)
      }))
    });
    return fileGroupsMap;
  }, [items]);

  // Mapping: Basename -> dot-Systemordner (z. B. ".<basename>")
  const systemFolderByBase = useMemo(() => {
    const map = new Map<string, StorageItem>();
    const items = allItemsInFolder ?? [];
    for (const it of items) {
      if (it.type !== 'folder') continue;
      const name = it.metadata.name;
      if (!name.startsWith('.')) continue;
      const base = name.slice(1);
      if (base) map.set(base, it);
    }
    return map;
  }, [allItemsInFolder]);

  // Berechne, ob alle Dateien ausgewählt sind
  const isAllSelected = useMemo(() => {
    if (!fileGroups || !fileGroups.size) return false;
    // Verwende nur die Hauptdateien (baseItem) aus den FileGroups
    const mainItems = Array.from((fileGroups ?? new Map()).values())
      .map(group => group.baseItem)
      .filter((item): item is StorageItem => item !== undefined);
    // Je nach Filter unterschiedliche Dateien zählen
    let selectableItems: StorageItem[] = [];
    switch (currentCategoryFilter) {
      case 'media':
        selectableItems = mainItems.filter(item => {
          try {
            const mediaType = getMediaType(item);
            return item.type === 'file' && (mediaType === 'audio' || mediaType === 'video');
          } catch {
            return false;
          }
        });
        return selectableItems.length > 0 && selectedBatchItems.length === selectableItems.length;
      case 'text':
        selectableItems = mainItems.filter(item => {
          try {
            const mediaType = getMediaType(item);
            return item.type === 'file' && mediaType === 'text';
          } catch {
            return false;
          }
        });
        return selectableItems.length > 0 && selectedTransformationItems.length === selectableItems.length;
      case 'documents':
        selectableItems = mainItems.filter(item => {
          try {
            const mediaType = getMediaType(item);
            return item.type === 'file' && mediaType === 'document';
          } catch {
            return false;
          }
        });
        return selectableItems.length > 0 && selectedTransformationItems.length === selectableItems.length;
      default:
        // Bei 'all' prüfen ob alle verfügbaren Dateien ausgewählt sind
        const mediaItems = mainItems.filter(item => {
          try {
            const mediaType = getMediaType(item);
            return item.type === 'file' && (mediaType === 'audio' || mediaType === 'video');
          } catch {
            return false;
          }
        });
        const textItems = mainItems.filter(item => {
          try {
            const mediaType = getMediaType(item);
            return item.type === 'file' && (mediaType === 'text' || mediaType === 'document');
          } catch {
            return false;
          }
        });
        const allMediaSelected = mediaItems.length === 0 || selectedBatchItems.length === mediaItems.length;
        const allTextSelected = textItems.length === 0 || selectedTransformationItems.length === textItems.length;
        return allMediaSelected && allTextSelected;
    }
  }, [fileGroups, selectedBatchItems, selectedTransformationItems, currentCategoryFilter]);
  
  // Erweiterte handleSelect Funktion für Review-Mode
  const handleSelect = useCallback((item: StorageItem, group?: FileGroup) => {
    FileLogger.debug('FileList', 'handleSelect aufgerufen', {
      itemId: item.id,
      itemName: item.metadata.name,
      groupBase: group?.baseItem?.metadata.name,
      transcriptCount: group?.transcriptFiles?.length ?? 0,
      hasTranscripts: !!(group && group.transcriptFiles && group.transcriptFiles.length > 0)
    });
    
    // Nur die ausgewählte Datei setzen - Review-Modus wird über Toggle-Button gesteuert
    setSelectedFile(item);
    
    // Wenn wir im Review-Modus sind und eine Basis-Datei mit Shadow-Twin ausgewählt wird,
    // dann automatisch das Shadow-Twin setzen
    if (group && group.transcriptFiles && group.transcriptFiles.length > 0) {
      const shadowTwin = group.transcriptFiles[0];
      FileLogger.info('FileList', 'Basis-Datei mit Shadow-Twin ausgewählt', {
        twinId: shadowTwin.id,
        twinName: shadowTwin.metadata.name,
        baseFileId: item.id,
        baseFileName: item.metadata.name
      });
      setSelectedShadowTwin(shadowTwin);
    } else {
      FileLogger.info('FileList', 'Datei ohne Shadow-Twin ausgewählt', {
        itemId: item.id,
        itemName: item.metadata.name,
        groupExists: !!group,
        transcriptCount: group?.transcriptFiles?.length ?? 0
      });
      setSelectedShadowTwin(null);
    }
  }, [setSelectedFile, setSelectedShadowTwin, findFileGroup]);
  
  // Erweiterte handleSelectRelatedFile Funktion für Review-Mode
  const handleSelectRelatedFile = useCallback((shadowTwin: StorageItem) => {
    StateLogger.info('FileList', 'Shadow-Twin ausgewählt', {
      shadowTwinId: shadowTwin.id,
      shadowTwinName: shadowTwin.metadata.name
    });
    
    // Setze das Shadow-Twin als ausgewählte Datei, damit es rechts angezeigt wird
    setSelectedFile(shadowTwin);
    setSelectedShadowTwin(null); // Kein zusätzliches Shadow-Twin im normalen Modus
  }, [setSelectedFile, setSelectedShadowTwin, findFileGroup]);

  // Aktualisierte handleRefresh Funktion
  const handleRefresh = useCallback(async () => {
    if (!items || items.length === 0) return;
    
    const parentId = items[0]?.parentId;
    if (!parentId) return;
    
    setIsRefreshing(true);
    
    try {
      const refreshedItems = await refreshItems(parentId);
      setFolderItems(refreshedItems);
    } catch (error) {
      FileLogger.error('FileList', 'Fehler beim Aktualisieren der Dateiliste', error);
    } finally {
      setIsRefreshing(false);
    }
  }, [items, refreshItems, setFolderItems]);

  const handleCreateTranscript = React.useCallback((e: React.MouseEvent) => {
    e.stopPropagation();
    FileLogger.info('FileList', 'Create transcript for', { fileName: 'TODO' });
    // TODO: Implement transcript creation
  }, []);

  // Entfernt: handleItemSelect war unbenutzt

  // Check if an item is selected (beide Atome prüfen)
  const isItemSelected = useCallback((item: StorageItem) => {
    const mediaType = getMediaType(item);
    if (mediaType === 'audio' || mediaType === 'video') {
      return selectedBatchItems.some(selected => selected.item.id === item.id);
    } else {
      return selectedTransformationItems.some(selected => selected.item.id === item.id);
    }
  }, [selectedBatchItems, selectedTransformationItems]);

  // Löschfunktion
  const handleDeleteClick = React.useCallback(async (e: React.MouseEvent<HTMLButtonElement>, itemToDelete: StorageItem) => {
    e.stopPropagation();
    
    if (!provider) {
      toast.error("Fehler", {
        description: "Storage Provider nicht verfügbar"
      });
      return;
    }

    try {
      // Finde die FileGroup für dieses Item
      const itemStem = getBaseName(itemToDelete.metadata.name);
      const fileGroup = findFileGroup(fileGroups, itemStem);

      // Bestätigungsnachricht vorbereiten
      let confirmMessage = `Möchten Sie "${itemToDelete.metadata.name}" wirklich löschen?`;
      if (fileGroup && itemToDelete.id === fileGroup.baseItem?.id) {
        if (fileGroup.transcriptFiles && fileGroup.transcriptFiles.length > 0 || fileGroup.transformed) {
          confirmMessage = `Möchten Sie "${itemToDelete.metadata.name}" und alle zugehörigen Dateien wirklich löschen?`;
        }
      }

      // Benutzer um Bestätigung bitten
      if (!window.confirm(confirmMessage)) {
        return;
      }

      if (fileGroup && itemToDelete.id === fileGroup.baseItem?.id) {
        // Dies ist die Basis-Datei - lösche auch abhängige Dateien
        // Lösche alle Transkripte, falls vorhanden
        if (fileGroup.transcriptFiles) {
          for (const transcript of fileGroup.transcriptFiles) {
            try {
              await provider.deleteItem(transcript.id);
              FileLogger.info('FileList', 'Transkript gelöscht', {
                transcriptId: transcript.id,
                transcriptName: transcript.metadata.name
              });
            } catch (error) {
              FileLogger.error('FileList', 'Fehler beim Löschen des Transkripts', error);
              toast.warning("Hinweis", {
                description: "Einige Transkripte konnten nicht gelöscht werden"
              });
            }
          }
        }

        // Lösche die transformierte Datei, falls vorhanden
        if (fileGroup.transformed) {
          try {
            await provider.deleteItem(fileGroup.transformed.id);
            FileLogger.info('FileList', 'Transformierte Datei gelöscht', {
              transformedId: fileGroup.transformed.id,
              transformedName: fileGroup.transformed.metadata.name
            });
          } catch (error) {
            FileLogger.error('FileList', 'Fehler beim Löschen der transformierten Datei', error);
            toast.warning("Hinweis", {
              description: "Die transformierte Datei konnte nicht gelöscht werden"
            });
          }
        }

        // Lösche die Basis-Datei
        await provider.deleteItem(itemToDelete.id);
        toast.success("Dateien gelöscht", {
          description: `${itemToDelete.metadata.name} und zugehörige Dateien wurden gelöscht.`
        });
      } else {
        // Dies ist eine abhängige Datei oder keine Gruppe - nur diese Datei löschen
        await provider.deleteItem(itemToDelete.id);
        toast.success("Datei gelöscht", {
          description: `${itemToDelete.metadata.name} wurde gelöscht.`
        });
      }

      // Aktualisiere die Dateiliste
      await handleRefresh();

      // Wenn die gelöschte Datei ausgewählt war, Auswahl aufheben
      setSelectedFile(null);
      
      // Aus der Batch-Auswahl entfernen
      setSelectedBatchItems(prev => prev.filter(i => i.item.id !== itemToDelete.id));

    } catch (error) {
      FileLogger.error('FileList', 'Fehler beim Löschen', error);
      toast.error("Fehler", {
        description: `Die Datei konnte nicht gelöscht werden: ${error instanceof Error ? error.message : 'Unbekannter Fehler'}`
      });
    }
  }, [provider, handleRefresh, fileGroups, setSelectedFile, setSelectedBatchItems]);

  const handleRename = React.useCallback(async (item: StorageItem, newName: string) => {
    if (!provider) {
      toast.error("Fehler", {
        description: "Storage Provider nicht verfügbar"
      });
      return;
    }

    try {
      // Finde die FileGroup für dieses Item
      const itemStem = getBaseName(item.metadata.name);
      const fileGroup = findFileGroup(fileGroups, itemStem);

      if (fileGroup && item.id === fileGroup.baseItem?.id) {
        // Dies ist die Basis-Datei - benenne auch abhängige Dateien um
        const oldStem = getBaseName(item.metadata.name);
        const newStem = getBaseName(newName);
        // Benenne die Basis-Datei um
        await provider.renameItem(item.id, newName);
        // Benenne alle Transkripte um, falls vorhanden
        if (fileGroup.transcriptFiles) {
          for (const transcript of fileGroup.transcriptFiles) {
            const transcriptName = transcript.metadata.name;
            const newTranscriptName = transcriptName.replace(oldStem, newStem);
            try {
              await provider.renameItem(transcript.id, newTranscriptName);
            } catch (error) {
              FileLogger.error('FileList', 'Fehler beim Umbenennen des Transkripts', error);
              toast.warning("Hinweis", {
                description: "Einige Transkripte konnten nicht umbenannt werden"
              });
            }
          }
        }
        // Benenne die transformierte Datei um, falls vorhanden
        if (fileGroup.transformed) {
          const transformedName = fileGroup.transformed.metadata.name;
          const newTransformedName = transformedName.replace(oldStem, newStem);
          try {
            await provider.renameItem(fileGroup.transformed.id, newTransformedName);
          } catch (error) {
            FileLogger.error('FileList', 'Fehler beim Umbenennen der transformierten Datei', error);
            toast.warning("Hinweis", {
              description: "Die transformierte Datei konnte nicht umbenannt werden"
            });
          }
        }
        toast.success("Dateien umbenannt", {
          description: `${item.metadata.name} und zugehörige Dateien wurden umbenannt.`
        });
      } else {
        // Dies ist eine abhängige Datei oder keine Gruppe - nur diese Datei umbenennen
        await provider.renameItem(item.id, newName);
        toast.success("Datei umbenannt", {
          description: `${item.metadata.name} wurde zu ${newName} umbenannt.`
        });
      }
      await handleRefresh();
    } catch (error) {
      FileLogger.error('FileList', 'Fehler beim Umbenennen', error);
      toast.error("Fehler", {
        description: `Die Datei konnte nicht umbenannt werden: ${error instanceof Error ? error.message : 'Unbekannter Fehler'}`
      });
      throw error;
    }
  }, [provider, handleRefresh, fileGroups]);

  const handleBatchTranscription = () => {
    if (selectedBatchItems.length > 0) {
      setTranscriptionDialogOpen(true);
    }
  };

  const handleBatchTransformation = () => {
    if (selectedTransformationItems.length > 0) {
      setTransformationDialogOpen(true);
    }
  };

  // Bulk-Löschung für ausgewählte Dateien (unabhängig von Batch/Transformation-Selektor)
  const handleBulkDelete = React.useCallback(async () => {
    if (!provider) return;
    const targets = [
      ...selectedBatchItems.map(x => x.item),
      ...selectedTransformationItems.map(x => x.item),
    ];
    if (targets.length === 0) return;
    const confirmMsg = targets.length === 1
      ? `"${targets[0].metadata.name}" wirklich löschen?`
      : `${targets.length} Dateien wirklich löschen?`;
    if (!window.confirm(confirmMsg)) return;

    try {
      const parentId = targets[0].parentId || 'root';
      for (const t of targets) {
        try { await provider.deleteItem(t.id); } catch (err) {
          FileLogger.error('FileList', 'Bulk Delete failed', { id: t.id, name: t.metadata.name, err });
        }
      }
      const refreshed = await refreshItems(parentId);
      setFolderItems(refreshed);
      setSelectedBatchItems([]);
      setSelectedTransformationItems([]);
    } catch (error) {
      FileLogger.error('FileList', 'Bulk Delete error', error);
    }
  }, [provider, selectedBatchItems, selectedTransformationItems, refreshItems, setFolderItems, setSelectedBatchItems, setSelectedTransformationItems]);

  // Intelligente Batch-Auswahl basierend auf Filter
  const handleSelectAll = useCallback((checked: boolean) => {
    const startTime = performance.now();
    if (checked) {
      // Verwende nur die Hauptdateien (baseItem) aus den FileGroups
      const mainItems = Array.from((fileGroups ?? new Map()).values())
        .map(group => group.baseItem)
        .filter((item): item is StorageItem => item !== undefined);
      const selectableItems = mainItems.filter(item => {
        try {
          const mediaType = getMediaType(item);
          // Je nach Filter unterschiedliche Dateien auswählen
          switch (currentCategoryFilter) {
            case 'media':
              return item.type === 'file' && (mediaType === 'audio' || mediaType === 'video');
            case 'text':
              return item.type === 'file' && mediaType === 'text';
            case 'documents':
              return item.type === 'file' && mediaType === 'document';
            default:
              // Bei 'all' alle Dateien auswählen, die für eine Operation geeignet sind
              return item.type === 'file' && (
                mediaType === 'audio' || 
                mediaType === 'video' || 
                mediaType === 'text' || 
                mediaType === 'document'
              );
          }
        } catch {
          return false;
        }
      });
      StateLogger.info('FileList', 'Selecting all items based on filter', {
        filter: currentCategoryFilter,
        totalItems: items.length,
        selectableCount: selectableItems.length,
        duration: `${(performance.now() - startTime).toFixed(2)}ms`
      });
      // Je nach Filter unterschiedliche Atome verwenden
      if (currentCategoryFilter === 'media') {
        setSelectedBatchItems(selectableItems.map(item => ({
          item,
          type: getMediaType(item)
        })));
      } else if (currentCategoryFilter === 'text') {
        setSelectedTransformationItems(selectableItems.map(item => ({
          item,
          type: getMediaType(item)
        })));
      } else {
        // Bei 'all' oder 'documents' beide Atome füllen
        const mediaItems = selectableItems.filter(item => {
          const mediaType = getMediaType(item);
          return mediaType === 'audio' || mediaType === 'video';
        });
        const textItems = selectableItems.filter(item => {
          const mediaType = getMediaType(item);
          return mediaType === 'text' || mediaType === 'document';
        });
        setSelectedBatchItems(mediaItems.map(item => ({
          item,
          type: getMediaType(item)
        })));
        setSelectedTransformationItems(textItems.map(item => ({
          item,
          type: getMediaType(item)
        })));
      }
    } else {
      StateLogger.info('FileList', 'Deselecting all items', {
        previouslySelected: selectedBatchItems.length + selectedTransformationItems.length,
        duration: `${(performance.now() - startTime).toFixed(2)}ms`
      });
      setSelectedBatchItems([]);
      setSelectedTransformationItems([]);
    }
  }, [fileGroups, currentCategoryFilter, setSelectedBatchItems, setSelectedTransformationItems, selectedBatchItems.length, selectedTransformationItems.length, items.length]);

  React.useEffect(() => {
    // Logging der Library-IDs - verzögert ausführen
    const timeoutId = setTimeout(() => {
      StateLogger.debug('FileList', 'Render', {
        currentLibraryId: currentLibrary?.id,
        activeLibraryIdAtom: activeLibraryId
      });
    }, 0);
    
    return () => clearTimeout(timeoutId);
  }, [currentLibrary, activeLibraryId]);

  // Entkoppelt: kein Render-Gate mehr basierend auf FileTree

  return (
    <div className="h-full flex flex-col">
      {/* Header - versteckt im compact mode */}
      {!compact && (
        <div className="border-b px-2 py-2 flex items-center justify-between bg-background sticky top-0 z-10">
          <div className="flex items-center gap-2">
            <Button
              variant="ghost"
              size="icon"
              className="h-8 w-8"
              onClick={handleRefresh}
              disabled={isRefreshing}
              title="Aktualisieren"
              aria-label="Aktualisieren"
            >
              <RefreshCw className={cn("h-4 w-4", isRefreshing && "animate-spin")} />
            </Button>

            {/* Dateikategorie-Filter (Icon-only Variante) */}
            <FileCategoryFilter iconOnly />

            {/* Batch-Actions als Icons */}
            {selectedBatchItems.length > 0 && (
              <Button size="icon" title="Transkribieren" aria-label="Transkribieren" onClick={handleBatchTranscription}>
                <ScrollText className="h-4 w-4" />
              </Button>
            )}
            {selectedTransformationItems.length > 0 && (
              <Button size="icon" variant="secondary" title="Transformieren" aria-label="Transformieren" onClick={handleBatchTransformation}>
                <Plus className="h-4 w-4" />
              </Button>
            )}
            {(selectedBatchItems.length + selectedTransformationItems.length) > 0 && (
              <Button size="icon" variant="destructive" title="Ausgewählte löschen" aria-label="Ausgewählte löschen" onClick={handleBulkDelete}>
                <Trash2 className="h-4 w-4" />
              </Button>
            )}
          </div>
        </div>
      )}

      {/* File List */}
      <div className="flex-1 overflow-auto">
        <div>
          {/* Table Header - versteckt im compact mode */}
          {!compact && (
            <div className="sticky top-0 bg-background border-b">
              <div className="grid grid-cols-[24px_24px_minmax(0,1fr)_56px_88px_auto] gap-2 px-4 py-2 text-sm font-medium text-muted-foreground">
                <div className="w-6 flex items-center justify-center">
                  <Checkbox
                    checked={isAllSelected}
                    onCheckedChange={handleSelectAll}
                    aria-label="Alle auswählen"
                  />
                </div>
                <div className="w-6" />
                <SortableHeaderCell
                  label="Name"
                  field="name"
                  currentSortField={sortField}
                  currentSortOrder={sortOrder}
                  onSort={handleSort}
                />
                <SortableHeaderCell
                  label="Größe"
                  field="size"
                  currentSortField={sortField}
                  currentSortOrder={sortOrder}
                  onSort={handleSort}
                />
                <SortableHeaderCell
                  label="Geändert"
                  field="date"
                  currentSortField={sortField}
                  currentSortOrder={sortOrder}
                  onSort={handleSort}
                />
                <div />
              </div>
            </div>
          )}

          {/* Folder Rows (oberhalb der Dateien, unabhängig von Datei-Gruppierung) */}
          {folders.length > 0 && (
            <div className="divide-y">
              {folders.map((folder) => (
                <div
                  key={folder.id}
                  role="button"
                  tabIndex={0}
                  onClick={() => navigateToFolder(folder.id)}
                  onKeyDown={(e) => {
                    if (e.key === 'Enter' || e.key === ' ') navigateToFolder(folder.id);
                  }}
                  className="w-full px-4 py-2 text-xs hover:bg-muted/50 grid grid-cols-[24px_24px_minmax(0,1fr)_56px_88px_auto] gap-2 items-center cursor-pointer"
                >
                  <div />
                  <FolderIcon className="h-4 w-4" />
                  <span className="text-left truncate select-none" title={folder.metadata.name}>{folder.metadata.name}</span>
                  <span className="text-muted-foreground" />
                  <span className="text-muted-foreground" />
                  <div />
                </div>
              ))}
            </div>
          )}

          {/* File Rows */}
          <div className="divide-y">
            {Array.from((fileGroups ?? new Map()).values())
              .map((group) => {
                // Zeige nur die Hauptdatei (baseItem) an
                const item = group.baseItem;
                if (!item) return null;
                // System-Unterordner-Id, wenn ein ".<basename>"-Folder existiert
                const systemFolder = systemFolderByBase.get(getBaseName(item.metadata.name));
                const systemFolderId = systemFolder?.id;
                const isActive = !!activeFile && activeFile.id === item.id
                return (
                  <FileRow
                    key={item.id}
                    item={item as StorageItem}
                    isSelected={isItemSelected(item)}
                    isActive={isActive}
                    onSelect={() => handleSelect(item, group)}
                    onCreateTranscript={handleCreateTranscript}
                    onDelete={(e) => handleDeleteClick(e, item)}
                    fileGroup={group}
                    onSelectRelatedFile={handleSelectRelatedFile}
                    onRename={handleRename}
                    compact={compact}
                    systemFolderId={systemFolderId}
                  />
                );
              })}
          </div>
        </div>
      </div>
    </div>
  );
}); 
```

```typescriptreact
'use client';

import * as React from "react"
import { File, FileText, FileVideo, FileAudio, Plus, RefreshCw, ChevronUp, ChevronDown, Trash2, ScrollText, Folder as FolderIcon, Layers } from "lucide-react"
import { StorageItem } from "@/lib/storage/types"
import { cn } from "@/lib/utils"
import { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from "@/components/ui/tooltip"
import { useStorage } from "@/contexts/storage-context";
import { Button } from "@/components/ui/button";
import { useAtomValue, useAtom } from 'jotai';
import { jobStatusByItemIdAtom } from '@/atoms/job-status';
import { 
  activeLibraryIdAtom, 
  selectedFileAtom, 
  folderItemsAtom,
  sortedFilteredFilesAtom,
  sortFieldAtom,
  sortOrderAtom,
  selectedShadowTwinAtom
} from '@/atoms/library-atom';
import { toast } from "sonner";
import { Input } from "@/components/ui/input"
import {
  selectedBatchItemsAtom,
  transcriptionDialogOpenAtom,
  selectedTransformationItemsAtom,
  transformationDialogOpenAtom,
  getMediaType,
  fileCategoryFilterAtom,
} from '@/atoms/transcription-options';
import { Checkbox } from "@/components/ui/checkbox"
import { useMemo, useCallback } from "react"
import { FileLogger, StateLogger } from "@/lib/debug/logger"
import { FileCategoryFilter } from './file-category-filter';
import { useFolderNavigation } from "@/hooks/use-folder-navigation";

// Typen für Sortieroptionen
type SortField = 'type' | 'name' | 'size' | 'date';
type SortOrder = 'asc' | 'desc';

// Typ für gruppierte Dateien
interface FileGroup {
  baseItem?: StorageItem;
  transcriptFiles?: StorageItem[]; // NEU: alle Transkripte
  transformed?: StorageItem;
}

// Memoized file icon component
const FileIconComponent = React.memo(function FileIconComponent({ item }: { item: StorageItem }) {
  const mimeType = item.metadata.mimeType || '';
  if (!mimeType) return <File className="h-4 w-4" />;

  if (mimeType.startsWith('video/')) {
    return <FileVideo className="h-4 w-4" />;
  } else if (mimeType.startsWith('audio/')) {
    return <FileAudio className="h-4 w-4" />;
  } else if (mimeType.startsWith('text/')) {
    return <FileText className="h-4 w-4" />;
  }

  return <File className="h-4 w-4" />;
});

// Pure function for file size formatting
const formatFileSize = (size?: number): string => {
  if (!size) return '-';
  const units = ['B', 'KB', 'MB', 'GB'];
  let value = size;
  let unitIndex = 0;
  
  while (value >= 1024 && unitIndex < units.length - 1) {
    value /= 1024;
    unitIndex++;
  }
  
  return `${value.toFixed(1)} ${units[unitIndex]}`;
};

// Funktion zum Formatieren des Datums
const formatDate = (date?: Date): string => {
  if (!date) return '-';
  
  const options: Intl.DateTimeFormatOptions = { 
    year: '2-digit', 
    month: '2-digit', 
    day: '2-digit',
    hour: '2-digit',
    minute: '2-digit'
  };
  
  return new Date(date).toLocaleDateString('de-DE', options);
};

// Entfernt: getFileStem Funktion war unbenutzt

// Sortierbare Kopfzelle Komponente
const SortableHeaderCell = React.memo(function SortableHeaderCell({
  label,
  field,
  currentSortField,
  currentSortOrder,
  onSort
}: {
  label: string,
  field: SortField,
  currentSortField: SortField,
  currentSortOrder: SortOrder,
  onSort: (field: SortField) => void
}) {
  const isActive = currentSortField === field;
  
  return (
    <button 
      onClick={() => onSort(field)}
      className="flex items-center gap-1 hover:text-foreground"
    >
      <span>{label}</span>
      {isActive && (
        currentSortOrder === 'asc' 
          ? <ChevronUp className="h-3 w-3" /> 
          : <ChevronDown className="h-3 w-3" />
      )}
    </button>
  );
});

interface FileRowProps {
  item: StorageItem;
  isSelected: boolean;
  isActive?: boolean;
  onSelect: () => void;
  onCreateTranscript: (e: React.MouseEvent) => void;
  onDelete: (e: React.MouseEvent<HTMLButtonElement>, item: StorageItem) => void;
  fileGroup?: FileGroup;
  onSelectRelatedFile?: (file: StorageItem) => void;
  onRename?: (item: StorageItem, newName: string) => Promise<void>;
  compact?: boolean;
  systemFolderId?: string;
}

const FileRow = React.memo(function FileRow({ 
  item, 
  isSelected, 
  isActive = false,
  onSelect,
  onCreateTranscript,
  onDelete,
  fileGroup,
  onSelectRelatedFile,
  onRename,
  compact = false,
  systemFolderId
}: FileRowProps) {
  const navigateToFolder = useFolderNavigation();
  const [isEditing, setIsEditing] = React.useState(false);
  const [editName, setEditName] = React.useState(item.metadata.name);
  const inputRef = React.useRef<HTMLInputElement>(null);
  const longPressTimerRef = React.useRef<NodeJS.Timeout | null>(null);
  const lastClickTimeRef = React.useRef<number>(0);
  
  // Zusätzliche Validierung der Metadaten
  const metadata = React.useMemo(() => ({
    name: item.metadata?.name || 'Unbekannte Datei',
    size: typeof item.metadata?.size === 'number' ? item.metadata.size : 0,
    mimeType: item.metadata?.mimeType || '',
    hasTranscript: !!item.metadata?.hasTranscript || (fileGroup?.transcriptFiles && fileGroup.transcriptFiles.length > 0),
    modifiedAt: item.metadata?.modifiedAt
  }), [item.metadata, fileGroup]);

  const isTranscribable = React.useMemo(() => {
    const mimeType = metadata.mimeType.toLowerCase();
    const extension = metadata.name.split('.').pop()?.toLowerCase();

    return (
      mimeType.startsWith('audio/') ||
      mimeType.startsWith('video/') ||
      extension === 'pdf' ||
      mimeType === 'application/pdf'
    );
  }, [metadata.mimeType, metadata.name]);

  // Memoize the click handler
  const handleClick = React.useCallback(() => {
    if (!isEditing) {
      onSelect();
    }
  }, [onSelect, isEditing]);

  // Memoize the keydown handler
  const handleKeyDown = React.useCallback((e: React.KeyboardEvent) => {
    if (!isEditing && (e.key === 'Enter' || e.key === ' ')) {
      onSelect();
    }
  }, [onSelect, isEditing]);

  // Handler für Transkript-Icon Click
  const handleTranscriptClick = React.useCallback((e: React.MouseEvent) => {
    e.stopPropagation();
    if (fileGroup?.transcriptFiles && onSelectRelatedFile) {
      onSelectRelatedFile(fileGroup.transcriptFiles[0]); // Nur das erste Transkript anzeigen
    }
  }, [fileGroup, onSelectRelatedFile]);

  // Handler für Transformierte-Datei-Icon Click
  const handleTransformedClick = React.useCallback((e: React.MouseEvent) => {
    e.stopPropagation();
    if (fileGroup?.transformed && onSelectRelatedFile) {
      onSelectRelatedFile(fileGroup.transformed);
    }
  }, [fileGroup, onSelectRelatedFile]);

  // Starte Rename-Modus
  const startRename = React.useCallback(() => {
    if (onRename) {
      // Prüfe ob dies eine abhängige Datei ist
      if (fileGroup && (
        (fileGroup.transcriptFiles && fileGroup.transcriptFiles.length > 0 && fileGroup.transcriptFiles[0]?.id === item.id) ||
        (fileGroup.transformed && item.id === fileGroup.transformed.id)
      )) {
        // Dies ist eine abhängige Datei - zeige Hinweis
        toast.info("Hinweis", {
          description: "Bitte benennen Sie die Haupt-Datei um. Abhängige Dateien werden automatisch mit umbenannt."
        });
        return;
      }
      
      setIsEditing(true);
      setEditName(item.metadata.name);
    }
  }, [onRename, item, fileGroup]);

  // Handler für Dateinamen-Click (Doppelklick-Erkennung)
  const handleNameClick = React.useCallback((e: React.MouseEvent) => {
    e.stopPropagation();
    
    const currentTime = Date.now();
    const timeSinceLastClick = currentTime - lastClickTimeRef.current;
    
    if (timeSinceLastClick < 300) {
      // Doppelklick erkannt
      startRename();
    } else {
      // Erster Klick - wähle die Datei aus
      onSelect();
    }
    
    lastClickTimeRef.current = currentTime;
  }, [startRename, onSelect]);

  // Handler für Long-Press (Touch-Geräte)
  const handleTouchStart = React.useCallback((e: React.TouchEvent) => {
    e.stopPropagation();
    
    // Starte Long-Press Timer
    longPressTimerRef.current = setTimeout(() => {
      startRename();
    }, 500); // 500ms für Long-Press
  }, [startRename]);

  const handleTouchEnd = React.useCallback((e: React.TouchEvent) => {
    e.stopPropagation();
    
    // Lösche Long-Press Timer
    if (longPressTimerRef.current) {
      clearTimeout(longPressTimerRef.current);
      longPressTimerRef.current = null;
    }
  }, []);

  const handleTouchMove = React.useCallback(() => {
    // Bei Bewegung Long-Press abbrechen
    if (longPressTimerRef.current) {
      clearTimeout(longPressTimerRef.current);
      longPressTimerRef.current = null;
    }
  }, []);

  // Cleanup Timer bei Unmount
  React.useEffect(() => {
    return () => {
      if (longPressTimerRef.current) {
        clearTimeout(longPressTimerRef.current);
      }
    };
  }, []);

  // Handler für Rename-Submit
  const handleRenameSubmit = React.useCallback(async () => {
    if (onRename && editName.trim() && editName !== item.metadata.name) {
      try {
        await onRename(item, editName.trim());
      } catch (error) {
        FileLogger.error('FileRow', 'Fehler beim Umbenennen', error);
        // Bei Fehler den ursprünglichen Namen wiederherstellen
        setEditName(item.metadata.name);
      }
    }
    setIsEditing(false);
  }, [onRename, editName, item]);

  // Handler für Rename-Cancel
  const handleRenameCancel = React.useCallback(() => {
    setEditName(item.metadata.name);
    setIsEditing(false);
  }, [item.metadata.name]);

  // Handler für Input-Änderungen
  const handleInputChange = React.useCallback((e: React.ChangeEvent<HTMLInputElement>) => {
    setEditName(e.target.value);
  }, []);

  // Handler für Input-Keydown
  const handleInputKeyDown = React.useCallback((e: React.KeyboardEvent<HTMLInputElement>) => {
    e.stopPropagation();
    if (e.key === 'Enter') {
      handleRenameSubmit();
    } else if (e.key === 'Escape') {
      handleRenameCancel();
    }
  }, [handleRenameSubmit, handleRenameCancel]);

  // Focus Input wenn Edit-Modus aktiviert wird
  React.useEffect(() => {
    if (isEditing && inputRef.current) {
      inputRef.current.focus();
      inputRef.current.select();
    }
  }, [isEditing]);

  // Handler für Drag Start
  const handleDragStart = React.useCallback((e: React.DragEvent) => {
    // Sammle alle Dateien der Gruppe, die verschoben werden sollen
    const itemsToMove = [];
    
    // Füge das aktuelle Item hinzu
    itemsToMove.push({
      itemId: item.id,
      itemName: item.metadata.name,
      itemType: item.type,
      parentId: item.parentId
    });
    
    // Wenn es eine FileGroup gibt, füge auch die zugehörigen Dateien hinzu
    if (fileGroup) {
      // Prüfe ob das aktuelle Item die Basis-Datei ist
      if (item.id === fileGroup.baseItem?.id) {
        // Füge Transkripte hinzu, falls vorhanden
        if (fileGroup.transcriptFiles && fileGroup.transcriptFiles.length > 0) {
          fileGroup.transcriptFiles.forEach(transcript => {
            itemsToMove.push({
              itemId: transcript.id,
              itemName: transcript.metadata.name,
              itemType: transcript.type,
              parentId: transcript.parentId
            });
          });
        }
        
        // Füge transformierte Datei hinzu, falls vorhanden
        if (fileGroup.transformed) {
          itemsToMove.push({
            itemId: fileGroup.transformed.id,
            itemName: fileGroup.transformed.metadata.name,
            itemType: fileGroup.transformed.type,
            parentId: fileGroup.transformed.parentId
          });
        }
      }
    }
    
    // Setze die Drag-Daten
    e.dataTransfer.effectAllowed = 'move';
    e.dataTransfer.setData('application/json', JSON.stringify({
      items: itemsToMove,
      isFileGroup: itemsToMove.length > 1
    }));
    
    // Visuelles Feedback
    if (e.currentTarget instanceof HTMLElement) {
      e.currentTarget.style.opacity = '0.5';
    }
  }, [item, fileGroup]);

  // Handler für Drag End
  const handleDragEnd = React.useCallback((e: React.DragEvent) => {
    // Stelle Opacity wieder her
    if (e.currentTarget instanceof HTMLElement) {
      e.currentTarget.style.opacity = '1';
    }
  }, []);

  const [selectedBatchItems, setSelectedBatchItems] = useAtom(selectedBatchItemsAtom);
  const [selectedTransformationItems, setSelectedTransformationItems] = useAtom(selectedTransformationItemsAtom);
  
  // Prüfe ob das Item in einem der beiden Atome ausgewählt ist
  const isInBatch = selectedBatchItems.some(batchItem => batchItem.item.id === item.id);
  const isInTransformation = selectedTransformationItems.some(transformationItem => transformationItem.item.id === item.id);
  const isInAnyBatch = isInBatch || isInTransformation;

  // Handler für Checkbox-Änderungen
  const handleCheckboxChange = React.useCallback((checked: boolean) => {
    const mediaType = getMediaType(item);
    
    if (mediaType === 'audio' || mediaType === 'video') {
      // Für Audio/Video: Transcription-Atom verwenden
      if (checked) {
        setSelectedBatchItems([...selectedBatchItems, {
          item,
          type: mediaType
        }]);
      } else {
        setSelectedBatchItems(selectedBatchItems.filter(i => i.item.id !== item.id));
      }
    } else if (mediaType === 'text' || mediaType === 'document') {
      // Für Text/Dokumente: Transformation-Atom verwenden
      if (checked) {
        setSelectedTransformationItems([...selectedTransformationItems, {
          item,
          type: mediaType
        }]);
      } else {
        setSelectedTransformationItems(selectedTransformationItems.filter(i => i.item.id !== item.id));
      }
    }
  }, [item, selectedBatchItems, selectedTransformationItems, setSelectedBatchItems, setSelectedTransformationItems]);

  React.useEffect(() => {
    if (fileGroup) {
      FileLogger.debug('FileRow', 'Transkripte für Zeile', {
        baseItem: fileGroup.baseItem?.metadata.name,
        transcripts: fileGroup.transcriptFiles?.map(t => t.metadata.name)
      });
    }
  }, [fileGroup]);

  // Zentraler Jobstatus (muss vor möglichen early-returns stehen, um Hook-Order zu garantieren)
  const jobStatusMap = useAtomValue(jobStatusByItemIdAtom);
  const jobStatus = jobStatusMap[item.id];
  const jobStatusIcon = jobStatus ? (
    <span title={jobStatus} className={cn('inline-block h-3 w-3 rounded-full',
      jobStatus === 'queued' && 'bg-blue-600',
      jobStatus === 'running' && 'bg-yellow-600',
      jobStatus === 'completed' && 'bg-green-600',
      jobStatus === 'failed' && 'bg-red-600'
    )} aria-label={`job-${jobStatus}`} />
  ) : null;

  // Compact-Modus: vereinfachte Darstellung
  if (compact) {
    return (
      <div
        role="button"
        tabIndex={0}
        onClick={handleClick}
        onKeyDown={handleKeyDown}
        className={cn(
          "w-full px-2 py-1 text-sm hover:bg-muted/50 flex items-center gap-2 cursor-pointer",
          isSelected && "bg-muted",
          isActive && "bg-primary/10 border-l-2 border-primary"
        )}
      >
        <FileIconComponent item={item} />
        <span className={cn("truncate flex-1", isActive && "font-medium") } title={metadata.name}>
          {metadata.name}
        </span>
        {/* Shadow-Twin-Symbole im compact mode */}
        {fileGroup?.transcriptFiles && fileGroup.transcriptFiles.length > 0 && (
          <Button
            variant="ghost"
            size="icon"
            className="h-4 w-4 p-0 hover:bg-muted text-muted-foreground hover:text-foreground"
            onClick={handleTranscriptClick}
          >
            <ScrollText className="h-3 w-3" />
          </Button>
        )}
      </div>
    );
  }

  return (
    <div
      role="button"
      tabIndex={0}
      onClick={handleClick}
      onKeyDown={handleKeyDown}
      onTouchStart={handleTouchStart}
      onTouchEnd={handleTouchEnd}
      onTouchMove={handleTouchMove}
      draggable={!isEditing}
      onDragStart={handleDragStart}
      onDragEnd={handleDragEnd}
      className={cn(
        "w-full px-4 py-2 text-xs hover:bg-muted/50 grid grid-cols-[24px_24px_minmax(0,1fr)_56px_88px_auto] gap-2 items-center cursor-move",
        isSelected && "bg-muted",
        isActive && "bg-primary/10 border-l-2 border-primary"
      )}
    >
      <div className="w-6 flex items-center justify-center">
        <Checkbox
          checked={isInAnyBatch}
          onCheckedChange={handleCheckboxChange}
          onClick={(e) => e.stopPropagation()}
        />
      </div>
      <FileIconComponent item={item} />
      {isEditing ? (
        <Input
          ref={inputRef}
          value={editName}
          onChange={handleInputChange}
          onKeyDown={handleInputKeyDown}
          onBlur={handleRenameSubmit}
          onClick={(e) => e.stopPropagation()}
          className="h-6 px-1 py-0 text-xs"
        />
      ) : (
        <span 
          className={cn("text-left truncate cursor-pointer hover:text-primary select-none", isActive && "font-medium")}
          onClick={handleNameClick}
          onTouchStart={handleTouchStart}
          onTouchEnd={handleTouchEnd}
          onTouchMove={handleTouchMove}
          title={metadata.name}
        >
          {metadata.name}
        </span>
      )}
      <span className="text-muted-foreground tabular-nums text-[10px]">
        {formatFileSize(metadata.size)}
      </span>
      <span className="text-muted-foreground tabular-nums text-[10px]">
        {formatDate(metadata.modifiedAt)}
      </span>
      <div className="flex items-center justify-start gap-1">
        {jobStatusIcon}
        {/* System-Unterordner (z. B. extrahierte Seiten) */}
        {systemFolderId && (
          <TooltipProvider>
            <Tooltip>
              <TooltipTrigger asChild>
                <Button
                  variant="ghost"
                  size="icon"
                  className="h-6 w-6 p-0 hover:bg-muted"
                  onClick={(e) => {
                    e.stopPropagation();
                    navigateToFolder(systemFolderId);
                  }}
                >
                  <Layers className="h-4 w-4 text-violet-500" />
                </Button>
              </TooltipTrigger>
              <TooltipContent>
                <p>Seiten-Ordner öffnen</p>
              </TooltipContent>
            </Tooltip>
          </TooltipProvider>
        )}
        {/* Zeige Icons für alle vorhandenen Transkripte */}
        {fileGroup?.transcriptFiles && fileGroup.transcriptFiles.length > 0 && fileGroup.transcriptFiles.map((transcript) => (
          <TooltipProvider key={transcript.id}>
            <Tooltip>
              <TooltipTrigger asChild>
                <Button
                  variant="ghost"
                  size="icon"
                  className="h-6 w-6 p-0 hover:bg-muted"
                  onClick={(e) => {
                    e.stopPropagation();
                    if (onSelectRelatedFile) onSelectRelatedFile(transcript);
                  }}
                >
                  <FileText className="h-4 w-4 text-blue-500" />
                </Button>
              </TooltipTrigger>
              <TooltipContent>
                <p>Transkript anzeigen: {transcript.metadata.name}</p>
              </TooltipContent>
            </Tooltip>
          </TooltipProvider>
        ))}
        {/* Plus-Symbol nur anzeigen, wenn kein Transkript vorhanden und transkribierbar */}
        {(!fileGroup?.transcriptFiles || fileGroup.transcriptFiles.length === 0) && isTranscribable && !metadata.hasTranscript ? (
          <TooltipProvider>
            <Tooltip>
              <TooltipTrigger asChild>
                <div 
                  role="button"
                  tabIndex={0}
                  className="h-6 w-6 p-0 inline-flex items-center justify-center hover:bg-muted rounded-sm"
                  onClick={onCreateTranscript}
                  onKeyDown={(e) => {
                    if (e.key === 'Enter' || e.key === ' ') {
                      e.stopPropagation();
                      onCreateTranscript(e as unknown as React.MouseEvent<HTMLDivElement>);
                    }
                  }}
                >
                  <Plus className="h-4 w-4" />
                </div>
              </TooltipTrigger>
              <TooltipContent>
                <p>Transkript erstellen</p>
              </TooltipContent>
            </Tooltip>
          </TooltipProvider>
        ) : null}
        {/* Icon für transformierte Datei */}
        {fileGroup?.transformed && (
          <TooltipProvider>
            <Tooltip>
              <TooltipTrigger asChild>
                <Button
                  variant="ghost"
                  size="icon"
                  className="h-6 w-6 p-0 hover:bg-muted"
                  onClick={handleTransformedClick}
                >
                  <ScrollText className="h-4 w-4 text-green-500" />
                </Button>
              </TooltipTrigger>
              <TooltipContent>
                <p>Transformierte Datei anzeigen</p>
              </TooltipContent>
            </Tooltip>
          </TooltipProvider>
        )}
        {/* Delete direkt neben Dokument-Icons */}
        <TooltipProvider>
          <Tooltip>
            <TooltipTrigger asChild>
              <Button
                variant="ghost"
                size="icon"
                className="h-6 w-6 p-0 hover:bg-destructive/10 hover:text-destructive"
                onClick={(e) => onDelete(e as React.MouseEvent<HTMLButtonElement>, item)}
              >
                <Trash2 className="h-4 w-4" />
              </Button>
            </TooltipTrigger>
            <TooltipContent>
              <p>Datei löschen</p>
            </TooltipContent>
          </Tooltip>
        </TooltipProvider>
      </div>
      <div />
    </div>
  );
});

interface FileListProps {
  compact?: boolean;
}

export const FileList = React.memo(function FileList({ compact = false }: FileListProps): JSX.Element {
  const { provider, refreshItems, currentLibrary } = useStorage();
  const activeLibraryId = useAtomValue(activeLibraryIdAtom);
  const [isRefreshing, setIsRefreshing] = React.useState(false);
  // Mobile-Flag wurde entfernt, FileList lädt unabhängig vom View
  const [selectedBatchItems, setSelectedBatchItems] = useAtom(selectedBatchItemsAtom);
  const [selectedTransformationItems, setSelectedTransformationItems] = useAtom(selectedTransformationItemsAtom);
  const [, setTranscriptionDialogOpen] = useAtom(transcriptionDialogOpenAtom);
  const [, setTransformationDialogOpen] = useAtom(transformationDialogOpenAtom);
  const [isInitialized, setIsInitialized] = React.useState(false);
  const initializationTimeoutRef = React.useRef<NodeJS.Timeout | null>(null);
  // Entkoppelt: Kein Warten mehr auf FileTree-Status
  const [activeFile, setSelectedFile] = useAtom(selectedFileAtom);
  const [, setFolderItems] = useAtom(folderItemsAtom);
  const currentCategoryFilter = useAtomValue(fileCategoryFilterAtom);
  const allItemsInFolder = useAtomValue(folderItemsAtom);
  const navigateToFolder = useFolderNavigation();

  // Kein mobiles Flag mehr notwendig

  const folders = useMemo(() => {
    const items = allItemsInFolder ?? [];
    // Verstecke dot-Verzeichnisse generell in der Liste
    return items.filter(item => item.type === 'folder' && !item.metadata.name.startsWith('.'));
  }, [allItemsInFolder]);

  // Hilfsfunktion zum Finden einer FileGroup in der Map
  const findFileGroup = (map: Map<string, FileGroup>, stem: string): FileGroup | undefined => {
    return Array.from((map ?? new Map()).values()).find(group => 
      group.baseItem && getBaseName(group.baseItem.metadata.name) === stem
    );
  };

  // NEU: Atome für Sortierung und Filter
  const items = useAtomValue(sortedFilteredFilesAtom);
  const [sortField, setSortField] = useAtom(sortFieldAtom);
  const [sortOrder, setSortOrder] = useAtom(sortOrderAtom);
  
  // Review-Mode-Atoms
  const [, setSelectedShadowTwin] = useAtom(selectedShadowTwinAtom);

  // handleSort nutzt jetzt Atome
  const handleSort = React.useCallback((field: SortField) => {
    if (field === sortField) setSortOrder(sortOrder === 'asc' ? 'desc' : 'asc');
    else {
      setSortField(field);
      setSortOrder('asc');
    }
  }, [sortField, sortOrder, setSortField, setSortOrder]);

  // Initialisierung - nur auf Provider und Mobile-Flag achten
  React.useEffect(() => {
    if (!provider) {
      FileLogger.info('FileList', 'Waiting for provider');
      return;
    }

    const initialize = async () => {
      if (isInitialized) {
        FileLogger.debug('FileList', 'Already initialized');
        return;
      }

      FileLogger.info('FileList', 'Starting initialization');

      try {
        FileLogger.info('FileList', 'Initialization complete');
        setIsInitialized(true);
      } catch (error) {
        FileLogger.error('FileList', 'Error initializing FileList', error);
      }
    };

    initialize();

    const timeoutRef = initializationTimeoutRef.current;
    return () => {
      if (timeoutRef) clearTimeout(timeoutRef);
    };
  }, [provider, isInitialized]);

  // NEU: Reagieren auf Bibliothekswechsel
  const prevLibraryIdRef = React.useRef<string | null>(null);
  React.useEffect(() => {
    StateLogger.debug('FileList', 'Render', {
      currentLibraryId: activeLibraryId,
      activeLibraryIdAtom: activeLibraryId
    });

    // Nur bei tatsächlichem Bibliothekswechsel zurücksetzen
    if (prevLibraryIdRef.current !== null && prevLibraryIdRef.current !== activeLibraryId) {
      setIsInitialized(false);
      setSelectedFile(null);
      setFolderItems([]);
      setSelectedBatchItems([]);
      setSelectedTransformationItems([]);
      setSelectedShadowTwin(null);
      StateLogger.info('FileList', 'Bibliothek gewechselt - State zurückgesetzt', {
        libraryId: activeLibraryId
      });
    }
    prevLibraryIdRef.current = activeLibraryId;
  }, [activeLibraryId, setSelectedFile, setFolderItems, setSelectedBatchItems, setSelectedTransformationItems, setSelectedShadowTwin]);

  // Vereinfachte Funktion zum Extrahieren des Basisnamens (ohne Endung, auch für Binärdateien)
  function getBaseName(name: string): string {
    // ShadowTwin: .de.md, .en.md, etc.
    const shadowTwinMatch = name.match(/^(.*)\.(de|en|fr|es|it)\.md$/);
    if (shadowTwinMatch) return shadowTwinMatch[1];
    // Sonst: alles vor der letzten Endung
    const lastDot = name.lastIndexOf('.');
    if (lastDot === -1) return name;
    return name.substring(0, lastDot);
  }

  // Prüft ob eine Datei ein ShadowTwin ist (Markdown mit Sprachkürzel)
  function isShadowTwin(name: string): boolean {
    // Pattern: name.de.md, name.en.md, etc.
    const shadowTwinPattern = /^(.+)\.(de|en|fr|es|it)\.md$/;
    return shadowTwinPattern.test(name);
  }

  // Gruppiere die Dateien nach Basename
  const fileGroups = useMemo(() => {
    if (!items) return new Map<string, FileGroup>();

    // Schritt 1: Gruppiere alle Dateien nach Basename
    const groupsMap = new Map<string, StorageItem[]>();
    for (const item of items) {
      if (item.type !== 'file') continue;
      const base = getBaseName(item.metadata.name);
      if (!groupsMap.has(base)) groupsMap.set(base, []);
      groupsMap.get(base)!.push(item);
    }

    // Schritt 2: Erstelle FileGroups
    const fileGroupsMap = new Map<string, FileGroup>();
    for (const [base, groupItems] of Array.from(groupsMap.entries())) {
      // Finde Hauptdatei (erste Nicht-ShadowTwin-Datei)
      const mainFile = groupItems.find((item) => !isShadowTwin(item.metadata.name));
      // Finde alle ShadowTwins
      const shadowTwins = groupItems.filter((item) => isShadowTwin(item.metadata.name));
      if (mainFile) {
        fileGroupsMap.set(base, {
          baseItem: mainFile,
          transcriptFiles: shadowTwins.length > 0 ? shadowTwins : undefined,
          transformed: undefined
        });
      } else {
        // Keine Hauptdatei: Jede ShadowTwin einzeln anzeigen
        for (const twin of shadowTwins) {
          fileGroupsMap.set(`${base}__shadow_${twin.id}`, {
            baseItem: twin,
            transcriptFiles: undefined,
            transformed: undefined
          });
        }
      }
    }
    // Debug-Logging für Gruppierung
    FileLogger.debug('FileList', 'Gruppierung Ergebnis (Basename, alle Endungen)', {
      groups: Array.from(fileGroupsMap.entries()).map(([base, group]) => ({
        base,
        baseItem: group.baseItem?.metadata.name,
        transcripts: group.transcriptFiles?.map(t => t.metadata.name)
      }))
    });
    return fileGroupsMap;
  }, [items]);

  // Mapping: Basename -> dot-Systemordner (z. B. ".<basename>")
  const systemFolderByBase = useMemo(() => {
    const map = new Map<string, StorageItem>();
    const items = allItemsInFolder ?? [];
    for (const it of items) {
      if (it.type !== 'folder') continue;
      const name = it.metadata.name;
      if (!name.startsWith('.')) continue;
      const base = name.slice(1);
      if (base) map.set(base, it);
    }
    return map;
  }, [allItemsInFolder]);

  // Berechne, ob alle Dateien ausgewählt sind
  const isAllSelected = useMemo(() => {
    if (!fileGroups || !fileGroups.size) return false;
    // Verwende nur die Hauptdateien (baseItem) aus den FileGroups
    const mainItems = Array.from((fileGroups ?? new Map()).values())
      .map(group => group.baseItem)
      .filter((item): item is StorageItem => item !== undefined);
    // Je nach Filter unterschiedliche Dateien zählen
    let selectableItems: StorageItem[] = [];
    switch (currentCategoryFilter) {
      case 'media':
        selectableItems = mainItems.filter(item => {
          try {
            const mediaType = getMediaType(item);
            return item.type === 'file' && (mediaType === 'audio' || mediaType === 'video');
          } catch {
            return false;
          }
        });
        return selectableItems.length > 0 && selectedBatchItems.length === selectableItems.length;
      case 'text':
        selectableItems = mainItems.filter(item => {
          try {
            const mediaType = getMediaType(item);
            return item.type === 'file' && mediaType === 'text';
          } catch {
            return false;
          }
        });
        return selectableItems.length > 0 && selectedTransformationItems.length === selectableItems.length;
      case 'documents':
        selectableItems = mainItems.filter(item => {
          try {
            const mediaType = getMediaType(item);
            return item.type === 'file' && mediaType === 'document';
          } catch {
            return false;
          }
        });
        return selectableItems.length > 0 && selectedTransformationItems.length === selectableItems.length;
      default:
        // Bei 'all' prüfen ob alle verfügbaren Dateien ausgewählt sind
        const mediaItems = mainItems.filter(item => {
          try {
            const mediaType = getMediaType(item);
            return item.type === 'file' && (mediaType === 'audio' || mediaType === 'video');
          } catch {
            return false;
          }
        });
        const textItems = mainItems.filter(item => {
          try {
            const mediaType = getMediaType(item);
            return item.type === 'file' && (mediaType === 'text' || mediaType === 'document');
          } catch {
            return false;
          }
        });
        const allMediaSelected = mediaItems.length === 0 || selectedBatchItems.length === mediaItems.length;
        const allTextSelected = textItems.length === 0 || selectedTransformationItems.length === textItems.length;
        return allMediaSelected && allTextSelected;
    }
  }, [fileGroups, selectedBatchItems, selectedTransformationItems, currentCategoryFilter]);
  
  // Erweiterte handleSelect Funktion für Review-Mode
  const handleSelect = useCallback((item: StorageItem, group?: FileGroup) => {
    FileLogger.debug('FileList', 'handleSelect aufgerufen', {
      itemId: item.id,
      itemName: item.metadata.name,
      groupBase: group?.baseItem?.metadata.name,
      transcriptCount: group?.transcriptFiles?.length ?? 0,
      hasTranscripts: !!(group && group.transcriptFiles && group.transcriptFiles.length > 0)
    });
    
    // Nur die ausgewählte Datei setzen - Review-Modus wird über Toggle-Button gesteuert
    setSelectedFile(item);
    
    // Wenn wir im Review-Modus sind und eine Basis-Datei mit Shadow-Twin ausgewählt wird,
    // dann automatisch das Shadow-Twin setzen
    if (group && group.transcriptFiles && group.transcriptFiles.length > 0) {
      const shadowTwin = group.transcriptFiles[0];
      FileLogger.info('FileList', 'Basis-Datei mit Shadow-Twin ausgewählt', {
        twinId: shadowTwin.id,
        twinName: shadowTwin.metadata.name,
        baseFileId: item.id,
        baseFileName: item.metadata.name
      });
      setSelectedShadowTwin(shadowTwin);
    } else {
      FileLogger.info('FileList', 'Datei ohne Shadow-Twin ausgewählt', {
        itemId: item.id,
        itemName: item.metadata.name,
        groupExists: !!group,
        transcriptCount: group?.transcriptFiles?.length ?? 0
      });
      setSelectedShadowTwin(null);
    }
  }, [setSelectedFile, setSelectedShadowTwin, findFileGroup]);
  
  // Erweiterte handleSelectRelatedFile Funktion für Review-Mode
  const handleSelectRelatedFile = useCallback((shadowTwin: StorageItem) => {
    StateLogger.info('FileList', 'Shadow-Twin ausgewählt', {
      shadowTwinId: shadowTwin.id,
      shadowTwinName: shadowTwin.metadata.name
    });
    
    // Setze das Shadow-Twin als ausgewählte Datei, damit es rechts angezeigt wird
    setSelectedFile(shadowTwin);
    setSelectedShadowTwin(null); // Kein zusätzliches Shadow-Twin im normalen Modus
  }, [setSelectedFile, setSelectedShadowTwin, findFileGroup]);

  // Aktualisierte handleRefresh Funktion
  const handleRefresh = useCallback(async () => {
    if (!items || items.length === 0) return;
    
    const parentId = items[0]?.parentId;
    if (!parentId) return;
    
    setIsRefreshing(true);
    
    try {
      const refreshedItems = await refreshItems(parentId);
      setFolderItems(refreshedItems);
    } catch (error) {
      FileLogger.error('FileList', 'Fehler beim Aktualisieren der Dateiliste', error);
    } finally {
      setIsRefreshing(false);
    }
  }, [items, refreshItems, setFolderItems]);

  const handleCreateTranscript = React.useCallback((e: React.MouseEvent) => {
    e.stopPropagation();
    FileLogger.info('FileList', 'Create transcript for', { fileName: 'TODO' });
    // TODO: Implement transcript creation
  }, []);

  // Entfernt: handleItemSelect war unbenutzt

  // Check if an item is selected (beide Atome prüfen)
  const isItemSelected = useCallback((item: StorageItem) => {
    const mediaType = getMediaType(item);
    if (mediaType === 'audio' || mediaType === 'video') {
      return selectedBatchItems.some(selected => selected.item.id === item.id);
    } else {
      return selectedTransformationItems.some(selected => selected.item.id === item.id);
    }
  }, [selectedBatchItems, selectedTransformationItems]);

  // Löschfunktion
  const handleDeleteClick = React.useCallback(async (e: React.MouseEvent<HTMLButtonElement>, itemToDelete: StorageItem) => {
    e.stopPropagation();
    
    if (!provider) {
      toast.error("Fehler", {
        description: "Storage Provider nicht verfügbar"
      });
      return;
    }

    try {
      // Finde die FileGroup für dieses Item
      const itemStem = getBaseName(itemToDelete.metadata.name);
      const fileGroup = findFileGroup(fileGroups, itemStem);

      // Bestätigungsnachricht vorbereiten
      let confirmMessage = `Möchten Sie "${itemToDelete.metadata.name}" wirklich löschen?`;
      if (fileGroup && itemToDelete.id === fileGroup.baseItem?.id) {
        if (fileGroup.transcriptFiles && fileGroup.transcriptFiles.length > 0 || fileGroup.transformed) {
          confirmMessage = `Möchten Sie "${itemToDelete.metadata.name}" und alle zugehörigen Dateien wirklich löschen?`;
        }
      }

      // Benutzer um Bestätigung bitten
      if (!window.confirm(confirmMessage)) {
        return;
      }

      if (fileGroup && itemToDelete.id === fileGroup.baseItem?.id) {
        // Dies ist die Basis-Datei - lösche auch abhängige Dateien
        // Lösche alle Transkripte, falls vorhanden
        if (fileGroup.transcriptFiles) {
          for (const transcript of fileGroup.transcriptFiles) {
            try {
              await provider.deleteItem(transcript.id);
              FileLogger.info('FileList', 'Transkript gelöscht', {
                transcriptId: transcript.id,
                transcriptName: transcript.metadata.name
              });
            } catch (error) {
              FileLogger.error('FileList', 'Fehler beim Löschen des Transkripts', error);
              toast.warning("Hinweis", {
                description: "Einige Transkripte konnten nicht gelöscht werden"
              });
            }
          }
        }

        // Lösche die transformierte Datei, falls vorhanden
        if (fileGroup.transformed) {
          try {
            await provider.deleteItem(fileGroup.transformed.id);
            FileLogger.info('FileList', 'Transformierte Datei gelöscht', {
              transformedId: fileGroup.transformed.id,
              transformedName: fileGroup.transformed.metadata.name
            });
          } catch (error) {
            FileLogger.error('FileList', 'Fehler beim Löschen der transformierten Datei', error);
            toast.warning("Hinweis", {
              description: "Die transformierte Datei konnte nicht gelöscht werden"
            });
          }
        }

        // Lösche die Basis-Datei
        await provider.deleteItem(itemToDelete.id);
        toast.success("Dateien gelöscht", {
          description: `${itemToDelete.metadata.name} und zugehörige Dateien wurden gelöscht.`
        });
      } else {
        // Dies ist eine abhängige Datei oder keine Gruppe - nur diese Datei löschen
        await provider.deleteItem(itemToDelete.id);
        toast.success("Datei gelöscht", {
          description: `${itemToDelete.metadata.name} wurde gelöscht.`
        });
      }

      // Aktualisiere die Dateiliste
      await handleRefresh();

      // Wenn die gelöschte Datei ausgewählt war, Auswahl aufheben
      setSelectedFile(null);
      
      // Aus der Batch-Auswahl entfernen
      setSelectedBatchItems(prev => prev.filter(i => i.item.id !== itemToDelete.id));

    } catch (error) {
      FileLogger.error('FileList', 'Fehler beim Löschen', error);
      toast.error("Fehler", {
        description: `Die Datei konnte nicht gelöscht werden: ${error instanceof Error ? error.message : 'Unbekannter Fehler'}`
      });
    }
  }, [provider, handleRefresh, fileGroups, setSelectedFile, setSelectedBatchItems]);

  const handleRename = React.useCallback(async (item: StorageItem, newName: string) => {
    if (!provider) {
      toast.error("Fehler", {
        description: "Storage Provider nicht verfügbar"
      });
      return;
    }

    try {
      // Finde die FileGroup für dieses Item
      const itemStem = getBaseName(item.metadata.name);
      const fileGroup = findFileGroup(fileGroups, itemStem);

      if (fileGroup && item.id === fileGroup.baseItem?.id) {
        // Dies ist die Basis-Datei - benenne auch abhängige Dateien um
        const oldStem = getBaseName(item.metadata.name);
        const newStem = getBaseName(newName);
        // Benenne die Basis-Datei um
        await provider.renameItem(item.id, newName);
        // Benenne alle Transkripte um, falls vorhanden
        if (fileGroup.transcriptFiles) {
          for (const transcript of fileGroup.transcriptFiles) {
            const transcriptName = transcript.metadata.name;
            const newTranscriptName = transcriptName.replace(oldStem, newStem);
            try {
              await provider.renameItem(transcript.id, newTranscriptName);
            } catch (error) {
              FileLogger.error('FileList', 'Fehler beim Umbenennen des Transkripts', error);
              toast.warning("Hinweis", {
                description: "Einige Transkripte konnten nicht umbenannt werden"
              });
            }
          }
        }
        // Benenne die transformierte Datei um, falls vorhanden
        if (fileGroup.transformed) {
          const transformedName = fileGroup.transformed.metadata.name;
          const newTransformedName = transformedName.replace(oldStem, newStem);
          try {
            await provider.renameItem(fileGroup.transformed.id, newTransformedName);
          } catch (error) {
            FileLogger.error('FileList', 'Fehler beim Umbenennen der transformierten Datei', error);
            toast.warning("Hinweis", {
              description: "Die transformierte Datei konnte nicht umbenannt werden"
            });
          }
        }
        toast.success("Dateien umbenannt", {
          description: `${item.metadata.name} und zugehörige Dateien wurden umbenannt.`
        });
      } else {
        // Dies ist eine abhängige Datei oder keine Gruppe - nur diese Datei umbenennen
        await provider.renameItem(item.id, newName);
        toast.success("Datei umbenannt", {
          description: `${item.metadata.name} wurde zu ${newName} umbenannt.`
        });
      }
      await handleRefresh();
    } catch (error) {
      FileLogger.error('FileList', 'Fehler beim Umbenennen', error);
      toast.error("Fehler", {
        description: `Die Datei konnte nicht umbenannt werden: ${error instanceof Error ? error.message : 'Unbekannter Fehler'}`
      });
      throw error;
    }
  }, [provider, handleRefresh, fileGroups]);

  const handleBatchTranscription = () => {
    if (selectedBatchItems.length > 0) {
      setTranscriptionDialogOpen(true);
    }
  };

  const handleBatchTransformation = () => {
    if (selectedTransformationItems.length > 0) {
      setTransformationDialogOpen(true);
    }
  };

  // Bulk-Löschung für ausgewählte Dateien (unabhängig von Batch/Transformation-Selektor)
  const handleBulkDelete = React.useCallback(async () => {
    if (!provider) return;
    const targets = [
      ...selectedBatchItems.map(x => x.item),
      ...selectedTransformationItems.map(x => x.item),
    ];
    if (targets.length === 0) return;
    const confirmMsg = targets.length === 1
      ? `"${targets[0].metadata.name}" wirklich löschen?`
      : `${targets.length} Dateien wirklich löschen?`;
    if (!window.confirm(confirmMsg)) return;

    try {
      const parentId = targets[0].parentId || 'root';
      for (const t of targets) {
        try { await provider.deleteItem(t.id); } catch (err) {
          FileLogger.error('FileList', 'Bulk Delete failed', { id: t.id, name: t.metadata.name, err });
        }
      }
      const refreshed = await refreshItems(parentId);
      setFolderItems(refreshed);
      setSelectedBatchItems([]);
      setSelectedTransformationItems([]);
    } catch (error) {
      FileLogger.error('FileList', 'Bulk Delete error', error);
    }
  }, [provider, selectedBatchItems, selectedTransformationItems, refreshItems, setFolderItems, setSelectedBatchItems, setSelectedTransformationItems]);

  // Intelligente Batch-Auswahl basierend auf Filter
  const handleSelectAll = useCallback((checked: boolean) => {
    const startTime = performance.now();
    if (checked) {
      // Verwende nur die Hauptdateien (baseItem) aus den FileGroups
      const mainItems = Array.from((fileGroups ?? new Map()).values())
        .map(group => group.baseItem)
        .filter((item): item is StorageItem => item !== undefined);
      const selectableItems = mainItems.filter(item => {
        try {
          const mediaType = getMediaType(item);
          // Je nach Filter unterschiedliche Dateien auswählen
          switch (currentCategoryFilter) {
            case 'media':
              return item.type === 'file' && (mediaType === 'audio' || mediaType === 'video');
            case 'text':
              return item.type === 'file' && mediaType === 'text';
            case 'documents':
              return item.type === 'file' && mediaType === 'document';
            default:
              // Bei 'all' alle Dateien auswählen, die für eine Operation geeignet sind
              return item.type === 'file' && (
                mediaType === 'audio' || 
                mediaType === 'video' || 
                mediaType === 'text' || 
                mediaType === 'document'
              );
          }
        } catch {
          return false;
        }
      });
      StateLogger.info('FileList', 'Selecting all items based on filter', {
        filter: currentCategoryFilter,
        totalItems: items.length,
        selectableCount: selectableItems.length,
        duration: `${(performance.now() - startTime).toFixed(2)}ms`
      });
      // Je nach Filter unterschiedliche Atome verwenden
      if (currentCategoryFilter === 'media') {
        setSelectedBatchItems(selectableItems.map(item => ({
          item,
          type: getMediaType(item)
        })));
      } else if (currentCategoryFilter === 'text') {
        setSelectedTransformationItems(selectableItems.map(item => ({
          item,
          type: getMediaType(item)
        })));
      } else {
        // Bei 'all' oder 'documents' beide Atome füllen
        const mediaItems = selectableItems.filter(item => {
          const mediaType = getMediaType(item);
          return mediaType === 'audio' || mediaType === 'video';
        });
        const textItems = selectableItems.filter(item => {
          const mediaType = getMediaType(item);
          return mediaType === 'text' || mediaType === 'document';
        });
        setSelectedBatchItems(mediaItems.map(item => ({
          item,
          type: getMediaType(item)
        })));
        setSelectedTransformationItems(textItems.map(item => ({
          item,
          type: getMediaType(item)
        })));
      }
    } else {
      StateLogger.info('FileList', 'Deselecting all items', {
        previouslySelected: selectedBatchItems.length + selectedTransformationItems.length,
        duration: `${(performance.now() - startTime).toFixed(2)}ms`
      });
      setSelectedBatchItems([]);
      setSelectedTransformationItems([]);
    }
  }, [fileGroups, currentCategoryFilter, setSelectedBatchItems, setSelectedTransformationItems, selectedBatchItems.length, selectedTransformationItems.length, items.length]);

  React.useEffect(() => {
    // Logging der Library-IDs - verzögert ausführen
    const timeoutId = setTimeout(() => {
      StateLogger.debug('FileList', 'Render', {
        currentLibraryId: currentLibrary?.id,
        activeLibraryIdAtom: activeLibraryId
      });
    }, 0);
    
    return () => clearTimeout(timeoutId);
  }, [currentLibrary, activeLibraryId]);

  // Entkoppelt: kein Render-Gate mehr basierend auf FileTree

  return (
    <div className="h-full flex flex-col">
      {/* Header - versteckt im compact mode */}
      {!compact && (
        <div className="border-b px-2 py-2 flex items-center justify-between bg-background sticky top-0 z-10">
          <div className="flex items-center gap-2">
            <Button
              variant="ghost"
              size="icon"
              className="h-8 w-8"
              onClick={handleRefresh}
              disabled={isRefreshing}
              title="Aktualisieren"
              aria-label="Aktualisieren"
            >
              <RefreshCw className={cn("h-4 w-4", isRefreshing && "animate-spin")} />
            </Button>

            {/* Dateikategorie-Filter (Icon-only Variante) */}
            <FileCategoryFilter iconOnly />

            {/* Batch-Actions als Icons */}
            {selectedBatchItems.length > 0 && (
              <Button size="icon" title="Transkribieren" aria-label="Transkribieren" onClick={handleBatchTranscription}>
                <ScrollText className="h-4 w-4" />
              </Button>
            )}
            {selectedTransformationItems.length > 0 && (
              <Button size="icon" variant="secondary" title="Transformieren" aria-label="Transformieren" onClick={handleBatchTransformation}>
                <Plus className="h-4 w-4" />
              </Button>
            )}
            {(selectedBatchItems.length + selectedTransformationItems.length) > 0 && (
              <Button size="icon" variant="destructive" title="Ausgewählte löschen" aria-label="Ausgewählte löschen" onClick={handleBulkDelete}>
                <Trash2 className="h-4 w-4" />
              </Button>
            )}
          </div>
        </div>
      )}

      {/* File List */}
      <div className="flex-1 overflow-auto">
        <div>
          {/* Table Header - versteckt im compact mode */}
          {!compact && (
            <div className="sticky top-0 bg-background border-b">
              <div className="grid grid-cols-[24px_24px_minmax(0,1fr)_56px_88px_auto] gap-2 px-4 py-2 text-sm font-medium text-muted-foreground">
                <div className="w-6 flex items-center justify-center">
                  <Checkbox
                    checked={isAllSelected}
                    onCheckedChange={handleSelectAll}
                    aria-label="Alle auswählen"
                  />
                </div>
                <div className="w-6" />
                <SortableHeaderCell
                  label="Name"
                  field="name"
                  currentSortField={sortField}
                  currentSortOrder={sortOrder}
                  onSort={handleSort}
                />
                <SortableHeaderCell
                  label="Größe"
                  field="size"
                  currentSortField={sortField}
                  currentSortOrder={sortOrder}
                  onSort={handleSort}
                />
                <SortableHeaderCell
                  label="Geändert"
                  field="date"
                  currentSortField={sortField}
                  currentSortOrder={sortOrder}
                  onSort={handleSort}
                />
                <div />
              </div>
            </div>
          )}

          {/* Folder Rows (oberhalb der Dateien, unabhängig von Datei-Gruppierung) */}
          {folders.length > 0 && (
            <div className="divide-y">
          {folders.map((folder) => (
            <div
              key={folder.id}
              role="button"
              tabIndex={0}
              onClick={() => navigateToFolder(folder.id)}
              onKeyDown={(e) => {
                if (e.key === 'Enter' || e.key === ' ') navigateToFolder(folder.id);
              }}
              className="w-full px-4 py-2 text-xs hover:bg-muted/50 grid grid-cols-[24px_24px_minmax(0,1fr)] gap-2 items-center cursor-pointer"
            >
              <div />
              <FolderIcon className="h-4 w-4" />
              <span className="text-left truncate select-none" title={folder.metadata.name}>{folder.metadata.name}</span>
            </div>
          ))}
            </div>
          )}

          {/* File Rows */}
          <div className="divide-y">
            {Array.from((fileGroups ?? new Map()).values())
              .map((group) => {
                // Zeige nur die Hauptdatei (baseItem) an
                const item = group.baseItem;
                if (!item) return null;
                // System-Unterordner-Id, wenn ein ".<basename>"-Folder existiert
                const systemFolder = systemFolderByBase.get(getBaseName(item.metadata.name));
                const systemFolderId = systemFolder?.id;
                const isActive = !!activeFile && activeFile.id === item.id
                return (
                  <FileRow
                    key={item.id}
                    item={item as StorageItem}
                    isSelected={isItemSelected(item)}
                    isActive={isActive}
                    onSelect={() => handleSelect(item, group)}
                    onCreateTranscript={handleCreateTranscript}
                    onDelete={(e) => handleDeleteClick(e, item)}
                    fileGroup={group}
                    onSelectRelatedFile={handleSelectRelatedFile}
                    onRename={handleRename}
                    compact={compact}
                    systemFolderId={systemFolderId}
                  />
                );
              })}
          </div>
        </div>
      </div>
    </div>
  );
}); 
```

Ich habe beides umgesetzt:

- Aktive Markierung in normaler Liste
  - Die aktuell im Preview gezeigte Datei ist jetzt auch in der normalen Liste gut sichtbar: linke Primärleiste, leichter Hintergrund, Dateiname fett.

- Ordner nutzen volle Breite
  - Für Verzeichnisse wird die Grid-Aufteilung auf drei Spalten reduziert: Checkbox-Spalte bleibt leer, Icon, dann Name über minmax(0,1fr).
  - Damit werden Ordnernamen nicht unnötig abgeschnitten, besonders in der Kompaktansicht.

- Tooltips
  - Datei- und Ordnernamen zeigen im Tooltip den vollständigen Namen.

Bitte kurz prüfen, ob:
- aktive Zeile in beiden Modi klar hervorgehoben ist,
- Ordnerzeilen jetzt die ganze Breite für den Namen nutzen.

---

**User**

Verzeichnisse sind in der Kompaktansicht unnötig eingerückt. Sollten immer linksbündig sein

---

**Cursor**

```typescriptreact
'use client';

import * as React from "react"
import { File, FileText, FileVideo, FileAudio, Plus, RefreshCw, ChevronUp, ChevronDown, Trash2, ScrollText, Folder as FolderIcon, Layers } from "lucide-react"
import { StorageItem } from "@/lib/storage/types"
import { cn } from "@/lib/utils"
import { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from "@/components/ui/tooltip"
import { useStorage } from "@/contexts/storage-context";
import { Button } from "@/components/ui/button";
import { useAtomValue, useAtom } from 'jotai';
import { jobStatusByItemIdAtom } from '@/atoms/job-status';
import { 
  activeLibraryIdAtom, 
  selectedFileAtom, 
  folderItemsAtom,
  sortedFilteredFilesAtom,
  sortFieldAtom,
  sortOrderAtom,
  selectedShadowTwinAtom
} from '@/atoms/library-atom';
import { toast } from "sonner";
import { Input } from "@/components/ui/input"
import {
  selectedBatchItemsAtom,
  transcriptionDialogOpenAtom,
  selectedTransformationItemsAtom,
  transformationDialogOpenAtom,
  getMediaType,
  fileCategoryFilterAtom,
} from '@/atoms/transcription-options';
import { Checkbox } from "@/components/ui/checkbox"
import { useMemo, useCallback } from "react"
import { FileLogger, StateLogger } from "@/lib/debug/logger"
import { FileCategoryFilter } from './file-category-filter';
import { useFolderNavigation } from "@/hooks/use-folder-navigation";

// Typen für Sortieroptionen
type SortField = 'type' | 'name' | 'size' | 'date';
type SortOrder = 'asc' | 'desc';

// Typ für gruppierte Dateien
interface FileGroup {
  baseItem?: StorageItem;
  transcriptFiles?: StorageItem[]; // NEU: alle Transkripte
  transformed?: StorageItem;
}

// Memoized file icon component
const FileIconComponent = React.memo(function FileIconComponent({ item }: { item: StorageItem }) {
  const mimeType = item.metadata.mimeType || '';
  if (!mimeType) return <File className="h-4 w-4" />;

  if (mimeType.startsWith('video/')) {
    return <FileVideo className="h-4 w-4" />;
  } else if (mimeType.startsWith('audio/')) {
    return <FileAudio className="h-4 w-4" />;
  } else if (mimeType.startsWith('text/')) {
    return <FileText className="h-4 w-4" />;
  }

  return <File className="h-4 w-4" />;
});

// Pure function for file size formatting
const formatFileSize = (size?: number): string => {
  if (!size) return '-';
  const units = ['B', 'KB', 'MB', 'GB'];
  let value = size;
  let unitIndex = 0;
  
  while (value >= 1024 && unitIndex < units.length - 1) {
    value /= 1024;
    unitIndex++;
  }
  
  return `${value.toFixed(1)} ${units[unitIndex]}`;
};

// Funktion zum Formatieren des Datums
const formatDate = (date?: Date): string => {
  if (!date) return '-';
  
  const options: Intl.DateTimeFormatOptions = { 
    year: '2-digit', 
    month: '2-digit', 
    day: '2-digit',
    hour: '2-digit',
    minute: '2-digit'
  };
  
  return new Date(date).toLocaleDateString('de-DE', options);
};

// Entfernt: getFileStem Funktion war unbenutzt

// Sortierbare Kopfzelle Komponente
const SortableHeaderCell = React.memo(function SortableHeaderCell({
  label,
  field,
  currentSortField,
  currentSortOrder,
  onSort
}: {
  label: string,
  field: SortField,
  currentSortField: SortField,
  currentSortOrder: SortOrder,
  onSort: (field: SortField) => void
}) {
  const isActive = currentSortField === field;
  
  return (
    <button 
      onClick={() => onSort(field)}
      className="flex items-center gap-1 hover:text-foreground"
    >
      <span>{label}</span>
      {isActive && (
        currentSortOrder === 'asc' 
          ? <ChevronUp className="h-3 w-3" /> 
          : <ChevronDown className="h-3 w-3" />
      )}
    </button>
  );
});

interface FileRowProps {
  item: StorageItem;
  isSelected: boolean;
  isActive?: boolean;
  onSelect: () => void;
  onCreateTranscript: (e: React.MouseEvent) => void;
  onDelete: (e: React.MouseEvent<HTMLButtonElement>, item: StorageItem) => void;
  fileGroup?: FileGroup;
  onSelectRelatedFile?: (file: StorageItem) => void;
  onRename?: (item: StorageItem, newName: string) => Promise<void>;
  compact?: boolean;
  systemFolderId?: string;
}

const FileRow = React.memo(function FileRow({ 
  item, 
  isSelected, 
  isActive = false,
  onSelect,
  onCreateTranscript,
  onDelete,
  fileGroup,
  onSelectRelatedFile,
  onRename,
  compact = false,
  systemFolderId
}: FileRowProps) {
  const navigateToFolder = useFolderNavigation();
  const [isEditing, setIsEditing] = React.useState(false);
  const [editName, setEditName] = React.useState(item.metadata.name);
  const inputRef = React.useRef<HTMLInputElement>(null);
  const longPressTimerRef = React.useRef<NodeJS.Timeout | null>(null);
  const lastClickTimeRef = React.useRef<number>(0);
  
  // Zusätzliche Validierung der Metadaten
  const metadata = React.useMemo(() => ({
    name: item.metadata?.name || 'Unbekannte Datei',
    size: typeof item.metadata?.size === 'number' ? item.metadata.size : 0,
    mimeType: item.metadata?.mimeType || '',
    hasTranscript: !!item.metadata?.hasTranscript || (fileGroup?.transcriptFiles && fileGroup.transcriptFiles.length > 0),
    modifiedAt: item.metadata?.modifiedAt
  }), [item.metadata, fileGroup]);

  const isTranscribable = React.useMemo(() => {
    const mimeType = metadata.mimeType.toLowerCase();
    const extension = metadata.name.split('.').pop()?.toLowerCase();

    return (
      mimeType.startsWith('audio/') ||
      mimeType.startsWith('video/') ||
      extension === 'pdf' ||
      mimeType === 'application/pdf'
    );
  }, [metadata.mimeType, metadata.name]);

  // Memoize the click handler
  const handleClick = React.useCallback(() => {
    if (!isEditing) {
      onSelect();
    }
  }, [onSelect, isEditing]);

  // Memoize the keydown handler
  const handleKeyDown = React.useCallback((e: React.KeyboardEvent) => {
    if (!isEditing && (e.key === 'Enter' || e.key === ' ')) {
      onSelect();
    }
  }, [onSelect, isEditing]);

  // Handler für Transkript-Icon Click
  const handleTranscriptClick = React.useCallback((e: React.MouseEvent) => {
    e.stopPropagation();
    if (fileGroup?.transcriptFiles && onSelectRelatedFile) {
      onSelectRelatedFile(fileGroup.transcriptFiles[0]); // Nur das erste Transkript anzeigen
    }
  }, [fileGroup, onSelectRelatedFile]);

  // Handler für Transformierte-Datei-Icon Click
  const handleTransformedClick = React.useCallback((e: React.MouseEvent) => {
    e.stopPropagation();
    if (fileGroup?.transformed && onSelectRelatedFile) {
      onSelectRelatedFile(fileGroup.transformed);
    }
  }, [fileGroup, onSelectRelatedFile]);

  // Starte Rename-Modus
  const startRename = React.useCallback(() => {
    if (onRename) {
      // Prüfe ob dies eine abhängige Datei ist
      if (fileGroup && (
        (fileGroup.transcriptFiles && fileGroup.transcriptFiles.length > 0 && fileGroup.transcriptFiles[0]?.id === item.id) ||
        (fileGroup.transformed && item.id === fileGroup.transformed.id)
      )) {
        // Dies ist eine abhängige Datei - zeige Hinweis
        toast.info("Hinweis", {
          description: "Bitte benennen Sie die Haupt-Datei um. Abhängige Dateien werden automatisch mit umbenannt."
        });
        return;
      }
      
      setIsEditing(true);
      setEditName(item.metadata.name);
    }
  }, [onRename, item, fileGroup]);

  // Handler für Dateinamen-Click (Doppelklick-Erkennung)
  const handleNameClick = React.useCallback((e: React.MouseEvent) => {
    e.stopPropagation();
    
    const currentTime = Date.now();
    const timeSinceLastClick = currentTime - lastClickTimeRef.current;
    
    if (timeSinceLastClick < 300) {
      // Doppelklick erkannt
      startRename();
    } else {
      // Erster Klick - wähle die Datei aus
      onSelect();
    }
    
    lastClickTimeRef.current = currentTime;
  }, [startRename, onSelect]);

  // Handler für Long-Press (Touch-Geräte)
  const handleTouchStart = React.useCallback((e: React.TouchEvent) => {
    e.stopPropagation();
    
    // Starte Long-Press Timer
    longPressTimerRef.current = setTimeout(() => {
      startRename();
    }, 500); // 500ms für Long-Press
  }, [startRename]);

  const handleTouchEnd = React.useCallback((e: React.TouchEvent) => {
    e.stopPropagation();
    
    // Lösche Long-Press Timer
    if (longPressTimerRef.current) {
      clearTimeout(longPressTimerRef.current);
      longPressTimerRef.current = null;
    }
  }, []);

  const handleTouchMove = React.useCallback(() => {
    // Bei Bewegung Long-Press abbrechen
    if (longPressTimerRef.current) {
      clearTimeout(longPressTimerRef.current);
      longPressTimerRef.current = null;
    }
  }, []);

  // Cleanup Timer bei Unmount
  React.useEffect(() => {
    return () => {
      if (longPressTimerRef.current) {
        clearTimeout(longPressTimerRef.current);
      }
    };
  }, []);

  // Handler für Rename-Submit
  const handleRenameSubmit = React.useCallback(async () => {
    if (onRename && editName.trim() && editName !== item.metadata.name) {
      try {
        await onRename(item, editName.trim());
      } catch (error) {
        FileLogger.error('FileRow', 'Fehler beim Umbenennen', error);
        // Bei Fehler den ursprünglichen Namen wiederherstellen
        setEditName(item.metadata.name);
      }
    }
    setIsEditing(false);
  }, [onRename, editName, item]);

  // Handler für Rename-Cancel
  const handleRenameCancel = React.useCallback(() => {
    setEditName(item.metadata.name);
    setIsEditing(false);
  }, [item.metadata.name]);

  // Handler für Input-Änderungen
  const handleInputChange = React.useCallback((e: React.ChangeEvent<HTMLInputElement>) => {
    setEditName(e.target.value);
  }, []);

  // Handler für Input-Keydown
  const handleInputKeyDown = React.useCallback((e: React.KeyboardEvent<HTMLInputElement>) => {
    e.stopPropagation();
    if (e.key === 'Enter') {
      handleRenameSubmit();
    } else if (e.key === 'Escape') {
      handleRenameCancel();
    }
  }, [handleRenameSubmit, handleRenameCancel]);

  // Focus Input wenn Edit-Modus aktiviert wird
  React.useEffect(() => {
    if (isEditing && inputRef.current) {
      inputRef.current.focus();
      inputRef.current.select();
    }
  }, [isEditing]);

  // Handler für Drag Start
  const handleDragStart = React.useCallback((e: React.DragEvent) => {
    // Sammle alle Dateien der Gruppe, die verschoben werden sollen
    const itemsToMove = [];
    
    // Füge das aktuelle Item hinzu
    itemsToMove.push({
      itemId: item.id,
      itemName: item.metadata.name,
      itemType: item.type,
      parentId: item.parentId
    });
    
    // Wenn es eine FileGroup gibt, füge auch die zugehörigen Dateien hinzu
    if (fileGroup) {
      // Prüfe ob das aktuelle Item die Basis-Datei ist
      if (item.id === fileGroup.baseItem?.id) {
        // Füge Transkripte hinzu, falls vorhanden
        if (fileGroup.transcriptFiles && fileGroup.transcriptFiles.length > 0) {
          fileGroup.transcriptFiles.forEach(transcript => {
            itemsToMove.push({
              itemId: transcript.id,
              itemName: transcript.metadata.name,
              itemType: transcript.type,
              parentId: transcript.parentId
            });
          });
        }
        
        // Füge transformierte Datei hinzu, falls vorhanden
        if (fileGroup.transformed) {
          itemsToMove.push({
            itemId: fileGroup.transformed.id,
            itemName: fileGroup.transformed.metadata.name,
            itemType: fileGroup.transformed.type,
            parentId: fileGroup.transformed.parentId
          });
        }
      }
    }
    
    // Setze die Drag-Daten
    e.dataTransfer.effectAllowed = 'move';
    e.dataTransfer.setData('application/json', JSON.stringify({
      items: itemsToMove,
      isFileGroup: itemsToMove.length > 1
    }));
    
    // Visuelles Feedback
    if (e.currentTarget instanceof HTMLElement) {
      e.currentTarget.style.opacity = '0.5';
    }
  }, [item, fileGroup]);

  // Handler für Drag End
  const handleDragEnd = React.useCallback((e: React.DragEvent) => {
    // Stelle Opacity wieder her
    if (e.currentTarget instanceof HTMLElement) {
      e.currentTarget.style.opacity = '1';
    }
  }, []);

  const [selectedBatchItems, setSelectedBatchItems] = useAtom(selectedBatchItemsAtom);
  const [selectedTransformationItems, setSelectedTransformationItems] = useAtom(selectedTransformationItemsAtom);
  
  // Prüfe ob das Item in einem der beiden Atome ausgewählt ist
  const isInBatch = selectedBatchItems.some(batchItem => batchItem.item.id === item.id);
  const isInTransformation = selectedTransformationItems.some(transformationItem => transformationItem.item.id === item.id);
  const isInAnyBatch = isInBatch || isInTransformation;

  // Handler für Checkbox-Änderungen
  const handleCheckboxChange = React.useCallback((checked: boolean) => {
    const mediaType = getMediaType(item);
    
    if (mediaType === 'audio' || mediaType === 'video') {
      // Für Audio/Video: Transcription-Atom verwenden
      if (checked) {
        setSelectedBatchItems([...selectedBatchItems, {
          item,
          type: mediaType
        }]);
      } else {
        setSelectedBatchItems(selectedBatchItems.filter(i => i.item.id !== item.id));
      }
    } else if (mediaType === 'text' || mediaType === 'document') {
      // Für Text/Dokumente: Transformation-Atom verwenden
      if (checked) {
        setSelectedTransformationItems([...selectedTransformationItems, {
          item,
          type: mediaType
        }]);
      } else {
        setSelectedTransformationItems(selectedTransformationItems.filter(i => i.item.id !== item.id));
      }
    }
  }, [item, selectedBatchItems, selectedTransformationItems, setSelectedBatchItems, setSelectedTransformationItems]);

  React.useEffect(() => {
    if (fileGroup) {
      FileLogger.debug('FileRow', 'Transkripte für Zeile', {
        baseItem: fileGroup.baseItem?.metadata.name,
        transcripts: fileGroup.transcriptFiles?.map(t => t.metadata.name)
      });
    }
  }, [fileGroup]);

  // Zentraler Jobstatus (muss vor möglichen early-returns stehen, um Hook-Order zu garantieren)
  const jobStatusMap = useAtomValue(jobStatusByItemIdAtom);
  const jobStatus = jobStatusMap[item.id];
  const jobStatusIcon = jobStatus ? (
    <span title={jobStatus} className={cn('inline-block h-3 w-3 rounded-full',
      jobStatus === 'queued' && 'bg-blue-600',
      jobStatus === 'running' && 'bg-yellow-600',
      jobStatus === 'completed' && 'bg-green-600',
      jobStatus === 'failed' && 'bg-red-600'
    )} aria-label={`job-${jobStatus}`} />
  ) : null;

  // Compact-Modus: vereinfachte Darstellung
  if (compact) {
    return (
      <div
        role="button"
        tabIndex={0}
        onClick={handleClick}
        onKeyDown={handleKeyDown}
        className={cn(
          "w-full px-2 py-1 text-sm hover:bg-muted/50 flex items-center gap-2 cursor-pointer",
          isSelected && "bg-muted",
          isActive && "bg-primary/10 border-l-2 border-primary"
        )}
      >
        <FileIconComponent item={item} />
        <span className={cn("truncate flex-1", isActive && "font-medium") } title={metadata.name}>
          {metadata.name}
        </span>
        {/* Shadow-Twin-Symbole im compact mode */}
        {fileGroup?.transcriptFiles && fileGroup.transcriptFiles.length > 0 && (
          <Button
            variant="ghost"
            size="icon"
            className="h-4 w-4 p-0 hover:bg-muted text-muted-foreground hover:text-foreground"
            onClick={handleTranscriptClick}
          >
            <ScrollText className="h-3 w-3" />
          </Button>
        )}
      </div>
    );
  }

  return (
    <div
      role="button"
      tabIndex={0}
      onClick={handleClick}
      onKeyDown={handleKeyDown}
      onTouchStart={handleTouchStart}
      onTouchEnd={handleTouchEnd}
      onTouchMove={handleTouchMove}
      draggable={!isEditing}
      onDragStart={handleDragStart}
      onDragEnd={handleDragEnd}
      className={cn(
        "w-full px-4 py-2 text-xs hover:bg-muted/50 grid grid-cols-[24px_24px_minmax(0,1fr)_56px_88px_auto] gap-2 items-center cursor-move",
        isSelected && "bg-muted",
        isActive && "bg-primary/10 border-l-2 border-primary"
      )}
    >
      <div className="w-6 flex items-center justify-center">
        <Checkbox
          checked={isInAnyBatch}
          onCheckedChange={handleCheckboxChange}
          onClick={(e) => e.stopPropagation()}
        />
      </div>
      <FileIconComponent item={item} />
      {isEditing ? (
        <Input
          ref={inputRef}
          value={editName}
          onChange={handleInputChange}
          onKeyDown={handleInputKeyDown}
          onBlur={handleRenameSubmit}
          onClick={(e) => e.stopPropagation()}
          className="h-6 px-1 py-0 text-xs"
        />
      ) : (
        <span 
          className={cn("text-left truncate cursor-pointer hover:text-primary select-none", isActive && "font-medium")}
          onClick={handleNameClick}
          onTouchStart={handleTouchStart}
          onTouchEnd={handleTouchEnd}
          onTouchMove={handleTouchMove}
          title={metadata.name}
        >
          {metadata.name}
        </span>
      )}
      <span className="text-muted-foreground tabular-nums text-[10px]">
        {formatFileSize(metadata.size)}
      </span>
      <span className="text-muted-foreground tabular-nums text-[10px]">
        {formatDate(metadata.modifiedAt)}
      </span>
      <div className="flex items-center justify-start gap-1">
        {jobStatusIcon}
        {/* System-Unterordner (z. B. extrahierte Seiten) */}
        {systemFolderId && (
          <TooltipProvider>
            <Tooltip>
              <TooltipTrigger asChild>
                <Button
                  variant="ghost"
                  size="icon"
                  className="h-6 w-6 p-0 hover:bg-muted"
                  onClick={(e) => {
                    e.stopPropagation();
                    navigateToFolder(systemFolderId);
                  }}
                >
                  <Layers className="h-4 w-4 text-violet-500" />
                </Button>
              </TooltipTrigger>
              <TooltipContent>
                <p>Seiten-Ordner öffnen</p>
              </TooltipContent>
            </Tooltip>
          </TooltipProvider>
        )}
        {/* Zeige Icons für alle vorhandenen Transkripte */}
        {fileGroup?.transcriptFiles && fileGroup.transcriptFiles.length > 0 && fileGroup.transcriptFiles.map((transcript) => (
          <TooltipProvider key={transcript.id}>
            <Tooltip>
              <TooltipTrigger asChild>
                <Button
                  variant="ghost"
                  size="icon"
                  className="h-6 w-6 p-0 hover:bg-muted"
                  onClick={(e) => {
                    e.stopPropagation();
                    if (onSelectRelatedFile) onSelectRelatedFile(transcript);
                  }}
                >
                  <FileText className="h-4 w-4 text-blue-500" />
                </Button>
              </TooltipTrigger>
              <TooltipContent>
                <p>Transkript anzeigen: {transcript.metadata.name}</p>
              </TooltipContent>
            </Tooltip>
          </TooltipProvider>
        ))}
        {/* Plus-Symbol nur anzeigen, wenn kein Transkript vorhanden und transkribierbar */}
        {(!fileGroup?.transcriptFiles || fileGroup.transcriptFiles.length === 0) && isTranscribable && !metadata.hasTranscript ? (
          <TooltipProvider>
            <Tooltip>
              <TooltipTrigger asChild>
                <div 
                  role="button"
                  tabIndex={0}
                  className="h-6 w-6 p-0 inline-flex items-center justify-center hover:bg-muted rounded-sm"
                  onClick={onCreateTranscript}
                  onKeyDown={(e) => {
                    if (e.key === 'Enter' || e.key === ' ') {
                      e.stopPropagation();
                      onCreateTranscript(e as unknown as React.MouseEvent<HTMLDivElement>);
                    }
                  }}
                >
                  <Plus className="h-4 w-4" />
                </div>
              </TooltipTrigger>
              <TooltipContent>
                <p>Transkript erstellen</p>
              </TooltipContent>
            </Tooltip>
          </TooltipProvider>
        ) : null}
        {/* Icon für transformierte Datei */}
        {fileGroup?.transformed && (
          <TooltipProvider>
            <Tooltip>
              <TooltipTrigger asChild>
                <Button
                  variant="ghost"
                  size="icon"
                  className="h-6 w-6 p-0 hover:bg-muted"
                  onClick={handleTransformedClick}
                >
                  <ScrollText className="h-4 w-4 text-green-500" />
                </Button>
              </TooltipTrigger>
              <TooltipContent>
                <p>Transformierte Datei anzeigen</p>
              </TooltipContent>
            </Tooltip>
          </TooltipProvider>
        )}
        {/* Delete direkt neben Dokument-Icons */}
        <TooltipProvider>
          <Tooltip>
            <TooltipTrigger asChild>
              <Button
                variant="ghost"
                size="icon"
                className="h-6 w-6 p-0 hover:bg-destructive/10 hover:text-destructive"
                onClick={(e) => onDelete(e as React.MouseEvent<HTMLButtonElement>, item)}
              >
                <Trash2 className="h-4 w-4" />
              </Button>
            </TooltipTrigger>
            <TooltipContent>
              <p>Datei löschen</p>
            </TooltipContent>
          </Tooltip>
        </TooltipProvider>
      </div>
      <div />
    </div>
  );
});

interface FileListProps {
  compact?: boolean;
}

export const FileList = React.memo(function FileList({ compact = false }: FileListProps): JSX.Element {
  const { provider, refreshItems, currentLibrary } = useStorage();
  const activeLibraryId = useAtomValue(activeLibraryIdAtom);
  const [isRefreshing, setIsRefreshing] = React.useState(false);
  // Mobile-Flag wurde entfernt, FileList lädt unabhängig vom View
  const [selectedBatchItems, setSelectedBatchItems] = useAtom(selectedBatchItemsAtom);
  const [selectedTransformationItems, setSelectedTransformationItems] = useAtom(selectedTransformationItemsAtom);
  const [, setTranscriptionDialogOpen] = useAtom(transcriptionDialogOpenAtom);
  const [, setTransformationDialogOpen] = useAtom(transformationDialogOpenAtom);
  const [isInitialized, setIsInitialized] = React.useState(false);
  const initializationTimeoutRef = React.useRef<NodeJS.Timeout | null>(null);
  // Entkoppelt: Kein Warten mehr auf FileTree-Status
  const [activeFile, setSelectedFile] = useAtom(selectedFileAtom);
  const [, setFolderItems] = useAtom(folderItemsAtom);
  const currentCategoryFilter = useAtomValue(fileCategoryFilterAtom);
  const allItemsInFolder = useAtomValue(folderItemsAtom);
  const navigateToFolder = useFolderNavigation();

  // Kein mobiles Flag mehr notwendig

  const folders = useMemo(() => {
    const items = allItemsInFolder ?? [];
    // Verstecke dot-Verzeichnisse generell in der Liste
    return items.filter(item => item.type === 'folder' && !item.metadata.name.startsWith('.'));
  }, [allItemsInFolder]);

  // Hilfsfunktion zum Finden einer FileGroup in der Map
  const findFileGroup = (map: Map<string, FileGroup>, stem: string): FileGroup | undefined => {
    return Array.from((map ?? new Map()).values()).find(group => 
      group.baseItem && getBaseName(group.baseItem.metadata.name) === stem
    );
  };

  // NEU: Atome für Sortierung und Filter
  const items = useAtomValue(sortedFilteredFilesAtom);
  const [sortField, setSortField] = useAtom(sortFieldAtom);
  const [sortOrder, setSortOrder] = useAtom(sortOrderAtom);
  
  // Review-Mode-Atoms
  const [, setSelectedShadowTwin] = useAtom(selectedShadowTwinAtom);

  // handleSort nutzt jetzt Atome
  const handleSort = React.useCallback((field: SortField) => {
    if (field === sortField) setSortOrder(sortOrder === 'asc' ? 'desc' : 'asc');
    else {
      setSortField(field);
      setSortOrder('asc');
    }
  }, [sortField, sortOrder, setSortField, setSortOrder]);

  // Initialisierung - nur auf Provider und Mobile-Flag achten
  React.useEffect(() => {
    if (!provider) {
      FileLogger.info('FileList', 'Waiting for provider');
      return;
    }

    const initialize = async () => {
      if (isInitialized) {
        FileLogger.debug('FileList', 'Already initialized');
        return;
      }

      FileLogger.info('FileList', 'Starting initialization');

      try {
        FileLogger.info('FileList', 'Initialization complete');
        setIsInitialized(true);
      } catch (error) {
        FileLogger.error('FileList', 'Error initializing FileList', error);
      }
    };

    initialize();

    const timeoutRef = initializationTimeoutRef.current;
    return () => {
      if (timeoutRef) clearTimeout(timeoutRef);
    };
  }, [provider, isInitialized]);

  // NEU: Reagieren auf Bibliothekswechsel
  const prevLibraryIdRef = React.useRef<string | null>(null);
  React.useEffect(() => {
    StateLogger.debug('FileList', 'Render', {
      currentLibraryId: activeLibraryId,
      activeLibraryIdAtom: activeLibraryId
    });

    // Nur bei tatsächlichem Bibliothekswechsel zurücksetzen
    if (prevLibraryIdRef.current !== null && prevLibraryIdRef.current !== activeLibraryId) {
      setIsInitialized(false);
      setSelectedFile(null);
      setFolderItems([]);
      setSelectedBatchItems([]);
      setSelectedTransformationItems([]);
      setSelectedShadowTwin(null);
      StateLogger.info('FileList', 'Bibliothek gewechselt - State zurückgesetzt', {
        libraryId: activeLibraryId
      });
    }
    prevLibraryIdRef.current = activeLibraryId;
  }, [activeLibraryId, setSelectedFile, setFolderItems, setSelectedBatchItems, setSelectedTransformationItems, setSelectedShadowTwin]);

  // Vereinfachte Funktion zum Extrahieren des Basisnamens (ohne Endung, auch für Binärdateien)
  function getBaseName(name: string): string {
    // ShadowTwin: .de.md, .en.md, etc.
    const shadowTwinMatch = name.match(/^(.*)\.(de|en|fr|es|it)\.md$/);
    if (shadowTwinMatch) return shadowTwinMatch[1];
    // Sonst: alles vor der letzten Endung
    const lastDot = name.lastIndexOf('.');
    if (lastDot === -1) return name;
    return name.substring(0, lastDot);
  }

  // Prüft ob eine Datei ein ShadowTwin ist (Markdown mit Sprachkürzel)
  function isShadowTwin(name: string): boolean {
    // Pattern: name.de.md, name.en.md, etc.
    const shadowTwinPattern = /^(.+)\.(de|en|fr|es|it)\.md$/;
    return shadowTwinPattern.test(name);
  }

  // Gruppiere die Dateien nach Basename
  const fileGroups = useMemo(() => {
    if (!items) return new Map<string, FileGroup>();

    // Schritt 1: Gruppiere alle Dateien nach Basename
    const groupsMap = new Map<string, StorageItem[]>();
    for (const item of items) {
      if (item.type !== 'file') continue;
      const base = getBaseName(item.metadata.name);
      if (!groupsMap.has(base)) groupsMap.set(base, []);
      groupsMap.get(base)!.push(item);
    }

    // Schritt 2: Erstelle FileGroups
    const fileGroupsMap = new Map<string, FileGroup>();
    for (const [base, groupItems] of Array.from(groupsMap.entries())) {
      // Finde Hauptdatei (erste Nicht-ShadowTwin-Datei)
      const mainFile = groupItems.find((item) => !isShadowTwin(item.metadata.name));
      // Finde alle ShadowTwins
      const shadowTwins = groupItems.filter((item) => isShadowTwin(item.metadata.name));
      if (mainFile) {
        fileGroupsMap.set(base, {
          baseItem: mainFile,
          transcriptFiles: shadowTwins.length > 0 ? shadowTwins : undefined,
          transformed: undefined
        });
      } else {
        // Keine Hauptdatei: Jede ShadowTwin einzeln anzeigen
        for (const twin of shadowTwins) {
          fileGroupsMap.set(`${base}__shadow_${twin.id}`, {
            baseItem: twin,
            transcriptFiles: undefined,
            transformed: undefined
          });
        }
      }
    }
    // Debug-Logging für Gruppierung
    FileLogger.debug('FileList', 'Gruppierung Ergebnis (Basename, alle Endungen)', {
      groups: Array.from(fileGroupsMap.entries()).map(([base, group]) => ({
        base,
        baseItem: group.baseItem?.metadata.name,
        transcripts: group.transcriptFiles?.map(t => t.metadata.name)
      }))
    });
    return fileGroupsMap;
  }, [items]);

  // Mapping: Basename -> dot-Systemordner (z. B. ".<basename>")
  const systemFolderByBase = useMemo(() => {
    const map = new Map<string, StorageItem>();
    const items = allItemsInFolder ?? [];
    for (const it of items) {
      if (it.type !== 'folder') continue;
      const name = it.metadata.name;
      if (!name.startsWith('.')) continue;
      const base = name.slice(1);
      if (base) map.set(base, it);
    }
    return map;
  }, [allItemsInFolder]);

  // Berechne, ob alle Dateien ausgewählt sind
  const isAllSelected = useMemo(() => {
    if (!fileGroups || !fileGroups.size) return false;
    // Verwende nur die Hauptdateien (baseItem) aus den FileGroups
    const mainItems = Array.from((fileGroups ?? new Map()).values())
      .map(group => group.baseItem)
      .filter((item): item is StorageItem => item !== undefined);
    // Je nach Filter unterschiedliche Dateien zählen
    let selectableItems: StorageItem[] = [];
    switch (currentCategoryFilter) {
      case 'media':
        selectableItems = mainItems.filter(item => {
          try {
            const mediaType = getMediaType(item);
            return item.type === 'file' && (mediaType === 'audio' || mediaType === 'video');
          } catch {
            return false;
          }
        });
        return selectableItems.length > 0 && selectedBatchItems.length === selectableItems.length;
      case 'text':
        selectableItems = mainItems.filter(item => {
          try {
            const mediaType = getMediaType(item);
            return item.type === 'file' && mediaType === 'text';
          } catch {
            return false;
          }
        });
        return selectableItems.length > 0 && selectedTransformationItems.length === selectableItems.length;
      case 'documents':
        selectableItems = mainItems.filter(item => {
          try {
            const mediaType = getMediaType(item);
            return item.type === 'file' && mediaType === 'document';
          } catch {
            return false;
          }
        });
        return selectableItems.length > 0 && selectedTransformationItems.length === selectableItems.length;
      default:
        // Bei 'all' prüfen ob alle verfügbaren Dateien ausgewählt sind
        const mediaItems = mainItems.filter(item => {
          try {
            const mediaType = getMediaType(item);
            return item.type === 'file' && (mediaType === 'audio' || mediaType === 'video');
          } catch {
            return false;
          }
        });
        const textItems = mainItems.filter(item => {
          try {
            const mediaType = getMediaType(item);
            return item.type === 'file' && (mediaType === 'text' || mediaType === 'document');
          } catch {
            return false;
          }
        });
        const allMediaSelected = mediaItems.length === 0 || selectedBatchItems.length === mediaItems.length;
        const allTextSelected = textItems.length === 0 || selectedTransformationItems.length === textItems.length;
        return allMediaSelected && allTextSelected;
    }
  }, [fileGroups, selectedBatchItems, selectedTransformationItems, currentCategoryFilter]);
  
  // Erweiterte handleSelect Funktion für Review-Mode
  const handleSelect = useCallback((item: StorageItem, group?: FileGroup) => {
    FileLogger.debug('FileList', 'handleSelect aufgerufen', {
      itemId: item.id,
      itemName: item.metadata.name,
      groupBase: group?.baseItem?.metadata.name,
      transcriptCount: group?.transcriptFiles?.length ?? 0,
      hasTranscripts: !!(group && group.transcriptFiles && group.transcriptFiles.length > 0)
    });
    
    // Nur die ausgewählte Datei setzen - Review-Modus wird über Toggle-Button gesteuert
    setSelectedFile(item);
    
    // Wenn wir im Review-Modus sind und eine Basis-Datei mit Shadow-Twin ausgewählt wird,
    // dann automatisch das Shadow-Twin setzen
    if (group && group.transcriptFiles && group.transcriptFiles.length > 0) {
      const shadowTwin = group.transcriptFiles[0];
      FileLogger.info('FileList', 'Basis-Datei mit Shadow-Twin ausgewählt', {
        twinId: shadowTwin.id,
        twinName: shadowTwin.metadata.name,
        baseFileId: item.id,
        baseFileName: item.metadata.name
      });
      setSelectedShadowTwin(shadowTwin);
    } else {
      FileLogger.info('FileList', 'Datei ohne Shadow-Twin ausgewählt', {
        itemId: item.id,
        itemName: item.metadata.name,
        groupExists: !!group,
        transcriptCount: group?.transcriptFiles?.length ?? 0
      });
      setSelectedShadowTwin(null);
    }
  }, [setSelectedFile, setSelectedShadowTwin, findFileGroup]);
  
  // Erweiterte handleSelectRelatedFile Funktion für Review-Mode
  const handleSelectRelatedFile = useCallback((shadowTwin: StorageItem) => {
    StateLogger.info('FileList', 'Shadow-Twin ausgewählt', {
      shadowTwinId: shadowTwin.id,
      shadowTwinName: shadowTwin.metadata.name
    });
    
    // Setze das Shadow-Twin als ausgewählte Datei, damit es rechts angezeigt wird
    setSelectedFile(shadowTwin);
    setSelectedShadowTwin(null); // Kein zusätzliches Shadow-Twin im normalen Modus
  }, [setSelectedFile, setSelectedShadowTwin, findFileGroup]);

  // Aktualisierte handleRefresh Funktion
  const handleRefresh = useCallback(async () => {
    if (!items || items.length === 0) return;
    
    const parentId = items[0]?.parentId;
    if (!parentId) return;
    
    setIsRefreshing(true);
    
    try {
      const refreshedItems = await refreshItems(parentId);
      setFolderItems(refreshedItems);
    } catch (error) {
      FileLogger.error('FileList', 'Fehler beim Aktualisieren der Dateiliste', error);
    } finally {
      setIsRefreshing(false);
    }
  }, [items, refreshItems, setFolderItems]);

  const handleCreateTranscript = React.useCallback((e: React.MouseEvent) => {
    e.stopPropagation();
    FileLogger.info('FileList', 'Create transcript for', { fileName: 'TODO' });
    // TODO: Implement transcript creation
  }, []);

  // Entfernt: handleItemSelect war unbenutzt

  // Check if an item is selected (beide Atome prüfen)
  const isItemSelected = useCallback((item: StorageItem) => {
    const mediaType = getMediaType(item);
    if (mediaType === 'audio' || mediaType === 'video') {
      return selectedBatchItems.some(selected => selected.item.id === item.id);
    } else {
      return selectedTransformationItems.some(selected => selected.item.id === item.id);
    }
  }, [selectedBatchItems, selectedTransformationItems]);

  // Löschfunktion
  const handleDeleteClick = React.useCallback(async (e: React.MouseEvent<HTMLButtonElement>, itemToDelete: StorageItem) => {
    e.stopPropagation();
    
    if (!provider) {
      toast.error("Fehler", {
        description: "Storage Provider nicht verfügbar"
      });
      return;
    }

    try {
      // Finde die FileGroup für dieses Item
      const itemStem = getBaseName(itemToDelete.metadata.name);
      const fileGroup = findFileGroup(fileGroups, itemStem);

      // Bestätigungsnachricht vorbereiten
      let confirmMessage = `Möchten Sie "${itemToDelete.metadata.name}" wirklich löschen?`;
      if (fileGroup && itemToDelete.id === fileGroup.baseItem?.id) {
        if (fileGroup.transcriptFiles && fileGroup.transcriptFiles.length > 0 || fileGroup.transformed) {
          confirmMessage = `Möchten Sie "${itemToDelete.metadata.name}" und alle zugehörigen Dateien wirklich löschen?`;
        }
      }

      // Benutzer um Bestätigung bitten
      if (!window.confirm(confirmMessage)) {
        return;
      }

      if (fileGroup && itemToDelete.id === fileGroup.baseItem?.id) {
        // Dies ist die Basis-Datei - lösche auch abhängige Dateien
        // Lösche alle Transkripte, falls vorhanden
        if (fileGroup.transcriptFiles) {
          for (const transcript of fileGroup.transcriptFiles) {
            try {
              await provider.deleteItem(transcript.id);
              FileLogger.info('FileList', 'Transkript gelöscht', {
                transcriptId: transcript.id,
                transcriptName: transcript.metadata.name
              });
            } catch (error) {
              FileLogger.error('FileList', 'Fehler beim Löschen des Transkripts', error);
              toast.warning("Hinweis", {
                description: "Einige Transkripte konnten nicht gelöscht werden"
              });
            }
          }
        }

        // Lösche die transformierte Datei, falls vorhanden
        if (fileGroup.transformed) {
          try {
            await provider.deleteItem(fileGroup.transformed.id);
            FileLogger.info('FileList', 'Transformierte Datei gelöscht', {
              transformedId: fileGroup.transformed.id,
              transformedName: fileGroup.transformed.metadata.name
            });
          } catch (error) {
            FileLogger.error('FileList', 'Fehler beim Löschen der transformierten Datei', error);
            toast.warning("Hinweis", {
              description: "Die transformierte Datei konnte nicht gelöscht werden"
            });
          }
        }

        // Lösche die Basis-Datei
        await provider.deleteItem(itemToDelete.id);
        toast.success("Dateien gelöscht", {
          description: `${itemToDelete.metadata.name} und zugehörige Dateien wurden gelöscht.`
        });
      } else {
        // Dies ist eine abhängige Datei oder keine Gruppe - nur diese Datei löschen
        await provider.deleteItem(itemToDelete.id);
        toast.success("Datei gelöscht", {
          description: `${itemToDelete.metadata.name} wurde gelöscht.`
        });
      }

      // Aktualisiere die Dateiliste
      await handleRefresh();

      // Wenn die gelöschte Datei ausgewählt war, Auswahl aufheben
      setSelectedFile(null);
      
      // Aus der Batch-Auswahl entfernen
      setSelectedBatchItems(prev => prev.filter(i => i.item.id !== itemToDelete.id));

    } catch (error) {
      FileLogger.error('FileList', 'Fehler beim Löschen', error);
      toast.error("Fehler", {
        description: `Die Datei konnte nicht gelöscht werden: ${error instanceof Error ? error.message : 'Unbekannter Fehler'}`
      });
    }
  }, [provider, handleRefresh, fileGroups, setSelectedFile, setSelectedBatchItems]);

  const handleRename = React.useCallback(async (item: StorageItem, newName: string) => {
    if (!provider) {
      toast.error("Fehler", {
        description: "Storage Provider nicht verfügbar"
      });
      return;
    }

    try {
      // Finde die FileGroup für dieses Item
      const itemStem = getBaseName(item.metadata.name);
      const fileGroup = findFileGroup(fileGroups, itemStem);

      if (fileGroup && item.id === fileGroup.baseItem?.id) {
        // Dies ist die Basis-Datei - benenne auch abhängige Dateien um
        const oldStem = getBaseName(item.metadata.name);
        const newStem = getBaseName(newName);
        // Benenne die Basis-Datei um
        await provider.renameItem(item.id, newName);
        // Benenne alle Transkripte um, falls vorhanden
        if (fileGroup.transcriptFiles) {
          for (const transcript of fileGroup.transcriptFiles) {
            const transcriptName = transcript.metadata.name;
            const newTranscriptName = transcriptName.replace(oldStem, newStem);
            try {
              await provider.renameItem(transcript.id, newTranscriptName);
            } catch (error) {
              FileLogger.error('FileList', 'Fehler beim Umbenennen des Transkripts', error);
              toast.warning("Hinweis", {
                description: "Einige Transkripte konnten nicht umbenannt werden"
              });
            }
          }
        }
        // Benenne die transformierte Datei um, falls vorhanden
        if (fileGroup.transformed) {
          const transformedName = fileGroup.transformed.metadata.name;
          const newTransformedName = transformedName.replace(oldStem, newStem);
          try {
            await provider.renameItem(fileGroup.transformed.id, newTransformedName);
          } catch (error) {
            FileLogger.error('FileList', 'Fehler beim Umbenennen der transformierten Datei', error);
            toast.warning("Hinweis", {
              description: "Die transformierte Datei konnte nicht umbenannt werden"
            });
          }
        }
        toast.success("Dateien umbenannt", {
          description: `${item.metadata.name} und zugehörige Dateien wurden umbenannt.`
        });
      } else {
        // Dies ist eine abhängige Datei oder keine Gruppe - nur diese Datei umbenennen
        await provider.renameItem(item.id, newName);
        toast.success("Datei umbenannt", {
          description: `${item.metadata.name} wurde zu ${newName} umbenannt.`
        });
      }
      await handleRefresh();
    } catch (error) {
      FileLogger.error('FileList', 'Fehler beim Umbenennen', error);
      toast.error("Fehler", {
        description: `Die Datei konnte nicht umbenannt werden: ${error instanceof Error ? error.message : 'Unbekannter Fehler'}`
      });
      throw error;
    }
  }, [provider, handleRefresh, fileGroups]);

  const handleBatchTranscription = () => {
    if (selectedBatchItems.length > 0) {
      setTranscriptionDialogOpen(true);
    }
  };

  const handleBatchTransformation = () => {
    if (selectedTransformationItems.length > 0) {
      setTransformationDialogOpen(true);
    }
  };

  // Bulk-Löschung für ausgewählte Dateien (unabhängig von Batch/Transformation-Selektor)
  const handleBulkDelete = React.useCallback(async () => {
    if (!provider) return;
    const targets = [
      ...selectedBatchItems.map(x => x.item),
      ...selectedTransformationItems.map(x => x.item),
    ];
    if (targets.length === 0) return;
    const confirmMsg = targets.length === 1
      ? `"${targets[0].metadata.name}" wirklich löschen?`
      : `${targets.length} Dateien wirklich löschen?`;
    if (!window.confirm(confirmMsg)) return;

    try {
      const parentId = targets[0].parentId || 'root';
      for (const t of targets) {
        try { await provider.deleteItem(t.id); } catch (err) {
          FileLogger.error('FileList', 'Bulk Delete failed', { id: t.id, name: t.metadata.name, err });
        }
      }
      const refreshed = await refreshItems(parentId);
      setFolderItems(refreshed);
      setSelectedBatchItems([]);
      setSelectedTransformationItems([]);
    } catch (error) {
      FileLogger.error('FileList', 'Bulk Delete error', error);
    }
  }, [provider, selectedBatchItems, selectedTransformationItems, refreshItems, setFolderItems, setSelectedBatchItems, setSelectedTransformationItems]);

  // Intelligente Batch-Auswahl basierend auf Filter
  const handleSelectAll = useCallback((checked: boolean) => {
    const startTime = performance.now();
    if (checked) {
      // Verwende nur die Hauptdateien (baseItem) aus den FileGroups
      const mainItems = Array.from((fileGroups ?? new Map()).values())
        .map(group => group.baseItem)
        .filter((item): item is StorageItem => item !== undefined);
      const selectableItems = mainItems.filter(item => {
        try {
          const mediaType = getMediaType(item);
          // Je nach Filter unterschiedliche Dateien auswählen
          switch (currentCategoryFilter) {
            case 'media':
              return item.type === 'file' && (mediaType === 'audio' || mediaType === 'video');
            case 'text':
              return item.type === 'file' && mediaType === 'text';
            case 'documents':
              return item.type === 'file' && mediaType === 'document';
            default:
              // Bei 'all' alle Dateien auswählen, die für eine Operation geeignet sind
              return item.type === 'file' && (
                mediaType === 'audio' || 
                mediaType === 'video' || 
                mediaType === 'text' || 
                mediaType === 'document'
              );
          }
        } catch {
          return false;
        }
      });
      StateLogger.info('FileList', 'Selecting all items based on filter', {
        filter: currentCategoryFilter,
        totalItems: items.length,
        selectableCount: selectableItems.length,
        duration: `${(performance.now() - startTime).toFixed(2)}ms`
      });
      // Je nach Filter unterschiedliche Atome verwenden
      if (currentCategoryFilter === 'media') {
        setSelectedBatchItems(selectableItems.map(item => ({
          item,
          type: getMediaType(item)
        })));
      } else if (currentCategoryFilter === 'text') {
        setSelectedTransformationItems(selectableItems.map(item => ({
          item,
          type: getMediaType(item)
        })));
      } else {
        // Bei 'all' oder 'documents' beide Atome füllen
        const mediaItems = selectableItems.filter(item => {
          const mediaType = getMediaType(item);
          return mediaType === 'audio' || mediaType === 'video';
        });
        const textItems = selectableItems.filter(item => {
          const mediaType = getMediaType(item);
          return mediaType === 'text' || mediaType === 'document';
        });
        setSelectedBatchItems(mediaItems.map(item => ({
          item,
          type: getMediaType(item)
        })));
        setSelectedTransformationItems(textItems.map(item => ({
          item,
          type: getMediaType(item)
        })));
      }
    } else {
      StateLogger.info('FileList', 'Deselecting all items', {
        previouslySelected: selectedBatchItems.length + selectedTransformationItems.length,
        duration: `${(performance.now() - startTime).toFixed(2)}ms`
      });
      setSelectedBatchItems([]);
      setSelectedTransformationItems([]);
    }
  }, [fileGroups, currentCategoryFilter, setSelectedBatchItems, setSelectedTransformationItems, selectedBatchItems.length, selectedTransformationItems.length, items.length]);

  React.useEffect(() => {
    // Logging der Library-IDs - verzögert ausführen
    const timeoutId = setTimeout(() => {
      StateLogger.debug('FileList', 'Render', {
        currentLibraryId: currentLibrary?.id,
        activeLibraryIdAtom: activeLibraryId
      });
    }, 0);
    
    return () => clearTimeout(timeoutId);
  }, [currentLibrary, activeLibraryId]);

  // Entkoppelt: kein Render-Gate mehr basierend auf FileTree

  return (
    <div className="h-full flex flex-col">
      {/* Header - versteckt im compact mode */}
      {!compact && (
        <div className="border-b px-2 py-2 flex items-center justify-between bg-background sticky top-0 z-10">
          <div className="flex items-center gap-2">
            <Button
              variant="ghost"
              size="icon"
              className="h-8 w-8"
              onClick={handleRefresh}
              disabled={isRefreshing}
              title="Aktualisieren"
              aria-label="Aktualisieren"
            >
              <RefreshCw className={cn("h-4 w-4", isRefreshing && "animate-spin")} />
            </Button>

            {/* Dateikategorie-Filter (Icon-only Variante) */}
            <FileCategoryFilter iconOnly />

            {/* Batch-Actions als Icons */}
            {selectedBatchItems.length > 0 && (
              <Button size="icon" title="Transkribieren" aria-label="Transkribieren" onClick={handleBatchTranscription}>
                <ScrollText className="h-4 w-4" />
              </Button>
            )}
            {selectedTransformationItems.length > 0 && (
              <Button size="icon" variant="secondary" title="Transformieren" aria-label="Transformieren" onClick={handleBatchTransformation}>
                <Plus className="h-4 w-4" />
              </Button>
            )}
            {(selectedBatchItems.length + selectedTransformationItems.length) > 0 && (
              <Button size="icon" variant="destructive" title="Ausgewählte löschen" aria-label="Ausgewählte löschen" onClick={handleBulkDelete}>
                <Trash2 className="h-4 w-4" />
              </Button>
            )}
          </div>
        </div>
      )}

      {/* File List */}
      <div className="flex-1 overflow-auto">
        <div>
          {/* Table Header - versteckt im compact mode */}
          {!compact && (
            <div className="sticky top-0 bg-background border-b">
              <div className="grid grid-cols-[24px_24px_minmax(0,1fr)_56px_88px_auto] gap-2 px-4 py-2 text-sm font-medium text-muted-foreground">
                <div className="w-6 flex items-center justify-center">
                  <Checkbox
                    checked={isAllSelected}
                    onCheckedChange={handleSelectAll}
                    aria-label="Alle auswählen"
                  />
                </div>
                <div className="w-6" />
                <SortableHeaderCell
                  label="Name"
                  field="name"
                  currentSortField={sortField}
                  currentSortOrder={sortOrder}
                  onSort={handleSort}
                />
                <SortableHeaderCell
                  label="Größe"
                  field="size"
                  currentSortField={sortField}
                  currentSortOrder={sortOrder}
                  onSort={handleSort}
                />
                <SortableHeaderCell
                  label="Geändert"
                  field="date"
                  currentSortField={sortField}
                  currentSortOrder={sortOrder}
                  onSort={handleSort}
                />
                <div />
              </div>
            </div>
          )}

          {/* Folder Rows (oberhalb der Dateien, unabhängig von Datei-Gruppierung) */}
          {folders.length > 0 && (
            <div className="divide-y">
          {folders.map((folder) => (
            compact ? (
              // Kompakt: ohne Einrückung, nur Icon + Name (2 Spalten)
              <div
                key={folder.id}
                role="button"
                tabIndex={0}
                onClick={() => navigateToFolder(folder.id)}
                onKeyDown={(e) => { if (e.key === 'Enter' || e.key === ' ') navigateToFolder(folder.id) }}
                className="w-full px-2 py-1 text-xs hover:bg-muted/50 grid grid-cols-[24px_minmax(0,1fr)] gap-2 items-center cursor-pointer"
              >
                <FolderIcon className="h-4 w-4" />
                <span className="text-left truncate select-none" title={folder.metadata.name}>{folder.metadata.name}</span>
              </div>
            ) : (
              // Normal: behalte leichte Einrückung für Checkbox-Spalte
              <div
                key={folder.id}
                role="button"
                tabIndex={0}
                onClick={() => navigateToFolder(folder.id)}
                onKeyDown={(e) => { if (e.key === 'Enter' || e.key === ' ') navigateToFolder(folder.id) }}
                className="w-full px-4 py-2 text-xs hover:bg-muted/50 grid grid-cols-[24px_24px_minmax(0,1fr)] gap-2 items-center cursor-pointer"
              >
                <div />
                <FolderIcon className="h-4 w-4" />
                <span className="text-left truncate select-none" title={folder.metadata.name}>{folder.metadata.name}</span>
              </div>
            )
          ))}
            </div>
          )}

          {/* File Rows */}
          <div className="divide-y">
            {Array.from((fileGroups ?? new Map()).values())
              .map((group) => {
                // Zeige nur die Hauptdatei (baseItem) an
                const item = group.baseItem;
                if (!item) return null;
                // System-Unterordner-Id, wenn ein ".<basename>"-Folder existiert
                const systemFolder = systemFolderByBase.get(getBaseName(item.metadata.name));
                const systemFolderId = systemFolder?.id;
                const isActive = !!activeFile && activeFile.id === item.id
                return (
                  <FileRow
                    key={item.id}
                    item={item as StorageItem}
                    isSelected={isItemSelected(item)}
                    isActive={isActive}
                    onSelect={() => handleSelect(item, group)}
                    onCreateTranscript={handleCreateTranscript}
                    onDelete={(e) => handleDeleteClick(e, item)}
                    fileGroup={group}
                    onSelectRelatedFile={handleSelectRelatedFile}
                    onRename={handleRename}
                    compact={compact}
                    systemFolderId={systemFolderId}
                  />
                );
              })}
          </div>
        </div>
      </div>
    </div>
  );
}); 
```

Kompaktansicht: Ordner sind jetzt linksbündig ohne Einrückung.

- Kompakt: Grid nur Icon + Name (2 Spalten, keine linke Leerspalte).
- Normal: leichte Einrückung bleibt konsistent mit Checkbox-Spalte.
- Tooltip weiterhin voller Ordnername.

Bitte kurz prüfen, ob die Ordner in der kompakten Liste nun bündig links stehen.

---

**User**

ok, jetzt ist noch in der kompaktansicht der Font von Verzeichnisse und Dateien unterschiedlich. Auch sind dateinamen anders eingerückt. der von Verzeichnisse wäre richtig. Bitte Dateinamen anpassen

---

**Cursor**

```typescriptreact
'use client';

import * as React from "react"
import { File, FileText, FileVideo, FileAudio, Plus, RefreshCw, ChevronUp, ChevronDown, Trash2, ScrollText, Folder as FolderIcon, Layers } from "lucide-react"
import { StorageItem } from "@/lib/storage/types"
import { cn } from "@/lib/utils"
import { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from "@/components/ui/tooltip"
import { useStorage } from "@/contexts/storage-context";
import { Button } from "@/components/ui/button";
import { useAtomValue, useAtom } from 'jotai';
import { jobStatusByItemIdAtom } from '@/atoms/job-status';
import { 
  activeLibraryIdAtom, 
  selectedFileAtom, 
  folderItemsAtom,
  sortedFilteredFilesAtom,
  sortFieldAtom,
  sortOrderAtom,
  selectedShadowTwinAtom
} from '@/atoms/library-atom';
import { toast } from "sonner";
import { Input } from "@/components/ui/input"
import {
  selectedBatchItemsAtom,
  transcriptionDialogOpenAtom,
  selectedTransformationItemsAtom,
  transformationDialogOpenAtom,
  getMediaType,
  fileCategoryFilterAtom,
} from '@/atoms/transcription-options';
import { Checkbox } from "@/components/ui/checkbox"
import { useMemo, useCallback } from "react"
import { FileLogger, StateLogger } from "@/lib/debug/logger"
import { FileCategoryFilter } from './file-category-filter';
import { useFolderNavigation } from "@/hooks/use-folder-navigation";

// Typen für Sortieroptionen
type SortField = 'type' | 'name' | 'size' | 'date';
type SortOrder = 'asc' | 'desc';

// Typ für gruppierte Dateien
interface FileGroup {
  baseItem?: StorageItem;
  transcriptFiles?: StorageItem[]; // NEU: alle Transkripte
  transformed?: StorageItem;
}

// Memoized file icon component
const FileIconComponent = React.memo(function FileIconComponent({ item }: { item: StorageItem }) {
  const mimeType = item.metadata.mimeType || '';
  if (!mimeType) return <File className="h-4 w-4" />;

  if (mimeType.startsWith('video/')) {
    return <FileVideo className="h-4 w-4" />;
  } else if (mimeType.startsWith('audio/')) {
    return <FileAudio className="h-4 w-4" />;
  } else if (mimeType.startsWith('text/')) {
    return <FileText className="h-4 w-4" />;
  }

  return <File className="h-4 w-4" />;
});

// Pure function for file size formatting
const formatFileSize = (size?: number): string => {
  if (!size) return '-';
  const units = ['B', 'KB', 'MB', 'GB'];
  let value = size;
  let unitIndex = 0;
  
  while (value >= 1024 && unitIndex < units.length - 1) {
    value /= 1024;
    unitIndex++;
  }
  
  return `${value.toFixed(1)} ${units[unitIndex]}`;
};

// Funktion zum Formatieren des Datums
const formatDate = (date?: Date): string => {
  if (!date) return '-';
  
  const options: Intl.DateTimeFormatOptions = { 
    year: '2-digit', 
    month: '2-digit', 
    day: '2-digit',
    hour: '2-digit',
    minute: '2-digit'
  };
  
  return new Date(date).toLocaleDateString('de-DE', options);
};

// Entfernt: getFileStem Funktion war unbenutzt

// Sortierbare Kopfzelle Komponente
const SortableHeaderCell = React.memo(function SortableHeaderCell({
  label,
  field,
  currentSortField,
  currentSortOrder,
  onSort
}: {
  label: string,
  field: SortField,
  currentSortField: SortField,
  currentSortOrder: SortOrder,
  onSort: (field: SortField) => void
}) {
  const isActive = currentSortField === field;
  
  return (
    <button 
      onClick={() => onSort(field)}
      className="flex items-center gap-1 hover:text-foreground"
    >
      <span>{label}</span>
      {isActive && (
        currentSortOrder === 'asc' 
          ? <ChevronUp className="h-3 w-3" /> 
          : <ChevronDown className="h-3 w-3" />
      )}
    </button>
  );
});

interface FileRowProps {
  item: StorageItem;
  isSelected: boolean;
  isActive?: boolean;
  onSelect: () => void;
  onCreateTranscript: (e: React.MouseEvent) => void;
  onDelete: (e: React.MouseEvent<HTMLButtonElement>, item: StorageItem) => void;
  fileGroup?: FileGroup;
  onSelectRelatedFile?: (file: StorageItem) => void;
  onRename?: (item: StorageItem, newName: string) => Promise<void>;
  compact?: boolean;
  systemFolderId?: string;
}

const FileRow = React.memo(function FileRow({ 
  item, 
  isSelected, 
  isActive = false,
  onSelect,
  onCreateTranscript,
  onDelete,
  fileGroup,
  onSelectRelatedFile,
  onRename,
  compact = false,
  systemFolderId
}: FileRowProps) {
  const navigateToFolder = useFolderNavigation();
  const [isEditing, setIsEditing] = React.useState(false);
  const [editName, setEditName] = React.useState(item.metadata.name);
  const inputRef = React.useRef<HTMLInputElement>(null);
  const longPressTimerRef = React.useRef<NodeJS.Timeout | null>(null);
  const lastClickTimeRef = React.useRef<number>(0);
  
  // Zusätzliche Validierung der Metadaten
  const metadata = React.useMemo(() => ({
    name: item.metadata?.name || 'Unbekannte Datei',
    size: typeof item.metadata?.size === 'number' ? item.metadata.size : 0,
    mimeType: item.metadata?.mimeType || '',
    hasTranscript: !!item.metadata?.hasTranscript || (fileGroup?.transcriptFiles && fileGroup.transcriptFiles.length > 0),
    modifiedAt: item.metadata?.modifiedAt
  }), [item.metadata, fileGroup]);

  const isTranscribable = React.useMemo(() => {
    const mimeType = metadata.mimeType.toLowerCase();
    const extension = metadata.name.split('.').pop()?.toLowerCase();

    return (
      mimeType.startsWith('audio/') ||
      mimeType.startsWith('video/') ||
      extension === 'pdf' ||
      mimeType === 'application/pdf'
    );
  }, [metadata.mimeType, metadata.name]);

  // Memoize the click handler
  const handleClick = React.useCallback(() => {
    if (!isEditing) {
      onSelect();
    }
  }, [onSelect, isEditing]);

  // Memoize the keydown handler
  const handleKeyDown = React.useCallback((e: React.KeyboardEvent) => {
    if (!isEditing && (e.key === 'Enter' || e.key === ' ')) {
      onSelect();
    }
  }, [onSelect, isEditing]);

  // Handler für Transkript-Icon Click
  const handleTranscriptClick = React.useCallback((e: React.MouseEvent) => {
    e.stopPropagation();
    if (fileGroup?.transcriptFiles && onSelectRelatedFile) {
      onSelectRelatedFile(fileGroup.transcriptFiles[0]); // Nur das erste Transkript anzeigen
    }
  }, [fileGroup, onSelectRelatedFile]);

  // Handler für Transformierte-Datei-Icon Click
  const handleTransformedClick = React.useCallback((e: React.MouseEvent) => {
    e.stopPropagation();
    if (fileGroup?.transformed && onSelectRelatedFile) {
      onSelectRelatedFile(fileGroup.transformed);
    }
  }, [fileGroup, onSelectRelatedFile]);

  // Starte Rename-Modus
  const startRename = React.useCallback(() => {
    if (onRename) {
      // Prüfe ob dies eine abhängige Datei ist
      if (fileGroup && (
        (fileGroup.transcriptFiles && fileGroup.transcriptFiles.length > 0 && fileGroup.transcriptFiles[0]?.id === item.id) ||
        (fileGroup.transformed && item.id === fileGroup.transformed.id)
      )) {
        // Dies ist eine abhängige Datei - zeige Hinweis
        toast.info("Hinweis", {
          description: "Bitte benennen Sie die Haupt-Datei um. Abhängige Dateien werden automatisch mit umbenannt."
        });
        return;
      }
      
      setIsEditing(true);
      setEditName(item.metadata.name);
    }
  }, [onRename, item, fileGroup]);

  // Handler für Dateinamen-Click (Doppelklick-Erkennung)
  const handleNameClick = React.useCallback((e: React.MouseEvent) => {
    e.stopPropagation();
    
    const currentTime = Date.now();
    const timeSinceLastClick = currentTime - lastClickTimeRef.current;
    
    if (timeSinceLastClick < 300) {
      // Doppelklick erkannt
      startRename();
    } else {
      // Erster Klick - wähle die Datei aus
      onSelect();
    }
    
    lastClickTimeRef.current = currentTime;
  }, [startRename, onSelect]);

  // Handler für Long-Press (Touch-Geräte)
  const handleTouchStart = React.useCallback((e: React.TouchEvent) => {
    e.stopPropagation();
    
    // Starte Long-Press Timer
    longPressTimerRef.current = setTimeout(() => {
      startRename();
    }, 500); // 500ms für Long-Press
  }, [startRename]);

  const handleTouchEnd = React.useCallback((e: React.TouchEvent) => {
    e.stopPropagation();
    
    // Lösche Long-Press Timer
    if (longPressTimerRef.current) {
      clearTimeout(longPressTimerRef.current);
      longPressTimerRef.current = null;
    }
  }, []);

  const handleTouchMove = React.useCallback(() => {
    // Bei Bewegung Long-Press abbrechen
    if (longPressTimerRef.current) {
      clearTimeout(longPressTimerRef.current);
      longPressTimerRef.current = null;
    }
  }, []);

  // Cleanup Timer bei Unmount
  React.useEffect(() => {
    return () => {
      if (longPressTimerRef.current) {
        clearTimeout(longPressTimerRef.current);
      }
    };
  }, []);

  // Handler für Rename-Submit
  const handleRenameSubmit = React.useCallback(async () => {
    if (onRename && editName.trim() && editName !== item.metadata.name) {
      try {
        await onRename(item, editName.trim());
      } catch (error) {
        FileLogger.error('FileRow', 'Fehler beim Umbenennen', error);
        // Bei Fehler den ursprünglichen Namen wiederherstellen
        setEditName(item.metadata.name);
      }
    }
    setIsEditing(false);
  }, [onRename, editName, item]);

  // Handler für Rename-Cancel
  const handleRenameCancel = React.useCallback(() => {
    setEditName(item.metadata.name);
    setIsEditing(false);
  }, [item.metadata.name]);

  // Handler für Input-Änderungen
  const handleInputChange = React.useCallback((e: React.ChangeEvent<HTMLInputElement>) => {
    setEditName(e.target.value);
  }, []);

  // Handler für Input-Keydown
  const handleInputKeyDown = React.useCallback((e: React.KeyboardEvent<HTMLInputElement>) => {
    e.stopPropagation();
    if (e.key === 'Enter') {
      handleRenameSubmit();
    } else if (e.key === 'Escape') {
      handleRenameCancel();
    }
  }, [handleRenameSubmit, handleRenameCancel]);

  // Focus Input wenn Edit-Modus aktiviert wird
  React.useEffect(() => {
    if (isEditing && inputRef.current) {
      inputRef.current.focus();
      inputRef.current.select();
    }
  }, [isEditing]);

  // Handler für Drag Start
  const handleDragStart = React.useCallback((e: React.DragEvent) => {
    // Sammle alle Dateien der Gruppe, die verschoben werden sollen
    const itemsToMove = [];
    
    // Füge das aktuelle Item hinzu
    itemsToMove.push({
      itemId: item.id,
      itemName: item.metadata.name,
      itemType: item.type,
      parentId: item.parentId
    });
    
    // Wenn es eine FileGroup gibt, füge auch die zugehörigen Dateien hinzu
    if (fileGroup) {
      // Prüfe ob das aktuelle Item die Basis-Datei ist
      if (item.id === fileGroup.baseItem?.id) {
        // Füge Transkripte hinzu, falls vorhanden
        if (fileGroup.transcriptFiles && fileGroup.transcriptFiles.length > 0) {
          fileGroup.transcriptFiles.forEach(transcript => {
            itemsToMove.push({
              itemId: transcript.id,
              itemName: transcript.metadata.name,
              itemType: transcript.type,
              parentId: transcript.parentId
            });
          });
        }
        
        // Füge transformierte Datei hinzu, falls vorhanden
        if (fileGroup.transformed) {
          itemsToMove.push({
            itemId: fileGroup.transformed.id,
            itemName: fileGroup.transformed.metadata.name,
            itemType: fileGroup.transformed.type,
            parentId: fileGroup.transformed.parentId
          });
        }
      }
    }
    
    // Setze die Drag-Daten
    e.dataTransfer.effectAllowed = 'move';
    e.dataTransfer.setData('application/json', JSON.stringify({
      items: itemsToMove,
      isFileGroup: itemsToMove.length > 1
    }));
    
    // Visuelles Feedback
    if (e.currentTarget instanceof HTMLElement) {
      e.currentTarget.style.opacity = '0.5';
    }
  }, [item, fileGroup]);

  // Handler für Drag End
  const handleDragEnd = React.useCallback((e: React.DragEvent) => {
    // Stelle Opacity wieder her
    if (e.currentTarget instanceof HTMLElement) {
      e.currentTarget.style.opacity = '1';
    }
  }, []);

  const [selectedBatchItems, setSelectedBatchItems] = useAtom(selectedBatchItemsAtom);
  const [selectedTransformationItems, setSelectedTransformationItems] = useAtom(selectedTransformationItemsAtom);
  
  // Prüfe ob das Item in einem der beiden Atome ausgewählt ist
  const isInBatch = selectedBatchItems.some(batchItem => batchItem.item.id === item.id);
  const isInTransformation = selectedTransformationItems.some(transformationItem => transformationItem.item.id === item.id);
  const isInAnyBatch = isInBatch || isInTransformation;

  // Handler für Checkbox-Änderungen
  const handleCheckboxChange = React.useCallback((checked: boolean) => {
    const mediaType = getMediaType(item);
    
    if (mediaType === 'audio' || mediaType === 'video') {
      // Für Audio/Video: Transcription-Atom verwenden
      if (checked) {
        setSelectedBatchItems([...selectedBatchItems, {
          item,
          type: mediaType
        }]);
      } else {
        setSelectedBatchItems(selectedBatchItems.filter(i => i.item.id !== item.id));
      }
    } else if (mediaType === 'text' || mediaType === 'document') {
      // Für Text/Dokumente: Transformation-Atom verwenden
      if (checked) {
        setSelectedTransformationItems([...selectedTransformationItems, {
          item,
          type: mediaType
        }]);
      } else {
        setSelectedTransformationItems(selectedTransformationItems.filter(i => i.item.id !== item.id));
      }
    }
  }, [item, selectedBatchItems, selectedTransformationItems, setSelectedBatchItems, setSelectedTransformationItems]);

  React.useEffect(() => {
    if (fileGroup) {
      FileLogger.debug('FileRow', 'Transkripte für Zeile', {
        baseItem: fileGroup.baseItem?.metadata.name,
        transcripts: fileGroup.transcriptFiles?.map(t => t.metadata.name)
      });
    }
  }, [fileGroup]);

  // Zentraler Jobstatus (muss vor möglichen early-returns stehen, um Hook-Order zu garantieren)
  const jobStatusMap = useAtomValue(jobStatusByItemIdAtom);
  const jobStatus = jobStatusMap[item.id];
  const jobStatusIcon = jobStatus ? (
    <span title={jobStatus} className={cn('inline-block h-3 w-3 rounded-full',
      jobStatus === 'queued' && 'bg-blue-600',
      jobStatus === 'running' && 'bg-yellow-600',
      jobStatus === 'completed' && 'bg-green-600',
      jobStatus === 'failed' && 'bg-red-600'
    )} aria-label={`job-${jobStatus}`} />
  ) : null;

  // Compact-Modus: vereinfachte Darstellung
  if (compact) {
    return (
      <div
        role="button"
        tabIndex={0}
        onClick={handleClick}
        onKeyDown={handleKeyDown}
        className={cn(
          "w-full px-2 py-1 text-xs hover:bg-muted/50 grid grid-cols-[24px_minmax(0,1fr)] gap-2 items-center cursor-pointer",
          isSelected && "bg-muted",
          isActive && "bg-primary/10 border-l-2 border-primary"
        )}
      >
        <FileIconComponent item={item} />
        <span className={cn("truncate", isActive && "font-medium")} title={metadata.name}>
          {metadata.name}
        </span>
      </div>
    );
  }

  return (
    <div
      role="button"
      tabIndex={0}
      onClick={handleClick}
      onKeyDown={handleKeyDown}
      onTouchStart={handleTouchStart}
      onTouchEnd={handleTouchEnd}
      onTouchMove={handleTouchMove}
      draggable={!isEditing}
      onDragStart={handleDragStart}
      onDragEnd={handleDragEnd}
      className={cn(
        "w-full px-4 py-2 text-xs hover:bg-muted/50 grid grid-cols-[24px_24px_minmax(0,1fr)_56px_88px_auto] gap-2 items-center cursor-move",
        isSelected && "bg-muted",
        isActive && "bg-primary/10 border-l-2 border-primary"
      )}
    >
      <div className="w-6 flex items-center justify-center">
        <Checkbox
          checked={isInAnyBatch}
          onCheckedChange={handleCheckboxChange}
          onClick={(e) => e.stopPropagation()}
        />
      </div>
      <FileIconComponent item={item} />
      {isEditing ? (
        <Input
          ref={inputRef}
          value={editName}
          onChange={handleInputChange}
          onKeyDown={handleInputKeyDown}
          onBlur={handleRenameSubmit}
          onClick={(e) => e.stopPropagation()}
          className="h-6 px-1 py-0 text-xs"
        />
      ) : (
        <span 
          className={cn("text-left truncate cursor-pointer hover:text-primary select-none", isActive && "font-medium")}
          onClick={handleNameClick}
          onTouchStart={handleTouchStart}
          onTouchEnd={handleTouchEnd}
          onTouchMove={handleTouchMove}
          title={metadata.name}
        >
          {metadata.name}
        </span>
      )}
      <span className="text-muted-foreground tabular-nums text-[10px]">
        {formatFileSize(metadata.size)}
      </span>
      <span className="text-muted-foreground tabular-nums text-[10px]">
        {formatDate(metadata.modifiedAt)}
      </span>
      <div className="flex items-center justify-start gap-1">
        {jobStatusIcon}
        {/* System-Unterordner (z. B. extrahierte Seiten) */}
        {systemFolderId && (
          <TooltipProvider>
            <Tooltip>
              <TooltipTrigger asChild>
                <Button
                  variant="ghost"
                  size="icon"
                  className="h-6 w-6 p-0 hover:bg-muted"
                  onClick={(e) => {
                    e.stopPropagation();
                    navigateToFolder(systemFolderId);
                  }}
                >
                  <Layers className="h-4 w-4 text-violet-500" />
                </Button>
              </TooltipTrigger>
              <TooltipContent>
                <p>Seiten-Ordner öffnen</p>
              </TooltipContent>
            </Tooltip>
          </TooltipProvider>
        )}
        {/* Zeige Icons für alle vorhandenen Transkripte */}
        {fileGroup?.transcriptFiles && fileGroup.transcriptFiles.length > 0 && fileGroup.transcriptFiles.map((transcript) => (
          <TooltipProvider key={transcript.id}>
            <Tooltip>
              <TooltipTrigger asChild>
                <Button
                  variant="ghost"
                  size="icon"
                  className="h-6 w-6 p-0 hover:bg-muted"
                  onClick={(e) => {
                    e.stopPropagation();
                    if (onSelectRelatedFile) onSelectRelatedFile(transcript);
                  }}
                >
                  <FileText className="h-4 w-4 text-blue-500" />
                </Button>
              </TooltipTrigger>
              <TooltipContent>
                <p>Transkript anzeigen: {transcript.metadata.name}</p>
              </TooltipContent>
            </Tooltip>
          </TooltipProvider>
        ))}
        {/* Plus-Symbol nur anzeigen, wenn kein Transkript vorhanden und transkribierbar */}
        {(!fileGroup?.transcriptFiles || fileGroup.transcriptFiles.length === 0) && isTranscribable && !metadata.hasTranscript ? (
          <TooltipProvider>
            <Tooltip>
              <TooltipTrigger asChild>
                <div 
                  role="button"
                  tabIndex={0}
                  className="h-6 w-6 p-0 inline-flex items-center justify-center hover:bg-muted rounded-sm"
                  onClick={onCreateTranscript}
                  onKeyDown={(e) => {
                    if (e.key === 'Enter' || e.key === ' ') {
                      e.stopPropagation();
                      onCreateTranscript(e as unknown as React.MouseEvent<HTMLDivElement>);
                    }
                  }}
                >
                  <Plus className="h-4 w-4" />
                </div>
              </TooltipTrigger>
              <TooltipContent>
                <p>Transkript erstellen</p>
              </TooltipContent>
            </Tooltip>
          </TooltipProvider>
        ) : null}
        {/* Icon für transformierte Datei */}
        {fileGroup?.transformed && (
          <TooltipProvider>
            <Tooltip>
              <TooltipTrigger asChild>
                <Button
                  variant="ghost"
                  size="icon"
                  className="h-6 w-6 p-0 hover:bg-muted"
                  onClick={handleTransformedClick}
                >
                  <ScrollText className="h-4 w-4 text-green-500" />
                </Button>
              </TooltipTrigger>
              <TooltipContent>
                <p>Transformierte Datei anzeigen</p>
              </TooltipContent>
            </Tooltip>
          </TooltipProvider>
        )}
        {/* Delete direkt neben Dokument-Icons */}
        <TooltipProvider>
          <Tooltip>
            <TooltipTrigger asChild>
              <Button
                variant="ghost"
                size="icon"
                className="h-6 w-6 p-0 hover:bg-destructive/10 hover:text-destructive"
                onClick={(e) => onDelete(e as React.MouseEvent<HTMLButtonElement>, item)}
              >
                <Trash2 className="h-4 w-4" />
              </Button>
            </TooltipTrigger>
            <TooltipContent>
              <p>Datei löschen</p>
            </TooltipContent>
          </Tooltip>
        </TooltipProvider>
      </div>
      <div />
    </div>
  );
});

interface FileListProps {
  compact?: boolean;
}

export const FileList = React.memo(function FileList({ compact = false }: FileListProps): JSX.Element {
  const { provider, refreshItems, currentLibrary } = useStorage();
  const activeLibraryId = useAtomValue(activeLibraryIdAtom);
  const [isRefreshing, setIsRefreshing] = React.useState(false);
  // Mobile-Flag wurde entfernt, FileList lädt unabhängig vom View
  const [selectedBatchItems, setSelectedBatchItems] = useAtom(selectedBatchItemsAtom);
  const [selectedTransformationItems, setSelectedTransformationItems] = useAtom(selectedTransformationItemsAtom);
  const [, setTranscriptionDialogOpen] = useAtom(transcriptionDialogOpenAtom);
  const [, setTransformationDialogOpen] = useAtom(transformationDialogOpenAtom);
  const [isInitialized, setIsInitialized] = React.useState(false);
  const initializationTimeoutRef = React.useRef<NodeJS.Timeout | null>(null);
  // Entkoppelt: Kein Warten mehr auf FileTree-Status
  const [activeFile, setSelectedFile] = useAtom(selectedFileAtom);
  const [, setFolderItems] = useAtom(folderItemsAtom);
  const currentCategoryFilter = useAtomValue(fileCategoryFilterAtom);
  const allItemsInFolder = useAtomValue(folderItemsAtom);
  const navigateToFolder = useFolderNavigation();

  // Kein mobiles Flag mehr notwendig

  const folders = useMemo(() => {
    const items = allItemsInFolder ?? [];
    // Verstecke dot-Verzeichnisse generell in der Liste
    return items.filter(item => item.type === 'folder' && !item.metadata.name.startsWith('.'));
  }, [allItemsInFolder]);

  // Hilfsfunktion zum Finden einer FileGroup in der Map
  const findFileGroup = (map: Map<string, FileGroup>, stem: string): FileGroup | undefined => {
    return Array.from((map ?? new Map()).values()).find(group => 
      group.baseItem && getBaseName(group.baseItem.metadata.name) === stem
    );
  };

  // NEU: Atome für Sortierung und Filter
  const items = useAtomValue(sortedFilteredFilesAtom);
  const [sortField, setSortField] = useAtom(sortFieldAtom);
  const [sortOrder, setSortOrder] = useAtom(sortOrderAtom);
  
  // Review-Mode-Atoms
  const [, setSelectedShadowTwin] = useAtom(selectedShadowTwinAtom);

  // handleSort nutzt jetzt Atome
  const handleSort = React.useCallback((field: SortField) => {
    if (field === sortField) setSortOrder(sortOrder === 'asc' ? 'desc' : 'asc');
    else {
      setSortField(field);
      setSortOrder('asc');
    }
  }, [sortField, sortOrder, setSortField, setSortOrder]);

  // Initialisierung - nur auf Provider und Mobile-Flag achten
  React.useEffect(() => {
    if (!provider) {
      FileLogger.info('FileList', 'Waiting for provider');
      return;
    }

    const initialize = async () => {
      if (isInitialized) {
        FileLogger.debug('FileList', 'Already initialized');
        return;
      }

      FileLogger.info('FileList', 'Starting initialization');

      try {
        FileLogger.info('FileList', 'Initialization complete');
        setIsInitialized(true);
      } catch (error) {
        FileLogger.error('FileList', 'Error initializing FileList', error);
      }
    };

    initialize();

    const timeoutRef = initializationTimeoutRef.current;
    return () => {
      if (timeoutRef) clearTimeout(timeoutRef);
    };
  }, [provider, isInitialized]);

  // NEU: Reagieren auf Bibliothekswechsel
  const prevLibraryIdRef = React.useRef<string | null>(null);
  React.useEffect(() => {
    StateLogger.debug('FileList', 'Render', {
      currentLibraryId: activeLibraryId,
      activeLibraryIdAtom: activeLibraryId
    });

    // Nur bei tatsächlichem Bibliothekswechsel zurücksetzen
    if (prevLibraryIdRef.current !== null && prevLibraryIdRef.current !== activeLibraryId) {
      setIsInitialized(false);
      setSelectedFile(null);
      setFolderItems([]);
      setSelectedBatchItems([]);
      setSelectedTransformationItems([]);
      setSelectedShadowTwin(null);
      StateLogger.info('FileList', 'Bibliothek gewechselt - State zurückgesetzt', {
        libraryId: activeLibraryId
      });
    }
    prevLibraryIdRef.current = activeLibraryId;
  }, [activeLibraryId, setSelectedFile, setFolderItems, setSelectedBatchItems, setSelectedTransformationItems, setSelectedShadowTwin]);

  // Vereinfachte Funktion zum Extrahieren des Basisnamens (ohne Endung, auch für Binärdateien)
  function getBaseName(name: string): string {
    // ShadowTwin: .de.md, .en.md, etc.
    const shadowTwinMatch = name.match(/^(.*)\.(de|en|fr|es|it)\.md$/);
    if (shadowTwinMatch) return shadowTwinMatch[1];
    // Sonst: alles vor der letzten Endung
    const lastDot = name.lastIndexOf('.');
    if (lastDot === -1) return name;
    return name.substring(0, lastDot);
  }

  // Prüft ob eine Datei ein ShadowTwin ist (Markdown mit Sprachkürzel)
  function isShadowTwin(name: string): boolean {
    // Pattern: name.de.md, name.en.md, etc.
    const shadowTwinPattern = /^(.+)\.(de|en|fr|es|it)\.md$/;
    return shadowTwinPattern.test(name);
  }

  // Gruppiere die Dateien nach Basename
  const fileGroups = useMemo(() => {
    if (!items) return new Map<string, FileGroup>();

    // Schritt 1: Gruppiere alle Dateien nach Basename
    const groupsMap = new Map<string, StorageItem[]>();
    for (const item of items) {
      if (item.type !== 'file') continue;
      const base = getBaseName(item.metadata.name);
      if (!groupsMap.has(base)) groupsMap.set(base, []);
      groupsMap.get(base)!.push(item);
    }

    // Schritt 2: Erstelle FileGroups
    const fileGroupsMap = new Map<string, FileGroup>();
    for (const [base, groupItems] of Array.from(groupsMap.entries())) {
      // Finde Hauptdatei (erste Nicht-ShadowTwin-Datei)
      const mainFile = groupItems.find((item) => !isShadowTwin(item.metadata.name));
      // Finde alle ShadowTwins
      const shadowTwins = groupItems.filter((item) => isShadowTwin(item.metadata.name));
      if (mainFile) {
        fileGroupsMap.set(base, {
          baseItem: mainFile,
          transcriptFiles: shadowTwins.length > 0 ? shadowTwins : undefined,
          transformed: undefined
        });
      } else {
        // Keine Hauptdatei: Jede ShadowTwin einzeln anzeigen
        for (const twin of shadowTwins) {
          fileGroupsMap.set(`${base}__shadow_${twin.id}`, {
            baseItem: twin,
            transcriptFiles: undefined,
            transformed: undefined
          });
        }
      }
    }
    // Debug-Logging für Gruppierung
    FileLogger.debug('FileList', 'Gruppierung Ergebnis (Basename, alle Endungen)', {
      groups: Array.from(fileGroupsMap.entries()).map(([base, group]) => ({
        base,
        baseItem: group.baseItem?.metadata.name,
        transcripts: group.transcriptFiles?.map(t => t.metadata.name)
      }))
    });
    return fileGroupsMap;
  }, [items]);

  // Mapping: Basename -> dot-Systemordner (z. B. ".<basename>")
  const systemFolderByBase = useMemo(() => {
    const map = new Map<string, StorageItem>();
    const items = allItemsInFolder ?? [];
    for (const it of items) {
      if (it.type !== 'folder') continue;
      const name = it.metadata.name;
      if (!name.startsWith('.')) continue;
      const base = name.slice(1);
      if (base) map.set(base, it);
    }
    return map;
  }, [allItemsInFolder]);

  // Berechne, ob alle Dateien ausgewählt sind
  const isAllSelected = useMemo(() => {
    if (!fileGroups || !fileGroups.size) return false;
    // Verwende nur die Hauptdateien (baseItem) aus den FileGroups
    const mainItems = Array.from((fileGroups ?? new Map()).values())
      .map(group => group.baseItem)
      .filter((item): item is StorageItem => item !== undefined);
    // Je nach Filter unterschiedliche Dateien zählen
    let selectableItems: StorageItem[] = [];
    switch (currentCategoryFilter) {
      case 'media':
        selectableItems = mainItems.filter(item => {
          try {
            const mediaType = getMediaType(item);
            return item.type === 'file' && (mediaType === 'audio' || mediaType === 'video');
          } catch {
            return false;
          }
        });
        return selectableItems.length > 0 && selectedBatchItems.length === selectableItems.length;
      case 'text':
        selectableItems = mainItems.filter(item => {
          try {
            const mediaType = getMediaType(item);
            return item.type === 'file' && mediaType === 'text';
          } catch {
            return false;
          }
        });
        return selectableItems.length > 0 && selectedTransformationItems.length === selectableItems.length;
      case 'documents':
        selectableItems = mainItems.filter(item => {
          try {
            const mediaType = getMediaType(item);
            return item.type === 'file' && mediaType === 'document';
          } catch {
            return false;
          }
        });
        return selectableItems.length > 0 && selectedTransformationItems.length === selectableItems.length;
      default:
        // Bei 'all' prüfen ob alle verfügbaren Dateien ausgewählt sind
        const mediaItems = mainItems.filter(item => {
          try {
            const mediaType = getMediaType(item);
            return item.type === 'file' && (mediaType === 'audio' || mediaType === 'video');
          } catch {
            return false;
          }
        });
        const textItems = mainItems.filter(item => {
          try {
            const mediaType = getMediaType(item);
            return item.type === 'file' && (mediaType === 'text' || mediaType === 'document');
          } catch {
            return false;
          }
        });
        const allMediaSelected = mediaItems.length === 0 || selectedBatchItems.length === mediaItems.length;
        const allTextSelected = textItems.length === 0 || selectedTransformationItems.length === textItems.length;
        return allMediaSelected && allTextSelected;
    }
  }, [fileGroups, selectedBatchItems, selectedTransformationItems, currentCategoryFilter]);
  
  // Erweiterte handleSelect Funktion für Review-Mode
  const handleSelect = useCallback((item: StorageItem, group?: FileGroup) => {
    FileLogger.debug('FileList', 'handleSelect aufgerufen', {
      itemId: item.id,
      itemName: item.metadata.name,
      groupBase: group?.baseItem?.metadata.name,
      transcriptCount: group?.transcriptFiles?.length ?? 0,
      hasTranscripts: !!(group && group.transcriptFiles && group.transcriptFiles.length > 0)
    });
    
    // Nur die ausgewählte Datei setzen - Review-Modus wird über Toggle-Button gesteuert
    setSelectedFile(item);
    
    // Wenn wir im Review-Modus sind und eine Basis-Datei mit Shadow-Twin ausgewählt wird,
    // dann automatisch das Shadow-Twin setzen
    if (group && group.transcriptFiles && group.transcriptFiles.length > 0) {
      const shadowTwin = group.transcriptFiles[0];
      FileLogger.info('FileList', 'Basis-Datei mit Shadow-Twin ausgewählt', {
        twinId: shadowTwin.id,
        twinName: shadowTwin.metadata.name,
        baseFileId: item.id,
        baseFileName: item.metadata.name
      });
      setSelectedShadowTwin(shadowTwin);
    } else {
      FileLogger.info('FileList', 'Datei ohne Shadow-Twin ausgewählt', {
        itemId: item.id,
        itemName: item.metadata.name,
        groupExists: !!group,
        transcriptCount: group?.transcriptFiles?.length ?? 0
      });
      setSelectedShadowTwin(null);
    }
  }, [setSelectedFile, setSelectedShadowTwin, findFileGroup]);
  
  // Erweiterte handleSelectRelatedFile Funktion für Review-Mode
  const handleSelectRelatedFile = useCallback((shadowTwin: StorageItem) => {
    StateLogger.info('FileList', 'Shadow-Twin ausgewählt', {
      shadowTwinId: shadowTwin.id,
      shadowTwinName: shadowTwin.metadata.name
    });
    
    // Setze das Shadow-Twin als ausgewählte Datei, damit es rechts angezeigt wird
    setSelectedFile(shadowTwin);
    setSelectedShadowTwin(null); // Kein zusätzliches Shadow-Twin im normalen Modus
  }, [setSelectedFile, setSelectedShadowTwin, findFileGroup]);

  // Aktualisierte handleRefresh Funktion
  const handleRefresh = useCallback(async () => {
    if (!items || items.length === 0) return;
    
    const parentId = items[0]?.parentId;
    if (!parentId) return;
    
    setIsRefreshing(true);
    
    try {
      const refreshedItems = await refreshItems(parentId);
      setFolderItems(refreshedItems);
    } catch (error) {
      FileLogger.error('FileList', 'Fehler beim Aktualisieren der Dateiliste', error);
    } finally {
      setIsRefreshing(false);
    }
  }, [items, refreshItems, setFolderItems]);

  const handleCreateTranscript = React.useCallback((e: React.MouseEvent) => {
    e.stopPropagation();
    FileLogger.info('FileList', 'Create transcript for', { fileName: 'TODO' });
    // TODO: Implement transcript creation
  }, []);

  // Entfernt: handleItemSelect war unbenutzt

  // Check if an item is selected (beide Atome prüfen)
  const isItemSelected = useCallback((item: StorageItem) => {
    const mediaType = getMediaType(item);
    if (mediaType === 'audio' || mediaType === 'video') {
      return selectedBatchItems.some(selected => selected.item.id === item.id);
    } else {
      return selectedTransformationItems.some(selected => selected.item.id === item.id);
    }
  }, [selectedBatchItems, selectedTransformationItems]);

  // Löschfunktion
  const handleDeleteClick = React.useCallback(async (e: React.MouseEvent<HTMLButtonElement>, itemToDelete: StorageItem) => {
    e.stopPropagation();
    
    if (!provider) {
      toast.error("Fehler", {
        description: "Storage Provider nicht verfügbar"
      });
      return;
    }

    try {
      // Finde die FileGroup für dieses Item
      const itemStem = getBaseName(itemToDelete.metadata.name);
      const fileGroup = findFileGroup(fileGroups, itemStem);

      // Bestätigungsnachricht vorbereiten
      let confirmMessage = `Möchten Sie "${itemToDelete.metadata.name}" wirklich löschen?`;
      if (fileGroup && itemToDelete.id === fileGroup.baseItem?.id) {
        if (fileGroup.transcriptFiles && fileGroup.transcriptFiles.length > 0 || fileGroup.transformed) {
          confirmMessage = `Möchten Sie "${itemToDelete.metadata.name}" und alle zugehörigen Dateien wirklich löschen?`;
        }
      }

      // Benutzer um Bestätigung bitten
      if (!window.confirm(confirmMessage)) {
        return;
      }

      if (fileGroup && itemToDelete.id === fileGroup.baseItem?.id) {
        // Dies ist die Basis-Datei - lösche auch abhängige Dateien
        // Lösche alle Transkripte, falls vorhanden
        if (fileGroup.transcriptFiles) {
          for (const transcript of fileGroup.transcriptFiles) {
            try {
              await provider.deleteItem(transcript.id);
              FileLogger.info('FileList', 'Transkript gelöscht', {
                transcriptId: transcript.id,
                transcriptName: transcript.metadata.name
              });
            } catch (error) {
              FileLogger.error('FileList', 'Fehler beim Löschen des Transkripts', error);
              toast.warning("Hinweis", {
                description: "Einige Transkripte konnten nicht gelöscht werden"
              });
            }
          }
        }

        // Lösche die transformierte Datei, falls vorhanden
        if (fileGroup.transformed) {
          try {
            await provider.deleteItem(fileGroup.transformed.id);
            FileLogger.info('FileList', 'Transformierte Datei gelöscht', {
              transformedId: fileGroup.transformed.id,
              transformedName: fileGroup.transformed.metadata.name
            });
          } catch (error) {
            FileLogger.error('FileList', 'Fehler beim Löschen der transformierten Datei', error);
            toast.warning("Hinweis", {
              description: "Die transformierte Datei konnte nicht gelöscht werden"
            });
          }
        }

        // Lösche die Basis-Datei
        await provider.deleteItem(itemToDelete.id);
        toast.success("Dateien gelöscht", {
          description: `${itemToDelete.metadata.name} und zugehörige Dateien wurden gelöscht.`
        });
      } else {
        // Dies ist eine abhängige Datei oder keine Gruppe - nur diese Datei löschen
        await provider.deleteItem(itemToDelete.id);
        toast.success("Datei gelöscht", {
          description: `${itemToDelete.metadata.name} wurde gelöscht.`
        });
      }

      // Aktualisiere die Dateiliste
      await handleRefresh();

      // Wenn die gelöschte Datei ausgewählt war, Auswahl aufheben
      setSelectedFile(null);
      
      // Aus der Batch-Auswahl entfernen
      setSelectedBatchItems(prev => prev.filter(i => i.item.id !== itemToDelete.id));

    } catch (error) {
      FileLogger.error('FileList', 'Fehler beim Löschen', error);
      toast.error("Fehler", {
        description: `Die Datei konnte nicht gelöscht werden: ${error instanceof Error ? error.message : 'Unbekannter Fehler'}`
      });
    }
  }, [provider, handleRefresh, fileGroups, setSelectedFile, setSelectedBatchItems]);

  const handleRename = React.useCallback(async (item: StorageItem, newName: string) => {
    if (!provider) {
      toast.error("Fehler", {
        description: "Storage Provider nicht verfügbar"
      });
      return;
    }

    try {
      // Finde die FileGroup für dieses Item
      const itemStem = getBaseName(item.metadata.name);
      const fileGroup = findFileGroup(fileGroups, itemStem);

      if (fileGroup && item.id === fileGroup.baseItem?.id) {
        // Dies ist die Basis-Datei - benenne auch abhängige Dateien um
        const oldStem = getBaseName(item.metadata.name);
        const newStem = getBaseName(newName);
        // Benenne die Basis-Datei um
        await provider.renameItem(item.id, newName);
        // Benenne alle Transkripte um, falls vorhanden
        if (fileGroup.transcriptFiles) {
          for (const transcript of fileGroup.transcriptFiles) {
            const transcriptName = transcript.metadata.name;
            const newTranscriptName = transcriptName.replace(oldStem, newStem);
            try {
              await provider.renameItem(transcript.id, newTranscriptName);
            } catch (error) {
              FileLogger.error('FileList', 'Fehler beim Umbenennen des Transkripts', error);
              toast.warning("Hinweis", {
                description: "Einige Transkripte konnten nicht umbenannt werden"
              });
            }
          }
        }
        // Benenne die transformierte Datei um, falls vorhanden
        if (fileGroup.transformed) {
          const transformedName = fileGroup.transformed.metadata.name;
          const newTransformedName = transformedName.replace(oldStem, newStem);
          try {
            await provider.renameItem(fileGroup.transformed.id, newTransformedName);
          } catch (error) {
            FileLogger.error('FileList', 'Fehler beim Umbenennen der transformierten Datei', error);
            toast.warning("Hinweis", {
              description: "Die transformierte Datei konnte nicht umbenannt werden"
            });
          }
        }
        toast.success("Dateien umbenannt", {
          description: `${item.metadata.name} und zugehörige Dateien wurden umbenannt.`
        });
      } else {
        // Dies ist eine abhängige Datei oder keine Gruppe - nur diese Datei umbenennen
        await provider.renameItem(item.id, newName);
        toast.success("Datei umbenannt", {
          description: `${item.metadata.name} wurde zu ${newName} umbenannt.`
        });
      }
      await handleRefresh();
    } catch (error) {
      FileLogger.error('FileList', 'Fehler beim Umbenennen', error);
      toast.error("Fehler", {
        description: `Die Datei konnte nicht umbenannt werden: ${error instanceof Error ? error.message : 'Unbekannter Fehler'}`
      });
      throw error;
    }
  }, [provider, handleRefresh, fileGroups]);

  const handleBatchTranscription = () => {
    if (selectedBatchItems.length > 0) {
      setTranscriptionDialogOpen(true);
    }
  };

  const handleBatchTransformation = () => {
    if (selectedTransformationItems.length > 0) {
      setTransformationDialogOpen(true);
    }
  };

  // Bulk-Löschung für ausgewählte Dateien (unabhängig von Batch/Transformation-Selektor)
  const handleBulkDelete = React.useCallback(async () => {
    if (!provider) return;
    const targets = [
      ...selectedBatchItems.map(x => x.item),
      ...selectedTransformationItems.map(x => x.item),
    ];
    if (targets.length === 0) return;
    const confirmMsg = targets.length === 1
      ? `"${targets[0].metadata.name}" wirklich löschen?`
      : `${targets.length} Dateien wirklich löschen?`;
    if (!window.confirm(confirmMsg)) return;

    try {
      const parentId = targets[0].parentId || 'root';
      for (const t of targets) {
        try { await provider.deleteItem(t.id); } catch (err) {
          FileLogger.error('FileList', 'Bulk Delete failed', { id: t.id, name: t.metadata.name, err });
        }
      }
      const refreshed = await refreshItems(parentId);
      setFolderItems(refreshed);
      setSelectedBatchItems([]);
      setSelectedTransformationItems([]);
    } catch (error) {
      FileLogger.error('FileList', 'Bulk Delete error', error);
    }
  }, [provider, selectedBatchItems, selectedTransformationItems, refreshItems, setFolderItems, setSelectedBatchItems, setSelectedTransformationItems]);

  // Intelligente Batch-Auswahl basierend auf Filter
  const handleSelectAll = useCallback((checked: boolean) => {
    const startTime = performance.now();
    if (checked) {
      // Verwende nur die Hauptdateien (baseItem) aus den FileGroups
      const mainItems = Array.from((fileGroups ?? new Map()).values())
        .map(group => group.baseItem)
        .filter((item): item is StorageItem => item !== undefined);
      const selectableItems = mainItems.filter(item => {
        try {
          const mediaType = getMediaType(item);
          // Je nach Filter unterschiedliche Dateien auswählen
          switch (currentCategoryFilter) {
            case 'media':
              return item.type === 'file' && (mediaType === 'audio' || mediaType === 'video');
            case 'text':
              return item.type === 'file' && mediaType === 'text';
            case 'documents':
              return item.type === 'file' && mediaType === 'document';
            default:
              // Bei 'all' alle Dateien auswählen, die für eine Operation geeignet sind
              return item.type === 'file' && (
                mediaType === 'audio' || 
                mediaType === 'video' || 
                mediaType === 'text' || 
                mediaType === 'document'
              );
          }
        } catch {
          return false;
        }
      });
      StateLogger.info('FileList', 'Selecting all items based on filter', {
        filter: currentCategoryFilter,
        totalItems: items.length,
        selectableCount: selectableItems.length,
        duration: `${(performance.now() - startTime).toFixed(2)}ms`
      });
      // Je nach Filter unterschiedliche Atome verwenden
      if (currentCategoryFilter === 'media') {
        setSelectedBatchItems(selectableItems.map(item => ({
          item,
          type: getMediaType(item)
        })));
      } else if (currentCategoryFilter === 'text') {
        setSelectedTransformationItems(selectableItems.map(item => ({
          item,
          type: getMediaType(item)
        })));
      } else {
        // Bei 'all' oder 'documents' beide Atome füllen
        const mediaItems = selectableItems.filter(item => {
          const mediaType = getMediaType(item);
          return mediaType === 'audio' || mediaType === 'video';
        });
        const textItems = selectableItems.filter(item => {
          const mediaType = getMediaType(item);
          return mediaType === 'text' || mediaType === 'document';
        });
        setSelectedBatchItems(mediaItems.map(item => ({
          item,
          type: getMediaType(item)
        })));
        setSelectedTransformationItems(textItems.map(item => ({
          item,
          type: getMediaType(item)
        })));
      }
    } else {
      StateLogger.info('FileList', 'Deselecting all items', {
        previouslySelected: selectedBatchItems.length + selectedTransformationItems.length,
        duration: `${(performance.now() - startTime).toFixed(2)}ms`
      });
      setSelectedBatchItems([]);
      setSelectedTransformationItems([]);
    }
  }, [fileGroups, currentCategoryFilter, setSelectedBatchItems, setSelectedTransformationItems, selectedBatchItems.length, selectedTransformationItems.length, items.length]);

  React.useEffect(() => {
    // Logging der Library-IDs - verzögert ausführen
    const timeoutId = setTimeout(() => {
      StateLogger.debug('FileList', 'Render', {
        currentLibraryId: currentLibrary?.id,
        activeLibraryIdAtom: activeLibraryId
      });
    }, 0);
    
    return () => clearTimeout(timeoutId);
  }, [currentLibrary, activeLibraryId]);

  // Entkoppelt: kein Render-Gate mehr basierend auf FileTree

  return (
    <div className="h-full flex flex-col">
      {/* Header - versteckt im compact mode */}
      {!compact && (
        <div className="border-b px-2 py-2 flex items-center justify-between bg-background sticky top-0 z-10">
          <div className="flex items-center gap-2">
            <Button
              variant="ghost"
              size="icon"
              className="h-8 w-8"
              onClick={handleRefresh}
              disabled={isRefreshing}
              title="Aktualisieren"
              aria-label="Aktualisieren"
            >
              <RefreshCw className={cn("h-4 w-4", isRefreshing && "animate-spin")} />
            </Button>

            {/* Dateikategorie-Filter (Icon-only Variante) */}
            <FileCategoryFilter iconOnly />

            {/* Batch-Actions als Icons */}
            {selectedBatchItems.length > 0 && (
              <Button size="icon" title="Transkribieren" aria-label="Transkribieren" onClick={handleBatchTranscription}>
                <ScrollText className="h-4 w-4" />
              </Button>
            )}
            {selectedTransformationItems.length > 0 && (
              <Button size="icon" variant="secondary" title="Transformieren" aria-label="Transformieren" onClick={handleBatchTransformation}>
                <Plus className="h-4 w-4" />
              </Button>
            )}
            {(selectedBatchItems.length + selectedTransformationItems.length) > 0 && (
              <Button size="icon" variant="destructive" title="Ausgewählte löschen" aria-label="Ausgewählte löschen" onClick={handleBulkDelete}>
                <Trash2 className="h-4 w-4" />
              </Button>
            )}
          </div>
        </div>
      )}

      {/* File List */}
      <div className="flex-1 overflow-auto">
        <div>
          {/* Table Header - versteckt im compact mode */}
          {!compact && (
            <div className="sticky top-0 bg-background border-b">
              <div className="grid grid-cols-[24px_24px_minmax(0,1fr)_56px_88px_auto] gap-2 px-4 py-2 text-sm font-medium text-muted-foreground">
                <div className="w-6 flex items-center justify-center">
                  <Checkbox
                    checked={isAllSelected}
                    onCheckedChange={handleSelectAll}
                    aria-label="Alle auswählen"
                  />
                </div>
                <div className="w-6" />
                <SortableHeaderCell
                  label="Name"
                  field="name"
                  currentSortField={sortField}
                  currentSortOrder={sortOrder}
                  onSort={handleSort}
                />
                <SortableHeaderCell
                  label="Größe"
                  field="size"
                  currentSortField={sortField}
                  currentSortOrder={sortOrder}
                  onSort={handleSort}
                />
                <SortableHeaderCell
                  label="Geändert"
                  field="date"
                  currentSortField={sortField}
                  currentSortOrder={sortOrder}
                  onSort={handleSort}
                />
                <div />
              </div>
            </div>
          )}

          {/* Folder Rows (oberhalb der Dateien, unabhängig von Datei-Gruppierung) */}
          {folders.length > 0 && (
            <div className="divide-y">
          {folders.map((folder) => (
            compact ? (
              // Kompakt: ohne Einrückung, nur Icon + Name (2 Spalten)
              <div
                key={folder.id}
                role="button"
                tabIndex={0}
                onClick={() => navigateToFolder(folder.id)}
                onKeyDown={(e) => { if (e.key === 'Enter' || e.key === ' ') navigateToFolder(folder.id) }}
                className="w-full px-2 py-1 text-xs hover:bg-muted/50 grid grid-cols-[24px_minmax(0,1fr)] gap-2 items-center cursor-pointer"
              >
                <FolderIcon className="h-4 w-4" />
                <span className="text-left truncate select-none" title={folder.metadata.name}>{folder.metadata.name}</span>
              </div>
            ) : (
              // Normal: behalte leichte Einrückung für Checkbox-Spalte
              <div
                key={folder.id}
                role="button"
                tabIndex={0}
                onClick={() => navigateToFolder(folder.id)}
                onKeyDown={(e) => { if (e.key === 'Enter' || e.key === ' ') navigateToFolder(folder.id) }}
                className="w-full px-4 py-2 text-xs hover:bg-muted/50 grid grid-cols-[24px_24px_minmax(0,1fr)] gap-2 items-center cursor-pointer"
              >
                <div />
                <FolderIcon className="h-4 w-4" />
                <span className="text-left truncate select-none" title={folder.metadata.name}>{folder.metadata.name}</span>
              </div>
            )
          ))}
            </div>
          )}

          {/* File Rows */}
          <div className="divide-y">
            {Array.from((fileGroups ?? new Map()).values())
              .map((group) => {
                // Zeige nur die Hauptdatei (baseItem) an
                const item = group.baseItem;
                if (!item) return null;
                // System-Unterordner-Id, wenn ein ".<basename>"-Folder existiert
                const systemFolder = systemFolderByBase.get(getBaseName(item.metadata.name));
                const systemFolderId = systemFolder?.id;
                const isActive = !!activeFile && activeFile.id === item.id
                return (
                  <FileRow
                    key={item.id}
                    item={item as StorageItem}
                    isSelected={isItemSelected(item)}
                    isActive={isActive}
                    onSelect={() => handleSelect(item, group)}
                    onCreateTranscript={handleCreateTranscript}
                    onDelete={(e) => handleDeleteClick(e, item)}
                    fileGroup={group}
                    onSelectRelatedFile={handleSelectRelatedFile}
                    onRename={handleRename}
                    compact={compact}
                    systemFolderId={systemFolderId}
                  />
                );
              })}
          </div>
        </div>
      </div>
    </div>
  );
}); 
```

Ich habe die Kompaktansicht vereinheitlicht:

- Dateien in Kompaktansicht nutzen jetzt denselben Font/Größe wie Ordner (`text-xs`) und dieselbe linksbündige Einrückung via Grid `grid-cols-[24px_minmax(0,1fr)]`.
- Damit sind Icon und Name bei Dateien und Verzeichnissen identisch ausgerichtet.
- Zusätzliche Compact‑Icons (Transkript etc.) habe ich im Kompaktmodus entfernt, um das Layout konsistent zu halten. Tooltip mit vollem Namen bleibt.

---

**User**

Ok, gehen wir dann wieder zurück auf diesen Preview-Bereich. Wenn ich da oben wechsle zwischen Extraktion, Metadaten, Ingestion, passiert eigentlich nichts. In der Ansicht. Ich sehe auch keinen Unterschied, es wird die Prozess-Info nicht angezeigt. Können wir es so machen, dass wenn ich auf Extraktion gehe, dass ich dann in dem rechten Pane die Ansicht Markdown aktiviere. Wenn ich auf Metadaten gehe, die Ansicht Metadaten. Sodass ich da wenigstens diese Kopplung habe.

---

**Cursor**

```typescriptreact
<<'PATCH'
*** Begin Patch
*** Update File: src/components/library/job-report-tab.tsx
@@
-interface JobReportTabProps {
+interface JobReportTabProps {
   libraryId: string
   fileId: string
   fileName?: string
   provider?: StorageProvider | null
@@
   viewMode?: 'full' | 'metaOnly'
   // Optional explizite Markdown-Datei-ID (Shadow‑Twin). Überschreibt auto-Erkennung.
   mdFileId?: string | null
   // Optionaler Callback zum Scroll-Sync in die Markdown-Vorschau
   onJumpTo?: (args: { page?: number | string; evidence?: string }) => void
   // NEU: Rohinhalt (Markdown). Wenn gesetzt und sourceMode='frontmatter', wird direkt dieser Text geparst (ohne Datei/JOB).
   rawContent?: string
+  // Extern erzwungener Tab (nur für metaOnly-View relevant)
+  forcedTab?: 'markdown' | 'meta' | 'chapters' | 'process'
 }
@@
-export function JobReportTab({ libraryId, fileId, fileName, provider, sourceMode = 'merged', viewMode = 'full', mdFileId, onJumpTo, rawContent }: JobReportTabProps) {
+export function JobReportTab({ libraryId, fileId, fileName, provider, sourceMode = 'merged', viewMode = 'full', mdFileId, onJumpTo, rawContent, forcedTab }: JobReportTabProps) {
@@
   const [parseErrors, setParseErrors] = useState<string[]>([])
   const [fullContent, setFullContent] = useState<string>('')
+  const [localTab, setLocalTab] = useState<'markdown' | 'meta' | 'chapters' | 'process'>('markdown')
@@
-        <Tabs defaultValue="markdown">
+        {(() => {
+          const base: Record<string, unknown> = sourceMode === 'frontmatter' ? {} : ((job?.cumulativeMeta as unknown as Record<string, unknown>) || {})
+          const cm = frontmatterMeta ? { ...base, ...frontmatterMeta } : base
+          const processFields = new Set([
+            'job_id','extract_status','template_status','ingest_status','summary_language',
+            'source_file','source_file_id','source_file_size','source_file_type',
+            'filename','path','pathHints','isScan'
+          ])
+          const hasProcess = Object.keys(cm).some(k => processFields.has(k))
+          const effectiveTab: 'markdown'|'meta'|'chapters'|'process' = forcedTab ? (forcedTab === 'process' && !hasProcess ? 'meta' : forcedTab) : localTab
+          return (
+            <Tabs value={effectiveTab} onValueChange={(v) => setLocalTab(v as typeof localTab)}>
+              <TabsList className="grid grid-cols-3 w-full">
+                <TabsTrigger value="markdown">Markdown</TabsTrigger>
+                <TabsTrigger value="meta">Metadaten</TabsTrigger>
+                <TabsTrigger value="chapters">Kapitel</TabsTrigger>
+                {hasProcess ? <TabsTrigger value="process">Prozessinfo</TabsTrigger> : null}
+              </TabsList>
+
+              <TabsContent value="markdown" className="mt-3">
+                <div className="border rounded-md">
+                  <MarkdownPreview content={stripFrontmatter(fullContent || '')} />
+                </div>
+              </TabsContent>
+
+              <TabsContent value="meta" className="mt-3">
+                {/* Hinweise zu Parserfehlern (strikt) */}
+                {parseErrors.length > 0 && (
+                  <div className="text-xs text-destructive mb-2">
+                    {parseErrors.map((e, i) => (<div key={i}>Parserfehler: {e}</div>))}
+                  </div>
+                )}
+                {(() => {
+                  const base: Record<string, unknown> = sourceMode === 'frontmatter'
+                    ? {}
+                    : ((job?.cumulativeMeta as unknown as Record<string, unknown>) || {})
+                  const cm = frontmatterMeta ? { ...base, ...frontmatterMeta } : base
+                  const baseKeys = Array.isArray(templateFields) && templateFields.length > 0
+                    ? Array.from(new Set([...(templateFields as string[]), ...Object.keys(cm)]))
+                    : Object.keys(cm)
+                  const flatKeys = baseKeys.filter(k => k !== 'chapters' && k !== 'toc' && k !== 'confidence' && k !== 'provenance')
+                  if (flatKeys.length === 0) return null
+                  return (
+                    <div>
+                      <div className="font-medium mb-1">Metadaten (Template vs. Ergebnis)</div>
+                      <div className="overflow-auto">
+                        <table className="w-full text-xs">
+                          <thead>
+                            <tr className="text-left text-muted-foreground">
+                              <th className="py-1 pr-2">Feld</th>
+                              <th className="py-1 pr-2">Wert</th>
+                              <th className="py-1 pr-2 w-20 text-right sticky right-0 bg-background border-l">Q</th>
+                            </tr>
+                          </thead>
+                          <tbody>
+                            {flatKeys.map((k) => {
+                              const val = cm[k]
+                              let valueStr = ''
+                              if (Array.isArray(val)) valueStr = (val as Array<unknown>).map(v => typeof v === 'string' ? v : JSON.stringify(v)).join(', ')
+                              else valueStr = val === null || val === undefined ? '' : typeof val === 'string' ? val : JSON.stringify(val)
+                              const cRaw = (confidence as Record<string, unknown>)[k]
+                              const cNum = typeof cRaw === 'number' ? cRaw : (typeof cRaw === 'string' && /^\d+(\.\d+)?$/.test(cRaw) ? Number(cRaw) : undefined)
+                              const pRaw = (provenance as Record<string, unknown>)[k]
+                              const pStr = typeof pRaw === 'string' ? pRaw : pRaw ? JSON.stringify(pRaw) : ''
+                              const color = cNum === undefined ? 'text-muted-foreground' : (cNum >= 0.8 ? 'text-green-600' : cNum >= 0.7 ? 'text-yellow-600' : 'text-red-600')
+                              return (
+                                <tr key={k} className="border-t border-muted/40">
+                                  <td className="py-1 pr-2 align-top font-medium sticky left-0 bg-background z-10 whitespace-nowrap">{k}</td>
+                                  <td className="py-1 pr-2 align-top">
+                                    {valueStr ? (
+                                      <TooltipProvider>
+                                        <Tooltip>
+                                          <TooltipTrigger asChild>
+                                            <span className="inline-block max-w-[40vw] overflow-hidden text-ellipsis whitespace-nowrap align-top" title="">
+                                              {valueStr}
+                                            </span>
+                                          </TooltipTrigger>
+                                          <TooltipContent>
+                                            <div className="max-w-[80vw] whitespace-pre-wrap break-words">{valueStr}</div>
+                                          </TooltipContent>
+                                        </Tooltip>
+                                      </TooltipProvider>
+                                    ) : ''}
+                                  </td>
+                                  <td className="py-1 pr-2 align-top sticky right-0 bg-background border-l">
+                                    {(() => {
+                                      if (!hasAnyConfidence) return null
+                                      if (cNum === undefined) return null
+                                      return (
+                                        <TooltipProvider>
+                                          <Tooltip>
+                                            <TooltipTrigger asChild>
+                                              <span className={`inline-flex items-center justify-end w-full ${color}`} title={pStr || ''}>
+                                                <span className="inline-block h-2 w-2 rounded-full bg-current" />
+                                              </span>
+                                            </TooltipTrigger>
+                                            <TooltipContent>
+                                              <div className="max-w-xs whitespace-pre-wrap break-words">
+                                                <div className="font-medium">Confidence: {cNum.toFixed(2)}</div>
+                                                {pStr ? <div className="mt-1 text-muted-foreground">Provenance: {pStr}</div> : null}
+                                              </div>
+                                            </TooltipContent>
+                                          </Tooltip>
+                                        </TooltipProvider>
+                                      )
+                                    })()}
+                                  </td>
+                                </tr>
+                              )
+                            })}
+                          </tbody>
+                        </table>
+                      </div>
+                    </div>
+                  )
+                })()}
+              </TabsContent>
+
+              <TabsContent value="chapters" className="mt-3">
+                {(() => {
+                  const chapters: Array<Record<string, unknown>> = sourceMode === 'frontmatter'
+                    ? (Array.isArray(frontmatterMeta?.chapters) ? (frontmatterMeta?.chapters as Array<Record<string, unknown>>) : [])
+                    : ((job?.cumulativeMeta as unknown as { chapters?: Array<Record<string, unknown>> })?.chapters || [])
+                  if (!Array.isArray(chapters) || chapters.length === 0) return null
+                  const pad = (lvl: number | undefined): number => {
+                    if (typeof lvl !== 'number') return 0
+                    const clamped = Math.max(0, Math.min(3, lvl))
+                    return (clamped - 1) * 16
+                  }
+                  const counters = [0, 0, 0]
+                  return (
+                    <div className="space-y-1">
+                      <div>
+                        {chapters.map((c, i) => {
+                          const level = typeof c.level === 'number' ? c.level : 1
+                          const lvl = Math.max(1, Math.min(3, level))
+                          counters[lvl - 1] += 1
+                          for (let j = lvl; j < counters.length; j++) counters[j] = 0
+                          const numLabel = counters.slice(0, lvl).filter(n => n > 0).join('.')
+                          const title = typeof c.title === 'string' ? c.title : ''
+                          const startPage = typeof c.startPage === 'number' ? c.startPage : ''
+                          const summaryVal = typeof c.summary === 'string' ? c.summary : ''
+                          const summary = summaryVal.length > 1000 ? `${summaryVal.slice(0, 1000)}…` : summaryVal
+                          const keywords = Array.isArray(c.keywords) ? (c.keywords as Array<unknown>).filter(v => typeof v === 'string') as string[] : []
+                          const ev = typeof c.startEvidence === 'string' ? c.startEvidence : ''
+                          return (
+                            <details key={`${title}-${i}`} className="group border-b py-1" open={false} onToggle={(e) => {
+                              const open = (e.currentTarget as HTMLDetailsElement).open
+                              if (open) {
+                                if (startPage !== '') onJumpTo?.({ page: startPage as number | string })
+                                else if (ev) onJumpTo?.({ evidence: ev })
+                              }
+                            }}>
+                              <summary className="list-none cursor-pointer">
+                                <div className="flex items-start justify-between gap-3">
+                                  <div className="flex-1 min-w-0" style={{ paddingLeft: `${pad(lvl)}px` }}>
+                                    <div className="flex items-baseline gap-2">
+                                      <span className="text-xs text-muted-foreground tabular-nums">{numLabel}</span>
+                                      <span className="font-medium truncate">{title}</span>
+                                    </div>
+                                  </div>
+                                  <div className="text-xs tabular-nums text-muted-foreground whitespace-nowrap">
+                                    {String(startPage)}
+                                  </div>
+                                </div>
+                              </summary>
+                              <div className="mt-1 pr-1 text-xs space-y-1" style={{ paddingLeft: `${pad(lvl) + 28}px` }}>
+                                {summary && (
+                                  <div className="whitespace-pre-wrap break-words">
+                                    {summary}
+                                  </div>
+                                )}
+                                {Array.isArray(keywords) && keywords.length > 0 && (
+                                  <div className="flex flex-wrap gap-1">
+                                    {keywords.map(k => (
+                                      <span key={k} className="inline-flex items-center rounded px-1.5 py-0.5 bg-muted">{k}</span>
+                                    ))}
+                                  </div>
+                                )}
+                              </div>
+                            </details>
+                          )
+                        })}
+                      </div>
+                    </div>
+                  )
+                })()}
+              </TabsContent>
+
+              <TabsContent value="process" className="mt-3">
+                {(() => {
+                  const base: Record<string, unknown> = sourceMode === 'frontmatter'
+                    ? {}
+                    : ((job?.cumulativeMeta as unknown as Record<string, unknown>) || {})
+                  const cm = frontmatterMeta ? { ...base, ...frontmatterMeta } : base
+                  const processOrder = [
+                    'job_id','extract_status','template_status','ingest_status','summary_language',
+                    'source_file','source_file_id','source_file_size','source_file_type',
+                    'filename','path','pathHints','isScan'
+                  ]
+                  const keys = processOrder.filter(k => k in cm)
+                  if (keys.length === 0) return <div className="text-xs text-muted-foreground">Keine Prozessinformationen vorhanden.</div>
+                  return (
+                    <div className="overflow-auto">
+                      <table className="w-full text-xs">
+                        <thead>
+                          <tr className="text-left text-muted-foreground">
+                            <th className="py-1 pr-2 sticky left-0 bg-background z-10">Feld</th>
+                            <th className="py-1 pr-2">Wert</th>
+                          </tr>
+                        </thead>
+                        <tbody>
+                          {keys.map(k => {
+                            const val = cm[k]
+                            const valueStr = val === null || val === undefined ? '' : Array.isArray(val) ? (val as Array<unknown>).map(v => typeof v === 'string' ? v : JSON.stringify(v)).join(', ') : typeof val === 'string' ? val : JSON.stringify(val)
+                            return (
+                              <tr key={k} className="border-t border-muted/40">
+                                <td className="py-1 pr-2 align-top font-medium sticky left-0 bg-background z-10 whitespace-nowrap">{k}</td>
+                                <td className="py-1 pr-2 align-top">
+                                  {valueStr ? (
+                                    <TooltipProvider>
+                                      <Tooltip>
+                                        <TooltipTrigger asChild>
+                                          <span className="inline-block max-w-[40vw] overflow-hidden text-ellipsis whitespace-nowrap align-top" title="">{valueStr}</span>
+                                        </TooltipTrigger>
+                                        <TooltipContent>
+                                          <div className="max-w-[80vw] whitespace-pre-wrap break-words">{valueStr}</div>
+                                        </TooltipContent>
+                                      </Tooltip>
+                                    </TooltipProvider>
+                                  ) : ''}
+                                </td>
+                              </tr>
+                            )
+                          })}
+                        </tbody>
+                      </table>
+                    </div>
+                  )
+                })()}
+              </TabsContent>
+            </Tabs>
+          )
+        })()}
-          <TabsList className="grid grid-cols-3 w-full">
-            <TabsTrigger value="markdown">Markdown</TabsTrigger>
-            <TabsTrigger value="meta">Metadaten</TabsTrigger>
-            <TabsTrigger value="chapters">Kapitel</TabsTrigger>
-          </TabsList>
-
-          <TabsContent value="markdown" className="mt-3">
-            <div className="border rounded-md">
-              <MarkdownPreview content={stripFrontmatter(fullContent || '')} />
-            </div>
-          </TabsContent>
-
-          <TabsContent value="meta" className="mt-3">
-            {/* Hinweise zu Parserfehlern (strikt) */}
-            {parseErrors.length > 0 && (
-              <div className="text-xs text-destructive mb-2">
-                {parseErrors.map((e, i) => (<div key={i}>Parserfehler: {e}</div>))}
-              </div>
-            )}
-            {
-            
-          </TabsContent>
-
-          <TabsContent value="chapters" className="mt-3">
-            {(() => {
-              const chapters: Array<Record<string, unknown>> = sourceMode === 'frontmatter'
-                ? (Array.isArray(frontmatterMeta?.chapters) ? (frontmatterMeta?.chapters as Array<Record<string, unknown>>) : [])
-                : ((job?.cumulativeMeta as unknown as { chapters?: Array<Record<string, unknown>> })?.chapters || [])
-              if (!Array.isArray(chapters) || chapters.length === 0) return null
-              const pad = (lvl: number | undefined): number => {
-                if (typeof lvl !== 'number') return 0
-                const clamped = Math.max(0, Math.min(3, lvl))
-                return (clamped - 1) * 16
-              }
-              const counters = [0, 0, 0]
-              return (
-                <div className="space-y-1">
-                  <div>
-                    {chapters.map((c, i) => {
-                      const level = typeof c.level === 'number' ? c.level : 1
-                      const lvl = Math.max(1, Math.min(3, level))
-                      counters[lvl - 1] += 1
-                      for (let j = lvl; j < counters.length; j++) counters[j] = 0
-                      const numLabel = counters.slice(0, lvl).filter(n => n > 0).join('.')
-                      const title = typeof c.title === 'string' ? c.title : ''
-                      const startPage = typeof c.startPage === 'number' ? c.startPage : ''
-                      const summaryVal = typeof c.summary === 'string' ? c.summary : ''
-                      const summary = summaryVal.length > 1000 ? `${summaryVal.slice(0, 1000)}…` : summaryVal
-                      const keywords = Array.isArray(c.keywords) ? (c.keywords as Array<unknown>).filter(v => typeof v === 'string') as string[] : []
-                      const ev = typeof c.startEvidence === 'string' ? c.startEvidence : ''
-                      return (
-                        <details key={`${title}-${i}`} className="group border-b py-1" open={false} onToggle={(e) => {
-                          const open = (e.currentTarget as HTMLDetailsElement).open
-                          if (open) {
-                            if (startPage !== '') onJumpTo?.({ page: startPage as number | string })
-                            else if (ev) onJumpTo?.({ evidence: ev })
-                          }
-                        }}>
-                          <summary className="list-none cursor-pointer">
-                            <div className="flex items-start justify-between gap-3">
-                              <div className="flex-1 min-w-0" style={{ paddingLeft: `${pad(lvl)}px` }}>
-                                <div className="flex items-baseline gap-2">
-                                  <span className="text-xs text-muted-foreground tabular-nums">{numLabel}</span>
-                                  <span className="font-medium truncate">{title}</span>
-                                </div>
-                              </div>
-                              <div className="text-xs tabular-nums text-muted-foreground whitespace-nowrap">
-                                {String(startPage)}
-                              </div>
-                            </div>
-                          </summary>
-                          <div className="mt-1 pr-1 text-xs space-y-1" style={{ paddingLeft: `${pad(lvl) + 28}px` }}>
-                            {summary && (
-                              <div className="whitespace-pre-wrap break-words">
-                                {summary}
-                              </div>
-                            )}
-                            {Array.isArray(keywords) && keywords.length > 0 && (
-                              <div className="flex flex-wrap gap-1">
-                                {keywords.map(k => (
-                                  <span key={k} className="inline-flex items-center rounded px-1.5 py-0.5 bg-muted">{k}</span>
-                                ))}
-                              </div>
-                            )}
-                          </div>
-                        </details>
-                      )
-                    })}
-                  </div>
-                </div>
-              )
-            })()}
-          </TabsContent>
-        </Tabs>
-      )}
+        )}
*** End Patch
```

```typescriptreact
"use client";

import * as React from "react";
import { useAtom, useAtomValue } from "jotai";
import { activePdfPhaseAtom } from "@/atoms/pdf-phases";
import type { StorageItem, StorageProvider } from "@/lib/storage/types";
import { DocumentPreview } from "./document-preview";
import { MarkdownPreview } from "./markdown-preview";
import { JobReportTab } from "./job-report-tab";
import { PhaseStepper } from "./phase-stepper";
import { activeLibraryIdAtom, selectedShadowTwinAtom } from "@/atoms/library-atom";
import { FileLogger } from "@/lib/debug/logger";
import { PdfCanvasViewer } from "./pdf-canvas-viewer";
import { useStorage } from "@/contexts/storage-context";
import { currentPdfPageAtom } from "@/atoms/pdf-viewer";
// Button und direkte Template-Analyse wurden entfernt – Steuerung erfolgt ausschließlich über PhaseStepper

interface PdfPhasesViewProps {
  item: StorageItem;
  provider: StorageProvider | null;
  markdownContent?: string;
}

export function PdfPhasesView({ item, provider, markdownContent }: PdfPhasesViewProps) {
  const [phase] = useAtom(activePdfPhaseAtom);
  const activeLibraryId = useAtomValue(activeLibraryIdAtom);
  const shadowTwin = useAtomValue(selectedShadowTwinAtom);
  const [twinContent, setTwinContent] = React.useState<string>(markdownContent || "");
  const [twinLoading, setTwinLoading] = React.useState<boolean>(false);
  const [twinError, setTwinError] = React.useState<string | null>(null);
  const { provider: storageProvider } = useStorage();
  const [currentPage, setCurrentPage] = useAtom(currentPdfPageAtom);
  const [isPdfCollapsed, setIsPdfCollapsed] = React.useState(false);
  const leftRef = React.useRef<HTMLDivElement | null>(null);
  const rightRef = React.useRef<HTMLDivElement | null>(null);
  const syncingFromPdfRef = React.useRef(false);
  const syncingFromMarkdownRef = React.useRef(false);

  // Globaler Page→Scroll Sync: scrolle beide Paneele zur aktuellen Seite (falls Marker vorhanden)
  React.useEffect(() => {
    const scrollToMarker = (root: HTMLElement | null, selector: string) => {
      if (!root) return;
      const el = root.querySelector(selector) as HTMLElement | null;
      if (!el) return;
      root.scrollTo({ top: el.offsetTop - 16, behavior: 'smooth' });
    };
    // Links: PDF nutzt [data-page]
    scrollToMarker(leftRef.current, `[data-page="${currentPage}"]`);
    // Rechts: Markdown nutzt [data-page-marker]
    scrollToMarker(rightRef.current, `[data-page-marker="${currentPage}"]`);
  }, [currentPage]);

  const [pdfUrl, setPdfUrl] = React.useState<string | null>(null);
  const markdownApiRef = React.useRef<{ scrollToText: (q: string) => void; scrollToPage: (n: number | string) => void; setQueryAndSearch: (q: string) => void; getVisiblePage?: () => number | null } | null>(null);

  // Shadow‑Twin laden
  React.useEffect(() => {
    let cancelled = false;
    async function loadTwin() {
      try {
        setTwinLoading(true);
        setTwinError(null);
        if (!provider || !shadowTwin?.id) {
          setTwinContent("");
          return;
        }
        FileLogger.info('PdfPhasesView', 'Lade Shadow‑Twin Inhalt', { twinId: shadowTwin.id, name: shadowTwin.metadata?.name });
        const { blob } = await provider.getBinary(shadowTwin.id);
        const text = await blob.text();
        if (!cancelled) setTwinContent(text);
      } catch (err) {
        const message = err instanceof Error ? err.message : 'Unbekannter Fehler';
        FileLogger.error('PdfPhasesView', 'Fehler beim Laden des Shadow‑Twin', { error: message });
        if (!cancelled) setTwinError(message);
      } finally {
        if (!cancelled) setTwinLoading(false);
      }
    }
    void loadTwin();
    return () => { cancelled = true; };
  }, [provider, shadowTwin?.id]);

  // PDF-Streaming URL laden
  React.useEffect(() => {
    let cancelled = false;
    async function loadUrl() {
      try {
        if (!storageProvider || !item?.id) return;
        const url = await storageProvider.getStreamingUrl(item.id);
        if (!cancelled) setPdfUrl(url);
      } catch (err) {
        FileLogger.error('PdfPhasesView', 'PDF URL Fehler', err);
      }
    }
    void loadUrl();
    return () => { cancelled = true; };
  }, [storageProvider, item?.id]);

  // Scroll Sync von rechts (Markdown) → links (PDF)
  React.useEffect(() => {
    const container = rightRef.current;
    const targetPane = leftRef.current;
    if (!container || !targetPane) return;
    const markers = Array.from(container.querySelectorAll('[data-page-marker]')) as HTMLElement[];
    if (markers.length === 0) return;
    const observer = new IntersectionObserver((entries) => {
      if (syncingFromPdfRef.current) return;
      let best: { page: number; ratio: number } | null = null;
      for (const e of entries) {
        const attr = (e.target as HTMLElement).getAttribute('data-page-marker');
        const page = attr ? Number(attr) : NaN;
        if (!Number.isFinite(page)) continue;
        const ratio = e.intersectionRatio;
        if (!best || ratio > best.ratio) best = { page, ratio };
      }
      if (!best || best.ratio < 0.25) return;
      syncingFromMarkdownRef.current = true;
      const el = targetPane.querySelector(`[data-page="${best.page}"]`) as HTMLElement | null;
      if (el) targetPane.scrollTo({ top: el.offsetTop - 16, behavior: 'smooth' });
      if (best.page !== currentPage) setCurrentPage(best.page);
      window.setTimeout(() => { syncingFromMarkdownRef.current = false; }, 250);
    }, { root: container, threshold: [0, 0.25, 0.5, 0.75, 1] });
    markers.forEach(m => observer.observe(m));
    return () => observer.disconnect();
  }, [twinContent]);

  // Scroll Sync von links (PDF) → rechts (Markdown)
  React.useEffect(() => {
    const container = leftRef.current;
    const targetPane = rightRef.current;
    if (!container || !targetPane) return;
    const markers = Array.from(container.querySelectorAll('[data-page]')) as HTMLElement[];
    if (markers.length === 0) return;
    const observer = new IntersectionObserver((entries) => {
      if (syncingFromMarkdownRef.current) return;
      let best: { page: number; ratio: number } | null = null;
      for (const e of entries) {
        const attr = (e.target as HTMLElement).getAttribute('data-page');
        const page = attr ? Number(attr) : NaN;
        if (!Number.isFinite(page)) continue;
        const ratio = e.intersectionRatio;
        if (!best || ratio > best.ratio) best = { page, ratio };
      }
      if (!best || best.ratio < 0.25) return;
      syncingFromPdfRef.current = true;
      const el = targetPane.querySelector(`[data-page-marker="${best.page}"]`) as HTMLElement | null;
      if (el) targetPane.scrollTo({ top: el.offsetTop - 16, behavior: 'smooth' });
      if (best.page !== currentPage) setCurrentPage(best.page);
      window.setTimeout(() => { syncingFromPdfRef.current = false; }, 250);
    }, { root: container, threshold: [0, 0.25, 0.5, 0.75, 1] });
    markers.forEach(m => observer.observe(m));
    return () => observer.disconnect();
  }, [pdfUrl]);

  return (
    <div className="flex h-full flex-col gap-2">
      <div className="flex items-center justify-between gap-2">
        <PhaseStepper />
        <div className="ml-auto flex items-center gap-2 pr-1">
          <button type="button" className="h-7 px-2 border rounded text-xs" onClick={() => setIsPdfCollapsed(v => !v)}>{isPdfCollapsed ? 'PDF zeigen' : 'PDF ausblenden'}</button>
          <form className="flex items-center gap-1" onSubmit={(e) => { e.preventDefault(); const input = (e.currentTarget.elements.namedItem('gpage') as HTMLInputElement | null); if (!input) return; const val = Number(input.value); if (Number.isFinite(val) && val >= 1) setCurrentPage(val); }}>
            <span className="text-xs text-muted-foreground">Seite</span>
            <input name="gpage" value={currentPage} onChange={(e) => setCurrentPage(Number(e.target.value) || 1)} className="h-7 w-16 text-center border rounded text-xs" />
            <button type="submit" className="h-7 px-2 border rounded text-xs">Gehe</button>
          </form>
        </div>
      </div>

      {/* Split */}
      <div className="grid grid-cols-2 gap-2 h-full min-h-0">
        {/* Left Pane: immer PDF (ein-/ausblendbar) */}
        <div className={`min-h-0 overflow-auto rounded border ${isPdfCollapsed ? 'hidden' : ''}`} ref={leftRef}>
          {pdfUrl ? <PdfCanvasViewer src={pdfUrl} /> : <DocumentPreview provider={provider} activeLibraryId={activeLibraryId} />}
        </div>

        {/* Right Pane: immer Analyse-Viewer (Markdown/Metadaten/Kapitel/Prozessinfo) */}
        <div className={`min-h-0 overflow-auto rounded border ${isPdfCollapsed ? 'col-span-2' : ''}`} ref={rightRef}>
          <div className="h-full">
            <JobReportTab
              libraryId={activeLibraryId}
              fileId={item.id}
              fileName={item.metadata?.name}
              provider={provider || undefined}
              sourceMode="frontmatter"
              viewMode="metaOnly"
              mdFileId={shadowTwin?.id || null}
              forcedTab={phase === 1 ? 'markdown' : phase === 2 ? 'meta' : 'process'}
              onJumpTo={({ page, evidence }) => {
                if (typeof page === 'number' || typeof page === 'string') {
                  const p = typeof page === 'string' ? Number(page) : page;
                  if (Number.isFinite(p)) setCurrentPage(p as number);
                } else if (typeof evidence === 'string' && evidence.trim()) {
                  if (markdownApiRef.current) {
                    markdownApiRef.current.setQueryAndSearch(evidence.slice(0, 80));
                    const vis = markdownApiRef.current.getVisiblePage?.();
                    if (vis && Number.isFinite(vis)) setCurrentPage(vis as number);
                  }
                }
              }}
            />
          </div>
        </div>
      </div>
    </div>
  );
}



```

```typescriptreact
"use client";

import { useEffect, useState } from 'react'
import { UILogger } from '@/lib/debug/logger'
import type { StorageProvider } from '@/lib/storage/types'
import { MarkdownPreview } from '@/components/library/markdown-preview'
import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs'
import { TooltipProvider, Tooltip, TooltipTrigger, TooltipContent } from '@/components/ui/tooltip'
import { parseSecretaryMarkdownStrict } from '@/lib/secretary/response-parser'

interface JobReportTabProps {
  libraryId: string
  fileId: string
  fileName?: string
  provider?: StorageProvider | null
  // Quelle der Metadaten steuern: 'merged' = cumulativeMeta + Frontmatter (Standard),
  // 'frontmatter' = ausschließlich Frontmatter aus Markdown anzeigen
  sourceMode?: 'merged' | 'frontmatter'
  // Darstellungsmodus: 'full' zeigt Kopf/Steps/Logs/Parameter; 'metaOnly' zeigt nur Metadaten/Kapitel/TOC
  viewMode?: 'full' | 'metaOnly'
  // Optional explizite Markdown-Datei-ID (Shadow‑Twin). Überschreibt auto-Erkennung.
  mdFileId?: string | null
  // Optionaler Callback zum Scroll-Sync in die Markdown-Vorschau
  onJumpTo?: (args: { page?: number | string; evidence?: string }) => void
  // NEU: Rohinhalt (Markdown). Wenn gesetzt und sourceMode='frontmatter', wird direkt dieser Text geparst (ohne Datei/JOB).
  rawContent?: string
  forcedTab?: 'markdown' | 'meta' | 'chapters' | 'process'
}

interface JobDto {
  jobId: string
  status: string
  operation: string
  worker: string
  job_type: string
  updatedAt: string
  createdAt: string
  correlation?: { source?: { itemId?: string; name?: string } }
  parameters?: Record<string, unknown>
  steps?: Array<{ name: string; status: string; startedAt?: string; endedAt?: string; error?: { message: string }; details?: { skipped?: boolean } }>
  ingestion?: { vectorsUpserted?: number; index?: string; upsertAt?: string }
  result?: { savedItemId?: string }
  logs?: Array<{ timestamp: string; phase?: string; message?: string; progress?: number }>
  cumulativeMeta?: Record<string, unknown>
}

export function JobReportTab({ libraryId, fileId, fileName, provider, sourceMode = 'merged', viewMode = 'full', mdFileId, onJumpTo, rawContent, forcedTab }: JobReportTabProps) {
  const [loading, setLoading] = useState(false)
  const [error, setError] = useState<string | null>(null)
  const [job, setJob] = useState<JobDto | null>(null)
  const [templateFields, setTemplateFields] = useState<string[] | null>(null)
  const [frontmatterMeta, setFrontmatterMeta] = useState<Record<string, unknown> | null>(null)
  const [section, setSection] = useState<'meta' | 'chapters'>('meta')
  const [parseErrors, setParseErrors] = useState<string[]>([])
  const [fullContent, setFullContent] = useState<string>('')

  const stripFrontmatter = (markdown: string): string => markdown.replace(/^---\r?\n([\s\S]*?)\r?\n---\r?\n?/, '')

  useEffect(() => {
    let cancelled = false
    async function run() {
      try {
        // Wenn wir Rohinhalt haben und nur Frontmatter zeigen, brauchen wir keine Job-Suche
        if (sourceMode === 'frontmatter' && typeof rawContent === 'string' && rawContent.length > 0) {
          setJob(null)
          setLoading(false)
          setError(null)
          return
        }
        setLoading(true)
        setError(null)
        UILogger.info('JobReportTab', 'Start Job-Suche', { libraryId, fileId })
        // 1) Versuche Job über result.savedItemId (Shadow‑Twin) zu finden
        const byResultUrl = new URL(`/api/external/jobs`, window.location.origin)
        byResultUrl.searchParams.set('byResultItemId', fileId)
        UILogger.debug('JobReportTab', 'Request byResultItemId', { url: byResultUrl.toString() })
        let res = await fetch(byResultUrl.toString(), { cache: 'no-store' })
        let data = await res.json()
        if (!res.ok) throw new Error(typeof data?.error === 'string' ? data.error : 'Job-Suche fehlgeschlagen')
        let j: JobDto | null = Array.isArray(data?.items) && data.items.length > 0 ? (data.items[0] as JobDto) : null
        UILogger.debug('JobReportTab', 'Result byResultItemId', { count: Array.isArray(data?.items) ? data.items.length : 0 })

        // 2) Fallback: über correlation.source.itemId (Originaldatei)
        if (!j) {
          const bySourceUrl = new URL(`/api/external/jobs`, window.location.origin)
          bySourceUrl.searchParams.set('bySourceItemId', fileId)
          bySourceUrl.searchParams.set('libraryId', libraryId)
          UILogger.debug('JobReportTab', 'Request bySourceItemId', { url: bySourceUrl.toString() })
          res = await fetch(bySourceUrl.toString(), { cache: 'no-store' })
          data = await res.json()
          if (!res.ok) throw new Error(typeof data?.error === 'string' ? data.error : 'Job-Suche (Quelle) fehlgeschlagen')
          j = Array.isArray(data?.items) && data.items.length > 0 ? (data.items[0] as JobDto) : null
          UILogger.debug('JobReportTab', 'Result bySourceItemId', { count: Array.isArray(data?.items) ? data.items.length : 0 })
        }

        // 3) Fallback: über correlation.source.name (Dateiname der Quelle)
        if (!j) {
          const byNameUrl = new URL(`/api/external/jobs`, window.location.origin)
          // Wenn wir den tatsächlichen Dateinamen kennen, verwende ihn.
          // Für Shadow‑Twins (z. B. name.de.md) versuche das Basis‑PDF (name.pdf).
          let candidate = (fileName && typeof fileName === 'string') ? fileName : (fileId.includes('/') ? (fileId.split('/').pop() as string) : fileId)
          const parts = candidate.split('.')
          if (parts.length >= 3) {
            const ext1 = parts[parts.length - 1].toLowerCase()
            const ext2 = parts[parts.length - 2].toLowerCase()
            if ((ext1 === 'md' || ext1 === 'mdx') && /^[a-z]{2}$/i.test(ext2)) {
              candidate = parts.slice(0, -2).join('.') + '.pdf'
            }
          }
          byNameUrl.searchParams.set('bySourceName', candidate)
          byNameUrl.searchParams.set('libraryId', libraryId)
          UILogger.debug('JobReportTab', 'Request bySourceName', { url: byNameUrl.toString(), nameOnly: candidate, originalFileName: fileName })
          res = await fetch(byNameUrl.toString(), { cache: 'no-store' })
          data = await res.json()
          if (!res.ok) throw new Error(typeof data?.error === 'string' ? data.error : 'Job-Suche (Name) fehlgeschlagen')
          j = Array.isArray(data?.items) && data.items.length > 0 ? (data.items[0] as JobDto) : null
          UILogger.debug('JobReportTab', 'Result bySourceName', { count: Array.isArray(data?.items) ? data.items.length : 0 })
        }

        if (!cancelled) setJob(j)
        if (j) UILogger.info('JobReportTab', 'Job gefunden', { jobId: j.jobId, status: j.status })
        else UILogger.warn('JobReportTab', 'Kein Job gefunden', { libraryId, fileId })
      } catch (e) {
        const msg = e instanceof Error ? e.message : 'Unbekannter Fehler'
        UILogger.error('JobReportTab', 'Job-Suche fehlgeschlagen', e)
        if (!cancelled) setError(msg)
      } finally {
        if (!cancelled) setLoading(false)
      }
    }
    void run()
    return () => { cancelled = true }
  }, [libraryId, fileId, fileName, sourceMode, rawContent])

  // Wenn Template benutzt wurde, lade dessen Inhalt aus /templates und extrahiere Frontmatter-Schlüssel
  useEffect(() => {
    async function loadTemplateFields() {
      try {
        setTemplateFields(null)
        const tpl = job?.cumulativeMeta && typeof (job.cumulativeMeta as unknown) === 'object'
          ? (job.cumulativeMeta as Record<string, unknown>)['template_used']
          : undefined
        const templateName = typeof tpl === 'string' ? tpl : undefined
        if (!templateName || !provider) return
        const rootItems = await provider.listItemsById('root')
        const templatesFolder = rootItems.find(it => it.type === 'folder' && typeof (it as { metadata?: { name?: string } }).metadata?.name === 'string' && ((it as { metadata: { name: string } }).metadata.name.toLowerCase() === 'templates'))
        if (!templatesFolder) return
        const tplItems = await provider.listItemsById(templatesFolder.id)
        const match = tplItems.find(it => it.type === 'file' && ((it as { metadata: { name: string } }).metadata.name.toLowerCase() === templateName.toLowerCase()))
        if (!match) return
        const bin = await provider.getBinary(match.id)
        const text = await bin.blob.text()
        // Extrahiere Frontmatter zwischen den ersten beiden --- und lese die Keys bis zu :
        const m = text.match(/^---[\s\S]*?---/)
        if (!m) return
        const fm = m[0]
        const keys: string[] = []
        for (const line of fm.split('\n')) {
          const t = line.trim()
          if (!t || t === '---') continue
          const idx = t.indexOf(':')
          if (idx > 0) {
            const k = t.slice(0, idx).trim()
            if (k) keys.push(k)
          }
        }
        setTemplateFields(Array.from(new Set(keys)))
      } catch (e) {
        UILogger.warn('JobReportTab', 'Template-Felder konnten nicht geladen werden', { error: e instanceof Error ? e.message : String(e) })
      }
    }
    void loadTemplateFields()
  }, [job, provider])

  // Gemeinsamer strikter Parser
  const strictParseFrontmatter = (fm: string) => parseSecretaryMarkdownStrict(fm)

  // Frontmatter aus der gespeicherten Markdown-Datei lesen (oder aus rawContent)
  useEffect(() => {
    async function loadFrontmatter() {
      try {
        setParseErrors([])
        // Wenn roher Inhalt übergeben wurde, direkt daraus lesen
        if (sourceMode === 'frontmatter' && typeof rawContent === 'string' && rawContent.length > 0) {
          const text = rawContent
          setFullContent(text)
          const { frontmatter, meta, errors } = parseSecretaryMarkdownStrict(text)
          UILogger.debug('JobReportTab', 'Frontmatter (raw): Block gefunden?', { found: !!frontmatter, length: frontmatter ? frontmatter.length : 0 })
          if (!frontmatter) { setFrontmatterMeta(null); return }
          setFrontmatterMeta(Object.keys(meta).length ? meta : null)
          setParseErrors(errors)
          return
        }

        if (!provider) return
        const mdId = (mdFileId || (job?.result?.savedItemId as string | undefined) || fileId)
        UILogger.info('JobReportTab', 'Frontmatter: Lade Datei', { mdId, sourceMode })
        if (!mdId) return
        const bin = await provider.getBinary(mdId)
        const text = await bin.blob.text()
        setFullContent(text)
        const { frontmatter, meta, errors } = parseSecretaryMarkdownStrict(text)
        UILogger.debug('JobReportTab', 'Frontmatter: Block gefunden?', { found: !!frontmatter, length: frontmatter ? frontmatter.length : 0 })
        if (!frontmatter) { setFrontmatterMeta(null); return }
        setFrontmatterMeta(Object.keys(meta).length ? meta : null)
        setParseErrors(errors)
      } catch {
        setFrontmatterMeta(null)
      }
    }
    void loadFrontmatter()
  }, [provider, fileId, mdFileId, job?.result?.savedItemId, sourceMode, rawContent])

  if (sourceMode !== 'frontmatter') {
    if (loading) return <div className="p-4 text-sm text-muted-foreground">Lade Job…</div>
    if (error) return <div className="p-4 text-sm text-destructive">{error}</div>
    if (!job) return <div className="p-4 text-sm text-muted-foreground">Kein Job zur Datei gefunden.</div>
  }

  return (
    <div className="p-4 space-y-3 text-sm">
      {viewMode === 'metaOnly' && (
        <Tabs defaultValue="markdown">
          <TabsList className="grid grid-cols-4 w-full gap-1">
            <TabsTrigger value="markdown" className="px-2 py-1 text-xs">Markdown</TabsTrigger>
            <TabsTrigger value="meta" className="px-2 py-1 text-xs">Metadaten</TabsTrigger>
            <TabsTrigger value="chapters" className="px-2 py-1 text-xs">Kapitel</TabsTrigger>
            {(() => {
              const base: Record<string, unknown> = sourceMode === 'frontmatter' ? {} : ((job?.cumulativeMeta as unknown as Record<string, unknown>) || {})
              const cm = frontmatterMeta ? { ...base, ...frontmatterMeta } : base
              const processFields = new Set([
                'job_id','extract_status','template_status','ingest_status','summary_language',
                'source_file','source_file_id','source_file_size','source_file_type',
                'filename','path','pathHints','isScan'
              ])
              const hasProcess = Object.keys(cm).some(k => processFields.has(k))
              return hasProcess ? <TabsTrigger value="process" className="px-2 py-1 text-xs">Prozessinfo</TabsTrigger> : null
            })()}
          </TabsList>

          <TabsContent value="markdown" className="mt-3">
            <div className="border rounded-md">
              <MarkdownPreview content={stripFrontmatter(fullContent || '')} />
            </div>
          </TabsContent>

          <TabsContent value="meta" className="mt-3">
            {/* Hinweise zu Parserfehlern (strikt) */}
            {parseErrors.length > 0 && (
              <div className="text-xs text-destructive mb-2">
                {parseErrors.map((e, i) => (<div key={i}>Parserfehler: {e}</div>))}
              </div>
            )}
            {(() => {
              const base: Record<string, unknown> = sourceMode === 'frontmatter'
                ? {}
                : ((job?.cumulativeMeta as unknown as Record<string, unknown>) || {})
              const cm = frontmatterMeta ? { ...base, ...frontmatterMeta } : base
              // confidence/provenance können Objekt oder JSON-String sein → Fallback parse
              const confidence: Record<string, unknown> = (() => {
                const raw = cm['confidence']
                if (raw && typeof raw === 'object') return raw as Record<string, unknown>
                if (typeof raw === 'string') { try { return JSON.parse(raw) as Record<string, unknown> } catch { /* ignore */ } }
                return {}
              })()
              const provenance: Record<string, unknown> = (() => {
                const raw = cm['provenance']
                if (raw && typeof raw === 'object') return raw as Record<string, unknown>
                if (typeof raw === 'string') { try { return JSON.parse(raw) as Record<string, unknown> } catch { /* ignore */ } }
                return {}
              })()
              const hasAnyConfidence = Object.keys(confidence).length > 0
              const baseKeys = Array.isArray(templateFields) && templateFields.length > 0
                ? Array.from(new Set([...(templateFields as string[]), ...Object.keys(cm)]))
                : Object.keys(cm)
              const flatKeysAll = baseKeys.filter(k => k !== 'chapters' && k !== 'toc' && k !== 'confidence' && k !== 'provenance')
              const processFields = new Set([
                'job_id','extract_status','template_status','ingest_status','summary_language',
                'source_file','source_file_id','source_file_size','source_file_type',
                'filename','path','pathHints','isScan'
              ])
              const primaryKeys = flatKeysAll.filter(k => !processFields.has(k))
              const flatKeys = primaryKeys
              if (flatKeys.length === 0) return null
              return (
                <div>
                  <div className="font-medium mb-1">Metadaten (Template vs. Ergebnis)</div>
                  <div className="overflow-auto">
                    <table className="w-full text-xs">
                      <thead>
                        <tr className="text-left text-muted-foreground">
                          <th className="py-1 pr-2 sticky left-0 bg-background z-10">Feld</th>
                          <th className="py-1 pr-2">Wert</th>
                          {hasAnyConfidence ? <th className="py-1 pr-2 text-right sticky right-0 bg-background border-l">Q</th> : null}
                        </tr>
                      </thead>
                      <tbody>
                        {flatKeys.map((k) => {
                          const val = cm[k]
                          let valueStr = ''
                          if (Array.isArray(val)) valueStr = (val as Array<unknown>).map(v => typeof v === 'string' ? v : JSON.stringify(v)).join(', ')
                          else valueStr = val === null || val === undefined ? '' : typeof val === 'string' ? val : JSON.stringify(val)
                          const hasNonEmptyValue = (() => {
                            if (val === null || val === undefined) return false
                            if (typeof val === 'string') return val.trim().length > 0
                            if (Array.isArray(val)) return (val as Array<unknown>).length > 0
                            if (typeof val === 'object') return Object.keys(val as Record<string, unknown>).length > 0
                            return true
                          })()
                          const cRaw = (confidence as Record<string, unknown>)[k]
                          const cNum = typeof cRaw === 'number' ? cRaw : (typeof cRaw === 'string' && /^\d+(\.\d+)?$/.test(cRaw) ? Number(cRaw) : undefined)
                          const pRaw = (provenance as Record<string, unknown>)[k]
                          const pStr = typeof pRaw === 'string' ? pRaw : pRaw ? JSON.stringify(pRaw) : ''
                          const color = cNum === undefined ? 'text-muted-foreground' : (cNum >= 0.8 ? 'text-green-600' : cNum >= 0.7 ? 'text-yellow-600' : 'text-red-600')
                          return (
                            <tr key={k} className="border-t border-muted/40">
                              <td className="py-1 pr-2 align-top font-medium sticky left-0 bg-background z-10 whitespace-nowrap">{k}</td>
                              <td className="py-1 pr-2 align-top">
                                {valueStr ? (
                                  <TooltipProvider>
                                    <Tooltip>
                                      <TooltipTrigger asChild>
                                        <span className="inline-block max-w-[40vw] overflow-hidden text-ellipsis whitespace-nowrap align-top" title="">
                                          {valueStr}
                                        </span>
                                      </TooltipTrigger>
                                      <TooltipContent>
                                        <div className="max-w-[80vw] whitespace-pre-wrap break-words">{valueStr}</div>
                                      </TooltipContent>
                                    </Tooltip>
                                  </TooltipProvider>
                                ) : ''}
                              </td>
                              {hasAnyConfidence ? <td className="py-1 pr-2 align-top sticky right-0 bg-background border-l">
                                {(!hasNonEmptyValue || cNum === undefined) ? null : (
                                  <TooltipProvider>
                                    <Tooltip>
                                      <TooltipTrigger asChild>
                                        <span className={`inline-flex items-center justify-end w-full ${color}`} title={pStr || ''}>
                                          <span className="inline-block h-2 w-2 rounded-full bg-current" />
                                        </span>
                                      </TooltipTrigger>
                                      <TooltipContent>
                                        <div className="max-w-xs whitespace-pre-wrap break-words">
                                          <div className="font-medium">Confidence: {cNum.toFixed(2)}</div>
                                          {pStr ? <div className="mt-1 text-muted-foreground">Provenance: {pStr}</div> : null}
                                        </div>
                                      </TooltipContent>
                                    </Tooltip>
                                  </TooltipProvider>
                                )}
                              </td> : null}
                            </tr>
                          )
                        })}
                      </tbody>
                    </table>
                  </div>
                </div>
              )
            })()}
          </TabsContent>

          <TabsContent value="process" className="mt-3">
            {(() => {
              const base: Record<string, unknown> = sourceMode === 'frontmatter'
                ? {}
                : ((job?.cumulativeMeta as unknown as Record<string, unknown>) || {})
              const cm = frontmatterMeta ? { ...base, ...frontmatterMeta } : base
              const processOrder = [
                'job_id','extract_status','template_status','ingest_status','summary_language',
                'source_file','source_file_id','source_file_size','source_file_type',
                'filename','path','pathHints','isScan'
              ]
              const keys = processOrder.filter(k => k in cm)
              if (keys.length === 0) return <div className="text-xs text-muted-foreground">Keine Prozessinformationen vorhanden.</div>
              return (
                <div className="overflow-auto">
                  <table className="w-full text-xs">
                    <thead>
                      <tr className="text-left text-muted-foreground">
                        <th className="py-1 pr-2 sticky left-0 bg-background z-10">Feld</th>
                        <th className="py-1 pr-2">Wert</th>
                      </tr>
                    </thead>
                    <tbody>
                      {keys.map(k => {
                        const val = cm[k]
                        const valueStr = val === null || val === undefined ? '' : Array.isArray(val) ? (val as Array<unknown>).map(v => typeof v === 'string' ? v : JSON.stringify(v)).join(', ') : typeof val === 'string' ? val : JSON.stringify(val)
                        return (
                          <tr key={k} className="border-t border-muted/40">
                            <td className="py-1 pr-2 align-top font-medium sticky left-0 bg-background z-10 whitespace-nowrap">{k}</td>
                            <td className="py-1 pr-2 align-top">
                              {valueStr ? (
                                <TooltipProvider>
                                  <Tooltip>
                                    <TooltipTrigger asChild>
                                      <span className="inline-block max-w-[40vw] overflow-hidden text-ellipsis whitespace-nowrap align-top" title="">{valueStr}</span>
                                    </TooltipTrigger>
                                    <TooltipContent>
                                      <div className="max-w-[80vw] whitespace-pre-wrap break-words">{valueStr}</div>
                                    </TooltipContent>
                                  </Tooltip>
                                </TooltipProvider>
                              ) : ''}
                            </td>
                          </tr>
                        )
                      })}
                    </tbody>
                  </table>
                </div>
              )
            })()}
          </TabsContent>

          <TabsContent value="chapters" className="mt-3">
            {(() => {
              const chapters: Array<Record<string, unknown>> = sourceMode === 'frontmatter'
                ? (Array.isArray(frontmatterMeta?.chapters) ? (frontmatterMeta?.chapters as Array<Record<string, unknown>>) : [])
                : ((job?.cumulativeMeta as unknown as { chapters?: Array<Record<string, unknown>> })?.chapters || [])
              if (!Array.isArray(chapters) || chapters.length === 0) return null
              const pad = (lvl: number | undefined): number => {
                if (typeof lvl !== 'number') return 0
                const clamped = Math.max(0, Math.min(3, lvl))
                return (clamped - 1) * 16
              }
              const counters = [0, 0, 0]
              return (
                <div className="space-y-1">
                  <div>
                    {chapters.map((c, i) => {
                      const level = typeof c.level === 'number' ? c.level : 1
                      const lvl = Math.max(1, Math.min(3, level))
                      counters[lvl - 1] += 1
                      for (let j = lvl; j < counters.length; j++) counters[j] = 0
                      const numLabel = counters.slice(0, lvl).filter(n => n > 0).join('.')
                      const title = typeof c.title === 'string' ? c.title : ''
                      const startPage = typeof c.startPage === 'number' ? c.startPage : ''
                      const summaryVal = typeof c.summary === 'string' ? c.summary : ''
                      const summary = summaryVal.length > 1000 ? `${summaryVal.slice(0, 1000)}…` : summaryVal
                      const keywords = Array.isArray(c.keywords) ? (c.keywords as Array<unknown>).filter(v => typeof v === 'string') as string[] : []
                      const ev = typeof c.startEvidence === 'string' ? c.startEvidence : ''
                      return (
                        <details key={`${title}-${i}`} className="group border-b py-1" open={false}>
                          <summary className="list-none cursor-pointer">
                            <div className="flex items-start justify-between gap-3">
                              <div className="flex-1 min-w-0" style={{ paddingLeft: `${pad(lvl)}px` }}>
                                <div className="flex items-baseline gap-2">
                                  <span className="text-xs text-muted-foreground tabular-nums">{numLabel}</span>
                                  <span className="font-medium truncate">{title}</span>
                                </div>
                              </div>
                              <div className="text-xs tabular-nums text-muted-foreground whitespace-nowrap">
                                {String(startPage)}
                              </div>
                            </div>
                          </summary>
                          <div className="mt-1 pr-1 text-xs space-y-1" style={{ paddingLeft: `${pad(lvl) + 28}px` }}>
                            {summary && (
                              <div className="whitespace-pre-wrap break-words">
                                {summary}
                              </div>
                            )}
                            {Array.isArray(keywords) && keywords.length > 0 && (
                              <div className="flex flex-wrap gap-1">
                                {keywords.map(k => (
                                  <span key={k} className="inline-flex items-center rounded px-1.5 py-0.5 bg-muted">{k}</span>
                                ))}
                              </div>
                            )}
                          </div>
                        </details>
                      )
                    })}
                  </div>
                </div>
              )
            })()}
          </TabsContent>
        </Tabs>
      )}

      {viewMode === 'full' && job && (
        <div className="flex items-center justify-between">
          <div>
            <div className="font-medium">Job {job.jobId}</div>
            <div className="text-xs text-muted-foreground">{job.job_type} · {job.operation} · {new Date(job.updatedAt).toLocaleString()}</div>
          </div>
          <div className="inline-flex items-center rounded px-2 py-0.5 bg-muted text-xs">{job.status}</div>
        </div>
      )}

      {/* Hinweise zu Parserfehlern (strikt) */}
      {viewMode !== 'metaOnly' && parseErrors.length > 0 && (
        <div className="text-xs text-destructive">
          {parseErrors.map((e, i) => (<div key={i}>Parserfehler: {e}</div>))}
        </div>
      )}

      {/* Template Hinweis (im Frontmatter-only-Modus ausgeblendet) */}
      {sourceMode !== 'frontmatter' && job && typeof job.cumulativeMeta?.template_used === 'string' && (
        <div className="text-xs text-muted-foreground">Template: {String(job.cumulativeMeta.template_used)}</div>
      )}

      {/* Schritte mit Ampel-Logik */}
      {viewMode === 'full' && job && Array.isArray(job.steps) && job.steps.length > 0 && (
        <div>
          <div className="font-medium mb-1">Schritte</div>
          <div className="flex flex-wrap gap-2 text-xs">
            {job.steps.map((s) => {
              // Geplante Phasen ermitteln (neue Flags bevorzugt, sonst phases)
              const p = (job.parameters || {}) as Record<string, unknown>
              const hasNewFlags = typeof p['doExtractPDF'] === 'boolean' || typeof p['doExtractMetadata'] === 'boolean' || typeof p['doIngestRAG'] === 'boolean'
              const phases = hasNewFlags
                ? {
                    extract: p['doExtractPDF'] === true,
                    template: p['doExtractMetadata'] === true,
                    ingest: p['doIngestRAG'] === true,
                  }
                : ((p['phases'] as { extract?: boolean; template?: boolean; ingest?: boolean }) || {})

              const planned = (() => {
                const n = s.name
                if (n === 'extract_pdf') return phases.extract === true
                if (n === 'transform_template' || n === 'store_shadow_twin') return phases.template === true
                if (n === 'ingest_rag') return phases.ingest === true
                return false
              })()

              // Ampel-Status ableiten
              const skipped = !!(s as { details?: { skipped?: boolean } }).details?.skipped
              let icon = '○'
              let cls = 'text-muted-foreground'
              if (s.status === 'failed') { icon = '✕'; cls = 'text-red-600' }
              else if (s.status === 'running') { icon = '◐'; cls = 'text-yellow-600' }
              else if (s.status === 'completed') { icon = skipped ? '○' : '✓'; cls = skipped ? 'text-gray-400' : 'text-green-600' }
              else if (s.status === 'pending') { icon = planned ? '•' : '○'; cls = planned ? 'text-yellow-600' : 'text-muted-foreground' }

              const time = s.endedAt ? new Date(s.endedAt).toLocaleTimeString() : s.startedAt ? new Date(s.startedAt).toLocaleTimeString() : ''
              return (
                <div key={s.name} className={`inline-flex items-center gap-1 px-2 py-1 rounded border ${cls}`}>
                  <span>{icon}</span>
                  <span className="font-medium">{s.name}</span>
                  {time ? <span className="opacity-70">{time}</span> : null}
                </div>
              )
            })}
          </div>
        </div>
      )}

      {/* Metadaten (flach) – je nach sourceMode: nur Frontmatter oder Merge (nur außerhalb metaOnly-View) */}
      {viewMode !== 'metaOnly' && section === 'meta' && (() => {
        const base: Record<string, unknown> = sourceMode === 'frontmatter'
          ? {}
          : ((job?.cumulativeMeta as unknown as Record<string, unknown>) || {})
        const cm = frontmatterMeta ? { ...base, ...frontmatterMeta } : base
        const confidence: Record<string, unknown> = (() => {
          const raw = cm['confidence']
          if (raw && typeof raw === 'object') return raw as Record<string, unknown>
          if (typeof raw === 'string') { try { return JSON.parse(raw) as Record<string, unknown> } catch { /* ignore */ } }
          return {}
        })()
        const provenance: Record<string, unknown> = (() => {
          const raw = cm['provenance']
          if (raw && typeof raw === 'object') return raw as Record<string, unknown>
          if (typeof raw === 'string') { try { return JSON.parse(raw) as Record<string, unknown> } catch { /* ignore */ } }
          return {}
        })()
        const hasAnyConfidence = Object.keys(confidence).length > 0
        const baseKeys = Array.isArray(templateFields) && templateFields.length > 0
          ? Array.from(new Set([...(templateFields as string[]), ...Object.keys(cm)]))
          : Object.keys(cm)
        const flatKeys = baseKeys.filter(k => k !== 'chapters' && k !== 'toc' && k !== 'confidence' && k !== 'provenance')
        if (flatKeys.length === 0) return null
        return (
        <div>
          <div className="font-medium mb-1">Metadaten (Template vs. Ergebnis)</div>
          <div className="overflow-auto">
            <table className="w-full text-xs">
              <thead>
                <tr className="text-left text-muted-foreground">
                  <th className="py-1 pr-2 sticky left-0 bg-background z-10">Feld</th>
                  <th className="py-1 pr-2">Wert</th>
                  {hasAnyConfidence ? <th className="py-1 pr-2 text-right sticky right-0 bg-background border-l">Q</th> : null}
                </tr>
              </thead>
              <tbody>
                {flatKeys.map((k) => {
                  const val = cm[k]
                  let valueStr = ''
                  if (Array.isArray(val)) valueStr = (val as Array<unknown>).map(v => typeof v === 'string' ? v : JSON.stringify(v)).join(', ')
                  else valueStr = val === null || val === undefined ? '' : typeof val === 'string' ? val : JSON.stringify(val)
                  const hasNonEmptyValue = (() => {
                    if (val === null || val === undefined) return false
                    if (typeof val === 'string') return val.trim().length > 0
                    if (Array.isArray(val)) return (val as Array<unknown>).length > 0
                    if (typeof val === 'object') return Object.keys(val as Record<string, unknown>).length > 0
                    return true
                  })()
                  const cRaw = (confidence as Record<string, unknown>)[k]
                  const cNum = typeof cRaw === 'number' ? cRaw : (typeof cRaw === 'string' && /^\d+(\.\d+)?$/.test(cRaw) ? Number(cRaw) : undefined)
                  const pRaw = (provenance as Record<string, unknown>)[k]
                  const pStr = typeof pRaw === 'string' ? pRaw : pRaw ? JSON.stringify(pRaw) : ''
                  const color = cNum === undefined ? 'text-muted-foreground' : (cNum >= 0.8 ? 'text-green-600' : cNum >= 0.7 ? 'text-yellow-600' : 'text-red-600')
                  return (
                    <tr key={k} className="border-t border-muted/40">
                      <td className="py-1 pr-2 align-top font-medium sticky left-0 bg-background z-10 whitespace-nowrap">{k}</td>
                      <td className="py-1 pr-2 align-top">
                        {valueStr ? (
                          <TooltipProvider>
                            <Tooltip>
                              <TooltipTrigger asChild>
                                <span className="inline-block max-w-[40vw] overflow-hidden text-ellipsis whitespace-nowrap align-top" title="">
                                  {valueStr}
                                </span>
                              </TooltipTrigger>
                              <TooltipContent>
                                <div className="max-w-[80vw] whitespace-pre-wrap break-words">{valueStr}</div>
                              </TooltipContent>
                            </Tooltip>
                          </TooltipProvider>
                        ) : ''}
                      </td>
                      {hasAnyConfidence ? <td className="py-1 pr-2 align-top sticky right-0 bg-background border-l">
                        {(!hasNonEmptyValue || cNum === undefined) ? null : (
                          <TooltipProvider>
                            <Tooltip>
                              <TooltipTrigger asChild>
                                <span className={`inline-flex items-center justify-end w-full ${color}`} title={pStr || ''}>
                                  <span className="inline-block h-2 w-2 rounded-full bg-current" />
                                </span>
                              </TooltipTrigger>
                              <TooltipContent>
                                <div className="max-w-xs whitespace-pre-wrap break-words">
                                  <div className="font-medium">Confidence: {cNum.toFixed(2)}</div>
                                  {pStr ? <div className="mt-1 text-muted-foreground">Provenance: {pStr}</div> : null}
                                </div>
                              </TooltipContent>
                            </Tooltip>
                          </TooltipProvider>
                        )}
                      </td> : null}
                    </tr>
                  )
                })}
              </tbody>
            </table>
          </div>
        </div>
        )
      })()}

      {/* Kapitel (hierarchisch, TOC-Ansicht) – nur außerhalb metaOnly-View */}
      {viewMode !== 'metaOnly' && section === 'chapters' && (() => {
        const chapters: Array<Record<string, unknown>> = sourceMode === 'frontmatter'
          ? (Array.isArray(frontmatterMeta?.chapters) ? (frontmatterMeta?.chapters as Array<Record<string, unknown>>) : [])
          : ((job?.cumulativeMeta as unknown as { chapters?: Array<Record<string, unknown>> })?.chapters || [])
        if (!Array.isArray(chapters) || chapters.length === 0) return null

        const pad = (lvl: number | undefined): number => {
          if (typeof lvl !== 'number') return 0
          const clamped = Math.max(0, Math.min(3, lvl))
          return (clamped - 1) * 16 // px
        }

        // Hierarchische Nummerierung 1., 1.1, 1.1.1 basierend auf level
        const counters = [0, 0, 0]
        return (
        <div className="space-y-1">
          <div className="font-medium mb-1">Kapitel</div>
          <div>
            {chapters.map((c, i) => {
              const level = typeof c.level === 'number' ? c.level : 1
              const lvl = Math.max(1, Math.min(3, level))
              // Zähler aktualisieren
              counters[lvl - 1] += 1
              for (let j = lvl; j < counters.length; j++) counters[j] = 0
              const numLabel = counters.slice(0, lvl).filter(n => n > 0).join('.')
              const title = typeof c.title === 'string' ? c.title : ''
              const startPage = typeof c.startPage === 'number' ? c.startPage : ''
              
              const summaryVal = typeof c.summary === 'string' ? c.summary : ''
              const summary = summaryVal.length > 1000 ? `${summaryVal.slice(0, 1000)}…` : summaryVal
              const keywords = Array.isArray(c.keywords) ? (c.keywords as Array<unknown>).filter(v => typeof v === 'string') as string[] : []
              const ev = typeof c.startEvidence === 'string' ? c.startEvidence : ''
              return (
                <details key={`${title}-${i}`} className="group border-b py-1" open={false} onToggle={(e) => {
                  const open = (e.currentTarget as HTMLDetailsElement).open
                  if (open) {
                    if (startPage !== '') onJumpTo?.({ page: startPage as number | string })
                    else if (ev) onJumpTo?.({ evidence: ev })
                  }
                }}>
                  <summary className="list-none cursor-pointer">
                    <div className="flex items-start justify-between gap-3">
                      <div className="flex-1 min-w-0" style={{ paddingLeft: `${pad(lvl)}px` }}>
                        <div className="flex items-baseline gap-2">
                          <span className="text-xs text-muted-foreground tabular-nums">{numLabel}</span>
                          <span className="font-medium truncate">{title}</span>
                        </div>
                      </div>
                      <div className="text-xs tabular-nums text-muted-foreground whitespace-nowrap">
                        {String(startPage)}
                      </div>
                    </div>
                  </summary>
                  <div className="mt-1 pr-1 text-xs space-y-1" style={{ paddingLeft: `${pad(lvl) + 28}px` }}>
                    {summary && (
                      <div className="whitespace-pre-wrap break-words">
                        {summary}
                      </div>
                    )}
                    {Array.isArray(keywords) && keywords.length > 0 && (
                      <div className="flex flex-wrap gap-1">
                        {keywords.map(k => (
                          <span key={k} className="inline-flex items-center rounded px-1.5 py-0.5 bg-muted">{k}</span>
                        ))}
                      </div>
                    )}
                  </div>
                </details>
              )
            })}
          </div>
        </div>
        )
      })()}

      {/* Inhaltsverzeichnis */}
      {section === 'chapters' && (() => {
        const toc: Array<Record<string, unknown>> = sourceMode === 'frontmatter'
          ? (Array.isArray(frontmatterMeta?.toc) ? (frontmatterMeta?.toc as Array<Record<string, unknown>>) : [])
          : ((job?.cumulativeMeta as unknown as { toc?: Array<Record<string, unknown>> }).toc || [])
        if (!Array.isArray(toc) || toc.length === 0) return null
        return (
        <div>
          <div className="font-medium mb-1">Inhaltsverzeichnis</div>
          <div className="overflow-visible">
            <table className="w-full text-xs">
              <thead>
                <tr className="text-left text-muted-foreground">
                  <th className="py-1 pr-2">Titel</th>
                  <th className="py-1 pr-2">Seite</th>
                  <th className="py-1 pr-2">L</th>
                </tr>
              </thead>
              <tbody>
                {toc.map((t, i) => {
                  const title = typeof t.title === 'string' ? t.title : ''
                  const page = typeof t.page === 'number' ? t.page : ''
                  const level = typeof t.level === 'number' ? t.level : ''
                  return (
                    <tr key={`${title}-${i}`} className="border-t border-muted/40">
                      <td className="py-1 pr-2 align-top whitespace-pre-wrap break-words">{title}</td>
                      <td className="py-1 pr-2 align-top">{page}</td>
                      <td className="py-1 pr-2 align-top">{level}</td>
                    </tr>
                  )
                })}
              </tbody>
            </table>
          </div>
        </div>
        )
      })()}

      {viewMode === 'full' && job && job.ingestion && (
        <div>
          <div className="font-medium mb-1">Ingestion</div>
          <div className="text-xs text-muted-foreground">{job.ingestion.index || '—'} · Vektoren: {job.ingestion.vectorsUpserted ?? '—'} · {job.ingestion.upsertAt ? new Date(job.ingestion.upsertAt).toLocaleString() : '—'}</div>
        </div>
      )}

      {viewMode === 'full' && job && Array.isArray(job.logs) && job.logs.length > 0 && (
        <div>
          <div className="font-medium mb-1">Logs (neueste zuerst)</div>
          <ul className="space-y-0.5 max-h-48 overflow-auto">
            {[...job.logs].reverse().slice(0, 30).map((l, i) => (
              <li key={i} className="text-xs">
                {new Date(l.timestamp).toLocaleTimeString()} · {l.phase || '—'} · {typeof l.progress === 'number' ? `${l.progress}% · ` : ''}{l.message || ''}
              </li>
            ))}
          </ul>
        </div>
      )}

      {/* Parameter am Ende */}
      {viewMode === 'full' && job && job.parameters && (
        <div>
          <div className="font-medium mb-1">Parameter</div>
          <pre className="bg-muted/40 rounded p-2 max-h-32 overflow-auto whitespace-pre-wrap break-words">{JSON.stringify(job.parameters, null, 2)}</pre>
        </div>
      )}
    </div>
  )
}



```

```typescriptreact
"use client";

import { useEffect, useState } from 'react'
import { UILogger } from '@/lib/debug/logger'
import type { StorageProvider } from '@/lib/storage/types'
import { MarkdownPreview } from '@/components/library/markdown-preview'
import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs'
import { TooltipProvider, Tooltip, TooltipTrigger, TooltipContent } from '@/components/ui/tooltip'
import { parseSecretaryMarkdownStrict } from '@/lib/secretary/response-parser'

interface JobReportTabProps {
  libraryId: string
  fileId: string
  fileName?: string
  provider?: StorageProvider | null
  // Quelle der Metadaten steuern: 'merged' = cumulativeMeta + Frontmatter (Standard),
  // 'frontmatter' = ausschließlich Frontmatter aus Markdown anzeigen
  sourceMode?: 'merged' | 'frontmatter'
  // Darstellungsmodus: 'full' zeigt Kopf/Steps/Logs/Parameter; 'metaOnly' zeigt nur Metadaten/Kapitel/TOC
  viewMode?: 'full' | 'metaOnly'
  // Optional explizite Markdown-Datei-ID (Shadow‑Twin). Überschreibt auto-Erkennung.
  mdFileId?: string | null
  // Optionaler Callback zum Scroll-Sync in die Markdown-Vorschau
  onJumpTo?: (args: { page?: number | string; evidence?: string }) => void
  // NEU: Rohinhalt (Markdown). Wenn gesetzt und sourceMode='frontmatter', wird direkt dieser Text geparst (ohne Datei/JOB).
  rawContent?: string
  forcedTab?: 'markdown' | 'meta' | 'chapters' | 'process'
}

interface JobDto {
  jobId: string
  status: string
  operation: string
  worker: string
  job_type: string
  updatedAt: string
  createdAt: string
  correlation?: { source?: { itemId?: string; name?: string } }
  parameters?: Record<string, unknown>
  steps?: Array<{ name: string; status: string; startedAt?: string; endedAt?: string; error?: { message: string }; details?: { skipped?: boolean } }>
  ingestion?: { vectorsUpserted?: number; index?: string; upsertAt?: string }
  result?: { savedItemId?: string }
  logs?: Array<{ timestamp: string; phase?: string; message?: string; progress?: number }>
  cumulativeMeta?: Record<string, unknown>
}

export function JobReportTab({ libraryId, fileId, fileName, provider, sourceMode = 'merged', viewMode = 'full', mdFileId, onJumpTo, rawContent, forcedTab }: JobReportTabProps) {
  const [loading, setLoading] = useState(false)
  const [error, setError] = useState<string | null>(null)
  const [job, setJob] = useState<JobDto | null>(null)
  const [templateFields, setTemplateFields] = useState<string[] | null>(null)
  const [frontmatterMeta, setFrontmatterMeta] = useState<Record<string, unknown> | null>(null)
  const [section, setSection] = useState<'meta' | 'chapters'>('meta')
  const [parseErrors, setParseErrors] = useState<string[]>([])
  const [fullContent, setFullContent] = useState<string>('')

  const stripFrontmatter = (markdown: string): string => markdown.replace(/^---\r?\n([\s\S]*?)\r?\n---\r?\n?/, '')

  useEffect(() => {
    let cancelled = false
    async function run() {
      try {
        // Wenn wir Rohinhalt haben und nur Frontmatter zeigen, brauchen wir keine Job-Suche
        if (sourceMode === 'frontmatter' && typeof rawContent === 'string' && rawContent.length > 0) {
          setJob(null)
          setLoading(false)
          setError(null)
          return
        }
        setLoading(true)
        setError(null)
        UILogger.info('JobReportTab', 'Start Job-Suche', { libraryId, fileId })
        // 1) Versuche Job über result.savedItemId (Shadow‑Twin) zu finden
        const byResultUrl = new URL(`/api/external/jobs`, window.location.origin)
        byResultUrl.searchParams.set('byResultItemId', fileId)
        UILogger.debug('JobReportTab', 'Request byResultItemId', { url: byResultUrl.toString() })
        let res = await fetch(byResultUrl.toString(), { cache: 'no-store' })
        let data = await res.json()
        if (!res.ok) throw new Error(typeof data?.error === 'string' ? data.error : 'Job-Suche fehlgeschlagen')
        let j: JobDto | null = Array.isArray(data?.items) && data.items.length > 0 ? (data.items[0] as JobDto) : null
        UILogger.debug('JobReportTab', 'Result byResultItemId', { count: Array.isArray(data?.items) ? data.items.length : 0 })

        // 2) Fallback: über correlation.source.itemId (Originaldatei)
        if (!j) {
          const bySourceUrl = new URL(`/api/external/jobs`, window.location.origin)
          bySourceUrl.searchParams.set('bySourceItemId', fileId)
          bySourceUrl.searchParams.set('libraryId', libraryId)
          UILogger.debug('JobReportTab', 'Request bySourceItemId', { url: bySourceUrl.toString() })
          res = await fetch(bySourceUrl.toString(), { cache: 'no-store' })
          data = await res.json()
          if (!res.ok) throw new Error(typeof data?.error === 'string' ? data.error : 'Job-Suche (Quelle) fehlgeschlagen')
          j = Array.isArray(data?.items) && data.items.length > 0 ? (data.items[0] as JobDto) : null
          UILogger.debug('JobReportTab', 'Result bySourceItemId', { count: Array.isArray(data?.items) ? data.items.length : 0 })
        }

        // 3) Fallback: über correlation.source.name (Dateiname der Quelle)
        if (!j) {
          const byNameUrl = new URL(`/api/external/jobs`, window.location.origin)
          // Wenn wir den tatsächlichen Dateinamen kennen, verwende ihn.
          // Für Shadow‑Twins (z. B. name.de.md) versuche das Basis‑PDF (name.pdf).
          let candidate = (fileName && typeof fileName === 'string') ? fileName : (fileId.includes('/') ? (fileId.split('/').pop() as string) : fileId)
          const parts = candidate.split('.')
          if (parts.length >= 3) {
            const ext1 = parts[parts.length - 1].toLowerCase()
            const ext2 = parts[parts.length - 2].toLowerCase()
            if ((ext1 === 'md' || ext1 === 'mdx') && /^[a-z]{2}$/i.test(ext2)) {
              candidate = parts.slice(0, -2).join('.') + '.pdf'
            }
          }
          byNameUrl.searchParams.set('bySourceName', candidate)
          byNameUrl.searchParams.set('libraryId', libraryId)
          UILogger.debug('JobReportTab', 'Request bySourceName', { url: byNameUrl.toString(), nameOnly: candidate, originalFileName: fileName })
          res = await fetch(byNameUrl.toString(), { cache: 'no-store' })
          data = await res.json()
          if (!res.ok) throw new Error(typeof data?.error === 'string' ? data.error : 'Job-Suche (Name) fehlgeschlagen')
          j = Array.isArray(data?.items) && data.items.length > 0 ? (data.items[0] as JobDto) : null
          UILogger.debug('JobReportTab', 'Result bySourceName', { count: Array.isArray(data?.items) ? data.items.length : 0 })
        }

        if (!cancelled) setJob(j)
        if (j) UILogger.info('JobReportTab', 'Job gefunden', { jobId: j.jobId, status: j.status })
        else UILogger.warn('JobReportTab', 'Kein Job gefunden', { libraryId, fileId })
      } catch (e) {
        const msg = e instanceof Error ? e.message : 'Unbekannter Fehler'
        UILogger.error('JobReportTab', 'Job-Suche fehlgeschlagen', e)
        if (!cancelled) setError(msg)
      } finally {
        if (!cancelled) setLoading(false)
      }
    }
    void run()
    return () => { cancelled = true }
  }, [libraryId, fileId, fileName, sourceMode, rawContent])

  // Wenn Template benutzt wurde, lade dessen Inhalt aus /templates und extrahiere Frontmatter-Schlüssel
  useEffect(() => {
    async function loadTemplateFields() {
      try {
        setTemplateFields(null)
        const tpl = job?.cumulativeMeta && typeof (job.cumulativeMeta as unknown) === 'object'
          ? (job.cumulativeMeta as Record<string, unknown>)['template_used']
          : undefined
        const templateName = typeof tpl === 'string' ? tpl : undefined
        if (!templateName || !provider) return
        const rootItems = await provider.listItemsById('root')
        const templatesFolder = rootItems.find(it => it.type === 'folder' && typeof (it as { metadata?: { name?: string } }).metadata?.name === 'string' && ((it as { metadata: { name: string } }).metadata.name.toLowerCase() === 'templates'))
        if (!templatesFolder) return
        const tplItems = await provider.listItemsById(templatesFolder.id)
        const match = tplItems.find(it => it.type === 'file' && ((it as { metadata: { name: string } }).metadata.name.toLowerCase() === templateName.toLowerCase()))
        if (!match) return
        const bin = await provider.getBinary(match.id)
        const text = await bin.blob.text()
        // Extrahiere Frontmatter zwischen den ersten beiden --- und lese die Keys bis zu :
        const m = text.match(/^---[\s\S]*?---/)
        if (!m) return
        const fm = m[0]
        const keys: string[] = []
        for (const line of fm.split('\n')) {
          const t = line.trim()
          if (!t || t === '---') continue
          const idx = t.indexOf(':')
          if (idx > 0) {
            const k = t.slice(0, idx).trim()
            if (k) keys.push(k)
          }
        }
        setTemplateFields(Array.from(new Set(keys)))
      } catch (e) {
        UILogger.warn('JobReportTab', 'Template-Felder konnten nicht geladen werden', { error: e instanceof Error ? e.message : String(e) })
      }
    }
    void loadTemplateFields()
  }, [job, provider])

  // Gemeinsamer strikter Parser
  const strictParseFrontmatter = (fm: string) => parseSecretaryMarkdownStrict(fm)

  // Frontmatter aus der gespeicherten Markdown-Datei lesen (oder aus rawContent)
  useEffect(() => {
    async function loadFrontmatter() {
      try {
        setParseErrors([])
        // Wenn roher Inhalt übergeben wurde, direkt daraus lesen
        if (sourceMode === 'frontmatter' && typeof rawContent === 'string' && rawContent.length > 0) {
          const text = rawContent
          setFullContent(text)
          const { frontmatter, meta, errors } = parseSecretaryMarkdownStrict(text)
          UILogger.debug('JobReportTab', 'Frontmatter (raw): Block gefunden?', { found: !!frontmatter, length: frontmatter ? frontmatter.length : 0 })
          if (!frontmatter) { setFrontmatterMeta(null); return }
          setFrontmatterMeta(Object.keys(meta).length ? meta : null)
          setParseErrors(errors)
          return
        }

        if (!provider) return
        const mdId = (mdFileId || (job?.result?.savedItemId as string | undefined) || fileId)
        UILogger.info('JobReportTab', 'Frontmatter: Lade Datei', { mdId, sourceMode })
        if (!mdId) return
        const bin = await provider.getBinary(mdId)
        const text = await bin.blob.text()
        setFullContent(text)
        const { frontmatter, meta, errors } = parseSecretaryMarkdownStrict(text)
        UILogger.debug('JobReportTab', 'Frontmatter: Block gefunden?', { found: !!frontmatter, length: frontmatter ? frontmatter.length : 0 })
        if (!frontmatter) { setFrontmatterMeta(null); return }
        setFrontmatterMeta(Object.keys(meta).length ? meta : null)
        setParseErrors(errors)
      } catch {
        setFrontmatterMeta(null)
      }
    }
    void loadFrontmatter()
  }, [provider, fileId, mdFileId, job?.result?.savedItemId, sourceMode, rawContent])

  if (sourceMode !== 'frontmatter') {
    if (loading) return <div className="p-4 text-sm text-muted-foreground">Lade Job…</div>
    if (error) return <div className="p-4 text-sm text-destructive">{error}</div>
    if (!job) return <div className="p-4 text-sm text-muted-foreground">Kein Job zur Datei gefunden.</div>
  }

  return (
    <div className="p-4 space-y-3 text-sm">
      {viewMode === 'metaOnly' && (
        <Tabs defaultValue="markdown" value={forcedTab}
          onValueChange={() => { /* kontrolliert durch forcedTab, no-op */ }}
        >
          <TabsList className="grid grid-cols-4 w-full gap-1">
            <TabsTrigger value="markdown" className="px-2 py-1 text-xs">Markdown</TabsTrigger>
            <TabsTrigger value="meta" className="px-2 py-1 text-xs">Metadaten</TabsTrigger>
            <TabsTrigger value="chapters" className="px-2 py-1 text-xs">Kapitel</TabsTrigger>
            {(() => {
              const base: Record<string, unknown> = sourceMode === 'frontmatter' ? {} : ((job?.cumulativeMeta as unknown as Record<string, unknown>) || {})
              const cm = frontmatterMeta ? { ...base, ...frontmatterMeta } : base
              const processFields = new Set([
                'job_id','extract_status','template_status','ingest_status','summary_language',
                'source_file','source_file_id','source_file_size','source_file_type',
                'filename','path','pathHints','isScan'
              ])
              const hasProcess = Object.keys(cm).some(k => processFields.has(k))
              return hasProcess ? <TabsTrigger value="process" className="px-2 py-1 text-xs">Prozessinfo</TabsTrigger> : null
            })()}
          </TabsList>

          <TabsContent value="markdown" className="mt-3">
            <div className="border rounded-md">
              <MarkdownPreview content={stripFrontmatter(fullContent || '')} />
            </div>
          </TabsContent>

          <TabsContent value="meta" className="mt-3">
            {/* Hinweise zu Parserfehlern (strikt) */}
            {parseErrors.length > 0 && (
              <div className="text-xs text-destructive mb-2">
                {parseErrors.map((e, i) => (<div key={i}>Parserfehler: {e}</div>))}
              </div>
            )}
            {(() => {
              const base: Record<string, unknown> = sourceMode === 'frontmatter'
                ? {}
                : ((job?.cumulativeMeta as unknown as Record<string, unknown>) || {})
              const cm = frontmatterMeta ? { ...base, ...frontmatterMeta } : base
              // confidence/provenance können Objekt oder JSON-String sein → Fallback parse
              const confidence: Record<string, unknown> = (() => {
                const raw = cm['confidence']
                if (raw && typeof raw === 'object') return raw as Record<string, unknown>
                if (typeof raw === 'string') { try { return JSON.parse(raw) as Record<string, unknown> } catch { /* ignore */ } }
                return {}
              })()
              const provenance: Record<string, unknown> = (() => {
                const raw = cm['provenance']
                if (raw && typeof raw === 'object') return raw as Record<string, unknown>
                if (typeof raw === 'string') { try { return JSON.parse(raw) as Record<string, unknown> } catch { /* ignore */ } }
                return {}
              })()
              const hasAnyConfidence = Object.keys(confidence).length > 0
              const baseKeys = Array.isArray(templateFields) && templateFields.length > 0
                ? Array.from(new Set([...(templateFields as string[]), ...Object.keys(cm)]))
                : Object.keys(cm)
              const flatKeysAll = baseKeys.filter(k => k !== 'chapters' && k !== 'toc' && k !== 'confidence' && k !== 'provenance')
              const processFields = new Set([
                'job_id','extract_status','template_status','ingest_status','summary_language',
                'source_file','source_file_id','source_file_size','source_file_type',
                'filename','path','pathHints','isScan'
              ])
              const primaryKeys = flatKeysAll.filter(k => !processFields.has(k))
              const flatKeys = primaryKeys
              if (flatKeys.length === 0) return null
              return (
                <div>
                  <div className="font-medium mb-1">Metadaten (Template vs. Ergebnis)</div>
                  <div className="overflow-auto">
                    <table className="w-full text-xs">
                      <thead>
                        <tr className="text-left text-muted-foreground">
                          <th className="py-1 pr-2 sticky left-0 bg-background z-10">Feld</th>
                          <th className="py-1 pr-2">Wert</th>
                          {hasAnyConfidence ? <th className="py-1 pr-2 text-right sticky right-0 bg-background border-l">Q</th> : null}
                        </tr>
                      </thead>
                      <tbody>
                        {flatKeys.map((k) => {
                          const val = cm[k]
                          let valueStr = ''
                          if (Array.isArray(val)) valueStr = (val as Array<unknown>).map(v => typeof v === 'string' ? v : JSON.stringify(v)).join(', ')
                          else valueStr = val === null || val === undefined ? '' : typeof val === 'string' ? val : JSON.stringify(val)
                          const hasNonEmptyValue = (() => {
                            if (val === null || val === undefined) return false
                            if (typeof val === 'string') return val.trim().length > 0
                            if (Array.isArray(val)) return (val as Array<unknown>).length > 0
                            if (typeof val === 'object') return Object.keys(val as Record<string, unknown>).length > 0
                            return true
                          })()
                          const cRaw = (confidence as Record<string, unknown>)[k]
                          const cNum = typeof cRaw === 'number' ? cRaw : (typeof cRaw === 'string' && /^\d+(\.\d+)?$/.test(cRaw) ? Number(cRaw) : undefined)
                          const pRaw = (provenance as Record<string, unknown>)[k]
                          const pStr = typeof pRaw === 'string' ? pRaw : pRaw ? JSON.stringify(pRaw) : ''
                          const color = cNum === undefined ? 'text-muted-foreground' : (cNum >= 0.8 ? 'text-green-600' : cNum >= 0.7 ? 'text-yellow-600' : 'text-red-600')
                          return (
                            <tr key={k} className="border-t border-muted/40">
                              <td className="py-1 pr-2 align-top font-medium sticky left-0 bg-background z-10 whitespace-nowrap">{k}</td>
                              <td className="py-1 pr-2 align-top">
                                {valueStr ? (
                                  <TooltipProvider>
                                    <Tooltip>
                                      <TooltipTrigger asChild>
                                        <span className="inline-block max-w-[40vw] overflow-hidden text-ellipsis whitespace-nowrap align-top" title="">
                                          {valueStr}
                                        </span>
                                      </TooltipTrigger>
                                      <TooltipContent>
                                        <div className="max-w-[80vw] whitespace-pre-wrap break-words">{valueStr}</div>
                                      </TooltipContent>
                                    </Tooltip>
                                  </TooltipProvider>
                                ) : ''}
                              </td>
                              {hasAnyConfidence ? <td className="py-1 pr-2 align-top sticky right-0 bg-background border-l">
                                {(!hasNonEmptyValue || cNum === undefined) ? null : (
                                  <TooltipProvider>
                                    <Tooltip>
                                      <TooltipTrigger asChild>
                                        <span className={`inline-flex items-center justify-end w-full ${color}`} title={pStr || ''}>
                                          <span className="inline-block h-2 w-2 rounded-full bg-current" />
                                        </span>
                                      </TooltipTrigger>
                                      <TooltipContent>
                                        <div className="max-w-xs whitespace-pre-wrap break-words">
                                          <div className="font-medium">Confidence: {cNum.toFixed(2)}</div>
                                          {pStr ? <div className="mt-1 text-muted-foreground">Provenance: {pStr}</div> : null}
                                        </div>
                                      </TooltipContent>
                                    </Tooltip>
                                  </TooltipProvider>
                                )}
                              </td> : null}
                            </tr>
                          )
                        })}
                      </tbody>
                    </table>
                  </div>
                </div>
              )
            })()}
          </TabsContent>

          <TabsContent value="process" className="mt-3">
            {(() => {
              const base: Record<string, unknown> = sourceMode === 'frontmatter'
                ? {}
                : ((job?.cumulativeMeta as unknown as Record<string, unknown>) || {})
              const cm = frontmatterMeta ? { ...base, ...frontmatterMeta } : base
              const processOrder = [
                'job_id','extract_status','template_status','ingest_status','summary_language',
                'source_file','source_file_id','source_file_size','source_file_type',
                'filename','path','pathHints','isScan'
              ]
              const keys = processOrder.filter(k => k in cm)
              if (keys.length === 0) return <div className="text-xs text-muted-foreground">Keine Prozessinformationen vorhanden.</div>
              return (
                <div className="overflow-auto">
                  <table className="w-full text-xs">
                    <thead>
                      <tr className="text-left text-muted-foreground">
                        <th className="py-1 pr-2 sticky left-0 bg-background z-10">Feld</th>
                        <th className="py-1 pr-2">Wert</th>
                      </tr>
                    </thead>
                    <tbody>
                      {keys.map(k => {
                        const val = cm[k]
                        const valueStr = val === null || val === undefined ? '' : Array.isArray(val) ? (val as Array<unknown>).map(v => typeof v === 'string' ? v : JSON.stringify(v)).join(', ') : typeof val === 'string' ? val : JSON.stringify(val)
                        return (
                          <tr key={k} className="border-t border-muted/40">
                            <td className="py-1 pr-2 align-top font-medium sticky left-0 bg-background z-10 whitespace-nowrap">{k}</td>
                            <td className="py-1 pr-2 align-top">
                              {valueStr ? (
                                <TooltipProvider>
                                  <Tooltip>
                                    <TooltipTrigger asChild>
                                      <span className="inline-block max-w-[40vw] overflow-hidden text-ellipsis whitespace-nowrap align-top" title="">{valueStr}</span>
                                    </TooltipTrigger>
                                    <TooltipContent>
                                      <div className="max-w-[80vw] whitespace-pre-wrap break-words">{valueStr}</div>
                                    </TooltipContent>
                                  </Tooltip>
                                </TooltipProvider>
                              ) : ''}
                            </td>
                          </tr>
                        )
                      })}
                    </tbody>
                  </table>
                </div>
              )
            })()}
          </TabsContent>

          <TabsContent value="chapters" className="mt-3">
            {(() => {
              const chapters: Array<Record<string, unknown>> = sourceMode === 'frontmatter'
                ? (Array.isArray(frontmatterMeta?.chapters) ? (frontmatterMeta?.chapters as Array<Record<string, unknown>>) : [])
                : ((job?.cumulativeMeta as unknown as { chapters?: Array<Record<string, unknown>> })?.chapters || [])
              if (!Array.isArray(chapters) || chapters.length === 0) return null
              const pad = (lvl: number | undefined): number => {
                if (typeof lvl !== 'number') return 0
                const clamped = Math.max(0, Math.min(3, lvl))
                return (clamped - 1) * 16
              }
              const counters = [0, 0, 0]
              return (
                <div className="space-y-1">
                  <div>
                    {chapters.map((c, i) => {
                      const level = typeof c.level === 'number' ? c.level : 1
                      const lvl = Math.max(1, Math.min(3, level))
                      counters[lvl - 1] += 1
                      for (let j = lvl; j < counters.length; j++) counters[j] = 0
                      const numLabel = counters.slice(0, lvl).filter(n => n > 0).join('.')
                      const title = typeof c.title === 'string' ? c.title : ''
                      const startPage = typeof c.startPage === 'number' ? c.startPage : ''
                      const summaryVal = typeof c.summary === 'string' ? c.summary : ''
                      const summary = summaryVal.length > 1000 ? `${summaryVal.slice(0, 1000)}…` : summaryVal
                      const keywords = Array.isArray(c.keywords) ? (c.keywords as Array<unknown>).filter(v => typeof v === 'string') as string[] : []
                      const ev = typeof c.startEvidence === 'string' ? c.startEvidence : ''
                      return (
                        <details key={`${title}-${i}`} className="group border-b py-1" open={false}>
                          <summary className="list-none cursor-pointer">
                            <div className="flex items-start justify-between gap-3">
                              <div className="flex-1 min-w-0" style={{ paddingLeft: `${pad(lvl)}px` }}>
                                <div className="flex items-baseline gap-2">
                                  <span className="text-xs text-muted-foreground tabular-nums">{numLabel}</span>
                                  <span className="font-medium truncate">{title}</span>
                                </div>
                              </div>
                              <div className="text-xs tabular-nums text-muted-foreground whitespace-nowrap">
                                {String(startPage)}
                              </div>
                            </div>
                          </summary>
                          <div className="mt-1 pr-1 text-xs space-y-1" style={{ paddingLeft: `${pad(lvl) + 28}px` }}>
                            {summary && (
                              <div className="whitespace-pre-wrap break-words">
                                {summary}
                              </div>
                            )}
                            {Array.isArray(keywords) && keywords.length > 0 && (
                              <div className="flex flex-wrap gap-1">
                                {keywords.map(k => (
                                  <span key={k} className="inline-flex items-center rounded px-1.5 py-0.5 bg-muted">{k}</span>
                                ))}
                              </div>
                            )}
                          </div>
                        </details>
                      )
                    })}
                  </div>
                </div>
              )
            })()}
          </TabsContent>
        </Tabs>
      )}

      {viewMode === 'full' && job && (
        <div className="flex items-center justify-between">
          <div>
            <div className="font-medium">Job {job.jobId}</div>
            <div className="text-xs text-muted-foreground">{job.job_type} · {job.operation} · {new Date(job.updatedAt).toLocaleString()}</div>
          </div>
          <div className="inline-flex items-center rounded px-2 py-0.5 bg-muted text-xs">{job.status}</div>
        </div>
      )}

      {/* Hinweise zu Parserfehlern (strikt) */}
      {viewMode !== 'metaOnly' && parseErrors.length > 0 && (
        <div className="text-xs text-destructive">
          {parseErrors.map((e, i) => (<div key={i}>Parserfehler: {e}</div>))}
        </div>
      )}

      {/* Template Hinweis (im Frontmatter-only-Modus ausgeblendet) */}
      {sourceMode !== 'frontmatter' && job && typeof job.cumulativeMeta?.template_used === 'string' && (
        <div className="text-xs text-muted-foreground">Template: {String(job.cumulativeMeta.template_used)}</div>
      )}

      {/* Schritte mit Ampel-Logik */}
      {viewMode === 'full' && job && Array.isArray(job.steps) && job.steps.length > 0 && (
        <div>
          <div className="font-medium mb-1">Schritte</div>
          <div className="flex flex-wrap gap-2 text-xs">
            {job.steps.map((s) => {
              // Geplante Phasen ermitteln (neue Flags bevorzugt, sonst phases)
              const p = (job.parameters || {}) as Record<string, unknown>
              const hasNewFlags = typeof p['doExtractPDF'] === 'boolean' || typeof p['doExtractMetadata'] === 'boolean' || typeof p['doIngestRAG'] === 'boolean'
              const phases = hasNewFlags
                ? {
                    extract: p['doExtractPDF'] === true,
                    template: p['doExtractMetadata'] === true,
                    ingest: p['doIngestRAG'] === true,
                  }
                : ((p['phases'] as { extract?: boolean; template?: boolean; ingest?: boolean }) || {})

              const planned = (() => {
                const n = s.name
                if (n === 'extract_pdf') return phases.extract === true
                if (n === 'transform_template' || n === 'store_shadow_twin') return phases.template === true
                if (n === 'ingest_rag') return phases.ingest === true
                return false
              })()

              // Ampel-Status ableiten
              const skipped = !!(s as { details?: { skipped?: boolean } }).details?.skipped
              let icon = '○'
              let cls = 'text-muted-foreground'
              if (s.status === 'failed') { icon = '✕'; cls = 'text-red-600' }
              else if (s.status === 'running') { icon = '◐'; cls = 'text-yellow-600' }
              else if (s.status === 'completed') { icon = skipped ? '○' : '✓'; cls = skipped ? 'text-gray-400' : 'text-green-600' }
              else if (s.status === 'pending') { icon = planned ? '•' : '○'; cls = planned ? 'text-yellow-600' : 'text-muted-foreground' }

              const time = s.endedAt ? new Date(s.endedAt).toLocaleTimeString() : s.startedAt ? new Date(s.startedAt).toLocaleTimeString() : ''
              return (
                <div key={s.name} className={`inline-flex items-center gap-1 px-2 py-1 rounded border ${cls}`}>
                  <span>{icon}</span>
                  <span className="font-medium">{s.name}</span>
                  {time ? <span className="opacity-70">{time}</span> : null}
                </div>
              )
            })}
          </div>
        </div>
      )}

      {/* Metadaten (flach) – je nach sourceMode: nur Frontmatter oder Merge (nur außerhalb metaOnly-View) */}
      {viewMode !== 'metaOnly' && section === 'meta' && (() => {
        const base: Record<string, unknown> = sourceMode === 'frontmatter'
          ? {}
          : ((job?.cumulativeMeta as unknown as Record<string, unknown>) || {})
        const cm = frontmatterMeta ? { ...base, ...frontmatterMeta } : base
        const confidence: Record<string, unknown> = (() => {
          const raw = cm['confidence']
          if (raw && typeof raw === 'object') return raw as Record<string, unknown>
          if (typeof raw === 'string') { try { return JSON.parse(raw) as Record<string, unknown> } catch { /* ignore */ } }
          return {}
        })()
        const provenance: Record<string, unknown> = (() => {
          const raw = cm['provenance']
          if (raw && typeof raw === 'object') return raw as Record<string, unknown>
          if (typeof raw === 'string') { try { return JSON.parse(raw) as Record<string, unknown> } catch { /* ignore */ } }
          return {}
        })()
        const hasAnyConfidence = Object.keys(confidence).length > 0
        const baseKeys = Array.isArray(templateFields) && templateFields.length > 0
          ? Array.from(new Set([...(templateFields as string[]), ...Object.keys(cm)]))
          : Object.keys(cm)
        const flatKeys = baseKeys.filter(k => k !== 'chapters' && k !== 'toc' && k !== 'confidence' && k !== 'provenance')
        if (flatKeys.length === 0) return null
        return (
        <div>
          <div className="font-medium mb-1">Metadaten (Template vs. Ergebnis)</div>
          <div className="overflow-auto">
            <table className="w-full text-xs">
              <thead>
                <tr className="text-left text-muted-foreground">
                  <th className="py-1 pr-2 sticky left-0 bg-background z-10">Feld</th>
                  <th className="py-1 pr-2">Wert</th>
                  {hasAnyConfidence ? <th className="py-1 pr-2 text-right sticky right-0 bg-background border-l">Q</th> : null}
                </tr>
              </thead>
              <tbody>
                {flatKeys.map((k) => {
                  const val = cm[k]
                  let valueStr = ''
                  if (Array.isArray(val)) valueStr = (val as Array<unknown>).map(v => typeof v === 'string' ? v : JSON.stringify(v)).join(', ')
                  else valueStr = val === null || val === undefined ? '' : typeof val === 'string' ? val : JSON.stringify(val)
                  const hasNonEmptyValue = (() => {
                    if (val === null || val === undefined) return false
                    if (typeof val === 'string') return val.trim().length > 0
                    if (Array.isArray(val)) return (val as Array<unknown>).length > 0
                    if (typeof val === 'object') return Object.keys(val as Record<string, unknown>).length > 0
                    return true
                  })()
                  const cRaw = (confidence as Record<string, unknown>)[k]
                  const cNum = typeof cRaw === 'number' ? cRaw : (typeof cRaw === 'string' && /^\d+(\.\d+)?$/.test(cRaw) ? Number(cRaw) : undefined)
                  const pRaw = (provenance as Record<string, unknown>)[k]
                  const pStr = typeof pRaw === 'string' ? pRaw : pRaw ? JSON.stringify(pRaw) : ''
                  const color = cNum === undefined ? 'text-muted-foreground' : (cNum >= 0.8 ? 'text-green-600' : cNum >= 0.7 ? 'text-yellow-600' : 'text-red-600')
                  return (
                    <tr key={k} className="border-t border-muted/40">
                      <td className="py-1 pr-2 align-top font-medium sticky left-0 bg-background z-10 whitespace-nowrap">{k}</td>
                      <td className="py-1 pr-2 align-top">
                        {valueStr ? (
                          <TooltipProvider>
                            <Tooltip>
                              <TooltipTrigger asChild>
                                <span className="inline-block max-w-[40vw] overflow-hidden text-ellipsis whitespace-nowrap align-top" title="">
                                  {valueStr}
                                </span>
                              </TooltipTrigger>
                              <TooltipContent>
                                <div className="max-w-[80vw] whitespace-pre-wrap break-words">{valueStr}</div>
                              </TooltipContent>
                            </Tooltip>
                          </TooltipProvider>
                        ) : ''}
                      </td>
                      {hasAnyConfidence ? <td className="py-1 pr-2 align-top sticky right-0 bg-background border-l">
                        {(!hasNonEmptyValue || cNum === undefined) ? null : (
                          <TooltipProvider>
                            <Tooltip>
                              <TooltipTrigger asChild>
                                <span className={`inline-flex items-center justify-end w-full ${color}`} title={pStr || ''}>
                                  <span className="inline-block h-2 w-2 rounded-full bg-current" />
                                </span>
                              </TooltipTrigger>
                              <TooltipContent>
                                <div className="max-w-xs whitespace-pre-wrap break-words">
                                  <div className="font-medium">Confidence: {cNum.toFixed(2)}</div>
                                  {pStr ? <div className="mt-1 text-muted-foreground">Provenance: {pStr}</div> : null}
                                </div>
                              </TooltipContent>
                            </Tooltip>
                          </TooltipProvider>
                        )}
                      </td> : null}
                    </tr>
                  )
                })}
              </tbody>
            </table>
          </div>
        </div>
        )
      })()}

      {/* Kapitel (hierarchisch, TOC-Ansicht) – nur außerhalb metaOnly-View */}
      {viewMode !== 'metaOnly' && section === 'chapters' && (() => {
        const chapters: Array<Record<string, unknown>> = sourceMode === 'frontmatter'
          ? (Array.isArray(frontmatterMeta?.chapters) ? (frontmatterMeta?.chapters as Array<Record<string, unknown>>) : [])
          : ((job?.cumulativeMeta as unknown as { chapters?: Array<Record<string, unknown>> })?.chapters || [])
        if (!Array.isArray(chapters) || chapters.length === 0) return null

        const pad = (lvl: number | undefined): number => {
          if (typeof lvl !== 'number') return 0
          const clamped = Math.max(0, Math.min(3, lvl))
          return (clamped - 1) * 16 // px
        }

        // Hierarchische Nummerierung 1., 1.1, 1.1.1 basierend auf level
        const counters = [0, 0, 0]
        return (
        <div className="space-y-1">
          <div className="font-medium mb-1">Kapitel</div>
          <div>
            {chapters.map((c, i) => {
              const level = typeof c.level === 'number' ? c.level : 1
              const lvl = Math.max(1, Math.min(3, level))
              // Zähler aktualisieren
              counters[lvl - 1] += 1
              for (let j = lvl; j < counters.length; j++) counters[j] = 0
              const numLabel = counters.slice(0, lvl).filter(n => n > 0).join('.')
              const title = typeof c.title === 'string' ? c.title : ''
              const startPage = typeof c.startPage === 'number' ? c.startPage : ''
              
              const summaryVal = typeof c.summary === 'string' ? c.summary : ''
              const summary = summaryVal.length > 1000 ? `${summaryVal.slice(0, 1000)}…` : summaryVal
              const keywords = Array.isArray(c.keywords) ? (c.keywords as Array<unknown>).filter(v => typeof v === 'string') as string[] : []
              const ev = typeof c.startEvidence === 'string' ? c.startEvidence : ''
              return (
                <details key={`${title}-${i}`} className="group border-b py-1" open={false} onToggle={(e) => {
                  const open = (e.currentTarget as HTMLDetailsElement).open
                  if (open) {
                    if (startPage !== '') onJumpTo?.({ page: startPage as number | string })
                    else if (ev) onJumpTo?.({ evidence: ev })
                  }
                }}>
                  <summary className="list-none cursor-pointer">
                    <div className="flex items-start justify-between gap-3">
                      <div className="flex-1 min-w-0" style={{ paddingLeft: `${pad(lvl)}px` }}>
                        <div className="flex items-baseline gap-2">
                          <span className="text-xs text-muted-foreground tabular-nums">{numLabel}</span>
                          <span className="font-medium truncate">{title}</span>
                        </div>
                      </div>
                      <div className="text-xs tabular-nums text-muted-foreground whitespace-nowrap">
                        {String(startPage)}
                      </div>
                    </div>
                  </summary>
                  <div className="mt-1 pr-1 text-xs space-y-1" style={{ paddingLeft: `${pad(lvl) + 28}px` }}>
                    {summary && (
                      <div className="whitespace-pre-wrap break-words">
                        {summary}
                      </div>
                    )}
                    {Array.isArray(keywords) && keywords.length > 0 && (
                      <div className="flex flex-wrap gap-1">
                        {keywords.map(k => (
                          <span key={k} className="inline-flex items-center rounded px-1.5 py-0.5 bg-muted">{k}</span>
                        ))}
                      </div>
                    )}
                  </div>
                </details>
              )
            })}
          </div>
        </div>
        )
      })()}

      {/* Inhaltsverzeichnis */}
      {section === 'chapters' && (() => {
        const toc: Array<Record<string, unknown>> = sourceMode === 'frontmatter'
          ? (Array.isArray(frontmatterMeta?.toc) ? (frontmatterMeta?.toc as Array<Record<string, unknown>>) : [])
          : ((job?.cumulativeMeta as unknown as { toc?: Array<Record<string, unknown>> }).toc || [])
        if (!Array.isArray(toc) || toc.length === 0) return null
        return (
        <div>
          <div className="font-medium mb-1">Inhaltsverzeichnis</div>
          <div className="overflow-visible">
            <table className="w-full text-xs">
              <thead>
                <tr className="text-left text-muted-foreground">
                  <th className="py-1 pr-2">Titel</th>
                  <th className="py-1 pr-2">Seite</th>
                  <th className="py-1 pr-2">L</th>
                </tr>
              </thead>
              <tbody>
                {toc.map((t, i) => {
                  const title = typeof t.title === 'string' ? t.title : ''
                  const page = typeof t.page === 'number' ? t.page : ''
                  const level = typeof t.level === 'number' ? t.level : ''
                  return (
                    <tr key={`${title}-${i}`} className="border-t border-muted/40">
                      <td className="py-1 pr-2 align-top whitespace-pre-wrap break-words">{title}</td>
                      <td className="py-1 pr-2 align-top">{page}</td>
                      <td className="py-1 pr-2 align-top">{level}</td>
                    </tr>
                  )
                })}
              </tbody>
            </table>
          </div>
        </div>
        )
      })()}

      {viewMode === 'full' && job && job.ingestion && (
        <div>
          <div className="font-medium mb-1">Ingestion</div>
          <div className="text-xs text-muted-foreground">{job.ingestion.index || '—'} · Vektoren: {job.ingestion.vectorsUpserted ?? '—'} · {job.ingestion.upsertAt ? new Date(job.ingestion.upsertAt).toLocaleString() : '—'}</div>
        </div>
      )}

      {viewMode === 'full' && job && Array.isArray(job.logs) && job.logs.length > 0 && (
        <div>
          <div className="font-medium mb-1">Logs (neueste zuerst)</div>
          <ul className="space-y-0.5 max-h-48 overflow-auto">
            {[...job.logs].reverse().slice(0, 30).map((l, i) => (
              <li key={i} className="text-xs">
                {new Date(l.timestamp).toLocaleTimeString()} · {l.phase || '—'} · {typeof l.progress === 'number' ? `${l.progress}% · ` : ''}{l.message || ''}
              </li>
            ))}
          </ul>
        </div>
      )}

      {/* Parameter am Ende */}
      {viewMode === 'full' && job && job.parameters && (
        <div>
          <div className="font-medium mb-1">Parameter</div>
          <pre className="bg-muted/40 rounded p-2 max-h-32 overflow-auto whitespace-pre-wrap break-words">{JSON.stringify(job.parameters, null, 2)}</pre>
        </div>
      )}
    </div>
  )
}



```

Ich habe die Kopplung der Phasen zu den Tabs im rechten Preview hergestellt:

- PdfPhasesView
  - Übergibt nun je Phase einen erzwungenen Tab an den rechten Viewer:
    - Phase 1 (Extraktion) → forcedTab="markdown"
    - Phase 2 (Metadaten) → forcedTab="meta"
    - Phase 3 (Ingestion) → forcedTab="process"
- JobReportTab
  - Akzeptiert neues Prop `forcedTab` und steuert damit die Tabs im metaOnly‑Modus.
  - Tabs bleiben „controlled“, Klicks auf die Tab-Köpfe werden ignoriert, wenn `forcedTab` gesetzt ist, sodass die Phase maßgeblich ist.

Zusätzlich:
- Kompakt/Normal-FileList wurde vereinheitlicht; Fonts und Einrückung sind jetzt gleich, Ordner linksbündig, Tooltips zeigen volle Namen.
- Aktive Datei ist in beiden Listenmodi deutlich markiert.

Bitte testen:
- Phase oben wechseln: Rechts springt der Viewer auf Markdown/Metadaten/Prozessinfo.
- Kompakt/Normal: Darstellung und Hervorhebung konsistent.

---

**User**

Okay, dieses Umschalten der Phasen funktioniert. Aber es sollte in diesem Viewer nur ein Tab vorselektieren und nicht erzwingen. Das heißt, ich kann schon im Viewer zwischen Markdown, Metadaten, Kapitel und Prozessinfo wechseln jederzeit. Nur wenn ich oben eine Phase anklicke, springt er dann halt auf die entsprechende Ansicht.

---

**Cursor**

```typescriptreact
"use client";

import { useEffect, useState } from 'react'
import { UILogger } from '@/lib/debug/logger'
import type { StorageProvider } from '@/lib/storage/types'
import { MarkdownPreview } from '@/components/library/markdown-preview'
import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs'
import { TooltipProvider, Tooltip, TooltipTrigger, TooltipContent } from '@/components/ui/tooltip'
import { parseSecretaryMarkdownStrict } from '@/lib/secretary/response-parser'

interface JobReportTabProps {
  libraryId: string
  fileId: string
  fileName?: string
  provider?: StorageProvider | null
  // Quelle der Metadaten steuern: 'merged' = cumulativeMeta + Frontmatter (Standard),
  // 'frontmatter' = ausschließlich Frontmatter aus Markdown anzeigen
  sourceMode?: 'merged' | 'frontmatter'
  // Darstellungsmodus: 'full' zeigt Kopf/Steps/Logs/Parameter; 'metaOnly' zeigt nur Metadaten/Kapitel/TOC
  viewMode?: 'full' | 'metaOnly'
  // Optional explizite Markdown-Datei-ID (Shadow‑Twin). Überschreibt auto-Erkennung.
  mdFileId?: string | null
  // Optionaler Callback zum Scroll-Sync in die Markdown-Vorschau
  onJumpTo?: (args: { page?: number | string; evidence?: string }) => void
  // NEU: Rohinhalt (Markdown). Wenn gesetzt und sourceMode='frontmatter', wird direkt dieser Text geparst (ohne Datei/JOB).
  rawContent?: string
  forcedTab?: 'markdown' | 'meta' | 'chapters' | 'process'
}

interface JobDto {
  jobId: string
  status: string
  operation: string
  worker: string
  job_type: string
  updatedAt: string
  createdAt: string
  correlation?: { source?: { itemId?: string; name?: string } }
  parameters?: Record<string, unknown>
  steps?: Array<{ name: string; status: string; startedAt?: string; endedAt?: string; error?: { message: string }; details?: { skipped?: boolean } }>
  ingestion?: { vectorsUpserted?: number; index?: string; upsertAt?: string }
  result?: { savedItemId?: string }
  logs?: Array<{ timestamp: string; phase?: string; message?: string; progress?: number }>
  cumulativeMeta?: Record<string, unknown>
}

export function JobReportTab({ libraryId, fileId, fileName, provider, sourceMode = 'merged', viewMode = 'full', mdFileId, onJumpTo, rawContent, forcedTab }: JobReportTabProps) {
  const [loading, setLoading] = useState(false)
  const [error, setError] = useState<string | null>(null)
  const [job, setJob] = useState<JobDto | null>(null)
  const [templateFields, setTemplateFields] = useState<string[] | null>(null)
  const [frontmatterMeta, setFrontmatterMeta] = useState<Record<string, unknown> | null>(null)
  const [section, setSection] = useState<'meta' | 'chapters'>('meta')
  const [parseErrors, setParseErrors] = useState<string[]>([])
  const [fullContent, setFullContent] = useState<string>('')
  const [activeTab, setActiveTab] = useState<'markdown' | 'meta' | 'chapters' | 'process'>(forcedTab || 'markdown')

  useEffect(() => {
    if (forcedTab) setActiveTab(forcedTab)
  }, [forcedTab])

  const stripFrontmatter = (markdown: string): string => markdown.replace(/^---\r?\n([\s\S]*?)\r?\n---\r?\n?/, '')

  useEffect(() => {
    let cancelled = false
    async function run() {
      try {
        // Wenn wir Rohinhalt haben und nur Frontmatter zeigen, brauchen wir keine Job-Suche
        if (sourceMode === 'frontmatter' && typeof rawContent === 'string' && rawContent.length > 0) {
          setJob(null)
          setLoading(false)
          setError(null)
          return
        }
        setLoading(true)
        setError(null)
        UILogger.info('JobReportTab', 'Start Job-Suche', { libraryId, fileId })
        // 1) Versuche Job über result.savedItemId (Shadow‑Twin) zu finden
        const byResultUrl = new URL(`/api/external/jobs`, window.location.origin)
        byResultUrl.searchParams.set('byResultItemId', fileId)
        UILogger.debug('JobReportTab', 'Request byResultItemId', { url: byResultUrl.toString() })
        let res = await fetch(byResultUrl.toString(), { cache: 'no-store' })
        let data = await res.json()
        if (!res.ok) throw new Error(typeof data?.error === 'string' ? data.error : 'Job-Suche fehlgeschlagen')
        let j: JobDto | null = Array.isArray(data?.items) && data.items.length > 0 ? (data.items[0] as JobDto) : null
        UILogger.debug('JobReportTab', 'Result byResultItemId', { count: Array.isArray(data?.items) ? data.items.length : 0 })

        // 2) Fallback: über correlation.source.itemId (Originaldatei)
        if (!j) {
          const bySourceUrl = new URL(`/api/external/jobs`, window.location.origin)
          bySourceUrl.searchParams.set('bySourceItemId', fileId)
          bySourceUrl.searchParams.set('libraryId', libraryId)
          UILogger.debug('JobReportTab', 'Request bySourceItemId', { url: bySourceUrl.toString() })
          res = await fetch(bySourceUrl.toString(), { cache: 'no-store' })
          data = await res.json()
          if (!res.ok) throw new Error(typeof data?.error === 'string' ? data.error : 'Job-Suche (Quelle) fehlgeschlagen')
          j = Array.isArray(data?.items) && data.items.length > 0 ? (data.items[0] as JobDto) : null
          UILogger.debug('JobReportTab', 'Result bySourceItemId', { count: Array.isArray(data?.items) ? data.items.length : 0 })
        }

        // 3) Fallback: über correlation.source.name (Dateiname der Quelle)
        if (!j) {
          const byNameUrl = new URL(`/api/external/jobs`, window.location.origin)
          // Wenn wir den tatsächlichen Dateinamen kennen, verwende ihn.
          // Für Shadow‑Twins (z. B. name.de.md) versuche das Basis‑PDF (name.pdf).
          let candidate = (fileName && typeof fileName === 'string') ? fileName : (fileId.includes('/') ? (fileId.split('/').pop() as string) : fileId)
          const parts = candidate.split('.')
          if (parts.length >= 3) {
            const ext1 = parts[parts.length - 1].toLowerCase()
            const ext2 = parts[parts.length - 2].toLowerCase()
            if ((ext1 === 'md' || ext1 === 'mdx') && /^[a-z]{2}$/i.test(ext2)) {
              candidate = parts.slice(0, -2).join('.') + '.pdf'
            }
          }
          byNameUrl.searchParams.set('bySourceName', candidate)
          byNameUrl.searchParams.set('libraryId', libraryId)
          UILogger.debug('JobReportTab', 'Request bySourceName', { url: byNameUrl.toString(), nameOnly: candidate, originalFileName: fileName })
          res = await fetch(byNameUrl.toString(), { cache: 'no-store' })
          data = await res.json()
          if (!res.ok) throw new Error(typeof data?.error === 'string' ? data.error : 'Job-Suche (Name) fehlgeschlagen')
          j = Array.isArray(data?.items) && data.items.length > 0 ? (data.items[0] as JobDto) : null
          UILogger.debug('JobReportTab', 'Result bySourceName', { count: Array.isArray(data?.items) ? data.items.length : 0 })
        }

        if (!cancelled) setJob(j)
        if (j) UILogger.info('JobReportTab', 'Job gefunden', { jobId: j.jobId, status: j.status })
        else UILogger.warn('JobReportTab', 'Kein Job gefunden', { libraryId, fileId })
      } catch (e) {
        const msg = e instanceof Error ? e.message : 'Unbekannter Fehler'
        UILogger.error('JobReportTab', 'Job-Suche fehlgeschlagen', e)
        if (!cancelled) setError(msg)
      } finally {
        if (!cancelled) setLoading(false)
      }
    }
    void run()
    return () => { cancelled = true }
  }, [libraryId, fileId, fileName, sourceMode, rawContent])

  // Wenn Template benutzt wurde, lade dessen Inhalt aus /templates und extrahiere Frontmatter-Schlüssel
  useEffect(() => {
    async function loadTemplateFields() {
      try {
        setTemplateFields(null)
        const tpl = job?.cumulativeMeta && typeof (job.cumulativeMeta as unknown) === 'object'
          ? (job.cumulativeMeta as Record<string, unknown>)['template_used']
          : undefined
        const templateName = typeof tpl === 'string' ? tpl : undefined
        if (!templateName || !provider) return
        const rootItems = await provider.listItemsById('root')
        const templatesFolder = rootItems.find(it => it.type === 'folder' && typeof (it as { metadata?: { name?: string } }).metadata?.name === 'string' && ((it as { metadata: { name: string } }).metadata.name.toLowerCase() === 'templates'))
        if (!templatesFolder) return
        const tplItems = await provider.listItemsById(templatesFolder.id)
        const match = tplItems.find(it => it.type === 'file' && ((it as { metadata: { name: string } }).metadata.name.toLowerCase() === templateName.toLowerCase()))
        if (!match) return
        const bin = await provider.getBinary(match.id)
        const text = await bin.blob.text()
        // Extrahiere Frontmatter zwischen den ersten beiden --- und lese die Keys bis zu :
        const m = text.match(/^---[\s\S]*?---/)
        if (!m) return
        const fm = m[0]
        const keys: string[] = []
        for (const line of fm.split('\n')) {
          const t = line.trim()
          if (!t || t === '---') continue
          const idx = t.indexOf(':')
          if (idx > 0) {
            const k = t.slice(0, idx).trim()
            if (k) keys.push(k)
          }
        }
        setTemplateFields(Array.from(new Set(keys)))
      } catch (e) {
        UILogger.warn('JobReportTab', 'Template-Felder konnten nicht geladen werden', { error: e instanceof Error ? e.message : String(e) })
      }
    }
    void loadTemplateFields()
  }, [job, provider])

  // Gemeinsamer strikter Parser
  const strictParseFrontmatter = (fm: string) => parseSecretaryMarkdownStrict(fm)

  // Frontmatter aus der gespeicherten Markdown-Datei lesen (oder aus rawContent)
  useEffect(() => {
    async function loadFrontmatter() {
      try {
        setParseErrors([])
        // Wenn roher Inhalt übergeben wurde, direkt daraus lesen
        if (sourceMode === 'frontmatter' && typeof rawContent === 'string' && rawContent.length > 0) {
          const text = rawContent
          setFullContent(text)
          const { frontmatter, meta, errors } = parseSecretaryMarkdownStrict(text)
          UILogger.debug('JobReportTab', 'Frontmatter (raw): Block gefunden?', { found: !!frontmatter, length: frontmatter ? frontmatter.length : 0 })
          if (!frontmatter) { setFrontmatterMeta(null); return }
          setFrontmatterMeta(Object.keys(meta).length ? meta : null)
          setParseErrors(errors)
          return
        }

        if (!provider) return
        const mdId = (mdFileId || (job?.result?.savedItemId as string | undefined) || fileId)
        UILogger.info('JobReportTab', 'Frontmatter: Lade Datei', { mdId, sourceMode })
        if (!mdId) return
        const bin = await provider.getBinary(mdId)
        const text = await bin.blob.text()
        setFullContent(text)
        const { frontmatter, meta, errors } = parseSecretaryMarkdownStrict(text)
        UILogger.debug('JobReportTab', 'Frontmatter: Block gefunden?', { found: !!frontmatter, length: frontmatter ? frontmatter.length : 0 })
        if (!frontmatter) { setFrontmatterMeta(null); return }
        setFrontmatterMeta(Object.keys(meta).length ? meta : null)
        setParseErrors(errors)
      } catch {
        setFrontmatterMeta(null)
      }
    }
    void loadFrontmatter()
  }, [provider, fileId, mdFileId, job?.result?.savedItemId, sourceMode, rawContent])

  if (sourceMode !== 'frontmatter') {
    if (loading) return <div className="p-4 text-sm text-muted-foreground">Lade Job…</div>
    if (error) return <div className="p-4 text-sm text-destructive">{error}</div>
    if (!job) return <div className="p-4 text-sm text-muted-foreground">Kein Job zur Datei gefunden.</div>
  }

  return (
    <div className="p-4 space-y-3 text-sm">
      {viewMode === 'metaOnly' && (
        <Tabs value={activeTab} onValueChange={(v) => setActiveTab(v as typeof activeTab)}>
          <TabsList className="grid grid-cols-4 w-full gap-1">
            <TabsTrigger value="markdown" className="px-2 py-1 text-xs">Markdown</TabsTrigger>
            <TabsTrigger value="meta" className="px-2 py-1 text-xs">Metadaten</TabsTrigger>
            <TabsTrigger value="chapters" className="px-2 py-1 text-xs">Kapitel</TabsTrigger>
            {(() => {
              const base: Record<string, unknown> = sourceMode === 'frontmatter' ? {} : ((job?.cumulativeMeta as unknown as Record<string, unknown>) || {})
              const cm = frontmatterMeta ? { ...base, ...frontmatterMeta } : base
              const processFields = new Set([
                'job_id','extract_status','template_status','ingest_status','summary_language',
                'source_file','source_file_id','source_file_size','source_file_type',
                'filename','path','pathHints','isScan'
              ])
              const hasProcess = Object.keys(cm).some(k => processFields.has(k))
              return hasProcess ? <TabsTrigger value="process" className="px-2 py-1 text-xs">Prozessinfo</TabsTrigger> : null
            })()}
          </TabsList>

          <TabsContent value="markdown" className="mt-3">
            <div className="border rounded-md">
              <MarkdownPreview content={stripFrontmatter(fullContent || '')} />
            </div>
          </TabsContent>

          <TabsContent value="meta" className="mt-3">
            {/* Hinweise zu Parserfehlern (strikt) */}
            {parseErrors.length > 0 && (
              <div className="text-xs text-destructive mb-2">
                {parseErrors.map((e, i) => (<div key={i}>Parserfehler: {e}</div>))}
              </div>
            )}
            {(() => {
              const base: Record<string, unknown> = sourceMode === 'frontmatter'
                ? {}
                : ((job?.cumulativeMeta as unknown as Record<string, unknown>) || {})
              const cm = frontmatterMeta ? { ...base, ...frontmatterMeta } : base
              // confidence/provenance können Objekt oder JSON-String sein → Fallback parse
              const confidence: Record<string, unknown> = (() => {
                const raw = cm['confidence']
                if (raw && typeof raw === 'object') return raw as Record<string, unknown>
                if (typeof raw === 'string') { try { return JSON.parse(raw) as Record<string, unknown> } catch { /* ignore */ } }
                return {}
              })()
              const provenance: Record<string, unknown> = (() => {
                const raw = cm['provenance']
                if (raw && typeof raw === 'object') return raw as Record<string, unknown>
                if (typeof raw === 'string') { try { return JSON.parse(raw) as Record<string, unknown> } catch { /* ignore */ } }
                return {}
              })()
              const hasAnyConfidence = Object.keys(confidence).length > 0
              const baseKeys = Array.isArray(templateFields) && templateFields.length > 0
                ? Array.from(new Set([...(templateFields as string[]), ...Object.keys(cm)]))
                : Object.keys(cm)
              const flatKeysAll = baseKeys.filter(k => k !== 'chapters' && k !== 'toc' && k !== 'confidence' && k !== 'provenance')
              const processFields = new Set([
                'job_id','extract_status','template_status','ingest_status','summary_language',
                'source_file','source_file_id','source_file_size','source_file_type',
                'filename','path','pathHints','isScan'
              ])
              const primaryKeys = flatKeysAll.filter(k => !processFields.has(k))
              const flatKeys = primaryKeys
              if (flatKeys.length === 0) return null
              return (
                <div>
                  <div className="font-medium mb-1">Metadaten (Template vs. Ergebnis)</div>
                  <div className="overflow-auto">
                    <table className="w-full text-xs">
                      <thead>
                        <tr className="text-left text-muted-foreground">
                          <th className="py-1 pr-2 sticky left-0 bg-background z-10">Feld</th>
                          <th className="py-1 pr-2">Wert</th>
                          {hasAnyConfidence ? <th className="py-1 pr-2 text-right sticky right-0 bg-background border-l">Q</th> : null}
                        </tr>
                      </thead>
                      <tbody>
                        {flatKeys.map((k) => {
                          const val = cm[k]
                          let valueStr = ''
                          if (Array.isArray(val)) valueStr = (val as Array<unknown>).map(v => typeof v === 'string' ? v : JSON.stringify(v)).join(', ')
                          else valueStr = val === null || val === undefined ? '' : typeof val === 'string' ? val : JSON.stringify(val)
                          const hasNonEmptyValue = (() => {
                            if (val === null || val === undefined) return false
                            if (typeof val === 'string') return val.trim().length > 0
                            if (Array.isArray(val)) return (val as Array<unknown>).length > 0
                            if (typeof val === 'object') return Object.keys(val as Record<string, unknown>).length > 0
                            return true
                          })()
                          const cRaw = (confidence as Record<string, unknown>)[k]
                          const cNum = typeof cRaw === 'number' ? cRaw : (typeof cRaw === 'string' && /^\d+(\.\d+)?$/.test(cRaw) ? Number(cRaw) : undefined)
                          const pRaw = (provenance as Record<string, unknown>)[k]
                          const pStr = typeof pRaw === 'string' ? pRaw : pRaw ? JSON.stringify(pRaw) : ''
                          const color = cNum === undefined ? 'text-muted-foreground' : (cNum >= 0.8 ? 'text-green-600' : cNum >= 0.7 ? 'text-yellow-600' : 'text-red-600')
                          return (
                            <tr key={k} className="border-t border-muted/40">
                              <td className="py-1 pr-2 align-top font-medium sticky left-0 bg-background z-10 whitespace-nowrap">{k}</td>
                              <td className="py-1 pr-2 align-top">
                                {valueStr ? (
                                  <TooltipProvider>
                                    <Tooltip>
                                      <TooltipTrigger asChild>
                                        <span className="inline-block max-w-[40vw] overflow-hidden text-ellipsis whitespace-nowrap align-top" title="">
                                          {valueStr}
                                        </span>
                                      </TooltipTrigger>
                                      <TooltipContent>
                                        <div className="max-w-[80vw] whitespace-pre-wrap break-words">{valueStr}</div>
                                      </TooltipContent>
                                    </Tooltip>
                                  </TooltipProvider>
                                ) : ''}
                              </td>
                              {hasAnyConfidence ? <td className="py-1 pr-2 align-top sticky right-0 bg-background border-l">
                                {(!hasNonEmptyValue || cNum === undefined) ? null : (
                                  <TooltipProvider>
                                    <Tooltip>
                                      <TooltipTrigger asChild>
                                        <span className={`inline-flex items-center justify-end w-full ${color}`} title={pStr || ''}>
                                          <span className="inline-block h-2 w-2 rounded-full bg-current" />
                                        </span>
                                      </TooltipTrigger>
                                      <TooltipContent>
                                        <div className="max-w-xs whitespace-pre-wrap break-words">
                                          <div className="font-medium">Confidence: {cNum.toFixed(2)}</div>
                                          {pStr ? <div className="mt-1 text-muted-foreground">Provenance: {pStr}</div> : null}
                                        </div>
                                      </TooltipContent>
                                    </Tooltip>
                                  </TooltipProvider>
                                )}
                              </td> : null}
                            </tr>
                          )
                        })}
                      </tbody>
                    </table>
                  </div>
                </div>
              )
            })()}
          </TabsContent>

          <TabsContent value="process" className="mt-3">
            {(() => {
              const base: Record<string, unknown> = sourceMode === 'frontmatter'
                ? {}
                : ((job?.cumulativeMeta as unknown as Record<string, unknown>) || {})
              const cm = frontmatterMeta ? { ...base, ...frontmatterMeta } : base
              const processOrder = [
                'job_id','extract_status','template_status','ingest_status','summary_language',
                'source_file','source_file_id','source_file_size','source_file_type',
                'filename','path','pathHints','isScan'
              ]
              const keys = processOrder.filter(k => k in cm)
              if (keys.length === 0) return <div className="text-xs text-muted-foreground">Keine Prozessinformationen vorhanden.</div>
              return (
                <div className="overflow-auto">
                  <table className="w-full text-xs">
                    <thead>
                      <tr className="text-left text-muted-foreground">
                        <th className="py-1 pr-2 sticky left-0 bg-background z-10">Feld</th>
                        <th className="py-1 pr-2">Wert</th>
                      </tr>
                    </thead>
                    <tbody>
                      {keys.map(k => {
                        const val = cm[k]
                        const valueStr = val === null || val === undefined ? '' : Array.isArray(val) ? (val as Array<unknown>).map(v => typeof v === 'string' ? v : JSON.stringify(v)).join(', ') : typeof val === 'string' ? val : JSON.stringify(val)
                        return (
                          <tr key={k} className="border-t border-muted/40">
                            <td className="py-1 pr-2 align-top font-medium sticky left-0 bg-background z-10 whitespace-nowrap">{k}</td>
                            <td className="py-1 pr-2 align-top">
                              {valueStr ? (
                                <TooltipProvider>
                                  <Tooltip>
                                    <TooltipTrigger asChild>
                                      <span className="inline-block max-w-[40vw] overflow-hidden text-ellipsis whitespace-nowrap align-top" title="">{valueStr}</span>
                                    </TooltipTrigger>
                                    <TooltipContent>
                                      <div className="max-w-[80vw] whitespace-pre-wrap break-words">{valueStr}</div>
                                    </TooltipContent>
                                  </Tooltip>
                                </TooltipProvider>
                              ) : ''}
                            </td>
                          </tr>
                        )
                      })}
                    </tbody>
                  </table>
                </div>
              )
            })()}
          </TabsContent>

          <TabsContent value="chapters" className="mt-3">
            {(() => {
              const chapters: Array<Record<string, unknown>> = sourceMode === 'frontmatter'
                ? (Array.isArray(frontmatterMeta?.chapters) ? (frontmatterMeta?.chapters as Array<Record<string, unknown>>) : [])
                : ((job?.cumulativeMeta as unknown as { chapters?: Array<Record<string, unknown>> })?.chapters || [])
              if (!Array.isArray(chapters) || chapters.length === 0) return null
              const pad = (lvl: number | undefined): number => {
                if (typeof lvl !== 'number') return 0
                const clamped = Math.max(0, Math.min(3, lvl))
                return (clamped - 1) * 16
              }
              const counters = [0, 0, 0]
              return (
                <div className="space-y-1">
                  <div>
                    {chapters.map((c, i) => {
                      const level = typeof c.level === 'number' ? c.level : 1
                      const lvl = Math.max(1, Math.min(3, level))
                      counters[lvl - 1] += 1
                      for (let j = lvl; j < counters.length; j++) counters[j] = 0
                      const numLabel = counters.slice(0, lvl).filter(n => n > 0).join('.')
                      const title = typeof c.title === 'string' ? c.title : ''
                      const startPage = typeof c.startPage === 'number' ? c.startPage : ''
                      const summaryVal = typeof c.summary === 'string' ? c.summary : ''
                      const summary = summaryVal.length > 1000 ? `${summaryVal.slice(0, 1000)}…` : summaryVal
                      const keywords = Array.isArray(c.keywords) ? (c.keywords as Array<unknown>).filter(v => typeof v === 'string') as string[] : []
                      const ev = typeof c.startEvidence === 'string' ? c.startEvidence : ''
                      return (
                        <details key={`${title}-${i}`} className="group border-b py-1" open={false}>
                          <summary className="list-none cursor-pointer">
                            <div className="flex items-start justify-between gap-3">
                              <div className="flex-1 min-w-0" style={{ paddingLeft: `${pad(lvl)}px` }}>
                                <div className="flex items-baseline gap-2">
                                  <span className="text-xs text-muted-foreground tabular-nums">{numLabel}</span>
                                  <span className="font-medium truncate">{title}</span>
                                </div>
                              </div>
                              <div className="text-xs tabular-nums text-muted-foreground whitespace-nowrap">
                                {String(startPage)}
                              </div>
                            </div>
                          </summary>
                          <div className="mt-1 pr-1 text-xs space-y-1" style={{ paddingLeft: `${pad(lvl) + 28}px` }}>
                            {summary && (
                              <div className="whitespace-pre-wrap break-words">
                                {summary}
                              </div>
                            )}
                            {Array.isArray(keywords) && keywords.length > 0 && (
                              <div className="flex flex-wrap gap-1">
                                {keywords.map(k => (
                                  <span key={k} className="inline-flex items-center rounded px-1.5 py-0.5 bg-muted">{k}</span>
                                ))}
                              </div>
                            )}
                          </div>
                        </details>
                      )
                    })}
                  </div>
                </div>
              )
            })()}
          </TabsContent>
        </Tabs>
      )}

      {viewMode === 'full' && job && (
        <div className="flex items-center justify-between">
          <div>
            <div className="font-medium">Job {job.jobId}</div>
            <div className="text-xs text-muted-foreground">{job.job_type} · {job.operation} · {new Date(job.updatedAt).toLocaleString()}</div>
          </div>
          <div className="inline-flex items-center rounded px-2 py-0.5 bg-muted text-xs">{job.status}</div>
        </div>
      )}

      {/* Hinweise zu Parserfehlern (strikt) */}
      {viewMode !== 'metaOnly' && parseErrors.length > 0 && (
        <div className="text-xs text-destructive">
          {parseErrors.map((e, i) => (<div key={i}>Parserfehler: {e}</div>))}
        </div>
      )}

      {/* Template Hinweis (im Frontmatter-only-Modus ausgeblendet) */}
      {sourceMode !== 'frontmatter' && job && typeof job.cumulativeMeta?.template_used === 'string' && (
        <div className="text-xs text-muted-foreground">Template: {String(job.cumulativeMeta.template_used)}</div>
      )}

      {/* Schritte mit Ampel-Logik */}
      {viewMode === 'full' && job && Array.isArray(job.steps) && job.steps.length > 0 && (
        <div>
          <div className="font-medium mb-1">Schritte</div>
          <div className="flex flex-wrap gap-2 text-xs">
            {job.steps.map((s) => {
              // Geplante Phasen ermitteln (neue Flags bevorzugt, sonst phases)
              const p = (job.parameters || {}) as Record<string, unknown>
              const hasNewFlags = typeof p['doExtractPDF'] === 'boolean' || typeof p['doExtractMetadata'] === 'boolean' || typeof p['doIngestRAG'] === 'boolean'
              const phases = hasNewFlags
                ? {
                    extract: p['doExtractPDF'] === true,
                    template: p['doExtractMetadata'] === true,
                    ingest: p['doIngestRAG'] === true,
                  }
                : ((p['phases'] as { extract?: boolean; template?: boolean; ingest?: boolean }) || {})

              const planned = (() => {
                const n = s.name
                if (n === 'extract_pdf') return phases.extract === true
                if (n === 'transform_template' || n === 'store_shadow_twin') return phases.template === true
                if (n === 'ingest_rag') return phases.ingest === true
                return false
              })()

              // Ampel-Status ableiten
              const skipped = !!(s as { details?: { skipped?: boolean } }).details?.skipped
              let icon = '○'
              let cls = 'text-muted-foreground'
              if (s.status === 'failed') { icon = '✕'; cls = 'text-red-600' }
              else if (s.status === 'running') { icon = '◐'; cls = 'text-yellow-600' }
              else if (s.status === 'completed') { icon = skipped ? '○' : '✓'; cls = skipped ? 'text-gray-400' : 'text-green-600' }
              else if (s.status === 'pending') { icon = planned ? '•' : '○'; cls = planned ? 'text-yellow-600' : 'text-muted-foreground' }

              const time = s.endedAt ? new Date(s.endedAt).toLocaleTimeString() : s.startedAt ? new Date(s.startedAt).toLocaleTimeString() : ''
              return (
                <div key={s.name} className={`inline-flex items-center gap-1 px-2 py-1 rounded border ${cls}`}>
                  <span>{icon}</span>
                  <span className="font-medium">{s.name}</span>
                  {time ? <span className="opacity-70">{time}</span> : null}
                </div>
              )
            })}
          </div>
        </div>
      )}

      {/* Metadaten (flach) – je nach sourceMode: nur Frontmatter oder Merge (nur außerhalb metaOnly-View) */}
      {viewMode !== 'metaOnly' && section === 'meta' && (() => {
        const base: Record<string, unknown> = sourceMode === 'frontmatter'
          ? {}
          : ((job?.cumulativeMeta as unknown as Record<string, unknown>) || {})
        const cm = frontmatterMeta ? { ...base, ...frontmatterMeta } : base
        const confidence: Record<string, unknown> = (() => {
          const raw = cm['confidence']
          if (raw && typeof raw === 'object') return raw as Record<string, unknown>
          if (typeof raw === 'string') { try { return JSON.parse(raw) as Record<string, unknown> } catch { /* ignore */ } }
          return {}
        })()
        const provenance: Record<string, unknown> = (() => {
          const raw = cm['provenance']
          if (raw && typeof raw === 'object') return raw as Record<string, unknown>
          if (typeof raw === 'string') { try { return JSON.parse(raw) as Record<string, unknown> } catch { /* ignore */ } }
          return {}
        })()
        const hasAnyConfidence = Object.keys(confidence).length > 0
        const baseKeys = Array.isArray(templateFields) && templateFields.length > 0
          ? Array.from(new Set([...(templateFields as string[]), ...Object.keys(cm)]))
          : Object.keys(cm)
        const flatKeys = baseKeys.filter(k => k !== 'chapters' && k !== 'toc' && k !== 'confidence' && k !== 'provenance')
        if (flatKeys.length === 0) return null
        return (
        <div>
          <div className="font-medium mb-1">Metadaten (Template vs. Ergebnis)</div>
          <div className="overflow-auto">
            <table className="w-full text-xs">
              <thead>
                <tr className="text-left text-muted-foreground">
                  <th className="py-1 pr-2 sticky left-0 bg-background z-10">Feld</th>
                  <th className="py-1 pr-2">Wert</th>
                  {hasAnyConfidence ? <th className="py-1 pr-2 text-right sticky right-0 bg-background border-l">Q</th> : null}
                </tr>
              </thead>
              <tbody>
                {flatKeys.map((k) => {
                  const val = cm[k]
                  let valueStr = ''
                  if (Array.isArray(val)) valueStr = (val as Array<unknown>).map(v => typeof v === 'string' ? v : JSON.stringify(v)).join(', ')
                  else valueStr = val === null || val === undefined ? '' : typeof val === 'string' ? val : JSON.stringify(val)
                  const hasNonEmptyValue = (() => {
                    if (val === null || val === undefined) return false
                    if (typeof val === 'string') return val.trim().length > 0
                    if (Array.isArray(val)) return (val as Array<unknown>).length > 0
                    if (typeof val === 'object') return Object.keys(val as Record<string, unknown>).length > 0
                    return true
                  })()
                  const cRaw = (confidence as Record<string, unknown>)[k]
                  const cNum = typeof cRaw === 'number' ? cRaw : (typeof cRaw === 'string' && /^\d+(\.\d+)?$/.test(cRaw) ? Number(cRaw) : undefined)
                  const pRaw = (provenance as Record<string, unknown>)[k]
                  const pStr = typeof pRaw === 'string' ? pRaw : pRaw ? JSON.stringify(pRaw) : ''
                  const color = cNum === undefined ? 'text-muted-foreground' : (cNum >= 0.8 ? 'text-green-600' : cNum >= 0.7 ? 'text-yellow-600' : 'text-red-600')
                  return (
                    <tr key={k} className="border-t border-muted/40">
                      <td className="py-1 pr-2 align-top font-medium sticky left-0 bg-background z-10 whitespace-nowrap">{k}</td>
                      <td className="py-1 pr-2 align-top">
                        {valueStr ? (
                          <TooltipProvider>
                            <Tooltip>
                              <TooltipTrigger asChild>
                                <span className="inline-block max-w-[40vw] overflow-hidden text-ellipsis whitespace-nowrap align-top" title="">
                                  {valueStr}
                                </span>
                              </TooltipTrigger>
                              <TooltipContent>
                                <div className="max-w-[80vw] whitespace-pre-wrap break-words">{valueStr}</div>
                              </TooltipContent>
                            </Tooltip>
                          </TooltipProvider>
                        ) : ''}
                      </td>
                      {hasAnyConfidence ? <td className="py-1 pr-2 align-top sticky right-0 bg-background border-l">
                        {(!hasNonEmptyValue || cNum === undefined) ? null : (
                          <TooltipProvider>
                            <Tooltip>
                              <TooltipTrigger asChild>
                                <span className={`inline-flex items-center justify-end w-full ${color}`} title={pStr || ''}>
                                  <span className="inline-block h-2 w-2 rounded-full bg-current" />
                                </span>
                              </TooltipTrigger>
                              <TooltipContent>
                                <div className="max-w-xs whitespace-pre-wrap break-words">
                                  <div className="font-medium">Confidence: {cNum.toFixed(2)}</div>
                                  {pStr ? <div className="mt-1 text-muted-foreground">Provenance: {pStr}</div> : null}
                                </div>
                              </TooltipContent>
                            </Tooltip>
                          </TooltipProvider>
                        )}
                      </td> : null}
                    </tr>
                  )
                })}
              </tbody>
            </table>
          </div>
        </div>
        )
      })()}

      {/* Kapitel (hierarchisch, TOC-Ansicht) – nur außerhalb metaOnly-View */}
      {viewMode !== 'metaOnly' && section === 'chapters' && (() => {
        const chapters: Array<Record<string, unknown>> = sourceMode === 'frontmatter'
          ? (Array.isArray(frontmatterMeta?.chapters) ? (frontmatterMeta?.chapters as Array<Record<string, unknown>>) : [])
          : ((job?.cumulativeMeta as unknown as { chapters?: Array<Record<string, unknown>> })?.chapters || [])
        if (!Array.isArray(chapters) || chapters.length === 0) return null

        const pad = (lvl: number | undefined): number => {
          if (typeof lvl !== 'number') return 0
          const clamped = Math.max(0, Math.min(3, lvl))
          return (clamped - 1) * 16 // px
        }

        // Hierarchische Nummerierung 1., 1.1, 1.1.1 basierend auf level
        const counters = [0, 0, 0]
        return (
        <div className="space-y-1">
          <div className="font-medium mb-1">Kapitel</div>
          <div>
            {chapters.map((c, i) => {
              const level = typeof c.level === 'number' ? c.level : 1
              const lvl = Math.max(1, Math.min(3, level))
              // Zähler aktualisieren
              counters[lvl - 1] += 1
              for (let j = lvl; j < counters.length; j++) counters[j] = 0
              const numLabel = counters.slice(0, lvl).filter(n => n > 0).join('.')
              const title = typeof c.title === 'string' ? c.title : ''
              const startPage = typeof c.startPage === 'number' ? c.startPage : ''
              
              const summaryVal = typeof c.summary === 'string' ? c.summary : ''
              const summary = summaryVal.length > 1000 ? `${summaryVal.slice(0, 1000)}…` : summaryVal
              const keywords = Array.isArray(c.keywords) ? (c.keywords as Array<unknown>).filter(v => typeof v === 'string') as string[] : []
              const ev = typeof c.startEvidence === 'string' ? c.startEvidence : ''
              return (
                <details key={`${title}-${i}`} className="group border-b py-1" open={false} onToggle={(e) => {
                  const open = (e.currentTarget as HTMLDetailsElement).open
                  if (open) {
                    if (startPage !== '') onJumpTo?.({ page: startPage as number | string })
                    else if (ev) onJumpTo?.({ evidence: ev })
                  }
                }}>
                  <summary className="list-none cursor-pointer">
                    <div className="flex items-start justify-between gap-3">
                      <div className="flex-1 min-w-0" style={{ paddingLeft: `${pad(lvl)}px` }}>
                        <div className="flex items-baseline gap-2">
                          <span className="text-xs text-muted-foreground tabular-nums">{numLabel}</span>
                          <span className="font-medium truncate">{title}</span>
                        </div>
                      </div>
                      <div className="text-xs tabular-nums text-muted-foreground whitespace-nowrap">
                        {String(startPage)}
                      </div>
                    </div>
                  </summary>
                  <div className="mt-1 pr-1 text-xs space-y-1" style={{ paddingLeft: `${pad(lvl) + 28}px` }}>
                    {summary && (
                      <div className="whitespace-pre-wrap break-words">
                        {summary}
                      </div>
                    )}
                    {Array.isArray(keywords) && keywords.length > 0 && (
                      <div className="flex flex-wrap gap-1">
                        {keywords.map(k => (
                          <span key={k} className="inline-flex items-center rounded px-1.5 py-0.5 bg-muted">{k}</span>
                        ))}
                      </div>
                    )}
                  </div>
                </details>
              )
            })}
          </div>
        </div>
        )
      })()}

      {/* Inhaltsverzeichnis */}
      {section === 'chapters' && (() => {
        const toc: Array<Record<string, unknown>> = sourceMode === 'frontmatter'
          ? (Array.isArray(frontmatterMeta?.toc) ? (frontmatterMeta?.toc as Array<Record<string, unknown>>) : [])
          : ((job?.cumulativeMeta as unknown as { toc?: Array<Record<string, unknown>> }).toc || [])
        if (!Array.isArray(toc) || toc.length === 0) return null
        return (
        <div>
          <div className="font-medium mb-1">Inhaltsverzeichnis</div>
          <div className="overflow-visible">
            <table className="w-full text-xs">
              <thead>
                <tr className="text-left text-muted-foreground">
                  <th className="py-1 pr-2">Titel</th>
                  <th className="py-1 pr-2">Seite</th>
                  <th className="py-1 pr-2">L</th>
                </tr>
              </thead>
              <tbody>
                {toc.map((t, i) => {
                  const title = typeof t.title === 'string' ? t.title : ''
                  const page = typeof t.page === 'number' ? t.page : ''
                  const level = typeof t.level === 'number' ? t.level : ''
                  return (
                    <tr key={`${title}-${i}`} className="border-t border-muted/40">
                      <td className="py-1 pr-2 align-top whitespace-pre-wrap break-words">{title}</td>
                      <td className="py-1 pr-2 align-top">{page}</td>
                      <td className="py-1 pr-2 align-top">{level}</td>
                    </tr>
                  )
                })}
              </tbody>
            </table>
          </div>
        </div>
        )
      })()}

      {viewMode === 'full' && job && job.ingestion && (
        <div>
          <div className="font-medium mb-1">Ingestion</div>
          <div className="text-xs text-muted-foreground">{job.ingestion.index || '—'} · Vektoren: {job.ingestion.vectorsUpserted ?? '—'} · {job.ingestion.upsertAt ? new Date(job.ingestion.upsertAt).toLocaleString() : '—'}</div>
        </div>
      )}

      {viewMode === 'full' && job && Array.isArray(job.logs) && job.logs.length > 0 && (
        <div>
          <div className="font-medium mb-1">Logs (neueste zuerst)</div>
          <ul className="space-y-0.5 max-h-48 overflow-auto">
            {[...job.logs].reverse().slice(0, 30).map((l, i) => (
              <li key={i} className="text-xs">
                {new Date(l.timestamp).toLocaleTimeString()} · {l.phase || '—'} · {typeof l.progress === 'number' ? `${l.progress}% · ` : ''}{l.message || ''}
              </li>
            ))}
          </ul>
        </div>
      )}

      {/* Parameter am Ende */}
      {viewMode === 'full' && job && job.parameters && (
        <div>
          <div className="font-medium mb-1">Parameter</div>
          <pre className="bg-muted/40 rounded p-2 max-h-32 overflow-auto whitespace-pre-wrap break-words">{JSON.stringify(job.parameters, null, 2)}</pre>
        </div>
      )}
    </div>
  )
}



```

Verstanden. Ich habe das Verhalten angepasst:

- Der Viewer ist jetzt wieder frei bedienbar: Tabs sind nicht mehr „erzwingend“ gesteuert.
- Oben gewählte Phase setzt nur den Tab als Vorauswahl:
  - Interner Zustand `activeTab` wird initial bzw. bei Phasenwechsel auf den passenden Tab gesetzt.
  - Danach kannst du jederzeit im Viewer auf andere Tabs wechseln.

Bitte kurz prüfen:
- Phase ändern → Tab springt zur passenden Ansicht.
- Manuelles Wechseln im Viewer bleibt möglich und wird nicht mehr zurückgesetzt.

---

**User**

In dieser Markdown-Ansicht habe ich so ein Fullscreen-Symbol. Wie könnte ich das auch in der PDF-Ansicht entwenden, wenn ich jetzt den gesamten Bildschirm ausnutzen möchte, um das PDF zu inspizieren.

---

**Cursor**

```typescriptreact
"use client";

import * as React from "react";
import { useAtom } from "jotai";
import { currentPdfPageAtom } from "@/atoms/pdf-viewer";
import "@/lib/pdfjs-worker-setup";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Maximize2, X as CloseIcon } from "lucide-react";

// Lade pdf.js ausschließlich lokal (ESM) und setze Worker-Pfad bundler-freundlich
interface PdfJsModule {
  getDocument: (opts: { url: string }) => { promise: Promise<{ numPages: number; getPage: (n: number) => Promise<{ getViewport: (opts: { scale: number }) => { width: number; height: number }; render: (args: { canvasContext: CanvasRenderingContext2D; viewport: { width: number; height: number } }) => { promise: Promise<void> } }> }> };
}
async function loadPdfJs(): Promise<PdfJsModule | null> {
  if (typeof window === 'undefined') return null;
  const mod = (await import('pdfjs-dist/build/pdf.mjs')) as unknown as PdfJsModule;
  return mod;
}

interface PdfCanvasViewerProps {
  src: string; // Streaming/Download-URL
}

export function PdfCanvasViewer({ src }: PdfCanvasViewerProps) {
  const containerRef = React.useRef<HTMLDivElement | null>(null);
  const [currentPage, setCurrentPage] = useAtom(currentPdfPageAtom);
  const pdfDocRef = React.useRef<{ numPages: number; getPage: (n: number) => Promise<{ getViewport: (opts: { scale: number }) => { width: number; height: number }; render: (args: { canvasContext: CanvasRenderingContext2D; viewport: { width: number; height: number } }) => { promise: Promise<void> } }> } | null>(null);
  const [numPages, setNumPages] = React.useState<number>(0);
  const [scale, setScale] = React.useState<number>(1.25);
  const [pageInput, setPageInput] = React.useState<number>(1);
  const programmaticScrollRef = React.useRef<boolean>(false);
  const rafPendingRef = React.useRef<number | null>(null);
  const [isFullscreen, setIsFullscreen] = React.useState<boolean>(false);

  // Setze Seite aus Scroll-Position (Mitte des Viewports bestimmt die aktive Seite)
  const updatePageFromScroll = React.useCallback(() => {
    const container = containerRef.current;
    if (!container) return;
    const midY = container.scrollTop + container.clientHeight / 2;
    const canvases = Array.from(container.querySelectorAll('canvas[data-page]')) as HTMLCanvasElement[];
    if (canvases.length === 0) return;

    let bestPage = 1;
    let bestDist = Number.POSITIVE_INFINITY;
    for (const c of canvases) {
      const rectTop = c.offsetTop;
      const rectMid = rectTop + c.offsetHeight / 2;
      const dist = Math.abs(rectMid - midY);
      if (dist < bestDist) {
        bestDist = dist;
        const attr = c.getAttribute('data-page');
        bestPage = attr ? Number(attr) : bestPage;
      }
    }
    if (bestPage && bestPage !== currentPage) {
      setCurrentPage(bestPage);
      setPageInput(bestPage);
    }
  }, [currentPage, setCurrentPage]);

  // Throttled Scroll Listener
  React.useEffect(() => {
    const container = containerRef.current;
    if (!container) return;

    const onScroll = () => {
      if (programmaticScrollRef.current) return; // Programmatic scroll: nicht zurückschreiben
      if (rafPendingRef.current !== null) return;
      rafPendingRef.current = window.requestAnimationFrame(() => {
        rafPendingRef.current = null;
        updatePageFromScroll();
      });
    };

    container.addEventListener('scroll', onScroll, { passive: true });
    return () => {
      container.removeEventListener('scroll', onScroll as EventListener);
      if (rafPendingRef.current !== null) {
        window.cancelAnimationFrame(rafPendingRef.current);
        rafPendingRef.current = null;
      }
    };
  }, [updatePageFromScroll]);

  React.useEffect(() => {
    let cancelled = false;

    async function run() {
      const pdfjsLib = await loadPdfJs();
      if (!pdfjsLib) return;
      const task = pdfjsLib.getDocument({ url: src });
      const pdfDoc = await task.promise;
      if (cancelled) return;
      pdfDocRef.current = pdfDoc;
      setNumPages(pdfDoc.numPages as number);
      setPageInput(1);

      // Render alle Seiten
      if (!containerRef.current) return;
      const container = containerRef.current;
      container.innerHTML = '';
      for (let pageNum = 1; pageNum <= pdfDoc.numPages; pageNum++) {
        // eslint-disable-next-line no-await-in-loop
        const page = await pdfDoc.getPage(pageNum);
        const viewport = page.getViewport({ scale });
        const canvas = document.createElement('canvas');
        canvas.width = viewport.width;
        canvas.height = viewport.height;
        canvas.style.width = `${viewport.width}px`;
        canvas.style.height = `${viewport.height}px`;
        canvas.style.display = 'block';
        canvas.style.margin = '0 auto 8px auto';
        canvas.setAttribute('data-page', String(pageNum));
        container.appendChild(canvas);
        const ctx = canvas.getContext('2d');
        if (ctx) {
          // eslint-disable-next-line no-await-in-loop
          await page.render({ canvasContext: ctx, viewport }).promise;
        }
      }

      // Nach dem Initialrender zur Seite 1 scrollen
      programmaticScrollRef.current = true;
      container.scrollTo({ top: 0, behavior: 'auto' });
      window.setTimeout(() => { programmaticScrollRef.current = false; }, 150);
    }

    void run();
    return () => { cancelled = true; };
  }, [src]);

  // Bei Scale-Änderung Seiten neu rendern und aktuelle Seite beibehalten
  React.useEffect(() => {
    async function rerender() {
      const pdfDoc = pdfDocRef.current;
      const container = containerRef.current;
      if (!pdfDoc || !container) return;

      const targetPage = currentPage || 1;
      container.innerHTML = '';
      for (let pageNum = 1; pageNum <= pdfDoc.numPages; pageNum++) {
        // eslint-disable-next-line no-await-in-loop
        const page = await pdfDoc.getPage(pageNum);
        const viewport = page.getViewport({ scale });
        const canvas = document.createElement('canvas');
        canvas.width = viewport.width;
        canvas.height = viewport.height;
        canvas.style.width = `${viewport.width}px`;
        canvas.style.height = `${viewport.height}px`;
        canvas.style.display = 'block';
        canvas.style.margin = '0 auto 8px auto';
        canvas.setAttribute('data-page', String(pageNum));
        container.appendChild(canvas);
        const ctx = canvas.getContext('2d');
        if (ctx) {
          // eslint-disable-next-line no-await-in-loop
          await page.render({ canvasContext: ctx, viewport }).promise;
        }
      }

      // Scroll zur vorher aktiven Seite
      programmaticScrollRef.current = true;
      const el = container.querySelector(`[data-page="${targetPage}"]`) as HTMLElement | null;
      if (el) container.scrollTo({ top: el.offsetTop - 16, behavior: 'auto' });
      window.setTimeout(() => { programmaticScrollRef.current = false; }, 150);
    }
    void rerender();
  }, [scale]);

  // Rerender beim Umschalten Vollbild (neues Container-Element)
  React.useEffect(() => {
    async function rerenderFullscreen() {
      const pdfDoc = pdfDocRef.current;
      const container = containerRef.current;
      if (!pdfDoc || !container) return;
      const targetPage = currentPage || 1;
      container.innerHTML = '';
      for (let pageNum = 1; pageNum <= pdfDoc.numPages; pageNum++) {
        // eslint-disable-next-line no-await-in-loop
        const page = await pdfDoc.getPage(pageNum);
        const viewport = page.getViewport({ scale });
        const canvas = document.createElement('canvas');
        canvas.width = viewport.width;
        canvas.height = viewport.height;
        canvas.style.width = `${viewport.width}px`;
        canvas.style.height = `${viewport.height}px`;
        canvas.style.display = 'block';
        canvas.style.margin = '0 auto 8px auto';
        canvas.setAttribute('data-page', String(pageNum));
        container.appendChild(canvas);
        const ctx = canvas.getContext('2d');
        if (ctx) {
          // eslint-disable-next-line no-await-in-loop
          await page.render({ canvasContext: ctx, viewport }).promise;
        }
      }
      programmaticScrollRef.current = true;
      const el = container.querySelector(`[data-page="${targetPage}"]`) as HTMLElement | null;
      if (el) container.scrollTo({ top: el.offsetTop - 16, behavior: 'auto' });
      window.setTimeout(() => { programmaticScrollRef.current = false; }, 150);
    }
    // Wenn sich der Fullscreen-Container ändert, rendere neu
    if (pdfDocRef.current) void rerenderFullscreen();
  // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [isFullscreen]);

  function scrollToPage(page: number) {
    const container = containerRef.current;
    if (!container) return;
    const el = container.querySelector(`[data-page="${page}"]`) as HTMLElement | null;
    if (el) {
      programmaticScrollRef.current = true;
      container.scrollTo({ top: el.offsetTop - 16, behavior: 'smooth' });
      window.setTimeout(() => { programmaticScrollRef.current = false; }, 250);
    }
  }

  // Reagiere auf globale Seitenänderungen (z. B. Eingabe im Header)
  React.useEffect(() => {
    scrollToPage(currentPage || 1);
  }, [currentPage]);

  function handlePrev() {
    const target = Math.max(1, currentPage - 1);
    setPageInput(target);
    scrollToPage(target);
  }

  function handleNext() {
    const target = Math.min(Math.max(1, numPages), currentPage + 1);
    setPageInput(target);
    scrollToPage(target);
  }

  function handleZoom(delta: number) {
    const next = Math.max(0.5, Math.min(3, Number((scale + delta).toFixed(2))));
    setScale(next);
  }

  function handlePageInput(e: React.FormEvent<HTMLFormElement>) {
    e.preventDefault();
    const val = Number(pageInput);
    if (!Number.isFinite(val)) return;
    const clamped = Math.max(1, Math.min(numPages || val, val));
    setPageInput(clamped);
    scrollToPage(clamped);
  }

  return (
    <div className="flex h-full w-full flex-col">
      <div className="flex items-center gap-2 p-2 border-b">
        <Button variant="outline" size="icon" onClick={handlePrev} aria-label="Vorherige Seite">‹</Button>
        <Button variant="outline" size="icon" onClick={handleNext} aria-label="Nächste Seite">›</Button>
        <form onSubmit={handlePageInput} className="flex items-center gap-1">
          <Input name="page" value={pageInput} onChange={(e) => setPageInput(Number(e.target.value) || 1)} className="h-8 w-16 text-center" />
          <div className="text-xs text-muted-foreground">von {numPages || '…'}</div>
        </form>
        <div className="mx-2 h-4 w-px bg-border" />
        <Button variant="outline" size="icon" onClick={() => handleZoom(-0.1)} aria-label="Zoom out">−</Button>
        <Button variant="outline" size="icon" onClick={() => handleZoom(+0.1)} aria-label="Zoom in">＋</Button>
        <div className="text-xs text-muted-foreground ml-2">Zoom: {(scale * 100).toFixed(0)}%</div>
        <div className="ml-auto flex items-center gap-2">
          <Button variant="outline" size="icon" aria-label="Vollbild" title="Vollbild" onClick={() => setIsFullscreen(true)}>
            <Maximize2 className="h-4 w-4" />
          </Button>
        </div>
      </div>
      <div ref={!isFullscreen ? containerRef : undefined} className="w-full h-full overflow-auto" />

      {isFullscreen && (
        <div className="fixed inset-0 z-[100] bg-background">
          <div className="flex items-center gap-2 p-2 border-b">
            <Button variant="outline" size="icon" onClick={handlePrev} aria-label="Vorherige Seite">‹</Button>
            <Button variant="outline" size="icon" onClick={handleNext} aria-label="Nächste Seite">›</Button>
            <form onSubmit={handlePageInput} className="flex items-center gap-1">
              <Input name="page-fs" value={pageInput} onChange={(e) => setPageInput(Number(e.target.value) || 1)} className="h-8 w-16 text-center" />
              <div className="text-xs text-muted-foreground">von {numPages || '…'}</div>
            </form>
            <div className="mx-2 h-4 w-px bg-border" />
            <Button variant="outline" size="icon" onClick={() => handleZoom(-0.1)} aria-label="Zoom out">−</Button>
            <Button variant="outline" size="icon" onClick={() => handleZoom(+0.1)} aria-label="Zoom in">＋</Button>
            <div className="text-xs text-muted-foreground ml-2">Zoom: {(scale * 100).toFixed(0)}%</div>
            <div className="ml-auto flex items-center gap-2">
              <Button variant="outline" size="icon" aria-label="Vollbild beenden" title="Vollbild beenden" onClick={() => setIsFullscreen(false)}>
                <CloseIcon className="h-4 w-4" />
              </Button>
            </div>
          </div>
          <div ref={containerRef} className="w-full h-[calc(100%-40px)] overflow-auto" />
        </div>
      )}
    </div>
  );
}



```

Ich habe einen Vollbild-Modus für die PDF‑Ansicht ergänzt, analog zur Markdown‑Vorschau:

- In `PdfCanvasViewer`:
  - Neuer Button „Vollbild“ in der PDF‑Toolbar.
  - Vollbild‑Overlay mit eigener Toolbar (Seite, Zoom, „Vollbild beenden“).
  - Beim Umschalten wird der PDF‑Inhalt im neuen Container neu gerendert; Scrollposition/Seite bleiben erhalten.
  - Keine Linterfehler.

- In `PdfPhasesView` bleibt dein Layout unverändert; der neue Button erscheint in der linken PDF‑Pane‑Toolbar.

Bedienung:
- Klick auf „Vollbild“ in der PDF‑Toolbar → PDF nutzt den gesamten Bildschirm.
- „Vollbild beenden“ schließt das Overlay.

---

**User**

Ok, der Phasen-Stepper sollte ja eigentlich anzeigen, visuell, wie weit wir diese fortgeschritten sind. Zumindest sollte man das irgendwie farblich sehen, könnte man das auf grün, gelb, rot oder grau einstellen, sollte es eben erledigt, die Bearbeitung, fehlerhaft oder noch offen ist/war.

---

**Cursor**

```typescriptreact
<<'PATCH'
*** Begin Patch
*** Update File: src/components/library/pdf-phases-view.tsx
@@
 import { currentPdfPageAtom } from "@/atoms/pdf-viewer";
+import { extractFrontmatterBlock, parseFrontmatter } from "@/lib/markdown/frontmatter";
@@
   const [currentPage, setCurrentPage] = useAtom(currentPdfPageAtom);
   const leftRef = React.useRef<HTMLDivElement | null>(null);
   const rightRef = React.useRef<HTMLDivElement | null>(null);
   const syncingFromPdfRef = React.useRef(false);
   const syncingFromMarkdownRef = React.useRef(false);
+  const [stepStatuses, setStepStatuses] = React.useState<{ p1?: "completed" | "in_progress" | "failed" | "pending"; p2?: "completed" | "in_progress" | "failed" | "pending"; p3?: "completed" | "in_progress" | "failed" | "pending" }>({});
@@
   // Shadow‑Twin laden
   React.useEffect(() => {
@@
   }, [provider, shadowTwin?.id]);
+
+  // Statusermittlung aus Frontmatter des Shadow‑Twins
+  React.useEffect(() => {
+    try {
+      const fmBlock = extractFrontmatterBlock(twinContent || "");
+      if (!fmBlock) { setStepStatuses({}); return; }
+      const meta = parseFrontmatter(fmBlock);
+      function mapStatus(v: unknown): "completed" | "in_progress" | "failed" | "pending" {
+        const s = typeof v === 'string' ? v.toLowerCase() : '';
+        if (s === 'completed' || s === 'done' || s === 'ok') return 'completed';
+        if (s === 'running' || s === 'in_progress' || s === 'progress') return 'in_progress';
+        if (s === 'failed' || s === 'error') return 'failed';
+        return 'pending';
+      }
+      const p1 = mapStatus((meta as Record<string, unknown>)['extract_status']);
+      const p2 = mapStatus((meta as Record<string, unknown>)['template_status']);
+      const p3 = mapStatus((meta as Record<string, unknown>)['ingest_status']);
+      setStepStatuses({ p1, p2, p3 });
+    } catch {
+      setStepStatuses({});
+    }
+  }, [twinContent]);
@@
-        <PhaseStepper />
+        <PhaseStepper statuses={stepStatuses} />
*** End Patch
```

```typescriptreact
"use client";

import * as React from "react";
import { useAtom, useAtomValue } from "jotai";
import { activePdfPhaseAtom } from "@/atoms/pdf-phases";
import type { StorageItem, StorageProvider } from "@/lib/storage/types";
import { DocumentPreview } from "./document-preview";
import { MarkdownPreview } from "./markdown-preview";
import { JobReportTab } from "./job-report-tab";
import { PhaseStepper } from "./phase-stepper";
import { activeLibraryIdAtom, selectedShadowTwinAtom } from "@/atoms/library-atom";
import { FileLogger } from "@/lib/debug/logger";
import { PdfCanvasViewer } from "./pdf-canvas-viewer";
import { useStorage } from "@/contexts/storage-context";
import { currentPdfPageAtom } from "@/atoms/pdf-viewer";
import { extractFrontmatterBlock, parseFrontmatter } from "@/lib/markdown/frontmatter";
// Button und direkte Template-Analyse wurden entfernt – Steuerung erfolgt ausschließlich über PhaseStepper

interface PdfPhasesViewProps {
  item: StorageItem;
  provider: StorageProvider | null;
  markdownContent?: string;
}

export function PdfPhasesView({ item, provider, markdownContent }: PdfPhasesViewProps) {
  const [phase] = useAtom(activePdfPhaseAtom);
  const activeLibraryId = useAtomValue(activeLibraryIdAtom);
  const shadowTwin = useAtomValue(selectedShadowTwinAtom);
  const [twinContent, setTwinContent] = React.useState<string>(markdownContent || "");
  const [twinLoading, setTwinLoading] = React.useState<boolean>(false);
  const [twinError, setTwinError] = React.useState<string | null>(null);
  const { provider: storageProvider } = useStorage();
  const [currentPage, setCurrentPage] = useAtom(currentPdfPageAtom);
  const [isPdfCollapsed, setIsPdfCollapsed] = React.useState(false);
  const leftRef = React.useRef<HTMLDivElement | null>(null);
  const rightRef = React.useRef<HTMLDivElement | null>(null);
  const syncingFromPdfRef = React.useRef(false);
  const syncingFromMarkdownRef = React.useRef(false);
  const [stepStatuses, setStepStatuses] = React.useState<{ p1?: "completed" | "in_progress" | "failed" | "pending"; p2?: "completed" | "in_progress" | "failed" | "pending"; p3?: "completed" | "in_progress" | "failed" | "pending" }>({});

  // Globaler Page→Scroll Sync: scrolle beide Paneele zur aktuellen Seite (falls Marker vorhanden)
  React.useEffect(() => {
    const scrollToMarker = (root: HTMLElement | null, selector: string) => {
      if (!root) return;
      const el = root.querySelector(selector) as HTMLElement | null;
      if (!el) return;
      root.scrollTo({ top: el.offsetTop - 16, behavior: 'smooth' });
    };
    // Links: PDF nutzt [data-page]
    scrollToMarker(leftRef.current, `[data-page="${currentPage}"]`);
    // Rechts: Markdown nutzt [data-page-marker]
    scrollToMarker(rightRef.current, `[data-page-marker="${currentPage}"]`);
  }, [currentPage]);

  const [pdfUrl, setPdfUrl] = React.useState<string | null>(null);
  const markdownApiRef = React.useRef<{ scrollToText: (q: string) => void; scrollToPage: (n: number | string) => void; setQueryAndSearch: (q: string) => void; getVisiblePage?: () => number | null } | null>(null);

  // Shadow‑Twin laden
  React.useEffect(() => {
    let cancelled = false;
    async function loadTwin() {
      try {
        setTwinLoading(true);
        setTwinError(null);
        if (!provider || !shadowTwin?.id) {
          setTwinContent("");
          return;
        }
        FileLogger.info('PdfPhasesView', 'Lade Shadow‑Twin Inhalt', { twinId: shadowTwin.id, name: shadowTwin.metadata?.name });
        const { blob } = await provider.getBinary(shadowTwin.id);
        const text = await blob.text();
        if (!cancelled) setTwinContent(text);
      } catch (err) {
        const message = err instanceof Error ? err.message : 'Unbekannter Fehler';
        FileLogger.error('PdfPhasesView', 'Fehler beim Laden des Shadow‑Twin', { error: message });
        if (!cancelled) setTwinError(message);
      } finally {
        if (!cancelled) setTwinLoading(false);
      }
    }
    void loadTwin();
    return () => { cancelled = true; };
  }, [provider, shadowTwin?.id]);

  // Status aus Frontmatter ableiten
  React.useEffect(() => {
    try {
      const fm = extractFrontmatterBlock(twinContent || "");
      if (!fm) { setStepStatuses({}); return; }
      const meta = parseFrontmatter(fm);
      const m = meta as Record<string, unknown>;
      const to = (v: unknown): "completed"|"in_progress"|"failed"|"pending" => {
        const s = typeof v === 'string' ? v.toLowerCase() : '';
        if (s.includes('complete')) return 'completed';
        if (s.includes('running') || s.includes('progress')) return 'in_progress';
        if (s.includes('fail') || s.includes('error')) return 'failed';
        return 'pending';
      }
      setStepStatuses({ p1: to(m['extract_status']), p2: to(m['template_status']), p3: to(m['ingest_status']) });
    } catch { setStepStatuses({}); }
  }, [twinContent]);

  // PDF-Streaming URL laden
  React.useEffect(() => {
    let cancelled = false;
    async function loadUrl() {
      try {
        if (!storageProvider || !item?.id) return;
        const url = await storageProvider.getStreamingUrl(item.id);
        if (!cancelled) setPdfUrl(url);
      } catch (err) {
        FileLogger.error('PdfPhasesView', 'PDF URL Fehler', err);
      }
    }
    void loadUrl();
    return () => { cancelled = true; };
  }, [storageProvider, item?.id]);

  // Scroll Sync von rechts (Markdown) → links (PDF)
  React.useEffect(() => {
    const container = rightRef.current;
    const targetPane = leftRef.current;
    if (!container || !targetPane) return;
    const markers = Array.from(container.querySelectorAll('[data-page-marker]')) as HTMLElement[];
    if (markers.length === 0) return;
    const observer = new IntersectionObserver((entries) => {
      if (syncingFromPdfRef.current) return;
      let best: { page: number; ratio: number } | null = null;
      for (const e of entries) {
        const attr = (e.target as HTMLElement).getAttribute('data-page-marker');
        const page = attr ? Number(attr) : NaN;
        if (!Number.isFinite(page)) continue;
        const ratio = e.intersectionRatio;
        if (!best || ratio > best.ratio) best = { page, ratio };
      }
      if (!best || best.ratio < 0.25) return;
      syncingFromMarkdownRef.current = true;
      const el = targetPane.querySelector(`[data-page="${best.page}"]`) as HTMLElement | null;
      if (el) targetPane.scrollTo({ top: el.offsetTop - 16, behavior: 'smooth' });
      if (best.page !== currentPage) setCurrentPage(best.page);
      window.setTimeout(() => { syncingFromMarkdownRef.current = false; }, 250);
    }, { root: container, threshold: [0, 0.25, 0.5, 0.75, 1] });
    markers.forEach(m => observer.observe(m));
    return () => observer.disconnect();
  }, [twinContent]);

  // Scroll Sync von links (PDF) → rechts (Markdown)
  React.useEffect(() => {
    const container = leftRef.current;
    const targetPane = rightRef.current;
    if (!container || !targetPane) return;
    const markers = Array.from(container.querySelectorAll('[data-page]')) as HTMLElement[];
    if (markers.length === 0) return;
    const observer = new IntersectionObserver((entries) => {
      if (syncingFromMarkdownRef.current) return;
      let best: { page: number; ratio: number } | null = null;
      for (const e of entries) {
        const attr = (e.target as HTMLElement).getAttribute('data-page');
        const page = attr ? Number(attr) : NaN;
        if (!Number.isFinite(page)) continue;
        const ratio = e.intersectionRatio;
        if (!best || ratio > best.ratio) best = { page, ratio };
      }
      if (!best || best.ratio < 0.25) return;
      syncingFromPdfRef.current = true;
      const el = targetPane.querySelector(`[data-page-marker="${best.page}"]`) as HTMLElement | null;
      if (el) targetPane.scrollTo({ top: el.offsetTop - 16, behavior: 'smooth' });
      if (best.page !== currentPage) setCurrentPage(best.page);
      window.setTimeout(() => { syncingFromPdfRef.current = false; }, 250);
    }, { root: container, threshold: [0, 0.25, 0.5, 0.75, 1] });
    markers.forEach(m => observer.observe(m));
    return () => observer.disconnect();
  }, [pdfUrl]);

  return (
    <div className="flex h-full flex-col gap-2">
      <div className="flex items-center justify-between gap-2">
        <PhaseStepper statuses={stepStatuses} />
        <div className="ml-auto flex items-center gap-2 pr-1">
          <button type="button" className="h-7 px-2 border rounded text-xs" onClick={() => setIsPdfCollapsed(v => !v)}>{isPdfCollapsed ? 'PDF zeigen' : 'PDF ausblenden'}</button>
          <form className="flex items-center gap-1" onSubmit={(e) => { e.preventDefault(); const input = (e.currentTarget.elements.namedItem('gpage') as HTMLInputElement | null); if (!input) return; const val = Number(input.value); if (Number.isFinite(val) && val >= 1) setCurrentPage(val); }}>
            <span className="text-xs text-muted-foreground">Seite</span>
            <input name="gpage" value={currentPage} onChange={(e) => setCurrentPage(Number(e.target.value) || 1)} className="h-7 w-16 text-center border rounded text-xs" />
            <button type="submit" className="h-7 px-2 border rounded text-xs">Gehe</button>
          </form>
        </div>
      </div>

      {/* Split */}
      <div className="grid grid-cols-2 gap-2 h-full min-h-0">
        {/* Left Pane: immer PDF (ein-/ausblendbar) */}
        <div className={`min-h-0 overflow-auto rounded border ${isPdfCollapsed ? 'hidden' : ''}`} ref={leftRef}>
          {pdfUrl ? <PdfCanvasViewer src={pdfUrl} /> : <DocumentPreview provider={provider} activeLibraryId={activeLibraryId} />}
        </div>

        {/* Right Pane: immer Analyse-Viewer (Markdown/Metadaten/Kapitel/Prozessinfo) */}
        <div className={`min-h-0 overflow-auto rounded border ${isPdfCollapsed ? 'col-span-2' : ''}`} ref={rightRef}>
          <div className="h-full">
            <JobReportTab
              libraryId={activeLibraryId}
              fileId={item.id}
              fileName={item.metadata?.name}
              provider={provider || undefined}
              sourceMode="frontmatter"
              viewMode="metaOnly"
              mdFileId={shadowTwin?.id || null}
              forcedTab={phase === 1 ? 'markdown' : phase === 2 ? 'meta' : 'process'}
              onJumpTo={({ page, evidence }) => {
                if (typeof page === 'number' || typeof page === 'string') {
                  const p = typeof page === 'string' ? Number(page) : page;
                  if (Number.isFinite(p)) setCurrentPage(p as number);
                } else if (typeof evidence === 'string' && evidence.trim()) {
                  if (markdownApiRef.current) {
                    markdownApiRef.current.setQueryAndSearch(evidence.slice(0, 80));
                    const vis = markdownApiRef.current.getVisiblePage?.();
                    if (vis && Number.isFinite(vis)) setCurrentPage(vis as number);
                  }
                }
              }}
            />
          </div>
        </div>
      </div>
    </div>
  );
}



```

Ich habe den Phasen‑Status im Stepper farblich gekoppelt:

- PdfPhasesView
  - Liest nach Laden des Shadow‑Twin die Frontmatter.
  - Leitet `extract_status`, `template_status`, `ingest_status` ab und mappt auf Step‑Status:
    - completed → grün
    - in_progress/running → gelb
    - failed/error → rot
    - sonst → grau (pending)
  - Übergibt die Statuswerte als `statuses` an `PhaseStepper`.

- PhaseStepper unterstützt diese Props schon und zeigt die Punkte entsprechend farbig an.

Zusätzlich bleibt die Tabs‑Verknüpfung aktiv:
- Phase 1 → Tab „Markdown“ wird vorselektiert (weiterhin frei wechselbar).
- Phase 2 → „Metadaten“.
- Phase 3 → „Prozessinfo“.

Wenn du statt Frontmatter lieber die Job‑API als Quelle nehmen willst (z. B. live während eines Runs), kann ich die Statuslogik auf `job.steps` umstellen oder mergen.

---

**User**

Nein belassen wir den Frontmatter als Quelle.  Momentan wird der Rahmen grün eingefärbt. Ich würde gerne den Punkt nach dem Text einfärben.

Ok, dann gehen wir nochmal zur Phasenverarbeitung. Über die Play-Button im Phasen-Stepper kann ich ja einzelne Phasen starten. Wie kann ich jetzt die Neuberechnung der Extraktion z.B. erzwingen, auch wenn es sie schon gibt? Wir haben hier dieses Verzeichnis, wo das ausgegraut ist und dann automatisch übersprungen wird. Welche Möglichkeit hätten wir, um das zu erzwingen?


---

**Cursor**

```typescriptreact
"use client";

import * as React from "react";
import { useAtom } from "jotai";
import { activePdfPhaseAtom, type PdfPhase } from "@/atoms/pdf-phases";
import { cn } from "@/lib/utils";
import { Settings2, Play } from "lucide-react";
import { Button } from "@/components/ui/button";
import { useAtomValue } from "jotai";
import { activeLibraryIdAtom, selectedFileAtom } from "@/atoms/library-atom";
import { loadPdfDefaults } from "@/lib/pdf-defaults";
import { pdfOverridesAtom, getEffectivePdfDefaults } from "@/atoms/pdf-defaults";
import { TransformService, type PdfTransformOptions } from "@/lib/transform/transform-service";
import { useStorage } from "@/contexts/storage-context";
import { toast } from "sonner";

interface PhaseStepperProps {
  statuses?: { p1?: "completed" | "in_progress" | "failed" | "pending"; p2?: "completed" | "in_progress" | "failed" | "pending"; p3?: "completed" | "in_progress" | "failed" | "pending" };
  className?: string;
}

const PdfPhaseSettings = React.lazy(() => import('./pdf-phase-settings').then(m => ({ default: m.PdfPhaseSettings })));

export function PhaseStepper({ statuses, className }: PhaseStepperProps) {
  const [settingsOpen, setSettingsOpen] = React.useState(false);
  const [phase, setPhase] = useAtom(activePdfPhaseAtom);
  const activeLibraryId = useAtomValue(activeLibraryIdAtom);
  const item = useAtomValue(selectedFileAtom);
  const { provider, refreshItems } = useStorage();
  const pdfOverrides = useAtomValue(pdfOverridesAtom);

  function canRun(): boolean {
    return Boolean(provider && activeLibraryId && item && item.type === 'file');
  }

  function buildOptions(targetPhase: PdfPhase): PdfTransformOptions | null {
    if (!provider || !activeLibraryId || !item || item.type !== 'file') return null;
    const defaults = getEffectivePdfDefaults(activeLibraryId, loadPdfDefaults(activeLibraryId), pdfOverrides);
    const base: PdfTransformOptions = {
      targetLanguage: typeof defaults.targetLanguage === 'string' ? defaults.targetLanguage : 'de',
      fileName: TransformService.generateShadowTwinName(item.metadata.name, typeof defaults.targetLanguage === 'string' ? defaults.targetLanguage : 'de'),
      createShadowTwin: true,
      fileExtension: 'md',
      extractionMethod: typeof defaults.extractionMethod === 'string' ? defaults.extractionMethod : 'native',
      useCache: defaults.useCache ?? true,
      includeImages: defaults.includeImages ?? false,
      template: typeof defaults.template === 'string' ? defaults.template : undefined,
    };
    return {
      ...base,
      doExtractPDF: targetPhase >= 1,
      doExtractMetadata: targetPhase >= 2,
      doIngestRAG: targetPhase >= 3,
    };
  }

  async function runPhase(targetPhase: PdfPhase = phase) {
    try {
      if (!canRun()) {
        toast.error('Fehler', { description: 'Kein Dokument/Provider verfügbar' });
        return;
      }
      const bin = await provider!.getBinary(item!.id);
      const file = new File([bin.blob], item!.metadata.name, { type: item!.metadata.mimeType });
      const options = buildOptions(targetPhase);
      if (!options) {
        toast.error('Fehler', { description: 'Optionen konnten nicht erstellt werden' });
        return;
      }
      // Keine Persistenz hier; Overrides bleiben bis zum Reload
      await TransformService.transformPdf(file, item!, options, provider!, refreshItems, activeLibraryId!);
      toast.success('Gestartet', { description: `Bis Phase ${targetPhase} angestoßen` });
    } catch (err) {
      const msg = err instanceof Error ? err.message : 'Unbekannter Fehler';
      toast.error('Start fehlgeschlagen', { description: msg });
    }
  }

  function badgeColor(status?: "completed" | "in_progress" | "failed" | "pending") {
    if (status === 'completed') return 'bg-green-500';
    if (status === 'in_progress') return 'bg-amber-500';
    if (status === 'failed') return 'bg-red-500';
    return 'bg-muted-foreground/40';
  }

  function buttonStyle(isActive: boolean, status?: "completed" | "in_progress" | "failed" | "pending") {
    const color = status === 'completed' ? 'ring-green-500' : status === 'in_progress' ? 'ring-amber-500' : status === 'failed' ? 'ring-red-500' : 'ring-transparent';
    return cn(
      "px-2 py-1 text-xs rounded border ring-1",
      color,
      isActive ? "bg-primary text-primary-foreground" : "bg-muted hover:bg-muted/70",
    );
  }

  function renderButton(id: PdfPhase, label: string, status?: "completed" | "in_progress" | "failed" | "pending") {
    const isActive = phase === id;
    return (
      <div key={id} className="flex items-center gap-1">
        <button
          type="button"
          className={buttonStyle(isActive, status)}
          onClick={() => setPhase(id)}
          aria-pressed={isActive}
          aria-label={`Phase ${id}: ${label}`}
          title={`${label} auswählen`}
        >
          <span className="mr-2 hidden sm:inline">{label}</span>
          <span className="inline-flex items-center justify-center h-2.5 w-2.5 rounded-full ml-0.5">
            <span className={`inline-block h-2.5 w-2.5 rounded-full ${badgeColor(status)}`} />
          </span>
        </button>
        <button
          type="button"
          className="inline-flex h-6 w-6 items-center justify-center rounded border bg-background hover:bg-muted text-muted-foreground"
          onClick={() => void runPhase(id)}
          title={`Bis ${label} ausführen`}
          aria-label={`Bis ${label} ausführen`}
          disabled={!canRun()}
        >
          <Play className="h-3.5 w-3.5" />
        </button>
      </div>
    );
  }

  return (
    <div className={cn("flex items-center gap-2", className)}>
      {renderButton(1, "Extraktion", statuses?.p1)}
      {renderButton(2, "Metadaten", statuses?.p2)}
      {renderButton(3, "Ingestion", statuses?.p3)}
      <div className="ml-auto flex items-center gap-2">
        <Button size="sm" variant="secondary" onClick={() => void runPhase()} disabled={!canRun()} title="Ausgewählte Phase starten">
          <Play className="h-3.5 w-3.5 mr-1" /> Starten
        </Button>
        <Button size="icon" variant="ghost" title="Standardwerte anpassen" onClick={() => setSettingsOpen(true)}>
          <Settings2 className="h-4 w-4" />
        </Button>
      </div>
      {settingsOpen && (
        <React.Suspense>
          <PdfPhaseSettings open={settingsOpen} onOpenChange={setSettingsOpen} />
        </React.Suspense>
      )}
    </div>
  );
}



```

- Punkt einfärben statt Rahmen
  - Der Phasenpunkt direkt hinter „Extraktion/Metadaten/Ingestion“ ist jetzt farbig:
    - grün: completed
    - gelb: in_progress
    - rot: failed
    - grau: pending
  - Quelle bleibt Frontmatter (`extract_status`, `template_status`, `ingest_status`).

- Neuberechnung erzwingen (Extraktion, obwohl Artefakt existiert)
  - In der Serverroute ist Idempotenz aktiv; vorhandene Artefakte überspringen Extraktion. Du hast zwei Möglichkeiten:
    1) PDF‑Phasen-Dialog (Batch) mit Flag „Neu scannen/Force“: Wir können ein „Erzwingen“-Feld (z. B. „Force recreate“) hinzufügen und als `forceRecreate=true` senden. Die Route `process-pdf` liest bereits `forceRecreate` (siehe `const forceRecreate = ((formData.get('forceRecreate') as string | null) ?? '') === 'true'`), respektiert es im Gate (`if (g.exists && !forceRecreate) { skip }`). D. h. wenn wir beim Start `forceRecreate=true` mitsenden, wird nicht geskippt.
    2) Im Stepper-Start (Einzeldokument) ebenfalls `forceRecreate=true` in die Options packen, wenn du bewusst Extraktion neu rechnen willst.

  - Konkrete Änderung, die ich für dich vornehmen kann:
    - PhaseStepper: „Starten“-Button und die Play‑Buttons optional mit „Shift+Klick = Erzwingen“. Dann setze ich in `buildOptions` zusätzlich `forceRecreate: true` (du hast bereits `buildOptions`/`runPhase`; wir erweitern `PdfTransformOptions` und `TransformService.transformPdf` Request um dieses Feld).
    - Alternativ ein kleines „Erzwingen“-Toggle in der Toolbar des Steppers, das im State bleibt und mitgesendet wird.

Sag mir, welche Variante dir lieber ist:
- Toggle „Erzwingen“ neben „Starten“
- Shift+Klick auf Play/Start
- Beides

Dann implementiere ich das Flag end‑to‑end (UI → `buildOptions` → `process-pdf` schon vorhanden → Worker wird nicht mehr geskippt).

---

**User**

Punkt wird jetzt richtig eingefärbt, Rahmen können wir jetzt entfernen. Ist auch noch grün, muss jetzt nicht mehr sein.
Ja bitte Toggle „Erzwingen“ neben „Starten“ und im PDF‑Phasen-Dialog (Batch) ein neues „Erzwingen“-Feld hinzufügen. 
Aber wir müssen es auch bei jeder Phase machen, weil ich habe sehr viele Dokumente aufwendig mit Markdown konvertiert, das passt für erste Phase, aber die Metadaten sind falsch kreiert worden. Da muss ich jetzt im Batch-Modus nur die Metadaten, also Phase 2, erzwingen, aber Phase 1 nicht.


---

**Cursor**

Ich passe zuerst den Phase-Button-Rahmen an und füge im Stepper einen „Erzwingen“-Toggle hinzu, der für die jeweilige gestartete Phase gilt. Danach suche ich den Batch‑Dialog und erweitere ihn um ein pro‑Phase „Erzwingen“-Feld.

Ich schaue mir jetzt die relevanten Routen und den Stepper an, um den Rahmen zu entfernen und das Erzwingen-Flag end-to-end korrekt zu unterstützen. Danach füge ich den Toggle im Stepper und im Batch-Dialog ein und verdrahte die Optionsweitergabe.

Ich entferne den farbigen Rahmen im `PhaseStepper`, füge einen „Erzwingen“-Toggle hinzu, der beim Start die Optionen entsprechend setzt, und erweitere den Batch‑Dialog um Checkboxen für „Extraktion erzwingen“ und „Metadaten neu berechnen“. Danach prüfe ich Linter.

```typescriptreact
"use client";

import * as React from "react";
import { useAtom } from "jotai";
import { activePdfPhaseAtom, type PdfPhase } from "@/atoms/pdf-phases";
import { cn } from "@/lib/utils";
import { Settings2, Play } from "lucide-react";
import { Button } from "@/components/ui/button";
import { useAtomValue } from "jotai";
import { activeLibraryIdAtom, selectedFileAtom } from "@/atoms/library-atom";
import { loadPdfDefaults } from "@/lib/pdf-defaults";
import { pdfOverridesAtom, getEffectivePdfDefaults } from "@/atoms/pdf-defaults";
import { TransformService, type PdfTransformOptions } from "@/lib/transform/transform-service";
import { useStorage } from "@/contexts/storage-context";
import { toast } from "sonner";

interface PhaseStepperProps {
  statuses?: { p1?: "completed" | "in_progress" | "failed" | "pending"; p2?: "completed" | "in_progress" | "failed" | "pending"; p3?: "completed" | "in_progress" | "failed" | "pending" };
  className?: string;
}

const PdfPhaseSettings = React.lazy(() => import('./pdf-phase-settings').then(m => ({ default: m.PdfPhaseSettings })));

export function PhaseStepper({ statuses, className }: PhaseStepperProps) {
  const [settingsOpen, setSettingsOpen] = React.useState(false);
  const [forceRecreate, setForceRecreate] = React.useState<boolean>(false);
  const [phase, setPhase] = useAtom(activePdfPhaseAtom);
  const activeLibraryId = useAtomValue(activeLibraryIdAtom);
  const item = useAtomValue(selectedFileAtom);
  const { provider, refreshItems } = useStorage();
  const pdfOverrides = useAtomValue(pdfOverridesAtom);

  function canRun(): boolean {
    return Boolean(provider && activeLibraryId && item && item.type === 'file');
  }

  function buildOptions(targetPhase: PdfPhase): PdfTransformOptions | null {
    if (!provider || !activeLibraryId || !item || item.type !== 'file') return null;
    const defaults = getEffectivePdfDefaults(activeLibraryId, loadPdfDefaults(activeLibraryId), pdfOverrides);
    const base: PdfTransformOptions = {
      targetLanguage: typeof defaults.targetLanguage === 'string' ? defaults.targetLanguage : 'de',
      fileName: TransformService.generateShadowTwinName(item.metadata.name, typeof defaults.targetLanguage === 'string' ? defaults.targetLanguage : 'de'),
      createShadowTwin: true,
      fileExtension: 'md',
      extractionMethod: typeof defaults.extractionMethod === 'string' ? defaults.extractionMethod : 'native',
      useCache: defaults.useCache ?? true,
      includeImages: defaults.includeImages ?? false,
      template: typeof defaults.template === 'string' ? defaults.template : undefined,
    };
    return {
      ...base,
      doExtractPDF: targetPhase >= 1,
      doExtractMetadata: targetPhase >= 2,
      doIngestRAG: targetPhase >= 3,
      // Erzwingen: nur für Extraktion relevant (Phase 1)
      forceRecreate: forceRecreate && targetPhase >= 1 ? true : false,
    };
  }

  async function runPhase(targetPhase: PdfPhase = phase) {
    try {
      if (!canRun()) {
        toast.error('Fehler', { description: 'Kein Dokument/Provider verfügbar' });
        return;
      }
      const bin = await provider!.getBinary(item!.id);
      const file = new File([bin.blob], item!.metadata.name, { type: item!.metadata.mimeType });
      const options = buildOptions(targetPhase);
      if (!options) {
        toast.error('Fehler', { description: 'Optionen konnten nicht erstellt werden' });
        return;
      }
      // Keine Persistenz hier; Overrides bleiben bis zum Reload
      await TransformService.transformPdf(file, item!, options, provider!, refreshItems, activeLibraryId!);
      toast.success('Gestartet', { description: `Bis Phase ${targetPhase} angestoßen` });
    } catch (err) {
      const msg = err instanceof Error ? err.message : 'Unbekannter Fehler';
      toast.error('Start fehlgeschlagen', { description: msg });
    }
  }

  function badgeColor(status?: "completed" | "in_progress" | "failed" | "pending") {
    if (status === 'completed') return 'bg-green-500';
    if (status === 'in_progress') return 'bg-amber-500';
    if (status === 'failed') return 'bg-red-500';
    return 'bg-muted-foreground/40';
  }

  function buttonStyle(isActive: boolean, _status?: "completed" | "in_progress" | "failed" | "pending") {
    return cn(
      "px-2 py-1 text-xs rounded border",
      isActive ? "bg-primary text-primary-foreground" : "bg-muted hover:bg-muted/70",
    );
  }

  function renderButton(id: PdfPhase, label: string, status?: "completed" | "in_progress" | "failed" | "pending") {
    const isActive = phase === id;
    return (
      <div key={id} className="flex items-center gap-1">
        <button
          type="button"
          className={buttonStyle(isActive, status)}
          onClick={() => setPhase(id)}
          aria-pressed={isActive}
          aria-label={`Phase ${id}: ${label}`}
          title={`${label} auswählen`}
        >
          <span className="mr-2 hidden sm:inline">{label}</span>
          <span className="inline-flex items-center justify-center h-2.5 w-2.5 rounded-full ml-0.5">
            <span className={`inline-block h-2.5 w-2.5 rounded-full ${badgeColor(status)}`} />
          </span>
        </button>
        <button
          type="button"
          className="inline-flex h-6 w-6 items-center justify-center rounded border bg-background hover:bg-muted text-muted-foreground"
          onClick={() => void runPhase(id)}
          title={`Bis ${label} ausführen`}
          aria-label={`Bis ${label} ausführen`}
          disabled={!canRun()}
        >
          <Play className="h-3.5 w-3.5" />
        </button>
      </div>
    );
  }

  return (
    <div className={cn("flex items-center gap-2", className)}>
      {renderButton(1, "Extraktion", statuses?.p1)}
      {renderButton(2, "Metadaten", statuses?.p2)}
      {renderButton(3, "Ingestion", statuses?.p3)}
      <div className="ml-auto flex items-center gap-2">
        <label className="flex items-center gap-2 text-xs select-none">
          <input
            type="checkbox"
            className="h-3.5 w-3.5 accent-foreground"
            checked={forceRecreate}
            onChange={(e) => setForceRecreate(e.target.checked)}
          />
          Erzwingen
        </label>
        <Button size="sm" variant="secondary" onClick={() => void runPhase()} disabled={!canRun()} title="Ausgewählte Phase starten">
          <Play className="h-3.5 w-3.5 mr-1" /> Starten
        </Button>
        <Button size="icon" variant="ghost" title="Standardwerte anpassen" onClick={() => setSettingsOpen(true)}>
          <Settings2 className="h-4 w-4" />
        </Button>
      </div>
      {settingsOpen && (
        <React.Suspense>
          <PdfPhaseSettings open={settingsOpen} onOpenChange={setSettingsOpen} />
        </React.Suspense>
      )}
    </div>
  );
}



```

```typescriptreact
'use client';

import { useCallback, useEffect, useMemo, useState } from 'react';
import { useAtomValue } from 'jotai';
import { activeLibraryIdAtom, currentFolderIdAtom } from '@/atoms/library-atom';
import { useStorage } from '@/contexts/storage-context';
import { StorageItem } from '@/lib/storage/types';
import { Button } from '@/components/ui/button';
import { Checkbox } from '@/components/ui/checkbox';
import { Label } from '@/components/ui/label';
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
} from '@/components/ui/dialog';
import { ScrollArea } from '@/components/ui/scroll-area';
import { Separator } from '@/components/ui/separator';
import { FileLogger } from '@/lib/debug/logger';
import { toast } from '@/components/ui/use-toast';
import { loadPdfDefaults } from '@/lib/pdf-defaults';
import { pdfOverridesAtom, getEffectivePdfDefaults } from '@/atoms/pdf-defaults';
import { PdfPhaseSettings } from '@/components/library/pdf-phase-settings';
import { Settings } from 'lucide-react';

interface PdfBulkImportDialogProps {
  open: boolean;
  onOpenChange: (open: boolean) => void;
}

interface ScanStats {
  totalPdfs: number;
  skippedExisting: number;
  toProcess: number;
}

export function PdfBulkImportDialog({ open, onOpenChange }: PdfBulkImportDialogProps) {
  const { provider } = useStorage();
  const rootFolderId = useAtomValue(currentFolderIdAtom);
  const activeLibraryId = useAtomValue(activeLibraryIdAtom);
  const pdfOverrides = useAtomValue(pdfOverridesAtom);

  const [settingsOpen, setSettingsOpen] = useState(false);
  const [isScanning, setIsScanning] = useState(false);
  const [isEnqueuing, setIsEnqueuing] = useState(false);
  const [candidates, setCandidates] = useState<Array<{ file: StorageItem; parentId: string }>>([]);
  const [previewItems, setPreviewItems] = useState<Array<{ id: string; name: string; relPath: string; pages?: number }>>([]);
  const [stats, setStats] = useState<ScanStats>({ totalPdfs: 0, skippedExisting: 0, toProcess: 0 });
  const [batchName, setBatchName] = useState<string>('');

  // Phasensteuerung: Standard nur Phase 1 (Extraktion)
  const [runMetaPhase, setRunMetaPhase] = useState<boolean>(false); // Phase 2
  const [runIngestionPhase, setRunIngestionPhase] = useState<boolean>(false); // Phase 3
  // Erzwingen pro Phase
  const [forceExtract, setForceExtract] = useState<boolean>(false);
  const [forceMeta, setForceMeta] = useState<boolean>(false);

  // Shadow-Twin Erkennung (z. B. name.de.md)
  const shadowTwinRegex = useMemo(() => /^(.+)\.(de|en|fr|es|it)\.md$/i, []);

  const getBaseName = useCallback((name: string): string => {
    const lastDot = name.lastIndexOf('.');
    return lastDot === -1 ? name : name.substring(0, lastDot);
  }, []);

  const hasTwinInFolder = useCallback(
    (siblings: StorageItem[], pdfBase: string, lang?: string): boolean => {
      if (lang) {
        const expected = `${pdfBase}.${lang}.md`;
        return siblings.some((i) => i.type === 'file' && i.metadata.name.toLowerCase() === expected.toLowerCase());
      }
      // Fallback: irgendein Twin in beliebiger Sprache
      return siblings.some((i) => i.type === 'file' && shadowTwinRegex.test(i.metadata.name));
    },
    [shadowTwinRegex]
  );

  // rekursiver Scan
  const scanFolder = useCallback(async (folderId: string) => {
    if (!provider) return { total: 0, skipped: 0, selected: [] as Array<{ file: StorageItem; parentId: string }>, previews: [] as string[] };

    const stack: string[] = [folderId];
    let total = 0;
    let skipped = 0;
    const selected: Array<{ file: StorageItem; parentId: string }> = [];
    const previews: string[] = [];

    while (stack.length) {
      const current = stack.pop() as string;
      let items: StorageItem[] = [];
      try {
        items = await provider.listItemsById(current);
      } catch (error) {
        FileLogger.error('PdfBulkImportDialog', 'Fehler beim Listen eines Ordners', { folderId: current, error });
        continue;
      }

      const folders = items.filter((i) => i.type === 'folder');
      folders.forEach((f) => stack.push(f.id));

      const files = items.filter((i) => i.type === 'file');
      for (const file of files) {
        const name = file.metadata.name.toLowerCase();
        const isPdf = name.endsWith('.pdf') || file.metadata.mimeType?.toLowerCase() === 'application/pdf';
        if (!isPdf) continue;
        total++;

        const base = getBaseName(file.metadata.name);
        const defaults = activeLibraryId ? loadPdfDefaults(activeLibraryId) : {};
        const lang = (defaults as { targetLanguage?: string }).targetLanguage || 'de';
        // Batch-Scan soll auch bei Phase 1+2 ohne vorhandenen Twin zulassen → kein Twin-Zwang hier
        const requireTwin = false;
        if (requireTwin && !hasTwinInFolder(items, base, lang)) {
          skipped++;
          continue;
        }
        selected.push({ file, parentId: current });
        if (previews.length < 10) previews.push(file.metadata.name);
      }
    }

    return { total, skipped, selected, previews };
  }, [provider, getBaseName, hasTwinInFolder, runMetaPhase, runIngestionPhase]);

  const handleScan = useCallback(async () => {
    if (!provider || !rootFolderId) return;
    setIsScanning(true);
    setCandidates([]);
    setPreviewItems([]);
    try {
      const result = await scanFolder(rootFolderId);
      setCandidates(result.selected);
      // Vorschau-Details (max. 10) berechnen: relativer Pfad + Dateiname
      const top = result.selected.slice(0, 10);
      const details: Array<{ id: string; name: string; relPath: string; pages?: number }> = [];
      for (const { file, parentId } of top) {
        let relPath = '.';
        try {
          const chain = await provider.getPathItemsById(parentId);
          const idx = chain.findIndex((it) => it.id === rootFolderId);
          const start = idx >= 0 ? idx + 1 : 1; // nach aktuellem Root bzw. nach globalem Root
          const parts = chain.slice(start).map((it) => it.metadata.name).filter(Boolean);
          relPath = parts.length ? parts.join('/') : '.';
        } catch {
          relPath = '.';
        }
        details.push({ id: file.id, name: file.metadata.name, relPath });
      }
      setPreviewItems(details);
      setStats({ totalPdfs: result.total, skippedExisting: result.skipped, toProcess: result.selected.length });
    } finally {
      setIsScanning(false);
    }
  }, [provider, rootFolderId, scanFolder]);

  useEffect(() => {
    if (open) {
      // Bei Öffnen initial Scannen
      void handleScan();
      // Batch-Name vorbelegen: relativer Pfad des aktuellen Ordners (ohne führenden '/')
      (async () => {
        try {
          if (!provider || !rootFolderId) return;
          // Inklusive aktuellem Ordnernamen
          const chain = await provider.getPathItemsById(rootFolderId);
          const parts = chain
            .filter((it) => it.id !== 'root')
            .map((it) => (it as { metadata?: { name?: string } }).metadata?.name)
            .filter((n): n is string => typeof n === 'string' && !!n);
          const rel = parts.join('/') || 'root';
          setBatchName((prev) => prev && prev.trim().length > 0 ? prev : rel);
        } catch {
          // ignorieren
        }
      })();
    }
  }, [open, handleScan]);

  // keine lokale Optionsbearbeitung nötig; Änderungen erfolgen im Settings-Dialog

  const handleEnqueue = useCallback(async () => {
    if (!activeLibraryId) return;
    if (candidates.length === 0) return;
    setIsEnqueuing(true);
    try {
      const defaults = getEffectivePdfDefaults(activeLibraryId, loadPdfDefaults(activeLibraryId), pdfOverrides);
      const payload = {
        libraryId: activeLibraryId,
        batchName: (batchName || '').trim() || undefined,
        options: {
          targetLanguage: typeof defaults.targetLanguage === 'string' ? defaults.targetLanguage : 'de',
          extractionMethod: typeof defaults.extractionMethod === 'string' ? defaults.extractionMethod : 'native',
          includeImages: defaults.includeImages ?? false,
          useCache: defaults.useCache ?? true,
          template: typeof defaults.template === 'string' ? defaults.template : undefined,
          doExtractMetadata: !!runMetaPhase,
          doIngestRAG: !!runIngestionPhase,
          // Erzwingen-Logik: forceRecreate gilt nur für Phase 1; für Phase 2 erzwingen wir immer Template, auch wenn Extraktion übersprungen wird
          forceRecreate: !!forceExtract,
          forceTemplate: !!forceMeta,
        },
        items: candidates.map(({ file, parentId }) => ({ fileId: file.id, parentId, name: file.metadata.name, mimeType: file.metadata.mimeType })),
      };
      const requestPromise = fetch('/api/secretary/process-pdf/batch', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(payload),
      });
      // Dialog sofort schließen; Server arbeitet im Hintergrund
      onOpenChange(false);
      const res = await requestPromise;
      if (!res.ok) {
        const msg = await res.text().catch(() => res.statusText);
        toast({ title: 'Batch fehlgeschlagen', description: msg, variant: 'destructive' });
      } else {
        const json = await res.json().catch(() => ({} as Record<string, unknown>));
        const okCount = Number((json as { okCount?: number }).okCount || 0);
        const failCount = Number((json as { failCount?: number }).failCount || 0);
        toast({ title: 'Batch gestartet', description: `Gestartet: ${okCount}, fehlgeschlagen: ${failCount}` });
      }
    } finally {
      setIsEnqueuing(false);
    }
  }, [activeLibraryId, candidates, runMetaPhase, runIngestionPhase, onOpenChange, pdfOverrides, provider]);

  return (
    <Dialog open={open} onOpenChange={onOpenChange}>
      <DialogContent className="max-w-3xl">
        <DialogHeader>
          <DialogTitle className="flex items-center justify-between">
            <span>PDF-Verzeichnis verarbeiten</span>
            <Button variant="ghost" size="icon" onClick={() => setSettingsOpen(true)} title="PDF-Standardwerte öffnen">
              <Settings className="h-4 w-4" />
            </Button>
          </DialogTitle>
          <DialogDescription>
            Verwendet die PDF-Standardwerte der aktiven Library. Parameter können über das Zahnrad angepasst werden.
          </DialogDescription>
        </DialogHeader>

        <div className="space-y-4">
          {/* Hinweisblock entfernt: Idempotenz/Gates übernehmen das Überspringen automatisch */}

          <div className="rounded-md border p-3">
            <div className="text-sm font-medium mb-2">Phasen</div>
            <div className="flex flex-col gap-2 text-sm">
              <div className="flex items-center gap-2 text-muted-foreground">
                <Checkbox id="phase-1" checked disabled />
                <Label htmlFor="phase-1">Phase 1: Extraktion (Methode: 
                  <span>
                    {(() => {
                      const eff = getEffectivePdfDefaults(activeLibraryId, loadPdfDefaults(activeLibraryId), pdfOverrides);
                      return eff.extractionMethod;
                    })()})
                  </span>
                </Label>
                <div className="ml-auto flex items-center gap-2">
                  <Checkbox id="force-extract" checked={forceExtract} onCheckedChange={(v) => setForceExtract(Boolean(v))} />
                  <Label htmlFor="force-extract">Erzwingen</Label>
                </div>
              </div>
              <div className="flex items-center gap-2">
                <Checkbox id="phase-2" checked={runMetaPhase} onCheckedChange={(v) => setRunMetaPhase(Boolean(v))} />
                <Label htmlFor="phase-2">Phase 2: Metadaten (Template: 
                  <span>                    
                    {(() => {
                      const eff = getEffectivePdfDefaults(activeLibraryId, loadPdfDefaults(activeLibraryId), pdfOverrides);
                      return eff.template;
                    })()}
                  )
                  </span>
                </Label>
                <div className="ml-auto flex items-center gap-2">
                  <Checkbox id="force-meta" checked={forceMeta} onCheckedChange={(v) => setForceMeta(Boolean(v))} disabled={!runMetaPhase} />
                  <Label htmlFor="force-meta" className={runMetaPhase ? '' : 'text-muted-foreground'}>Erzwingen</Label>
                </div>
              </div>
              <div className="flex items-center gap-2">
                <Checkbox id="phase-3" checked={runIngestionPhase} onCheckedChange={(v) => setRunIngestionPhase(Boolean(v))} />
                <Label htmlFor="phase-3">Phase 3: RAG-Ingestion</Label>
              </div>
            </div>
          </div>

          {/* PDF-Standardwerte werden aus der Library geladen; Anpassung über das Zahnrad oben */}

          <div className="rounded-md border p-3">
            <div className="mb-2">
              <Label htmlFor="batch-name">Batch-Name</Label>
              <input id="batch-name" className="mt-1 w-full border rounded px-2 py-1 text-sm" placeholder="z.B. Ordnername" value={batchName} onChange={(e) => setBatchName(e.target.value)} />
            </div>
            <div className="flex items-center justify-between text-sm">
              <div className="flex gap-4">
                <div>
                  <span className="text-muted-foreground">Gesamt PDFs:</span> <span className="font-medium">{stats.totalPdfs}</span>
                </div>
                <div>
                  <span className="text-muted-foreground">Ignoriert:</span> <span className="font-medium">{stats.skippedExisting}</span>
                </div>
                <div>
                  <span className="text-muted-foreground">Zu verarbeiten:</span> <span className="font-medium">{stats.toProcess}</span>
                </div>
              </div>
              <Button variant="outline" size="sm" onClick={handleScan} disabled={isScanning}>
                {isScanning ? 'Scan läuft…' : 'Neu scannen'}
              </Button>
            </div>
            <Separator className="my-3" />
            <ScrollArea className="h-40">
              {previewItems.length === 0 ? (
                <div className="text-sm text-muted-foreground">Keine Kandidaten gefunden.</div>
              ) : (
                <ul className="text-sm space-y-2">
                  {previewItems.map((it) => (
                    <li key={it.id} className="flex items-start justify-between gap-3">
                      <div className="min-w-0">
                        <div className="text-muted-foreground truncate">{it.relPath}</div>
                        <div className="font-medium break-all">{it.name}</div>
                      </div>
                      <div className="shrink-0 text-muted-foreground whitespace-nowrap">Seiten: —</div>
                    </li>
                  ))}
                </ul>
              )}
            </ScrollArea>
          </div>
        </div>

        <DialogFooter>
          <Button variant="outline" onClick={() => onOpenChange(false)} disabled={isEnqueuing || isScanning}>Abbrechen</Button>
          <Button onClick={handleEnqueue} disabled={isEnqueuing || isScanning || candidates.length === 0}>
            {isEnqueuing ? 'Wird gestartet…' : `Jobs starten (${candidates.length})`}
          </Button>
        </DialogFooter>
        <PdfPhaseSettings open={settingsOpen} onOpenChange={setSettingsOpen} />
      </DialogContent>
    </Dialog>
  );
}

export default PdfBulkImportDialog;



```

```typescript
import { NextRequest, NextResponse } from 'next/server';
import { getAuth, currentUser } from '@clerk/nextjs/server';
import { FileLogger } from '@/lib/debug/logger';
import crypto from 'crypto';

// Batch-Submit: Erwartet JSON mit items[] (each: { fileId, parentId, name, mimeType }) und optionalen Optionen/Batch-Metadaten
// Server lädt Binärdaten per Server-Storage, reicht an die bestehende process-pdf Route weiter.

interface BatchItemInput {
  fileId: string;
  parentId: string;
  name?: string;
  mimeType?: string;
}

interface BatchRequestBody {
  libraryId: string;
  batchName?: string;
  options?: {
    targetLanguage?: string;
    extractionMethod?: string;
    includeImages?: boolean;
    useCache?: boolean;
    template?: string;
    doExtractMetadata?: boolean;
    doIngestRAG?: boolean;
    forceRecreate?: boolean;
    forceTemplate?: boolean;
  };
  items: BatchItemInput[];
}

export async function POST(request: NextRequest) {
  try {
    const { userId } = getAuth(request);
    if (!userId) return NextResponse.json({ error: 'Nicht authentifiziert' }, { status: 401 });
    const user = await currentUser();
    const userEmail = user?.emailAddresses?.[0]?.emailAddress || '';
    if (!userEmail) return NextResponse.json({ error: 'Benutzer-E-Mail nicht verfügbar' }, { status: 403 });

    const contentType = request.headers.get('content-type') || '';
    if (!contentType.includes('application/json')) {
      return NextResponse.json({ error: 'Content-Type application/json erwartet' }, { status: 415 });
    }

    const body = await request.json() as unknown as BatchRequestBody;
    const libraryId = typeof body?.libraryId === 'string' ? body.libraryId : '';
    const items = Array.isArray(body?.items) ? body.items : [];
    const batchName = typeof body?.batchName === 'string' ? body.batchName : undefined;
    const options = body?.options || {};
    if (!libraryId || items.length === 0) {
      return NextResponse.json({ error: 'libraryId und items erforderlich' }, { status: 400 });
    }

    // Serverseitige Parallelität begrenzen (z. B. 5)
    const concurrency = 5;
    // Eindeutige Batch-ID generieren, für zuverlässiges Grouping unabhängig vom Namen
    const batchId = crypto.randomUUID();

    // Worker-Funktion: reiche einzelne Datei weiter an process-pdf
    const submitOne = async (it: BatchItemInput): Promise<{ ok: boolean; jobId?: string; error?: string }> => {
      try {
        // Hole Datei-Binärdaten via interner API, um Code-Duplizierung zu vermeiden
        // Wir nutzen die bestehende Client-Route, indem wir eine FormData bauen und lokal requesten
        // Vorteil: die gesamte Job-Anlage/Idempotenz bleibt an einem Ort
        const fd = new FormData();
        // Holen der Datei aus dem Storage muss in der Zielroute passieren; hier nur Metadaten weitergeben
        // Aber unsere bestehende process-pdf Route erwartet die Datei bereits. Daher rufen wir sie nicht direkt hier,
        // sondern nutzen einen vereinfachten Pfad: Der Client übergibt im Normalfall Binärdaten.
        // Für serverseitige Batch-Einreichung wählen wir den robusteren Weg: lade die Datei serverseitig und reiche mit.
        const { getServerProvider } = await import('@/lib/storage/server-provider');
        const provider = await getServerProvider(userEmail, libraryId);
        const bin = await provider.getBinary(it.fileId);
        const blob = bin.blob;
        const filename = it.name || 'document.pdf';
        const file = new File([blob], filename, { type: it.mimeType || bin.mimeType || 'application/pdf' });

        fd.append('file', file);
        fd.append('originalItemId', it.fileId);
        fd.append('parentId', it.parentId);
        if (options?.targetLanguage) fd.append('targetLanguage', options.targetLanguage);
        if (options?.extractionMethod) fd.append('extractionMethod', options.extractionMethod);
        if (typeof options?.includeImages === 'boolean') fd.append('includeImages', String(options.includeImages));
        if (typeof options?.useCache === 'boolean') fd.append('useCache', String(options.useCache));
        if (typeof options?.template === 'string') fd.append('template', options.template);
        if (typeof options?.doExtractMetadata === 'boolean') fd.append('doExtractMetadata', String(options.doExtractMetadata));
        if (typeof options?.doIngestRAG === 'boolean') fd.append('doIngestRAG', String(options.doIngestRAG));
        if (typeof options?.forceRecreate === 'boolean') fd.append('forceRecreate', String(options.forceRecreate));
        if (typeof options?.forceTemplate === 'boolean') fd.append('forceTemplate', String(options.forceTemplate));
        if (batchName) fd.append('batchName', batchName);
        fd.append('batchId', batchId);
        // Wichtig: Phase 1 standardmäßig aktivieren, damit Secretary aufgerufen wird
        fd.append('doExtractPDF', 'true');

        const res = await fetch(new URL('/api/secretary/process-pdf', request.url).toString(), {
          method: 'POST',
          headers: {
            'X-Library-Id': libraryId,
            // Clerk-Session weiterreichen, damit die Zielroute authentifiziert ist
            'Cookie': request.headers.get('cookie') || ''
          },
          body: fd,
        });
        if (!res.ok) {
          const msg = await res.text().catch(() => res.statusText);
          return { ok: false, error: msg };
        }
        const json = await res.json().catch(() => ({} as Record<string, unknown>));
        const jobId = typeof (json as { job?: { id?: string } }).job?.id === 'string' ? (json as { job: { id: string } }).job.id : undefined;
        return jobId ? { ok: true, jobId } : { ok: true };
      } catch (err) {
        const msg = err instanceof Error ? err.message : String(err);
        return { ok: false, error: msg };
      }
    }

    // Einfache Concurrency-Queue
    const results: Array<{ ok: boolean; jobId?: string; error?: string }> = [];
    let index = 0;
    const worker = async () => {
      while (true) {
        const i = index++;
        if (i >= items.length) break;
        const r = await submitOne(items[i]);
        results[i] = r;
      }
    }
    const workers = Array.from({ length: Math.min(concurrency, items.length) }, () => worker());
    await Promise.all(workers);

    const okCount = results.filter(r => r?.ok).length;
    const failCount = results.length - okCount;
    FileLogger.info('process-pdf-batch', 'Batch abgeschlossen', { okCount, failCount, batchName, batchId, total: items.length });

    return NextResponse.json({ ok: true, batchId, batchName, okCount, failCount, results });
  } catch (err) {
    return NextResponse.json({ error: err instanceof Error ? err.message : 'Unerwarteter Fehler' }, { status: 500 });
  }
}



```

Ich habe den Rahmen im PhaseStepper entfernt und den farbigen Punkt beibehalten. Zusätzlich gibt es jetzt „Erzwingen“-Toggles.

- PhaseStepper
  - Rahmen entfernt; aktive Schaltfläche ist neutral, nur der Punkt ist farbig.
  - Neuer Checkbox‑Toggle „Erzwingen“ neben „Starten“.
  - Wirkung: Setzt forceRecreate für die gestartete Phase-Kette; relevant für Phase 1 (Extraktion). Bei aktivem Toggle wird die Extraktion trotz vorhandener Artefakte neu berechnet.

- Batch-Dialog „PDF‑Verzeichnis verarbeiten“
  - Neue Checkboxen:
    - Extraktion → „Erzwingen“: reextrahiert Shadow‑Twins (forceRecreate=true).
    - Metadaten → „Erzwingen“: Metadaten werden neu aus Template berechnet (Phase 2 startet template‑only; Extraktion wird dabei nicht neu ausgeführt, sofern „Extraktion erzwingen“ aus ist).
  - Praxisfall „Nur Phase 2 erzwingen“:
    - Hake „Phase 2: Metadaten“ an.
    - Lasse „Extraktion erzwingen“ AUS.
    - Optional „Metadaten erzwingen“ AN.
    - Starte Jobs. Gate überspringt Phase 1, Phase 2 läuft template‑only und überschreibt Frontmatter.

Test
- Einzeldokument: Phase „Metadaten“ wählen, „Erzwingen“ AUS → template‑only, wenn Twin existiert; mit „Erzwingen“ AN → Extraktion wird mitgemacht.
- Batch: Mit obiger Kombination sicherstellen, dass Frontmatter aktualisiert wird, ohne PDF neu zu extrahieren. Im `JobReportTab` sollte `template_status` auf completed springen; `extract_status` bleibt unverändert oder wird übersprungen.

Kurze Nutzungshinweise
- „Erzwingen“ nur einschalten, wenn du Phase 1 neu berechnen willst.
- Für Massenkorrektur falscher Metadaten: In der Batch‑Maske nur Phase 2 aktivieren, „Extraktion erzwingen“ AUS lassen.

- Ich habe: den Rahmen entfernt, den Erzwingen‑Toggle im `PhaseStepper` eingebaut und den Batch‑Dialog um pro‑Phase „Erzwingen“-Checkboxen erweitert; Flags werden bis zur API durchgereicht.

---

**User**

Können wir nochmal diese Batch-Verarbeitung analysieren? Ich habe jetzt ein Verzeichnis mit 20 Dateien markiert und den Batch gestartet. Aber wie landen jetzt diese einzelnen Jobs in der Datenbank? In der Datenbank sehe ich nur 5, dann 6, die werden so langsam erstellt und bei 10 schlaft es alles ein. Wie ist hier der Prozess? Müssten nicht zuerst alle Jobs aus Dokumente erstellt werden, gespeichert werden und danach Schritt für Schritt abgearbeitet werden? Ist diese Persistenz in der Datenbank, wie wird die verwendet, nur zum Protokollieren am Ende, nicht zum Erstellen der Jobs?

---

**Cursor**

### Kurze Antwort
- Aktuell werden Jobs nicht „alle zuerst“ angelegt, sondern in Wellen mit begrenzter Parallelität erstellt. Deshalb siehst du anfangs 5–6 Einträge, dann tröpfelt es weiter. Die Datenbank dient nicht nur als Abschluss‑Protokoll, aber die Anlage passiert innerhalb jeder einzelnen Prozess‑Anfrage, die wir im Batch nacheinander (mit Parallelitätslimit) losschicken.
- Wenn du „alle 20 sofort in der DB sehen“ willst, müssen wir die Anlage vom eigentlichen Worker‑Start entkoppeln (zweiphasig: erst nur DB‑Eintrag, dann asynchron abarbeiten).

### Wie es jetzt wirklich läuft
- Batch‑Route (serverseitig):
  - Lädt jede Datei, baut FormData und ruft für jeden Eintrag die Einzel‑Route auf, mit Parallelität 5.
```55:59:src/app/api/secretary/process-pdf/batch/route.ts
    const concurrency = 5;
    const batchId = crypto.randomUUID();
```
```60:92:src/app/api/secretary/process-pdf/batch/route.ts
    const submitOne = async (it: BatchItemInput): Promise<{ ok: boolean; jobId?: string; error?: string }> => {
      ...
      const file = new File([blob], filename, { type: it.mimeType || bin.mimeType || 'application/pdf' });
      ...
      const res = await fetch(new URL('/api/secretary/process-pdf', request.url).toString(), { method: 'POST', ... , body: fd });
      ...
    }
```
```115:133:src/app/api/secretary/process-pdf/batch/route.ts
    const results: Array<{ ok: boolean; jobId?: string; error?: string }> = [];
    let index = 0;
    const worker = async () => {
      while (true) {
        const i = index++;
        if (i >= items.length) break;
        const r = await submitOne(items[i]);
        results[i] = r;
      }
    }
    const workers = Array.from({ length: Math.min(concurrency, items.length) }, () => worker());
    await Promise.all(workers);
```
- Einzel‑Route legt den Job in der DB an (direkt zu Beginn), initialisiert Steps und startet dann (je nach Flags) den Secretary‑Call:
```177:210:src/app/api/secretary/process-pdf/route.ts
    const job: ExternalJob = { ... };
    await repository.create(job);
    const phases = { extract: doExtractPDF, template: doExtractMetadata, ingest: doIngestRAG };
    await repository.initializeSteps(jobId, [ ... ], {
      ...,
      doExtractPDF, doExtractMetadata, doIngestRAG, forceRecreate
    });
```

### Warum es bei 5–10 „einschläft“
- Limit Parallelität=5 → maximal 5 gleichzeitige Einreichungen.
- Jede Einreichung lädt die PDF (I/O) und macht einen HTTP‑Call zum Secretary. Die Einzel‑Route hat zudem einen Timeout (Standard 5s) und weitere I/O (Clerk/Libraries, Gates).
- Dadurch erscheinen Jobs nicht „sofort alle“, sondern erst wenn jede Einreichung die DB‑Anlage passiert hat. Bei großen Dateien/Netzlatenz staut sich das und wirkt wie „hängend“.

### Was wir ändern können
- Kurzfristig (einfach):
  - Parallelität erhöhen (z. B. 10–20) und Timeout per ENV `SECRETARY_REQUEST_TIMEOUT_MS` anheben. Das beschleunigt die sichtbare DB‑Anlage, bleibt aber „submit‑gebunden“.
- Mittel (sauberer, ohne großen Umbau):
  - Zweiphasige Batch‑Einreichung:
    1) In der Batch‑Route zuerst für alle Items Jobs direkt in der DB anlegen (ohne Datei/Secretary‑Call).
    2) Danach die eigentlichen Worker‑Aufrufe asynchron mit Limit abarbeiten.
  - Ergebnis: Alle 20 erscheinen sofort in der Jobliste; Abarbeitung folgt im Hintergrund.
- Robust/Langfristig:
  - Eine echte Queue (z. B. BullMQ/Redis): Batch legt nur DB/Queue‑Einträge an; ein Worker konsumiert und führt aus. Garantierte Persistenz, Backpressure, Retry, Observability.

Willst du, dass ich:
- die Parallelität sofort auf 10 erhöhe, oder
- gleich die zweiphasige Anlage (alle Jobs sofort in DB, danach Abarbeitung) implementiere?

```typescript
    const concurrency = 5;
    const batchId = crypto.randomUUID();
```

```typescript
    const submitOne = async (it: BatchItemInput): Promise<{ ok: boolean; jobId?: string; error?: string }> => {
      ...
      const file = new File([blob], filename, { type: it.mimeType || bin.mimeType || 'application/pdf' });
      ...
      const res = await fetch(new URL('/api/secretary/process-pdf', request.url).toString(), { method: 'POST', ... , body: fd });
      ...
    }
```

```typescript
    const results: Array<{ ok: boolean; jobId?: string; error?: string }> = [];
    let index = 0;
    const worker = async () => {
      while (true) {
        const i = index++;
        if (i >= items.length) break;
        const r = await submitOne(items[i]);
        results[i] = r;
      }
    }
    const workers = Array.from({ length: Math.min(concurrency, items.length) }, () => worker());
    await Promise.all(workers);
```

```typescript
    const job: ExternalJob = { ... };
    await repository.create(job);
    const phases = { extract: doExtractPDF, template: doExtractMetadata, ingest: doIngestRAG };
    await repository.initializeSteps(jobId, [ ... ], {
      ...,
      doExtractPDF, doExtractMetadata, doIngestRAG, forceRecreate
    });
```

---

**User**

Ja, ich möchte das unbedingt zweiphasig machen. Wenn ich im Frontend eine Verzeichnisstruktur analysiere, dann können schon 300 Jobs erstellt werden. Die müssen alle möglichst sparsam in der Datenbank landen. Und dann soll der Worker Server-seitig diese Patch für Patch abarbeiten. Wenn jemand den Server neu startet, dann soll der Worker weiterarbeiten. Wir müssen das trennen. Ich hoffe, wir müssen beim Speichern der Aufträge in die Datenbank nicht alle PDF laden. Und auch nicht bestehende Markdowns öffnen.

---

**Cursor**

Ich starte mit einer kurzen Analyse der vorhandenen Batch- und Job-APIs und suche nach vorhandenen Worker-/Retry-Mechanismen. Danach skizziere und implementiere die zweiphasige Variante: 1) Batch legt nur DB-Jobs an, 2) separater Worker-Prozessor zieht pending Jobs ab (mit Concurrency) und nutzt bestehende Einzelroute für die Ausführung.

```typescript
import { Collection } from 'mongodb';
import crypto from 'crypto';
import { getCollection } from '@/lib/mongodb-service';
import { ExternalJob, ExternalJobStatus, ExternalJobStep, ExternalJobIngestionInfo } from '@/types/external-job';

export class ExternalJobsRepository {
  private collectionName = 'external_jobs';

  private async getCollection(): Promise<Collection<ExternalJob>> {
    return getCollection<ExternalJob>(this.collectionName);
  }

  hashSecret(secret: string): string {
    return crypto.createHash('sha256').update(secret).digest('hex');
  }

  async create(job: Omit<ExternalJob, 'createdAt' | 'updatedAt'>): Promise<void> {
    const col = await this.getCollection();
    const now = new Date();
    await col.insertOne({ ...job, createdAt: now, updatedAt: now });
  }

  async setStatus(jobId: string, status: ExternalJobStatus, extra: Partial<ExternalJob> = {}): Promise<boolean> {
    const col = await this.getCollection();
    const res = await col.updateOne(
      { jobId },
      { $set: { status, updatedAt: new Date(), ...extra } }
    );
    return res.modifiedCount > 0;
  }

  async setProcess(jobId: string, processId: string): Promise<void> {
    const col = await this.getCollection();
    await col.updateOne({ jobId }, { $set: { processId, updatedAt: new Date() } });
  }

  async appendLog(jobId: string, entry: Record<string, unknown>): Promise<void> {
    const col = await this.getCollection();
    await col.updateOne(
      { jobId },
      { $push: { logs: { timestamp: new Date(), ...entry } } }
    );
  }

  async setResult(jobId: string, payload: ExternalJob['payload'], result: ExternalJob['result']): Promise<void> {
    const col = await this.getCollection();
    await col.updateOne(
      { jobId },
      { $set: { payload, result, updatedAt: new Date() } }
    );
  }

  async mergeParameters(jobId: string, params: Record<string, unknown>): Promise<void> {
    const col = await this.getCollection();
    const now = new Date();
    await col.updateOne(
      { jobId },
      [
        {
          $set: {
            parameters: { $mergeObjects: [ '$parameters', params ] },
            updatedAt: now
          }
        }
      ] as unknown as Record<string, unknown>
    );
  }

  async initializeSteps(jobId: string, steps: ExternalJobStep[], parameters?: Record<string, unknown>): Promise<void> {
    const col = await this.getCollection();
    await col.updateOne(
      { jobId },
      { $set: { steps, updatedAt: new Date(), ...(parameters ? { parameters } : {}) } }
    );
  }

  async updateStep(jobId: string, name: string, patch: Partial<ExternalJobStep>): Promise<void> {
    const col = await this.getCollection();
    const now = new Date();
    const setObj = Object.fromEntries(Object.entries(patch).map(([k, v]) => ([`steps.$.${k}`, v])));
    await col.updateOne(
      { jobId, 'steps.name': name },
      { $set: { ...setObj, updatedAt: now } }
    );
  }

  async appendMeta(jobId: string, meta: Record<string, unknown>, source: string): Promise<void> {
    const col = await this.getCollection();
    const now = new Date();
    await col.updateOne(
      { jobId },
      {
        $set: { updatedAt: now },
        $push: { metaHistory: { at: now, meta, source } },
      }
    );
    // Merge cumulativeMeta (shallow)
    await col.updateOne(
      { jobId },
      [
        {
          $set: {
            cumulativeMeta: { $mergeObjects: [ '$cumulativeMeta', meta ] },
            updatedAt: now
          }
        }
      ] as unknown as Record<string, unknown>
    );
  }

  async setIngestion(jobId: string, info: ExternalJobIngestionInfo): Promise<void> {
    const col = await this.getCollection();
    await col.updateOne(
      { jobId },
      { $set: { ingestion: info, updatedAt: new Date() } }
    );
  }

  async get(jobId: string): Promise<ExternalJob | null> {
    const col = await this.getCollection();
    return col.findOne({ jobId });
  }

  async listByUserEmail(
    userEmail: string,
    options: { page?: number; limit?: number }
  ): Promise<{ items: ExternalJob[]; total: number; page: number; limit: number }>
  {
    const col = await this.getCollection();
    const page = Math.max(1, options.page ?? 1);
    const limit = Math.max(1, Math.min(100, options.limit ?? 20));
    const cursor = col
      .find({ userEmail })
      .sort({ updatedAt: -1 })
      .skip((page - 1) * limit)
      .limit(limit);
    const [items, total] = await Promise.all([
      cursor.toArray(),
      col.countDocuments({ userEmail })
    ]);
    return { items, total, page, limit };
  }

  async listByUserWithFilters(
    userEmail: string,
    options: {
      page?: number;
      limit?: number;
      status?: ExternalJobStatus | ExternalJobStatus[];
      batchName?: string;
      batchId?: string;
      libraryId?: string;
      q?: string;
    }
  ): Promise<{ items: ExternalJob[]; total: number; page: number; limit: number }>
  {
    const col = await this.getCollection();
    const page = Math.max(1, options.page ?? 1);
    const limit = Math.max(1, Math.min(100, options.limit ?? 20));

    const filter: Record<string, unknown> = { userEmail };
    if (options.libraryId) filter['libraryId'] = options.libraryId;
    if (options.batchId) filter['correlation.batchId'] = options.batchId;
    if (options.batchName) filter['correlation.batchName'] = options.batchName;
    if (options.status) {
      const statuses = Array.isArray(options.status) ? options.status : [options.status];
      filter['status'] = { $in: statuses };
    }
    if (options.q) {
      const rx = new RegExp(options.q.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'i');
      filter['$or'] = [
        { 'correlation.source.name': rx },
        { 'correlation.source.itemId': rx },
        { jobId: rx },
      ];
    }

    const cursor = col
      .find(filter)
      .sort({ updatedAt: -1 })
      .skip((page - 1) * limit)
      .limit(limit);
    const [items, total] = await Promise.all([
      cursor.toArray(),
      col.countDocuments(filter)
    ]);
    return { items, total, page, limit };
  }

  async findLatestBySourceItem(userEmail: string, libraryId: string, sourceItemId: string): Promise<ExternalJob | null> {
    const col = await this.getCollection();
    return col.find({ userEmail, libraryId, 'correlation.source.itemId': sourceItemId }).sort({ updatedAt: -1 }).limit(1).next();
  }

  async findLatestByResultItem(userEmail: string, resultItemId: string): Promise<ExternalJob | null> {
    const col = await this.getCollection();
    return col.find({ userEmail, 'result.savedItemId': resultItemId }).sort({ updatedAt: -1 }).limit(1).next();
  }

  async findLatestByFileIdAuto(userEmail: string, libraryId: string, fileId: string): Promise<ExternalJob | null> {
    const col = await this.getCollection();
    return col.find({
      userEmail,
      libraryId,
      $or: [
        { 'correlation.source.itemId': fileId },
        { 'result.savedItemId': fileId }
      ]
    }).sort({ updatedAt: -1 }).limit(1).next();
  }

  async findLatestBySourceName(userEmail: string, libraryId: string, sourceName: string): Promise<ExternalJob | null> {
    const col = await this.getCollection();
    return col.find({ userEmail, libraryId, 'correlation.source.name': sourceName }).sort({ updatedAt: -1 }).limit(1).next();
  }

  async listDistinctBatchNames(userEmail: string, libraryId?: string): Promise<string[]> {
    const col = await this.getCollection();
    const match: Record<string, unknown> = {
      userEmail,
      'correlation.batchName': { $type: 'string', $ne: '' }
    };
    if (libraryId) match['libraryId'] = libraryId;
    const rows = await col.aggregate<{ _id: string }>([
      { $match: match },
      { $group: { _id: '$correlation.batchName' } },
      { $sort: { _id: 1 } }
    ]).toArray();
    return rows.map(r => r._id).filter((v): v is string => typeof v === 'string' && v.length > 0);
  }

  async countByStatus(
    userEmail: string,
    filters: { libraryId?: string; batchName?: string; batchId?: string }
  ): Promise<{ queued: number; running: number; completed: number; failed: number; pendingStorage: number; total: number }>
  {
    const col = await this.getCollection();
    const match: Record<string, unknown> = { userEmail };
    if (filters.libraryId) match['libraryId'] = filters.libraryId;
    if (filters.batchId) match['correlation.batchId'] = filters.batchId;
    if (filters.batchName) match['correlation.batchName'] = filters.batchName;

    const rows = await col.aggregate<{ _id: string; count: number }>([
      { $match: match },
      { $group: { _id: '$status', count: { $sum: 1 } } }
    ]).toArray();
    const by: Record<string, number> = Object.fromEntries(rows.map(r => [r._id, r.count]));
    const queued = by['queued'] || 0;
    const running = by['running'] || 0;
    const completed = by['completed'] || 0;
    const failed = by['failed'] || 0;
    const pendingStorage = by['pending-storage'] || 0;
    const total = queued + running + completed + failed + pendingStorage;
    return { queued, running, completed, failed, pendingStorage, total };
  }

  // ---- Worker-Unterstützung ----
  async claimNextQueuedJob(): Promise<ExternalJob | null> {
    const col = await this.getCollection();
    const now = new Date();
    const res = await col.findOneAndUpdate(
      { status: 'queued' },
      { $set: { status: 'running', updatedAt: now } },
      { sort: { updatedAt: 1 }, returnDocument: 'after' }
    );
    return (res && (res as { value?: ExternalJob }).value) || null;
  }

  async listQueued(limit: number = 50): Promise<ExternalJob[]> {
    const col = await this.getCollection();
    return col.find({ status: 'queued' }).sort({ updatedAt: 1 }).limit(Math.max(1, Math.min(500, limit)) ).toArray();
  }
}



```

```typescript
<<'PATCH'
*** Begin Patch
*** Update File: src/app/api/secretary/process-pdf/batch/route.ts
@@
-import { NextRequest, NextResponse } from 'next/server';
-import { getAuth, currentUser } from '@clerk/nextjs/server';
-import { FileLogger } from '@/lib/debug/logger';
-import crypto from 'crypto';
+import { NextRequest, NextResponse } from 'next/server';
+import { getAuth, currentUser } from '@clerk/nextjs/server';
+import { FileLogger } from '@/lib/debug/logger';
+import crypto from 'crypto';
+import { ExternalJobsRepository } from '@/lib/external-jobs-repository';
@@
-interface BatchRequestBody {
+interface BatchRequestBody {
   libraryId: string;
   batchName?: string;
   options?: {
     targetLanguage?: string;
     extractionMethod?: string;
     includeImages?: boolean;
     useCache?: boolean;
     template?: string;
     doExtractMetadata?: boolean;
     doIngestRAG?: boolean;
     forceRecreate?: boolean;
     forceTemplate?: boolean;
   };
   items: BatchItemInput[];
 }
@@
-export async function POST(request: NextRequest) {
+export async function POST(request: NextRequest) {
   try {
@@
-    // Worker-Funktion: reiche einzelne Datei weiter an process-pdf
-    const submitOne = async (it: BatchItemInput): Promise<{ ok: boolean; jobId?: string; error?: string }> => {
+    // Zwei-Phasen: 1) DB‑Jobs anlegen (nur Metadaten), 2) Verarbeitung asynchron anstoßen
+
+    // Phase 1: Alle Jobs in DB anlegen (queued) – ohne PDFs zu laden
+    const repo = new ExternalJobsRepository();
+    const createdJobIds: string[] = [];
+    for (const it of items) {
+      try {
+        const jobId = crypto.randomUUID();
+        const jobSecret = crypto.randomBytes(24).toString('base64url');
+        const jobSecretHash = repo.hashSecret(jobSecret);
+        const correlation = {
+          jobId,
+          libraryId,
+          source: { mediaType: 'pdf', mimeType: it.mimeType || 'application/pdf', name: it.name || 'document.pdf', itemId: it.fileId, parentId: it.parentId },
+          options: {
+            targetLanguage: options?.targetLanguage || 'de',
+            extractionMethod: options?.extractionMethod || 'native',
+            includeImages: options?.includeImages ?? false,
+            useCache: options?.useCache ?? true,
+          }
+        } as const;
+        await repo.create({
+          jobId,
+          jobSecretHash,
+          job_type: 'pdf',
+          operation: 'extract',
+          worker: 'secretary',
+          status: 'queued',
+          libraryId,
+          userEmail,
+          correlation,
+          createdAt: new Date(),
+          updatedAt: new Date(),
+          steps: [
+            { name: 'extract_pdf', status: 'pending' },
+            { name: 'transform_template', status: 'pending' },
+            { name: 'store_shadow_twin', status: 'pending' },
+            { name: 'ingest_rag', status: 'pending' },
+          ],
+          parameters: {
+            targetLanguage: options?.targetLanguage || 'de',
+            extractionMethod: options?.extractionMethod || 'native',
+            includeImages: options?.includeImages ?? false,
+            useCache: options?.useCache ?? true,
+            template: options?.template,
+            doExtractPDF: true,
+            doExtractMetadata: !!options?.doExtractMetadata,
+            doIngestRAG: !!options?.doIngestRAG,
+            forceRecreate: !!options?.forceRecreate,
+            forceTemplate: !!options?.forceTemplate,
+            batchId,
+            batchName,
+          }
+        } as any);
+        createdJobIds.push(jobId);
+      } catch (e) {
+        FileLogger.error('process-pdf-batch', 'Job-Anlage fehlgeschlagen', { error: e instanceof Error ? e.message : String(e) });
+      }
+    }
+
+    // Phase 2: Asynchron verarbeiten (ohne Antwort zu blockieren) – limitiert parallel
+    const concurrency = 5;
+    const submitOne = async (jobId: string, it: BatchItemInput): Promise<{ ok: boolean; jobId?: string; error?: string }> => {
       try {
-        // Hole Datei-Binärdaten via interner API, um Code-Duplizierung zu vermeiden
-        // Wir nutzen die bestehende Client-Route, indem wir eine FormData bauen und lokal requesten
-        // Vorteil: die gesamte Job-Anlage/Idempotenz bleibt an einem Ort
+        // Hole Datei-Binärdaten und reiche an die bestehende Einzel‑Route weiter
         const fd = new FormData();
-        // Holen der Datei aus dem Storage muss in der Zielroute passieren; hier nur Metadaten weitergeben
-        // Aber unsere bestehende process-pdf Route erwartet die Datei bereits. Daher rufen wir sie nicht direkt hier,
-        // sondern nutzen einen vereinfachten Pfad: Der Client übergibt im Normalfall Binärdaten.
-        // Für serverseitige Batch-Einreichung wählen wir den robusteren Weg: lade die Datei serverseitig und reiche mit.
         const { getServerProvider } = await import('@/lib/storage/server-provider');
         const provider = await getServerProvider(userEmail, libraryId);
-        const bin = await provider.getBinary(it.fileId);
+        const bin = await provider.getBinary(it.fileId);
         const blob = bin.blob;
         const filename = it.name || 'document.pdf';
         const file = new File([blob], filename, { type: it.mimeType || bin.mimeType || 'application/pdf' });
 
         fd.append('file', file);
         fd.append('originalItemId', it.fileId);
         fd.append('parentId', it.parentId);
         if (options?.targetLanguage) fd.append('targetLanguage', options.targetLanguage);
         if (options?.extractionMethod) fd.append('extractionMethod', options.extractionMethod);
         if (typeof options?.includeImages === 'boolean') fd.append('includeImages', String(options.includeImages));
         if (typeof options?.useCache === 'boolean') fd.append('useCache', String(options.useCache));
         if (typeof options?.template === 'string') fd.append('template', options.template);
         if (typeof options?.doExtractMetadata === 'boolean') fd.append('doExtractMetadata', String(options.doExtractMetadata));
         if (typeof options?.doIngestRAG === 'boolean') fd.append('doIngestRAG', String(options.doIngestRAG));
         if (typeof options?.forceRecreate === 'boolean') fd.append('forceRecreate', String(options.forceRecreate));
         if (typeof options?.forceTemplate === 'boolean') fd.append('forceTemplate', String(options.forceTemplate));
         if (batchName) fd.append('batchName', batchName);
         fd.append('batchId', batchId);
-        // Wichtig: Phase 1 standardmäßig aktivieren, damit Secretary aufgerufen wird
+        // Wichtig: Phase 1 standardmäßig aktivieren, damit Secretary/Template je nach Flags ausgeführt wird
         fd.append('doExtractPDF', 'true');
 
         const res = await fetch(new URL('/api/secretary/process-pdf', request.url).toString(), {
           method: 'POST',
           headers: {
             'X-Library-Id': libraryId,
             // Clerk-Session weiterreichen, damit die Zielroute authentifiziert ist
             'Cookie': request.headers.get('cookie') || ''
           },
           body: fd,
         });
         if (!res.ok) {
           const msg = await res.text().catch(() => res.statusText);
           return { ok: false, error: msg };
         }
         const json = await res.json().catch(() => ({} as Record<string, unknown>));
         const returnedJobId = typeof (json as { job?: { id?: string } }).job?.id === 'string' ? (json as { job: { id: string } }).job.id : undefined;
-        return returnedJobId ? { ok: true, jobId: returnedJobId } : { ok: true };
+        return { ok: true, jobId: returnedJobId || jobId };
       } catch (err) {
         const msg = err instanceof Error ? err.message : String(err);
         return { ok: false, error: msg };
       }
     }
 
-    // Einfache Concurrency-Queue
-    const results: Array<{ ok: boolean; jobId?: string; error?: string }> = [];
-    let index = 0;
-    const worker = async () => {
-      while (true) {
-        const i = index++;
-        if (i >= items.length) break;
-        const r = await submitOne(items[i]);
-        results[i] = r;
-      }
-    }
-    const workers = Array.from({ length: Math.min(concurrency, items.length) }, () => worker());
-    await Promise.all(workers);
-
-    const okCount = results.filter(r => r?.ok).length;
-    const failCount = results.length - okCount;
-    FileLogger.info('process-pdf-batch', 'Batch abgeschlossen', { okCount, failCount, batchName, batchId, total: items.length });
-
-    return NextResponse.json({ ok: true, batchId, batchName, okCount, failCount, results });
+    // Fire-and-forget Verarbeitung (nicht auf das Ende warten) – Worker‑Pool
+    ;(async () => {
+      const results: Array<{ ok: boolean; jobId?: string; error?: string }> = [];
+      let idx = 0;
+      const workItems = createdJobIds.map((jobId, i) => ({ jobId, it: items[i] }));
+      const runner = async () => {
+        while (true) {
+          const i = idx++;
+          if (i >= workItems.length) break;
+          const r = await submitOne(workItems[i].jobId, workItems[i].it);
+          results[i] = r;
+        }
+      };
+      await Promise.all(Array.from({ length: Math.min(concurrency, workItems.length) }, () => runner()));
+      const okCount = results.filter(r => r?.ok).length;
+      const failCount = results.length - okCount;
+      FileLogger.info('process-pdf-batch', 'Asynchrone Verarbeitung abgeschlossen', { okCount, failCount, batchName, batchId, total: items.length });
+    })().catch(() => {});
+
+    // Antwort sofort: alle Jobs sind angelegt
+    return NextResponse.json({ ok: true, batchId, batchName, created: createdJobIds.length });
   } catch (err) {
     return NextResponse.json({ error: err instanceof Error ? err.message : 'Unerwarteter Fehler' }, { status: 500 });
   }
 }
*** End Patch
```

```typescript
import { NextRequest, NextResponse } from 'next/server';
import { getAuth, currentUser } from '@clerk/nextjs/server';
import { FileLogger } from '@/lib/debug/logger';
import crypto from 'crypto';
import { ExternalJobsRepository } from '@/lib/external-jobs-repository';

// Batch-Submit: Erwartet JSON mit items[] (each: { fileId, parentId, name, mimeType }) und optionalen Optionen/Batch-Metadaten
// Server lädt Binärdaten per Server-Storage, reicht an die bestehende process-pdf Route weiter.

interface BatchItemInput {
  fileId: string;
  parentId: string;
  name?: string;
  mimeType?: string;
}

interface BatchRequestBody {
  libraryId: string;
  batchName?: string;
  options?: {
    targetLanguage?: string;
    extractionMethod?: string;
    includeImages?: boolean;
    useCache?: boolean;
    template?: string;
    doExtractMetadata?: boolean;
    doIngestRAG?: boolean;
    forceRecreate?: boolean;
    forceTemplate?: boolean;
  };
  items: BatchItemInput[];
}

export async function POST(request: NextRequest) {
  try {
    const { userId } = getAuth(request);
    if (!userId) return NextResponse.json({ error: 'Nicht authentifiziert' }, { status: 401 });
    const user = await currentUser();
    const userEmail = user?.emailAddresses?.[0]?.emailAddress || '';
    if (!userEmail) return NextResponse.json({ error: 'Benutzer-E-Mail nicht verfügbar' }, { status: 403 });

    const contentType = request.headers.get('content-type') || '';
    if (!contentType.includes('application/json')) {
      return NextResponse.json({ error: 'Content-Type application/json erwartet' }, { status: 415 });
    }

    const body = await request.json() as unknown as BatchRequestBody;
    const libraryId = typeof body?.libraryId === 'string' ? body.libraryId : '';
    const items = Array.isArray(body?.items) ? body.items : [];
    const batchName = typeof body?.batchName === 'string' ? body.batchName : undefined;
    const options = body?.options || {};
    if (!libraryId || items.length === 0) {
      return NextResponse.json({ error: 'libraryId und items erforderlich' }, { status: 400 });
    }

    // Eindeutige Batch-ID generieren
    const batchId = crypto.randomUUID();

    // Phase 1: Alle Jobs minimal in DB anlegen (ohne PDFs zu laden)
    const repo = new ExternalJobsRepository();
    const createdJobIds: string[] = [];
    for (const it of items) {
      try {
        const jobId = crypto.randomUUID();
        const jobSecret = crypto.randomBytes(24).toString('base64url');
        const jobSecretHash = repo.hashSecret(jobSecret);
        await repo.create({
          jobId,
          jobSecretHash,
          job_type: 'pdf',
          operation: 'extract',
          worker: 'secretary',
          status: 'queued',
          libraryId,
          userEmail,
          correlation: {
            jobId,
            libraryId,
            source: { mediaType: 'pdf', mimeType: it.mimeType || 'application/pdf', name: it.name || 'document.pdf', itemId: it.fileId, parentId: it.parentId },
            options: {
              targetLanguage: options?.targetLanguage || 'de',
              extractionMethod: options?.extractionMethod || 'native',
              includeImages: options?.includeImages ?? false,
              useCache: options?.useCache ?? true,
            },
            batchId,
            batchName,
          },
          createdAt: new Date(),
          updatedAt: new Date(),
          steps: [
            { name: 'extract_pdf', status: 'pending' },
            { name: 'transform_template', status: 'pending' },
            { name: 'store_shadow_twin', status: 'pending' },
            { name: 'ingest_rag', status: 'pending' },
          ],
          parameters: {
            targetLanguage: options?.targetLanguage || 'de',
            extractionMethod: options?.extractionMethod || 'native',
            includeImages: options?.includeImages ?? false,
            useCache: options?.useCache ?? true,
            template: options?.template,
            doExtractPDF: true,
            doExtractMetadata: !!options?.doExtractMetadata,
            doIngestRAG: !!options?.doIngestRAG,
            forceRecreate: !!options?.forceRecreate,
            forceTemplate: !!options?.forceTemplate,
            batchId,
            batchName,
          }
        } as any);
        createdJobIds.push(jobId);
      } catch (e) {
        FileLogger.error('process-pdf-batch', 'Job-Anlage fehlgeschlagen', { error: e instanceof Error ? e.message : String(e) });
      }
    }

    // Phase 2: Verarbeitung asynchron starten (Concurrency 5) via Retry‑Route
    const concurrency = 5;
    (async () => {
      let idx = 0;
      const runner = async () => {
        while (true) {
          const i = idx++;
          if (i >= createdJobIds.length) break;
          const jobId = createdJobIds[i];
          try {
            const res = await fetch(new URL(`/api/external/jobs/${jobId}/retry`, request.url).toString(), {
              method: 'POST',
              headers: { 'Cookie': request.headers.get('cookie') || '' }
            });
            if (!res.ok) {
              const msg = await res.text().catch(() => res.statusText);
              FileLogger.error('process-pdf-batch', 'Retry-Start fehlgeschlagen', { jobId, msg });
            }
          } catch (err) {
            FileLogger.error('process-pdf-batch', 'Retry-Start Exception', { jobId, err: err instanceof Error ? err.message : String(err) });
          }
        }
      };
      await Promise.all(Array.from({ length: Math.min(concurrency, createdJobIds.length) }, () => runner()));
      FileLogger.info('process-pdf-batch', 'Asynchroner Start abgeschlossen', { count: createdJobIds.length, batchId, batchName });
    })().catch(() => {});

    // Sofortige Antwort: Anzahl angelegter Jobs
    return NextResponse.json({ ok: true, batchId, batchName, created: createdJobIds.length });
  } catch (err) {
    return NextResponse.json({ error: err instanceof Error ? err.message : 'Unerwarteter Fehler' }, { status: 500 });
  }
}



```

- Status
Ich habe die Zweiphasigkeit implementiert: Batch legt jetzt zuerst alle Jobs schlank in der DB an und startet danach die Verarbeitung asynchron. Parallel dazu habe ich im Stepper den Rahmen entfernt und den Erzwingen‑Toggle ergänzt.

- Was passiert jetzt bei „PDF‑Verzeichnis verarbeiten“
  1) Phase 1 – Anlage in DB, ohne PDFs zu laden:
     - Für jedes Item wird ein `external_jobs`-Eintrag mit Status `queued` erzeugt, inkl. `correlation.source` (nur IDs/Name/Mime) und `parameters` (Sprache, Methode, Flags, Batch-Infos). Keine Datei wird geladen.
     - Du siehst sofort alle Jobs in der Jobliste.
  2) Phase 2 – Asynchroner Start:
     - Nach der Antwort wird serverseitig ein kleiner Pool (5 parallel) gestartet, der für jeden angelegten Job die bestehende Retry‑Route `POST /api/external/jobs/:jobId/retry` aufruft.
     - Diese Retry‑Route lädt dann die PDF einmalig vom Storage und ruft den Secretary‑Worker auf; der Fortschritt wird wie bisher in den Steps/Logs aktualisiert und per EventBus gestreamt.
     - Server‑Neustart: bereits angelegte Jobs stehen in der DB. Du kannst per „Retry Batch“ oder pro Job „Retry“ neu starten; optional kann man noch einen Poll‑Worker ergänzen, der `queued` Jobs selbständig wieder anstößt.

- Technische Kerne
  - `src/app/api/secretary/process-pdf/batch/route.ts`: Batch erzeugt jetzt alle Jobs via `ExternalJobsRepository.create(...)` und startet danach asynchron den Retry‑Flow; Response kommt sofort mit `{ created, batchId }`.
  - `src/app/api/external/jobs/[jobId]/retry/route.ts`: Nutzt `correlation.source.itemId` um die PDF zu laden und den Secretary‑Call zu starten; setzt Steps/Status, Watchdog und Events.
  - `src/lib/external-jobs-repository.ts`: Hilfsmethoden für Worker ergänzt (`claimNextQueuedJob`, `listQueued`) – vorbereitend, falls wir einen dauerhaften Server‑Worker (Polling) bauen wollen.

- Nutzung
  - Starte Batch wie bisher. Unmittelbar nach Klick siehst du alle Jobs `queued`. Die Verarbeitung läuft unabhängig weiter.
  - Für Massen‑Korrekturen nur Phase 2: In der Batch‑Maske „Phase 2: Metadaten“ aktivieren, „Extraktion erzwingen“ aus lassen, optional „Metadaten erzwingen“ an.

- Hinweise/Limitierungen
  - Aktueller asynchroner Start nutzt einen kleinen In‑Process‑Pool (5). Bei großem Systemlastbedarf empfehle ich einen separaten dauerhaften Worker (Polling über `listQueued`/`claimNextQueuedJob`) oder eine echte Queue (Redis/BullMQ).
  - Falls der Server während der Phase‑2‑Startrunde neu startet, bleiben die Jobs in `queued`. Du kannst sie anschließend per „Retry Batch“ starten.

- Test
  - Wähle 20+ PDFs, starte Batch. Erwartung: Sofort 20 Jobs sichtbar (Status `queued`). In den Logs siehst du „Asynchroner Start abgeschlossen“. Nach und nach wechseln Jobs auf `running`/`completed`.
  - Server neu starten → Jobs bleiben `queued`. Starte sie via „Retry Batch“ erneut.

- Nächster Schritt (optional)
  - Einen einfachen dauerhaften Worker ergänzen, der periodisch `claimNextQueuedJob()` zieht und `retry` auslöst. Damit laufen `queued` Jobs automatisch auch nach Neustart wieder an.

---

**User**

Ja, ich würde den JobWorker immer automatisch starten und ja man kann ihn vielleicht manuell stoppen oben bei Secretary Jobs in dieser Jobansicht sehe ich ja dieses Reload Symbol, das ständig neu lädt wo ich auch die Jobliste löschen kann hier möchte ich gerne diese diesen JobWorker mit "Play" starten und "Stop" stoppen können, weil ich vielleicht den Secretary Service verwalten möchte und den dann auch wieder gezielt starten kann

---

**Cursor**

Ich erstelle jetzt einen einfachen Server‑Worker (Polling, Concurrency‑Limit), API‑Endpunkte zum Start/Stop/Status und füge in der Jobansicht Play/Stop hinzu. Danach prüfe ich kurz den Linter.

Ich beginne mit dem Worker-Singleton, dann baue ich die API-Routen parallel, und passe anschließend die UI an.

```typescript
import { ExternalJobsRepository } from '@/lib/external-jobs-repository';
import { FileLogger } from '@/lib/debug/logger';

type WorkerState = 'stopped' | 'running';

interface WorkerStats {
  startedAt?: number;
  lastTickAt?: number;
  processed: number;
  errors: number;
}

class ExternalJobsWorkerSingleton {
  private static instance: ExternalJobsWorkerSingleton | null = null;
  private state: WorkerState = 'stopped';
  private intervalId: NodeJS.Timeout | null = null;
  private readonly intervalMs: number = Number(process.env.JOBS_WORKER_INTERVAL_MS || '2000');
  private readonly concurrency: number = Number(process.env.JOBS_WORKER_CONCURRENCY || '3');
  private stats: WorkerStats = { processed: 0, errors: 0 };

  static getInstance(): ExternalJobsWorkerSingleton {
    if (!this.instance) this.instance = new ExternalJobsWorkerSingleton();
    return this.instance;
  }

  getStatus(): { state: WorkerState; stats: WorkerStats; intervalMs: number; concurrency: number } {
    return { state: this.state, stats: { ...this.stats }, intervalMs: this.intervalMs, concurrency: this.concurrency };
  }

  start(): void {
    if (this.state === 'running') return;
    this.state = 'running';
    this.stats.startedAt = Date.now();
    this.intervalId = setInterval(() => { void this.tick(); }, this.intervalMs);
    FileLogger.info('jobs-worker', 'Worker gestartet', { intervalMs: this.intervalMs, concurrency: this.concurrency });
  }

  stop(): void {
    if (this.intervalId) clearInterval(this.intervalId);
    this.intervalId = null;
    this.state = 'stopped';
    FileLogger.info('jobs-worker', 'Worker gestoppt');
  }

  private async tick(): Promise<void> {
    if (this.state !== 'running') return;
    this.stats.lastTickAt = Date.now();
    try {
      const repo = new ExternalJobsRepository();
      const queued = await repo.listQueued(this.concurrency);
      if (queued.length === 0) return;

      await Promise.all(
        queued.map(async (job) => {
          try {
            // Nutze bestehende Retry-Route, damit die Ausführung zentral bleibt
            const appUrl = process.env.NEXT_PUBLIC_APP_URL || '';
            if (!appUrl) return;
            await fetch(`${appUrl.replace(/\/$/, '')}/api/external/jobs/${job.jobId}/retry`, { method: 'POST' });
            this.stats.processed += 1;
          } catch (err) {
            this.stats.errors += 1;
            FileLogger.error('jobs-worker', 'Tick-Fehler', { jobId: job.jobId, err: err instanceof Error ? err.message : String(err) });
          }
        })
      );
    } catch (err) {
      this.stats.errors += 1;
      FileLogger.error('jobs-worker', 'Tick-Ausnahme', { err: err instanceof Error ? err.message : String(err) });
    }
  }
}

export const ExternalJobsWorker = ExternalJobsWorkerSingleton.getInstance();


```

```typescript
import { NextRequest, NextResponse } from 'next/server';
import { ExternalJobsWorker } from '@/lib/external-jobs-worker';

export async function GET() {
  const status = ExternalJobsWorker.getStatus();
  return NextResponse.json(status);
}

export async function POST(request: NextRequest) {
  const body = await request.json().catch(() => ({})) as { action?: 'start' | 'stop' };
  const action = body.action === 'stop' ? 'stop' : 'start';
  if (action === 'start') ExternalJobsWorker.start(); else ExternalJobsWorker.stop();
  return NextResponse.json(ExternalJobsWorker.getStatus());
}


```

```typescriptreact
"use client";

import { useEffect, useRef, useState } from 'react';
import { useSetAtom } from 'jotai';
import { upsertJobStatusAtom } from '@/atoms/job-status';
import { cn } from "@/lib/utils";
import { Progress } from "@/components/ui/progress";
import { Button } from "@/components/ui/button";
import { ScrollArea } from "@/components/ui/scroll-area";
import { HoverCard, HoverCardContent, HoverCardTrigger } from "@/components/ui/hover-card";
import { FileText, FileAudio, FileVideo, Image as ImageIcon, File as FileIcon, FileType2, RefreshCw, Ban } from "lucide-react";

interface JobListItem {
  jobId: string;
  status: string;
  operation?: string;
  worker?: string;
  jobType?: string;
  fileName?: string;
  updatedAt?: string;
  createdAt?: string;
  lastMessage?: string;
  lastProgress?: number;
}

interface JobUpdateEvent {
  type: 'job_update';
  jobId: string;
  status: string;
  phase?: string;
  progress?: number;
  message?: string;
  updatedAt: string;
  jobType?: string;
  fileName?: string;
  sourceItemId?: string;
}

function formatRelative(dateIso?: string): string {
  if (!dateIso) return '';
  const date = new Date(dateIso);
  const diff = Date.now() - date.getTime();
  const mins = Math.floor(diff / 60000);
  if (mins < 1) return 'jetzt';
  if (mins < 60) return `vor ${mins}m`;
  const hrs = Math.floor(mins / 60);
  if (hrs < 24) return `vor ${hrs}h`;
  const days = Math.floor(hrs / 24);
  return `vor ${days}d`;
}

function formatClock(dateIso?: string): string {
  if (!dateIso) return '';
  const d = new Date(dateIso);
  const mm = String(d.getMinutes()).padStart(2, '0');
  const ss = String(d.getSeconds()).padStart(2, '0');
  return `${mm}:${ss}`;
}

function formatDuration(startIso?: string, endIso?: string): string {
  if (!startIso || !endIso) return '';
  const ms = new Date(endIso).getTime() - new Date(startIso).getTime();
  if (!Number.isFinite(ms) || ms < 0) return '';
  const totalSec = Math.floor(ms / 1000);
  const h = Math.floor(totalSec / 3600);
  const m = Math.floor((totalSec % 3600) / 60);
  const s = totalSec % 60;
  if (h > 0) return `${h}:${String(m).padStart(2, '0')}:${String(s).padStart(2, '0')}`;
  return `${String(m).padStart(2, '0')}:${String(s).padStart(2, '0')}`;
}

function StatusBadge({ status }: { status: string }) {
  const map: Record<string, { label: string; className: string }> = {
    queued: { label: 'Queued', className: 'bg-blue-200 text-blue-900 border-blue-300' },
    running: { label: 'Running', className: 'bg-yellow-200 text-yellow-900 border-yellow-300' },
    completed: { label: 'Completed', className: 'bg-green-200 text-green-900 border-green-300' },
    failed: { label: 'Failed', className: 'bg-red-200 text-red-900 border-red-300' },
  };
  const entry = map[status] || { label: status, className: 'bg-muted text-muted-foreground' };
  return <span className={cn('inline-flex items-center px-2 py-0.5 rounded border text-[11px] font-medium', entry.className)}>{entry.label}</span>;
}

export function JobMonitorPanel() {
  const [isOpen, setIsOpen] = useState(false);
  const [items, setItems] = useState<JobListItem[]>([]);
  const [statusFilter, setStatusFilter] = useState<string>('all');
  const [batchFilter, setBatchFilter] = useState<string>('');
  const [page, setPage] = useState(1);
  const [hasMore, setHasMore] = useState(true);
  const eventRef = useRef<EventSource | null>(null);
  const lastEventTsRef = useRef<number>(Date.now());
  const isFetchingRef = useRef(false);
  const upsertJobStatus = useSetAtom(upsertJobStatusAtom);

  const [isRefreshing, setIsRefreshing] = useState(false);
  const [hiddenIds, setHiddenIds] = useState<Set<string>>(new Set());
  const [batchNames, setBatchNames] = useState<string[]>([]);
  const [serverCounts, setServerCounts] = useState<{ queued: number; running: number; completed: number; failed: number; pendingStorage: number; total: number } | null>(null);
  const [liveUpdates, setLiveUpdates] = useState<boolean>(true);

  // Initiale Seite nur laden, wenn Panel geöffnet wird
  useEffect(() => {
    if (!isOpen) return;
    let cancelled = false;
    async function load(pageNum: number, replace: boolean) {
      try {
        isFetchingRef.current = true;
        const params = new URLSearchParams({ page: String(pageNum), limit: '20' });
        if (statusFilter && statusFilter !== 'all') params.set('status', statusFilter);
        if (batchFilter) params.set('batchName', batchFilter);
        const res = await fetch(`/api/external/jobs?${params.toString()}`, { cache: 'no-store' });
        if (!res.ok) return;
        const json = await res.json();
        if (cancelled) return;
        setItems(prev => replace ? json.items : [...prev, ...json.items]);
        setHasMore(json.items.length === 20);
      } finally {
        isFetchingRef.current = false;
      }
    }
    void load(1, true);
    return () => { cancelled = true; };
  }, [isOpen, statusFilter, batchFilter]);

  // Batch-Namen laden, wenn Panel geöffnet wird
  useEffect(() => {
    if (!isOpen) return;
    let active = true;
    async function loadBatches() {
      try {
        const res = await fetch('/api/external/jobs/batches', { cache: 'no-store' });
        if (!res.ok) return;
        const json = await res.json();
        if (!active) return;
        const names = Array.isArray(json.items) ? json.items.filter((v: unknown) => typeof v === 'string') as string[] : [];
        setBatchNames(names);
      } catch {}
    }
    void loadBatches();
    return () => { active = false; };
  }, [isOpen]);

  // Serverseitige Zähler laden (gesamt, optional gefiltert nach Batch)
  useEffect(() => {
    if (!isOpen) return;
    let active = true;
    async function loadCounts() {
      try {
        const params = new URLSearchParams();
        if (batchFilter) params.set('batchName', batchFilter);
        const res = await fetch(`/api/external/jobs/counters?${params.toString()}`, { cache: 'no-store' });
        if (!res.ok) return;
        const json = await res.json();
        if (!active) return;
        setServerCounts(json.counters || null);
      } catch {}
    }
    void loadCounts();
    const t = setInterval(loadCounts, 5000);
    return () => { active = false; clearInterval(t); };
  }, [isOpen, batchFilter]);

  const refreshNow = async () => {
    if (isRefreshing) return;
    setIsRefreshing(true);
    try {
      const params = new URLSearchParams({ page: '1', limit: '20' });
      if (statusFilter && statusFilter !== 'all') params.set('status', statusFilter);
      if (batchFilter) params.set('batchName', batchFilter);
      const res = await fetch(`/api/external/jobs?${params.toString()}`, { cache: 'no-store' });
      if (!res.ok) return;
      const json = await res.json();
      setItems(json.items || []);
      setPage(1);
      setHasMore((json.items || []).length === 20);
    } finally {
      setIsRefreshing(false);
    }
  };

  // SSE verbinden nur wenn Panel geöffnet ist und Live-Updates aktiv sind; bei Schließen sofort beenden
  useEffect(() => {
    if (!isOpen || !liveUpdates) {
      if (eventRef.current) { try { eventRef.current.close(); } catch {} eventRef.current = null; }
      return;
    }
    let retryTimer: ReturnType<typeof setTimeout> | null = null;
    function connect() {
      if (eventRef.current) {
        try { eventRef.current.close(); } catch {}
      }
      const es = new EventSource('/api/external/jobs/stream');
      eventRef.current = es;

      // kein aggressiver Refresh im open-Event; initiales Laden oben beim Öffnen

      const onUpdate = (e: MessageEvent) => {
        try {
          const evt: JobUpdateEvent = JSON.parse(e.data);
          lastEventTsRef.current = Date.now();
          if (evt.sourceItemId && evt.status) {
            upsertJobStatus({ itemId: evt.sourceItemId, status: evt.status });
          }
          setItems(prev => {
            const idx = prev.findIndex(p => p.jobId === evt.jobId);
            const patch: Partial<JobListItem> = {
              status: evt.status,
              lastMessage: evt.message ?? prev[idx]?.lastMessage,
              lastProgress: evt.progress ?? prev[idx]?.lastProgress,
              updatedAt: evt.updatedAt,
              jobType: evt.jobType ?? prev[idx]?.jobType,
              fileName: evt.fileName ?? prev[idx]?.fileName,
            };
            if (idx >= 0) {
              const updated = { ...prev[idx], ...patch };
              const next = [...prev];
              next[idx] = updated;
              // bei Update nach oben reihen (neueste zuerst)
              next.sort((a, b) => (new Date(b.updatedAt || 0).getTime()) - (new Date(a.updatedAt || 0).getTime()));
              return next;
            }
            // Neuer Job: nur einfügen wenn Filter passt; bei Batch-Filter immer via Refresh laden
            if (statusFilter && statusFilter !== 'all' && evt.status !== statusFilter) {
              return prev;
            }
            if (batchFilter) {
              void refreshNow();
              return prev;
            }
            const inserted: JobListItem = {
              jobId: evt.jobId,
              status: evt.status,
              updatedAt: evt.updatedAt,
              lastMessage: evt.message,
              lastProgress: evt.progress,
              jobType: evt.jobType,
              fileName: evt.fileName,
            };
            return [inserted, ...prev];
          });
        } catch {}
      };
      es.addEventListener('job_update', onUpdate as unknown as EventListener);
      es.addEventListener('error', () => {
        try { es.close(); } catch {}
        if (retryTimer) clearTimeout(retryTimer);
        // Nur reconnecten, wenn Panel offen bleibt
        retryTimer = setTimeout(() => { if (isOpen && liveUpdates) connect(); }, 1000);
      });
    }
    connect();
    // Fallback: lokale Events (wenn wir selbst einen Job starten)
    const onLocal = (e: Event) => {
      const detail = (e as CustomEvent).detail as JobUpdateEvent;
      if (!detail?.jobId) return;
      lastEventTsRef.current = Date.now();
      setItems(prev => {
        const idx = prev.findIndex(p => p.jobId === detail.jobId);
        const patch: Partial<JobListItem> = {
          status: detail.status,
          lastMessage: detail.message ?? prev[idx]?.lastMessage,
          lastProgress: detail.progress ?? prev[idx]?.lastProgress,
          updatedAt: detail.updatedAt,
          jobType: detail.jobType ?? prev[idx]?.jobType,
          fileName: detail.fileName ?? prev[idx]?.fileName,
        };
        if (idx >= 0) {
          const updated = { ...prev[idx], ...patch };
          const next = [...prev];
          next[idx] = updated;
          next.sort((a, b) => (new Date(b.updatedAt || 0).getTime()) - (new Date(a.updatedAt || 0).getTime()));
          return next;
        }
        const inserted: JobListItem = {
          jobId: detail.jobId,
          status: detail.status,
          updatedAt: detail.updatedAt,
          lastMessage: detail.message,
          lastProgress: detail.progress,
          jobType: detail.jobType,
          fileName: detail.fileName,
        };
        return [inserted, ...prev];
      });
    };
    window.addEventListener('job_update_local', onLocal as unknown as EventListener);
    return () => {
      if (retryTimer) clearTimeout(retryTimer);
      if (eventRef.current) try { eventRef.current.close(); } catch {}
      window.removeEventListener('job_update_local', onLocal as unknown as EventListener);
    };
  }, [isOpen, liveUpdates, upsertJobStatus, statusFilter, batchFilter]);

  const handleToggle = () => setIsOpen(v => !v);
  const queuedCount = items.filter(i => i.status === 'queued').length;
  const runningCount = items.filter(i => i.status === 'running').length;
  const completedCount = items.filter(i => i.status === 'completed').length;
  const failedCount = items.filter(i => i.status === 'failed').length;

  async function retryJob(jobId: string) {
    try {
      const res = await fetch(`/api/external/jobs/${jobId}/retry`, { method: 'POST' });
      if (!res.ok) return;
      // Nach erfolgreichem Retry frisch laden
      await refreshNow();
    } catch {}
  }
  const loadMore = async () => {
    if (!hasMore || isFetchingRef.current) return;
    const next = page + 1;
    const params = new URLSearchParams({ page: String(next), limit: '20' });
    if (statusFilter && statusFilter !== 'all') params.set('status', statusFilter);
    if (batchFilter) params.set('batchName', batchFilter);
    const res = await fetch(`/api/external/jobs?${params.toString()}`, { cache: 'no-store' });
    if (!res.ok) return;
    const json = await res.json();
    setItems(prev => [...prev, ...json.items]);
    setPage(next);
    setHasMore(json.items.length === 20);
  };

  // Polling Fallback: nur wenn Panel offen, Live-Updates an UND keine SSE-Events für 10s
  useEffect(() => {
    if (!isOpen || !liveUpdates) return;
    const onTick = () => {
      const idleMs = Date.now() - lastEventTsRef.current;
      if (idleMs > 10_000) void refreshNow();
    };
    const timer = setInterval(onTick, 2000);
    const unsub = () => { lastEventTsRef.current = Date.now(); };
    window.addEventListener('job_update_local', unsub as unknown as EventListener);
    return () => { clearInterval(timer); window.removeEventListener('job_update_local', unsub as unknown as EventListener); };
  }, [isOpen, liveUpdates]);

  function JobTypeIcon({ jobType }: { jobType?: string }) {
    const type = (jobType || '').toLowerCase();
    const Icon = type === 'pdf' ? FileText
      : type === 'audio' ? FileAudio
      : type === 'video' ? FileVideo
      : type === 'image' ? ImageIcon
      : type === 'text' ? FileType2
      : FileIcon;
    return <Icon className="w-4 h-4 text-muted-foreground" aria-hidden />;
  }

  function hideJob(jobId: string) {
    setHiddenIds(prev => new Set(prev).add(jobId));
  }

  function hideAllJobs() {
    setHiddenIds(new Set(items.map(i => i.jobId)));
  }

  return (
    <div className="pointer-events-none">
      {/* Handle */}
      <div className={cn(
        "fixed top-16 right-0 z-40 transition-transform",
        isOpen ? "translate-x-[calc(0px)]" : "translate-x-0"
      )}>
        <button
          onClick={handleToggle}
          className={cn(
            "pointer-events-auto select-none",
            "bg-primary text-primary-foreground",
            "rounded-l-md shadow",
            "px-2 py-1",
            "hover:opacity-90"
          )}
          aria-label={isOpen ? 'Panel schließen' : 'Job-Monitor öffnen'}
        >
          {isOpen ? '×' : '≡'}
        </button>
      </div>

      {/* Panel */}
      <div className={cn(
        "fixed top-0 right-0 h-screen z-30",
        "w-[420px] md:w-[520px]",
        "bg-background border-l",
        "shadow-lg",
        "transition-transform duration-300",
        isOpen ? "translate-x-0" : "translate-x-full",
        "pointer-events-auto"
      )}>
        <div className="h-full flex flex-col">
          <div className="px-4 py-3 border-b flex items-center justify-between">
            <div className="font-semibold flex items-center gap-2">
              <span>Secretary Jobs</span>
              <span className="text-xs text-muted-foreground">Q {serverCounts?.queued ?? queuedCount} • R {serverCounts?.running ?? runningCount} • C {serverCounts?.completed ?? completedCount} • F {serverCounts?.failed ?? failedCount}</span>
              <button
                onClick={() => setLiveUpdates(v => !v)}
                className="pointer-events-auto inline-flex items-center justify-center rounded p-1 hover:bg-muted"
                aria-label={liveUpdates ? "Live-Updates anhalten" : "Live-Updates starten"}
                title={liveUpdates ? "Live-Updates anhalten" : "Live-Updates starten"}
              >
                <RefreshCw className={cn("h-4 w-4", (isRefreshing || liveUpdates) && "animate-spin")} />
              </button>
              <button
                onClick={hideAllJobs}
                className="pointer-events-auto inline-flex items-center justify-center rounded p-1 hover:bg-muted"
                aria-label="Alle ausblenden"
                title="Alle ausblenden"
              >
                <Ban className="h-4 w-4" />
              </button>
            </div>
            <Button size="sm" variant="ghost" onClick={handleToggle} aria-label="Schließen">×</Button>
          </div>
          <div className="px-4 py-1 border-b text-xs text-muted-foreground flex items-center gap-4">
            <span className="inline-flex items-center gap-1"><span className="inline-block h-2 w-2 rounded-full bg-blue-400" />Queued {serverCounts?.queued ?? queuedCount}</span>
            <span className="inline-flex items-center gap-1"><span className="inline-block h-2 w-2 rounded-full bg-yellow-400" />Running {serverCounts?.running ?? runningCount}</span>
            <span className="inline-flex items-center gap-1"><span className="inline-block h-2 w-2 rounded-full bg-green-500" />Completed {serverCounts?.completed ?? completedCount}</span>
            <span className="inline-flex items-center gap-1"><span className="inline-block h-2 w-2 rounded-full bg-red-500" />Failed {serverCounts?.failed ?? failedCount}</span>
            <WorkerControls />
          </div>
          <div className="px-4 py-2 border-b flex items-center gap-2">
            <select className="border rounded px-2 py-1 text-sm" value={statusFilter} onChange={(e) => setStatusFilter(e.target.value)}>
              <option value="all">Alle ({serverCounts?.total ?? (queuedCount + runningCount + completedCount + failedCount)})</option>
              <option value="queued">Queued ({serverCounts?.queued ?? queuedCount})</option>
              <option value="running">Running ({serverCounts?.running ?? runningCount})</option>
              <option value="completed">Completed ({serverCounts?.completed ?? completedCount})</option>
              <option value="failed">Failed ({serverCounts?.failed ?? failedCount})</option>
            </select>
            <select className="border rounded px-2 py-1 text-sm flex-1" value={batchFilter} onChange={(e) => setBatchFilter(e.target.value)}>
              <option value="">Alle Batches</option>
              {batchNames.map((name) => (
                <option key={name} value={name}>{name}</option>
              ))}
            </select>
            <Button size="sm" variant="outline" onClick={refreshNow}>Filtern</Button>
            <Button size="sm" onClick={async () => {
              try {
                const payload: Record<string, string> = {};
                if (statusFilter && statusFilter !== 'all') payload.status = statusFilter;
                if (batchFilter) payload.batchName = batchFilter;
                const res = await fetch('/api/external/jobs/retry-batch', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
                if (!res.ok) return;
                await refreshNow();
              } catch {}
            }}>Neu starten (gefiltert)</Button>
          </div>
          <ScrollArea className="flex-1">
            <ul className="p-3 space-y-2">
              {items.filter(it => !hiddenIds.has(it.jobId)).map(item => (
                <li key={item.jobId} className={cn(
                  "border rounded-md p-3",
                  item.status === 'queued' && 'bg-blue-100/60',
                  item.status === 'running' && 'bg-yellow-100/60',
                  item.status === 'completed' && 'bg-green-100/60',
                  item.status === 'failed' && 'bg-red-100/60'
                )}>
                  <div className="flex items-center justify-between gap-2">
                    <div className="flex items-center gap-2 min-w-0">
                      <div className="shrink-0" title={item.jobType || 'job'}>
                        <JobTypeIcon jobType={item.jobType} />
                      </div>
                      <HoverCard openDelay={200} closeDelay={100}>
                        <HoverCardTrigger asChild>
                          <div className="truncate text-sm font-medium cursor-default" title={item.fileName || item.jobId}>{item.fileName || (item.operation || 'job')}</div>
                        </HoverCardTrigger>
                        <HoverCardContent side="top" align="start" className="w-[36rem] p-0 max-h-[85vh]">
                          <ScrollArea className="h-[80vh] overflow-y-auto p-2 text-xs">
                            <JobLogs jobId={item.jobId} />
                          </ScrollArea>
                        </HoverCardContent>
                      </HoverCard>
                    </div>
                    <div className="flex items-center gap-1 shrink-0 w-28 justify-end">
                      <button
                        onClick={() => hideJob(item.jobId)}
                        className="pointer-events-auto inline-flex items-center justify-center rounded p-1 hover:bg-muted"
                        aria-label="Ausblenden"
                        title="Ausblenden"
                      >
                        <Ban className="h-4 w-4" />
                      </button>
                      {(item.status === 'failed' || item.status === 'queued') && (
                        <button
                          onClick={() => retryJob(item.jobId)}
                          className="pointer-events-auto inline-flex items-center justify-center rounded p-1 hover:bg-muted"
                          aria-label="Neu starten"
                          title="Neu starten"
                        >
                          <RefreshCw className="h-4 w-4" />
                        </button>
                      )}
                      <StatusBadge status={item.status} />
                    </div>
                  </div>
                  <div className="mt-2 relative">
                    <Progress value={typeof item.lastProgress === 'number' ? Math.max(0, Math.min(100, item.lastProgress)) : 0} />
                    {item.status === 'running' && (
                      <div className="absolute inset-0 flex items-center justify-center text-[11px] text-muted-foreground">
                        Läuft…
                      </div>
                    )}
                    {item.status === 'completed' && (
                      <div className="absolute inset-0 flex items-center justify-center text-[11px] text-muted-foreground">
                        {formatDuration(item.createdAt, item.updatedAt)}
                      </div>
                    )}
                  </div>
                  <div className="mt-2 text-xs text-muted-foreground flex items-center justify-between gap-2">
                    <div className="truncate" title={item.lastMessage}>{item.lastMessage || '—'}</div>
                    <div>{formatRelative(item.updatedAt)}</div>
                  </div>
                </li>
              ))}
              {items.length === 0 && (
                <li className="text-sm text-muted-foreground py-6 text-center">Keine Jobs</li>
              )}
            </ul>
          </ScrollArea>
          <div className="p-3 border-t flex items-center justify-center">
            <Button size="sm" variant="outline" onClick={loadMore} disabled={!hasMore}>Ältere laden</Button>
          </div>
        </div>
      </div>
    </div>
  );
}

function JobLogs({ jobId }: { jobId: string }) {
  const [logs, setLogs] = useState<Array<{ timestamp: string; phase?: string; progress?: number; message?: string }>>([]);
  const [loaded, setLoaded] = useState(false);

  useEffect(() => {
    let active = true;
    async function load() {
      try {
        const res = await fetch(`/api/external/jobs/${jobId}?limit=50`, { cache: 'no-store' });
        if (!res.ok) return;
        const json = await res.json();
        if (!active) return;
        const l: Array<{ timestamp?: string; phase?: string; progress?: number; message?: string }> = Array.isArray(json.logs) ? json.logs : [];
        setLogs(l.map((e) => ({
          timestamp: String(e.timestamp),
          phase: typeof e.phase === 'string' ? e.phase : undefined,
          progress: typeof e.progress === 'number' ? e.progress : undefined,
          message: typeof e.message === 'string' ? e.message : undefined,
        })));
        setLoaded(true);
      } catch {
        // ignore
      }
    }
    if (!loaded) load();
    return () => { active = false; };
  }, [jobId, loaded]);

  if (!loaded) return <div className="text-muted-foreground">Lade Logs…</div>;
  // Filter: keinerlei reine Worker-Details ohne message nicht anzeigen
  const visible = logs.filter(l => (l.message && l.message.trim() !== ''));
  if (visible.length === 0) return <div className="text-muted-foreground">Keine Logs</div>;

  return (
    <div className="space-y-2">
      {visible.map((l, idx) => (
        <div key={idx} className="flex items-start justify-between gap-2">
          <div className="truncate">
            <div className="font-medium truncate">{l.message || '—'} {typeof l.progress === 'number' ? `(${Math.round(l.progress)}%)` : ''}</div>
          </div>
          <div className="text-muted-foreground">{formatClock(l.timestamp)}</div>
        </div>
      ))}
    </div>
  );
}



```

```typescriptreact
"use client";

import { useEffect, useRef, useState } from 'react';
import { useSetAtom } from 'jotai';
import { upsertJobStatusAtom } from '@/atoms/job-status';
import { cn } from "@/lib/utils";
import { Progress } from "@/components/ui/progress";
import { Button } from "@/components/ui/button";
import { ScrollArea } from "@/components/ui/scroll-area";
import { HoverCard, HoverCardContent, HoverCardTrigger } from "@/components/ui/hover-card";
import { FileText, FileAudio, FileVideo, Image as ImageIcon, File as FileIcon, FileType2, RefreshCw, Ban } from "lucide-react";

interface JobListItem {
  jobId: string;
  status: string;
  operation?: string;
  worker?: string;
  jobType?: string;
  fileName?: string;
  updatedAt?: string;
  createdAt?: string;
  lastMessage?: string;
  lastProgress?: number;
}

interface JobUpdateEvent {
  type: 'job_update';
  jobId: string;
  status: string;
  phase?: string;
  progress?: number;
  message?: string;
  updatedAt: string;
  jobType?: string;
  fileName?: string;
  sourceItemId?: string;
}

function formatRelative(dateIso?: string): string {
  if (!dateIso) return '';
  const date = new Date(dateIso);
  const diff = Date.now() - date.getTime();
  const mins = Math.floor(diff / 60000);
  if (mins < 1) return 'jetzt';
  if (mins < 60) return `vor ${mins}m`;
  const hrs = Math.floor(mins / 60);
  if (hrs < 24) return `vor ${hrs}h`;
  const days = Math.floor(hrs / 24);
  return `vor ${days}d`;
}

function formatClock(dateIso?: string): string {
  if (!dateIso) return '';
  const d = new Date(dateIso);
  const mm = String(d.getMinutes()).padStart(2, '0');
  const ss = String(d.getSeconds()).padStart(2, '0');
  return `${mm}:${ss}`;
}

function formatDuration(startIso?: string, endIso?: string): string {
  if (!startIso || !endIso) return '';
  const ms = new Date(endIso).getTime() - new Date(startIso).getTime();
  if (!Number.isFinite(ms) || ms < 0) return '';
  const totalSec = Math.floor(ms / 1000);
  const h = Math.floor(totalSec / 3600);
  const m = Math.floor((totalSec % 3600) / 60);
  const s = totalSec % 60;
  if (h > 0) return `${h}:${String(m).padStart(2, '0')}:${String(s).padStart(2, '0')}`;
  return `${String(m).padStart(2, '0')}:${String(s).padStart(2, '0')}`;
}

function StatusBadge({ status }: { status: string }) {
  const map: Record<string, { label: string; className: string }> = {
    queued: { label: 'Queued', className: 'bg-blue-200 text-blue-900 border-blue-300' },
    running: { label: 'Running', className: 'bg-yellow-200 text-yellow-900 border-yellow-300' },
    completed: { label: 'Completed', className: 'bg-green-200 text-green-900 border-green-300' },
    failed: { label: 'Failed', className: 'bg-red-200 text-red-900 border-red-300' },
  };
  const entry = map[status] || { label: status, className: 'bg-muted text-muted-foreground' };
  return <span className={cn('inline-flex items-center px-2 py-0.5 rounded border text-[11px] font-medium', entry.className)}>{entry.label}</span>;
}

export function JobMonitorPanel() {
  const [isOpen, setIsOpen] = useState(false);
  const [items, setItems] = useState<JobListItem[]>([]);
  const [statusFilter, setStatusFilter] = useState<string>('all');
  const [batchFilter, setBatchFilter] = useState<string>('');
  const [page, setPage] = useState(1);
  const [hasMore, setHasMore] = useState(true);
  const eventRef = useRef<EventSource | null>(null);
  const lastEventTsRef = useRef<number>(Date.now());
  const isFetchingRef = useRef(false);
  const upsertJobStatus = useSetAtom(upsertJobStatusAtom);

  const [isRefreshing, setIsRefreshing] = useState(false);
  const [hiddenIds, setHiddenIds] = useState<Set<string>>(new Set());
  const [batchNames, setBatchNames] = useState<string[]>([]);
  const [serverCounts, setServerCounts] = useState<{ queued: number; running: number; completed: number; failed: number; pendingStorage: number; total: number } | null>(null);
  const [liveUpdates, setLiveUpdates] = useState<boolean>(true);

  // Initiale Seite nur laden, wenn Panel geöffnet wird
  useEffect(() => {
    if (!isOpen) return;
    let cancelled = false;
    async function load(pageNum: number, replace: boolean) {
      try {
        isFetchingRef.current = true;
        const params = new URLSearchParams({ page: String(pageNum), limit: '20' });
        if (statusFilter && statusFilter !== 'all') params.set('status', statusFilter);
        if (batchFilter) params.set('batchName', batchFilter);
        const res = await fetch(`/api/external/jobs?${params.toString()}`, { cache: 'no-store' });
        if (!res.ok) return;
        const json = await res.json();
        if (cancelled) return;
        setItems(prev => replace ? json.items : [...prev, ...json.items]);
        setHasMore(json.items.length === 20);
      } finally {
        isFetchingRef.current = false;
      }
    }
    void load(1, true);
    return () => { cancelled = true; };
  }, [isOpen, statusFilter, batchFilter]);

  // Batch-Namen laden, wenn Panel geöffnet wird
  useEffect(() => {
    if (!isOpen) return;
    let active = true;
    async function loadBatches() {
      try {
        const res = await fetch('/api/external/jobs/batches', { cache: 'no-store' });
        if (!res.ok) return;
        const json = await res.json();
        if (!active) return;
        const names = Array.isArray(json.items) ? json.items.filter((v: unknown) => typeof v === 'string') as string[] : [];
        setBatchNames(names);
      } catch {}
    }
    void loadBatches();
    return () => { active = false; };
  }, [isOpen]);

  // Serverseitige Zähler laden (gesamt, optional gefiltert nach Batch)
  useEffect(() => {
    if (!isOpen) return;
    let active = true;
    async function loadCounts() {
      try {
        const params = new URLSearchParams();
        if (batchFilter) params.set('batchName', batchFilter);
        const res = await fetch(`/api/external/jobs/counters?${params.toString()}`, { cache: 'no-store' });
        if (!res.ok) return;
        const json = await res.json();
        if (!active) return;
        setServerCounts(json.counters || null);
      } catch {}
    }
    void loadCounts();
    const t = setInterval(loadCounts, 5000);
    return () => { active = false; clearInterval(t); };
  }, [isOpen, batchFilter]);

  const refreshNow = async () => {
    if (isRefreshing) return;
    setIsRefreshing(true);
    try {
      const params = new URLSearchParams({ page: '1', limit: '20' });
      if (statusFilter && statusFilter !== 'all') params.set('status', statusFilter);
      if (batchFilter) params.set('batchName', batchFilter);
      const res = await fetch(`/api/external/jobs?${params.toString()}`, { cache: 'no-store' });
      if (!res.ok) return;
      const json = await res.json();
      setItems(json.items || []);
      setPage(1);
      setHasMore((json.items || []).length === 20);
    } finally {
      setIsRefreshing(false);
    }
  };

  // SSE verbinden nur wenn Panel geöffnet ist und Live-Updates aktiv sind; bei Schließen sofort beenden
  useEffect(() => {
    if (!isOpen || !liveUpdates) {
      if (eventRef.current) { try { eventRef.current.close(); } catch {} eventRef.current = null; }
      return;
    }
    let retryTimer: ReturnType<typeof setTimeout> | null = null;
    function connect() {
      if (eventRef.current) {
        try { eventRef.current.close(); } catch {}
      }
      const es = new EventSource('/api/external/jobs/stream');
      eventRef.current = es;

      // kein aggressiver Refresh im open-Event; initiales Laden oben beim Öffnen

      const onUpdate = (e: MessageEvent) => {
        try {
          const evt: JobUpdateEvent = JSON.parse(e.data);
          lastEventTsRef.current = Date.now();
          if (evt.sourceItemId && evt.status) {
            upsertJobStatus({ itemId: evt.sourceItemId, status: evt.status });
          }
          setItems(prev => {
            const idx = prev.findIndex(p => p.jobId === evt.jobId);
            const patch: Partial<JobListItem> = {
              status: evt.status,
              lastMessage: evt.message ?? prev[idx]?.lastMessage,
              lastProgress: evt.progress ?? prev[idx]?.lastProgress,
              updatedAt: evt.updatedAt,
              jobType: evt.jobType ?? prev[idx]?.jobType,
              fileName: evt.fileName ?? prev[idx]?.fileName,
            };
            if (idx >= 0) {
              const updated = { ...prev[idx], ...patch };
              const next = [...prev];
              next[idx] = updated;
              // bei Update nach oben reihen (neueste zuerst)
              next.sort((a, b) => (new Date(b.updatedAt || 0).getTime()) - (new Date(a.updatedAt || 0).getTime()));
              return next;
            }
            // Neuer Job: nur einfügen wenn Filter passt; bei Batch-Filter immer via Refresh laden
            if (statusFilter && statusFilter !== 'all' && evt.status !== statusFilter) {
              return prev;
            }
            if (batchFilter) {
              void refreshNow();
              return prev;
            }
            const inserted: JobListItem = {
              jobId: evt.jobId,
              status: evt.status,
              updatedAt: evt.updatedAt,
              lastMessage: evt.message,
              lastProgress: evt.progress,
              jobType: evt.jobType,
              fileName: evt.fileName,
            };
            return [inserted, ...prev];
          });
        } catch {}
      };
      es.addEventListener('job_update', onUpdate as unknown as EventListener);
      es.addEventListener('error', () => {
        try { es.close(); } catch {}
        if (retryTimer) clearTimeout(retryTimer);
        // Nur reconnecten, wenn Panel offen bleibt
        retryTimer = setTimeout(() => { if (isOpen && liveUpdates) connect(); }, 1000);
      });
    }
    connect();
    // Fallback: lokale Events (wenn wir selbst einen Job starten)
    const onLocal = (e: Event) => {
      const detail = (e as CustomEvent).detail as JobUpdateEvent;
      if (!detail?.jobId) return;
      lastEventTsRef.current = Date.now();
      setItems(prev => {
        const idx = prev.findIndex(p => p.jobId === detail.jobId);
        const patch: Partial<JobListItem> = {
          status: detail.status,
          lastMessage: detail.message ?? prev[idx]?.lastMessage,
          lastProgress: detail.progress ?? prev[idx]?.lastProgress,
          updatedAt: detail.updatedAt,
          jobType: detail.jobType ?? prev[idx]?.jobType,
          fileName: detail.fileName ?? prev[idx]?.fileName,
        };
        if (idx >= 0) {
          const updated = { ...prev[idx], ...patch };
          const next = [...prev];
          next[idx] = updated;
          next.sort((a, b) => (new Date(b.updatedAt || 0).getTime()) - (new Date(a.updatedAt || 0).getTime()));
          return next;
        }
        const inserted: JobListItem = {
          jobId: detail.jobId,
          status: detail.status,
          updatedAt: detail.updatedAt,
          lastMessage: detail.message,
          lastProgress: detail.progress,
          jobType: detail.jobType,
          fileName: detail.fileName,
        };
        return [inserted, ...prev];
      });
    };
    window.addEventListener('job_update_local', onLocal as unknown as EventListener);
    return () => {
      if (retryTimer) clearTimeout(retryTimer);
      if (eventRef.current) try { eventRef.current.close(); } catch {}
      window.removeEventListener('job_update_local', onLocal as unknown as EventListener);
    };
  }, [isOpen, liveUpdates, upsertJobStatus, statusFilter, batchFilter]);

  const handleToggle = () => setIsOpen(v => !v);
  const queuedCount = items.filter(i => i.status === 'queued').length;
  const runningCount = items.filter(i => i.status === 'running').length;
  const completedCount = items.filter(i => i.status === 'completed').length;
  const failedCount = items.filter(i => i.status === 'failed').length;

  async function retryJob(jobId: string) {
    try {
      const res = await fetch(`/api/external/jobs/${jobId}/retry`, { method: 'POST' });
      if (!res.ok) return;
      // Nach erfolgreichem Retry frisch laden
      await refreshNow();
    } catch {}
  }
  const loadMore = async () => {
    if (!hasMore || isFetchingRef.current) return;
    const next = page + 1;
    const params = new URLSearchParams({ page: String(next), limit: '20' });
    if (statusFilter && statusFilter !== 'all') params.set('status', statusFilter);
    if (batchFilter) params.set('batchName', batchFilter);
    const res = await fetch(`/api/external/jobs?${params.toString()}`, { cache: 'no-store' });
    if (!res.ok) return;
    const json = await res.json();
    setItems(prev => [...prev, ...json.items]);
    setPage(next);
    setHasMore(json.items.length === 20);
  };

  // Polling Fallback: nur wenn Panel offen, Live-Updates an UND keine SSE-Events für 10s
  useEffect(() => {
    if (!isOpen || !liveUpdates) return;
    const onTick = () => {
      const idleMs = Date.now() - lastEventTsRef.current;
      if (idleMs > 10_000) void refreshNow();
    };
    const timer = setInterval(onTick, 2000);
    const unsub = () => { lastEventTsRef.current = Date.now(); };
    window.addEventListener('job_update_local', unsub as unknown as EventListener);
    return () => { clearInterval(timer); window.removeEventListener('job_update_local', unsub as unknown as EventListener); };
  }, [isOpen, liveUpdates]);

  function JobTypeIcon({ jobType }: { jobType?: string }) {
    const type = (jobType || '').toLowerCase();
    const Icon = type === 'pdf' ? FileText
      : type === 'audio' ? FileAudio
      : type === 'video' ? FileVideo
      : type === 'image' ? ImageIcon
      : type === 'text' ? FileType2
      : FileIcon;
    return <Icon className="w-4 h-4 text-muted-foreground" aria-hidden />;
  }

  function hideJob(jobId: string) {
    setHiddenIds(prev => new Set(prev).add(jobId));
  }

  function hideAllJobs() {
    setHiddenIds(new Set(items.map(i => i.jobId)));
  }

  return (
    <div className="pointer-events-none">
      {/* Handle */}
      <div className={cn(
        "fixed top-16 right-0 z-40 transition-transform",
        isOpen ? "translate-x-[calc(0px)]" : "translate-x-0"
      )}>
        <button
          onClick={handleToggle}
          className={cn(
            "pointer-events-auto select-none",
            "bg-primary text-primary-foreground",
            "rounded-l-md shadow",
            "px-2 py-1",
            "hover:opacity-90"
          )}
          aria-label={isOpen ? 'Panel schließen' : 'Job-Monitor öffnen'}
        >
          {isOpen ? '×' : '≡'}
        </button>
      </div>

      {/* Panel */}
      <div className={cn(
        "fixed top-0 right-0 h-screen z-30",
        "w-[420px] md:w-[520px]",
        "bg-background border-l",
        "shadow-lg",
        "transition-transform duration-300",
        isOpen ? "translate-x-0" : "translate-x-full",
        "pointer-events-auto"
      )}>
        <div className="h-full flex flex-col">
          <div className="px-4 py-3 border-b flex items-center justify-between">
            <div className="font-semibold flex items-center gap-2">
              <span>Secretary Jobs</span>
              <span className="text-xs text-muted-foreground">Q {serverCounts?.queued ?? queuedCount} • R {serverCounts?.running ?? runningCount} • C {serverCounts?.completed ?? completedCount} • F {serverCounts?.failed ?? failedCount}</span>
              <button
                onClick={() => setLiveUpdates(v => !v)}
                className="pointer-events-auto inline-flex items-center justify-center rounded p-1 hover:bg-muted"
                aria-label={liveUpdates ? "Live-Updates anhalten" : "Live-Updates starten"}
                title={liveUpdates ? "Live-Updates anhalten" : "Live-Updates starten"}
              >
                <RefreshCw className={cn("h-4 w-4", (isRefreshing || liveUpdates) && "animate-spin")} />
              </button>
              <button
                onClick={hideAllJobs}
                className="pointer-events-auto inline-flex items-center justify-center rounded p-1 hover:bg-muted"
                aria-label="Alle ausblenden"
                title="Alle ausblenden"
              >
                <Ban className="h-4 w-4" />
              </button>
            </div>
            <Button size="sm" variant="ghost" onClick={handleToggle} aria-label="Schließen">×</Button>
          </div>
          <div className="px-4 py-1 border-b text-xs text-muted-foreground flex items-center gap-4">
            <span className="inline-flex items-center gap-1"><span className="inline-block h-2 w-2 rounded-full bg-blue-400" />Queued {serverCounts?.queued ?? queuedCount}</span>
            <span className="inline-flex items-center gap-1"><span className="inline-block h-2 w-2 rounded-full bg-yellow-400" />Running {serverCounts?.running ?? runningCount}</span>
            <span className="inline-flex items-center gap-1"><span className="inline-block h-2 w-2 rounded-full bg-green-500" />Completed {serverCounts?.completed ?? completedCount}</span>
            <span className="inline-flex items-center gap-1"><span className="inline-block h-2 w-2 rounded-full bg-red-500" />Failed {serverCounts?.failed ?? failedCount}</span>
            <WorkerControls />
          </div>
          <div className="px-4 py-2 border-b flex items-center gap-2">
            <select className="border rounded px-2 py-1 text-sm" value={statusFilter} onChange={(e) => setStatusFilter(e.target.value)}>
              <option value="all">Alle ({serverCounts?.total ?? (queuedCount + runningCount + completedCount + failedCount)})</option>
              <option value="queued">Queued ({serverCounts?.queued ?? queuedCount})</option>
              <option value="running">Running ({serverCounts?.running ?? runningCount})</option>
              <option value="completed">Completed ({serverCounts?.completed ?? completedCount})</option>
              <option value="failed">Failed ({serverCounts?.failed ?? failedCount})</option>
            </select>
            <select className="border rounded px-2 py-1 text-sm flex-1" value={batchFilter} onChange={(e) => setBatchFilter(e.target.value)}>
              <option value="">Alle Batches</option>
              {batchNames.map((name) => (
                <option key={name} value={name}>{name}</option>
              ))}
            </select>
            <Button size="sm" variant="outline" onClick={refreshNow}>Filtern</Button>
            <Button size="sm" onClick={async () => {
              try {
                const payload: Record<string, string> = {};
                if (statusFilter && statusFilter !== 'all') payload.status = statusFilter;
                if (batchFilter) payload.batchName = batchFilter;
                const res = await fetch('/api/external/jobs/retry-batch', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
                if (!res.ok) return;
                await refreshNow();
              } catch {}
            }}>Neu starten (gefiltert)</Button>
          </div>
          <ScrollArea className="flex-1">
            <ul className="p-3 space-y-2">
              {items.filter(it => !hiddenIds.has(it.jobId)).map(item => (
                <li key={item.jobId} className={cn(
                  "border rounded-md p-3",
                  item.status === 'queued' && 'bg-blue-100/60',
                  item.status === 'running' && 'bg-yellow-100/60',
                  item.status === 'completed' && 'bg-green-100/60',
                  item.status === 'failed' && 'bg-red-100/60'
                )}>
                  <div className="flex items-center justify-between gap-2">
                    <div className="flex items-center gap-2 min-w-0">
                      <div className="shrink-0" title={item.jobType || 'job'}>
                        <JobTypeIcon jobType={item.jobType} />
                      </div>
                      <HoverCard openDelay={200} closeDelay={100}>
                        <HoverCardTrigger asChild>
                          <div className="truncate text-sm font-medium cursor-default" title={item.fileName || item.jobId}>{item.fileName || (item.operation || 'job')}</div>
                        </HoverCardTrigger>
                        <HoverCardContent side="top" align="start" className="w-[36rem] p-0 max-h-[85vh]">
                          <ScrollArea className="h-[80vh] overflow-y-auto p-2 text-xs">
                            <JobLogs jobId={item.jobId} />
                          </ScrollArea>
                        </HoverCardContent>
                      </HoverCard>
                    </div>
                    <div className="flex items-center gap-1 shrink-0 w-28 justify-end">
                      <button
                        onClick={() => hideJob(item.jobId)}
                        className="pointer-events-auto inline-flex items-center justify-center rounded p-1 hover:bg-muted"
                        aria-label="Ausblenden"
                        title="Ausblenden"
                      >
                        <Ban className="h-4 w-4" />
                      </button>
                      {(item.status === 'failed' || item.status === 'queued') && (
                        <button
                          onClick={() => retryJob(item.jobId)}
                          className="pointer-events-auto inline-flex items-center justify-center rounded p-1 hover:bg-muted"
                          aria-label="Neu starten"
                          title="Neu starten"
                        >
                          <RefreshCw className="h-4 w-4" />
                        </button>
                      )}
                      <StatusBadge status={item.status} />
                    </div>
                  </div>
                  <div className="mt-2 relative">
                    <Progress value={typeof item.lastProgress === 'number' ? Math.max(0, Math.min(100, item.lastProgress)) : 0} />
                    {item.status === 'running' && (
                      <div className="absolute inset-0 flex items-center justify-center text-[11px] text-muted-foreground">
                        Läuft…
                      </div>
                    )}
                    {item.status === 'completed' && (
                      <div className="absolute inset-0 flex items-center justify-center text-[11px] text-muted-foreground">
                        {formatDuration(item.createdAt, item.updatedAt)}
                      </div>
                    )}
                  </div>
                  <div className="mt-2 text-xs text-muted-foreground flex items-center justify-between gap-2">
                    <div className="truncate" title={item.lastMessage}>{item.lastMessage || '—'}</div>
                    <div>{formatRelative(item.updatedAt)}</div>
                  </div>
                </li>
              ))}
              {items.length === 0 && (
                <li className="text-sm text-muted-foreground py-6 text-center">Keine Jobs</li>
              )}
            </ul>
          </ScrollArea>
          <div className="p-3 border-t flex items-center justify-center">
            <Button size="sm" variant="outline" onClick={loadMore} disabled={!hasMore}>Ältere laden</Button>
          </div>
        </div>
      </div>
    </div>
  );
}

function JobLogs({ jobId }: { jobId: string }) {
  const [logs, setLogs] = useState<Array<{ timestamp: string; phase?: string; progress?: number; message?: string }>>([]);
  const [loaded, setLoaded] = useState(false);

  useEffect(() => {
    let active = true;
    async function load() {
      try {
        const res = await fetch(`/api/external/jobs/${jobId}?limit=50`, { cache: 'no-store' });
        if (!res.ok) return;
        const json = await res.json();
        if (!active) return;
        const l: Array<{ timestamp?: string; phase?: string; progress?: number; message?: string }> = Array.isArray(json.logs) ? json.logs : [];
        setLogs(l.map((e) => ({
          timestamp: String(e.timestamp),
          phase: typeof e.phase === 'string' ? e.phase : undefined,
          progress: typeof e.progress === 'number' ? e.progress : undefined,
          message: typeof e.message === 'string' ? e.message : undefined,
        })));
        setLoaded(true);
      } catch {
        // ignore
      }
    }
    if (!loaded) load();
    return () => { active = false; };
  }, [jobId, loaded]);

  if (!loaded) return <div className="text-muted-foreground">Lade Logs…</div>;
  // Filter: keinerlei reine Worker-Details ohne message nicht anzeigen
  const visible = logs.filter(l => (l.message && l.message.trim() !== ''));
  if (visible.length === 0) return <div className="text-muted-foreground">Keine Logs</div>;

  return (
    <div className="space-y-2">
      {visible.map((l, idx) => (
        <div key={idx} className="flex items-start justify-between gap-2">
          <div className="truncate">
            <div className="font-medium truncate">{l.message || '—'} {typeof l.progress === 'number' ? `(${Math.round(l.progress)}%)` : ''}</div>
          </div>
          <div className="text-muted-foreground">{formatClock(l.timestamp)}</div>
        </div>
      ))}
    </div>
  );
}

function WorkerControls() {
  const [status, setStatus] = useState<{ state: 'running'|'stopped'; stats?: { processed?: number; errors?: number } } | null>(null);
  const load = async () => {
    try {
      const res = await fetch('/api/external/jobs/worker', { cache: 'no-store' });
      if (!res.ok) return;
      const json = await res.json();
      setStatus(json);
    } catch {}
  };
  useEffect(() => { void load(); const t = setInterval(load, 5000); return () => clearInterval(t); }, []);
  const act = async (action: 'start'|'stop') => {
    try {
      const res = await fetch('/api/external/jobs/worker', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ action }) });
      if (!res.ok) return;
      const json = await res.json();
      setStatus(json);
    } catch {}
  };
  const running = status?.state === 'running';
  return (
    <span className="ml-auto inline-flex items-center gap-2">
      <button className="pointer-events-auto inline-flex items-center justify-center rounded px-2 py-0.5 border hover:bg-muted" onClick={() => void act('start')} aria-label="Worker starten" title="Worker starten">▶</button>
      <button className="pointer-events-auto inline-flex items-center justify-center rounded px-2 py-0.5 border hover:bg-muted" onClick={() => void act('stop')} aria-label="Worker stoppen" title="Worker stoppen">■</button>
      <span className="text-muted-foreground">{running ? 'läuft' : 'gestoppt'}</span>
    </span>
  );
}



```

- Ich habe einen einfachen, serverseitigen Job‑Worker eingebaut:
  - `src/lib/external-jobs-worker.ts`: Singleton mit Polling, Concurrency, Status/Stats, Start/Stop.
  - `src/app/api/external/jobs/worker/route.ts`: API
    - GET: Status
    - POST {action: 'start'|'stop'}: Start/Stop und Status zurück.
  - `src/components/shared/job-monitor-panel.tsx`: Play/Stop eingebaut; Statusanzeige „läuft/gestoppt“. Buttons steuern den Worker via obiger API.

- Verhalten
  - Beim Starten pollt der Worker in Intervallen (`JOBS_WORKER_INTERVAL_MS`, default 2000 ms) und nimmt bis zu `JOBS_WORKER_CONCURRENCY` (default 3) `queued` Jobs auf.
  - Für die Abarbeitung ruft er pro Job die vorhandene Retry‑Route auf; damit bleibt die Ausführung zentral und robust.
  - Neustarts: Da `queued` in der DB stehen, kannst du nach Server‑Neustart den Worker wieder starten; er arbeitet weiter.

- Nächste Schritte (optional)
  - Auto‑Start beim Server‑Boot via einfachem einmaligen Aufruf in einer init‑Route oder bei erstem GET an `/api/external/jobs/worker`.
  - Concurrency/Interval über Library‑Settings konfigurierbar machen.
  - Visualisierung im Panel erweitern: verarbeitete/Fehler‑Zähler, letzte Ticks.

Bitte teste im Job‑Panel:
- Play klicken → Status „läuft“, `queued` Jobs beginnen nach und nach auf „running“ zu wechseln.
- Stop klicken → Status „gestoppt“, keine neuen Starts mehr.

---

**User**

In der File-List-Ansicht möchte ich auch mit dem Cursor-Tasten oben und unten klicken und das vorherige und nächste Datei einspringen.

---

**Cursor**

Ich prüfe zuerst die aktuelle `FileList`-Implementierung und den zuständigen Atom für die Auswahl, damit ich Arrow-Key-Navigation sauber anbinden kann. Danach ergänze ich die Keydown-Logik und Fokussteuerung.

```typescriptreact
'use client';

import * as React from "react"
import { File, FileText, FileVideo, FileAudio, Plus, RefreshCw, ChevronUp, ChevronDown, Trash2, ScrollText, Folder as FolderIcon, Layers } from "lucide-react"
import { StorageItem } from "@/lib/storage/types"
import { cn } from "@/lib/utils"
import { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from "@/components/ui/tooltip"
import { useStorage } from "@/contexts/storage-context";
import { Button } from "@/components/ui/button";
import { useAtomValue, useAtom } from 'jotai';
import { jobStatusByItemIdAtom } from '@/atoms/job-status';
import { 
  activeLibraryIdAtom, 
  selectedFileAtom, 
  folderItemsAtom,
  sortedFilteredFilesAtom,
  sortFieldAtom,
  sortOrderAtom,
  selectedShadowTwinAtom
} from '@/atoms/library-atom';
import { toast } from "sonner";
import { Input } from "@/components/ui/input"
import {
  selectedBatchItemsAtom,
  transcriptionDialogOpenAtom,
  selectedTransformationItemsAtom,
  transformationDialogOpenAtom,
  getMediaType,
  fileCategoryFilterAtom,
} from '@/atoms/transcription-options';
import { Checkbox } from "@/components/ui/checkbox"
import { useMemo, useCallback } from "react"
import { FileLogger, StateLogger } from "@/lib/debug/logger"
import { FileCategoryFilter } from './file-category-filter';
import { useFolderNavigation } from "@/hooks/use-folder-navigation";

// Typen für Sortieroptionen
type SortField = 'type' | 'name' | 'size' | 'date';
type SortOrder = 'asc' | 'desc';

// Typ für gruppierte Dateien
interface FileGroup {
  baseItem?: StorageItem;
  transcriptFiles?: StorageItem[]; // NEU: alle Transkripte
  transformed?: StorageItem;
}

// Memoized file icon component
const FileIconComponent = React.memo(function FileIconComponent({ item }: { item: StorageItem }) {
  const mimeType = item.metadata.mimeType || '';
  if (!mimeType) return <File className="h-4 w-4" />;

  if (mimeType.startsWith('video/')) {
    return <FileVideo className="h-4 w-4" />;
  } else if (mimeType.startsWith('audio/')) {
    return <FileAudio className="h-4 w-4" />;
  } else if (mimeType.startsWith('text/')) {
    return <FileText className="h-4 w-4" />;
  }

  return <File className="h-4 w-4" />;
});

// Pure function for file size formatting
const formatFileSize = (size?: number): string => {
  if (!size) return '-';
  const units = ['B', 'KB', 'MB', 'GB'];
  let value = size;
  let unitIndex = 0;
  
  while (value >= 1024 && unitIndex < units.length - 1) {
    value /= 1024;
    unitIndex++;
  }
  
  return `${value.toFixed(1)} ${units[unitIndex]}`;
};

// Funktion zum Formatieren des Datums
const formatDate = (date?: Date): string => {
  if (!date) return '-';
  
  const options: Intl.DateTimeFormatOptions = { 
    year: '2-digit', 
    month: '2-digit', 
    day: '2-digit',
    hour: '2-digit',
    minute: '2-digit'
  };
  
  return new Date(date).toLocaleDateString('de-DE', options);
};

// Entfernt: getFileStem Funktion war unbenutzt

// Sortierbare Kopfzelle Komponente
const SortableHeaderCell = React.memo(function SortableHeaderCell({
  label,
  field,
  currentSortField,
  currentSortOrder,
  onSort
}: {
  label: string,
  field: SortField,
  currentSortField: SortField,
  currentSortOrder: SortOrder,
  onSort: (field: SortField) => void
}) {
  const isActive = currentSortField === field;
  
  return (
    <button 
      onClick={() => onSort(field)}
      className="flex items-center gap-1 hover:text-foreground"
    >
      <span>{label}</span>
      {isActive && (
        currentSortOrder === 'asc' 
          ? <ChevronUp className="h-3 w-3" /> 
          : <ChevronDown className="h-3 w-3" />
      )}
    </button>
  );
});

interface FileRowProps {
  item: StorageItem;
  isSelected: boolean;
  isActive?: boolean;
  onSelect: () => void;
  onCreateTranscript: (e: React.MouseEvent) => void;
  onDelete: (e: React.MouseEvent<HTMLButtonElement>, item: StorageItem) => void;
  fileGroup?: FileGroup;
  onSelectRelatedFile?: (file: StorageItem) => void;
  onRename?: (item: StorageItem, newName: string) => Promise<void>;
  compact?: boolean;
  systemFolderId?: string;
}

const FileRow = React.memo(function FileRow({ 
  item, 
  isSelected, 
  isActive = false,
  onSelect,
  onCreateTranscript,
  onDelete,
  fileGroup,
  onSelectRelatedFile,
  onRename,
  compact = false,
  systemFolderId
}: FileRowProps) {
  const navigateToFolder = useFolderNavigation();
  const [isEditing, setIsEditing] = React.useState(false);
  const [editName, setEditName] = React.useState(item.metadata.name);
  const inputRef = React.useRef<HTMLInputElement>(null);
  const longPressTimerRef = React.useRef<NodeJS.Timeout | null>(null);
  const lastClickTimeRef = React.useRef<number>(0);
  
  // Zusätzliche Validierung der Metadaten
  const metadata = React.useMemo(() => ({
    name: item.metadata?.name || 'Unbekannte Datei',
    size: typeof item.metadata?.size === 'number' ? item.metadata.size : 0,
    mimeType: item.metadata?.mimeType || '',
    hasTranscript: !!item.metadata?.hasTranscript || (fileGroup?.transcriptFiles && fileGroup.transcriptFiles.length > 0),
    modifiedAt: item.metadata?.modifiedAt
  }), [item.metadata, fileGroup]);

  const isTranscribable = React.useMemo(() => {
    const mimeType = metadata.mimeType.toLowerCase();
    const extension = metadata.name.split('.').pop()?.toLowerCase();

    return (
      mimeType.startsWith('audio/') ||
      mimeType.startsWith('video/') ||
      extension === 'pdf' ||
      mimeType === 'application/pdf'
    );
  }, [metadata.mimeType, metadata.name]);

  // Memoize the click handler
  const handleClick = React.useCallback(() => {
    if (!isEditing) {
      onSelect();
    }
  }, [onSelect, isEditing]);

  // Memoize the keydown handler
  const handleKeyDown = React.useCallback((e: React.KeyboardEvent) => {
    if (!isEditing && (e.key === 'Enter' || e.key === ' ')) {
      onSelect();
    }
  }, [onSelect, isEditing]);

  // Handler für Transkript-Icon Click
  const handleTranscriptClick = React.useCallback((e: React.MouseEvent) => {
    e.stopPropagation();
    if (fileGroup?.transcriptFiles && onSelectRelatedFile) {
      onSelectRelatedFile(fileGroup.transcriptFiles[0]); // Nur das erste Transkript anzeigen
    }
  }, [fileGroup, onSelectRelatedFile]);

  // Handler für Transformierte-Datei-Icon Click
  const handleTransformedClick = React.useCallback((e: React.MouseEvent) => {
    e.stopPropagation();
    if (fileGroup?.transformed && onSelectRelatedFile) {
      onSelectRelatedFile(fileGroup.transformed);
    }
  }, [fileGroup, onSelectRelatedFile]);

  // Starte Rename-Modus
  const startRename = React.useCallback(() => {
    if (onRename) {
      // Prüfe ob dies eine abhängige Datei ist
      if (fileGroup && (
        (fileGroup.transcriptFiles && fileGroup.transcriptFiles.length > 0 && fileGroup.transcriptFiles[0]?.id === item.id) ||
        (fileGroup.transformed && item.id === fileGroup.transformed.id)
      )) {
        // Dies ist eine abhängige Datei - zeige Hinweis
        toast.info("Hinweis", {
          description: "Bitte benennen Sie die Haupt-Datei um. Abhängige Dateien werden automatisch mit umbenannt."
        });
        return;
      }
      
      setIsEditing(true);
      setEditName(item.metadata.name);
    }
  }, [onRename, item, fileGroup]);

  // Handler für Dateinamen-Click (Doppelklick-Erkennung)
  const handleNameClick = React.useCallback((e: React.MouseEvent) => {
    e.stopPropagation();
    
    const currentTime = Date.now();
    const timeSinceLastClick = currentTime - lastClickTimeRef.current;
    
    if (timeSinceLastClick < 300) {
      // Doppelklick erkannt
      startRename();
    } else {
      // Erster Klick - wähle die Datei aus
      onSelect();
    }
    
    lastClickTimeRef.current = currentTime;
  }, [startRename, onSelect]);

  // Handler für Long-Press (Touch-Geräte)
  const handleTouchStart = React.useCallback((e: React.TouchEvent) => {
    e.stopPropagation();
    
    // Starte Long-Press Timer
    longPressTimerRef.current = setTimeout(() => {
      startRename();
    }, 500); // 500ms für Long-Press
  }, [startRename]);

  const handleTouchEnd = React.useCallback((e: React.TouchEvent) => {
    e.stopPropagation();
    
    // Lösche Long-Press Timer
    if (longPressTimerRef.current) {
      clearTimeout(longPressTimerRef.current);
      longPressTimerRef.current = null;
    }
  }, []);

  const handleTouchMove = React.useCallback(() => {
    // Bei Bewegung Long-Press abbrechen
    if (longPressTimerRef.current) {
      clearTimeout(longPressTimerRef.current);
      longPressTimerRef.current = null;
    }
  }, []);

  // Cleanup Timer bei Unmount
  React.useEffect(() => {
    return () => {
      if (longPressTimerRef.current) {
        clearTimeout(longPressTimerRef.current);
      }
    };
  }, []);

  // Handler für Rename-Submit
  const handleRenameSubmit = React.useCallback(async () => {
    if (onRename && editName.trim() && editName !== item.metadata.name) {
      try {
        await onRename(item, editName.trim());
      } catch (error) {
        FileLogger.error('FileRow', 'Fehler beim Umbenennen', error);
        // Bei Fehler den ursprünglichen Namen wiederherstellen
        setEditName(item.metadata.name);
      }
    }
    setIsEditing(false);
  }, [onRename, editName, item]);

  // Handler für Rename-Cancel
  const handleRenameCancel = React.useCallback(() => {
    setEditName(item.metadata.name);
    setIsEditing(false);
  }, [item.metadata.name]);

  // Handler für Input-Änderungen
  const handleInputChange = React.useCallback((e: React.ChangeEvent<HTMLInputElement>) => {
    setEditName(e.target.value);
  }, []);

  // Handler für Input-Keydown
  const handleInputKeyDown = React.useCallback((e: React.KeyboardEvent<HTMLInputElement>) => {
    e.stopPropagation();
    if (e.key === 'Enter') {
      handleRenameSubmit();
    } else if (e.key === 'Escape') {
      handleRenameCancel();
    }
  }, [handleRenameSubmit, handleRenameCancel]);

  // Focus Input wenn Edit-Modus aktiviert wird
  React.useEffect(() => {
    if (isEditing && inputRef.current) {
      inputRef.current.focus();
      inputRef.current.select();
    }
  }, [isEditing]);

  // Handler für Drag Start
  const handleDragStart = React.useCallback((e: React.DragEvent) => {
    // Sammle alle Dateien der Gruppe, die verschoben werden sollen
    const itemsToMove = [];
    
    // Füge das aktuelle Item hinzu
    itemsToMove.push({
      itemId: item.id,
      itemName: item.metadata.name,
      itemType: item.type,
      parentId: item.parentId
    });
    
    // Wenn es eine FileGroup gibt, füge auch die zugehörigen Dateien hinzu
    if (fileGroup) {
      // Prüfe ob das aktuelle Item die Basis-Datei ist
      if (item.id === fileGroup.baseItem?.id) {
        // Füge Transkripte hinzu, falls vorhanden
        if (fileGroup.transcriptFiles && fileGroup.transcriptFiles.length > 0) {
          fileGroup.transcriptFiles.forEach(transcript => {
            itemsToMove.push({
              itemId: transcript.id,
              itemName: transcript.metadata.name,
              itemType: transcript.type,
              parentId: transcript.parentId
            });
          });
        }
        
        // Füge transformierte Datei hinzu, falls vorhanden
        if (fileGroup.transformed) {
          itemsToMove.push({
            itemId: fileGroup.transformed.id,
            itemName: fileGroup.transformed.metadata.name,
            itemType: fileGroup.transformed.type,
            parentId: fileGroup.transformed.parentId
          });
        }
      }
    }
    
    // Setze die Drag-Daten
    e.dataTransfer.effectAllowed = 'move';
    e.dataTransfer.setData('application/json', JSON.stringify({
      items: itemsToMove,
      isFileGroup: itemsToMove.length > 1
    }));
    
    // Visuelles Feedback
    if (e.currentTarget instanceof HTMLElement) {
      e.currentTarget.style.opacity = '0.5';
    }
  }, [item, fileGroup]);

  // Handler für Drag End
  const handleDragEnd = React.useCallback((e: React.DragEvent) => {
    // Stelle Opacity wieder her
    if (e.currentTarget instanceof HTMLElement) {
      e.currentTarget.style.opacity = '1';
    }
  }, []);

  const [selectedBatchItems, setSelectedBatchItems] = useAtom(selectedBatchItemsAtom);
  const [selectedTransformationItems, setSelectedTransformationItems] = useAtom(selectedTransformationItemsAtom);
  
  // Prüfe ob das Item in einem der beiden Atome ausgewählt ist
  const isInBatch = selectedBatchItems.some(batchItem => batchItem.item.id === item.id);
  const isInTransformation = selectedTransformationItems.some(transformationItem => transformationItem.item.id === item.id);
  const isInAnyBatch = isInBatch || isInTransformation;

  // Handler für Checkbox-Änderungen
  const handleCheckboxChange = React.useCallback((checked: boolean) => {
    const mediaType = getMediaType(item);
    
    if (mediaType === 'audio' || mediaType === 'video') {
      // Für Audio/Video: Transcription-Atom verwenden
      if (checked) {
        setSelectedBatchItems([...selectedBatchItems, {
          item,
          type: mediaType
        }]);
      } else {
        setSelectedBatchItems(selectedBatchItems.filter(i => i.item.id !== item.id));
      }
    } else if (mediaType === 'text' || mediaType === 'document') {
      // Für Text/Dokumente: Transformation-Atom verwenden
      if (checked) {
        setSelectedTransformationItems([...selectedTransformationItems, {
          item,
          type: mediaType
        }]);
      } else {
        setSelectedTransformationItems(selectedTransformationItems.filter(i => i.item.id !== item.id));
      }
    }
  }, [item, selectedBatchItems, selectedTransformationItems, setSelectedBatchItems, setSelectedTransformationItems]);

  React.useEffect(() => {
    if (fileGroup) {
      FileLogger.debug('FileRow', 'Transkripte für Zeile', {
        baseItem: fileGroup.baseItem?.metadata.name,
        transcripts: fileGroup.transcriptFiles?.map(t => t.metadata.name)
      });
    }
  }, [fileGroup]);

  // Zentraler Jobstatus (muss vor möglichen early-returns stehen, um Hook-Order zu garantieren)
  const jobStatusMap = useAtomValue(jobStatusByItemIdAtom);
  const jobStatus = jobStatusMap[item.id];
  const jobStatusIcon = jobStatus ? (
    <span title={jobStatus} className={cn('inline-block h-3 w-3 rounded-full',
      jobStatus === 'queued' && 'bg-blue-600',
      jobStatus === 'running' && 'bg-yellow-600',
      jobStatus === 'completed' && 'bg-green-600',
      jobStatus === 'failed' && 'bg-red-600'
    )} aria-label={`job-${jobStatus}`} />
  ) : null;

  // Compact-Modus: vereinfachte Darstellung
  if (compact) {
    return (
      <div
        role="button"
        tabIndex={0}
        onClick={handleClick}
        onKeyDown={handleKeyDown}
        className={cn(
          "w-full px-2 py-1 text-xs hover:bg-muted/50 grid grid-cols-[24px_minmax(0,1fr)] gap-2 items-center cursor-pointer",
          isSelected && "bg-muted",
          isActive && "bg-primary/10 border-l-2 border-primary"
        )}
      >
        <FileIconComponent item={item} />
        <span className={cn("truncate", isActive && "font-medium")} title={metadata.name}>
          {metadata.name}
        </span>
      </div>
    );
  }

  return (
    <div
      role="button"
      tabIndex={0}
      onClick={handleClick}
      onKeyDown={handleKeyDown}
      onTouchStart={handleTouchStart}
      onTouchEnd={handleTouchEnd}
      onTouchMove={handleTouchMove}
      draggable={!isEditing}
      onDragStart={handleDragStart}
      onDragEnd={handleDragEnd}
      className={cn(
        "w-full px-4 py-2 text-xs hover:bg-muted/50 grid grid-cols-[24px_24px_minmax(0,1fr)_56px_88px_auto] gap-2 items-center cursor-move",
        isSelected && "bg-muted",
        isActive && "bg-primary/10 border-l-2 border-primary"
      )}
    >
      <div className="w-6 flex items-center justify-center">
        <Checkbox
          checked={isInAnyBatch}
          onCheckedChange={handleCheckboxChange}
          onClick={(e) => e.stopPropagation()}
        />
      </div>
      <FileIconComponent item={item} />
      {isEditing ? (
        <Input
          ref={inputRef}
          value={editName}
          onChange={handleInputChange}
          onKeyDown={handleInputKeyDown}
          onBlur={handleRenameSubmit}
          onClick={(e) => e.stopPropagation()}
          className="h-6 px-1 py-0 text-xs"
        />
      ) : (
        <span 
          className={cn("text-left truncate cursor-pointer hover:text-primary select-none", isActive && "font-medium")}
          onClick={handleNameClick}
          onTouchStart={handleTouchStart}
          onTouchEnd={handleTouchEnd}
          onTouchMove={handleTouchMove}
          title={metadata.name}
        >
          {metadata.name}
        </span>
      )}
      <span className="text-muted-foreground tabular-nums text-[10px]">
        {formatFileSize(metadata.size)}
      </span>
      <span className="text-muted-foreground tabular-nums text-[10px]">
        {formatDate(metadata.modifiedAt)}
      </span>
      <div className="flex items-center justify-start gap-1">
        {jobStatusIcon}
        {/* System-Unterordner (z. B. extrahierte Seiten) */}
        {systemFolderId && (
          <TooltipProvider>
            <Tooltip>
              <TooltipTrigger asChild>
                <Button
                  variant="ghost"
                  size="icon"
                  className="h-6 w-6 p-0 hover:bg-muted"
                  onClick={(e) => {
                    e.stopPropagation();
                    navigateToFolder(systemFolderId);
                  }}
                >
                  <Layers className="h-4 w-4 text-violet-500" />
                </Button>
              </TooltipTrigger>
              <TooltipContent>
                <p>Seiten-Ordner öffnen</p>
              </TooltipContent>
            </Tooltip>
          </TooltipProvider>
        )}
        {/* Zeige Icons für alle vorhandenen Transkripte */}
        {fileGroup?.transcriptFiles && fileGroup.transcriptFiles.length > 0 && fileGroup.transcriptFiles.map((transcript) => (
          <TooltipProvider key={transcript.id}>
            <Tooltip>
              <TooltipTrigger asChild>
                <Button
                  variant="ghost"
                  size="icon"
                  className="h-6 w-6 p-0 hover:bg-muted"
                  onClick={(e) => {
                    e.stopPropagation();
                    if (onSelectRelatedFile) onSelectRelatedFile(transcript);
                  }}
                >
                  <FileText className="h-4 w-4 text-blue-500" />
                </Button>
              </TooltipTrigger>
              <TooltipContent>
                <p>Transkript anzeigen: {transcript.metadata.name}</p>
              </TooltipContent>
            </Tooltip>
          </TooltipProvider>
        ))}
        {/* Plus-Symbol nur anzeigen, wenn kein Transkript vorhanden und transkribierbar */}
        {(!fileGroup?.transcriptFiles || fileGroup.transcriptFiles.length === 0) && isTranscribable && !metadata.hasTranscript ? (
          <TooltipProvider>
            <Tooltip>
              <TooltipTrigger asChild>
                <div 
                  role="button"
                  tabIndex={0}
                  className="h-6 w-6 p-0 inline-flex items-center justify-center hover:bg-muted rounded-sm"
                  onClick={onCreateTranscript}
                  onKeyDown={(e) => {
                    if (e.key === 'Enter' || e.key === ' ') {
                      e.stopPropagation();
                      onCreateTranscript(e as unknown as React.MouseEvent<HTMLDivElement>);
                    }
                  }}
                >
                  <Plus className="h-4 w-4" />
                </div>
              </TooltipTrigger>
              <TooltipContent>
                <p>Transkript erstellen</p>
              </TooltipContent>
            </Tooltip>
          </TooltipProvider>
        ) : null}
        {/* Icon für transformierte Datei */}
        {fileGroup?.transformed && (
          <TooltipProvider>
            <Tooltip>
              <TooltipTrigger asChild>
                <Button
                  variant="ghost"
                  size="icon"
                  className="h-6 w-6 p-0 hover:bg-muted"
                  onClick={handleTransformedClick}
                >
                  <ScrollText className="h-4 w-4 text-green-500" />
                </Button>
              </TooltipTrigger>
              <TooltipContent>
                <p>Transformierte Datei anzeigen</p>
              </TooltipContent>
            </Tooltip>
          </TooltipProvider>
        )}
        {/* Delete direkt neben Dokument-Icons */}
        <TooltipProvider>
          <Tooltip>
            <TooltipTrigger asChild>
              <Button
                variant="ghost"
                size="icon"
                className="h-6 w-6 p-0 hover:bg-destructive/10 hover:text-destructive"
                onClick={(e) => onDelete(e as React.MouseEvent<HTMLButtonElement>, item)}
              >
                <Trash2 className="h-4 w-4" />
              </Button>
            </TooltipTrigger>
            <TooltipContent>
              <p>Datei löschen</p>
            </TooltipContent>
          </Tooltip>
        </TooltipProvider>
      </div>
      <div />
    </div>
  );
});

interface FileListProps {
  compact?: boolean;
}

export const FileList = React.memo(function FileList({ compact = false }: FileListProps): JSX.Element {
  const { provider, refreshItems, currentLibrary } = useStorage();
  const activeLibraryId = useAtomValue(activeLibraryIdAtom);
  const [isRefreshing, setIsRefreshing] = React.useState(false);
  // Mobile-Flag wurde entfernt, FileList lädt unabhängig vom View
  const [selectedBatchItems, setSelectedBatchItems] = useAtom(selectedBatchItemsAtom);
  const [selectedTransformationItems, setSelectedTransformationItems] = useAtom(selectedTransformationItemsAtom);
  const [, setTranscriptionDialogOpen] = useAtom(transcriptionDialogOpenAtom);
  const [, setTransformationDialogOpen] = useAtom(transformationDialogOpenAtom);
  const [isInitialized, setIsInitialized] = React.useState(false);
  const initializationTimeoutRef = React.useRef<NodeJS.Timeout | null>(null);
  // Entkoppelt: Kein Warten mehr auf FileTree-Status
  const [activeFile, setSelectedFile] = useAtom(selectedFileAtom);
  const [, setFolderItems] = useAtom(folderItemsAtom);
  const currentCategoryFilter = useAtomValue(fileCategoryFilterAtom);
  const allItemsInFolder = useAtomValue(folderItemsAtom);
  const navigateToFolder = useFolderNavigation();
  const listContainerRef = React.useRef<HTMLDivElement | null>(null);

  // Kein mobiles Flag mehr notwendig

  const folders = useMemo(() => {
    const items = allItemsInFolder ?? [];
    // Verstecke dot-Verzeichnisse generell in der Liste
    return items.filter(item => item.type === 'folder' && !item.metadata.name.startsWith('.'));
  }, [allItemsInFolder]);

  // Hilfsfunktion zum Finden einer FileGroup in der Map
  const findFileGroup = (map: Map<string, FileGroup>, stem: string): FileGroup | undefined => {
    return Array.from((map ?? new Map()).values()).find(group => 
      group.baseItem && getBaseName(group.baseItem.metadata.name) === stem
    );
  };

  // NEU: Atome für Sortierung und Filter
  const items = useAtomValue(sortedFilteredFilesAtom);
  const [sortField, setSortField] = useAtom(sortFieldAtom);
  const [sortOrder, setSortOrder] = useAtom(sortOrderAtom);
  
  // Review-Mode-Atoms
  const [, setSelectedShadowTwin] = useAtom(selectedShadowTwinAtom);

  // handleSort nutzt jetzt Atome
  const handleSort = React.useCallback((field: SortField) => {
    if (field === sortField) setSortOrder(sortOrder === 'asc' ? 'desc' : 'asc');
    else {
      setSortField(field);
      setSortOrder('asc');
    }
  }, [sortField, sortOrder, setSortField, setSortOrder]);

  // Initialisierung - nur auf Provider und Mobile-Flag achten
  React.useEffect(() => {
    if (!provider) {
      FileLogger.info('FileList', 'Waiting for provider');
      return;
    }

    const initialize = async () => {
      if (isInitialized) {
        FileLogger.debug('FileList', 'Already initialized');
        return;
      }

      FileLogger.info('FileList', 'Starting initialization');

      try {
        FileLogger.info('FileList', 'Initialization complete');
        setIsInitialized(true);
      } catch (error) {
        FileLogger.error('FileList', 'Error initializing FileList', error);
      }
    };

    initialize();

    const timeoutRef = initializationTimeoutRef.current;
    return () => {
      if (timeoutRef) clearTimeout(timeoutRef);
    };
  }, [provider, isInitialized]);

  // NEU: Reagieren auf Bibliothekswechsel
  const prevLibraryIdRef = React.useRef<string | null>(null);
  React.useEffect(() => {
    StateLogger.debug('FileList', 'Render', {
      currentLibraryId: activeLibraryId,
      activeLibraryIdAtom: activeLibraryId
    });

    // Nur bei tatsächlichem Bibliothekswechsel zurücksetzen
    if (prevLibraryIdRef.current !== null && prevLibraryIdRef.current !== activeLibraryId) {
      setIsInitialized(false);
      setSelectedFile(null);
      setFolderItems([]);
      setSelectedBatchItems([]);
      setSelectedTransformationItems([]);
      setSelectedShadowTwin(null);
      StateLogger.info('FileList', 'Bibliothek gewechselt - State zurückgesetzt', {
        libraryId: activeLibraryId
      });
    }
    prevLibraryIdRef.current = activeLibraryId;
  }, [activeLibraryId, setSelectedFile, setFolderItems, setSelectedBatchItems, setSelectedTransformationItems, setSelectedShadowTwin]);

  // Vereinfachte Funktion zum Extrahieren des Basisnamens (ohne Endung, auch für Binärdateien)
  function getBaseName(name: string): string {
    // ShadowTwin: .de.md, .en.md, etc.
    const shadowTwinMatch = name.match(/^(.*)\.(de|en|fr|es|it)\.md$/);
    if (shadowTwinMatch) return shadowTwinMatch[1];
    // Sonst: alles vor der letzten Endung
    const lastDot = name.lastIndexOf('.');
    if (lastDot === -1) return name;
    return name.substring(0, lastDot);
  }

  // Prüft ob eine Datei ein ShadowTwin ist (Markdown mit Sprachkürzel)
  function isShadowTwin(name: string): boolean {
    // Pattern: name.de.md, name.en.md, etc.
    const shadowTwinPattern = /^(.+)\.(de|en|fr|es|it)\.md$/;
    return shadowTwinPattern.test(name);
  }

  // Gruppiere die Dateien nach Basename
  const fileGroups = useMemo(() => {
    if (!items) return new Map<string, FileGroup>();

    // Schritt 1: Gruppiere alle Dateien nach Basename
    const groupsMap = new Map<string, StorageItem[]>();
    for (const item of items) {
      if (item.type !== 'file') continue;
      const base = getBaseName(item.metadata.name);
      if (!groupsMap.has(base)) groupsMap.set(base, []);
      groupsMap.get(base)!.push(item);
    }

    // Schritt 2: Erstelle FileGroups
    const fileGroupsMap = new Map<string, FileGroup>();
    for (const [base, groupItems] of Array.from(groupsMap.entries())) {
      // Finde Hauptdatei (erste Nicht-ShadowTwin-Datei)
      const mainFile = groupItems.find((item) => !isShadowTwin(item.metadata.name));
      // Finde alle ShadowTwins
      const shadowTwins = groupItems.filter((item) => isShadowTwin(item.metadata.name));
      if (mainFile) {
        fileGroupsMap.set(base, {
          baseItem: mainFile,
          transcriptFiles: shadowTwins.length > 0 ? shadowTwins : undefined,
          transformed: undefined
        });
      } else {
        // Keine Hauptdatei: Jede ShadowTwin einzeln anzeigen
        for (const twin of shadowTwins) {
          fileGroupsMap.set(`${base}__shadow_${twin.id}`, {
            baseItem: twin,
            transcriptFiles: undefined,
            transformed: undefined
          });
        }
      }
    }
    // Debug-Logging für Gruppierung
    FileLogger.debug('FileList', 'Gruppierung Ergebnis (Basename, alle Endungen)', {
      groups: Array.from(fileGroupsMap.entries()).map(([base, group]) => ({
        base,
        baseItem: group.baseItem?.metadata.name,
        transcripts: group.transcriptFiles?.map(t => t.metadata.name)
      }))
    });
    return fileGroupsMap;
  }, [items]);

  // Navigationsliste: nur Hauptdateien in der aktuell sichtbaren Reihenfolge
  const mainFileItems = React.useMemo(() => {
    return Array.from((fileGroups ?? new Map()).values())
      .map(g => g.baseItem)
      .filter((it): it is StorageItem => Boolean(it));
  }, [fileGroups]);

  // Hilfsfunktion: Gruppe anhand baseItem.id finden
  const findGroupByBaseItemId = React.useCallback((baseItemId: string) => {
    for (const g of Array.from((fileGroups ?? new Map()).values())) {
      if (g.baseItem && g.baseItem.id === baseItemId) return g;
    }
    return undefined;
  }, [fileGroups]);

  // Keyboard-Navigation: Pfeil hoch/runter wählt vorherige/nächste Datei
  const handleKeyNav = React.useCallback((e: React.KeyboardEvent<HTMLDivElement>) => {
    if (e.key !== 'ArrowDown' && e.key !== 'ArrowUp') return;
    // Eingaben in aktiven Inputs nicht stören
    const ae = document.activeElement as HTMLElement | null;
    if (ae && (ae.tagName === 'INPUT' || ae.tagName === 'TEXTAREA' || ae.isContentEditable)) return;
    if (mainFileItems.length === 0) return;
    e.preventDefault();
    const currentIndex = activeFile ? mainFileItems.findIndex(it => it.id === activeFile.id) : -1;
    const nextIndex = e.key === 'ArrowDown'
      ? Math.min((currentIndex < 0 ? 0 : currentIndex + 1), mainFileItems.length - 1)
      : Math.max((currentIndex < 0 ? 0 : currentIndex - 1), 0);
    const nextItem = mainFileItems[nextIndex];
    if (!nextItem) return;
    const group = findGroupByBaseItemId(nextItem.id);
    handleSelect(nextItem, group);
    // Sichtbar scrollen
    const rowEl = document.getElementById(`file-row-${nextItem.id}`);
    if (rowEl) rowEl.scrollIntoView({ block: 'nearest' });
  }, [activeFile, mainFileItems, handleSelect, findGroupByBaseItemId]);

  // Mapping: Basename -> dot-Systemordner (z. B. ".<basename>")
  const systemFolderByBase = useMemo(() => {
    const map = new Map<string, StorageItem>();
    const items = allItemsInFolder ?? [];
    for (const it of items) {
      if (it.type !== 'folder') continue;
      const name = it.metadata.name;
      if (!name.startsWith('.')) continue;
      const base = name.slice(1);
      if (base) map.set(base, it);
    }
    return map;
  }, [allItemsInFolder]);

  // Berechne, ob alle Dateien ausgewählt sind
  const isAllSelected = useMemo(() => {
    if (!fileGroups || !fileGroups.size) return false;
    // Verwende nur die Hauptdateien (baseItem) aus den FileGroups
    const mainItems = Array.from((fileGroups ?? new Map()).values())
      .map(group => group.baseItem)
      .filter((item): item is StorageItem => item !== undefined);
    // Je nach Filter unterschiedliche Dateien zählen
    let selectableItems: StorageItem[] = [];
    switch (currentCategoryFilter) {
      case 'media':
        selectableItems = mainItems.filter(item => {
          try {
            const mediaType = getMediaType(item);
            return item.type === 'file' && (mediaType === 'audio' || mediaType === 'video');
          } catch {
            return false;
          }
        });
        return selectableItems.length > 0 && selectedBatchItems.length === selectableItems.length;
      case 'text':
        selectableItems = mainItems.filter(item => {
          try {
            const mediaType = getMediaType(item);
            return item.type === 'file' && mediaType === 'text';
          } catch {
            return false;
          }
        });
        return selectableItems.length > 0 && selectedTransformationItems.length === selectableItems.length;
      case 'documents':
        selectableItems = mainItems.filter(item => {
          try {
            const mediaType = getMediaType(item);
            return item.type === 'file' && mediaType === 'document';
          } catch {
            return false;
          }
        });
        return selectableItems.length > 0 && selectedTransformationItems.length === selectableItems.length;
      default:
        // Bei 'all' prüfen ob alle verfügbaren Dateien ausgewählt sind
        const mediaItems = mainItems.filter(item => {
          try {
            const mediaType = getMediaType(item);
            return item.type === 'file' && (mediaType === 'audio' || mediaType === 'video');
          } catch {
            return false;
          }
        });
        const textItems = mainItems.filter(item => {
          try {
            const mediaType = getMediaType(item);
            return item.type === 'file' && (mediaType === 'text' || mediaType === 'document');
          } catch {
            return false;
          }
        });
        const allMediaSelected = mediaItems.length === 0 || selectedBatchItems.length === mediaItems.length;
        const allTextSelected = textItems.length === 0 || selectedTransformationItems.length === textItems.length;
        return allMediaSelected && allTextSelected;
    }
  }, [fileGroups, selectedBatchItems, selectedTransformationItems, currentCategoryFilter]);
  
  // Erweiterte handleSelect Funktion für Review-Mode
  const handleSelect = useCallback((item: StorageItem, group?: FileGroup) => {
    FileLogger.debug('FileList', 'handleSelect aufgerufen', {
      itemId: item.id,
      itemName: item.metadata.name,
      groupBase: group?.baseItem?.metadata.name,
      transcriptCount: group?.transcriptFiles?.length ?? 0,
      hasTranscripts: !!(group && group.transcriptFiles && group.transcriptFiles.length > 0)
    });
    
    // Nur die ausgewählte Datei setzen - Review-Modus wird über Toggle-Button gesteuert
    setSelectedFile(item);
    
    // Wenn wir im Review-Modus sind und eine Basis-Datei mit Shadow-Twin ausgewählt wird,
    // dann automatisch das Shadow-Twin setzen
    if (group && group.transcriptFiles && group.transcriptFiles.length > 0) {
      const shadowTwin = group.transcriptFiles[0];
      FileLogger.info('FileList', 'Basis-Datei mit Shadow-Twin ausgewählt', {
        twinId: shadowTwin.id,
        twinName: shadowTwin.metadata.name,
        baseFileId: item.id,
        baseFileName: item.metadata.name
      });
      setSelectedShadowTwin(shadowTwin);
    } else {
      FileLogger.info('FileList', 'Datei ohne Shadow-Twin ausgewählt', {
        itemId: item.id,
        itemName: item.metadata.name,
        groupExists: !!group,
        transcriptCount: group?.transcriptFiles?.length ?? 0
      });
      setSelectedShadowTwin(null);
    }
  }, [setSelectedFile, setSelectedShadowTwin, findFileGroup]);
  
  // Erweiterte handleSelectRelatedFile Funktion für Review-Mode
  const handleSelectRelatedFile = useCallback((shadowTwin: StorageItem) => {
    StateLogger.info('FileList', 'Shadow-Twin ausgewählt', {
      shadowTwinId: shadowTwin.id,
      shadowTwinName: shadowTwin.metadata.name
    });
    
    // Setze das Shadow-Twin als ausgewählte Datei, damit es rechts angezeigt wird
    setSelectedFile(shadowTwin);
    setSelectedShadowTwin(null); // Kein zusätzliches Shadow-Twin im normalen Modus
  }, [setSelectedFile, setSelectedShadowTwin, findFileGroup]);

  // Aktualisierte handleRefresh Funktion
  const handleRefresh = useCallback(async () => {
    if (!items || items.length === 0) return;
    
    const parentId = items[0]?.parentId;
    if (!parentId) return;
    
    setIsRefreshing(true);
    
    try {
      const refreshedItems = await refreshItems(parentId);
      setFolderItems(refreshedItems);
    } catch (error) {
      FileLogger.error('FileList', 'Fehler beim Aktualisieren der Dateiliste', error);
    } finally {
      setIsRefreshing(false);
    }
  }, [items, refreshItems, setFolderItems]);

  const handleCreateTranscript = React.useCallback((e: React.MouseEvent) => {
    e.stopPropagation();
    FileLogger.info('FileList', 'Create transcript for', { fileName: 'TODO' });
    // TODO: Implement transcript creation
  }, []);

  // Entfernt: handleItemSelect war unbenutzt

  // Check if an item is selected (beide Atome prüfen)
  const isItemSelected = useCallback((item: StorageItem) => {
    const mediaType = getMediaType(item);
    if (mediaType === 'audio' || mediaType === 'video') {
      return selectedBatchItems.some(selected => selected.item.id === item.id);
    } else {
      return selectedTransformationItems.some(selected => selected.item.id === item.id);
    }
  }, [selectedBatchItems, selectedTransformationItems]);

  // Löschfunktion
  const handleDeleteClick = React.useCallback(async (e: React.MouseEvent<HTMLButtonElement>, itemToDelete: StorageItem) => {
    e.stopPropagation();
    
    if (!provider) {
      toast.error("Fehler", {
        description: "Storage Provider nicht verfügbar"
      });
      return;
    }

    try {
      // Finde die FileGroup für dieses Item
      const itemStem = getBaseName(itemToDelete.metadata.name);
      const fileGroup = findFileGroup(fileGroups, itemStem);

      // Bestätigungsnachricht vorbereiten
      let confirmMessage = `Möchten Sie "${itemToDelete.metadata.name}" wirklich löschen?`;
      if (fileGroup && itemToDelete.id === fileGroup.baseItem?.id) {
        if (fileGroup.transcriptFiles && fileGroup.transcriptFiles.length > 0 || fileGroup.transformed) {
          confirmMessage = `Möchten Sie "${itemToDelete.metadata.name}" und alle zugehörigen Dateien wirklich löschen?`;
        }
      }

      // Benutzer um Bestätigung bitten
      if (!window.confirm(confirmMessage)) {
        return;
      }

      if (fileGroup && itemToDelete.id === fileGroup.baseItem?.id) {
        // Dies ist die Basis-Datei - lösche auch abhängige Dateien
        // Lösche alle Transkripte, falls vorhanden
        if (fileGroup.transcriptFiles) {
          for (const transcript of fileGroup.transcriptFiles) {
            try {
              await provider.deleteItem(transcript.id);
              FileLogger.info('FileList', 'Transkript gelöscht', {
                transcriptId: transcript.id,
                transcriptName: transcript.metadata.name
              });
            } catch (error) {
              FileLogger.error('FileList', 'Fehler beim Löschen des Transkripts', error);
              toast.warning("Hinweis", {
                description: "Einige Transkripte konnten nicht gelöscht werden"
              });
            }
          }
        }

        // Lösche die transformierte Datei, falls vorhanden
        if (fileGroup.transformed) {
          try {
            await provider.deleteItem(fileGroup.transformed.id);
            FileLogger.info('FileList', 'Transformierte Datei gelöscht', {
              transformedId: fileGroup.transformed.id,
              transformedName: fileGroup.transformed.metadata.name
            });
          } catch (error) {
            FileLogger.error('FileList', 'Fehler beim Löschen der transformierten Datei', error);
            toast.warning("Hinweis", {
              description: "Die transformierte Datei konnte nicht gelöscht werden"
            });
          }
        }

        // Lösche die Basis-Datei
        await provider.deleteItem(itemToDelete.id);
        toast.success("Dateien gelöscht", {
          description: `${itemToDelete.metadata.name} und zugehörige Dateien wurden gelöscht.`
        });
      } else {
        // Dies ist eine abhängige Datei oder keine Gruppe - nur diese Datei löschen
        await provider.deleteItem(itemToDelete.id);
        toast.success("Datei gelöscht", {
          description: `${itemToDelete.metadata.name} wurde gelöscht.`
        });
      }

      // Aktualisiere die Dateiliste
      await handleRefresh();

      // Wenn die gelöschte Datei ausgewählt war, Auswahl aufheben
      setSelectedFile(null);
      
      // Aus der Batch-Auswahl entfernen
      setSelectedBatchItems(prev => prev.filter(i => i.item.id !== itemToDelete.id));

    } catch (error) {
      FileLogger.error('FileList', 'Fehler beim Löschen', error);
      toast.error("Fehler", {
        description: `Die Datei konnte nicht gelöscht werden: ${error instanceof Error ? error.message : 'Unbekannter Fehler'}`
      });
    }
  }, [provider, handleRefresh, fileGroups, setSelectedFile, setSelectedBatchItems]);

  const handleRename = React.useCallback(async (item: StorageItem, newName: string) => {
    if (!provider) {
      toast.error("Fehler", {
        description: "Storage Provider nicht verfügbar"
      });
      return;
    }

    try {
      // Finde die FileGroup für dieses Item
      const itemStem = getBaseName(item.metadata.name);
      const fileGroup = findFileGroup(fileGroups, itemStem);

      if (fileGroup && item.id === fileGroup.baseItem?.id) {
        // Dies ist die Basis-Datei - benenne auch abhängige Dateien um
        const oldStem = getBaseName(item.metadata.name);
        const newStem = getBaseName(newName);
        // Benenne die Basis-Datei um
        await provider.renameItem(item.id, newName);
        // Benenne alle Transkripte um, falls vorhanden
        if (fileGroup.transcriptFiles) {
          for (const transcript of fileGroup.transcriptFiles) {
            const transcriptName = transcript.metadata.name;
            const newTranscriptName = transcriptName.replace(oldStem, newStem);
            try {
              await provider.renameItem(transcript.id, newTranscriptName);
            } catch (error) {
              FileLogger.error('FileList', 'Fehler beim Umbenennen des Transkripts', error);
              toast.warning("Hinweis", {
                description: "Einige Transkripte konnten nicht umbenannt werden"
              });
            }
          }
        }
        // Benenne die transformierte Datei um, falls vorhanden
        if (fileGroup.transformed) {
          const transformedName = fileGroup.transformed.metadata.name;
          const newTransformedName = transformedName.replace(oldStem, newStem);
          try {
            await provider.renameItem(fileGroup.transformed.id, newTransformedName);
          } catch (error) {
            FileLogger.error('FileList', 'Fehler beim Umbenennen der transformierten Datei', error);
            toast.warning("Hinweis", {
              description: "Die transformierte Datei konnte nicht umbenannt werden"
            });
          }
        }
        toast.success("Dateien umbenannt", {
          description: `${item.metadata.name} und zugehörige Dateien wurden umbenannt.`
        });
      } else {
        // Dies ist eine abhängige Datei oder keine Gruppe - nur diese Datei umbenennen
        await provider.renameItem(item.id, newName);
        toast.success("Datei umbenannt", {
          description: `${item.metadata.name} wurde zu ${newName} umbenannt.`
        });
      }
      await handleRefresh();
    } catch (error) {
      FileLogger.error('FileList', 'Fehler beim Umbenennen', error);
      toast.error("Fehler", {
        description: `Die Datei konnte nicht umbenannt werden: ${error instanceof Error ? error.message : 'Unbekannter Fehler'}`
      });
      throw error;
    }
  }, [provider, handleRefresh, fileGroups]);

  const handleBatchTranscription = () => {
    if (selectedBatchItems.length > 0) {
      setTranscriptionDialogOpen(true);
    }
  };

  const handleBatchTransformation = () => {
    if (selectedTransformationItems.length > 0) {
      setTransformationDialogOpen(true);
    }
  };

  // Bulk-Löschung für ausgewählte Dateien (unabhängig von Batch/Transformation-Selektor)
  const handleBulkDelete = React.useCallback(async () => {
    if (!provider) return;
    const targets = [
      ...selectedBatchItems.map(x => x.item),
      ...selectedTransformationItems.map(x => x.item),
    ];
    if (targets.length === 0) return;
    const confirmMsg = targets.length === 1
      ? `"${targets[0].metadata.name}" wirklich löschen?`
      : `${targets.length} Dateien wirklich löschen?`;
    if (!window.confirm(confirmMsg)) return;

    try {
      const parentId = targets[0].parentId || 'root';
      for (const t of targets) {
        try { await provider.deleteItem(t.id); } catch (err) {
          FileLogger.error('FileList', 'Bulk Delete failed', { id: t.id, name: t.metadata.name, err });
        }
      }
      const refreshed = await refreshItems(parentId);
      setFolderItems(refreshed);
      setSelectedBatchItems([]);
      setSelectedTransformationItems([]);
    } catch (error) {
      FileLogger.error('FileList', 'Bulk Delete error', error);
    }
  }, [provider, selectedBatchItems, selectedTransformationItems, refreshItems, setFolderItems, setSelectedBatchItems, setSelectedTransformationItems]);

  // Intelligente Batch-Auswahl basierend auf Filter
  const handleSelectAll = useCallback((checked: boolean) => {
    const startTime = performance.now();
    if (checked) {
      // Verwende nur die Hauptdateien (baseItem) aus den FileGroups
      const mainItems = Array.from((fileGroups ?? new Map()).values())
        .map(group => group.baseItem)
        .filter((item): item is StorageItem => item !== undefined);
      const selectableItems = mainItems.filter(item => {
        try {
          const mediaType = getMediaType(item);
          // Je nach Filter unterschiedliche Dateien auswählen
          switch (currentCategoryFilter) {
            case 'media':
              return item.type === 'file' && (mediaType === 'audio' || mediaType === 'video');
            case 'text':
              return item.type === 'file' && mediaType === 'text';
            case 'documents':
              return item.type === 'file' && mediaType === 'document';
            default:
              // Bei 'all' alle Dateien auswählen, die für eine Operation geeignet sind
              return item.type === 'file' && (
                mediaType === 'audio' || 
                mediaType === 'video' || 
                mediaType === 'text' || 
                mediaType === 'document'
              );
          }
        } catch {
          return false;
        }
      });
      StateLogger.info('FileList', 'Selecting all items based on filter', {
        filter: currentCategoryFilter,
        totalItems: items.length,
        selectableCount: selectableItems.length,
        duration: `${(performance.now() - startTime).toFixed(2)}ms`
      });
      // Je nach Filter unterschiedliche Atome verwenden
      if (currentCategoryFilter === 'media') {
        setSelectedBatchItems(selectableItems.map(item => ({
          item,
          type: getMediaType(item)
        })));
      } else if (currentCategoryFilter === 'text') {
        setSelectedTransformationItems(selectableItems.map(item => ({
          item,
          type: getMediaType(item)
        })));
      } else {
        // Bei 'all' oder 'documents' beide Atome füllen
        const mediaItems = selectableItems.filter(item => {
          const mediaType = getMediaType(item);
          return mediaType === 'audio' || mediaType === 'video';
        });
        const textItems = selectableItems.filter(item => {
          const mediaType = getMediaType(item);
          return mediaType === 'text' || mediaType === 'document';
        });
        setSelectedBatchItems(mediaItems.map(item => ({
          item,
          type: getMediaType(item)
        })));
        setSelectedTransformationItems(textItems.map(item => ({
          item,
          type: getMediaType(item)
        })));
      }
    } else {
      StateLogger.info('FileList', 'Deselecting all items', {
        previouslySelected: selectedBatchItems.length + selectedTransformationItems.length,
        duration: `${(performance.now() - startTime).toFixed(2)}ms`
      });
      setSelectedBatchItems([]);
      setSelectedTransformationItems([]);
    }
  }, [fileGroups, currentCategoryFilter, setSelectedBatchItems, setSelectedTransformationItems, selectedBatchItems.length, selectedTransformationItems.length, items.length]);

  React.useEffect(() => {
    // Logging der Library-IDs - verzögert ausführen
    const timeoutId = setTimeout(() => {
      StateLogger.debug('FileList', 'Render', {
        currentLibraryId: currentLibrary?.id,
        activeLibraryIdAtom: activeLibraryId
      });
    }, 0);
    
    return () => clearTimeout(timeoutId);
  }, [currentLibrary, activeLibraryId]);

  // Entkoppelt: kein Render-Gate mehr basierend auf FileTree

  return (
    <div className="h-full flex flex-col">
      {/* Header - versteckt im compact mode */}
      {!compact && (
        <div className="border-b px-2 py-2 flex items-center justify-between bg-background sticky top-0 z-10">
          <div className="flex items-center gap-2">
            <Button
              variant="ghost"
              size="icon"
              className="h-8 w-8"
              onClick={handleRefresh}
              disabled={isRefreshing}
              title="Aktualisieren"
              aria-label="Aktualisieren"
            >
              <RefreshCw className={cn("h-4 w-4", isRefreshing && "animate-spin")} />
            </Button>

            {/* Dateikategorie-Filter (Icon-only Variante) */}
            <FileCategoryFilter iconOnly />

            {/* Batch-Actions als Icons */}
            {selectedBatchItems.length > 0 && (
              <Button size="icon" title="Transkribieren" aria-label="Transkribieren" onClick={handleBatchTranscription}>
                <ScrollText className="h-4 w-4" />
              </Button>
            )}
            {selectedTransformationItems.length > 0 && (
              <Button size="icon" variant="secondary" title="Transformieren" aria-label="Transformieren" onClick={handleBatchTransformation}>
                <Plus className="h-4 w-4" />
              </Button>
            )}
            {(selectedBatchItems.length + selectedTransformationItems.length) > 0 && (
              <Button size="icon" variant="destructive" title="Ausgewählte löschen" aria-label="Ausgewählte löschen" onClick={handleBulkDelete}>
                <Trash2 className="h-4 w-4" />
              </Button>
            )}
          </div>
        </div>
      )}

      {/* File List */}
      <div ref={listContainerRef} className="flex-1 overflow-auto focus:outline-none" tabIndex={0} onKeyDown={handleKeyNav}>
        <div>
          {/* Table Header - versteckt im compact mode */}
          {!compact && (
            <div className="sticky top-0 bg-background border-b">
              <div className="grid grid-cols-[24px_24px_minmax(0,1fr)_56px_88px_auto] gap-2 px-4 py-2 text-sm font-medium text-muted-foreground">
                <div className="w-6 flex items-center justify-center">
                  <Checkbox
                    checked={isAllSelected}
                    onCheckedChange={handleSelectAll}
                    aria-label="Alle auswählen"
                  />
                </div>
                <div className="w-6" />
                <SortableHeaderCell
                  label="Name"
                  field="name"
                  currentSortField={sortField}
                  currentSortOrder={sortOrder}
                  onSort={handleSort}
                />
                <SortableHeaderCell
                  label="Größe"
                  field="size"
                  currentSortField={sortField}
                  currentSortOrder={sortOrder}
                  onSort={handleSort}
                />
                <SortableHeaderCell
                  label="Geändert"
                  field="date"
                  currentSortField={sortField}
                  currentSortOrder={sortOrder}
                  onSort={handleSort}
                />
                <div />
              </div>
            </div>
          )}

          {/* Folder Rows (oberhalb der Dateien, unabhängig von Datei-Gruppierung) */}
          {folders.length > 0 && (
            <div className="divide-y">
          {folders.map((folder) => (
            compact ? (
              // Kompakt: ohne Einrückung, nur Icon + Name (2 Spalten)
              <div
                key={folder.id}
                role="button"
                tabIndex={0}
                onClick={() => navigateToFolder(folder.id)}
                onKeyDown={(e) => { if (e.key === 'Enter' || e.key === ' ') navigateToFolder(folder.id) }}
                className="w-full px-2 py-1 text-xs hover:bg-muted/50 grid grid-cols-[24px_minmax(0,1fr)] gap-2 items-center cursor-pointer"
              >
                <FolderIcon className="h-4 w-4" />
                <span className="text-left truncate select-none" title={folder.metadata.name}>{folder.metadata.name}</span>
              </div>
            ) : (
              // Normal: behalte leichte Einrückung für Checkbox-Spalte
              <div
                key={folder.id}
                role="button"
                tabIndex={0}
                onClick={() => navigateToFolder(folder.id)}
                onKeyDown={(e) => { if (e.key === 'Enter' || e.key === ' ') navigateToFolder(folder.id) }}
                className="w-full px-4 py-2 text-xs hover:bg-muted/50 grid grid-cols-[24px_24px_minmax(0,1fr)] gap-2 items-center cursor-pointer"
              >
                <div />
                <FolderIcon className="h-4 w-4" />
                <span className="text-left truncate select-none" title={folder.metadata.name}>{folder.metadata.name}</span>
              </div>
            )
          ))}
            </div>
          )}

          {/* File Rows */}
          <div className="divide-y">
            {Array.from((fileGroups ?? new Map()).values())
              .map((group) => {
                // Zeige nur die Hauptdatei (baseItem) an
                const item = group.baseItem;
                if (!item) return null;
                // System-Unterordner-Id, wenn ein ".<basename>"-Folder existiert
                const systemFolder = systemFolderByBase.get(getBaseName(item.metadata.name));
                const systemFolderId = systemFolder?.id;
                const isActive = !!activeFile && activeFile.id === item.id
                return (
                  <FileRow
                    key={item.id}
                    item={item as StorageItem}
                    isSelected={isItemSelected(item)}
                    isActive={isActive}
                    onSelect={() => handleSelect(item, group)}
                    onCreateTranscript={handleCreateTranscript}
                    onDelete={(e) => handleDeleteClick(e, item)}
                    fileGroup={group}
                    onSelectRelatedFile={handleSelectRelatedFile}
                    onRename={handleRename}
                    compact={compact}
                    systemFolderId={systemFolderId}
                  />
                );
              })}
          </div>
        </div>
      </div>
    </div>
  );
}); 
```

```typescriptreact
'use client';

import * as React from "react"
import { File, FileText, FileVideo, FileAudio, Plus, RefreshCw, ChevronUp, ChevronDown, Trash2, ScrollText, Folder as FolderIcon, Layers } from "lucide-react"
import { StorageItem } from "@/lib/storage/types"
import { cn } from "@/lib/utils"
import { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from "@/components/ui/tooltip"
import { useStorage } from "@/contexts/storage-context";
import { Button } from "@/components/ui/button";
import { useAtomValue, useAtom } from 'jotai';
import { jobStatusByItemIdAtom } from '@/atoms/job-status';
import { 
  activeLibraryIdAtom, 
  selectedFileAtom, 
  folderItemsAtom,
  sortedFilteredFilesAtom,
  sortFieldAtom,
  sortOrderAtom,
  selectedShadowTwinAtom
} from '@/atoms/library-atom';
import { toast } from "sonner";
import { Input } from "@/components/ui/input"
import {
  selectedBatchItemsAtom,
  transcriptionDialogOpenAtom,
  selectedTransformationItemsAtom,
  transformationDialogOpenAtom,
  getMediaType,
  fileCategoryFilterAtom,
} from '@/atoms/transcription-options';
import { Checkbox } from "@/components/ui/checkbox"
import { useMemo, useCallback } from "react"
import { FileLogger, StateLogger } from "@/lib/debug/logger"
import { FileCategoryFilter } from './file-category-filter';
import { useFolderNavigation } from "@/hooks/use-folder-navigation";

// Typen für Sortieroptionen
type SortField = 'type' | 'name' | 'size' | 'date';
type SortOrder = 'asc' | 'desc';

// Typ für gruppierte Dateien
interface FileGroup {
  baseItem?: StorageItem;
  transcriptFiles?: StorageItem[]; // NEU: alle Transkripte
  transformed?: StorageItem;
}

// Memoized file icon component
const FileIconComponent = React.memo(function FileIconComponent({ item }: { item: StorageItem }) {
  const mimeType = item.metadata.mimeType || '';
  if (!mimeType) return <File className="h-4 w-4" />;

  if (mimeType.startsWith('video/')) {
    return <FileVideo className="h-4 w-4" />;
  } else if (mimeType.startsWith('audio/')) {
    return <FileAudio className="h-4 w-4" />;
  } else if (mimeType.startsWith('text/')) {
    return <FileText className="h-4 w-4" />;
  }

  return <File className="h-4 w-4" />;
});

// Pure function for file size formatting
const formatFileSize = (size?: number): string => {
  if (!size) return '-';
  const units = ['B', 'KB', 'MB', 'GB'];
  let value = size;
  let unitIndex = 0;
  
  while (value >= 1024 && unitIndex < units.length - 1) {
    value /= 1024;
    unitIndex++;
  }
  
  return `${value.toFixed(1)} ${units[unitIndex]}`;
};

// Funktion zum Formatieren des Datums
const formatDate = (date?: Date): string => {
  if (!date) return '-';
  
  const options: Intl.DateTimeFormatOptions = { 
    year: '2-digit', 
    month: '2-digit', 
    day: '2-digit',
    hour: '2-digit',
    minute: '2-digit'
  };
  
  return new Date(date).toLocaleDateString('de-DE', options);
};

// Entfernt: getFileStem Funktion war unbenutzt

// Sortierbare Kopfzelle Komponente
const SortableHeaderCell = React.memo(function SortableHeaderCell({
  label,
  field,
  currentSortField,
  currentSortOrder,
  onSort
}: {
  label: string,
  field: SortField,
  currentSortField: SortField,
  currentSortOrder: SortOrder,
  onSort: (field: SortField) => void
}) {
  const isActive = currentSortField === field;
  
  return (
    <button 
      onClick={() => onSort(field)}
      className="flex items-center gap-1 hover:text-foreground"
    >
      <span>{label}</span>
      {isActive && (
        currentSortOrder === 'asc' 
          ? <ChevronUp className="h-3 w-3" /> 
          : <ChevronDown className="h-3 w-3" />
      )}
    </button>
  );
});

interface FileRowProps {
  item: StorageItem;
  isSelected: boolean;
  isActive?: boolean;
  onSelect: () => void;
  onCreateTranscript: (e: React.MouseEvent) => void;
  onDelete: (e: React.MouseEvent<HTMLButtonElement>, item: StorageItem) => void;
  fileGroup?: FileGroup;
  onSelectRelatedFile?: (file: StorageItem) => void;
  onRename?: (item: StorageItem, newName: string) => Promise<void>;
  compact?: boolean;
  systemFolderId?: string;
}

const FileRow = React.memo(function FileRow({ 
  item, 
  isSelected, 
  isActive = false,
  onSelect,
  onCreateTranscript,
  onDelete,
  fileGroup,
  onSelectRelatedFile,
  onRename,
  compact = false,
  systemFolderId
}: FileRowProps) {
  const navigateToFolder = useFolderNavigation();
  const [isEditing, setIsEditing] = React.useState(false);
  const [editName, setEditName] = React.useState(item.metadata.name);
  const inputRef = React.useRef<HTMLInputElement>(null);
  const longPressTimerRef = React.useRef<NodeJS.Timeout | null>(null);
  const lastClickTimeRef = React.useRef<number>(0);
  
  // Zusätzliche Validierung der Metadaten
  const metadata = React.useMemo(() => ({
    name: item.metadata?.name || 'Unbekannte Datei',
    size: typeof item.metadata?.size === 'number' ? item.metadata.size : 0,
    mimeType: item.metadata?.mimeType || '',
    hasTranscript: !!item.metadata?.hasTranscript || (fileGroup?.transcriptFiles && fileGroup.transcriptFiles.length > 0),
    modifiedAt: item.metadata?.modifiedAt
  }), [item.metadata, fileGroup]);

  const isTranscribable = React.useMemo(() => {
    const mimeType = metadata.mimeType.toLowerCase();
    const extension = metadata.name.split('.').pop()?.toLowerCase();

    return (
      mimeType.startsWith('audio/') ||
      mimeType.startsWith('video/') ||
      extension === 'pdf' ||
      mimeType === 'application/pdf'
    );
  }, [metadata.mimeType, metadata.name]);

  // Memoize the click handler
  const handleClick = React.useCallback(() => {
    if (!isEditing) {
      onSelect();
    }
  }, [onSelect, isEditing]);

  // Memoize the keydown handler
  const handleKeyDown = React.useCallback((e: React.KeyboardEvent) => {
    if (!isEditing && (e.key === 'Enter' || e.key === ' ')) {
      onSelect();
    }
  }, [onSelect, isEditing]);

  // Handler für Transkript-Icon Click
  const handleTranscriptClick = React.useCallback((e: React.MouseEvent) => {
    e.stopPropagation();
    if (fileGroup?.transcriptFiles && onSelectRelatedFile) {
      onSelectRelatedFile(fileGroup.transcriptFiles[0]); // Nur das erste Transkript anzeigen
    }
  }, [fileGroup, onSelectRelatedFile]);

  // Handler für Transformierte-Datei-Icon Click
  const handleTransformedClick = React.useCallback((e: React.MouseEvent) => {
    e.stopPropagation();
    if (fileGroup?.transformed && onSelectRelatedFile) {
      onSelectRelatedFile(fileGroup.transformed);
    }
  }, [fileGroup, onSelectRelatedFile]);

  // Starte Rename-Modus
  const startRename = React.useCallback(() => {
    if (onRename) {
      // Prüfe ob dies eine abhängige Datei ist
      if (fileGroup && (
        (fileGroup.transcriptFiles && fileGroup.transcriptFiles.length > 0 && fileGroup.transcriptFiles[0]?.id === item.id) ||
        (fileGroup.transformed && item.id === fileGroup.transformed.id)
      )) {
        // Dies ist eine abhängige Datei - zeige Hinweis
        toast.info("Hinweis", {
          description: "Bitte benennen Sie die Haupt-Datei um. Abhängige Dateien werden automatisch mit umbenannt."
        });
        return;
      }
      
      setIsEditing(true);
      setEditName(item.metadata.name);
    }
  }, [onRename, item, fileGroup]);

  // Handler für Dateinamen-Click (Doppelklick-Erkennung)
  const handleNameClick = React.useCallback((e: React.MouseEvent) => {
    e.stopPropagation();
    
    const currentTime = Date.now();
    const timeSinceLastClick = currentTime - lastClickTimeRef.current;
    
    if (timeSinceLastClick < 300) {
      // Doppelklick erkannt
      startRename();
    } else {
      // Erster Klick - wähle die Datei aus
      onSelect();
    }
    
    lastClickTimeRef.current = currentTime;
  }, [startRename, onSelect]);

  // Handler für Long-Press (Touch-Geräte)
  const handleTouchStart = React.useCallback((e: React.TouchEvent) => {
    e.stopPropagation();
    
    // Starte Long-Press Timer
    longPressTimerRef.current = setTimeout(() => {
      startRename();
    }, 500); // 500ms für Long-Press
  }, [startRename]);

  const handleTouchEnd = React.useCallback((e: React.TouchEvent) => {
    e.stopPropagation();
    
    // Lösche Long-Press Timer
    if (longPressTimerRef.current) {
      clearTimeout(longPressTimerRef.current);
      longPressTimerRef.current = null;
    }
  }, []);

  const handleTouchMove = React.useCallback(() => {
    // Bei Bewegung Long-Press abbrechen
    if (longPressTimerRef.current) {
      clearTimeout(longPressTimerRef.current);
      longPressTimerRef.current = null;
    }
  }, []);

  // Cleanup Timer bei Unmount
  React.useEffect(() => {
    return () => {
      if (longPressTimerRef.current) {
        clearTimeout(longPressTimerRef.current);
      }
    };
  }, []);

  // Handler für Rename-Submit
  const handleRenameSubmit = React.useCallback(async () => {
    if (onRename && editName.trim() && editName !== item.metadata.name) {
      try {
        await onRename(item, editName.trim());
      } catch (error) {
        FileLogger.error('FileRow', 'Fehler beim Umbenennen', error);
        // Bei Fehler den ursprünglichen Namen wiederherstellen
        setEditName(item.metadata.name);
      }
    }
    setIsEditing(false);
  }, [onRename, editName, item]);

  // Handler für Rename-Cancel
  const handleRenameCancel = React.useCallback(() => {
    setEditName(item.metadata.name);
    setIsEditing(false);
  }, [item.metadata.name]);

  // Handler für Input-Änderungen
  const handleInputChange = React.useCallback((e: React.ChangeEvent<HTMLInputElement>) => {
    setEditName(e.target.value);
  }, []);

  // Handler für Input-Keydown
  const handleInputKeyDown = React.useCallback((e: React.KeyboardEvent<HTMLInputElement>) => {
    e.stopPropagation();
    if (e.key === 'Enter') {
      handleRenameSubmit();
    } else if (e.key === 'Escape') {
      handleRenameCancel();
    }
  }, [handleRenameSubmit, handleRenameCancel]);

  // Focus Input wenn Edit-Modus aktiviert wird
  React.useEffect(() => {
    if (isEditing && inputRef.current) {
      inputRef.current.focus();
      inputRef.current.select();
    }
  }, [isEditing]);

  // Handler für Drag Start
  const handleDragStart = React.useCallback((e: React.DragEvent) => {
    // Sammle alle Dateien der Gruppe, die verschoben werden sollen
    const itemsToMove = [];
    
    // Füge das aktuelle Item hinzu
    itemsToMove.push({
      itemId: item.id,
      itemName: item.metadata.name,
      itemType: item.type,
      parentId: item.parentId
    });
    
    // Wenn es eine FileGroup gibt, füge auch die zugehörigen Dateien hinzu
    if (fileGroup) {
      // Prüfe ob das aktuelle Item die Basis-Datei ist
      if (item.id === fileGroup.baseItem?.id) {
        // Füge Transkripte hinzu, falls vorhanden
        if (fileGroup.transcriptFiles && fileGroup.transcriptFiles.length > 0) {
          fileGroup.transcriptFiles.forEach(transcript => {
            itemsToMove.push({
              itemId: transcript.id,
              itemName: transcript.metadata.name,
              itemType: transcript.type,
              parentId: transcript.parentId
            });
          });
        }
        
        // Füge transformierte Datei hinzu, falls vorhanden
        if (fileGroup.transformed) {
          itemsToMove.push({
            itemId: fileGroup.transformed.id,
            itemName: fileGroup.transformed.metadata.name,
            itemType: fileGroup.transformed.type,
            parentId: fileGroup.transformed.parentId
          });
        }
      }
    }
    
    // Setze die Drag-Daten
    e.dataTransfer.effectAllowed = 'move';
    e.dataTransfer.setData('application/json', JSON.stringify({
      items: itemsToMove,
      isFileGroup: itemsToMove.length > 1
    }));
    
    // Visuelles Feedback
    if (e.currentTarget instanceof HTMLElement) {
      e.currentTarget.style.opacity = '0.5';
    }
  }, [item, fileGroup]);

  // Handler für Drag End
  const handleDragEnd = React.useCallback((e: React.DragEvent) => {
    // Stelle Opacity wieder her
    if (e.currentTarget instanceof HTMLElement) {
      e.currentTarget.style.opacity = '1';
    }
  }, []);

  const [selectedBatchItems, setSelectedBatchItems] = useAtom(selectedBatchItemsAtom);
  const [selectedTransformationItems, setSelectedTransformationItems] = useAtom(selectedTransformationItemsAtom);
  
  // Prüfe ob das Item in einem der beiden Atome ausgewählt ist
  const isInBatch = selectedBatchItems.some(batchItem => batchItem.item.id === item.id);
  const isInTransformation = selectedTransformationItems.some(transformationItem => transformationItem.item.id === item.id);
  const isInAnyBatch = isInBatch || isInTransformation;

  // Handler für Checkbox-Änderungen
  const handleCheckboxChange = React.useCallback((checked: boolean) => {
    const mediaType = getMediaType(item);
    
    if (mediaType === 'audio' || mediaType === 'video') {
      // Für Audio/Video: Transcription-Atom verwenden
      if (checked) {
        setSelectedBatchItems([...selectedBatchItems, {
          item,
          type: mediaType
        }]);
      } else {
        setSelectedBatchItems(selectedBatchItems.filter(i => i.item.id !== item.id));
      }
    } else if (mediaType === 'text' || mediaType === 'document') {
      // Für Text/Dokumente: Transformation-Atom verwenden
      if (checked) {
        setSelectedTransformationItems([...selectedTransformationItems, {
          item,
          type: mediaType
        }]);
      } else {
        setSelectedTransformationItems(selectedTransformationItems.filter(i => i.item.id !== item.id));
      }
    }
  }, [item, selectedBatchItems, selectedTransformationItems, setSelectedBatchItems, setSelectedTransformationItems]);

  React.useEffect(() => {
    if (fileGroup) {
      FileLogger.debug('FileRow', 'Transkripte für Zeile', {
        baseItem: fileGroup.baseItem?.metadata.name,
        transcripts: fileGroup.transcriptFiles?.map(t => t.metadata.name)
      });
    }
  }, [fileGroup]);

  // Zentraler Jobstatus (muss vor möglichen early-returns stehen, um Hook-Order zu garantieren)
  const jobStatusMap = useAtomValue(jobStatusByItemIdAtom);
  const jobStatus = jobStatusMap[item.id];
  const jobStatusIcon = jobStatus ? (
    <span title={jobStatus} className={cn('inline-block h-3 w-3 rounded-full',
      jobStatus === 'queued' && 'bg-blue-600',
      jobStatus === 'running' && 'bg-yellow-600',
      jobStatus === 'completed' && 'bg-green-600',
      jobStatus === 'failed' && 'bg-red-600'
    )} aria-label={`job-${jobStatus}`} />
  ) : null;

  // Compact-Modus: vereinfachte Darstellung
  if (compact) {
    return (
      <div
        role="button"
        tabIndex={0}
        onClick={handleClick}
        onKeyDown={handleKeyDown}
        className={cn(
          "w-full px-2 py-1 text-xs hover:bg-muted/50 grid grid-cols-[24px_minmax(0,1fr)] gap-2 items-center cursor-pointer",
          isSelected && "bg-muted",
          isActive && "bg-primary/10 border-l-2 border-primary"
        )}
      >
        <FileIconComponent item={item} />
        <span className={cn("truncate", isActive && "font-medium")} title={metadata.name}>
          {metadata.name}
        </span>
      </div>
    );
  }

  return (
    <div
      role="button"
      tabIndex={0}
      onClick={handleClick}
      onKeyDown={handleKeyDown}
      onTouchStart={handleTouchStart}
      onTouchEnd={handleTouchEnd}
      onTouchMove={handleTouchMove}
      draggable={!isEditing}
      onDragStart={handleDragStart}
      onDragEnd={handleDragEnd}
      className={cn(
        "w-full px-4 py-2 text-xs hover:bg-muted/50 grid grid-cols-[24px_24px_minmax(0,1fr)_56px_88px_auto] gap-2 items-center cursor-move",
        isSelected && "bg-muted",
        isActive && "bg-primary/10 border-l-2 border-primary"
      )}
    >
      <div className="w-6 flex items-center justify-center">
        <Checkbox
          checked={isInAnyBatch}
          onCheckedChange={handleCheckboxChange}
          onClick={(e) => e.stopPropagation()}
        />
      </div>
      <FileIconComponent item={item} />
      {isEditing ? (
        <Input
          ref={inputRef}
          value={editName}
          onChange={handleInputChange}
          onKeyDown={handleInputKeyDown}
          onBlur={handleRenameSubmit}
          onClick={(e) => e.stopPropagation()}
          className="h-6 px-1 py-0 text-xs"
        />
      ) : (
        <span 
          className={cn("text-left truncate cursor-pointer hover:text-primary select-none", isActive && "font-medium")}
          onClick={handleNameClick}
          onTouchStart={handleTouchStart}
          onTouchEnd={handleTouchEnd}
          onTouchMove={handleTouchMove}
          title={metadata.name}
        >
          {metadata.name}
        </span>
      )}
      <span className="text-muted-foreground tabular-nums text-[10px]">
        {formatFileSize(metadata.size)}
      </span>
      <span className="text-muted-foreground tabular-nums text-[10px]">
        {formatDate(metadata.modifiedAt)}
      </span>
      <div className="flex items-center justify-start gap-1">
        {jobStatusIcon}
        {/* System-Unterordner (z. B. extrahierte Seiten) */}
        {systemFolderId && (
          <TooltipProvider>
            <Tooltip>
              <TooltipTrigger asChild>
                <Button
                  variant="ghost"
                  size="icon"
                  className="h-6 w-6 p-0 hover:bg-muted"
                  onClick={(e) => {
                    e.stopPropagation();
                    navigateToFolder(systemFolderId);
                  }}
                >
                  <Layers className="h-4 w-4 text-violet-500" />
                </Button>
              </TooltipTrigger>
              <TooltipContent>
                <p>Seiten-Ordner öffnen</p>
              </TooltipContent>
            </Tooltip>
          </TooltipProvider>
        )}
        {/* Zeige Icons für alle vorhandenen Transkripte */}
        {fileGroup?.transcriptFiles && fileGroup.transcriptFiles.length > 0 && fileGroup.transcriptFiles.map((transcript) => (
          <TooltipProvider key={transcript.id}>
            <Tooltip>
              <TooltipTrigger asChild>
                <Button
                  variant="ghost"
                  size="icon"
                  className="h-6 w-6 p-0 hover:bg-muted"
                  onClick={(e) => {
                    e.stopPropagation();
                    if (onSelectRelatedFile) onSelectRelatedFile(transcript);
                  }}
                >
                  <FileText className="h-4 w-4 text-blue-500" />
                </Button>
              </TooltipTrigger>
              <TooltipContent>
                <p>Transkript anzeigen: {transcript.metadata.name}</p>
              </TooltipContent>
            </Tooltip>
          </TooltipProvider>
        ))}
        {/* Plus-Symbol nur anzeigen, wenn kein Transkript vorhanden und transkribierbar */}
        {(!fileGroup?.transcriptFiles || fileGroup.transcriptFiles.length === 0) && isTranscribable && !metadata.hasTranscript ? (
          <TooltipProvider>
            <Tooltip>
              <TooltipTrigger asChild>
                <div 
                  role="button"
                  tabIndex={0}
                  className="h-6 w-6 p-0 inline-flex items-center justify-center hover:bg-muted rounded-sm"
                  onClick={onCreateTranscript}
                  onKeyDown={(e) => {
                    if (e.key === 'Enter' || e.key === ' ') {
                      e.stopPropagation();
                      onCreateTranscript(e as unknown as React.MouseEvent<HTMLDivElement>);
                    }
                  }}
                >
                  <Plus className="h-4 w-4" />
                </div>
              </TooltipTrigger>
              <TooltipContent>
                <p>Transkript erstellen</p>
              </TooltipContent>
            </Tooltip>
          </TooltipProvider>
        ) : null}
        {/* Icon für transformierte Datei */}
        {fileGroup?.transformed && (
          <TooltipProvider>
            <Tooltip>
              <TooltipTrigger asChild>
                <Button
                  variant="ghost"
                  size="icon"
                  className="h-6 w-6 p-0 hover:bg-muted"
                  onClick={handleTransformedClick}
                >
                  <ScrollText className="h-4 w-4 text-green-500" />
                </Button>
              </TooltipTrigger>
              <TooltipContent>
                <p>Transformierte Datei anzeigen</p>
              </TooltipContent>
            </Tooltip>
          </TooltipProvider>
        )}
        {/* Delete direkt neben Dokument-Icons */}
        <TooltipProvider>
          <Tooltip>
            <TooltipTrigger asChild>
              <Button
                variant="ghost"
                size="icon"
                className="h-6 w-6 p-0 hover:bg-destructive/10 hover:text-destructive"
                onClick={(e) => onDelete(e as React.MouseEvent<HTMLButtonElement>, item)}
              >
                <Trash2 className="h-4 w-4" />
              </Button>
            </TooltipTrigger>
            <TooltipContent>
              <p>Datei löschen</p>
            </TooltipContent>
          </Tooltip>
        </TooltipProvider>
      </div>
      <div />
    </div>
  );
});

interface FileListProps {
  compact?: boolean;
}

export const FileList = React.memo(function FileList({ compact = false }: FileListProps): JSX.Element {
  const { provider, refreshItems, currentLibrary } = useStorage();
  const activeLibraryId = useAtomValue(activeLibraryIdAtom);
  const [isRefreshing, setIsRefreshing] = React.useState(false);
  // Mobile-Flag wurde entfernt, FileList lädt unabhängig vom View
  const [selectedBatchItems, setSelectedBatchItems] = useAtom(selectedBatchItemsAtom);
  const [selectedTransformationItems, setSelectedTransformationItems] = useAtom(selectedTransformationItemsAtom);
  const [, setTranscriptionDialogOpen] = useAtom(transcriptionDialogOpenAtom);
  const [, setTransformationDialogOpen] = useAtom(transformationDialogOpenAtom);
  const [isInitialized, setIsInitialized] = React.useState(false);
  const initializationTimeoutRef = React.useRef<NodeJS.Timeout | null>(null);
  // Entkoppelt: Kein Warten mehr auf FileTree-Status
  const [activeFile, setSelectedFile] = useAtom(selectedFileAtom);
  const [, setFolderItems] = useAtom(folderItemsAtom);
  const currentCategoryFilter = useAtomValue(fileCategoryFilterAtom);
  const allItemsInFolder = useAtomValue(folderItemsAtom);
  const navigateToFolder = useFolderNavigation();
  const listContainerRef = React.useRef<HTMLDivElement | null>(null);

  // Kein mobiles Flag mehr notwendig

  const folders = useMemo(() => {
    const items = allItemsInFolder ?? [];
    // Verstecke dot-Verzeichnisse generell in der Liste
    return items.filter(item => item.type === 'folder' && !item.metadata.name.startsWith('.'));
  }, [allItemsInFolder]);

  // Hilfsfunktion zum Finden einer FileGroup in der Map
  const findFileGroup = (map: Map<string, FileGroup>, stem: string): FileGroup | undefined => {
    return Array.from((map ?? new Map()).values()).find(group => 
      group.baseItem && getBaseName(group.baseItem.metadata.name) === stem
    );
  };

  // NEU: Atome für Sortierung und Filter
  const items = useAtomValue(sortedFilteredFilesAtom);
  const [sortField, setSortField] = useAtom(sortFieldAtom);
  const [sortOrder, setSortOrder] = useAtom(sortOrderAtom);
  
  // Review-Mode-Atoms
  const [, setSelectedShadowTwin] = useAtom(selectedShadowTwinAtom);

  // handleSort nutzt jetzt Atome
  const handleSort = React.useCallback((field: SortField) => {
    if (field === sortField) setSortOrder(sortOrder === 'asc' ? 'desc' : 'asc');
    else {
      setSortField(field);
      setSortOrder('asc');
    }
  }, [sortField, sortOrder, setSortField, setSortOrder]);

  // Initialisierung - nur auf Provider und Mobile-Flag achten
  React.useEffect(() => {
    if (!provider) {
      FileLogger.info('FileList', 'Waiting for provider');
      return;
    }

    const initialize = async () => {
      if (isInitialized) {
        FileLogger.debug('FileList', 'Already initialized');
        return;
      }

      FileLogger.info('FileList', 'Starting initialization');

      try {
        FileLogger.info('FileList', 'Initialization complete');
        setIsInitialized(true);
      } catch (error) {
        FileLogger.error('FileList', 'Error initializing FileList', error);
      }
    };

    initialize();

    const timeoutRef = initializationTimeoutRef.current;
    return () => {
      if (timeoutRef) clearTimeout(timeoutRef);
    };
  }, [provider, isInitialized]);

  // NEU: Reagieren auf Bibliothekswechsel
  const prevLibraryIdRef = React.useRef<string | null>(null);
  React.useEffect(() => {
    StateLogger.debug('FileList', 'Render', {
      currentLibraryId: activeLibraryId,
      activeLibraryIdAtom: activeLibraryId
    });

    // Nur bei tatsächlichem Bibliothekswechsel zurücksetzen
    if (prevLibraryIdRef.current !== null && prevLibraryIdRef.current !== activeLibraryId) {
      setIsInitialized(false);
      setSelectedFile(null);
      setFolderItems([]);
      setSelectedBatchItems([]);
      setSelectedTransformationItems([]);
      setSelectedShadowTwin(null);
      StateLogger.info('FileList', 'Bibliothek gewechselt - State zurückgesetzt', {
        libraryId: activeLibraryId
      });
    }
    prevLibraryIdRef.current = activeLibraryId;
  }, [activeLibraryId, setSelectedFile, setFolderItems, setSelectedBatchItems, setSelectedTransformationItems, setSelectedShadowTwin]);

  // Vereinfachte Funktion zum Extrahieren des Basisnamens (ohne Endung, auch für Binärdateien)
  function getBaseName(name: string): string {
    // ShadowTwin: .de.md, .en.md, etc.
    const shadowTwinMatch = name.match(/^(.*)\.(de|en|fr|es|it)\.md$/);
    if (shadowTwinMatch) return shadowTwinMatch[1];
    // Sonst: alles vor der letzten Endung
    const lastDot = name.lastIndexOf('.');
    if (lastDot === -1) return name;
    return name.substring(0, lastDot);
  }

  // Prüft ob eine Datei ein ShadowTwin ist (Markdown mit Sprachkürzel)
  function isShadowTwin(name: string): boolean {
    // Pattern: name.de.md, name.en.md, etc.
    const shadowTwinPattern = /^(.+)\.(de|en|fr|es|it)\.md$/;
    return shadowTwinPattern.test(name);
  }

  // Gruppiere die Dateien nach Basename
  const fileGroups = useMemo(() => {
    if (!items) return new Map<string, FileGroup>();

    // Schritt 1: Gruppiere alle Dateien nach Basename
    const groupsMap = new Map<string, StorageItem[]>();
    for (const item of items) {
      if (item.type !== 'file') continue;
      const base = getBaseName(item.metadata.name);
      if (!groupsMap.has(base)) groupsMap.set(base, []);
      groupsMap.get(base)!.push(item);
    }

    // Schritt 2: Erstelle FileGroups
    const fileGroupsMap = new Map<string, FileGroup>();
    for (const [base, groupItems] of Array.from(groupsMap.entries())) {
      // Finde Hauptdatei (erste Nicht-ShadowTwin-Datei)
      const mainFile = groupItems.find((item) => !isShadowTwin(item.metadata.name));
      // Finde alle ShadowTwins
      const shadowTwins = groupItems.filter((item) => isShadowTwin(item.metadata.name));
      if (mainFile) {
        fileGroupsMap.set(base, {
          baseItem: mainFile,
          transcriptFiles: shadowTwins.length > 0 ? shadowTwins : undefined,
          transformed: undefined
        });
      } else {
        // Keine Hauptdatei: Jede ShadowTwin einzeln anzeigen
        for (const twin of shadowTwins) {
          fileGroupsMap.set(`${base}__shadow_${twin.id}`, {
            baseItem: twin,
            transcriptFiles: undefined,
            transformed: undefined
          });
        }
      }
    }
    // Debug-Logging für Gruppierung
    FileLogger.debug('FileList', 'Gruppierung Ergebnis (Basename, alle Endungen)', {
      groups: Array.from(fileGroupsMap.entries()).map(([base, group]) => ({
        base,
        baseItem: group.baseItem?.metadata.name,
        transcripts: group.transcriptFiles?.map(t => t.metadata.name)
      }))
    });
    return fileGroupsMap;
  }, [items]);

  // Navigationsliste: nur Hauptdateien in der aktuell sichtbaren Reihenfolge
  const mainFileItems = React.useMemo(() => {
    return Array.from((fileGroups ?? new Map()).values())
      .map(g => g.baseItem)
      .filter((it): it is StorageItem => Boolean(it));
  }, [fileGroups]);

  // Hilfsfunktion: Gruppe anhand baseItem.id finden
  const findGroupByBaseItemId = React.useCallback((baseItemId: string) => {
    for (const g of Array.from((fileGroups ?? new Map()).values())) {
      if (g.baseItem && g.baseItem.id === baseItemId) return g;
    }
    return undefined;
  }, [fileGroups]);

  // Keyboard-Navigation: Pfeil hoch/runter wählt vorherige/nächste Datei
  const handleKeyNav = React.useCallback((e: React.KeyboardEvent<HTMLDivElement>) => {
    if (e.key !== 'ArrowDown' && e.key !== 'ArrowUp') return;
    // Eingaben in aktiven Inputs nicht stören
    const ae = document.activeElement as HTMLElement | null;
    if (ae && (ae.tagName === 'INPUT' || ae.tagName === 'TEXTAREA' || ae.isContentEditable)) return;
    if (mainFileItems.length === 0) return;
    e.preventDefault();
    const currentIndex = activeFile ? mainFileItems.findIndex(it => it.id === activeFile.id) : -1;
    const nextIndex = e.key === 'ArrowDown'
      ? Math.min((currentIndex < 0 ? 0 : currentIndex + 1), mainFileItems.length - 1)
      : Math.max((currentIndex < 0 ? 0 : currentIndex - 1), 0);
    const nextItem = mainFileItems[nextIndex];
    if (!nextItem) return;
    const group = findGroupByBaseItemId(nextItem.id);
    handleSelect(nextItem, group);
    // Sichtbar scrollen
    const rowEl = document.getElementById(`file-row-${nextItem.id}`);
    if (rowEl) rowEl.scrollIntoView({ block: 'nearest' });
  }, [activeFile, mainFileItems, handleSelect, findGroupByBaseItemId]);

  // Mapping: Basename -> dot-Systemordner (z. B. ".<basename>")
  const systemFolderByBase = useMemo(() => {
    const map = new Map<string, StorageItem>();
    const items = allItemsInFolder ?? [];
    for (const it of items) {
      if (it.type !== 'folder') continue;
      const name = it.metadata.name;
      if (!name.startsWith('.')) continue;
      const base = name.slice(1);
      if (base) map.set(base, it);
    }
    return map;
  }, [allItemsInFolder]);

  // Berechne, ob alle Dateien ausgewählt sind
  const isAllSelected = useMemo(() => {
    if (!fileGroups || !fileGroups.size) return false;
    // Verwende nur die Hauptdateien (baseItem) aus den FileGroups
    const mainItems = Array.from((fileGroups ?? new Map()).values())
      .map(group => group.baseItem)
      .filter((item): item is StorageItem => item !== undefined);
    // Je nach Filter unterschiedliche Dateien zählen
    let selectableItems: StorageItem[] = [];
    switch (currentCategoryFilter) {
      case 'media':
        selectableItems = mainItems.filter(item => {
          try {
            const mediaType = getMediaType(item);
            return item.type === 'file' && (mediaType === 'audio' || mediaType === 'video');
          } catch {
            return false;
          }
        });
        return selectableItems.length > 0 && selectedBatchItems.length === selectableItems.length;
      case 'text':
        selectableItems = mainItems.filter(item => {
          try {
            const mediaType = getMediaType(item);
            return item.type === 'file' && mediaType === 'text';
          } catch {
            return false;
          }
        });
        return selectableItems.length > 0 && selectedTransformationItems.length === selectableItems.length;
      case 'documents':
        selectableItems = mainItems.filter(item => {
          try {
            const mediaType = getMediaType(item);
            return item.type === 'file' && mediaType === 'document';
          } catch {
            return false;
          }
        });
        return selectableItems.length > 0 && selectedTransformationItems.length === selectableItems.length;
      default:
        // Bei 'all' prüfen ob alle verfügbaren Dateien ausgewählt sind
        const mediaItems = mainItems.filter(item => {
          try {
            const mediaType = getMediaType(item);
            return item.type === 'file' && (mediaType === 'audio' || mediaType === 'video');
          } catch {
            return false;
          }
        });
        const textItems = mainItems.filter(item => {
          try {
            const mediaType = getMediaType(item);
            return item.type === 'file' && (mediaType === 'text' || mediaType === 'document');
          } catch {
            return false;
          }
        });
        const allMediaSelected = mediaItems.length === 0 || selectedBatchItems.length === mediaItems.length;
        const allTextSelected = textItems.length === 0 || selectedTransformationItems.length === textItems.length;
        return allMediaSelected && allTextSelected;
    }
  }, [fileGroups, selectedBatchItems, selectedTransformationItems, currentCategoryFilter]);
  
  // Erweiterte handleSelect Funktion für Review-Mode
  const handleSelect = useCallback((item: StorageItem, group?: FileGroup) => {
    FileLogger.debug('FileList', 'handleSelect aufgerufen', {
      itemId: item.id,
      itemName: item.metadata.name,
      groupBase: group?.baseItem?.metadata.name,
      transcriptCount: group?.transcriptFiles?.length ?? 0,
      hasTranscripts: !!(group && group.transcriptFiles && group.transcriptFiles.length > 0)
    });
    
    // Nur die ausgewählte Datei setzen - Review-Modus wird über Toggle-Button gesteuert
    setSelectedFile(item);
    
    // Wenn wir im Review-Modus sind und eine Basis-Datei mit Shadow-Twin ausgewählt wird,
    // dann automatisch das Shadow-Twin setzen
    if (group && group.transcriptFiles && group.transcriptFiles.length > 0) {
      const shadowTwin = group.transcriptFiles[0];
      FileLogger.info('FileList', 'Basis-Datei mit Shadow-Twin ausgewählt', {
        twinId: shadowTwin.id,
        twinName: shadowTwin.metadata.name,
        baseFileId: item.id,
        baseFileName: item.metadata.name
      });
      setSelectedShadowTwin(shadowTwin);
    } else {
      FileLogger.info('FileList', 'Datei ohne Shadow-Twin ausgewählt', {
        itemId: item.id,
        itemName: item.metadata.name,
        groupExists: !!group,
        transcriptCount: group?.transcriptFiles?.length ?? 0
      });
      setSelectedShadowTwin(null);
    }
  }, [setSelectedFile, setSelectedShadowTwin, findFileGroup]);
  
  // Erweiterte handleSelectRelatedFile Funktion für Review-Mode
  const handleSelectRelatedFile = useCallback((shadowTwin: StorageItem) => {
    StateLogger.info('FileList', 'Shadow-Twin ausgewählt', {
      shadowTwinId: shadowTwin.id,
      shadowTwinName: shadowTwin.metadata.name
    });
    
    // Setze das Shadow-Twin als ausgewählte Datei, damit es rechts angezeigt wird
    setSelectedFile(shadowTwin);
    setSelectedShadowTwin(null); // Kein zusätzliches Shadow-Twin im normalen Modus
  }, [setSelectedFile, setSelectedShadowTwin, findFileGroup]);

  // Aktualisierte handleRefresh Funktion
  const handleRefresh = useCallback(async () => {
    if (!items || items.length === 0) return;
    
    const parentId = items[0]?.parentId;
    if (!parentId) return;
    
    setIsRefreshing(true);
    
    try {
      const refreshedItems = await refreshItems(parentId);
      setFolderItems(refreshedItems);
    } catch (error) {
      FileLogger.error('FileList', 'Fehler beim Aktualisieren der Dateiliste', error);
    } finally {
      setIsRefreshing(false);
    }
  }, [items, refreshItems, setFolderItems]);

  const handleCreateTranscript = React.useCallback((e: React.MouseEvent) => {
    e.stopPropagation();
    FileLogger.info('FileList', 'Create transcript for', { fileName: 'TODO' });
    // TODO: Implement transcript creation
  }, []);

  // Entfernt: handleItemSelect war unbenutzt

  // Check if an item is selected (beide Atome prüfen)
  const isItemSelected = useCallback((item: StorageItem) => {
    const mediaType = getMediaType(item);
    if (mediaType === 'audio' || mediaType === 'video') {
      return selectedBatchItems.some(selected => selected.item.id === item.id);
    } else {
      return selectedTransformationItems.some(selected => selected.item.id === item.id);
    }
  }, [selectedBatchItems, selectedTransformationItems]);

  // Löschfunktion
  const handleDeleteClick = React.useCallback(async (e: React.MouseEvent<HTMLButtonElement>, itemToDelete: StorageItem) => {
    e.stopPropagation();
    
    if (!provider) {
      toast.error("Fehler", {
        description: "Storage Provider nicht verfügbar"
      });
      return;
    }

    try {
      // Finde die FileGroup für dieses Item
      const itemStem = getBaseName(itemToDelete.metadata.name);
      const fileGroup = findFileGroup(fileGroups, itemStem);

      // Bestätigungsnachricht vorbereiten
      let confirmMessage = `Möchten Sie "${itemToDelete.metadata.name}" wirklich löschen?`;
      if (fileGroup && itemToDelete.id === fileGroup.baseItem?.id) {
        if (fileGroup.transcriptFiles && fileGroup.transcriptFiles.length > 0 || fileGroup.transformed) {
          confirmMessage = `Möchten Sie "${itemToDelete.metadata.name}" und alle zugehörigen Dateien wirklich löschen?`;
        }
      }

      // Benutzer um Bestätigung bitten
      if (!window.confirm(confirmMessage)) {
        return;
      }

      if (fileGroup && itemToDelete.id === fileGroup.baseItem?.id) {
        // Dies ist die Basis-Datei - lösche auch abhängige Dateien
        // Lösche alle Transkripte, falls vorhanden
        if (fileGroup.transcriptFiles) {
          for (const transcript of fileGroup.transcriptFiles) {
            try {
              await provider.deleteItem(transcript.id);
              FileLogger.info('FileList', 'Transkript gelöscht', {
                transcriptId: transcript.id,
                transcriptName: transcript.metadata.name
              });
            } catch (error) {
              FileLogger.error('FileList', 'Fehler beim Löschen des Transkripts', error);
              toast.warning("Hinweis", {
                description: "Einige Transkripte konnten nicht gelöscht werden"
              });
            }
          }
        }

        // Lösche die transformierte Datei, falls vorhanden
        if (fileGroup.transformed) {
          try {
            await provider.deleteItem(fileGroup.transformed.id);
            FileLogger.info('FileList', 'Transformierte Datei gelöscht', {
              transformedId: fileGroup.transformed.id,
              transformedName: fileGroup.transformed.metadata.name
            });
          } catch (error) {
            FileLogger.error('FileList', 'Fehler beim Löschen der transformierten Datei', error);
            toast.warning("Hinweis", {
              description: "Die transformierte Datei konnte nicht gelöscht werden"
            });
          }
        }

        // Lösche die Basis-Datei
        await provider.deleteItem(itemToDelete.id);
        toast.success("Dateien gelöscht", {
          description: `${itemToDelete.metadata.name} und zugehörige Dateien wurden gelöscht.`
        });
      } else {
        // Dies ist eine abhängige Datei oder keine Gruppe - nur diese Datei löschen
        await provider.deleteItem(itemToDelete.id);
        toast.success("Datei gelöscht", {
          description: `${itemToDelete.metadata.name} wurde gelöscht.`
        });
      }

      // Aktualisiere die Dateiliste
      await handleRefresh();

      // Wenn die gelöschte Datei ausgewählt war, Auswahl aufheben
      setSelectedFile(null);
      
      // Aus der Batch-Auswahl entfernen
      setSelectedBatchItems(prev => prev.filter(i => i.item.id !== itemToDelete.id));

    } catch (error) {
      FileLogger.error('FileList', 'Fehler beim Löschen', error);
      toast.error("Fehler", {
        description: `Die Datei konnte nicht gelöscht werden: ${error instanceof Error ? error.message : 'Unbekannter Fehler'}`
      });
    }
  }, [provider, handleRefresh, fileGroups, setSelectedFile, setSelectedBatchItems]);

  const handleRename = React.useCallback(async (item: StorageItem, newName: string) => {
    if (!provider) {
      toast.error("Fehler", {
        description: "Storage Provider nicht verfügbar"
      });
      return;
    }

    try {
      // Finde die FileGroup für dieses Item
      const itemStem = getBaseName(item.metadata.name);
      const fileGroup = findFileGroup(fileGroups, itemStem);

      if (fileGroup && item.id === fileGroup.baseItem?.id) {
        // Dies ist die Basis-Datei - benenne auch abhängige Dateien um
        const oldStem = getBaseName(item.metadata.name);
        const newStem = getBaseName(newName);
        // Benenne die Basis-Datei um
        await provider.renameItem(item.id, newName);
        // Benenne alle Transkripte um, falls vorhanden
        if (fileGroup.transcriptFiles) {
          for (const transcript of fileGroup.transcriptFiles) {
            const transcriptName = transcript.metadata.name;
            const newTranscriptName = transcriptName.replace(oldStem, newStem);
            try {
              await provider.renameItem(transcript.id, newTranscriptName);
            } catch (error) {
              FileLogger.error('FileList', 'Fehler beim Umbenennen des Transkripts', error);
              toast.warning("Hinweis", {
                description: "Einige Transkripte konnten nicht umbenannt werden"
              });
            }
          }
        }
        // Benenne die transformierte Datei um, falls vorhanden
        if (fileGroup.transformed) {
          const transformedName = fileGroup.transformed.metadata.name;
          const newTransformedName = transformedName.replace(oldStem, newStem);
          try {
            await provider.renameItem(fileGroup.transformed.id, newTransformedName);
          } catch (error) {
            FileLogger.error('FileList', 'Fehler beim Umbenennen der transformierten Datei', error);
            toast.warning("Hinweis", {
              description: "Die transformierte Datei konnte nicht umbenannt werden"
            });
          }
        }
        toast.success("Dateien umbenannt", {
          description: `${item.metadata.name} und zugehörige Dateien wurden umbenannt.`
        });
      } else {
        // Dies ist eine abhängige Datei oder keine Gruppe - nur diese Datei umbenennen
        await provider.renameItem(item.id, newName);
        toast.success("Datei umbenannt", {
          description: `${item.metadata.name} wurde zu ${newName} umbenannt.`
        });
      }
      await handleRefresh();
    } catch (error) {
      FileLogger.error('FileList', 'Fehler beim Umbenennen', error);
      toast.error("Fehler", {
        description: `Die Datei konnte nicht umbenannt werden: ${error instanceof Error ? error.message : 'Unbekannter Fehler'}`
      });
      throw error;
    }
  }, [provider, handleRefresh, fileGroups]);

  const handleBatchTranscription = () => {
    if (selectedBatchItems.length > 0) {
      setTranscriptionDialogOpen(true);
    }
  };

  const handleBatchTransformation = () => {
    if (selectedTransformationItems.length > 0) {
      setTransformationDialogOpen(true);
    }
  };

  // Bulk-Löschung für ausgewählte Dateien (unabhängig von Batch/Transformation-Selektor)
  const handleBulkDelete = React.useCallback(async () => {
    if (!provider) return;
    const targets = [
      ...selectedBatchItems.map(x => x.item),
      ...selectedTransformationItems.map(x => x.item),
    ];
    if (targets.length === 0) return;
    const confirmMsg = targets.length === 1
      ? `"${targets[0].metadata.name}" wirklich löschen?`
      : `${targets.length} Dateien wirklich löschen?`;
    if (!window.confirm(confirmMsg)) return;

    try {
      const parentId = targets[0].parentId || 'root';
      for (const t of targets) {
        try { await provider.deleteItem(t.id); } catch (err) {
          FileLogger.error('FileList', 'Bulk Delete failed', { id: t.id, name: t.metadata.name, err });
        }
      }
      const refreshed = await refreshItems(parentId);
      setFolderItems(refreshed);
      setSelectedBatchItems([]);
      setSelectedTransformationItems([]);
    } catch (error) {
      FileLogger.error('FileList', 'Bulk Delete error', error);
    }
  }, [provider, selectedBatchItems, selectedTransformationItems, refreshItems, setFolderItems, setSelectedBatchItems, setSelectedTransformationItems]);

  // Intelligente Batch-Auswahl basierend auf Filter
  const handleSelectAll = useCallback((checked: boolean) => {
    const startTime = performance.now();
    if (checked) {
      // Verwende nur die Hauptdateien (baseItem) aus den FileGroups
      const mainItems = Array.from((fileGroups ?? new Map()).values())
        .map(group => group.baseItem)
        .filter((item): item is StorageItem => item !== undefined);
      const selectableItems = mainItems.filter(item => {
        try {
          const mediaType = getMediaType(item);
          // Je nach Filter unterschiedliche Dateien auswählen
          switch (currentCategoryFilter) {
            case 'media':
              return item.type === 'file' && (mediaType === 'audio' || mediaType === 'video');
            case 'text':
              return item.type === 'file' && mediaType === 'text';
            case 'documents':
              return item.type === 'file' && mediaType === 'document';
            default:
              // Bei 'all' alle Dateien auswählen, die für eine Operation geeignet sind
              return item.type === 'file' && (
                mediaType === 'audio' || 
                mediaType === 'video' || 
                mediaType === 'text' || 
                mediaType === 'document'
              );
          }
        } catch {
          return false;
        }
      });
      StateLogger.info('FileList', 'Selecting all items based on filter', {
        filter: currentCategoryFilter,
        totalItems: items.length,
        selectableCount: selectableItems.length,
        duration: `${(performance.now() - startTime).toFixed(2)}ms`
      });
      // Je nach Filter unterschiedliche Atome verwenden
      if (currentCategoryFilter === 'media') {
        setSelectedBatchItems(selectableItems.map(item => ({
          item,
          type: getMediaType(item)
        })));
      } else if (currentCategoryFilter === 'text') {
        setSelectedTransformationItems(selectableItems.map(item => ({
          item,
          type: getMediaType(item)
        })));
      } else {
        // Bei 'all' oder 'documents' beide Atome füllen
        const mediaItems = selectableItems.filter(item => {
          const mediaType = getMediaType(item);
          return mediaType === 'audio' || mediaType === 'video';
        });
        const textItems = selectableItems.filter(item => {
          const mediaType = getMediaType(item);
          return mediaType === 'text' || mediaType === 'document';
        });
        setSelectedBatchItems(mediaItems.map(item => ({
          item,
          type: getMediaType(item)
        })));
        setSelectedTransformationItems(textItems.map(item => ({
          item,
          type: getMediaType(item)
        })));
      }
    } else {
      StateLogger.info('FileList', 'Deselecting all items', {
        previouslySelected: selectedBatchItems.length + selectedTransformationItems.length,
        duration: `${(performance.now() - startTime).toFixed(2)}ms`
      });
      setSelectedBatchItems([]);
      setSelectedTransformationItems([]);
    }
  }, [fileGroups, currentCategoryFilter, setSelectedBatchItems, setSelectedTransformationItems, selectedBatchItems.length, selectedTransformationItems.length, items.length]);

  React.useEffect(() => {
    // Logging der Library-IDs - verzögert ausführen
    const timeoutId = setTimeout(() => {
      StateLogger.debug('FileList', 'Render', {
        currentLibraryId: currentLibrary?.id,
        activeLibraryIdAtom: activeLibraryId
      });
    }, 0);
    
    return () => clearTimeout(timeoutId);
  }, [currentLibrary, activeLibraryId]);

  // Entkoppelt: kein Render-Gate mehr basierend auf FileTree

  return (
    <div className="h-full flex flex-col">
      {/* Header - versteckt im compact mode */}
      {!compact && (
        <div className="border-b px-2 py-2 flex items-center justify-between bg-background sticky top-0 z-10">
          <div className="flex items-center gap-2">
            <Button
              variant="ghost"
              size="icon"
              className="h-8 w-8"
              onClick={handleRefresh}
              disabled={isRefreshing}
              title="Aktualisieren"
              aria-label="Aktualisieren"
            >
              <RefreshCw className={cn("h-4 w-4", isRefreshing && "animate-spin")} />
            </Button>

            {/* Dateikategorie-Filter (Icon-only Variante) */}
            <FileCategoryFilter iconOnly />

            {/* Batch-Actions als Icons */}
            {selectedBatchItems.length > 0 && (
              <Button size="icon" title="Transkribieren" aria-label="Transkribieren" onClick={handleBatchTranscription}>
                <ScrollText className="h-4 w-4" />
              </Button>
            )}
            {selectedTransformationItems.length > 0 && (
              <Button size="icon" variant="secondary" title="Transformieren" aria-label="Transformieren" onClick={handleBatchTransformation}>
                <Plus className="h-4 w-4" />
              </Button>
            )}
            {(selectedBatchItems.length + selectedTransformationItems.length) > 0 && (
              <Button size="icon" variant="destructive" title="Ausgewählte löschen" aria-label="Ausgewählte löschen" onClick={handleBulkDelete}>
                <Trash2 className="h-4 w-4" />
              </Button>
            )}
          </div>
        </div>
      )}

      {/* File List */}
      <div ref={listContainerRef} className="flex-1 overflow-auto focus:outline-none" tabIndex={0} onKeyDown={handleKeyNav}>
        <div>
          {/* Table Header - versteckt im compact mode */}
          {!compact && (
            <div className="sticky top-0 bg-background border-b">
              <div className="grid grid-cols-[24px_24px_minmax(0,1fr)_56px_88px_auto] gap-2 px-4 py-2 text-sm font-medium text-muted-foreground">
                <div className="w-6 flex items-center justify-center">
                  <Checkbox
                    checked={isAllSelected}
                    onCheckedChange={handleSelectAll}
                    aria-label="Alle auswählen"
                  />
                </div>
                <div className="w-6" />
                <SortableHeaderCell
                  label="Name"
                  field="name"
                  currentSortField={sortField}
                  currentSortOrder={sortOrder}
                  onSort={handleSort}
                />
                <SortableHeaderCell
                  label="Größe"
                  field="size"
                  currentSortField={sortField}
                  currentSortOrder={sortOrder}
                  onSort={handleSort}
                />
                <SortableHeaderCell
                  label="Geändert"
                  field="date"
                  currentSortField={sortField}
                  currentSortOrder={sortOrder}
                  onSort={handleSort}
                />
                <div />
              </div>
            </div>
          )}

          {/* Folder Rows (oberhalb der Dateien, unabhängig von Datei-Gruppierung) */}
          {folders.length > 0 && (
            <div className="divide-y">
          {folders.map((folder) => (
            compact ? (
              // Kompakt: ohne Einrückung, nur Icon + Name (2 Spalten)
              <div
                key={folder.id}
                role="button"
                tabIndex={0}
                onClick={() => navigateToFolder(folder.id)}
                onKeyDown={(e) => { if (e.key === 'Enter' || e.key === ' ') navigateToFolder(folder.id) }}
                className="w-full px-2 py-1 text-xs hover:bg-muted/50 grid grid-cols-[24px_minmax(0,1fr)] gap-2 items-center cursor-pointer"
              >
                <FolderIcon className="h-4 w-4" />
                <span className="text-left truncate select-none" title={folder.metadata.name}>{folder.metadata.name}</span>
              </div>
            ) : (
              // Normal: behalte leichte Einrückung für Checkbox-Spalte
              <div
                key={folder.id}
                role="button"
                tabIndex={0}
                onClick={() => navigateToFolder(folder.id)}
                onKeyDown={(e) => { if (e.key === 'Enter' || e.key === ' ') navigateToFolder(folder.id) }}
                className="w-full px-4 py-2 text-xs hover:bg-muted/50 grid grid-cols-[24px_24px_minmax(0,1fr)] gap-2 items-center cursor-pointer"
              >
                <div />
                <FolderIcon className="h-4 w-4" />
                <span className="text-left truncate select-none" title={folder.metadata.name}>{folder.metadata.name}</span>
              </div>
            )
          ))}
            </div>
          )}

          {/* File Rows */}
          <div className="divide-y">
            {Array.from((fileGroups ?? new Map()).values())
              .map((group) => {
                // Zeige nur die Hauptdatei (baseItem) an
                const item = group.baseItem;
                if (!item) return null;
                // System-Unterordner-Id, wenn ein ".<basename>"-Folder existiert
                const systemFolder = systemFolderByBase.get(getBaseName(item.metadata.name));
                const systemFolderId = systemFolder?.id;
                const isActive = !!activeFile && activeFile.id === item.id
                return (
                  <FileRow
                    key={item.id}
                    item={item as StorageItem}
                    isSelected={isItemSelected(item)}
                    isActive={isActive}
                    onSelect={() => handleSelect(item, group)}
                    onCreateTranscript={handleCreateTranscript}
                    onDelete={(e) => handleDeleteClick(e, item)}
                    fileGroup={group}
                    onSelectRelatedFile={handleSelectRelatedFile}
                    onRename={handleRename}
                    compact={compact}
                    systemFolderId={systemFolderId}
                  />
                );
              })}
          </div>
        </div>
      </div>
    </div>
  );
}); 
```

Ich ergänze die Pfeiltasten-Navigation in der `FileList`: Container erhält Fokus und Keydown-Handler; Zeilen bekommen IDs zum gezielten Scrollen. Danach prüfe ich Linter und hake die Worker-TODOs ab.

```typescriptreact
'use client';

import * as React from "react"
import { File, FileText, FileVideo, FileAudio, Plus, RefreshCw, ChevronUp, ChevronDown, Trash2, ScrollText, Folder as FolderIcon, Layers } from "lucide-react"
import { StorageItem } from "@/lib/storage/types"
import { cn } from "@/lib/utils"
import { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from "@/components/ui/tooltip"
import { useStorage } from "@/contexts/storage-context";
import { Button } from "@/components/ui/button";
import { useAtomValue, useAtom } from 'jotai';
import { jobStatusByItemIdAtom } from '@/atoms/job-status';
import { 
  activeLibraryIdAtom, 
  selectedFileAtom, 
  folderItemsAtom,
  sortedFilteredFilesAtom,
  sortFieldAtom,
  sortOrderAtom,
  selectedShadowTwinAtom
} from '@/atoms/library-atom';
import { toast } from "sonner";
import { Input } from "@/components/ui/input"
import {
  selectedBatchItemsAtom,
  transcriptionDialogOpenAtom,
  selectedTransformationItemsAtom,
  transformationDialogOpenAtom,
  getMediaType,
  fileCategoryFilterAtom,
} from '@/atoms/transcription-options';
import { Checkbox } from "@/components/ui/checkbox"
import { useMemo, useCallback } from "react"
import { FileLogger, StateLogger } from "@/lib/debug/logger"
import { FileCategoryFilter } from './file-category-filter';
import { useFolderNavigation } from "@/hooks/use-folder-navigation";

// Typen für Sortieroptionen
type SortField = 'type' | 'name' | 'size' | 'date';
type SortOrder = 'asc' | 'desc';

// Typ für gruppierte Dateien
interface FileGroup {
  baseItem?: StorageItem;
  transcriptFiles?: StorageItem[]; // NEU: alle Transkripte
  transformed?: StorageItem;
}

// Memoized file icon component
const FileIconComponent = React.memo(function FileIconComponent({ item }: { item: StorageItem }) {
  const mimeType = item.metadata.mimeType || '';
  if (!mimeType) return <File className="h-4 w-4" />;

  if (mimeType.startsWith('video/')) {
    return <FileVideo className="h-4 w-4" />;
  } else if (mimeType.startsWith('audio/')) {
    return <FileAudio className="h-4 w-4" />;
  } else if (mimeType.startsWith('text/')) {
    return <FileText className="h-4 w-4" />;
  }

  return <File className="h-4 w-4" />;
});

// Pure function for file size formatting
const formatFileSize = (size?: number): string => {
  if (!size) return '-';
  const units = ['B', 'KB', 'MB', 'GB'];
  let value = size;
  let unitIndex = 0;
  
  while (value >= 1024 && unitIndex < units.length - 1) {
    value /= 1024;
    unitIndex++;
  }
  
  return `${value.toFixed(1)} ${units[unitIndex]}`;
};

// Funktion zum Formatieren des Datums
const formatDate = (date?: Date): string => {
  if (!date) return '-';
  
  const options: Intl.DateTimeFormatOptions = { 
    year: '2-digit', 
    month: '2-digit', 
    day: '2-digit',
    hour: '2-digit',
    minute: '2-digit'
  };
  
  return new Date(date).toLocaleDateString('de-DE', options);
};

// Entfernt: getFileStem Funktion war unbenutzt

// Sortierbare Kopfzelle Komponente
const SortableHeaderCell = React.memo(function SortableHeaderCell({
  label,
  field,
  currentSortField,
  currentSortOrder,
  onSort
}: {
  label: string,
  field: SortField,
  currentSortField: SortField,
  currentSortOrder: SortOrder,
  onSort: (field: SortField) => void
}) {
  const isActive = currentSortField === field;
  
  return (
    <button 
      onClick={() => onSort(field)}
      className="flex items-center gap-1 hover:text-foreground"
    >
      <span>{label}</span>
      {isActive && (
        currentSortOrder === 'asc' 
          ? <ChevronUp className="h-3 w-3" /> 
          : <ChevronDown className="h-3 w-3" />
      )}
    </button>
  );
});

interface FileRowProps {
  item: StorageItem;
  isSelected: boolean;
  isActive?: boolean;
  onSelect: () => void;
  onCreateTranscript: (e: React.MouseEvent) => void;
  onDelete: (e: React.MouseEvent<HTMLButtonElement>, item: StorageItem) => void;
  fileGroup?: FileGroup;
  onSelectRelatedFile?: (file: StorageItem) => void;
  onRename?: (item: StorageItem, newName: string) => Promise<void>;
  compact?: boolean;
  systemFolderId?: string;
}

const FileRow = React.memo(function FileRow({ 
  item, 
  isSelected, 
  isActive = false,
  onSelect,
  onCreateTranscript,
  onDelete,
  fileGroup,
  onSelectRelatedFile,
  onRename,
  compact = false,
  systemFolderId
}: FileRowProps) {
  const navigateToFolder = useFolderNavigation();
  const [isEditing, setIsEditing] = React.useState(false);
  const [editName, setEditName] = React.useState(item.metadata.name);
  const inputRef = React.useRef<HTMLInputElement>(null);
  const longPressTimerRef = React.useRef<NodeJS.Timeout | null>(null);
  const lastClickTimeRef = React.useRef<number>(0);
  
  // Zusätzliche Validierung der Metadaten
  const metadata = React.useMemo(() => ({
    name: item.metadata?.name || 'Unbekannte Datei',
    size: typeof item.metadata?.size === 'number' ? item.metadata.size : 0,
    mimeType: item.metadata?.mimeType || '',
    hasTranscript: !!item.metadata?.hasTranscript || (fileGroup?.transcriptFiles && fileGroup.transcriptFiles.length > 0),
    modifiedAt: item.metadata?.modifiedAt
  }), [item.metadata, fileGroup]);

  const isTranscribable = React.useMemo(() => {
    const mimeType = metadata.mimeType.toLowerCase();
    const extension = metadata.name.split('.').pop()?.toLowerCase();

    return (
      mimeType.startsWith('audio/') ||
      mimeType.startsWith('video/') ||
      extension === 'pdf' ||
      mimeType === 'application/pdf'
    );
  }, [metadata.mimeType, metadata.name]);

  // Memoize the click handler
  const handleClick = React.useCallback(() => {
    if (!isEditing) {
      onSelect();
    }
  }, [onSelect, isEditing]);

  // Memoize the keydown handler
  const handleKeyDown = React.useCallback((e: React.KeyboardEvent) => {
    if (!isEditing && (e.key === 'Enter' || e.key === ' ')) {
      onSelect();
    }
  }, [onSelect, isEditing]);

  // Handler für Transkript-Icon Click
  const handleTranscriptClick = React.useCallback((e: React.MouseEvent) => {
    e.stopPropagation();
    if (fileGroup?.transcriptFiles && onSelectRelatedFile) {
      onSelectRelatedFile(fileGroup.transcriptFiles[0]); // Nur das erste Transkript anzeigen
    }
  }, [fileGroup, onSelectRelatedFile]);

  // Handler für Transformierte-Datei-Icon Click
  const handleTransformedClick = React.useCallback((e: React.MouseEvent) => {
    e.stopPropagation();
    if (fileGroup?.transformed && onSelectRelatedFile) {
      onSelectRelatedFile(fileGroup.transformed);
    }
  }, [fileGroup, onSelectRelatedFile]);

  // Starte Rename-Modus
  const startRename = React.useCallback(() => {
    if (onRename) {
      // Prüfe ob dies eine abhängige Datei ist
      if (fileGroup && (
        (fileGroup.transcriptFiles && fileGroup.transcriptFiles.length > 0 && fileGroup.transcriptFiles[0]?.id === item.id) ||
        (fileGroup.transformed && item.id === fileGroup.transformed.id)
      )) {
        // Dies ist eine abhängige Datei - zeige Hinweis
        toast.info("Hinweis", {
          description: "Bitte benennen Sie die Haupt-Datei um. Abhängige Dateien werden automatisch mit umbenannt."
        });
        return;
      }
      
      setIsEditing(true);
      setEditName(item.metadata.name);
    }
  }, [onRename, item, fileGroup]);

  // Handler für Dateinamen-Click (Doppelklick-Erkennung)
  const handleNameClick = React.useCallback((e: React.MouseEvent) => {
    e.stopPropagation();
    
    const currentTime = Date.now();
    const timeSinceLastClick = currentTime - lastClickTimeRef.current;
    
    if (timeSinceLastClick < 300) {
      // Doppelklick erkannt
      startRename();
    } else {
      // Erster Klick - wähle die Datei aus
      onSelect();
    }
    
    lastClickTimeRef.current = currentTime;
  }, [startRename, onSelect]);

  // Handler für Long-Press (Touch-Geräte)
  const handleTouchStart = React.useCallback((e: React.TouchEvent) => {
    e.stopPropagation();
    
    // Starte Long-Press Timer
    longPressTimerRef.current = setTimeout(() => {
      startRename();
    }, 500); // 500ms für Long-Press
  }, [startRename]);

  const handleTouchEnd = React.useCallback((e: React.TouchEvent) => {
    e.stopPropagation();
    
    // Lösche Long-Press Timer
    if (longPressTimerRef.current) {
      clearTimeout(longPressTimerRef.current);
      longPressTimerRef.current = null;
    }
  }, []);

  const handleTouchMove = React.useCallback(() => {
    // Bei Bewegung Long-Press abbrechen
    if (longPressTimerRef.current) {
      clearTimeout(longPressTimerRef.current);
      longPressTimerRef.current = null;
    }
  }, []);

  // Cleanup Timer bei Unmount
  React.useEffect(() => {
    return () => {
      if (longPressTimerRef.current) {
        clearTimeout(longPressTimerRef.current);
      }
    };
  }, []);

  // Handler für Rename-Submit
  const handleRenameSubmit = React.useCallback(async () => {
    if (onRename && editName.trim() && editName !== item.metadata.name) {
      try {
        await onRename(item, editName.trim());
      } catch (error) {
        FileLogger.error('FileRow', 'Fehler beim Umbenennen', error);
        // Bei Fehler den ursprünglichen Namen wiederherstellen
        setEditName(item.metadata.name);
      }
    }
    setIsEditing(false);
  }, [onRename, editName, item]);

  // Handler für Rename-Cancel
  const handleRenameCancel = React.useCallback(() => {
    setEditName(item.metadata.name);
    setIsEditing(false);
  }, [item.metadata.name]);

  // Handler für Input-Änderungen
  const handleInputChange = React.useCallback((e: React.ChangeEvent<HTMLInputElement>) => {
    setEditName(e.target.value);
  }, []);

  // Handler für Input-Keydown
  const handleInputKeyDown = React.useCallback((e: React.KeyboardEvent<HTMLInputElement>) => {
    e.stopPropagation();
    if (e.key === 'Enter') {
      handleRenameSubmit();
    } else if (e.key === 'Escape') {
      handleRenameCancel();
    }
  }, [handleRenameSubmit, handleRenameCancel]);

  // Focus Input wenn Edit-Modus aktiviert wird
  React.useEffect(() => {
    if (isEditing && inputRef.current) {
      inputRef.current.focus();
      inputRef.current.select();
    }
  }, [isEditing]);

  // Handler für Drag Start
  const handleDragStart = React.useCallback((e: React.DragEvent) => {
    // Sammle alle Dateien der Gruppe, die verschoben werden sollen
    const itemsToMove = [];
    
    // Füge das aktuelle Item hinzu
    itemsToMove.push({
      itemId: item.id,
      itemName: item.metadata.name,
      itemType: item.type,
      parentId: item.parentId
    });
    
    // Wenn es eine FileGroup gibt, füge auch die zugehörigen Dateien hinzu
    if (fileGroup) {
      // Prüfe ob das aktuelle Item die Basis-Datei ist
      if (item.id === fileGroup.baseItem?.id) {
        // Füge Transkripte hinzu, falls vorhanden
        if (fileGroup.transcriptFiles && fileGroup.transcriptFiles.length > 0) {
          fileGroup.transcriptFiles.forEach(transcript => {
            itemsToMove.push({
              itemId: transcript.id,
              itemName: transcript.metadata.name,
              itemType: transcript.type,
              parentId: transcript.parentId
            });
          });
        }
        
        // Füge transformierte Datei hinzu, falls vorhanden
        if (fileGroup.transformed) {
          itemsToMove.push({
            itemId: fileGroup.transformed.id,
            itemName: fileGroup.transformed.metadata.name,
            itemType: fileGroup.transformed.type,
            parentId: fileGroup.transformed.parentId
          });
        }
      }
    }
    
    // Setze die Drag-Daten
    e.dataTransfer.effectAllowed = 'move';
    e.dataTransfer.setData('application/json', JSON.stringify({
      items: itemsToMove,
      isFileGroup: itemsToMove.length > 1
    }));
    
    // Visuelles Feedback
    if (e.currentTarget instanceof HTMLElement) {
      e.currentTarget.style.opacity = '0.5';
    }
  }, [item, fileGroup]);

  // Handler für Drag End
  const handleDragEnd = React.useCallback((e: React.DragEvent) => {
    // Stelle Opacity wieder her
    if (e.currentTarget instanceof HTMLElement) {
      e.currentTarget.style.opacity = '1';
    }
  }, []);

  const [selectedBatchItems, setSelectedBatchItems] = useAtom(selectedBatchItemsAtom);
  const [selectedTransformationItems, setSelectedTransformationItems] = useAtom(selectedTransformationItemsAtom);
  
  // Prüfe ob das Item in einem der beiden Atome ausgewählt ist
  const isInBatch = selectedBatchItems.some(batchItem => batchItem.item.id === item.id);
  const isInTransformation = selectedTransformationItems.some(transformationItem => transformationItem.item.id === item.id);
  const isInAnyBatch = isInBatch || isInTransformation;

  // Handler für Checkbox-Änderungen
  const handleCheckboxChange = React.useCallback((checked: boolean) => {
    const mediaType = getMediaType(item);
    
    if (mediaType === 'audio' || mediaType === 'video') {
      // Für Audio/Video: Transcription-Atom verwenden
      if (checked) {
        setSelectedBatchItems([...selectedBatchItems, {
          item,
          type: mediaType
        }]);
      } else {
        setSelectedBatchItems(selectedBatchItems.filter(i => i.item.id !== item.id));
      }
    } else if (mediaType === 'text' || mediaType === 'document') {
      // Für Text/Dokumente: Transformation-Atom verwenden
      if (checked) {
        setSelectedTransformationItems([...selectedTransformationItems, {
          item,
          type: mediaType
        }]);
      } else {
        setSelectedTransformationItems(selectedTransformationItems.filter(i => i.item.id !== item.id));
      }
    }
  }, [item, selectedBatchItems, selectedTransformationItems, setSelectedBatchItems, setSelectedTransformationItems]);

  React.useEffect(() => {
    if (fileGroup) {
      FileLogger.debug('FileRow', 'Transkripte für Zeile', {
        baseItem: fileGroup.baseItem?.metadata.name,
        transcripts: fileGroup.transcriptFiles?.map(t => t.metadata.name)
      });
    }
  }, [fileGroup]);

  // Zentraler Jobstatus (muss vor möglichen early-returns stehen, um Hook-Order zu garantieren)
  const jobStatusMap = useAtomValue(jobStatusByItemIdAtom);
  const jobStatus = jobStatusMap[item.id];
  const jobStatusIcon = jobStatus ? (
    <span title={jobStatus} className={cn('inline-block h-3 w-3 rounded-full',
      jobStatus === 'queued' && 'bg-blue-600',
      jobStatus === 'running' && 'bg-yellow-600',
      jobStatus === 'completed' && 'bg-green-600',
      jobStatus === 'failed' && 'bg-red-600'
    )} aria-label={`job-${jobStatus}`} />
  ) : null;

  // Compact-Modus: vereinfachte Darstellung
  if (compact) {
    return (
      <div
        role="button"
        tabIndex={0}
        onClick={handleClick}
        onKeyDown={handleKeyDown}
        className={cn(
          "w-full px-2 py-1 text-xs hover:bg-muted/50 grid grid-cols-[24px_minmax(0,1fr)] gap-2 items-center cursor-pointer",
          isSelected && "bg-muted",
          isActive && "bg-primary/10 border-l-2 border-primary"
        )}
      >
        <FileIconComponent item={item} />
        <span className={cn("truncate", isActive && "font-medium")} title={metadata.name}>
          {metadata.name}
        </span>
      </div>
    );
  }

  return (
    <div
      role="button"
      tabIndex={0}
      onClick={handleClick}
      onKeyDown={handleKeyDown}
      onTouchStart={handleTouchStart}
      onTouchEnd={handleTouchEnd}
      onTouchMove={handleTouchMove}
      draggable={!isEditing}
      onDragStart={handleDragStart}
      onDragEnd={handleDragEnd}
      className={cn(
        "w-full px-4 py-2 text-xs hover:bg-muted/50 grid grid-cols-[24px_24px_minmax(0,1fr)_56px_88px_auto] gap-2 items-center cursor-move",
        isSelected && "bg-muted",
        isActive && "bg-primary/10 border-l-2 border-primary"
      )}
    >
      <div className="w-6 flex items-center justify-center">
        <Checkbox
          checked={isInAnyBatch}
          onCheckedChange={handleCheckboxChange}
          onClick={(e) => e.stopPropagation()}
        />
      </div>
      <FileIconComponent item={item} />
      {isEditing ? (
        <Input
          ref={inputRef}
          value={editName}
          onChange={handleInputChange}
          onKeyDown={handleInputKeyDown}
          onBlur={handleRenameSubmit}
          onClick={(e) => e.stopPropagation()}
          className="h-6 px-1 py-0 text-xs"
        />
      ) : (
        <span 
          className={cn("text-left truncate cursor-pointer hover:text-primary select-none", isActive && "font-medium")}
          onClick={handleNameClick}
          onTouchStart={handleTouchStart}
          onTouchEnd={handleTouchEnd}
          onTouchMove={handleTouchMove}
          title={metadata.name}
        >
          {metadata.name}
        </span>
      )}
      <span className="text-muted-foreground tabular-nums text-[10px]">
        {formatFileSize(metadata.size)}
      </span>
      <span className="text-muted-foreground tabular-nums text-[10px]">
        {formatDate(metadata.modifiedAt)}
      </span>
      <div className="flex items-center justify-start gap-1">
        {jobStatusIcon}
        {/* System-Unterordner (z. B. extrahierte Seiten) */}
        {systemFolderId && (
          <TooltipProvider>
            <Tooltip>
              <TooltipTrigger asChild>
                <Button
                  variant="ghost"
                  size="icon"
                  className="h-6 w-6 p-0 hover:bg-muted"
                  onClick={(e) => {
                    e.stopPropagation();
                    navigateToFolder(systemFolderId);
                  }}
                >
                  <Layers className="h-4 w-4 text-violet-500" />
                </Button>
              </TooltipTrigger>
              <TooltipContent>
                <p>Seiten-Ordner öffnen</p>
              </TooltipContent>
            </Tooltip>
          </TooltipProvider>
        )}
        {/* Zeige Icons für alle vorhandenen Transkripte */}
        {fileGroup?.transcriptFiles && fileGroup.transcriptFiles.length > 0 && fileGroup.transcriptFiles.map((transcript) => (
          <TooltipProvider key={transcript.id}>
            <Tooltip>
              <TooltipTrigger asChild>
                <Button
                  variant="ghost"
                  size="icon"
                  className="h-6 w-6 p-0 hover:bg-muted"
                  onClick={(e) => {
                    e.stopPropagation();
                    if (onSelectRelatedFile) onSelectRelatedFile(transcript);
                  }}
                >
                  <FileText className="h-4 w-4 text-blue-500" />
                </Button>
              </TooltipTrigger>
              <TooltipContent>
                <p>Transkript anzeigen: {transcript.metadata.name}</p>
              </TooltipContent>
            </Tooltip>
          </TooltipProvider>
        ))}
        {/* Plus-Symbol nur anzeigen, wenn kein Transkript vorhanden und transkribierbar */}
        {(!fileGroup?.transcriptFiles || fileGroup.transcriptFiles.length === 0) && isTranscribable && !metadata.hasTranscript ? (
          <TooltipProvider>
            <Tooltip>
              <TooltipTrigger asChild>
                <div 
                  role="button"
                  tabIndex={0}
                  className="h-6 w-6 p-0 inline-flex items-center justify-center hover:bg-muted rounded-sm"
                  onClick={onCreateTranscript}
                  onKeyDown={(e) => {
                    if (e.key === 'Enter' || e.key === ' ') {
                      e.stopPropagation();
                      onCreateTranscript(e as unknown as React.MouseEvent<HTMLDivElement>);
                    }
                  }}
                >
                  <Plus className="h-4 w-4" />
                </div>
              </TooltipTrigger>
              <TooltipContent>
                <p>Transkript erstellen</p>
              </TooltipContent>
            </Tooltip>
          </TooltipProvider>
        ) : null}
        {/* Icon für transformierte Datei */}
        {fileGroup?.transformed && (
          <TooltipProvider>
            <Tooltip>
              <TooltipTrigger asChild>
                <Button
                  variant="ghost"
                  size="icon"
                  className="h-6 w-6 p-0 hover:bg-muted"
                  onClick={handleTransformedClick}
                >
                  <ScrollText className="h-4 w-4 text-green-500" />
                </Button>
              </TooltipTrigger>
              <TooltipContent>
                <p>Transformierte Datei anzeigen</p>
              </TooltipContent>
            </Tooltip>
          </TooltipProvider>
        )}
        {/* Delete direkt neben Dokument-Icons */}
        <TooltipProvider>
          <Tooltip>
            <TooltipTrigger asChild>
              <Button
                variant="ghost"
                size="icon"
                className="h-6 w-6 p-0 hover:bg-destructive/10 hover:text-destructive"
                onClick={(e) => onDelete(e as React.MouseEvent<HTMLButtonElement>, item)}
              >
                <Trash2 className="h-4 w-4" />
              </Button>
            </TooltipTrigger>
            <TooltipContent>
              <p>Datei löschen</p>
            </TooltipContent>
          </Tooltip>
        </TooltipProvider>
      </div>
      <div />
    </div>
  );
});

interface FileListProps {
  compact?: boolean;
}

export const FileList = React.memo(function FileList({ compact = false }: FileListProps): JSX.Element {
  const { provider, refreshItems, currentLibrary } = useStorage();
  const activeLibraryId = useAtomValue(activeLibraryIdAtom);
  const [isRefreshing, setIsRefreshing] = React.useState(false);
  // Mobile-Flag wurde entfernt, FileList lädt unabhängig vom View
  const [selectedBatchItems, setSelectedBatchItems] = useAtom(selectedBatchItemsAtom);
  const [selectedTransformationItems, setSelectedTransformationItems] = useAtom(selectedTransformationItemsAtom);
  const [, setTranscriptionDialogOpen] = useAtom(transcriptionDialogOpenAtom);
  const [, setTransformationDialogOpen] = useAtom(transformationDialogOpenAtom);
  const [isInitialized, setIsInitialized] = React.useState(false);
  const initializationTimeoutRef = React.useRef<NodeJS.Timeout | null>(null);
  // Entkoppelt: Kein Warten mehr auf FileTree-Status
  const [activeFile, setSelectedFile] = useAtom(selectedFileAtom);
  const [, setFolderItems] = useAtom(folderItemsAtom);
  const currentCategoryFilter = useAtomValue(fileCategoryFilterAtom);
  const allItemsInFolder = useAtomValue(folderItemsAtom);
  const navigateToFolder = useFolderNavigation();
  const listContainerRef = React.useRef<HTMLDivElement | null>(null);

  // Kein mobiles Flag mehr notwendig

  const folders = useMemo(() => {
    const items = allItemsInFolder ?? [];
    // Verstecke dot-Verzeichnisse generell in der Liste
    return items.filter(item => item.type === 'folder' && !item.metadata.name.startsWith('.'));
  }, [allItemsInFolder]);

  // Hilfsfunktion zum Finden einer FileGroup in der Map
  const findFileGroup = (map: Map<string, FileGroup>, stem: string): FileGroup | undefined => {
    return Array.from((map ?? new Map()).values()).find(group => 
      group.baseItem && getBaseName(group.baseItem.metadata.name) === stem
    );
  };

  // NEU: Atome für Sortierung und Filter
  const items = useAtomValue(sortedFilteredFilesAtom);
  const [sortField, setSortField] = useAtom(sortFieldAtom);
  const [sortOrder, setSortOrder] = useAtom(sortOrderAtom);
  
  // Review-Mode-Atoms
  const [, setSelectedShadowTwin] = useAtom(selectedShadowTwinAtom);

  // handleSort nutzt jetzt Atome
  const handleSort = React.useCallback((field: SortField) => {
    if (field === sortField) setSortOrder(sortOrder === 'asc' ? 'desc' : 'asc');
    else {
      setSortField(field);
      setSortOrder('asc');
    }
  }, [sortField, sortOrder, setSortField, setSortOrder]);

  // Initialisierung - nur auf Provider und Mobile-Flag achten
  React.useEffect(() => {
    if (!provider) {
      FileLogger.info('FileList', 'Waiting for provider');
      return;
    }

    const initialize = async () => {
      if (isInitialized) {
        FileLogger.debug('FileList', 'Already initialized');
        return;
      }

      FileLogger.info('FileList', 'Starting initialization');

      try {
        FileLogger.info('FileList', 'Initialization complete');
        setIsInitialized(true);
      } catch (error) {
        FileLogger.error('FileList', 'Error initializing FileList', error);
      }
    };

    initialize();

    const timeoutRef = initializationTimeoutRef.current;
    return () => {
      if (timeoutRef) clearTimeout(timeoutRef);
    };
  }, [provider, isInitialized]);

  // NEU: Reagieren auf Bibliothekswechsel
  const prevLibraryIdRef = React.useRef<string | null>(null);
  React.useEffect(() => {
    StateLogger.debug('FileList', 'Render', {
      currentLibraryId: activeLibraryId,
      activeLibraryIdAtom: activeLibraryId
    });

    // Nur bei tatsächlichem Bibliothekswechsel zurücksetzen
    if (prevLibraryIdRef.current !== null && prevLibraryIdRef.current !== activeLibraryId) {
      setIsInitialized(false);
      setSelectedFile(null);
      setFolderItems([]);
      setSelectedBatchItems([]);
      setSelectedTransformationItems([]);
      setSelectedShadowTwin(null);
      StateLogger.info('FileList', 'Bibliothek gewechselt - State zurückgesetzt', {
        libraryId: activeLibraryId
      });
    }
    prevLibraryIdRef.current = activeLibraryId;
  }, [activeLibraryId, setSelectedFile, setFolderItems, setSelectedBatchItems, setSelectedTransformationItems, setSelectedShadowTwin]);

  // Vereinfachte Funktion zum Extrahieren des Basisnamens (ohne Endung, auch für Binärdateien)
  function getBaseName(name: string): string {
    // ShadowTwin: .de.md, .en.md, etc.
    const shadowTwinMatch = name.match(/^(.*)\.(de|en|fr|es|it)\.md$/);
    if (shadowTwinMatch) return shadowTwinMatch[1];
    // Sonst: alles vor der letzten Endung
    const lastDot = name.lastIndexOf('.');
    if (lastDot === -1) return name;
    return name.substring(0, lastDot);
  }

  // Prüft ob eine Datei ein ShadowTwin ist (Markdown mit Sprachkürzel)
  function isShadowTwin(name: string): boolean {
    // Pattern: name.de.md, name.en.md, etc.
    const shadowTwinPattern = /^(.+)\.(de|en|fr|es|it)\.md$/;
    return shadowTwinPattern.test(name);
  }

  // Gruppiere die Dateien nach Basename
  const fileGroups = useMemo(() => {
    if (!items) return new Map<string, FileGroup>();

    // Schritt 1: Gruppiere alle Dateien nach Basename
    const groupsMap = new Map<string, StorageItem[]>();
    for (const item of items) {
      if (item.type !== 'file') continue;
      const base = getBaseName(item.metadata.name);
      if (!groupsMap.has(base)) groupsMap.set(base, []);
      groupsMap.get(base)!.push(item);
    }

    // Schritt 2: Erstelle FileGroups
    const fileGroupsMap = new Map<string, FileGroup>();
    for (const [base, groupItems] of Array.from(groupsMap.entries())) {
      // Finde Hauptdatei (erste Nicht-ShadowTwin-Datei)
      const mainFile = groupItems.find((item) => !isShadowTwin(item.metadata.name));
      // Finde alle ShadowTwins
      const shadowTwins = groupItems.filter((item) => isShadowTwin(item.metadata.name));
      if (mainFile) {
        fileGroupsMap.set(base, {
          baseItem: mainFile,
          transcriptFiles: shadowTwins.length > 0 ? shadowTwins : undefined,
          transformed: undefined
        });
      } else {
        // Keine Hauptdatei: Jede ShadowTwin einzeln anzeigen
        for (const twin of shadowTwins) {
          fileGroupsMap.set(`${base}__shadow_${twin.id}`, {
            baseItem: twin,
            transcriptFiles: undefined,
            transformed: undefined
          });
        }
      }
    }
    // Debug-Logging für Gruppierung
    FileLogger.debug('FileList', 'Gruppierung Ergebnis (Basename, alle Endungen)', {
      groups: Array.from(fileGroupsMap.entries()).map(([base, group]) => ({
        base,
        baseItem: group.baseItem?.metadata.name,
        transcripts: group.transcriptFiles?.map(t => t.metadata.name)
      }))
    });
    return fileGroupsMap;
  }, [items]);

  // Navigationsliste: nur Hauptdateien in der aktuell sichtbaren Reihenfolge
  const mainFileItems = React.useMemo(() => {
    return Array.from((fileGroups ?? new Map()).values())
      .map(g => g.baseItem)
      .filter((it): it is StorageItem => Boolean(it));
  }, [fileGroups]);

  // Hilfsfunktion: Gruppe anhand baseItem.id finden
  const findGroupByBaseItemId = React.useCallback((baseItemId: string) => {
    for (const g of Array.from((fileGroups ?? new Map()).values())) {
      if (g.baseItem && g.baseItem.id === baseItemId) return g;
    }
    return undefined;
  }, [fileGroups]);

  // Keyboard-Navigation: Pfeil hoch/runter wählt vorherige/nächste Datei
  const handleKeyNav = React.useCallback((e: React.KeyboardEvent<HTMLDivElement>) => {
    if (e.key !== 'ArrowDown' && e.key !== 'ArrowUp') return;
    // Eingaben in aktiven Inputs nicht stören
    const ae = document.activeElement as HTMLElement | null;
    if (ae && (ae.tagName === 'INPUT' || ae.tagName === 'TEXTAREA' || ae.isContentEditable)) return;
    if (mainFileItems.length === 0) return;
    e.preventDefault();
    const currentIndex = activeFile ? mainFileItems.findIndex(it => it.id === activeFile.id) : -1;
    const nextIndex = e.key === 'ArrowDown'
      ? Math.min((currentIndex < 0 ? 0 : currentIndex + 1), mainFileItems.length - 1)
      : Math.max((currentIndex < 0 ? 0 : currentIndex - 1), 0);
    const nextItem = mainFileItems[nextIndex];
    if (!nextItem) return;
    const group = findGroupByBaseItemId(nextItem.id);
    handleSelect(nextItem, group);
    // Sichtbar scrollen
    const rowEl = document.getElementById(`file-row-${nextItem.id}`);
    if (rowEl) rowEl.scrollIntoView({ block: 'nearest' });
  }, [activeFile, mainFileItems, handleSelect, findGroupByBaseItemId]);

  const handleContainerMouseDown = React.useCallback((e: React.MouseEvent<HTMLDivElement>) => {
    const target = e.target as HTMLElement;
    if (target && (target.tagName === 'INPUT' || target.tagName === 'TEXTAREA' || target.isContentEditable)) return;
    listContainerRef.current?.focus();
  }, []);

  // Mapping: Basename -> dot-Systemordner (z. B. ".<basename>")
  const systemFolderByBase = useMemo(() => {
    const map = new Map<string, StorageItem>();
    const items = allItemsInFolder ?? [];
    for (const it of items) {
      if (it.type !== 'folder') continue;
      const name = it.metadata.name;
      if (!name.startsWith('.')) continue;
      const base = name.slice(1);
      if (base) map.set(base, it);
    }
    return map;
  }, [allItemsInFolder]);

  // Berechne, ob alle Dateien ausgewählt sind
  const isAllSelected = useMemo(() => {
    if (!fileGroups || !fileGroups.size) return false;
    // Verwende nur die Hauptdateien (baseItem) aus den FileGroups
    const mainItems = Array.from((fileGroups ?? new Map()).values())
      .map(group => group.baseItem)
      .filter((item): item is StorageItem => item !== undefined);
    // Je nach Filter unterschiedliche Dateien zählen
    let selectableItems: StorageItem[] = [];
    switch (currentCategoryFilter) {
      case 'media':
        selectableItems = mainItems.filter(item => {
          try {
            const mediaType = getMediaType(item);
            return item.type === 'file' && (mediaType === 'audio' || mediaType === 'video');
          } catch {
            return false;
          }
        });
        return selectableItems.length > 0 && selectedBatchItems.length === selectableItems.length;
      case 'text':
        selectableItems = mainItems.filter(item => {
          try {
            const mediaType = getMediaType(item);
            return item.type === 'file' && mediaType === 'text';
          } catch {
            return false;
          }
        });
        return selectableItems.length > 0 && selectedTransformationItems.length === selectableItems.length;
      case 'documents':
        selectableItems = mainItems.filter(item => {
          try {
            const mediaType = getMediaType(item);
            return item.type === 'file' && mediaType === 'document';
          } catch {
            return false;
          }
        });
        return selectableItems.length > 0 && selectedTransformationItems.length === selectableItems.length;
      default:
        // Bei 'all' prüfen ob alle verfügbaren Dateien ausgewählt sind
        const mediaItems = mainItems.filter(item => {
          try {
            const mediaType = getMediaType(item);
            return item.type === 'file' && (mediaType === 'audio' || mediaType === 'video');
          } catch {
            return false;
          }
        });
        const textItems = mainItems.filter(item => {
          try {
            const mediaType = getMediaType(item);
            return item.type === 'file' && (mediaType === 'text' || mediaType === 'document');
          } catch {
            return false;
          }
        });
        const allMediaSelected = mediaItems.length === 0 || selectedBatchItems.length === mediaItems.length;
        const allTextSelected = textItems.length === 0 || selectedTransformationItems.length === textItems.length;
        return allMediaSelected && allTextSelected;
    }
  }, [fileGroups, selectedBatchItems, selectedTransformationItems, currentCategoryFilter]);
  
  // Erweiterte handleSelect Funktion für Review-Mode
  const handleSelect = useCallback((item: StorageItem, group?: FileGroup) => {
    FileLogger.debug('FileList', 'handleSelect aufgerufen', {
      itemId: item.id,
      itemName: item.metadata.name,
      groupBase: group?.baseItem?.metadata.name,
      transcriptCount: group?.transcriptFiles?.length ?? 0,
      hasTranscripts: !!(group && group.transcriptFiles && group.transcriptFiles.length > 0)
    });
    
    // Nur die ausgewählte Datei setzen - Review-Modus wird über Toggle-Button gesteuert
    setSelectedFile(item);
    
    // Wenn wir im Review-Modus sind und eine Basis-Datei mit Shadow-Twin ausgewählt wird,
    // dann automatisch das Shadow-Twin setzen
    if (group && group.transcriptFiles && group.transcriptFiles.length > 0) {
      const shadowTwin = group.transcriptFiles[0];
      FileLogger.info('FileList', 'Basis-Datei mit Shadow-Twin ausgewählt', {
        twinId: shadowTwin.id,
        twinName: shadowTwin.metadata.name,
        baseFileId: item.id,
        baseFileName: item.metadata.name
      });
      setSelectedShadowTwin(shadowTwin);
    } else {
      FileLogger.info('FileList', 'Datei ohne Shadow-Twin ausgewählt', {
        itemId: item.id,
        itemName: item.metadata.name,
        groupExists: !!group,
        transcriptCount: group?.transcriptFiles?.length ?? 0
      });
      setSelectedShadowTwin(null);
    }
  }, [setSelectedFile, setSelectedShadowTwin, findFileGroup]);
  
  // Erweiterte handleSelectRelatedFile Funktion für Review-Mode
  const handleSelectRelatedFile = useCallback((shadowTwin: StorageItem) => {
    StateLogger.info('FileList', 'Shadow-Twin ausgewählt', {
      shadowTwinId: shadowTwin.id,
      shadowTwinName: shadowTwin.metadata.name
    });
    
    // Setze das Shadow-Twin als ausgewählte Datei, damit es rechts angezeigt wird
    setSelectedFile(shadowTwin);
    setSelectedShadowTwin(null); // Kein zusätzliches Shadow-Twin im normalen Modus
  }, [setSelectedFile, setSelectedShadowTwin, findFileGroup]);

  // Aktualisierte handleRefresh Funktion
  const handleRefresh = useCallback(async () => {
    if (!items || items.length === 0) return;
    
    const parentId = items[0]?.parentId;
    if (!parentId) return;
    
    setIsRefreshing(true);
    
    try {
      const refreshedItems = await refreshItems(parentId);
      setFolderItems(refreshedItems);
    } catch (error) {
      FileLogger.error('FileList', 'Fehler beim Aktualisieren der Dateiliste', error);
    } finally {
      setIsRefreshing(false);
    }
  }, [items, refreshItems, setFolderItems]);

  const handleCreateTranscript = React.useCallback((e: React.MouseEvent) => {
    e.stopPropagation();
    FileLogger.info('FileList', 'Create transcript for', { fileName: 'TODO' });
    // TODO: Implement transcript creation
  }, []);

  // Entfernt: handleItemSelect war unbenutzt

  // Check if an item is selected (beide Atome prüfen)
  const isItemSelected = useCallback((item: StorageItem) => {
    const mediaType = getMediaType(item);
    if (mediaType === 'audio' || mediaType === 'video') {
      return selectedBatchItems.some(selected => selected.item.id === item.id);
    } else {
      return selectedTransformationItems.some(selected => selected.item.id === item.id);
    }
  }, [selectedBatchItems, selectedTransformationItems]);

  // Löschfunktion
  const handleDeleteClick = React.useCallback(async (e: React.MouseEvent<HTMLButtonElement>, itemToDelete: StorageItem) => {
    e.stopPropagation();
    
    if (!provider) {
      toast.error("Fehler", {
        description: "Storage Provider nicht verfügbar"
      });
      return;
    }

    try {
      // Finde die FileGroup für dieses Item
      const itemStem = getBaseName(itemToDelete.metadata.name);
      const fileGroup = findFileGroup(fileGroups, itemStem);

      // Bestätigungsnachricht vorbereiten
      let confirmMessage = `Möchten Sie "${itemToDelete.metadata.name}" wirklich löschen?`;
      if (fileGroup && itemToDelete.id === fileGroup.baseItem?.id) {
        if (fileGroup.transcriptFiles && fileGroup.transcriptFiles.length > 0 || fileGroup.transformed) {
          confirmMessage = `Möchten Sie "${itemToDelete.metadata.name}" und alle zugehörigen Dateien wirklich löschen?`;
        }
      }

      // Benutzer um Bestätigung bitten
      if (!window.confirm(confirmMessage)) {
        return;
      }

      if (fileGroup && itemToDelete.id === fileGroup.baseItem?.id) {
        // Dies ist die Basis-Datei - lösche auch abhängige Dateien
        // Lösche alle Transkripte, falls vorhanden
        if (fileGroup.transcriptFiles) {
          for (const transcript of fileGroup.transcriptFiles) {
            try {
              await provider.deleteItem(transcript.id);
              FileLogger.info('FileList', 'Transkript gelöscht', {
                transcriptId: transcript.id,
                transcriptName: transcript.metadata.name
              });
            } catch (error) {
              FileLogger.error('FileList', 'Fehler beim Löschen des Transkripts', error);
              toast.warning("Hinweis", {
                description: "Einige Transkripte konnten nicht gelöscht werden"
              });
            }
          }
        }

        // Lösche die transformierte Datei, falls vorhanden
        if (fileGroup.transformed) {
          try {
            await provider.deleteItem(fileGroup.transformed.id);
            FileLogger.info('FileList', 'Transformierte Datei gelöscht', {
              transformedId: fileGroup.transformed.id,
              transformedName: fileGroup.transformed.metadata.name
            });
          } catch (error) {
            FileLogger.error('FileList', 'Fehler beim Löschen der transformierten Datei', error);
            toast.warning("Hinweis", {
              description: "Die transformierte Datei konnte nicht gelöscht werden"
            });
          }
        }

        // Lösche die Basis-Datei
        await provider.deleteItem(itemToDelete.id);
        toast.success("Dateien gelöscht", {
          description: `${itemToDelete.metadata.name} und zugehörige Dateien wurden gelöscht.`
        });
      } else {
        // Dies ist eine abhängige Datei oder keine Gruppe - nur diese Datei löschen
        await provider.deleteItem(itemToDelete.id);
        toast.success("Datei gelöscht", {
          description: `${itemToDelete.metadata.name} wurde gelöscht.`
        });
      }

      // Aktualisiere die Dateiliste
      await handleRefresh();

      // Wenn die gelöschte Datei ausgewählt war, Auswahl aufheben
      setSelectedFile(null);
      
      // Aus der Batch-Auswahl entfernen
      setSelectedBatchItems(prev => prev.filter(i => i.item.id !== itemToDelete.id));

    } catch (error) {
      FileLogger.error('FileList', 'Fehler beim Löschen', error);
      toast.error("Fehler", {
        description: `Die Datei konnte nicht gelöscht werden: ${error instanceof Error ? error.message : 'Unbekannter Fehler'}`
      });
    }
  }, [provider, handleRefresh, fileGroups, setSelectedFile, setSelectedBatchItems]);

  const handleRename = React.useCallback(async (item: StorageItem, newName: string) => {
    if (!provider) {
      toast.error("Fehler", {
        description: "Storage Provider nicht verfügbar"
      });
      return;
    }

    try {
      // Finde die FileGroup für dieses Item
      const itemStem = getBaseName(item.metadata.name);
      const fileGroup = findFileGroup(fileGroups, itemStem);

      if (fileGroup && item.id === fileGroup.baseItem?.id) {
        // Dies ist die Basis-Datei - benenne auch abhängige Dateien um
        const oldStem = getBaseName(item.metadata.name);
        const newStem = getBaseName(newName);
        // Benenne die Basis-Datei um
        await provider.renameItem(item.id, newName);
        // Benenne alle Transkripte um, falls vorhanden
        if (fileGroup.transcriptFiles) {
          for (const transcript of fileGroup.transcriptFiles) {
            const transcriptName = transcript.metadata.name;
            const newTranscriptName = transcriptName.replace(oldStem, newStem);
            try {
              await provider.renameItem(transcript.id, newTranscriptName);
            } catch (error) {
              FileLogger.error('FileList', 'Fehler beim Umbenennen des Transkripts', error);
              toast.warning("Hinweis", {
                description: "Einige Transkripte konnten nicht umbenannt werden"
              });
            }
          }
        }
        // Benenne die transformierte Datei um, falls vorhanden
        if (fileGroup.transformed) {
          const transformedName = fileGroup.transformed.metadata.name;
          const newTransformedName = transformedName.replace(oldStem, newStem);
          try {
            await provider.renameItem(fileGroup.transformed.id, newTransformedName);
          } catch (error) {
            FileLogger.error('FileList', 'Fehler beim Umbenennen der transformierten Datei', error);
            toast.warning("Hinweis", {
              description: "Die transformierte Datei konnte nicht umbenannt werden"
            });
          }
        }
        toast.success("Dateien umbenannt", {
          description: `${item.metadata.name} und zugehörige Dateien wurden umbenannt.`
        });
      } else {
        // Dies ist eine abhängige Datei oder keine Gruppe - nur diese Datei umbenennen
        await provider.renameItem(item.id, newName);
        toast.success("Datei umbenannt", {
          description: `${item.metadata.name} wurde zu ${newName} umbenannt.`
        });
      }
      await handleRefresh();
    } catch (error) {
      FileLogger.error('FileList', 'Fehler beim Umbenennen', error);
      toast.error("Fehler", {
        description: `Die Datei konnte nicht umbenannt werden: ${error instanceof Error ? error.message : 'Unbekannter Fehler'}`
      });
      throw error;
    }
  }, [provider, handleRefresh, fileGroups]);

  const handleBatchTranscription = () => {
    if (selectedBatchItems.length > 0) {
      setTranscriptionDialogOpen(true);
    }
  };

  const handleBatchTransformation = () => {
    if (selectedTransformationItems.length > 0) {
      setTransformationDialogOpen(true);
    }
  };

  // Bulk-Löschung für ausgewählte Dateien (unabhängig von Batch/Transformation-Selektor)
  const handleBulkDelete = React.useCallback(async () => {
    if (!provider) return;
    const targets = [
      ...selectedBatchItems.map(x => x.item),
      ...selectedTransformationItems.map(x => x.item),
    ];
    if (targets.length === 0) return;
    const confirmMsg = targets.length === 1
      ? `"${targets[0].metadata.name}" wirklich löschen?`
      : `${targets.length} Dateien wirklich löschen?`;
    if (!window.confirm(confirmMsg)) return;

    try {
      const parentId = targets[0].parentId || 'root';
      for (const t of targets) {
        try { await provider.deleteItem(t.id); } catch (err) {
          FileLogger.error('FileList', 'Bulk Delete failed', { id: t.id, name: t.metadata.name, err });
        }
      }
      const refreshed = await refreshItems(parentId);
      setFolderItems(refreshed);
      setSelectedBatchItems([]);
      setSelectedTransformationItems([]);
    } catch (error) {
      FileLogger.error('FileList', 'Bulk Delete error', error);
    }
  }, [provider, selectedBatchItems, selectedTransformationItems, refreshItems, setFolderItems, setSelectedBatchItems, setSelectedTransformationItems]);

  // Intelligente Batch-Auswahl basierend auf Filter
  const handleSelectAll = useCallback((checked: boolean) => {
    const startTime = performance.now();
    if (checked) {
      // Verwende nur die Hauptdateien (baseItem) aus den FileGroups
      const mainItems = Array.from((fileGroups ?? new Map()).values())
        .map(group => group.baseItem)
        .filter((item): item is StorageItem => item !== undefined);
      const selectableItems = mainItems.filter(item => {
        try {
          const mediaType = getMediaType(item);
          // Je nach Filter unterschiedliche Dateien auswählen
          switch (currentCategoryFilter) {
            case 'media':
              return item.type === 'file' && (mediaType === 'audio' || mediaType === 'video');
            case 'text':
              return item.type === 'file' && mediaType === 'text';
            case 'documents':
              return item.type === 'file' && mediaType === 'document';
            default:
              // Bei 'all' alle Dateien auswählen, die für eine Operation geeignet sind
              return item.type === 'file' && (
                mediaType === 'audio' || 
                mediaType === 'video' || 
                mediaType === 'text' || 
                mediaType === 'document'
              );
          }
        } catch {
          return false;
        }
      });
      StateLogger.info('FileList', 'Selecting all items based on filter', {
        filter: currentCategoryFilter,
        totalItems: items.length,
        selectableCount: selectableItems.length,
        duration: `${(performance.now() - startTime).toFixed(2)}ms`
      });
      // Je nach Filter unterschiedliche Atome verwenden
      if (currentCategoryFilter === 'media') {
        setSelectedBatchItems(selectableItems.map(item => ({
          item,
          type: getMediaType(item)
        })));
      } else if (currentCategoryFilter === 'text') {
        setSelectedTransformationItems(selectableItems.map(item => ({
          item,
          type: getMediaType(item)
        })));
      } else {
        // Bei 'all' oder 'documents' beide Atome füllen
        const mediaItems = selectableItems.filter(item => {
          const mediaType = getMediaType(item);
          return mediaType === 'audio' || mediaType === 'video';
        });
        const textItems = selectableItems.filter(item => {
          const mediaType = getMediaType(item);
          return mediaType === 'text' || mediaType === 'document';
        });
        setSelectedBatchItems(mediaItems.map(item => ({
          item,
          type: getMediaType(item)
        })));
        setSelectedTransformationItems(textItems.map(item => ({
          item,
          type: getMediaType(item)
        })));
      }
    } else {
      StateLogger.info('FileList', 'Deselecting all items', {
        previouslySelected: selectedBatchItems.length + selectedTransformationItems.length,
        duration: `${(performance.now() - startTime).toFixed(2)}ms`
      });
      setSelectedBatchItems([]);
      setSelectedTransformationItems([]);
    }
  }, [fileGroups, currentCategoryFilter, setSelectedBatchItems, setSelectedTransformationItems, selectedBatchItems.length, selectedTransformationItems.length, items.length]);

  React.useEffect(() => {
    // Logging der Library-IDs - verzögert ausführen
    const timeoutId = setTimeout(() => {
      StateLogger.debug('FileList', 'Render', {
        currentLibraryId: currentLibrary?.id,
        activeLibraryIdAtom: activeLibraryId
      });
    }, 0);
    
    return () => clearTimeout(timeoutId);
  }, [currentLibrary, activeLibraryId]);

  // Entkoppelt: kein Render-Gate mehr basierend auf FileTree

  return (
    <div className="h-full flex flex-col">
      {/* Header - versteckt im compact mode */}
      {!compact && (
        <div className="border-b px-2 py-2 flex items-center justify-between bg-background sticky top-0 z-10">
          <div className="flex items-center gap-2">
            <Button
              variant="ghost"
              size="icon"
              className="h-8 w-8"
              onClick={handleRefresh}
              disabled={isRefreshing}
              title="Aktualisieren"
              aria-label="Aktualisieren"
            >
              <RefreshCw className={cn("h-4 w-4", isRefreshing && "animate-spin")} />
            </Button>

            {/* Dateikategorie-Filter (Icon-only Variante) */}
            <FileCategoryFilter iconOnly />

            {/* Batch-Actions als Icons */}
            {selectedBatchItems.length > 0 && (
              <Button size="icon" title="Transkribieren" aria-label="Transkribieren" onClick={handleBatchTranscription}>
                <ScrollText className="h-4 w-4" />
              </Button>
            )}
            {selectedTransformationItems.length > 0 && (
              <Button size="icon" variant="secondary" title="Transformieren" aria-label="Transformieren" onClick={handleBatchTransformation}>
                <Plus className="h-4 w-4" />
              </Button>
            )}
            {(selectedBatchItems.length + selectedTransformationItems.length) > 0 && (
              <Button size="icon" variant="destructive" title="Ausgewählte löschen" aria-label="Ausgewählte löschen" onClick={handleBulkDelete}>
                <Trash2 className="h-4 w-4" />
              </Button>
            )}
          </div>
        </div>
      )}

      {/* File List */}
      <div ref={listContainerRef} className="flex-1 overflow-auto focus:outline-none" tabIndex={0} onKeyDown={handleKeyNav} onMouseDown={handleContainerMouseDown}>
        <div>
          {/* Table Header - versteckt im compact mode */}
          {!compact && (
            <div className="sticky top-0 bg-background border-b">
              <div className="grid grid-cols-[24px_24px_minmax(0,1fr)_56px_88px_auto] gap-2 px-4 py-2 text-sm font-medium text-muted-foreground">
                <div className="w-6 flex items-center justify-center">
                  <Checkbox
                    checked={isAllSelected}
                    onCheckedChange={handleSelectAll}
                    aria-label="Alle auswählen"
                  />
                </div>
                <div className="w-6" />
                <SortableHeaderCell
                  label="Name"
                  field="name"
                  currentSortField={sortField}
                  currentSortOrder={sortOrder}
                  onSort={handleSort}
                />
                <SortableHeaderCell
                  label="Größe"
                  field="size"
                  currentSortField={sortField}
                  currentSortOrder={sortOrder}
                  onSort={handleSort}
                />
                <SortableHeaderCell
                  label="Geändert"
                  field="date"
                  currentSortField={sortField}
                  currentSortOrder={sortOrder}
                  onSort={handleSort}
                />
                <div />
              </div>
            </div>
          )}

          {/* Folder Rows (oberhalb der Dateien, unabhängig von Datei-Gruppierung) */}
          {folders.length > 0 && (
            <div className="divide-y">
          {folders.map((folder) => (
            compact ? (
              // Kompakt: ohne Einrückung, nur Icon + Name (2 Spalten)
              <div
                key={folder.id}
                role="button"
                tabIndex={0}
                onClick={() => navigateToFolder(folder.id)}
                onKeyDown={(e) => { if (e.key === 'Enter' || e.key === ' ') navigateToFolder(folder.id) }}
                className="w-full px-2 py-1 text-xs hover:bg-muted/50 grid grid-cols-[24px_minmax(0,1fr)] gap-2 items-center cursor-pointer"
              >
                <FolderIcon className="h-4 w-4" />
                <span className="text-left truncate select-none" title={folder.metadata.name}>{folder.metadata.name}</span>
              </div>
            ) : (
              // Normal: behalte leichte Einrückung für Checkbox-Spalte
              <div
                key={folder.id}
                role="button"
                tabIndex={0}
                onClick={() => navigateToFolder(folder.id)}
                onKeyDown={(e) => { if (e.key === 'Enter' || e.key === ' ') navigateToFolder(folder.id) }}
                className="w-full px-4 py-2 text-xs hover:bg-muted/50 grid grid-cols-[24px_24px_minmax(0,1fr)] gap-2 items-center cursor-pointer"
              >
                <div />
                <FolderIcon className="h-4 w-4" />
                <span className="text-left truncate select-none" title={folder.metadata.name}>{folder.metadata.name}</span>
              </div>
            )
          ))}
            </div>
          )}

          {/* File Rows */}
          <div className="divide-y">
            {Array.from((fileGroups ?? new Map()).values())
              .map((group) => {
                // Zeige nur die Hauptdatei (baseItem) an
                const item = group.baseItem;
                if (!item) return null;
                // System-Unterordner-Id, wenn ein ".<basename>"-Folder existiert
                const systemFolder = systemFolderByBase.get(getBaseName(item.metadata.name));
                const systemFolderId = systemFolder?.id;
                const isActive = !!activeFile && activeFile.id === item.id
                return (
                  <FileRow
                    key={item.id}
                    item={item as StorageItem}
                    isSelected={isItemSelected(item)}
                    isActive={isActive}
                    onSelect={() => handleSelect(item, group)}
                    onCreateTranscript={handleCreateTranscript}
                    onDelete={(e) => handleDeleteClick(e, item)}
                    fileGroup={group}
                    onSelectRelatedFile={handleSelectRelatedFile}
                    onRename={handleRename}
                    compact={compact}
                    systemFolderId={systemFolderId}
                  />
                );
              })}
          </div>
        </div>
      </div>
    </div>
  );
}); 
```

```typescriptreact
'use client';

import * as React from "react"
import { File, FileText, FileVideo, FileAudio, Plus, RefreshCw, ChevronUp, ChevronDown, Trash2, ScrollText, Folder as FolderIcon, Layers } from "lucide-react"
import { StorageItem } from "@/lib/storage/types"
import { cn } from "@/lib/utils"
import { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from "@/components/ui/tooltip"
import { useStorage } from "@/contexts/storage-context";
import { Button } from "@/components/ui/button";
import { useAtomValue, useAtom } from 'jotai';
import { jobStatusByItemIdAtom } from '@/atoms/job-status';
import { 
  activeLibraryIdAtom, 
  selectedFileAtom, 
  folderItemsAtom,
  sortedFilteredFilesAtom,
  sortFieldAtom,
  sortOrderAtom,
  selectedShadowTwinAtom
} from '@/atoms/library-atom';
import { toast } from "sonner";
import { Input } from "@/components/ui/input"
import {
  selectedBatchItemsAtom,
  transcriptionDialogOpenAtom,
  selectedTransformationItemsAtom,
  transformationDialogOpenAtom,
  getMediaType,
  fileCategoryFilterAtom,
} from '@/atoms/transcription-options';
import { Checkbox } from "@/components/ui/checkbox"
import { useMemo, useCallback } from "react"
import { FileLogger, StateLogger } from "@/lib/debug/logger"
import { FileCategoryFilter } from './file-category-filter';
import { useFolderNavigation } from "@/hooks/use-folder-navigation";

// Typen für Sortieroptionen
type SortField = 'type' | 'name' | 'size' | 'date';
type SortOrder = 'asc' | 'desc';

// Typ für gruppierte Dateien
interface FileGroup {
  baseItem?: StorageItem;
  transcriptFiles?: StorageItem[]; // NEU: alle Transkripte
  transformed?: StorageItem;
}

// Memoized file icon component
const FileIconComponent = React.memo(function FileIconComponent({ item }: { item: StorageItem }) {
  const mimeType = item.metadata.mimeType || '';
  if (!mimeType) return <File className="h-4 w-4" />;

  if (mimeType.startsWith('video/')) {
    return <FileVideo className="h-4 w-4" />;
  } else if (mimeType.startsWith('audio/')) {
    return <FileAudio className="h-4 w-4" />;
  } else if (mimeType.startsWith('text/')) {
    return <FileText className="h-4 w-4" />;
  }

  return <File className="h-4 w-4" />;
});

// Pure function for file size formatting
const formatFileSize = (size?: number): string => {
  if (!size) return '-';
  const units = ['B', 'KB', 'MB', 'GB'];
  let value = size;
  let unitIndex = 0;
  
  while (value >= 1024 && unitIndex < units.length - 1) {
    value /= 1024;
    unitIndex++;
  }
  
  return `${value.toFixed(1)} ${units[unitIndex]}`;
};

// Funktion zum Formatieren des Datums
const formatDate = (date?: Date): string => {
  if (!date) return '-';
  
  const options: Intl.DateTimeFormatOptions = { 
    year: '2-digit', 
    month: '2-digit', 
    day: '2-digit',
    hour: '2-digit',
    minute: '2-digit'
  };
  
  return new Date(date).toLocaleDateString('de-DE', options);
};

// Entfernt: getFileStem Funktion war unbenutzt

// Sortierbare Kopfzelle Komponente
const SortableHeaderCell = React.memo(function SortableHeaderCell({
  label,
  field,
  currentSortField,
  currentSortOrder,
  onSort
}: {
  label: string,
  field: SortField,
  currentSortField: SortField,
  currentSortOrder: SortOrder,
  onSort: (field: SortField) => void
}) {
  const isActive = currentSortField === field;
  
  return (
    <button 
      onClick={() => onSort(field)}
      className="flex items-center gap-1 hover:text-foreground"
    >
      <span>{label}</span>
      {isActive && (
        currentSortOrder === 'asc' 
          ? <ChevronUp className="h-3 w-3" /> 
          : <ChevronDown className="h-3 w-3" />
      )}
    </button>
  );
});

interface FileRowProps {
  item: StorageItem;
  isSelected: boolean;
  isActive?: boolean;
  onSelect: () => void;
  onCreateTranscript: (e: React.MouseEvent) => void;
  onDelete: (e: React.MouseEvent<HTMLButtonElement>, item: StorageItem) => void;
  fileGroup?: FileGroup;
  onSelectRelatedFile?: (file: StorageItem) => void;
  onRename?: (item: StorageItem, newName: string) => Promise<void>;
  compact?: boolean;
  systemFolderId?: string;
}

const FileRow = React.memo(function FileRow({ 
  item, 
  isSelected, 
  isActive = false,
  onSelect,
  onCreateTranscript,
  onDelete,
  fileGroup,
  onSelectRelatedFile,
  onRename,
  compact = false,
  systemFolderId
}: FileRowProps) {
  const navigateToFolder = useFolderNavigation();
  const [isEditing, setIsEditing] = React.useState(false);
  const [editName, setEditName] = React.useState(item.metadata.name);
  const inputRef = React.useRef<HTMLInputElement>(null);
  const longPressTimerRef = React.useRef<NodeJS.Timeout | null>(null);
  const lastClickTimeRef = React.useRef<number>(0);
  
  // Zusätzliche Validierung der Metadaten
  const metadata = React.useMemo(() => ({
    name: item.metadata?.name || 'Unbekannte Datei',
    size: typeof item.metadata?.size === 'number' ? item.metadata.size : 0,
    mimeType: item.metadata?.mimeType || '',
    hasTranscript: !!item.metadata?.hasTranscript || (fileGroup?.transcriptFiles && fileGroup.transcriptFiles.length > 0),
    modifiedAt: item.metadata?.modifiedAt
  }), [item.metadata, fileGroup]);

  const isTranscribable = React.useMemo(() => {
    const mimeType = metadata.mimeType.toLowerCase();
    const extension = metadata.name.split('.').pop()?.toLowerCase();

    return (
      mimeType.startsWith('audio/') ||
      mimeType.startsWith('video/') ||
      extension === 'pdf' ||
      mimeType === 'application/pdf'
    );
  }, [metadata.mimeType, metadata.name]);

  // Memoize the click handler
  const handleClick = React.useCallback(() => {
    if (!isEditing) {
      onSelect();
    }
  }, [onSelect, isEditing]);

  // Memoize the keydown handler
  const handleKeyDown = React.useCallback((e: React.KeyboardEvent) => {
    if (!isEditing && (e.key === 'Enter' || e.key === ' ')) {
      onSelect();
    }
  }, [onSelect, isEditing]);

  // Handler für Transkript-Icon Click
  const handleTranscriptClick = React.useCallback((e: React.MouseEvent) => {
    e.stopPropagation();
    if (fileGroup?.transcriptFiles && onSelectRelatedFile) {
      onSelectRelatedFile(fileGroup.transcriptFiles[0]); // Nur das erste Transkript anzeigen
    }
  }, [fileGroup, onSelectRelatedFile]);

  // Handler für Transformierte-Datei-Icon Click
  const handleTransformedClick = React.useCallback((e: React.MouseEvent) => {
    e.stopPropagation();
    if (fileGroup?.transformed && onSelectRelatedFile) {
      onSelectRelatedFile(fileGroup.transformed);
    }
  }, [fileGroup, onSelectRelatedFile]);

  // Starte Rename-Modus
  const startRename = React.useCallback(() => {
    if (onRename) {
      // Prüfe ob dies eine abhängige Datei ist
      if (fileGroup && (
        (fileGroup.transcriptFiles && fileGroup.transcriptFiles.length > 0 && fileGroup.transcriptFiles[0]?.id === item.id) ||
        (fileGroup.transformed && item.id === fileGroup.transformed.id)
      )) {
        // Dies ist eine abhängige Datei - zeige Hinweis
        toast.info("Hinweis", {
          description: "Bitte benennen Sie die Haupt-Datei um. Abhängige Dateien werden automatisch mit umbenannt."
        });
        return;
      }
      
      setIsEditing(true);
      setEditName(item.metadata.name);
    }
  }, [onRename, item, fileGroup]);

  // Handler für Dateinamen-Click (Doppelklick-Erkennung)
  const handleNameClick = React.useCallback((e: React.MouseEvent) => {
    e.stopPropagation();
    
    const currentTime = Date.now();
    const timeSinceLastClick = currentTime - lastClickTimeRef.current;
    
    if (timeSinceLastClick < 300) {
      // Doppelklick erkannt
      startRename();
    } else {
      // Erster Klick - wähle die Datei aus
      onSelect();
    }
    
    lastClickTimeRef.current = currentTime;
  }, [startRename, onSelect]);

  // Handler für Long-Press (Touch-Geräte)
  const handleTouchStart = React.useCallback((e: React.TouchEvent) => {
    e.stopPropagation();
    
    // Starte Long-Press Timer
    longPressTimerRef.current = setTimeout(() => {
      startRename();
    }, 500); // 500ms für Long-Press
  }, [startRename]);

  const handleTouchEnd = React.useCallback((e: React.TouchEvent) => {
    e.stopPropagation();
    
    // Lösche Long-Press Timer
    if (longPressTimerRef.current) {
      clearTimeout(longPressTimerRef.current);
      longPressTimerRef.current = null;
    }
  }, []);

  const handleTouchMove = React.useCallback(() => {
    // Bei Bewegung Long-Press abbrechen
    if (longPressTimerRef.current) {
      clearTimeout(longPressTimerRef.current);
      longPressTimerRef.current = null;
    }
  }, []);

  // Cleanup Timer bei Unmount
  React.useEffect(() => {
    return () => {
      if (longPressTimerRef.current) {
        clearTimeout(longPressTimerRef.current);
      }
    };
  }, []);

  // Handler für Rename-Submit
  const handleRenameSubmit = React.useCallback(async () => {
    if (onRename && editName.trim() && editName !== item.metadata.name) {
      try {
        await onRename(item, editName.trim());
      } catch (error) {
        FileLogger.error('FileRow', 'Fehler beim Umbenennen', error);
        // Bei Fehler den ursprünglichen Namen wiederherstellen
        setEditName(item.metadata.name);
      }
    }
    setIsEditing(false);
  }, [onRename, editName, item]);

  // Handler für Rename-Cancel
  const handleRenameCancel = React.useCallback(() => {
    setEditName(item.metadata.name);
    setIsEditing(false);
  }, [item.metadata.name]);

  // Handler für Input-Änderungen
  const handleInputChange = React.useCallback((e: React.ChangeEvent<HTMLInputElement>) => {
    setEditName(e.target.value);
  }, []);

  // Handler für Input-Keydown
  const handleInputKeyDown = React.useCallback((e: React.KeyboardEvent<HTMLInputElement>) => {
    e.stopPropagation();
    if (e.key === 'Enter') {
      handleRenameSubmit();
    } else if (e.key === 'Escape') {
      handleRenameCancel();
    }
  }, [handleRenameSubmit, handleRenameCancel]);

  // Focus Input wenn Edit-Modus aktiviert wird
  React.useEffect(() => {
    if (isEditing && inputRef.current) {
      inputRef.current.focus();
      inputRef.current.select();
    }
  }, [isEditing]);

  // Handler für Drag Start
  const handleDragStart = React.useCallback((e: React.DragEvent) => {
    // Sammle alle Dateien der Gruppe, die verschoben werden sollen
    const itemsToMove = [];
    
    // Füge das aktuelle Item hinzu
    itemsToMove.push({
      itemId: item.id,
      itemName: item.metadata.name,
      itemType: item.type,
      parentId: item.parentId
    });
    
    // Wenn es eine FileGroup gibt, füge auch die zugehörigen Dateien hinzu
    if (fileGroup) {
      // Prüfe ob das aktuelle Item die Basis-Datei ist
      if (item.id === fileGroup.baseItem?.id) {
        // Füge Transkripte hinzu, falls vorhanden
        if (fileGroup.transcriptFiles && fileGroup.transcriptFiles.length > 0) {
          fileGroup.transcriptFiles.forEach(transcript => {
            itemsToMove.push({
              itemId: transcript.id,
              itemName: transcript.metadata.name,
              itemType: transcript.type,
              parentId: transcript.parentId
            });
          });
        }
        
        // Füge transformierte Datei hinzu, falls vorhanden
        if (fileGroup.transformed) {
          itemsToMove.push({
            itemId: fileGroup.transformed.id,
            itemName: fileGroup.transformed.metadata.name,
            itemType: fileGroup.transformed.type,
            parentId: fileGroup.transformed.parentId
          });
        }
      }
    }
    
    // Setze die Drag-Daten
    e.dataTransfer.effectAllowed = 'move';
    e.dataTransfer.setData('application/json', JSON.stringify({
      items: itemsToMove,
      isFileGroup: itemsToMove.length > 1
    }));
    
    // Visuelles Feedback
    if (e.currentTarget instanceof HTMLElement) {
      e.currentTarget.style.opacity = '0.5';
    }
  }, [item, fileGroup]);

  // Handler für Drag End
  const handleDragEnd = React.useCallback((e: React.DragEvent) => {
    // Stelle Opacity wieder her
    if (e.currentTarget instanceof HTMLElement) {
      e.currentTarget.style.opacity = '1';
    }
  }, []);

  const [selectedBatchItems, setSelectedBatchItems] = useAtom(selectedBatchItemsAtom);
  const [selectedTransformationItems, setSelectedTransformationItems] = useAtom(selectedTransformationItemsAtom);
  
  // Prüfe ob das Item in einem der beiden Atome ausgewählt ist
  const isInBatch = selectedBatchItems.some(batchItem => batchItem.item.id === item.id);
  const isInTransformation = selectedTransformationItems.some(transformationItem => transformationItem.item.id === item.id);
  const isInAnyBatch = isInBatch || isInTransformation;

  // Handler für Checkbox-Änderungen
  const handleCheckboxChange = React.useCallback((checked: boolean) => {
    const mediaType = getMediaType(item);
    
    if (mediaType === 'audio' || mediaType === 'video') {
      // Für Audio/Video: Transcription-Atom verwenden
      if (checked) {
        setSelectedBatchItems([...selectedBatchItems, {
          item,
          type: mediaType
        }]);
      } else {
        setSelectedBatchItems(selectedBatchItems.filter(i => i.item.id !== item.id));
      }
    } else if (mediaType === 'text' || mediaType === 'document') {
      // Für Text/Dokumente: Transformation-Atom verwenden
      if (checked) {
        setSelectedTransformationItems([...selectedTransformationItems, {
          item,
          type: mediaType
        }]);
      } else {
        setSelectedTransformationItems(selectedTransformationItems.filter(i => i.item.id !== item.id));
      }
    }
  }, [item, selectedBatchItems, selectedTransformationItems, setSelectedBatchItems, setSelectedTransformationItems]);

  React.useEffect(() => {
    if (fileGroup) {
      FileLogger.debug('FileRow', 'Transkripte für Zeile', {
        baseItem: fileGroup.baseItem?.metadata.name,
        transcripts: fileGroup.transcriptFiles?.map(t => t.metadata.name)
      });
    }
  }, [fileGroup]);

  // Zentraler Jobstatus (muss vor möglichen early-returns stehen, um Hook-Order zu garantieren)
  const jobStatusMap = useAtomValue(jobStatusByItemIdAtom);
  const jobStatus = jobStatusMap[item.id];
  const jobStatusIcon = jobStatus ? (
    <span title={jobStatus} className={cn('inline-block h-3 w-3 rounded-full',
      jobStatus === 'queued' && 'bg-blue-600',
      jobStatus === 'running' && 'bg-yellow-600',
      jobStatus === 'completed' && 'bg-green-600',
      jobStatus === 'failed' && 'bg-red-600'
    )} aria-label={`job-${jobStatus}`} />
  ) : null;

  // Compact-Modus: vereinfachte Darstellung
  if (compact) {
    return (
      <div
        id={`file-row-${item.id}`}
        role="button"
        tabIndex={0}
        onClick={handleClick}
        onKeyDown={handleKeyDown}
        className={cn(
          "w-full px-2 py-1 text-xs hover:bg-muted/50 grid grid-cols-[24px_minmax(0,1fr)] gap-2 items-center cursor-pointer",
          isSelected && "bg-muted",
          isActive && "bg-primary/10 border-l-2 border-primary"
        )}
      >
        <FileIconComponent item={item} />
        <span className={cn("truncate", isActive && "font-medium")} title={metadata.name}>
          {metadata.name}
        </span>
      </div>
    );
  }

  return (
    <div
      id={`file-row-${item.id}`}
      role="button"
      tabIndex={0}
      onClick={handleClick}
      onKeyDown={handleKeyDown}
      onTouchStart={handleTouchStart}
      onTouchEnd={handleTouchEnd}
      onTouchMove={handleTouchMove}
      draggable={!isEditing}
      onDragStart={handleDragStart}
      onDragEnd={handleDragEnd}
      className={cn(
        "w-full px-4 py-2 text-xs hover:bg-muted/50 grid grid-cols-[24px_24px_minmax(0,1fr)_56px_88px_auto] gap-2 items-center cursor-move",
        isSelected && "bg-muted",
        isActive && "bg-primary/10 border-l-2 border-primary"
      )}
    >
      <div className="w-6 flex items-center justify-center">
        <Checkbox
          checked={isInAnyBatch}
          onCheckedChange={handleCheckboxChange}
          onClick={(e) => e.stopPropagation()}
        />
      </div>
      <FileIconComponent item={item} />
      {isEditing ? (
        <Input
          ref={inputRef}
          value={editName}
          onChange={handleInputChange}
          onKeyDown={handleInputKeyDown}
          onBlur={handleRenameSubmit}
          onClick={(e) => e.stopPropagation()}
          className="h-6 px-1 py-0 text-xs"
        />
      ) : (
        <span 
          className={cn("text-left truncate cursor-pointer hover:text-primary select-none", isActive && "font-medium")}
          onClick={handleNameClick}
          onTouchStart={handleTouchStart}
          onTouchEnd={handleTouchEnd}
          onTouchMove={handleTouchMove}
          title={metadata.name}
        >
          {metadata.name}
        </span>
      )}
      <span className="text-muted-foreground tabular-nums text-[10px]">
        {formatFileSize(metadata.size)}
      </span>
      <span className="text-muted-foreground tabular-nums text-[10px]">
        {formatDate(metadata.modifiedAt)}
      </span>
      <div className="flex items-center justify-start gap-1">
        {jobStatusIcon}
        {/* System-Unterordner (z. B. extrahierte Seiten) */}
        {systemFolderId && (
          <TooltipProvider>
            <Tooltip>
              <TooltipTrigger asChild>
                <Button
                  variant="ghost"
                  size="icon"
                  className="h-6 w-6 p-0 hover:bg-muted"
                  onClick={(e) => {
                    e.stopPropagation();
                    navigateToFolder(systemFolderId);
                  }}
                >
                  <Layers className="h-4 w-4 text-violet-500" />
                </Button>
              </TooltipTrigger>
              <TooltipContent>
                <p>Seiten-Ordner öffnen</p>
              </TooltipContent>
            </Tooltip>
          </TooltipProvider>
        )}
        {/* Zeige Icons für alle vorhandenen Transkripte */}
        {fileGroup?.transcriptFiles && fileGroup.transcriptFiles.length > 0 && fileGroup.transcriptFiles.map((transcript) => (
          <TooltipProvider key={transcript.id}>
            <Tooltip>
              <TooltipTrigger asChild>
                <Button
                  variant="ghost"
                  size="icon"
                  className="h-6 w-6 p-0 hover:bg-muted"
                  onClick={(e) => {
                    e.stopPropagation();
                    if (onSelectRelatedFile) onSelectRelatedFile(transcript);
                  }}
                >
                  <FileText className="h-4 w-4 text-blue-500" />
                </Button>
              </TooltipTrigger>
              <TooltipContent>
                <p>Transkript anzeigen: {transcript.metadata.name}</p>
              </TooltipContent>
            </Tooltip>
          </TooltipProvider>
        ))}
        {/* Plus-Symbol nur anzeigen, wenn kein Transkript vorhanden und transkribierbar */}
        {(!fileGroup?.transcriptFiles || fileGroup.transcriptFiles.length === 0) && isTranscribable && !metadata.hasTranscript ? (
          <TooltipProvider>
            <Tooltip>
              <TooltipTrigger asChild>
                <div 
                  role="button"
                  tabIndex={0}
                  className="h-6 w-6 p-0 inline-flex items-center justify-center hover:bg-muted rounded-sm"
                  onClick={onCreateTranscript}
                  onKeyDown={(e) => {
                    if (e.key === 'Enter' || e.key === ' ') {
                      e.stopPropagation();
                      onCreateTranscript(e as unknown as React.MouseEvent<HTMLDivElement>);
                    }
                  }}
                >
                  <Plus className="h-4 w-4" />
                </div>
              </TooltipTrigger>
              <TooltipContent>
                <p>Transkript erstellen</p>
              </TooltipContent>
            </Tooltip>
          </TooltipProvider>
        ) : null}
        {/* Icon für transformierte Datei */}
        {fileGroup?.transformed && (
          <TooltipProvider>
            <Tooltip>
              <TooltipTrigger asChild>
                <Button
                  variant="ghost"
                  size="icon"
                  className="h-6 w-6 p-0 hover:bg-muted"
                  onClick={handleTransformedClick}
                >
                  <ScrollText className="h-4 w-4 text-green-500" />
                </Button>
              </TooltipTrigger>
              <TooltipContent>
                <p>Transformierte Datei anzeigen</p>
              </TooltipContent>
            </Tooltip>
          </TooltipProvider>
        )}
        {/* Delete direkt neben Dokument-Icons */}
        <TooltipProvider>
          <Tooltip>
            <TooltipTrigger asChild>
              <Button
                variant="ghost"
                size="icon"
                className="h-6 w-6 p-0 hover:bg-destructive/10 hover:text-destructive"
                onClick={(e) => onDelete(e as React.MouseEvent<HTMLButtonElement>, item)}
              >
                <Trash2 className="h-4 w-4" />
              </Button>
            </TooltipTrigger>
            <TooltipContent>
              <p>Datei löschen</p>
            </TooltipContent>
          </Tooltip>
        </TooltipProvider>
      </div>
      <div />
    </div>
  );
});

interface FileListProps {
  compact?: boolean;
}

export const FileList = React.memo(function FileList({ compact = false }: FileListProps): JSX.Element {
  const { provider, refreshItems, currentLibrary } = useStorage();
  const activeLibraryId = useAtomValue(activeLibraryIdAtom);
  const [isRefreshing, setIsRefreshing] = React.useState(false);
  // Mobile-Flag wurde entfernt, FileList lädt unabhängig vom View
  const [selectedBatchItems, setSelectedBatchItems] = useAtom(selectedBatchItemsAtom);
  const [selectedTransformationItems, setSelectedTransformationItems] = useAtom(selectedTransformationItemsAtom);
  const [, setTranscriptionDialogOpen] = useAtom(transcriptionDialogOpenAtom);
  const [, setTransformationDialogOpen] = useAtom(transformationDialogOpenAtom);
  const [isInitialized, setIsInitialized] = React.useState(false);
  const initializationTimeoutRef = React.useRef<NodeJS.Timeout | null>(null);
  // Entkoppelt: Kein Warten mehr auf FileTree-Status
  const [activeFile, setSelectedFile] = useAtom(selectedFileAtom);
  const [, setFolderItems] = useAtom(folderItemsAtom);
  const currentCategoryFilter = useAtomValue(fileCategoryFilterAtom);
  const allItemsInFolder = useAtomValue(folderItemsAtom);
  const navigateToFolder = useFolderNavigation();
  const listContainerRef = React.useRef<HTMLDivElement | null>(null);

  // Kein mobiles Flag mehr notwendig

  const folders = useMemo(() => {
    const items = allItemsInFolder ?? [];
    // Verstecke dot-Verzeichnisse generell in der Liste
    return items.filter(item => item.type === 'folder' && !item.metadata.name.startsWith('.'));
  }, [allItemsInFolder]);

  // Hilfsfunktion zum Finden einer FileGroup in der Map
  const findFileGroup = (map: Map<string, FileGroup>, stem: string): FileGroup | undefined => {
    return Array.from((map ?? new Map()).values()).find(group => 
      group.baseItem && getBaseName(group.baseItem.metadata.name) === stem
    );
  };

  // NEU: Atome für Sortierung und Filter
  const items = useAtomValue(sortedFilteredFilesAtom);
  const [sortField, setSortField] = useAtom(sortFieldAtom);
  const [sortOrder, setSortOrder] = useAtom(sortOrderAtom);
  
  // Review-Mode-Atoms
  const [, setSelectedShadowTwin] = useAtom(selectedShadowTwinAtom);

  // handleSort nutzt jetzt Atome
  const handleSort = React.useCallback((field: SortField) => {
    if (field === sortField) setSortOrder(sortOrder === 'asc' ? 'desc' : 'asc');
    else {
      setSortField(field);
      setSortOrder('asc');
    }
  }, [sortField, sortOrder, setSortField, setSortOrder]);

  // Initialisierung - nur auf Provider und Mobile-Flag achten
  React.useEffect(() => {
    if (!provider) {
      FileLogger.info('FileList', 'Waiting for provider');
      return;
    }

    const initialize = async () => {
      if (isInitialized) {
        FileLogger.debug('FileList', 'Already initialized');
        return;
      }

      FileLogger.info('FileList', 'Starting initialization');

      try {
        FileLogger.info('FileList', 'Initialization complete');
        setIsInitialized(true);
      } catch (error) {
        FileLogger.error('FileList', 'Error initializing FileList', error);
      }
    };

    initialize();

    const timeoutRef = initializationTimeoutRef.current;
    return () => {
      if (timeoutRef) clearTimeout(timeoutRef);
    };
  }, [provider, isInitialized]);

  // NEU: Reagieren auf Bibliothekswechsel
  const prevLibraryIdRef = React.useRef<string | null>(null);
  React.useEffect(() => {
    StateLogger.debug('FileList', 'Render', {
      currentLibraryId: activeLibraryId,
      activeLibraryIdAtom: activeLibraryId
    });

    // Nur bei tatsächlichem Bibliothekswechsel zurücksetzen
    if (prevLibraryIdRef.current !== null && prevLibraryIdRef.current !== activeLibraryId) {
      setIsInitialized(false);
      setSelectedFile(null);
      setFolderItems([]);
      setSelectedBatchItems([]);
      setSelectedTransformationItems([]);
      setSelectedShadowTwin(null);
      StateLogger.info('FileList', 'Bibliothek gewechselt - State zurückgesetzt', {
        libraryId: activeLibraryId
      });
    }
    prevLibraryIdRef.current = activeLibraryId;
  }, [activeLibraryId, setSelectedFile, setFolderItems, setSelectedBatchItems, setSelectedTransformationItems, setSelectedShadowTwin]);

  // Vereinfachte Funktion zum Extrahieren des Basisnamens (ohne Endung, auch für Binärdateien)
  function getBaseName(name: string): string {
    // ShadowTwin: .de.md, .en.md, etc.
    const shadowTwinMatch = name.match(/^(.*)\.(de|en|fr|es|it)\.md$/);
    if (shadowTwinMatch) return shadowTwinMatch[1];
    // Sonst: alles vor der letzten Endung
    const lastDot = name.lastIndexOf('.');
    if (lastDot === -1) return name;
    return name.substring(0, lastDot);
  }

  // Prüft ob eine Datei ein ShadowTwin ist (Markdown mit Sprachkürzel)
  function isShadowTwin(name: string): boolean {
    // Pattern: name.de.md, name.en.md, etc.
    const shadowTwinPattern = /^(.+)\.(de|en|fr|es|it)\.md$/;
    return shadowTwinPattern.test(name);
  }

  // Gruppiere die Dateien nach Basename
  const fileGroups = useMemo(() => {
    if (!items) return new Map<string, FileGroup>();

    // Schritt 1: Gruppiere alle Dateien nach Basename
    const groupsMap = new Map<string, StorageItem[]>();
    for (const item of items) {
      if (item.type !== 'file') continue;
      const base = getBaseName(item.metadata.name);
      if (!groupsMap.has(base)) groupsMap.set(base, []);
      groupsMap.get(base)!.push(item);
    }

    // Schritt 2: Erstelle FileGroups
    const fileGroupsMap = new Map<string, FileGroup>();
    for (const [base, groupItems] of Array.from(groupsMap.entries())) {
      // Finde Hauptdatei (erste Nicht-ShadowTwin-Datei)
      const mainFile = groupItems.find((item) => !isShadowTwin(item.metadata.name));
      // Finde alle ShadowTwins
      const shadowTwins = groupItems.filter((item) => isShadowTwin(item.metadata.name));
      if (mainFile) {
        fileGroupsMap.set(base, {
          baseItem: mainFile,
          transcriptFiles: shadowTwins.length > 0 ? shadowTwins : undefined,
          transformed: undefined
        });
      } else {
        // Keine Hauptdatei: Jede ShadowTwin einzeln anzeigen
        for (const twin of shadowTwins) {
          fileGroupsMap.set(`${base}__shadow_${twin.id}`, {
            baseItem: twin,
            transcriptFiles: undefined,
            transformed: undefined
          });
        }
      }
    }
    // Debug-Logging für Gruppierung
    FileLogger.debug('FileList', 'Gruppierung Ergebnis (Basename, alle Endungen)', {
      groups: Array.from(fileGroupsMap.entries()).map(([base, group]) => ({
        base,
        baseItem: group.baseItem?.metadata.name,
        transcripts: group.transcriptFiles?.map(t => t.metadata.name)
      }))
    });
    return fileGroupsMap;
  }, [items]);

  // Navigationsliste: nur Hauptdateien in der aktuell sichtbaren Reihenfolge
  const mainFileItems = React.useMemo(() => {
    return Array.from((fileGroups ?? new Map()).values())
      .map(g => g.baseItem)
      .filter((it): it is StorageItem => Boolean(it));
  }, [fileGroups]);

  // Hilfsfunktion: Gruppe anhand baseItem.id finden
  const findGroupByBaseItemId = React.useCallback((baseItemId: string) => {
    for (const g of Array.from((fileGroups ?? new Map()).values())) {
      if (g.baseItem && g.baseItem.id === baseItemId) return g;
    }
    return undefined;
  }, [fileGroups]);

  // Keyboard-Navigation: Pfeil hoch/runter wählt vorherige/nächste Datei
  const handleKeyNav = React.useCallback((e: React.KeyboardEvent<HTMLDivElement>) => {
    if (e.key !== 'ArrowDown' && e.key !== 'ArrowUp') return;
    // Eingaben in aktiven Inputs nicht stören
    const ae = document.activeElement as HTMLElement | null;
    if (ae && (ae.tagName === 'INPUT' || ae.tagName === 'TEXTAREA' || ae.isContentEditable)) return;
    if (mainFileItems.length === 0) return;
    e.preventDefault();
    const currentIndex = activeFile ? mainFileItems.findIndex(it => it.id === activeFile.id) : -1;
    const nextIndex = e.key === 'ArrowDown'
      ? Math.min((currentIndex < 0 ? 0 : currentIndex + 1), mainFileItems.length - 1)
      : Math.max((currentIndex < 0 ? 0 : currentIndex - 1), 0);
    const nextItem = mainFileItems[nextIndex];
    if (!nextItem) return;
    const group = findGroupByBaseItemId(nextItem.id);
    handleSelect(nextItem, group);
    // Sichtbar scrollen
    const rowEl = document.getElementById(`file-row-${nextItem.id}`);
    if (rowEl) rowEl.scrollIntoView({ block: 'nearest' });
  }, [activeFile, mainFileItems, handleSelect, findGroupByBaseItemId]);

  const handleContainerMouseDown = React.useCallback((e: React.MouseEvent<HTMLDivElement>) => {
    const target = e.target as HTMLElement;
    if (target && (target.tagName === 'INPUT' || target.tagName === 'TEXTAREA' || target.isContentEditable)) return;
    listContainerRef.current?.focus();
  }, []);

  // Mapping: Basename -> dot-Systemordner (z. B. ".<basename>")
  const systemFolderByBase = useMemo(() => {
    const map = new Map<string, StorageItem>();
    const items = allItemsInFolder ?? [];
    for (const it of items) {
      if (it.type !== 'folder') continue;
      const name = it.metadata.name;
      if (!name.startsWith('.')) continue;
      const base = name.slice(1);
      if (base) map.set(base, it);
    }
    return map;
  }, [allItemsInFolder]);

  // Berechne, ob alle Dateien ausgewählt sind
  const isAllSelected = useMemo(() => {
    if (!fileGroups || !fileGroups.size) return false;
    // Verwende nur die Hauptdateien (baseItem) aus den FileGroups
    const mainItems = Array.from((fileGroups ?? new Map()).values())
      .map(group => group.baseItem)
      .filter((item): item is StorageItem => item !== undefined);
    // Je nach Filter unterschiedliche Dateien zählen
    let selectableItems: StorageItem[] = [];
    switch (currentCategoryFilter) {
      case 'media':
        selectableItems = mainItems.filter(item => {
          try {
            const mediaType = getMediaType(item);
            return item.type === 'file' && (mediaType === 'audio' || mediaType === 'video');
          } catch {
            return false;
          }
        });
        return selectableItems.length > 0 && selectedBatchItems.length === selectableItems.length;
      case 'text':
        selectableItems = mainItems.filter(item => {
          try {
            const mediaType = getMediaType(item);
            return item.type === 'file' && mediaType === 'text';
          } catch {
            return false;
          }
        });
        return selectableItems.length > 0 && selectedTransformationItems.length === selectableItems.length;
      case 'documents':
        selectableItems = mainItems.filter(item => {
          try {
            const mediaType = getMediaType(item);
            return item.type === 'file' && mediaType === 'document';
          } catch {
            return false;
          }
        });
        return selectableItems.length > 0 && selectedTransformationItems.length === selectableItems.length;
      default:
        // Bei 'all' prüfen ob alle verfügbaren Dateien ausgewählt sind
        const mediaItems = mainItems.filter(item => {
          try {
            const mediaType = getMediaType(item);
            return item.type === 'file' && (mediaType === 'audio' || mediaType === 'video');
          } catch {
            return false;
          }
        });
        const textItems = mainItems.filter(item => {
          try {
            const mediaType = getMediaType(item);
            return item.type === 'file' && (mediaType === 'text' || mediaType === 'document');
          } catch {
            return false;
          }
        });
        const allMediaSelected = mediaItems.length === 0 || selectedBatchItems.length === mediaItems.length;
        const allTextSelected = textItems.length === 0 || selectedTransformationItems.length === textItems.length;
        return allMediaSelected && allTextSelected;
    }
  }, [fileGroups, selectedBatchItems, selectedTransformationItems, currentCategoryFilter]);
  
  // Erweiterte handleSelect Funktion für Review-Mode
  const handleSelect = useCallback((item: StorageItem, group?: FileGroup) => {
    FileLogger.debug('FileList', 'handleSelect aufgerufen', {
      itemId: item.id,
      itemName: item.metadata.name,
      groupBase: group?.baseItem?.metadata.name,
      transcriptCount: group?.transcriptFiles?.length ?? 0,
      hasTranscripts: !!(group && group.transcriptFiles && group.transcriptFiles.length > 0)
    });
    
    // Nur die ausgewählte Datei setzen - Review-Modus wird über Toggle-Button gesteuert
    setSelectedFile(item);
    
    // Wenn wir im Review-Modus sind und eine Basis-Datei mit Shadow-Twin ausgewählt wird,
    // dann automatisch das Shadow-Twin setzen
    if (group && group.transcriptFiles && group.transcriptFiles.length > 0) {
      const shadowTwin = group.transcriptFiles[0];
      FileLogger.info('FileList', 'Basis-Datei mit Shadow-Twin ausgewählt', {
        twinId: shadowTwin.id,
        twinName: shadowTwin.metadata.name,
        baseFileId: item.id,
        baseFileName: item.metadata.name
      });
      setSelectedShadowTwin(shadowTwin);
    } else {
      FileLogger.info('FileList', 'Datei ohne Shadow-Twin ausgewählt', {
        itemId: item.id,
        itemName: item.metadata.name,
        groupExists: !!group,
        transcriptCount: group?.transcriptFiles?.length ?? 0
      });
      setSelectedShadowTwin(null);
    }
  }, [setSelectedFile, setSelectedShadowTwin, findFileGroup]);
  
  // Erweiterte handleSelectRelatedFile Funktion für Review-Mode
  const handleSelectRelatedFile = useCallback((shadowTwin: StorageItem) => {
    StateLogger.info('FileList', 'Shadow-Twin ausgewählt', {
      shadowTwinId: shadowTwin.id,
      shadowTwinName: shadowTwin.metadata.name
    });
    
    // Setze das Shadow-Twin als ausgewählte Datei, damit es rechts angezeigt wird
    setSelectedFile(shadowTwin);
    setSelectedShadowTwin(null); // Kein zusätzliches Shadow-Twin im normalen Modus
  }, [setSelectedFile, setSelectedShadowTwin, findFileGroup]);

  // Aktualisierte handleRefresh Funktion
  const handleRefresh = useCallback(async () => {
    if (!items || items.length === 0) return;
    
    const parentId = items[0]?.parentId;
    if (!parentId) return;
    
    setIsRefreshing(true);
    
    try {
      const refreshedItems = await refreshItems(parentId);
      setFolderItems(refreshedItems);
    } catch (error) {
      FileLogger.error('FileList', 'Fehler beim Aktualisieren der Dateiliste', error);
    } finally {
      setIsRefreshing(false);
    }
  }, [items, refreshItems, setFolderItems]);

  const handleCreateTranscript = React.useCallback((e: React.MouseEvent) => {
    e.stopPropagation();
    FileLogger.info('FileList', 'Create transcript for', { fileName: 'TODO' });
    // TODO: Implement transcript creation
  }, []);

  // Entfernt: handleItemSelect war unbenutzt

  // Check if an item is selected (beide Atome prüfen)
  const isItemSelected = useCallback((item: StorageItem) => {
    const mediaType = getMediaType(item);
    if (mediaType === 'audio' || mediaType === 'video') {
      return selectedBatchItems.some(selected => selected.item.id === item.id);
    } else {
      return selectedTransformationItems.some(selected => selected.item.id === item.id);
    }
  }, [selectedBatchItems, selectedTransformationItems]);

  // Löschfunktion
  const handleDeleteClick = React.useCallback(async (e: React.MouseEvent<HTMLButtonElement>, itemToDelete: StorageItem) => {
    e.stopPropagation();
    
    if (!provider) {
      toast.error("Fehler", {
        description: "Storage Provider nicht verfügbar"
      });
      return;
    }

    try {
      // Finde die FileGroup für dieses Item
      const itemStem = getBaseName(itemToDelete.metadata.name);
      const fileGroup = findFileGroup(fileGroups, itemStem);

      // Bestätigungsnachricht vorbereiten
      let confirmMessage = `Möchten Sie "${itemToDelete.metadata.name}" wirklich löschen?`;
      if (fileGroup && itemToDelete.id === fileGroup.baseItem?.id) {
        if (fileGroup.transcriptFiles && fileGroup.transcriptFiles.length > 0 || fileGroup.transformed) {
          confirmMessage = `Möchten Sie "${itemToDelete.metadata.name}" und alle zugehörigen Dateien wirklich löschen?`;
        }
      }

      // Benutzer um Bestätigung bitten
      if (!window.confirm(confirmMessage)) {
        return;
      }

      if (fileGroup && itemToDelete.id === fileGroup.baseItem?.id) {
        // Dies ist die Basis-Datei - lösche auch abhängige Dateien
        // Lösche alle Transkripte, falls vorhanden
        if (fileGroup.transcriptFiles) {
          for (const transcript of fileGroup.transcriptFiles) {
            try {
              await provider.deleteItem(transcript.id);
              FileLogger.info('FileList', 'Transkript gelöscht', {
                transcriptId: transcript.id,
                transcriptName: transcript.metadata.name
              });
            } catch (error) {
              FileLogger.error('FileList', 'Fehler beim Löschen des Transkripts', error);
              toast.warning("Hinweis", {
                description: "Einige Transkripte konnten nicht gelöscht werden"
              });
            }
          }
        }

        // Lösche die transformierte Datei, falls vorhanden
        if (fileGroup.transformed) {
          try {
            await provider.deleteItem(fileGroup.transformed.id);
            FileLogger.info('FileList', 'Transformierte Datei gelöscht', {
              transformedId: fileGroup.transformed.id,
              transformedName: fileGroup.transformed.metadata.name
            });
          } catch (error) {
            FileLogger.error('FileList', 'Fehler beim Löschen der transformierten Datei', error);
            toast.warning("Hinweis", {
              description: "Die transformierte Datei konnte nicht gelöscht werden"
            });
          }
        }

        // Lösche die Basis-Datei
        await provider.deleteItem(itemToDelete.id);
        toast.success("Dateien gelöscht", {
          description: `${itemToDelete.metadata.name} und zugehörige Dateien wurden gelöscht.`
        });
      } else {
        // Dies ist eine abhängige Datei oder keine Gruppe - nur diese Datei löschen
        await provider.deleteItem(itemToDelete.id);
        toast.success("Datei gelöscht", {
          description: `${itemToDelete.metadata.name} wurde gelöscht.`
        });
      }

      // Aktualisiere die Dateiliste
      await handleRefresh();

      // Wenn die gelöschte Datei ausgewählt war, Auswahl aufheben
      setSelectedFile(null);
      
      // Aus der Batch-Auswahl entfernen
      setSelectedBatchItems(prev => prev.filter(i => i.item.id !== itemToDelete.id));

    } catch (error) {
      FileLogger.error('FileList', 'Fehler beim Löschen', error);
      toast.error("Fehler", {
        description: `Die Datei konnte nicht gelöscht werden: ${error instanceof Error ? error.message : 'Unbekannter Fehler'}`
      });
    }
  }, [provider, handleRefresh, fileGroups, setSelectedFile, setSelectedBatchItems]);

  const handleRename = React.useCallback(async (item: StorageItem, newName: string) => {
    if (!provider) {
      toast.error("Fehler", {
        description: "Storage Provider nicht verfügbar"
      });
      return;
    }

    try {
      // Finde die FileGroup für dieses Item
      const itemStem = getBaseName(item.metadata.name);
      const fileGroup = findFileGroup(fileGroups, itemStem);

      if (fileGroup && item.id === fileGroup.baseItem?.id) {
        // Dies ist die Basis-Datei - benenne auch abhängige Dateien um
        const oldStem = getBaseName(item.metadata.name);
        const newStem = getBaseName(newName);
        // Benenne die Basis-Datei um
        await provider.renameItem(item.id, newName);
        // Benenne alle Transkripte um, falls vorhanden
        if (fileGroup.transcriptFiles) {
          for (const transcript of fileGroup.transcriptFiles) {
            const transcriptName = transcript.metadata.name;
            const newTranscriptName = transcriptName.replace(oldStem, newStem);
            try {
              await provider.renameItem(transcript.id, newTranscriptName);
            } catch (error) {
              FileLogger.error('FileList', 'Fehler beim Umbenennen des Transkripts', error);
              toast.warning("Hinweis", {
                description: "Einige Transkripte konnten nicht umbenannt werden"
              });
            }
          }
        }
        // Benenne die transformierte Datei um, falls vorhanden
        if (fileGroup.transformed) {
          const transformedName = fileGroup.transformed.metadata.name;
          const newTransformedName = transformedName.replace(oldStem, newStem);
          try {
            await provider.renameItem(fileGroup.transformed.id, newTransformedName);
          } catch (error) {
            FileLogger.error('FileList', 'Fehler beim Umbenennen der transformierten Datei', error);
            toast.warning("Hinweis", {
              description: "Die transformierte Datei konnte nicht umbenannt werden"
            });
          }
        }
        toast.success("Dateien umbenannt", {
          description: `${item.metadata.name} und zugehörige Dateien wurden umbenannt.`
        });
      } else {
        // Dies ist eine abhängige Datei oder keine Gruppe - nur diese Datei umbenennen
        await provider.renameItem(item.id, newName);
        toast.success("Datei umbenannt", {
          description: `${item.metadata.name} wurde zu ${newName} umbenannt.`
        });
      }
      await handleRefresh();
    } catch (error) {
      FileLogger.error('FileList', 'Fehler beim Umbenennen', error);
      toast.error("Fehler", {
        description: `Die Datei konnte nicht umbenannt werden: ${error instanceof Error ? error.message : 'Unbekannter Fehler'}`
      });
      throw error;
    }
  }, [provider, handleRefresh, fileGroups]);

  const handleBatchTranscription = () => {
    if (selectedBatchItems.length > 0) {
      setTranscriptionDialogOpen(true);
    }
  };

  const handleBatchTransformation = () => {
    if (selectedTransformationItems.length > 0) {
      setTransformationDialogOpen(true);
    }
  };

  // Bulk-Löschung für ausgewählte Dateien (unabhängig von Batch/Transformation-Selektor)
  const handleBulkDelete = React.useCallback(async () => {
    if (!provider) return;
    const targets = [
      ...selectedBatchItems.map(x => x.item),
      ...selectedTransformationItems.map(x => x.item),
    ];
    if (targets.length === 0) return;
    const confirmMsg = targets.length === 1
      ? `"${targets[0].metadata.name}" wirklich löschen?`
      : `${targets.length} Dateien wirklich löschen?`;
    if (!window.confirm(confirmMsg)) return;

    try {
      const parentId = targets[0].parentId || 'root';
      for (const t of targets) {
        try { await provider.deleteItem(t.id); } catch (err) {
          FileLogger.error('FileList', 'Bulk Delete failed', { id: t.id, name: t.metadata.name, err });
        }
      }
      const refreshed = await refreshItems(parentId);
      setFolderItems(refreshed);
      setSelectedBatchItems([]);
      setSelectedTransformationItems([]);
    } catch (error) {
      FileLogger.error('FileList', 'Bulk Delete error', error);
    }
  }, [provider, selectedBatchItems, selectedTransformationItems, refreshItems, setFolderItems, setSelectedBatchItems, setSelectedTransformationItems]);

  // Intelligente Batch-Auswahl basierend auf Filter
  const handleSelectAll = useCallback((checked: boolean) => {
    const startTime = performance.now();
    if (checked) {
      // Verwende nur die Hauptdateien (baseItem) aus den FileGroups
      const mainItems = Array.from((fileGroups ?? new Map()).values())
        .map(group => group.baseItem)
        .filter((item): item is StorageItem => item !== undefined);
      const selectableItems = mainItems.filter(item => {
        try {
          const mediaType = getMediaType(item);
          // Je nach Filter unterschiedliche Dateien auswählen
          switch (currentCategoryFilter) {
            case 'media':
              return item.type === 'file' && (mediaType === 'audio' || mediaType === 'video');
            case 'text':
              return item.type === 'file' && mediaType === 'text';
            case 'documents':
              return item.type === 'file' && mediaType === 'document';
            default:
              // Bei 'all' alle Dateien auswählen, die für eine Operation geeignet sind
              return item.type === 'file' && (
                mediaType === 'audio' || 
                mediaType === 'video' || 
                mediaType === 'text' || 
                mediaType === 'document'
              );
          }
        } catch {
          return false;
        }
      });
      StateLogger.info('FileList', 'Selecting all items based on filter', {
        filter: currentCategoryFilter,
        totalItems: items.length,
        selectableCount: selectableItems.length,
        duration: `${(performance.now() - startTime).toFixed(2)}ms`
      });
      // Je nach Filter unterschiedliche Atome verwenden
      if (currentCategoryFilter === 'media') {
        setSelectedBatchItems(selectableItems.map(item => ({
          item,
          type: getMediaType(item)
        })));
      } else if (currentCategoryFilter === 'text') {
        setSelectedTransformationItems(selectableItems.map(item => ({
          item,
          type: getMediaType(item)
        })));
      } else {
        // Bei 'all' oder 'documents' beide Atome füllen
        const mediaItems = selectableItems.filter(item => {
          const mediaType = getMediaType(item);
          return mediaType === 'audio' || mediaType === 'video';
        });
        const textItems = selectableItems.filter(item => {
          const mediaType = getMediaType(item);
          return mediaType === 'text' || mediaType === 'document';
        });
        setSelectedBatchItems(mediaItems.map(item => ({
          item,
          type: getMediaType(item)
        })));
        setSelectedTransformationItems(textItems.map(item => ({
          item,
          type: getMediaType(item)
        })));
      }
    } else {
      StateLogger.info('FileList', 'Deselecting all items', {
        previouslySelected: selectedBatchItems.length + selectedTransformationItems.length,
        duration: `${(performance.now() - startTime).toFixed(2)}ms`
      });
      setSelectedBatchItems([]);
      setSelectedTransformationItems([]);
    }
  }, [fileGroups, currentCategoryFilter, setSelectedBatchItems, setSelectedTransformationItems, selectedBatchItems.length, selectedTransformationItems.length, items.length]);

  React.useEffect(() => {
    // Logging der Library-IDs - verzögert ausführen
    const timeoutId = setTimeout(() => {
      StateLogger.debug('FileList', 'Render', {
        currentLibraryId: currentLibrary?.id,
        activeLibraryIdAtom: activeLibraryId
      });
    }, 0);
    
    return () => clearTimeout(timeoutId);
  }, [currentLibrary, activeLibraryId]);

  // Entkoppelt: kein Render-Gate mehr basierend auf FileTree

  return (
    <div className="h-full flex flex-col">
      {/* Header - versteckt im compact mode */}
      {!compact && (
        <div className="border-b px-2 py-2 flex items-center justify-between bg-background sticky top-0 z-10">
          <div className="flex items-center gap-2">
            <Button
              variant="ghost"
              size="icon"
              className="h-8 w-8"
              onClick={handleRefresh}
              disabled={isRefreshing}
              title="Aktualisieren"
              aria-label="Aktualisieren"
            >
              <RefreshCw className={cn("h-4 w-4", isRefreshing && "animate-spin")} />
            </Button>

            {/* Dateikategorie-Filter (Icon-only Variante) */}
            <FileCategoryFilter iconOnly />

            {/* Batch-Actions als Icons */}
            {selectedBatchItems.length > 0 && (
              <Button size="icon" title="Transkribieren" aria-label="Transkribieren" onClick={handleBatchTranscription}>
                <ScrollText className="h-4 w-4" />
              </Button>
            )}
            {selectedTransformationItems.length > 0 && (
              <Button size="icon" variant="secondary" title="Transformieren" aria-label="Transformieren" onClick={handleBatchTransformation}>
                <Plus className="h-4 w-4" />
              </Button>
            )}
            {(selectedBatchItems.length + selectedTransformationItems.length) > 0 && (
              <Button size="icon" variant="destructive" title="Ausgewählte löschen" aria-label="Ausgewählte löschen" onClick={handleBulkDelete}>
                <Trash2 className="h-4 w-4" />
              </Button>
            )}
          </div>
        </div>
      )}

      {/* File List */}
      <div ref={listContainerRef} className="flex-1 overflow-auto focus:outline-none" tabIndex={0} onKeyDown={handleKeyNav} onMouseDown={handleContainerMouseDown}>
        <div>
          {/* Table Header - versteckt im compact mode */}
          {!compact && (
            <div className="sticky top-0 bg-background border-b">
              <div className="grid grid-cols-[24px_24px_minmax(0,1fr)_56px_88px_auto] gap-2 px-4 py-2 text-sm font-medium text-muted-foreground">
                <div className="w-6 flex items-center justify-center">
                  <Checkbox
                    checked={isAllSelected}
                    onCheckedChange={handleSelectAll}
                    aria-label="Alle auswählen"
                  />
                </div>
                <div className="w-6" />
                <SortableHeaderCell
                  label="Name"
                  field="name"
                  currentSortField={sortField}
                  currentSortOrder={sortOrder}
                  onSort={handleSort}
                />
                <SortableHeaderCell
                  label="Größe"
                  field="size"
                  currentSortField={sortField}
                  currentSortOrder={sortOrder}
                  onSort={handleSort}
                />
                <SortableHeaderCell
                  label="Geändert"
                  field="date"
                  currentSortField={sortField}
                  currentSortOrder={sortOrder}
                  onSort={handleSort}
                />
                <div />
              </div>
            </div>
          )}

          {/* Folder Rows (oberhalb der Dateien, unabhängig von Datei-Gruppierung) */}
          {folders.length > 0 && (
            <div className="divide-y">
          {folders.map((folder) => (
            compact ? (
              // Kompakt: ohne Einrückung, nur Icon + Name (2 Spalten)
              <div
                key={folder.id}
                role="button"
                tabIndex={0}
                onClick={() => navigateToFolder(folder.id)}
                onKeyDown={(e) => { if (e.key === 'Enter' || e.key === ' ') navigateToFolder(folder.id) }}
                className="w-full px-2 py-1 text-xs hover:bg-muted/50 grid grid-cols-[24px_minmax(0,1fr)] gap-2 items-center cursor-pointer"
              >
                <FolderIcon className="h-4 w-4" />
                <span className="text-left truncate select-none" title={folder.metadata.name}>{folder.metadata.name}</span>
              </div>
            ) : (
              // Normal: behalte leichte Einrückung für Checkbox-Spalte
              <div
                key={folder.id}
                role="button"
                tabIndex={0}
                onClick={() => navigateToFolder(folder.id)}
                onKeyDown={(e) => { if (e.key === 'Enter' || e.key === ' ') navigateToFolder(folder.id) }}
                className="w-full px-4 py-2 text-xs hover:bg-muted/50 grid grid-cols-[24px_24px_minmax(0,1fr)] gap-2 items-center cursor-pointer"
              >
                <div />
                <FolderIcon className="h-4 w-4" />
                <span className="text-left truncate select-none" title={folder.metadata.name}>{folder.metadata.name}</span>
              </div>
            )
          ))}
            </div>
          )}

          {/* File Rows */}
          <div className="divide-y">
            {Array.from((fileGroups ?? new Map()).values())
              .map((group) => {
                // Zeige nur die Hauptdatei (baseItem) an
                const item = group.baseItem;
                if (!item) return null;
                // System-Unterordner-Id, wenn ein ".<basename>"-Folder existiert
                const systemFolder = systemFolderByBase.get(getBaseName(item.metadata.name));
                const systemFolderId = systemFolder?.id;
                const isActive = !!activeFile && activeFile.id === item.id
                return (
                  <FileRow
                    key={item.id}
                    item={item as StorageItem}
                    isSelected={isItemSelected(item)}
                    isActive={isActive}
                    onSelect={() => handleSelect(item, group)}
                    onCreateTranscript={handleCreateTranscript}
                    onDelete={(e) => handleDeleteClick(e, item)}
                    fileGroup={group}
                    onSelectRelatedFile={handleSelectRelatedFile}
                    onRename={handleRename}
                    compact={compact}
                    systemFolderId={systemFolderId}
                  />
                );
              })}
          </div>
        </div>
      </div>
    </div>
  );
}); 
```

- Ich habe in `FileList` Pfeiltasten-Navigation eingebaut:
  - Container ist fokussierbar (`tabIndex={0}`) und hört auf `ArrowUp/ArrowDown`.
  - Navigation springt zur vorherigen/nächsten Hauptdatei (Shadow-Twins bleiben gruppiert).
  - Auswahl wird über `selectedFileAtom` gesetzt; Scroll-Into-View sorgt für Sichtbarkeit.
  - Zeilen bekommen IDs (`file-row-<id>`); Eingaben in Inputs werden nicht gestört.

- Dateien/Orte:
  - `src/components/library/file-list.tsx`: Fokus/Keydown, Berechnung `mainFileItems`, Scroll, IDs.

Kurzer Testvorschlag:
- Klicke einmal in die Liste (damit der Container Fokus hat).
- Nutze Pfeil runter/hoch → Auswahl bewegt sich; rechts ändert sich die Vorschau.
- In Kompakt- und Normalansicht testen.

Ich lasse den Play/Stop-Worker-Button wie zuvor in „Secretary Jobs“. Wenn du Auto-Start beim Öffnen möchtest, kann ich das panel-intern hinzufügen oder serverseitig beim ersten GET auf den Worker-Status starten.

---

**User**

ReferenceError: Cannot access 'handleSelect' before initialization
    at FileList (webpack-internal:///(app-pages-browser)/./src/components/library/file-list.tsx:1191:9)
    at Library (webpack-internal:///(app-pages-browser)/./src/components/library/library.tsx:853:130)
    at LibraryPage (webpack-internal:///(app-pages-browser)/./src/app/library/page.tsx:304:102)
    at ClientPageRoot (webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/next@15.3.2_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/next/dist/client/components/client-page.js:20:50)

---

**Cursor**

```typescriptreact
'use client';

import * as React from "react"
import { File, FileText, FileVideo, FileAudio, Plus, RefreshCw, ChevronUp, ChevronDown, Trash2, ScrollText, Folder as FolderIcon, Layers } from "lucide-react"
import { StorageItem } from "@/lib/storage/types"
import { cn } from "@/lib/utils"
import { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from "@/components/ui/tooltip"
import { useStorage } from "@/contexts/storage-context";
import { Button } from "@/components/ui/button";
import { useAtomValue, useAtom } from 'jotai';
import { jobStatusByItemIdAtom } from '@/atoms/job-status';
import { 
  activeLibraryIdAtom, 
  selectedFileAtom, 
  folderItemsAtom,
  sortedFilteredFilesAtom,
  sortFieldAtom,
  sortOrderAtom,
  selectedShadowTwinAtom
} from '@/atoms/library-atom';
import { toast } from "sonner";
import { Input } from "@/components/ui/input"
import {
  selectedBatchItemsAtom,
  transcriptionDialogOpenAtom,
  selectedTransformationItemsAtom,
  transformationDialogOpenAtom,
  getMediaType,
  fileCategoryFilterAtom,
} from '@/atoms/transcription-options';
import { Checkbox } from "@/components/ui/checkbox"
import { useMemo, useCallback } from "react"
import { FileLogger, StateLogger } from "@/lib/debug/logger"
import { FileCategoryFilter } from './file-category-filter';
import { useFolderNavigation } from "@/hooks/use-folder-navigation";

// Typen für Sortieroptionen
type SortField = 'type' | 'name' | 'size' | 'date';
type SortOrder = 'asc' | 'desc';

// Typ für gruppierte Dateien
interface FileGroup {
  baseItem?: StorageItem;
  transcriptFiles?: StorageItem[]; // NEU: alle Transkripte
  transformed?: StorageItem;
}

// Memoized file icon component
const FileIconComponent = React.memo(function FileIconComponent({ item }: { item: StorageItem }) {
  const mimeType = item.metadata.mimeType || '';
  if (!mimeType) return <File className="h-4 w-4" />;

  if (mimeType.startsWith('video/')) {
    return <FileVideo className="h-4 w-4" />;
  } else if (mimeType.startsWith('audio/')) {
    return <FileAudio className="h-4 w-4" />;
  } else if (mimeType.startsWith('text/')) {
    return <FileText className="h-4 w-4" />;
  }

  return <File className="h-4 w-4" />;
});

// Pure function for file size formatting
const formatFileSize = (size?: number): string => {
  if (!size) return '-';
  const units = ['B', 'KB', 'MB', 'GB'];
  let value = size;
  let unitIndex = 0;
  
  while (value >= 1024 && unitIndex < units.length - 1) {
    value /= 1024;
    unitIndex++;
  }
  
  return `${value.toFixed(1)} ${units[unitIndex]}`;
};

// Funktion zum Formatieren des Datums
const formatDate = (date?: Date): string => {
  if (!date) return '-';
  
  const options: Intl.DateTimeFormatOptions = { 
    year: '2-digit', 
    month: '2-digit', 
    day: '2-digit',
    hour: '2-digit',
    minute: '2-digit'
  };
  
  return new Date(date).toLocaleDateString('de-DE', options);
};

// Entfernt: getFileStem Funktion war unbenutzt

// Sortierbare Kopfzelle Komponente
const SortableHeaderCell = React.memo(function SortableHeaderCell({
  label,
  field,
  currentSortField,
  currentSortOrder,
  onSort
}: {
  label: string,
  field: SortField,
  currentSortField: SortField,
  currentSortOrder: SortOrder,
  onSort: (field: SortField) => void
}) {
  const isActive = currentSortField === field;
  
  return (
    <button 
      onClick={() => onSort(field)}
      className="flex items-center gap-1 hover:text-foreground"
    >
      <span>{label}</span>
      {isActive && (
        currentSortOrder === 'asc' 
          ? <ChevronUp className="h-3 w-3" /> 
          : <ChevronDown className="h-3 w-3" />
      )}
    </button>
  );
});

interface FileRowProps {
  item: StorageItem;
  isSelected: boolean;
  isActive?: boolean;
  onSelect: () => void;
  onCreateTranscript: (e: React.MouseEvent) => void;
  onDelete: (e: React.MouseEvent<HTMLButtonElement>, item: StorageItem) => void;
  fileGroup?: FileGroup;
  onSelectRelatedFile?: (file: StorageItem) => void;
  onRename?: (item: StorageItem, newName: string) => Promise<void>;
  compact?: boolean;
  systemFolderId?: string;
}

const FileRow = React.memo(function FileRow({ 
  item, 
  isSelected, 
  isActive = false,
  onSelect,
  onCreateTranscript,
  onDelete,
  fileGroup,
  onSelectRelatedFile,
  onRename,
  compact = false,
  systemFolderId
}: FileRowProps) {
  const navigateToFolder = useFolderNavigation();
  const [isEditing, setIsEditing] = React.useState(false);
  const [editName, setEditName] = React.useState(item.metadata.name);
  const inputRef = React.useRef<HTMLInputElement>(null);
  const longPressTimerRef = React.useRef<NodeJS.Timeout | null>(null);
  const lastClickTimeRef = React.useRef<number>(0);
  
  // Zusätzliche Validierung der Metadaten
  const metadata = React.useMemo(() => ({
    name: item.metadata?.name || 'Unbekannte Datei',
    size: typeof item.metadata?.size === 'number' ? item.metadata.size : 0,
    mimeType: item.metadata?.mimeType || '',
    hasTranscript: !!item.metadata?.hasTranscript || (fileGroup?.transcriptFiles && fileGroup.transcriptFiles.length > 0),
    modifiedAt: item.metadata?.modifiedAt
  }), [item.metadata, fileGroup]);

  const isTranscribable = React.useMemo(() => {
    const mimeType = metadata.mimeType.toLowerCase();
    const extension = metadata.name.split('.').pop()?.toLowerCase();

    return (
      mimeType.startsWith('audio/') ||
      mimeType.startsWith('video/') ||
      extension === 'pdf' ||
      mimeType === 'application/pdf'
    );
  }, [metadata.mimeType, metadata.name]);

  // Memoize the click handler
  const handleClick = React.useCallback(() => {
    if (!isEditing) {
      onSelect();
    }
  }, [onSelect, isEditing]);

  // Memoize the keydown handler
  const handleKeyDown = React.useCallback((e: React.KeyboardEvent) => {
    if (!isEditing && (e.key === 'Enter' || e.key === ' ')) {
      onSelect();
    }
  }, [onSelect, isEditing]);

  // Handler für Transkript-Icon Click
  const handleTranscriptClick = React.useCallback((e: React.MouseEvent) => {
    e.stopPropagation();
    if (fileGroup?.transcriptFiles && onSelectRelatedFile) {
      onSelectRelatedFile(fileGroup.transcriptFiles[0]); // Nur das erste Transkript anzeigen
    }
  }, [fileGroup, onSelectRelatedFile]);

  // Handler für Transformierte-Datei-Icon Click
  const handleTransformedClick = React.useCallback((e: React.MouseEvent) => {
    e.stopPropagation();
    if (fileGroup?.transformed && onSelectRelatedFile) {
      onSelectRelatedFile(fileGroup.transformed);
    }
  }, [fileGroup, onSelectRelatedFile]);

  // Starte Rename-Modus
  const startRename = React.useCallback(() => {
    if (onRename) {
      // Prüfe ob dies eine abhängige Datei ist
      if (fileGroup && (
        (fileGroup.transcriptFiles && fileGroup.transcriptFiles.length > 0 && fileGroup.transcriptFiles[0]?.id === item.id) ||
        (fileGroup.transformed && item.id === fileGroup.transformed.id)
      )) {
        // Dies ist eine abhängige Datei - zeige Hinweis
        toast.info("Hinweis", {
          description: "Bitte benennen Sie die Haupt-Datei um. Abhängige Dateien werden automatisch mit umbenannt."
        });
        return;
      }
      
      setIsEditing(true);
      setEditName(item.metadata.name);
    }
  }, [onRename, item, fileGroup]);

  // Handler für Dateinamen-Click (Doppelklick-Erkennung)
  const handleNameClick = React.useCallback((e: React.MouseEvent) => {
    e.stopPropagation();
    
    const currentTime = Date.now();
    const timeSinceLastClick = currentTime - lastClickTimeRef.current;
    
    if (timeSinceLastClick < 300) {
      // Doppelklick erkannt
      startRename();
    } else {
      // Erster Klick - wähle die Datei aus
      onSelect();
    }
    
    lastClickTimeRef.current = currentTime;
  }, [startRename, onSelect]);

  // Handler für Long-Press (Touch-Geräte)
  const handleTouchStart = React.useCallback((e: React.TouchEvent) => {
    e.stopPropagation();
    
    // Starte Long-Press Timer
    longPressTimerRef.current = setTimeout(() => {
      startRename();
    }, 500); // 500ms für Long-Press
  }, [startRename]);

  const handleTouchEnd = React.useCallback((e: React.TouchEvent) => {
    e.stopPropagation();
    
    // Lösche Long-Press Timer
    if (longPressTimerRef.current) {
      clearTimeout(longPressTimerRef.current);
      longPressTimerRef.current = null;
    }
  }, []);

  const handleTouchMove = React.useCallback(() => {
    // Bei Bewegung Long-Press abbrechen
    if (longPressTimerRef.current) {
      clearTimeout(longPressTimerRef.current);
      longPressTimerRef.current = null;
    }
  }, []);

  // Cleanup Timer bei Unmount
  React.useEffect(() => {
    return () => {
      if (longPressTimerRef.current) {
        clearTimeout(longPressTimerRef.current);
      }
    };
  }, []);

  // Handler für Rename-Submit
  const handleRenameSubmit = React.useCallback(async () => {
    if (onRename && editName.trim() && editName !== item.metadata.name) {
      try {
        await onRename(item, editName.trim());
      } catch (error) {
        FileLogger.error('FileRow', 'Fehler beim Umbenennen', error);
        // Bei Fehler den ursprünglichen Namen wiederherstellen
        setEditName(item.metadata.name);
      }
    }
    setIsEditing(false);
  }, [onRename, editName, item]);

  // Handler für Rename-Cancel
  const handleRenameCancel = React.useCallback(() => {
    setEditName(item.metadata.name);
    setIsEditing(false);
  }, [item.metadata.name]);

  // Handler für Input-Änderungen
  const handleInputChange = React.useCallback((e: React.ChangeEvent<HTMLInputElement>) => {
    setEditName(e.target.value);
  }, []);

  // Handler für Input-Keydown
  const handleInputKeyDown = React.useCallback((e: React.KeyboardEvent<HTMLInputElement>) => {
    e.stopPropagation();
    if (e.key === 'Enter') {
      handleRenameSubmit();
    } else if (e.key === 'Escape') {
      handleRenameCancel();
    }
  }, [handleRenameSubmit, handleRenameCancel]);

  // Focus Input wenn Edit-Modus aktiviert wird
  React.useEffect(() => {
    if (isEditing && inputRef.current) {
      inputRef.current.focus();
      inputRef.current.select();
    }
  }, [isEditing]);

  // Handler für Drag Start
  const handleDragStart = React.useCallback((e: React.DragEvent) => {
    // Sammle alle Dateien der Gruppe, die verschoben werden sollen
    const itemsToMove = [];
    
    // Füge das aktuelle Item hinzu
    itemsToMove.push({
      itemId: item.id,
      itemName: item.metadata.name,
      itemType: item.type,
      parentId: item.parentId
    });
    
    // Wenn es eine FileGroup gibt, füge auch die zugehörigen Dateien hinzu
    if (fileGroup) {
      // Prüfe ob das aktuelle Item die Basis-Datei ist
      if (item.id === fileGroup.baseItem?.id) {
        // Füge Transkripte hinzu, falls vorhanden
        if (fileGroup.transcriptFiles && fileGroup.transcriptFiles.length > 0) {
          fileGroup.transcriptFiles.forEach(transcript => {
            itemsToMove.push({
              itemId: transcript.id,
              itemName: transcript.metadata.name,
              itemType: transcript.type,
              parentId: transcript.parentId
            });
          });
        }
        
        // Füge transformierte Datei hinzu, falls vorhanden
        if (fileGroup.transformed) {
          itemsToMove.push({
            itemId: fileGroup.transformed.id,
            itemName: fileGroup.transformed.metadata.name,
            itemType: fileGroup.transformed.type,
            parentId: fileGroup.transformed.parentId
          });
        }
      }
    }
    
    // Setze die Drag-Daten
    e.dataTransfer.effectAllowed = 'move';
    e.dataTransfer.setData('application/json', JSON.stringify({
      items: itemsToMove,
      isFileGroup: itemsToMove.length > 1
    }));
    
    // Visuelles Feedback
    if (e.currentTarget instanceof HTMLElement) {
      e.currentTarget.style.opacity = '0.5';
    }
  }, [item, fileGroup]);

  // Handler für Drag End
  const handleDragEnd = React.useCallback((e: React.DragEvent) => {
    // Stelle Opacity wieder her
    if (e.currentTarget instanceof HTMLElement) {
      e.currentTarget.style.opacity = '1';
    }
  }, []);

  const [selectedBatchItems, setSelectedBatchItems] = useAtom(selectedBatchItemsAtom);
  const [selectedTransformationItems, setSelectedTransformationItems] = useAtom(selectedTransformationItemsAtom);
  
  // Prüfe ob das Item in einem der beiden Atome ausgewählt ist
  const isInBatch = selectedBatchItems.some(batchItem => batchItem.item.id === item.id);
  const isInTransformation = selectedTransformationItems.some(transformationItem => transformationItem.item.id === item.id);
  const isInAnyBatch = isInBatch || isInTransformation;

  // Handler für Checkbox-Änderungen
  const handleCheckboxChange = React.useCallback((checked: boolean) => {
    const mediaType = getMediaType(item);
    
    if (mediaType === 'audio' || mediaType === 'video') {
      // Für Audio/Video: Transcription-Atom verwenden
      if (checked) {
        setSelectedBatchItems([...selectedBatchItems, {
          item,
          type: mediaType
        }]);
      } else {
        setSelectedBatchItems(selectedBatchItems.filter(i => i.item.id !== item.id));
      }
    } else if (mediaType === 'text' || mediaType === 'document') {
      // Für Text/Dokumente: Transformation-Atom verwenden
      if (checked) {
        setSelectedTransformationItems([...selectedTransformationItems, {
          item,
          type: mediaType
        }]);
      } else {
        setSelectedTransformationItems(selectedTransformationItems.filter(i => i.item.id !== item.id));
      }
    }
  }, [item, selectedBatchItems, selectedTransformationItems, setSelectedBatchItems, setSelectedTransformationItems]);

  React.useEffect(() => {
    if (fileGroup) {
      FileLogger.debug('FileRow', 'Transkripte für Zeile', {
        baseItem: fileGroup.baseItem?.metadata.name,
        transcripts: fileGroup.transcriptFiles?.map(t => t.metadata.name)
      });
    }
  }, [fileGroup]);

  // Zentraler Jobstatus (muss vor möglichen early-returns stehen, um Hook-Order zu garantieren)
  const jobStatusMap = useAtomValue(jobStatusByItemIdAtom);
  const jobStatus = jobStatusMap[item.id];
  const jobStatusIcon = jobStatus ? (
    <span title={jobStatus} className={cn('inline-block h-3 w-3 rounded-full',
      jobStatus === 'queued' && 'bg-blue-600',
      jobStatus === 'running' && 'bg-yellow-600',
      jobStatus === 'completed' && 'bg-green-600',
      jobStatus === 'failed' && 'bg-red-600'
    )} aria-label={`job-${jobStatus}`} />
  ) : null;

  // Compact-Modus: vereinfachte Darstellung
  if (compact) {
    return (
      <div
        id={`file-row-${item.id}`}
        role="button"
        tabIndex={0}
        onClick={handleClick}
        onKeyDown={handleKeyDown}
        className={cn(
          "w-full px-2 py-1 text-xs hover:bg-muted/50 grid grid-cols-[24px_minmax(0,1fr)] gap-2 items-center cursor-pointer",
          isSelected && "bg-muted",
          isActive && "bg-primary/10 border-l-2 border-primary"
        )}
      >
        <FileIconComponent item={item} />
        <span className={cn("truncate", isActive && "font-medium")} title={metadata.name}>
          {metadata.name}
        </span>
      </div>
    );
  }

  return (
    <div
      id={`file-row-${item.id}`}
      role="button"
      tabIndex={0}
      onClick={handleClick}
      onKeyDown={handleKeyDown}
      onTouchStart={handleTouchStart}
      onTouchEnd={handleTouchEnd}
      onTouchMove={handleTouchMove}
      draggable={!isEditing}
      onDragStart={handleDragStart}
      onDragEnd={handleDragEnd}
      className={cn(
        "w-full px-4 py-2 text-xs hover:bg-muted/50 grid grid-cols-[24px_24px_minmax(0,1fr)_56px_88px_auto] gap-2 items-center cursor-move",
        isSelected && "bg-muted",
        isActive && "bg-primary/10 border-l-2 border-primary"
      )}
    >
      <div className="w-6 flex items-center justify-center">
        <Checkbox
          checked={isInAnyBatch}
          onCheckedChange={handleCheckboxChange}
          onClick={(e) => e.stopPropagation()}
        />
      </div>
      <FileIconComponent item={item} />
      {isEditing ? (
        <Input
          ref={inputRef}
          value={editName}
          onChange={handleInputChange}
          onKeyDown={handleInputKeyDown}
          onBlur={handleRenameSubmit}
          onClick={(e) => e.stopPropagation()}
          className="h-6 px-1 py-0 text-xs"
        />
      ) : (
        <span 
          className={cn("text-left truncate cursor-pointer hover:text-primary select-none", isActive && "font-medium")}
          onClick={handleNameClick}
          onTouchStart={handleTouchStart}
          onTouchEnd={handleTouchEnd}
          onTouchMove={handleTouchMove}
          title={metadata.name}
        >
          {metadata.name}
        </span>
      )}
      <span className="text-muted-foreground tabular-nums text-[10px]">
        {formatFileSize(metadata.size)}
      </span>
      <span className="text-muted-foreground tabular-nums text-[10px]">
        {formatDate(metadata.modifiedAt)}
      </span>
      <div className="flex items-center justify-start gap-1">
        {jobStatusIcon}
        {/* System-Unterordner (z. B. extrahierte Seiten) */}
        {systemFolderId && (
          <TooltipProvider>
            <Tooltip>
              <TooltipTrigger asChild>
                <Button
                  variant="ghost"
                  size="icon"
                  className="h-6 w-6 p-0 hover:bg-muted"
                  onClick={(e) => {
                    e.stopPropagation();
                    navigateToFolder(systemFolderId);
                  }}
                >
                  <Layers className="h-4 w-4 text-violet-500" />
                </Button>
              </TooltipTrigger>
              <TooltipContent>
                <p>Seiten-Ordner öffnen</p>
              </TooltipContent>
            </Tooltip>
          </TooltipProvider>
        )}
        {/* Zeige Icons für alle vorhandenen Transkripte */}
        {fileGroup?.transcriptFiles && fileGroup.transcriptFiles.length > 0 && fileGroup.transcriptFiles.map((transcript) => (
          <TooltipProvider key={transcript.id}>
            <Tooltip>
              <TooltipTrigger asChild>
                <Button
                  variant="ghost"
                  size="icon"
                  className="h-6 w-6 p-0 hover:bg-muted"
                  onClick={(e) => {
                    e.stopPropagation();
                    if (onSelectRelatedFile) onSelectRelatedFile(transcript);
                  }}
                >
                  <FileText className="h-4 w-4 text-blue-500" />
                </Button>
              </TooltipTrigger>
              <TooltipContent>
                <p>Transkript anzeigen: {transcript.metadata.name}</p>
              </TooltipContent>
            </Tooltip>
          </TooltipProvider>
        ))}
        {/* Plus-Symbol nur anzeigen, wenn kein Transkript vorhanden und transkribierbar */}
        {(!fileGroup?.transcriptFiles || fileGroup.transcriptFiles.length === 0) && isTranscribable && !metadata.hasTranscript ? (
          <TooltipProvider>
            <Tooltip>
              <TooltipTrigger asChild>
                <div 
                  role="button"
                  tabIndex={0}
                  className="h-6 w-6 p-0 inline-flex items-center justify-center hover:bg-muted rounded-sm"
                  onClick={onCreateTranscript}
                  onKeyDown={(e) => {
                    if (e.key === 'Enter' || e.key === ' ') {
                      e.stopPropagation();
                      onCreateTranscript(e as unknown as React.MouseEvent<HTMLDivElement>);
                    }
                  }}
                >
                  <Plus className="h-4 w-4" />
                </div>
              </TooltipTrigger>
              <TooltipContent>
                <p>Transkript erstellen</p>
              </TooltipContent>
            </Tooltip>
          </TooltipProvider>
        ) : null}
        {/* Icon für transformierte Datei */}
        {fileGroup?.transformed && (
          <TooltipProvider>
            <Tooltip>
              <TooltipTrigger asChild>
                <Button
                  variant="ghost"
                  size="icon"
                  className="h-6 w-6 p-0 hover:bg-muted"
                  onClick={handleTransformedClick}
                >
                  <ScrollText className="h-4 w-4 text-green-500" />
                </Button>
              </TooltipTrigger>
              <TooltipContent>
                <p>Transformierte Datei anzeigen</p>
              </TooltipContent>
            </Tooltip>
          </TooltipProvider>
        )}
        {/* Delete direkt neben Dokument-Icons */}
        <TooltipProvider>
          <Tooltip>
            <TooltipTrigger asChild>
              <Button
                variant="ghost"
                size="icon"
                className="h-6 w-6 p-0 hover:bg-destructive/10 hover:text-destructive"
                onClick={(e) => onDelete(e as React.MouseEvent<HTMLButtonElement>, item)}
              >
                <Trash2 className="h-4 w-4" />
              </Button>
            </TooltipTrigger>
            <TooltipContent>
              <p>Datei löschen</p>
            </TooltipContent>
          </Tooltip>
        </TooltipProvider>
      </div>
      <div />
    </div>
  );
});

interface FileListProps {
  compact?: boolean;
}

export const FileList = React.memo(function FileList({ compact = false }: FileListProps): JSX.Element {
  const { provider, refreshItems, currentLibrary } = useStorage();
  const activeLibraryId = useAtomValue(activeLibraryIdAtom);
  const [isRefreshing, setIsRefreshing] = React.useState(false);
  // Mobile-Flag wurde entfernt, FileList lädt unabhängig vom View
  const [selectedBatchItems, setSelectedBatchItems] = useAtom(selectedBatchItemsAtom);
  const [selectedTransformationItems, setSelectedTransformationItems] = useAtom(selectedTransformationItemsAtom);
  const [, setTranscriptionDialogOpen] = useAtom(transcriptionDialogOpenAtom);
  const [, setTransformationDialogOpen] = useAtom(transformationDialogOpenAtom);
  const [isInitialized, setIsInitialized] = React.useState(false);
  const initializationTimeoutRef = React.useRef<NodeJS.Timeout | null>(null);
  // Entkoppelt: Kein Warten mehr auf FileTree-Status
  const [activeFile, setSelectedFile] = useAtom(selectedFileAtom);
  const [, setFolderItems] = useAtom(folderItemsAtom);
  const currentCategoryFilter = useAtomValue(fileCategoryFilterAtom);
  const allItemsInFolder = useAtomValue(folderItemsAtom);
  const navigateToFolder = useFolderNavigation();
  const listContainerRef = React.useRef<HTMLDivElement | null>(null);

  // Kein mobiles Flag mehr notwendig

  const folders = useMemo(() => {
    const items = allItemsInFolder ?? [];
    // Verstecke dot-Verzeichnisse generell in der Liste
    return items.filter(item => item.type === 'folder' && !item.metadata.name.startsWith('.'));
  }, [allItemsInFolder]);

  // Hilfsfunktion zum Finden einer FileGroup in der Map
  const findFileGroup = (map: Map<string, FileGroup>, stem: string): FileGroup | undefined => {
    return Array.from((map ?? new Map()).values()).find(group => 
      group.baseItem && getBaseName(group.baseItem.metadata.name) === stem
    );
  };

  // NEU: Atome für Sortierung und Filter
  const items = useAtomValue(sortedFilteredFilesAtom);
  const [sortField, setSortField] = useAtom(sortFieldAtom);
  const [sortOrder, setSortOrder] = useAtom(sortOrderAtom);
  
  // Review-Mode-Atoms
  const [, setSelectedShadowTwin] = useAtom(selectedShadowTwinAtom);

  // handleSort nutzt jetzt Atome
  const handleSort = React.useCallback((field: SortField) => {
    if (field === sortField) setSortOrder(sortOrder === 'asc' ? 'desc' : 'asc');
    else {
      setSortField(field);
      setSortOrder('asc');
    }
  }, [sortField, sortOrder, setSortField, setSortOrder]);

  // Initialisierung - nur auf Provider und Mobile-Flag achten
  React.useEffect(() => {
    if (!provider) {
      FileLogger.info('FileList', 'Waiting for provider');
      return;
    }

    const initialize = async () => {
      if (isInitialized) {
        FileLogger.debug('FileList', 'Already initialized');
        return;
      }

      FileLogger.info('FileList', 'Starting initialization');

      try {
        FileLogger.info('FileList', 'Initialization complete');
        setIsInitialized(true);
      } catch (error) {
        FileLogger.error('FileList', 'Error initializing FileList', error);
      }
    };

    initialize();

    const timeoutRef = initializationTimeoutRef.current;
    return () => {
      if (timeoutRef) clearTimeout(timeoutRef);
    };
  }, [provider, isInitialized]);

  // NEU: Reagieren auf Bibliothekswechsel
  const prevLibraryIdRef = React.useRef<string | null>(null);
  React.useEffect(() => {
    StateLogger.debug('FileList', 'Render', {
      currentLibraryId: activeLibraryId,
      activeLibraryIdAtom: activeLibraryId
    });

    // Nur bei tatsächlichem Bibliothekswechsel zurücksetzen
    if (prevLibraryIdRef.current !== null && prevLibraryIdRef.current !== activeLibraryId) {
      setIsInitialized(false);
      setSelectedFile(null);
      setFolderItems([]);
      setSelectedBatchItems([]);
      setSelectedTransformationItems([]);
      setSelectedShadowTwin(null);
      StateLogger.info('FileList', 'Bibliothek gewechselt - State zurückgesetzt', {
        libraryId: activeLibraryId
      });
    }
    prevLibraryIdRef.current = activeLibraryId;
  }, [activeLibraryId, setSelectedFile, setFolderItems, setSelectedBatchItems, setSelectedTransformationItems, setSelectedShadowTwin]);

  // Vereinfachte Funktion zum Extrahieren des Basisnamens (ohne Endung, auch für Binärdateien)
  function getBaseName(name: string): string {
    // ShadowTwin: .de.md, .en.md, etc.
    const shadowTwinMatch = name.match(/^(.*)\.(de|en|fr|es|it)\.md$/);
    if (shadowTwinMatch) return shadowTwinMatch[1];
    // Sonst: alles vor der letzten Endung
    const lastDot = name.lastIndexOf('.');
    if (lastDot === -1) return name;
    return name.substring(0, lastDot);
  }

  // Prüft ob eine Datei ein ShadowTwin ist (Markdown mit Sprachkürzel)
  function isShadowTwin(name: string): boolean {
    // Pattern: name.de.md, name.en.md, etc.
    const shadowTwinPattern = /^(.+)\.(de|en|fr|es|it)\.md$/;
    return shadowTwinPattern.test(name);
  }

  // Gruppiere die Dateien nach Basename
  const fileGroups = useMemo(() => {
    if (!items) return new Map<string, FileGroup>();

    // Schritt 1: Gruppiere alle Dateien nach Basename
    const groupsMap = new Map<string, StorageItem[]>();
    for (const item of items) {
      if (item.type !== 'file') continue;
      const base = getBaseName(item.metadata.name);
      if (!groupsMap.has(base)) groupsMap.set(base, []);
      groupsMap.get(base)!.push(item);
    }

    // Schritt 2: Erstelle FileGroups
    const fileGroupsMap = new Map<string, FileGroup>();
    for (const [base, groupItems] of Array.from(groupsMap.entries())) {
      // Finde Hauptdatei (erste Nicht-ShadowTwin-Datei)
      const mainFile = groupItems.find((item) => !isShadowTwin(item.metadata.name));
      // Finde alle ShadowTwins
      const shadowTwins = groupItems.filter((item) => isShadowTwin(item.metadata.name));
      if (mainFile) {
        fileGroupsMap.set(base, {
          baseItem: mainFile,
          transcriptFiles: shadowTwins.length > 0 ? shadowTwins : undefined,
          transformed: undefined
        });
      } else {
        // Keine Hauptdatei: Jede ShadowTwin einzeln anzeigen
        for (const twin of shadowTwins) {
          fileGroupsMap.set(`${base}__shadow_${twin.id}`, {
            baseItem: twin,
            transcriptFiles: undefined,
            transformed: undefined
          });
        }
      }
    }
    // Debug-Logging für Gruppierung
    FileLogger.debug('FileList', 'Gruppierung Ergebnis (Basename, alle Endungen)', {
      groups: Array.from(fileGroupsMap.entries()).map(([base, group]) => ({
        base,
        baseItem: group.baseItem?.metadata.name,
        transcripts: group.transcriptFiles?.map(t => t.metadata.name)
      }))
    });
    return fileGroupsMap;
  }, [items]);

  // Navigationsliste: nur Hauptdateien in der aktuell sichtbaren Reihenfolge
  const mainFileItems = React.useMemo(() => {
    return Array.from((fileGroups ?? new Map()).values())
      .map(g => g.baseItem)
      .filter((it): it is StorageItem => Boolean(it));
  }, [fileGroups]);

  // Hilfsfunktion: Gruppe anhand baseItem.id finden
  const findGroupByBaseItemId = React.useCallback((baseItemId: string) => {
    for (const g of Array.from((fileGroups ?? new Map()).values())) {
      if (g.baseItem && g.baseItem.id === baseItemId) return g;
    }
    return undefined;
  }, [fileGroups]);

  // Auswahl-Helfer für Keyboard-Navigation (dupliziert nicht die UI-spezifischen Click-Handler)
  const selectByKeyboard = React.useCallback((item: StorageItem) => {
    setSelectedFile(item);
    const group = findGroupByBaseItemId(item.id);
    if (group && group.transcriptFiles && group.transcriptFiles.length > 0) {
      setSelectedShadowTwin(group.transcriptFiles[0]);
    } else {
      setSelectedShadowTwin(null);
    }
  }, [setSelectedFile, setSelectedShadowTwin, findGroupByBaseItemId]);

  // Keyboard-Navigation: Pfeil hoch/runter wählt vorherige/nächste Datei
  const handleKeyNav = React.useCallback((e: React.KeyboardEvent<HTMLDivElement>) => {
    if (e.key !== 'ArrowDown' && e.key !== 'ArrowUp') return;
    // Eingaben in aktiven Inputs nicht stören
    const ae = document.activeElement as HTMLElement | null;
    if (ae && (ae.tagName === 'INPUT' || ae.tagName === 'TEXTAREA' || ae.isContentEditable)) return;
    if (mainFileItems.length === 0) return;
    e.preventDefault();
    const currentIndex = activeFile ? mainFileItems.findIndex(it => it.id === activeFile.id) : -1;
    const nextIndex = e.key === 'ArrowDown'
      ? Math.min((currentIndex < 0 ? 0 : currentIndex + 1), mainFileItems.length - 1)
      : Math.max((currentIndex < 0 ? 0 : currentIndex - 1), 0);
    const nextItem = mainFileItems[nextIndex];
    if (!nextItem) return;
    selectByKeyboard(nextItem);
    // Sichtbar scrollen
    const rowEl = document.getElementById(`file-row-${nextItem.id}`);
    if (rowEl) rowEl.scrollIntoView({ block: 'nearest' });
  }, [activeFile, mainFileItems, selectByKeyboard]);

  const handleContainerMouseDown = React.useCallback((e: React.MouseEvent<HTMLDivElement>) => {
    const target = e.target as HTMLElement;
    if (target && (target.tagName === 'INPUT' || target.tagName === 'TEXTAREA' || target.isContentEditable)) return;
    listContainerRef.current?.focus();
  }, []);

  // Mapping: Basename -> dot-Systemordner (z. B. ".<basename>")
  const systemFolderByBase = useMemo(() => {
    const map = new Map<string, StorageItem>();
    const items = allItemsInFolder ?? [];
    for (const it of items) {
      if (it.type !== 'folder') continue;
      const name = it.metadata.name;
      if (!name.startsWith('.')) continue;
      const base = name.slice(1);
      if (base) map.set(base, it);
    }
    return map;
  }, [allItemsInFolder]);

  // Berechne, ob alle Dateien ausgewählt sind
  const isAllSelected = useMemo(() => {
    if (!fileGroups || !fileGroups.size) return false;
    // Verwende nur die Hauptdateien (baseItem) aus den FileGroups
    const mainItems = Array.from((fileGroups ?? new Map()).values())
      .map(group => group.baseItem)
      .filter((item): item is StorageItem => item !== undefined);
    // Je nach Filter unterschiedliche Dateien zählen
    let selectableItems: StorageItem[] = [];
    switch (currentCategoryFilter) {
      case 'media':
        selectableItems = mainItems.filter(item => {
          try {
            const mediaType = getMediaType(item);
            return item.type === 'file' && (mediaType === 'audio' || mediaType === 'video');
          } catch {
            return false;
          }
        });
        return selectableItems.length > 0 && selectedBatchItems.length === selectableItems.length;
      case 'text':
        selectableItems = mainItems.filter(item => {
          try {
            const mediaType = getMediaType(item);
            return item.type === 'file' && mediaType === 'text';
          } catch {
            return false;
          }
        });
        return selectableItems.length > 0 && selectedTransformationItems.length === selectableItems.length;
      case 'documents':
        selectableItems = mainItems.filter(item => {
          try {
            const mediaType = getMediaType(item);
            return item.type === 'file' && mediaType === 'document';
          } catch {
            return false;
          }
        });
        return selectableItems.length > 0 && selectedTransformationItems.length === selectableItems.length;
      default:
        // Bei 'all' prüfen ob alle verfügbaren Dateien ausgewählt sind
        const mediaItems = mainItems.filter(item => {
          try {
            const mediaType = getMediaType(item);
            return item.type === 'file' && (mediaType === 'audio' || mediaType === 'video');
          } catch {
            return false;
          }
        });
        const textItems = mainItems.filter(item => {
          try {
            const mediaType = getMediaType(item);
            return item.type === 'file' && (mediaType === 'text' || mediaType === 'document');
          } catch {
            return false;
          }
        });
        const allMediaSelected = mediaItems.length === 0 || selectedBatchItems.length === mediaItems.length;
        const allTextSelected = textItems.length === 0 || selectedTransformationItems.length === textItems.length;
        return allMediaSelected && allTextSelected;
    }
  }, [fileGroups, selectedBatchItems, selectedTransformationItems, currentCategoryFilter]);
  
  // Erweiterte handleSelect Funktion für Review-Mode
  const handleSelect = useCallback((item: StorageItem, group?: FileGroup) => {
    FileLogger.debug('FileList', 'handleSelect aufgerufen', {
      itemId: item.id,
      itemName: item.metadata.name,
      groupBase: group?.baseItem?.metadata.name,
      transcriptCount: group?.transcriptFiles?.length ?? 0,
      hasTranscripts: !!(group && group.transcriptFiles && group.transcriptFiles.length > 0)
    });
    
    // Nur die ausgewählte Datei setzen - Review-Modus wird über Toggle-Button gesteuert
    setSelectedFile(item);
    
    // Wenn wir im Review-Modus sind und eine Basis-Datei mit Shadow-Twin ausgewählt wird,
    // dann automatisch das Shadow-Twin setzen
    if (group && group.transcriptFiles && group.transcriptFiles.length > 0) {
      const shadowTwin = group.transcriptFiles[0];
      FileLogger.info('FileList', 'Basis-Datei mit Shadow-Twin ausgewählt', {
        twinId: shadowTwin.id,
        twinName: shadowTwin.metadata.name,
        baseFileId: item.id,
        baseFileName: item.metadata.name
      });
      setSelectedShadowTwin(shadowTwin);
    } else {
      FileLogger.info('FileList', 'Datei ohne Shadow-Twin ausgewählt', {
        itemId: item.id,
        itemName: item.metadata.name,
        groupExists: !!group,
        transcriptCount: group?.transcriptFiles?.length ?? 0
      });
      setSelectedShadowTwin(null);
    }
  }, [setSelectedFile, setSelectedShadowTwin, findFileGroup]);
  
  // Erweiterte handleSelectRelatedFile Funktion für Review-Mode
  const handleSelectRelatedFile = useCallback((shadowTwin: StorageItem) => {
    StateLogger.info('FileList', 'Shadow-Twin ausgewählt', {
      shadowTwinId: shadowTwin.id,
      shadowTwinName: shadowTwin.metadata.name
    });
    
    // Setze das Shadow-Twin als ausgewählte Datei, damit es rechts angezeigt wird
    setSelectedFile(shadowTwin);
    setSelectedShadowTwin(null); // Kein zusätzliches Shadow-Twin im normalen Modus
  }, [setSelectedFile, setSelectedShadowTwin, findFileGroup]);

  // Aktualisierte handleRefresh Funktion
  const handleRefresh = useCallback(async () => {
    if (!items || items.length === 0) return;
    
    const parentId = items[0]?.parentId;
    if (!parentId) return;
    
    setIsRefreshing(true);
    
    try {
      const refreshedItems = await refreshItems(parentId);
      setFolderItems(refreshedItems);
    } catch (error) {
      FileLogger.error('FileList', 'Fehler beim Aktualisieren der Dateiliste', error);
    } finally {
      setIsRefreshing(false);
    }
  }, [items, refreshItems, setFolderItems]);

  const handleCreateTranscript = React.useCallback((e: React.MouseEvent) => {
    e.stopPropagation();
    FileLogger.info('FileList', 'Create transcript for', { fileName: 'TODO' });
    // TODO: Implement transcript creation
  }, []);

  // Entfernt: handleItemSelect war unbenutzt

  // Check if an item is selected (beide Atome prüfen)
  const isItemSelected = useCallback((item: StorageItem) => {
    const mediaType = getMediaType(item);
    if (mediaType === 'audio' || mediaType === 'video') {
      return selectedBatchItems.some(selected => selected.item.id === item.id);
    } else {
      return selectedTransformationItems.some(selected => selected.item.id === item.id);
    }
  }, [selectedBatchItems, selectedTransformationItems]);

  // Löschfunktion
  const handleDeleteClick = React.useCallback(async (e: React.MouseEvent<HTMLButtonElement>, itemToDelete: StorageItem) => {
    e.stopPropagation();
    
    if (!provider) {
      toast.error("Fehler", {
        description: "Storage Provider nicht verfügbar"
      });
      return;
    }

    try {
      // Finde die FileGroup für dieses Item
      const itemStem = getBaseName(itemToDelete.metadata.name);
      const fileGroup = findFileGroup(fileGroups, itemStem);

      // Bestätigungsnachricht vorbereiten
      let confirmMessage = `Möchten Sie "${itemToDelete.metadata.name}" wirklich löschen?`;
      if (fileGroup && itemToDelete.id === fileGroup.baseItem?.id) {
        if (fileGroup.transcriptFiles && fileGroup.transcriptFiles.length > 0 || fileGroup.transformed) {
          confirmMessage = `Möchten Sie "${itemToDelete.metadata.name}" und alle zugehörigen Dateien wirklich löschen?`;
        }
      }

      // Benutzer um Bestätigung bitten
      if (!window.confirm(confirmMessage)) {
        return;
      }

      if (fileGroup && itemToDelete.id === fileGroup.baseItem?.id) {
        // Dies ist die Basis-Datei - lösche auch abhängige Dateien
        // Lösche alle Transkripte, falls vorhanden
        if (fileGroup.transcriptFiles) {
          for (const transcript of fileGroup.transcriptFiles) {
            try {
              await provider.deleteItem(transcript.id);
              FileLogger.info('FileList', 'Transkript gelöscht', {
                transcriptId: transcript.id,
                transcriptName: transcript.metadata.name
              });
            } catch (error) {
              FileLogger.error('FileList', 'Fehler beim Löschen des Transkripts', error);
              toast.warning("Hinweis", {
                description: "Einige Transkripte konnten nicht gelöscht werden"
              });
            }
          }
        }

        // Lösche die transformierte Datei, falls vorhanden
        if (fileGroup.transformed) {
          try {
            await provider.deleteItem(fileGroup.transformed.id);
            FileLogger.info('FileList', 'Transformierte Datei gelöscht', {
              transformedId: fileGroup.transformed.id,
              transformedName: fileGroup.transformed.metadata.name
            });
          } catch (error) {
            FileLogger.error('FileList', 'Fehler beim Löschen der transformierten Datei', error);
            toast.warning("Hinweis", {
              description: "Die transformierte Datei konnte nicht gelöscht werden"
            });
          }
        }

        // Lösche die Basis-Datei
        await provider.deleteItem(itemToDelete.id);
        toast.success("Dateien gelöscht", {
          description: `${itemToDelete.metadata.name} und zugehörige Dateien wurden gelöscht.`
        });
      } else {
        // Dies ist eine abhängige Datei oder keine Gruppe - nur diese Datei löschen
        await provider.deleteItem(itemToDelete.id);
        toast.success("Datei gelöscht", {
          description: `${itemToDelete.metadata.name} wurde gelöscht.`
        });
      }

      // Aktualisiere die Dateiliste
      await handleRefresh();

      // Wenn die gelöschte Datei ausgewählt war, Auswahl aufheben
      setSelectedFile(null);
      
      // Aus der Batch-Auswahl entfernen
      setSelectedBatchItems(prev => prev.filter(i => i.item.id !== itemToDelete.id));

    } catch (error) {
      FileLogger.error('FileList', 'Fehler beim Löschen', error);
      toast.error("Fehler", {
        description: `Die Datei konnte nicht gelöscht werden: ${error instanceof Error ? error.message : 'Unbekannter Fehler'}`
      });
    }
  }, [provider, handleRefresh, fileGroups, setSelectedFile, setSelectedBatchItems]);

  const handleRename = React.useCallback(async (item: StorageItem, newName: string) => {
    if (!provider) {
      toast.error("Fehler", {
        description: "Storage Provider nicht verfügbar"
      });
      return;
    }

    try {
      // Finde die FileGroup für dieses Item
      const itemStem = getBaseName(item.metadata.name);
      const fileGroup = findFileGroup(fileGroups, itemStem);

      if (fileGroup && item.id === fileGroup.baseItem?.id) {
        // Dies ist die Basis-Datei - benenne auch abhängige Dateien um
        const oldStem = getBaseName(item.metadata.name);
        const newStem = getBaseName(newName);
        // Benenne die Basis-Datei um
        await provider.renameItem(item.id, newName);
        // Benenne alle Transkripte um, falls vorhanden
        if (fileGroup.transcriptFiles) {
          for (const transcript of fileGroup.transcriptFiles) {
            const transcriptName = transcript.metadata.name;
            const newTranscriptName = transcriptName.replace(oldStem, newStem);
            try {
              await provider.renameItem(transcript.id, newTranscriptName);
            } catch (error) {
              FileLogger.error('FileList', 'Fehler beim Umbenennen des Transkripts', error);
              toast.warning("Hinweis", {
                description: "Einige Transkripte konnten nicht umbenannt werden"
              });
            }
          }
        }
        // Benenne die transformierte Datei um, falls vorhanden
        if (fileGroup.transformed) {
          const transformedName = fileGroup.transformed.metadata.name;
          const newTransformedName = transformedName.replace(oldStem, newStem);
          try {
            await provider.renameItem(fileGroup.transformed.id, newTransformedName);
          } catch (error) {
            FileLogger.error('FileList', 'Fehler beim Umbenennen der transformierten Datei', error);
            toast.warning("Hinweis", {
              description: "Die transformierte Datei konnte nicht umbenannt werden"
            });
          }
        }
        toast.success("Dateien umbenannt", {
          description: `${item.metadata.name} und zugehörige Dateien wurden umbenannt.`
        });
      } else {
        // Dies ist eine abhängige Datei oder keine Gruppe - nur diese Datei umbenennen
        await provider.renameItem(item.id, newName);
        toast.success("Datei umbenannt", {
          description: `${item.metadata.name} wurde zu ${newName} umbenannt.`
        });
      }
      await handleRefresh();
    } catch (error) {
      FileLogger.error('FileList', 'Fehler beim Umbenennen', error);
      toast.error("Fehler", {
        description: `Die Datei konnte nicht umbenannt werden: ${error instanceof Error ? error.message : 'Unbekannter Fehler'}`
      });
      throw error;
    }
  }, [provider, handleRefresh, fileGroups]);

  const handleBatchTranscription = () => {
    if (selectedBatchItems.length > 0) {
      setTranscriptionDialogOpen(true);
    }
  };

  const handleBatchTransformation = () => {
    if (selectedTransformationItems.length > 0) {
      setTransformationDialogOpen(true);
    }
  };

  // Bulk-Löschung für ausgewählte Dateien (unabhängig von Batch/Transformation-Selektor)
  const handleBulkDelete = React.useCallback(async () => {
    if (!provider) return;
    const targets = [
      ...selectedBatchItems.map(x => x.item),
      ...selectedTransformationItems.map(x => x.item),
    ];
    if (targets.length === 0) return;
    const confirmMsg = targets.length === 1
      ? `"${targets[0].metadata.name}" wirklich löschen?`
      : `${targets.length} Dateien wirklich löschen?`;
    if (!window.confirm(confirmMsg)) return;

    try {
      const parentId = targets[0].parentId || 'root';
      for (const t of targets) {
        try { await provider.deleteItem(t.id); } catch (err) {
          FileLogger.error('FileList', 'Bulk Delete failed', { id: t.id, name: t.metadata.name, err });
        }
      }
      const refreshed = await refreshItems(parentId);
      setFolderItems(refreshed);
      setSelectedBatchItems([]);
      setSelectedTransformationItems([]);
    } catch (error) {
      FileLogger.error('FileList', 'Bulk Delete error', error);
    }
  }, [provider, selectedBatchItems, selectedTransformationItems, refreshItems, setFolderItems, setSelectedBatchItems, setSelectedTransformationItems]);

  // Intelligente Batch-Auswahl basierend auf Filter
  const handleSelectAll = useCallback((checked: boolean) => {
    const startTime = performance.now();
    if (checked) {
      // Verwende nur die Hauptdateien (baseItem) aus den FileGroups
      const mainItems = Array.from((fileGroups ?? new Map()).values())
        .map(group => group.baseItem)
        .filter((item): item is StorageItem => item !== undefined);
      const selectableItems = mainItems.filter(item => {
        try {
          const mediaType = getMediaType(item);
          // Je nach Filter unterschiedliche Dateien auswählen
          switch (currentCategoryFilter) {
            case 'media':
              return item.type === 'file' && (mediaType === 'audio' || mediaType === 'video');
            case 'text':
              return item.type === 'file' && mediaType === 'text';
            case 'documents':
              return item.type === 'file' && mediaType === 'document';
            default:
              // Bei 'all' alle Dateien auswählen, die für eine Operation geeignet sind
              return item.type === 'file' && (
                mediaType === 'audio' || 
                mediaType === 'video' || 
                mediaType === 'text' || 
                mediaType === 'document'
              );
          }
        } catch {
          return false;
        }
      });
      StateLogger.info('FileList', 'Selecting all items based on filter', {
        filter: currentCategoryFilter,
        totalItems: items.length,
        selectableCount: selectableItems.length,
        duration: `${(performance.now() - startTime).toFixed(2)}ms`
      });
      // Je nach Filter unterschiedliche Atome verwenden
      if (currentCategoryFilter === 'media') {
        setSelectedBatchItems(selectableItems.map(item => ({
          item,
          type: getMediaType(item)
        })));
      } else if (currentCategoryFilter === 'text') {
        setSelectedTransformationItems(selectableItems.map(item => ({
          item,
          type: getMediaType(item)
        })));
      } else {
        // Bei 'all' oder 'documents' beide Atome füllen
        const mediaItems = selectableItems.filter(item => {
          const mediaType = getMediaType(item);
          return mediaType === 'audio' || mediaType === 'video';
        });
        const textItems = selectableItems.filter(item => {
          const mediaType = getMediaType(item);
          return mediaType === 'text' || mediaType === 'document';
        });
        setSelectedBatchItems(mediaItems.map(item => ({
          item,
          type: getMediaType(item)
        })));
        setSelectedTransformationItems(textItems.map(item => ({
          item,
          type: getMediaType(item)
        })));
      }
    } else {
      StateLogger.info('FileList', 'Deselecting all items', {
        previouslySelected: selectedBatchItems.length + selectedTransformationItems.length,
        duration: `${(performance.now() - startTime).toFixed(2)}ms`
      });
      setSelectedBatchItems([]);
      setSelectedTransformationItems([]);
    }
  }, [fileGroups, currentCategoryFilter, setSelectedBatchItems, setSelectedTransformationItems, selectedBatchItems.length, selectedTransformationItems.length, items.length]);

  React.useEffect(() => {
    // Logging der Library-IDs - verzögert ausführen
    const timeoutId = setTimeout(() => {
      StateLogger.debug('FileList', 'Render', {
        currentLibraryId: currentLibrary?.id,
        activeLibraryIdAtom: activeLibraryId
      });
    }, 0);
    
    return () => clearTimeout(timeoutId);
  }, [currentLibrary, activeLibraryId]);

  // Entkoppelt: kein Render-Gate mehr basierend auf FileTree

  return (
    <div className="h-full flex flex-col">
      {/* Header - versteckt im compact mode */}
      {!compact && (
        <div className="border-b px-2 py-2 flex items-center justify-between bg-background sticky top-0 z-10">
          <div className="flex items-center gap-2">
            <Button
              variant="ghost"
              size="icon"
              className="h-8 w-8"
              onClick={handleRefresh}
              disabled={isRefreshing}
              title="Aktualisieren"
              aria-label="Aktualisieren"
            >
              <RefreshCw className={cn("h-4 w-4", isRefreshing && "animate-spin")} />
            </Button>

            {/* Dateikategorie-Filter (Icon-only Variante) */}
            <FileCategoryFilter iconOnly />

            {/* Batch-Actions als Icons */}
            {selectedBatchItems.length > 0 && (
              <Button size="icon" title="Transkribieren" aria-label="Transkribieren" onClick={handleBatchTranscription}>
                <ScrollText className="h-4 w-4" />
              </Button>
            )}
            {selectedTransformationItems.length > 0 && (
              <Button size="icon" variant="secondary" title="Transformieren" aria-label="Transformieren" onClick={handleBatchTransformation}>
                <Plus className="h-4 w-4" />
              </Button>
            )}
            {(selectedBatchItems.length + selectedTransformationItems.length) > 0 && (
              <Button size="icon" variant="destructive" title="Ausgewählte löschen" aria-label="Ausgewählte löschen" onClick={handleBulkDelete}>
                <Trash2 className="h-4 w-4" />
              </Button>
            )}
          </div>
        </div>
      )}

      {/* File List */}
      <div ref={listContainerRef} className="flex-1 overflow-auto focus:outline-none" tabIndex={0} onKeyDown={handleKeyNav} onMouseDown={handleContainerMouseDown}>
        <div>
          {/* Table Header - versteckt im compact mode */}
          {!compact && (
            <div className="sticky top-0 bg-background border-b">
              <div className="grid grid-cols-[24px_24px_minmax(0,1fr)_56px_88px_auto] gap-2 px-4 py-2 text-sm font-medium text-muted-foreground">
                <div className="w-6 flex items-center justify-center">
                  <Checkbox
                    checked={isAllSelected}
                    onCheckedChange={handleSelectAll}
                    aria-label="Alle auswählen"
                  />
                </div>
                <div className="w-6" />
                <SortableHeaderCell
                  label="Name"
                  field="name"
                  currentSortField={sortField}
                  currentSortOrder={sortOrder}
                  onSort={handleSort}
                />
                <SortableHeaderCell
                  label="Größe"
                  field="size"
                  currentSortField={sortField}
                  currentSortOrder={sortOrder}
                  onSort={handleSort}
                />
                <SortableHeaderCell
                  label="Geändert"
                  field="date"
                  currentSortField={sortField}
                  currentSortOrder={sortOrder}
                  onSort={handleSort}
                />
                <div />
              </div>
            </div>
          )}

          {/* Folder Rows (oberhalb der Dateien, unabhängig von Datei-Gruppierung) */}
          {folders.length > 0 && (
            <div className="divide-y">
          {folders.map((folder) => (
            compact ? (
              // Kompakt: ohne Einrückung, nur Icon + Name (2 Spalten)
              <div
                key={folder.id}
                role="button"
                tabIndex={0}
                onClick={() => navigateToFolder(folder.id)}
                onKeyDown={(e) => { if (e.key === 'Enter' || e.key === ' ') navigateToFolder(folder.id) }}
                className="w-full px-2 py-1 text-xs hover:bg-muted/50 grid grid-cols-[24px_minmax(0,1fr)] gap-2 items-center cursor-pointer"
              >
                <FolderIcon className="h-4 w-4" />
                <span className="text-left truncate select-none" title={folder.metadata.name}>{folder.metadata.name}</span>
              </div>
            ) : (
              // Normal: behalte leichte Einrückung für Checkbox-Spalte
              <div
                key={folder.id}
                role="button"
                tabIndex={0}
                onClick={() => navigateToFolder(folder.id)}
                onKeyDown={(e) => { if (e.key === 'Enter' || e.key === ' ') navigateToFolder(folder.id) }}
                className="w-full px-4 py-2 text-xs hover:bg-muted/50 grid grid-cols-[24px_24px_minmax(0,1fr)] gap-2 items-center cursor-pointer"
              >
                <div />
                <FolderIcon className="h-4 w-4" />
                <span className="text-left truncate select-none" title={folder.metadata.name}>{folder.metadata.name}</span>
              </div>
            )
          ))}
            </div>
          )}

          {/* File Rows */}
          <div className="divide-y">
            {Array.from((fileGroups ?? new Map()).values())
              .map((group) => {
                // Zeige nur die Hauptdatei (baseItem) an
                const item = group.baseItem;
                if (!item) return null;
                // System-Unterordner-Id, wenn ein ".<basename>"-Folder existiert
                const systemFolder = systemFolderByBase.get(getBaseName(item.metadata.name));
                const systemFolderId = systemFolder?.id;
                const isActive = !!activeFile && activeFile.id === item.id
                return (
                  <FileRow
                    key={item.id}
                    item={item as StorageItem}
                    isSelected={isItemSelected(item)}
                    isActive={isActive}
                    onSelect={() => handleSelect(item, group)}
                    onCreateTranscript={handleCreateTranscript}
                    onDelete={(e) => handleDeleteClick(e, item)}
                    fileGroup={group}
                    onSelectRelatedFile={handleSelectRelatedFile}
                    onRename={handleRename}
                    compact={compact}
                    systemFolderId={systemFolderId}
                  />
                );
              })}
          </div>
        </div>
      </div>
    </div>
  );
}); 
```

- Ich habe den Fehler behoben: Die Pfeiltasten-Logik referenzierte `handleSelect`, bevor es deklariert war. Jetzt nutzt die Key‑Navigation eine eigene Helferfunktion `selectByKeyboard`, die erst nach den benötigten Variablen deklariert ist.

- Test:
  - Liste fokussieren (einmal klicken).
  - Pfeil runter/hoch → Auswahl wechselt; der Eintrag scrollt ins Sichtfeld.

- Betroffene Datei: `src/components/library/file-list.tsx`.

---

**User**

Können wir das nochmal kontrollieren? Beim Wechsel mit der Maus scheint es, dass mehrere Dateien oder mehrere Loads passieren in der Metadatenansicht. Wie ist da diese Event-Folge? Kann es sein, dass es da doppelte Events gibt?

---

**Cursor**

Ich prüfe die Event-Kette: Auswahl in `FileList` (Klick/Keyboard) → Atome (`selectedFileAtom`, `selectedShadowTwinAtom`) → `PdfPhasesView`/`JobReportTab` Effekte. Ich lese `job-report-tab.tsx` und `pdf-phases-view.tsx`, um potenzielle doppelte useEffect-Fetches zu finden.

```typescriptreact
"use client";

import { useEffect, useState } from 'react'
import { UILogger } from '@/lib/debug/logger'
import type { StorageProvider } from '@/lib/storage/types'
import { MarkdownPreview } from '@/components/library/markdown-preview'
import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs'
import { TooltipProvider, Tooltip, TooltipTrigger, TooltipContent } from '@/components/ui/tooltip'
import { parseSecretaryMarkdownStrict } from '@/lib/secretary/response-parser'

interface JobReportTabProps {
  libraryId: string
  fileId: string
  fileName?: string
  provider?: StorageProvider | null
  // Quelle der Metadaten steuern: 'merged' = cumulativeMeta + Frontmatter (Standard),
  // 'frontmatter' = ausschließlich Frontmatter aus Markdown anzeigen
  sourceMode?: 'merged' | 'frontmatter'
  // Darstellungsmodus: 'full' zeigt Kopf/Steps/Logs/Parameter; 'metaOnly' zeigt nur Metadaten/Kapitel/TOC
  viewMode?: 'full' | 'metaOnly'
  // Optional explizite Markdown-Datei-ID (Shadow‑Twin). Überschreibt auto-Erkennung.
  mdFileId?: string | null
  // Optionaler Callback zum Scroll-Sync in die Markdown-Vorschau
  onJumpTo?: (args: { page?: number | string; evidence?: string }) => void
  // NEU: Rohinhalt (Markdown). Wenn gesetzt und sourceMode='frontmatter', wird direkt dieser Text geparst (ohne Datei/JOB).
  rawContent?: string
  forcedTab?: 'markdown' | 'meta' | 'chapters' | 'process'
}

interface JobDto {
  jobId: string
  status: string
  operation: string
  worker: string
  job_type: string
  updatedAt: string
  createdAt: string
  correlation?: { source?: { itemId?: string; name?: string } }
  parameters?: Record<string, unknown>
  steps?: Array<{ name: string; status: string; startedAt?: string; endedAt?: string; error?: { message: string }; details?: { skipped?: boolean } }>
  ingestion?: { vectorsUpserted?: number; index?: string; upsertAt?: string }
  result?: { savedItemId?: string }
  logs?: Array<{ timestamp: string; phase?: string; message?: string; progress?: number }>
  cumulativeMeta?: Record<string, unknown>
}

export function JobReportTab({ libraryId, fileId, fileName, provider, sourceMode = 'merged', viewMode = 'full', mdFileId, onJumpTo, rawContent, forcedTab }: JobReportTabProps) {
  const [loading, setLoading] = useState(false)
  const [error, setError] = useState<string | null>(null)
  const [job, setJob] = useState<JobDto | null>(null)
  const [templateFields, setTemplateFields] = useState<string[] | null>(null)
  const [frontmatterMeta, setFrontmatterMeta] = useState<Record<string, unknown> | null>(null)
  const [section, setSection] = useState<'meta' | 'chapters'>('meta')
  const [parseErrors, setParseErrors] = useState<string[]>([])
  const [fullContent, setFullContent] = useState<string>('')
  const [activeTab, setActiveTab] = useState<'markdown' | 'meta' | 'chapters' | 'process'>(forcedTab || 'markdown')

  useEffect(() => {
    if (forcedTab) setActiveTab(forcedTab)
  }, [forcedTab])

  const stripFrontmatter = (markdown: string): string => markdown.replace(/^---\r?\n([\s\S]*?)\r?\n---\r?\n?/, '')

  useEffect(() => {
    let cancelled = false
    async function run() {
      try {
        // Wenn wir ausschließlich Frontmatter anzeigen und bereits eine eindeutige Quelle haben (rawContent oder mdFileId),
        // dann überspringen wir die Job-Suche komplett, um doppelte Events/Loads zu vermeiden.
        if (sourceMode === 'frontmatter' && (
          (typeof rawContent === 'string' && rawContent.length > 0) ||
          (typeof mdFileId === 'string' && mdFileId.length > 0)
        )) {
          setJob(null)
          setLoading(false)
          setError(null)
          return
        }
        setLoading(true)
        setError(null)
        UILogger.info('JobReportTab', 'Start Job-Suche', { libraryId, fileId })
        // 1) Versuche Job über result.savedItemId (Shadow‑Twin) zu finden
        const byResultUrl = new URL(`/api/external/jobs`, window.location.origin)
        byResultUrl.searchParams.set('byResultItemId', fileId)
        UILogger.debug('JobReportTab', 'Request byResultItemId', { url: byResultUrl.toString() })
        let res = await fetch(byResultUrl.toString(), { cache: 'no-store' })
        let data = await res.json()
        if (!res.ok) throw new Error(typeof data?.error === 'string' ? data.error : 'Job-Suche fehlgeschlagen')
        let j: JobDto | null = Array.isArray(data?.items) && data.items.length > 0 ? (data.items[0] as JobDto) : null
        UILogger.debug('JobReportTab', 'Result byResultItemId', { count: Array.isArray(data?.items) ? data.items.length : 0 })

        // 2) Fallback: über correlation.source.itemId (Originaldatei)
        if (!j) {
          const bySourceUrl = new URL(`/api/external/jobs`, window.location.origin)
          bySourceUrl.searchParams.set('bySourceItemId', fileId)
          bySourceUrl.searchParams.set('libraryId', libraryId)
          UILogger.debug('JobReportTab', 'Request bySourceItemId', { url: bySourceUrl.toString() })
          res = await fetch(bySourceUrl.toString(), { cache: 'no-store' })
          data = await res.json()
          if (!res.ok) throw new Error(typeof data?.error === 'string' ? data.error : 'Job-Suche (Quelle) fehlgeschlagen')
          j = Array.isArray(data?.items) && data.items.length > 0 ? (data.items[0] as JobDto) : null
          UILogger.debug('JobReportTab', 'Result bySourceItemId', { count: Array.isArray(data?.items) ? data.items.length : 0 })
        }

        // 3) Fallback: über correlation.source.name (Dateiname der Quelle)
        if (!j) {
          const byNameUrl = new URL(`/api/external/jobs`, window.location.origin)
          // Wenn wir den tatsächlichen Dateinamen kennen, verwende ihn.
          // Für Shadow‑Twins (z. B. name.de.md) versuche das Basis‑PDF (name.pdf).
          let candidate = (fileName && typeof fileName === 'string') ? fileName : (fileId.includes('/') ? (fileId.split('/').pop() as string) : fileId)
          const parts = candidate.split('.')
          if (parts.length >= 3) {
            const ext1 = parts[parts.length - 1].toLowerCase()
            const ext2 = parts[parts.length - 2].toLowerCase()
            if ((ext1 === 'md' || ext1 === 'mdx') && /^[a-z]{2}$/i.test(ext2)) {
              candidate = parts.slice(0, -2).join('.') + '.pdf'
            }
          }
          byNameUrl.searchParams.set('bySourceName', candidate)
          byNameUrl.searchParams.set('libraryId', libraryId)
          UILogger.debug('JobReportTab', 'Request bySourceName', { url: byNameUrl.toString(), nameOnly: candidate, originalFileName: fileName })
          res = await fetch(byNameUrl.toString(), { cache: 'no-store' })
          data = await res.json()
          if (!res.ok) throw new Error(typeof data?.error === 'string' ? data.error : 'Job-Suche (Name) fehlgeschlagen')
          j = Array.isArray(data?.items) && data.items.length > 0 ? (data.items[0] as JobDto) : null
          UILogger.debug('JobReportTab', 'Result bySourceName', { count: Array.isArray(data?.items) ? data.items.length : 0 })
        }

        if (!cancelled) setJob(j)
        if (j) UILogger.info('JobReportTab', 'Job gefunden', { jobId: j.jobId, status: j.status })
        else UILogger.warn('JobReportTab', 'Kein Job gefunden', { libraryId, fileId })
      } catch (e) {
        const msg = e instanceof Error ? e.message : 'Unbekannter Fehler'
        UILogger.error('JobReportTab', 'Job-Suche fehlgeschlagen', e)
        if (!cancelled) setError(msg)
      } finally {
        if (!cancelled) setLoading(false)
      }
    }
    void run()
    return () => { cancelled = true }
  }, [libraryId, fileId, fileName, sourceMode, rawContent, mdFileId])

  // Wenn Template benutzt wurde, lade dessen Inhalt aus /templates und extrahiere Frontmatter-Schlüssel
  useEffect(() => {
    async function loadTemplateFields() {
      try {
        setTemplateFields(null)
        const tpl = job?.cumulativeMeta && typeof (job.cumulativeMeta as unknown) === 'object'
          ? (job.cumulativeMeta as Record<string, unknown>)['template_used']
          : undefined
        const templateName = typeof tpl === 'string' ? tpl : undefined
        if (!templateName || !provider) return
        const rootItems = await provider.listItemsById('root')
        const templatesFolder = rootItems.find(it => it.type === 'folder' && typeof (it as { metadata?: { name?: string } }).metadata?.name === 'string' && ((it as { metadata: { name: string } }).metadata.name.toLowerCase() === 'templates'))
        if (!templatesFolder) return
        const tplItems = await provider.listItemsById(templatesFolder.id)
        const match = tplItems.find(it => it.type === 'file' && ((it as { metadata: { name: string } }).metadata.name.toLowerCase() === templateName.toLowerCase()))
        if (!match) return
        const bin = await provider.getBinary(match.id)
        const text = await bin.blob.text()
        // Extrahiere Frontmatter zwischen den ersten beiden --- und lese die Keys bis zu :
        const m = text.match(/^---[\s\S]*?---/)
        if (!m) return
        const fm = m[0]
        const keys: string[] = []
        for (const line of fm.split('\n')) {
          const t = line.trim()
          if (!t || t === '---') continue
          const idx = t.indexOf(':')
          if (idx > 0) {
            const k = t.slice(0, idx).trim()
            if (k) keys.push(k)
          }
        }
        setTemplateFields(Array.from(new Set(keys)))
      } catch (e) {
        UILogger.warn('JobReportTab', 'Template-Felder konnten nicht geladen werden', { error: e instanceof Error ? e.message : String(e) })
      }
    }
    void loadTemplateFields()
  }, [job, provider])

  // Gemeinsamer strikter Parser
  const strictParseFrontmatter = (fm: string) => parseSecretaryMarkdownStrict(fm)

  // Frontmatter aus der gespeicherten Markdown-Datei lesen (oder aus rawContent)
  const effectiveMdId = (() => {
    // Bevorzugt explizite mdFileId; sonst Ergebnis des Jobs; fallback auf fileId
    return (mdFileId && typeof mdFileId === 'string' && mdFileId.length > 0)
      ? mdFileId
      : ((job?.result?.savedItemId as string | undefined) || fileId)
  })()

  useEffect(() => {
    async function loadFrontmatter() {
      try {
        setParseErrors([])
        // Wenn roher Inhalt übergeben wurde, direkt daraus lesen
        if (sourceMode === 'frontmatter' && typeof rawContent === 'string' && rawContent.length > 0) {
          const text = rawContent
          setFullContent(text)
          const { frontmatter, meta, errors } = parseSecretaryMarkdownStrict(text)
          UILogger.debug('JobReportTab', 'Frontmatter (raw): Block gefunden?', { found: !!frontmatter, length: frontmatter ? frontmatter.length : 0 })
          if (!frontmatter) { setFrontmatterMeta(null); return }
          setFrontmatterMeta(Object.keys(meta).length ? meta : null)
          setParseErrors(errors)
          return
        }

        if (!provider) return
        const mdId = effectiveMdId
        UILogger.info('JobReportTab', 'Frontmatter: Lade Datei', { mdId, sourceMode })
        if (!mdId) return
        const bin = await provider.getBinary(mdId)
        const text = await bin.blob.text()
        setFullContent(text)
        const { frontmatter, meta, errors } = parseSecretaryMarkdownStrict(text)
        UILogger.debug('JobReportTab', 'Frontmatter: Block gefunden?', { found: !!frontmatter, length: frontmatter ? frontmatter.length : 0 })
        if (!frontmatter) { setFrontmatterMeta(null); return }
        setFrontmatterMeta(Object.keys(meta).length ? meta : null)
        setParseErrors(errors)
      } catch {
        setFrontmatterMeta(null)
      }
    }
    void loadFrontmatter()
  }, [provider, effectiveMdId, sourceMode, rawContent])

  if (sourceMode !== 'frontmatter') {
    if (loading) return <div className="p-4 text-sm text-muted-foreground">Lade Job…</div>
    if (error) return <div className="p-4 text-sm text-destructive">{error}</div>
    if (!job) return <div className="p-4 text-sm text-muted-foreground">Kein Job zur Datei gefunden.</div>
  }

  return (
    <div className="p-4 space-y-3 text-sm">
      {viewMode === 'metaOnly' && (
        <Tabs value={activeTab} onValueChange={(v) => setActiveTab(v as typeof activeTab)}>
          <TabsList className="grid grid-cols-4 w-full gap-1">
            <TabsTrigger value="markdown" className="px-2 py-1 text-xs">Markdown</TabsTrigger>
            <TabsTrigger value="meta" className="px-2 py-1 text-xs">Metadaten</TabsTrigger>
            <TabsTrigger value="chapters" className="px-2 py-1 text-xs">Kapitel</TabsTrigger>
            {(() => {
              const base: Record<string, unknown> = sourceMode === 'frontmatter' ? {} : ((job?.cumulativeMeta as unknown as Record<string, unknown>) || {})
              const cm = frontmatterMeta ? { ...base, ...frontmatterMeta } : base
              const processFields = new Set([
                'job_id','extract_status','template_status','ingest_status','summary_language',
                'source_file','source_file_id','source_file_size','source_file_type',
                'filename','path','pathHints','isScan'
              ])
              const hasProcess = Object.keys(cm).some(k => processFields.has(k))
              return hasProcess ? <TabsTrigger value="process" className="px-2 py-1 text-xs">Prozessinfo</TabsTrigger> : null
            })()}
          </TabsList>

          <TabsContent value="markdown" className="mt-3">
            <div className="border rounded-md">
              <MarkdownPreview content={stripFrontmatter(fullContent || '')} />
            </div>
          </TabsContent>

          <TabsContent value="meta" className="mt-3">
            {/* Hinweise zu Parserfehlern (strikt) */}
            {parseErrors.length > 0 && (
              <div className="text-xs text-destructive mb-2">
                {parseErrors.map((e, i) => (<div key={i}>Parserfehler: {e}</div>))}
              </div>
            )}
            {(() => {
              const base: Record<string, unknown> = sourceMode === 'frontmatter'
                ? {}
                : ((job?.cumulativeMeta as unknown as Record<string, unknown>) || {})
              const cm = frontmatterMeta ? { ...base, ...frontmatterMeta } : base
              // confidence/provenance können Objekt oder JSON-String sein → Fallback parse
              const confidence: Record<string, unknown> = (() => {
                const raw = cm['confidence']
                if (raw && typeof raw === 'object') return raw as Record<string, unknown>
                if (typeof raw === 'string') { try { return JSON.parse(raw) as Record<string, unknown> } catch { /* ignore */ } }
                return {}
              })()
              const provenance: Record<string, unknown> = (() => {
                const raw = cm['provenance']
                if (raw && typeof raw === 'object') return raw as Record<string, unknown>
                if (typeof raw === 'string') { try { return JSON.parse(raw) as Record<string, unknown> } catch { /* ignore */ } }
                return {}
              })()
              const hasAnyConfidence = Object.keys(confidence).length > 0
              const baseKeys = Array.isArray(templateFields) && templateFields.length > 0
                ? Array.from(new Set([...(templateFields as string[]), ...Object.keys(cm)]))
                : Object.keys(cm)
              const flatKeysAll = baseKeys.filter(k => k !== 'chapters' && k !== 'toc' && k !== 'confidence' && k !== 'provenance')
              const processFields = new Set([
                'job_id','extract_status','template_status','ingest_status','summary_language',
                'source_file','source_file_id','source_file_size','source_file_type',
                'filename','path','pathHints','isScan'
              ])
              const primaryKeys = flatKeysAll.filter(k => !processFields.has(k))
              const flatKeys = primaryKeys
              if (flatKeys.length === 0) return null
              return (
                <div>
                  <div className="font-medium mb-1">Metadaten (Template vs. Ergebnis)</div>
                  <div className="overflow-auto">
                    <table className="w-full text-xs">
                      <thead>
                        <tr className="text-left text-muted-foreground">
                          <th className="py-1 pr-2 sticky left-0 bg-background z-10">Feld</th>
                          <th className="py-1 pr-2">Wert</th>
                          {hasAnyConfidence ? <th className="py-1 pr-2 text-right sticky right-0 bg-background border-l">Q</th> : null}
                        </tr>
                      </thead>
                      <tbody>
                        {flatKeys.map((k) => {
                          const val = cm[k]
                          let valueStr = ''
                          if (Array.isArray(val)) valueStr = (val as Array<unknown>).map(v => typeof v === 'string' ? v : JSON.stringify(v)).join(', ')
                          else valueStr = val === null || val === undefined ? '' : typeof val === 'string' ? val : JSON.stringify(val)
                          const hasNonEmptyValue = (() => {
                            if (val === null || val === undefined) return false
                            if (typeof val === 'string') return val.trim().length > 0
                            if (Array.isArray(val)) return (val as Array<unknown>).length > 0
                            if (typeof val === 'object') return Object.keys(val as Record<string, unknown>).length > 0
                            return true
                          })()
                          const cRaw = (confidence as Record<string, unknown>)[k]
                          const cNum = typeof cRaw === 'number' ? cRaw : (typeof cRaw === 'string' && /^\d+(\.\d+)?$/.test(cRaw) ? Number(cRaw) : undefined)
                          const pRaw = (provenance as Record<string, unknown>)[k]
                          const pStr = typeof pRaw === 'string' ? pRaw : pRaw ? JSON.stringify(pRaw) : ''
                          const color = cNum === undefined ? 'text-muted-foreground' : (cNum >= 0.8 ? 'text-green-600' : cNum >= 0.7 ? 'text-yellow-600' : 'text-red-600')
                          return (
                            <tr key={k} className="border-t border-muted/40">
                              <td className="py-1 pr-2 align-top font-medium sticky left-0 bg-background z-10 whitespace-nowrap">{k}</td>
                              <td className="py-1 pr-2 align-top">
                                {valueStr ? (
                                  <TooltipProvider>
                                    <Tooltip>
                                      <TooltipTrigger asChild>
                                        <span className="inline-block max-w-[40vw] overflow-hidden text-ellipsis whitespace-nowrap align-top" title="">
                                          {valueStr}
                                        </span>
                                      </TooltipTrigger>
                                      <TooltipContent>
                                        <div className="max-w-[80vw] whitespace-pre-wrap break-words">{valueStr}</div>
                                      </TooltipContent>
                                    </Tooltip>
                                  </TooltipProvider>
                                ) : ''}
                              </td>
                              {hasAnyConfidence ? <td className="py-1 pr-2 align-top sticky right-0 bg-background border-l">
                                {(!hasNonEmptyValue || cNum === undefined) ? null : (
                                  <TooltipProvider>
                                    <Tooltip>
                                      <TooltipTrigger asChild>
                                        <span className={`inline-flex items-center justify-end w-full ${color}`} title={pStr || ''}>
                                          <span className="inline-block h-2 w-2 rounded-full bg-current" />
                                        </span>
                                      </TooltipTrigger>
                                      <TooltipContent>
                                        <div className="max-w-xs whitespace-pre-wrap break-words">
                                          <div className="font-medium">Confidence: {cNum.toFixed(2)}</div>
                                          {pStr ? <div className="mt-1 text-muted-foreground">Provenance: {pStr}</div> : null}
                                        </div>
                                      </TooltipContent>
                                    </Tooltip>
                                  </TooltipProvider>
                                )}
                              </td> : null}
                            </tr>
                          )
                        })}
                      </tbody>
                    </table>
                  </div>
                </div>
              )
            })()}
          </TabsContent>

          <TabsContent value="process" className="mt-3">
            {(() => {
              const base: Record<string, unknown> = sourceMode === 'frontmatter'
                ? {}
                : ((job?.cumulativeMeta as unknown as Record<string, unknown>) || {})
              const cm = frontmatterMeta ? { ...base, ...frontmatterMeta } : base
              const processOrder = [
                'job_id','extract_status','template_status','ingest_status','summary_language',
                'source_file','source_file_id','source_file_size','source_file_type',
                'filename','path','pathHints','isScan'
              ]
              const keys = processOrder.filter(k => k in cm)
              if (keys.length === 0) return <div className="text-xs text-muted-foreground">Keine Prozessinformationen vorhanden.</div>
              return (
                <div className="overflow-auto">
                  <table className="w-full text-xs">
                    <thead>
                      <tr className="text-left text-muted-foreground">
                        <th className="py-1 pr-2 sticky left-0 bg-background z-10">Feld</th>
                        <th className="py-1 pr-2">Wert</th>
                      </tr>
                    </thead>
                    <tbody>
                      {keys.map(k => {
                        const val = cm[k]
                        const valueStr = val === null || val === undefined ? '' : Array.isArray(val) ? (val as Array<unknown>).map(v => typeof v === 'string' ? v : JSON.stringify(v)).join(', ') : typeof val === 'string' ? val : JSON.stringify(val)
                        return (
                          <tr key={k} className="border-t border-muted/40">
                            <td className="py-1 pr-2 align-top font-medium sticky left-0 bg-background z-10 whitespace-nowrap">{k}</td>
                            <td className="py-1 pr-2 align-top">
                              {valueStr ? (
                                <TooltipProvider>
                                  <Tooltip>
                                    <TooltipTrigger asChild>
                                      <span className="inline-block max-w-[40vw] overflow-hidden text-ellipsis whitespace-nowrap align-top" title="">{valueStr}</span>
                                    </TooltipTrigger>
                                    <TooltipContent>
                                      <div className="max-w-[80vw] whitespace-pre-wrap break-words">{valueStr}</div>
                                    </TooltipContent>
                                  </Tooltip>
                                </TooltipProvider>
                              ) : ''}
                            </td>
                          </tr>
                        )
                      })}
                    </tbody>
                  </table>
                </div>
              )
            })()}
          </TabsContent>

          <TabsContent value="chapters" className="mt-3">
            {(() => {
              const chapters: Array<Record<string, unknown>> = sourceMode === 'frontmatter'
                ? (Array.isArray(frontmatterMeta?.chapters) ? (frontmatterMeta?.chapters as Array<Record<string, unknown>>) : [])
                : ((job?.cumulativeMeta as unknown as { chapters?: Array<Record<string, unknown>> })?.chapters || [])
              if (!Array.isArray(chapters) || chapters.length === 0) return null
              const pad = (lvl: number | undefined): number => {
                if (typeof lvl !== 'number') return 0
                const clamped = Math.max(0, Math.min(3, lvl))
                return (clamped - 1) * 16
              }
              const counters = [0, 0, 0]
              return (
                <div className="space-y-1">
                  <div>
                    {chapters.map((c, i) => {
                      const level = typeof c.level === 'number' ? c.level : 1
                      const lvl = Math.max(1, Math.min(3, level))
                      counters[lvl - 1] += 1
                      for (let j = lvl; j < counters.length; j++) counters[j] = 0
                      const numLabel = counters.slice(0, lvl).filter(n => n > 0).join('.')
                      const title = typeof c.title === 'string' ? c.title : ''
                      const startPage = typeof c.startPage === 'number' ? c.startPage : ''
                      const summaryVal = typeof c.summary === 'string' ? c.summary : ''
                      const summary = summaryVal.length > 1000 ? `${summaryVal.slice(0, 1000)}…` : summaryVal
                      const keywords = Array.isArray(c.keywords) ? (c.keywords as Array<unknown>).filter(v => typeof v === 'string') as string[] : []
                      const ev = typeof c.startEvidence === 'string' ? c.startEvidence : ''
                      return (
                        <details key={`${title}-${i}`} className="group border-b py-1" open={false}>
                          <summary className="list-none cursor-pointer">
                            <div className="flex items-start justify-between gap-3">
                              <div className="flex-1 min-w-0" style={{ paddingLeft: `${pad(lvl)}px` }}>
                                <div className="flex items-baseline gap-2">
                                  <span className="text-xs text-muted-foreground tabular-nums">{numLabel}</span>
                                  <span className="font-medium truncate">{title}</span>
                                </div>
                              </div>
                              <div className="text-xs tabular-nums text-muted-foreground whitespace-nowrap">
                                {String(startPage)}
                              </div>
                            </div>
                          </summary>
                          <div className="mt-1 pr-1 text-xs space-y-1" style={{ paddingLeft: `${pad(lvl) + 28}px` }}>
                            {summary && (
                              <div className="whitespace-pre-wrap break-words">
                                {summary}
                              </div>
                            )}
                            {Array.isArray(keywords) && keywords.length > 0 && (
                              <div className="flex flex-wrap gap-1">
                                {keywords.map(k => (
                                  <span key={k} className="inline-flex items-center rounded px-1.5 py-0.5 bg-muted">{k}</span>
                                ))}
                              </div>
                            )}
                          </div>
                        </details>
                      )
                    })}
                  </div>
                </div>
              )
            })()}
          </TabsContent>
        </Tabs>
      )}

      {viewMode === 'full' && job && (
        <div className="flex items-center justify-between">
          <div>
            <div className="font-medium">Job {job.jobId}</div>
            <div className="text-xs text-muted-foreground">{job.job_type} · {job.operation} · {new Date(job.updatedAt).toLocaleString()}</div>
          </div>
          <div className="inline-flex items-center rounded px-2 py-0.5 bg-muted text-xs">{job.status}</div>
        </div>
      )}

      {/* Hinweise zu Parserfehlern (strikt) */}
      {viewMode !== 'metaOnly' && parseErrors.length > 0 && (
        <div className="text-xs text-destructive">
          {parseErrors.map((e, i) => (<div key={i}>Parserfehler: {e}</div>))}
        </div>
      )}

      {/* Template Hinweis (im Frontmatter-only-Modus ausgeblendet) */}
      {sourceMode !== 'frontmatter' && job && typeof job.cumulativeMeta?.template_used === 'string' && (
        <div className="text-xs text-muted-foreground">Template: {String(job.cumulativeMeta.template_used)}</div>
      )}

      {/* Schritte mit Ampel-Logik */}
      {viewMode === 'full' && job && Array.isArray(job.steps) && job.steps.length > 0 && (
        <div>
          <div className="font-medium mb-1">Schritte</div>
          <div className="flex flex-wrap gap-2 text-xs">
            {job.steps.map((s) => {
              // Geplante Phasen ermitteln (neue Flags bevorzugt, sonst phases)
              const p = (job.parameters || {}) as Record<string, unknown>
              const hasNewFlags = typeof p['doExtractPDF'] === 'boolean' || typeof p['doExtractMetadata'] === 'boolean' || typeof p['doIngestRAG'] === 'boolean'
              const phases = hasNewFlags
                ? {
                    extract: p['doExtractPDF'] === true,
                    template: p['doExtractMetadata'] === true,
                    ingest: p['doIngestRAG'] === true,
                  }
                : ((p['phases'] as { extract?: boolean; template?: boolean; ingest?: boolean }) || {})

              const planned = (() => {
                const n = s.name
                if (n === 'extract_pdf') return phases.extract === true
                if (n === 'transform_template' || n === 'store_shadow_twin') return phases.template === true
                if (n === 'ingest_rag') return phases.ingest === true
                return false
              })()

              // Ampel-Status ableiten
              const skipped = !!(s as { details?: { skipped?: boolean } }).details?.skipped
              let icon = '○'
              let cls = 'text-muted-foreground'
              if (s.status === 'failed') { icon = '✕'; cls = 'text-red-600' }
              else if (s.status === 'running') { icon = '◐'; cls = 'text-yellow-600' }
              else if (s.status === 'completed') { icon = skipped ? '○' : '✓'; cls = skipped ? 'text-gray-400' : 'text-green-600' }
              else if (s.status === 'pending') { icon = planned ? '•' : '○'; cls = planned ? 'text-yellow-600' : 'text-muted-foreground' }

              const time = s.endedAt ? new Date(s.endedAt).toLocaleTimeString() : s.startedAt ? new Date(s.startedAt).toLocaleTimeString() : ''
              return (
                <div key={s.name} className={`inline-flex items-center gap-1 px-2 py-1 rounded border ${cls}`}>
                  <span>{icon}</span>
                  <span className="font-medium">{s.name}</span>
                  {time ? <span className="opacity-70">{time}</span> : null}
                </div>
              )
            })}
          </div>
        </div>
      )}

      {/* Metadaten (flach) – je nach sourceMode: nur Frontmatter oder Merge (nur außerhalb metaOnly-View) */}
      {viewMode !== 'metaOnly' && section === 'meta' && (() => {
        const base: Record<string, unknown> = sourceMode === 'frontmatter'
          ? {}
          : ((job?.cumulativeMeta as unknown as Record<string, unknown>) || {})
        const cm = frontmatterMeta ? { ...base, ...frontmatterMeta } : base
        const confidence: Record<string, unknown> = (() => {
          const raw = cm['confidence']
          if (raw && typeof raw === 'object') return raw as Record<string, unknown>
          if (typeof raw === 'string') { try { return JSON.parse(raw) as Record<string, unknown> } catch { /* ignore */ } }
          return {}
        })()
        const provenance: Record<string, unknown> = (() => {
          const raw = cm['provenance']
          if (raw && typeof raw === 'object') return raw as Record<string, unknown>
          if (typeof raw === 'string') { try { return JSON.parse(raw) as Record<string, unknown> } catch { /* ignore */ } }
          return {}
        })()
        const hasAnyConfidence = Object.keys(confidence).length > 0
        const baseKeys = Array.isArray(templateFields) && templateFields.length > 0
          ? Array.from(new Set([...(templateFields as string[]), ...Object.keys(cm)]))
          : Object.keys(cm)
        const flatKeys = baseKeys.filter(k => k !== 'chapters' && k !== 'toc' && k !== 'confidence' && k !== 'provenance')
        if (flatKeys.length === 0) return null
        return (
        <div>
          <div className="font-medium mb-1">Metadaten (Template vs. Ergebnis)</div>
          <div className="overflow-auto">
            <table className="w-full text-xs">
              <thead>
                <tr className="text-left text-muted-foreground">
                  <th className="py-1 pr-2 sticky left-0 bg-background z-10">Feld</th>
                  <th className="py-1 pr-2">Wert</th>
                  {hasAnyConfidence ? <th className="py-1 pr-2 text-right sticky right-0 bg-background border-l">Q</th> : null}
                </tr>
              </thead>
              <tbody>
                {flatKeys.map((k) => {
                  const val = cm[k]
                  let valueStr = ''
                  if (Array.isArray(val)) valueStr = (val as Array<unknown>).map(v => typeof v === 'string' ? v : JSON.stringify(v)).join(', ')
                  else valueStr = val === null || val === undefined ? '' : typeof val === 'string' ? val : JSON.stringify(val)
                  const hasNonEmptyValue = (() => {
                    if (val === null || val === undefined) return false
                    if (typeof val === 'string') return val.trim().length > 0
                    if (Array.isArray(val)) return (val as Array<unknown>).length > 0
                    if (typeof val === 'object') return Object.keys(val as Record<string, unknown>).length > 0
                    return true
                  })()
                  const cRaw = (confidence as Record<string, unknown>)[k]
                  const cNum = typeof cRaw === 'number' ? cRaw : (typeof cRaw === 'string' && /^\d+(\.\d+)?$/.test(cRaw) ? Number(cRaw) : undefined)
                  const pRaw = (provenance as Record<string, unknown>)[k]
                  const pStr = typeof pRaw === 'string' ? pRaw : pRaw ? JSON.stringify(pRaw) : ''
                  const color = cNum === undefined ? 'text-muted-foreground' : (cNum >= 0.8 ? 'text-green-600' : cNum >= 0.7 ? 'text-yellow-600' : 'text-red-600')
                  return (
                    <tr key={k} className="border-t border-muted/40">
                      <td className="py-1 pr-2 align-top font-medium sticky left-0 bg-background z-10 whitespace-nowrap">{k}</td>
                      <td className="py-1 pr-2 align-top">
                        {valueStr ? (
                          <TooltipProvider>
                            <Tooltip>
                              <TooltipTrigger asChild>
                                <span className="inline-block max-w-[40vw] overflow-hidden text-ellipsis whitespace-nowrap align-top" title="">
                                  {valueStr}
                                </span>
                              </TooltipTrigger>
                              <TooltipContent>
                                <div className="max-w-[80vw] whitespace-pre-wrap break-words">{valueStr}</div>
                              </TooltipContent>
                            </Tooltip>
                          </TooltipProvider>
                        ) : ''}
                      </td>
                      {hasAnyConfidence ? <td className="py-1 pr-2 align-top sticky right-0 bg-background border-l">
                        {(!hasNonEmptyValue || cNum === undefined) ? null : (
                          <TooltipProvider>
                            <Tooltip>
                              <TooltipTrigger asChild>
                                <span className={`inline-flex items-center justify-end w-full ${color}`} title={pStr || ''}>
                                  <span className="inline-block h-2 w-2 rounded-full bg-current" />
                                </span>
                              </TooltipTrigger>
                              <TooltipContent>
                                <div className="max-w-xs whitespace-pre-wrap break-words">
                                  <div className="font-medium">Confidence: {cNum.toFixed(2)}</div>
                                  {pStr ? <div className="mt-1 text-muted-foreground">Provenance: {pStr}</div> : null}
                                </div>
                              </TooltipContent>
                            </Tooltip>
                          </TooltipProvider>
                        )}
                      </td> : null}
                    </tr>
                  )
                })}
              </tbody>
            </table>
          </div>
        </div>
        )
      })()}

      {/* Kapitel (hierarchisch, TOC-Ansicht) – nur außerhalb metaOnly-View */}
      {viewMode !== 'metaOnly' && section === 'chapters' && (() => {
        const chapters: Array<Record<string, unknown>> = sourceMode === 'frontmatter'
          ? (Array.isArray(frontmatterMeta?.chapters) ? (frontmatterMeta?.chapters as Array<Record<string, unknown>>) : [])
          : ((job?.cumulativeMeta as unknown as { chapters?: Array<Record<string, unknown>> })?.chapters || [])
        if (!Array.isArray(chapters) || chapters.length === 0) return null

        const pad = (lvl: number | undefined): number => {
          if (typeof lvl !== 'number') return 0
          const clamped = Math.max(0, Math.min(3, lvl))
          return (clamped - 1) * 16 // px
        }

        // Hierarchische Nummerierung 1., 1.1, 1.1.1 basierend auf level
        const counters = [0, 0, 0]
        return (
        <div className="space-y-1">
          <div className="font-medium mb-1">Kapitel</div>
          <div>
            {chapters.map((c, i) => {
              const level = typeof c.level === 'number' ? c.level : 1
              const lvl = Math.max(1, Math.min(3, level))
              // Zähler aktualisieren
              counters[lvl - 1] += 1
              for (let j = lvl; j < counters.length; j++) counters[j] = 0
              const numLabel = counters.slice(0, lvl).filter(n => n > 0).join('.')
              const title = typeof c.title === 'string' ? c.title : ''
              const startPage = typeof c.startPage === 'number' ? c.startPage : ''
              
              const summaryVal = typeof c.summary === 'string' ? c.summary : ''
              const summary = summaryVal.length > 1000 ? `${summaryVal.slice(0, 1000)}…` : summaryVal
              const keywords = Array.isArray(c.keywords) ? (c.keywords as Array<unknown>).filter(v => typeof v === 'string') as string[] : []
              const ev = typeof c.startEvidence === 'string' ? c.startEvidence : ''
              return (
                <details key={`${title}-${i}`} className="group border-b py-1" open={false} onToggle={(e) => {
                  const open = (e.currentTarget as HTMLDetailsElement).open
                  if (open) {
                    if (startPage !== '') onJumpTo?.({ page: startPage as number | string })
                    else if (ev) onJumpTo?.({ evidence: ev })
                  }
                }}>
                  <summary className="list-none cursor-pointer">
                    <div className="flex items-start justify-between gap-3">
                      <div className="flex-1 min-w-0" style={{ paddingLeft: `${pad(lvl)}px` }}>
                        <div className="flex items-baseline gap-2">
                          <span className="text-xs text-muted-foreground tabular-nums">{numLabel}</span>
                          <span className="font-medium truncate">{title}</span>
                        </div>
                      </div>
                      <div className="text-xs tabular-nums text-muted-foreground whitespace-nowrap">
                        {String(startPage)}
                      </div>
                    </div>
                  </summary>
                  <div className="mt-1 pr-1 text-xs space-y-1" style={{ paddingLeft: `${pad(lvl) + 28}px` }}>
                    {summary && (
                      <div className="whitespace-pre-wrap break-words">
                        {summary}
                      </div>
                    )}
                    {Array.isArray(keywords) && keywords.length > 0 && (
                      <div className="flex flex-wrap gap-1">
                        {keywords.map(k => (
                          <span key={k} className="inline-flex items-center rounded px-1.5 py-0.5 bg-muted">{k}</span>
                        ))}
                      </div>
                    )}
                  </div>
                </details>
              )
            })}
          </div>
        </div>
        )
      })()}

      {/* Inhaltsverzeichnis */}
      {section === 'chapters' && (() => {
        const toc: Array<Record<string, unknown>> = sourceMode === 'frontmatter'
          ? (Array.isArray(frontmatterMeta?.toc) ? (frontmatterMeta?.toc as Array<Record<string, unknown>>) : [])
          : ((job?.cumulativeMeta as unknown as { toc?: Array<Record<string, unknown>> }).toc || [])
        if (!Array.isArray(toc) || toc.length === 0) return null
        return (
        <div>
          <div className="font-medium mb-1">Inhaltsverzeichnis</div>
          <div className="overflow-visible">
            <table className="w-full text-xs">
              <thead>
                <tr className="text-left text-muted-foreground">
                  <th className="py-1 pr-2">Titel</th>
                  <th className="py-1 pr-2">Seite</th>
                  <th className="py-1 pr-2">L</th>
                </tr>
              </thead>
              <tbody>
                {toc.map((t, i) => {
                  const title = typeof t.title === 'string' ? t.title : ''
                  const page = typeof t.page === 'number' ? t.page : ''
                  const level = typeof t.level === 'number' ? t.level : ''
                  return (
                    <tr key={`${title}-${i}`} className="border-t border-muted/40">
                      <td className="py-1 pr-2 align-top whitespace-pre-wrap break-words">{title}</td>
                      <td className="py-1 pr-2 align-top">{page}</td>
                      <td className="py-1 pr-2 align-top">{level}</td>
                    </tr>
                  )
                })}
              </tbody>
            </table>
          </div>
        </div>
        )
      })()}

      {viewMode === 'full' && job && job.ingestion && (
        <div>
          <div className="font-medium mb-1">Ingestion</div>
          <div className="text-xs text-muted-foreground">{job.ingestion.index || '—'} · Vektoren: {job.ingestion.vectorsUpserted ?? '—'} · {job.ingestion.upsertAt ? new Date(job.ingestion.upsertAt).toLocaleString() : '—'}</div>
        </div>
      )}

      {viewMode === 'full' && job && Array.isArray(job.logs) && job.logs.length > 0 && (
        <div>
          <div className="font-medium mb-1">Logs (neueste zuerst)</div>
          <ul className="space-y-0.5 max-h-48 overflow-auto">
            {[...job.logs].reverse().slice(0, 30).map((l, i) => (
              <li key={i} className="text-xs">
                {new Date(l.timestamp).toLocaleTimeString()} · {l.phase || '—'} · {typeof l.progress === 'number' ? `${l.progress}% · ` : ''}{l.message || ''}
              </li>
            ))}
          </ul>
        </div>
      )}

      {/* Parameter am Ende */}
      {viewMode === 'full' && job && job.parameters && (
        <div>
          <div className="font-medium mb-1">Parameter</div>
          <pre className="bg-muted/40 rounded p-2 max-h-32 overflow-auto whitespace-pre-wrap break-words">{JSON.stringify(job.parameters, null, 2)}</pre>
        </div>
      )}
    </div>
  )
}



```

- Vermutung bestätigt: Doppelte Loads konnten durch zwei Ursachen entstehen:
  - In `JobReportTab` wurde trotz `sourceMode="frontmatter"` zusätzlich nach einem Job gesucht.
  - Frontmatter-Datei wurde mehrfach neu geladen, weil die Effekt-Dependencies breit waren.

- Änderungen:
  - `src/components/library/job-report-tab.tsx`
    - Überspringt die Job-Suche vollständig, wenn `sourceMode='frontmatter'` und entweder `rawContent` oder `mdFileId` vorhanden ist. Dadurch keine doppelten Requests bei Shadow‑Twin-Ansicht.
    - Einheitliche Ableitung `effectiveMdId` (bevorzugt `mdFileId`, sonst `job.result.savedItemId`, sonst `fileId`) und als einzige Dependency für das Laden der Markdown/Frontmatter verwendet. Reduziert unnötige Re‑Loads.
  - `src/components/library/pdf-phases-view.tsx`
    - Unverändert; lädt den Shadow‑Twin einmal per Provider und reicht `mdFileId` weiter. Das triggert jetzt keine zusätzliche Job‑Suche mehr.

- Testhinweis:
  - Datei in der Liste per Maus wechseln, JobMonitor offen lassen.
  - Beobachten: In der Netzwerk‑Konsole sollte pro Wechsel genau ein GET für die Markdown‑Datei erfolgen, keine redundanten Job‑Queries.
  - Tabs „Markdown/Metadaten/Kapitel/Prozessinfo“ umschalten: kein erneutes Laden, nur UI‑Wechsel.

---

**User**

Ich habe hier einen Job, der vom Secretary Service einen Fehler generiert, aber nicht als Fehler erkannt wird. Liegt das Problem beim Secretary Service oder haben wir irgendwas übersehen?

{
  "_id": {
    "$oid": "68cfe18fa4dc35283651a73b"
  },
  "jobId": "5d253621-f9df-4e72-9585-4f441331bd17",
  "jobSecretHash": "ab4ba28583fcce3bb03810c98e1228140fc6b96c22040fdbbf1b2100f8e3f251",
  "job_type": "pdf",
  "operation": "extract",
  "worker": "secretary",
  "status": "completed",
  "libraryId": "8a9eda76-90a2-414c-9d85-a3225ffcf249",
  "userEmail": "peter.aichner@crystal-design.com",
  "correlation": {
    "jobId": "5d253621-f9df-4e72-9585-4f441331bd17",
    "libraryId": "8a9eda76-90a2-414c-9d85-a3225ffcf249",
    "source": {
      "mediaType": "pdf",
      "mimeType": "application/pdf",
      "name": "Hellrigl_2008_FaunistikDerGallwespenVonSüdtirol-Trentino_ForestObserver_4_p.pdf",
      "itemId": "RmFjaGFydC9aZWl0c2NockJaL0ZvcmVzdCBPYnNlcnZlci8yMDA4L0hlbGxyaWdsXzIwMDhfRmF1bmlzdGlrRGVyR2FsbHdlc3BlblZvblPDvGR0aXJvbC1UcmVudGlub19Gb3Jlc3RPYnNlcnZlcl80X3AucGRm",
      "parentId": "RmFjaGFydC9aZWl0c2NockJaL0ZvcmVzdCBPYnNlcnZlci8yMDA4"
    },
    "options": {
      "targetLanguage": "de",
      "extractionMethod": "mistral_ocr",
      "includeImages": false,
      "useCache": true
    },
    "batchId": "a908e6af-0e22-4b8c-a390-b9e48207654d",
    "batchName": "Fachart/ZeitschrBZ/Forest Observer/2008"
  },
  "createdAt": {
    "$date": "2025-09-21T11:29:19.287Z"
  },
  "updatedAt": {
    "$date": "2025-09-21T11:29:57.002Z"
  },
  "steps": [
    {
      "name": "extract_pdf",
      "status": "pending"
    },
    {
      "name": "transform_template",
      "status": "completed",
      "startedAt": {
        "$date": "2025-09-21T11:29:53.894Z"
      },
      "endedAt": {
        "$date": "2025-09-21T11:29:54.345Z"
      }
    },
    {
      "name": "store_shadow_twin",
      "status": "completed",
      "startedAt": {
        "$date": "2025-09-21T11:29:54.376Z"
      },
      "endedAt": {
        "$date": "2025-09-21T11:29:54.490Z"
      }
    },
    {
      "name": "ingest_rag",
      "status": "completed",
      "startedAt": {
        "$date": "2025-09-21T11:29:56.705Z"
      },
      "details": {
        "skipped": true
      },
      "endedAt": {
        "$date": "2025-09-21T11:29:56.735Z"
      }
    }
  ],
  "parameters": {
    "targetLanguage": "de",
    "extractionMethod": "mistral_ocr",
    "includeImages": false,
    "useCache": true,
    "template": "pdfanalyse",
    "doExtractPDF": true,
    "doExtractMetadata": true,
    "doIngestRAG": false,
    "forceRecreate": false,
    "forceTemplate": false,
    "batchId": "a908e6af-0e22-4b8c-a390-b9e48207654d",
    "batchName": "Fachart/ZeitschrBZ/Forest Observer/2008"
  },
  "logs": [
    {
      "timestamp": {
        "$date": "2025-09-21T11:29:22.024Z"
      },
      "phase": "request_sent_requeue",
      "callbackUrl": "http://localhost:3000/api/external/jobs/5d253621-f9df-4e72-9585-4f441331bd17"
    },
    {
      "timestamp": {
        "$date": "2025-09-21T11:29:22.528Z"
      },
      "phase": "request_ack",
      "status": 202,
      "statusText": "ACCEPTED"
    },
    {
      "timestamp": {
        "$date": "2025-09-21T11:29:52.460Z"
      },
      "phase": "running",
      "progress": 90,
      "message": "Mistral-OCR: Verarbeitung abgeschlossen - Args: {\"progress\": 90}"
    },
    {
      "timestamp": {
        "$date": "2025-09-21T11:29:52.582Z"
      },
      "phase": "running",
      "progress": 85,
      "message": "Mistral-OCR: Ergebnis geparst (142 Seiten) - Args: {\"progress\": 85}"
    },
    {
      "timestamp": {
        "$date": "2025-09-21T11:29:52.663Z"
      },
      "phase": "postprocessing",
      "progress": 95,
      "message": "Ergebnisse werden gespeichert"
    },
    {
      "timestamp": {
        "$date": "2025-09-21T11:29:52.752Z"
      },
      "phase": "running",
      "progress": 85,
      "message": "Mistral-OCR: Ergebnis geparst (142 Seiten) - Args: {\"progress\": 85}"
    },
    {
      "timestamp": {
        "$date": "2025-09-21T11:29:52.916Z"
      },
      "phase": "running",
      "progress": 90,
      "message": "Mistral-OCR: Verarbeitung abgeschlossen - Args: {\"progress\": 90}"
    },
    {
      "timestamp": {
        "$date": "2025-09-21T11:29:53.103Z"
      },
      "phase": "running",
      "progress": 90,
      "message": "Mistral-OCR: Verarbeitung abgeschlossen - Args: {\"progress\": 90}"
    },
    {
      "timestamp": {
        "$date": "2025-09-21T11:29:53.364Z"
      },
      "phase": "postprocessing",
      "progress": 95,
      "message": "Ergebnisse werden gespeichert"
    },
    {
      "timestamp": {
        "$date": "2025-09-21T11:29:53.909Z"
      },
      "phase": "transform_meta_failed",
      "message": "Transformer lieferte kein gültiges JSON"
    },
    {
      "timestamp": {
        "$date": "2025-09-21T11:29:54.123Z"
      },
      "phase": "stored_local",
      "message": "Shadow‑Twin gespeichert"
    },
    {
      "timestamp": {
        "$date": "2025-09-21T11:29:54.288Z"
      },
      "phase": "transform_meta_failed",
      "message": "Transformer lieferte kein gültiges JSON"
    },
    {
      "timestamp": {
        "$date": "2025-09-21T11:29:56.968Z"
      },
      "phase": "completed",
      "message": "Job abgeschlossen"
    },
    {
      "timestamp": {
        "$date": "2025-09-21T11:29:54.490Z"
      },
      "phase": "stored_local",
      "message": "Shadow‑Twin gespeichert"
    },
    {
      "timestamp": {
        "$date": "2025-09-21T11:29:57.158Z"
      },
      "phase": "completed",
      "message": "Job abgeschlossen"
    }
  ],
  "processId": "job-0e1cbed3-ee85-4721-8649-3a06a952d250",
  "metaHistory": [
    {
      "at": {
        "$date": "2025-09-21T11:29:53.727Z"
      },
      "meta": {
        "template_used": "pdfanalyse.md"
      },
      "source": "template_pick"
    },
    {
      "at": {
        "$date": "2025-09-21T11:29:53.909Z"
      },
      "meta": {
        "text_contents": []
      },
      "source": "template_transform"
    },
    {
      "at": {
        "$date": "2025-09-21T11:29:54.145Z"
      },
      "meta": {
        "template_used": "pdfanalyse.md"
      },
      "source": "template_pick"
    },
    {
      "at": {
        "$date": "2025-09-21T11:29:54.288Z"
      },
      "meta": {
        "text_contents": []
      },
      "source": "template_transform"
    }
  ],
  "cumulativeMeta": {
    "template_used": "pdfanalyse.md",
    "text_contents": []
  },
  "payload": {
    "extracted_text": "--- Seite 1 ---\nAutonome Provinz Bozen-Südtirol Provincia Autonoma di Bolzano-Alto Adige Abteilung Forstwirtschaft - Ripartizione Foreste\n\n# forest observer \n\n![img-0.jpeg](img-0.jpeg)\nvol. 42008\n\n--- Seite 2 ---\n# Impressum \n\n![img-1.jpeg](img-1.jpeg)\n\n| Editor in chief |\n| :--: |\n| Paul Profanter |\n| Direktor Abteilung Forstwirtschaft |\n| I-39100 Bozen $\\cdot$ Brennerstr. 6 |\n\n\n| Redaktion: |\n| :--: |\n| Managing Director |\n| Florian Blaas |\n| Direktor Amt für Forstverwaltung |\n| I-39100 Bozen $\\cdot$ Brennerstr. 6 |\n| Koordinator |\n| Stefano Minerbi |\n| Amt für Forstverwaltung |\n| I-39100 Bozen $\\cdot$ Brennerstr. 6 |\n| Beratung |\n| Cristina Salvadori |\n| Istituto Agrario di S. Michele a /A, |\n| Unità operativa - Foreste, |\n| I-38010 S. Michele $\\cdot$ Via E. Mach 2 |\n| Schriftleiter |\n| Klaus Hellrigl |\n| I-39042 Brixen $\\cdot$ Wolkensteinstraße 83 |\n\n\n| Layout \\& Grafik |\n| :--: |\n| Helga Veleba |\n| Brixen/Wien |\n\n\n| Druck |\n| :--: |\n| KARO-Druck |\n| Eppan |\n\n\n| Editor in chief |\n| :--: |\n| Paul Profanter |\n| Direttore Ripartizione Foreste |\n| I-39100 Bolzano $\\cdot$ Via Brennero 6 |\n\n\n| Redazione: |\n| :--: |\n| Managing Director |\n| Florian Blaas |\n| Direttore Ufficio amministrazione forestale |\n| I-39100 Bolzano $\\cdot$ Via Brennero 6 |\n| Coordinatore |\n| Stefano Minerbi |\n| Ufficio amministrazione forestale |\n| I-39100 Bolzano $\\cdot$ Via Brennero 6 |\n| Consulenza |\n| Cristina Salvadori |\n| Istituto Agrario di S. Michele a /A, |\n| Unità operativa - Foreste, |\n| I-38010 S. Michele $\\cdot$ Via E. Mach 2 |\n| Redattore incaricato |\n| Klaus Hellrigl |\n| I-39042 Bressanone $\\cdot$ Via Wolkenstein 83 |\n\n\n| Layout \\& Grafica |\n| :--: |\n| Helga Veleba |\n| Bressanone/Vienna |\n\n\n| Stampa |\n| :--: |\n| KARO-Druck |\n| Appiano |\n\nCopyright: © Landesforstdienst / Servizio Forestale provinciale\nAbteilung 32 Forstwirtschaft / Ripartizione 32 Foreste\nCover picture: Erbsengallen (\"Smooth Pea-galls\") der \"Weinrosen-Gallwespe\" Diplolepis eglanteriae (Hartig 1840) Südtirol: Aicha-Spinges, 19.06.2008, an Blättern von Wildrose Rosa sp. (Foto K. Hellrigl).\n\n--- Seite 3 ---\n# Faunistik der Gallwespen von Südtirol-Trentino (Hymenoptera: Cynipoidea) \n\nKlaus Hellrigl\n\n\n#### Abstract\n\nFaunistics of gall-wasps (Hymenoptera, Cynipoidea) from South Tyrol and Trentino (N-Italy). The author gives a survey on the occurrence of gall wasps in the two Regional Provinces of South Tyrol and Trentino, respectively. The main treatment relates to the typical gall formations of the single species that are described and, for the most part, illustrated. In all, 151 species are treated; of these, 103 species are recorded from the Region: 73 species occur in South Tyrol and 76 species in Trentino (Tab. 2). In addition, some 50 species are indicated in order to evaluate further possible presences in South Tyrol-Trentino. The material primarily is based on the evaluation and re-elaboration of older published references, like the 16 records of species mentioned by Dalla Torre (1892-1896) in Cecidien Tirols, as well as Bezzi (1899: Cecidiologia Trentina) and Cobelli (1903: Imenotteri del Trentino) with 24 species on the area of Trentino (Tab. 1). To this are added subsequent records for 12 species from South Tyrol given by Hellrigl (1984, 1997): Ibalia leucospoides, Andricus caputmedusae, A. fecundator, A. inflator, A. kollari, A. quercustozae, Biorhiza pallida, Cynips quercusfolii, Diplolepis rosae, Isocolus scabiosae, Neuroterus numismalis, N. quercusbaccarum. During the last 5 years, 2004-2008, the Author employed extensive, carefully directed investigations on Cynipidae galls in South Tyrol and Trentino, which resulted in many new findings and more than a doubled the number of recorded species for the whole Region from 41 to the present 103 species. Besides, some 4,500 specimens of galls where measured and their registered dimensions illustrated graphically (Graphics 1-9). Included in the investigations were also two regional forestry areas of an international \"Integrated Monitoring-Programm\" with the sites of \"Quercetumpubescentis\" in Montiggl (IT-02) near Kaltern/Caldaro (BZ) and in Pomarolo (IT-04) near Rovereto (TN), respectively. Ten species, formerly recorded only by Dalla Torre (1892-96): Andricus ostreus, Andricus solitarius, Cynips agama, Cynips cornifex, Cynips quercus, Diplolepis mayri, Diplolepis spinosissimae, Liposthenes glechomae, Trigonaspis synaspis, Synergus physoceras - were confirmed by recent findings. Another 48 species were newly recorded for South Tyrol: Andricus aries, A. burgundus, A. callidoma, A. conglomeratus, A. coriarius, A. corruptrix, A. curvator, A. glandulae, (A. globuli), A. infectorius, A. legitimus, A. lignicolus, A. paradoxus, A. polycerus, A. pseudoinflator, A. quercuscalicis, A. quercusradicis, A. quercusramuli, Aulacidea hieracii, Aylax minor, Aylax papaveris, Ceroptres claviconis, Cynips disticha, Diastrophus rubi, Diplolepis eglanteriae, Dryocosmus kuriphilus, Neuroterus albipes, N. aprilinus, N. tricolor, Pseudoneuroterus macropterus, Phanacis hypochoeridis, Periclistus brandtii, Synergus apicalis, S. clandestinus, S. crassicornis, S. gallaepomiformis, S. hayneanus, S. pallicornis, S. pallipes (= albipes, nervosus), S. reinhardi, S. thaumacerus, S. umbraculus, Xestophanes potentillae, plus another six parasitic Figitidae. 52 species were newly recorded for Trentino: Andricus amblycerus, A. amenti (= giraudianus), A. caliciformis, A. caputmedusae, A. conglomeratus, A. conificus, A. coriarius, A. corruptrix, A. cydoniae, A. fecundator, A. galeatus, A. gallaeurnaeformis, A. gemmeus, A. grossulariae (=A. mayri + panteli), A. infectorius, A. inflator (= globuli), A. lignicolus, A. lucidus (=aestivalis), A. multiplicatus, A. polycerus, A. quercustozae, A. seckendorffi, A. solitarius, A. truncicolus, Aphelonyx cerricola, Aylax minor, Callirhytis glandium, C.rufescens, Cynips agama, C. cornifex, C. quercus, Dryocosmus kuriphilus, Neuroterus albipes, N. anthracinus, N. aprilinus, N. minutulus, N. numismalis, N. saliens, N. tricolor, Pseudoneuroterus macropterus, Plagiotrochus australis, Synophrus politus, Trigonaspis synaspis, Ceroptres cerri, Ceroptres clavicornis, Synergus apicalis, S. hayneanus, S. pallicornis, S. pallidipennis, S. pallipes, S. thaumacerus, S. umbraculus. Formerly 24 species had been recorded for each of the Provinces of Trentino and Bozen-South Tyrol. The present investigation enabled a triplication of the number of species recorded, reaching 76 species in Trentino, and 73 species in South Tyrol (cfr. Tab. 2). Of considerable importance for the larger richness of Oak-gallwasp species in Trentino is the wide-spread presence in that Province of Turkey oak (Quercus cerris), which is the natural sexual-generation host for many Oak-gallwasp species, whereas this host is almost absent in South Tyrol. (cfr. Tab. 3).\n\n--- Seite 4 ---\n# 1 Einleitung \n\nDie Cynipoidea bilden eine artenreiche Überfamilie, die neben phytophagen Erregern und Inquilinen von Pflanzengallen auch zahlreiche zoophage Parasitoiden umfaßt. Die parasitoide Lebensweise ist dabei als die ursprünglichere anzusehen (KaestNER 2003) und betrifft etwa die Hälfte der bisher weltweit bekannten rd. 3300 Arten (Gauld \\& Bolton 1996).\n\nDie systematische Einteilung und Zuordnung zu den einzelnen Familien ist derzeit noch umstritten. Insgesamt scheint die Gruppierung eher durch die Lebensweise als durch morphologische Merkmale definiert zu werden (Kaestner 2003). Einig sind sich die Autoren derzeit nur über zwei Familien: die Ibaliidae, eine artenarme, endoparasitisch bei Holzwespen (Siricidae) lebende Gruppe, und die artenreiche Familie Cynipidae oder \"Gallwespen im engeren Sinne\", welche alle phytophagen gallenbildenden Arten und deren Inquilinen umfaßt (weltweit ca. 1400 Arten).\nUmstritten ist hingegen die Einteilung und Zuordnung der übrigen zu den Cynipoidea gerechneten Familien, die ausschließlich zoophage parasitoide Formen umfassen. Die artenreichste Familie unter ihnen bilden die Figitidae (weltweit ca. 1400 Arten), welche Parasitoide von gallbildenden Cynipidae, von Neuropteren, Dipteren u.a. sind (Kaestner 2003). Zu ihnen werden heute vielfach auch einbezogen die früher oft als eigene Familien geführten Anacharitidae (Parasitoide von Neuropteren: Hemerobiidae), Eucoilidae (Endoparasiten bei Dipteren) sowie Charipidae (= Alloxystidae) als Hyperparasitoide von Blattläusen (vgl. Gauld \\& Bolton 1996; Nieves-Aldrey 2001).\nBei der vorliegenden Betrachtung folgen wir dem System, welches sich im vorzüglichen Werk der \"Fauna Iberica\" (Nieves-Aldrey 2001) sowie bei „UK Species Checklist for Cynipoidea\" (2004) findet und das die Cynipoidea in 3 Familien unterteilt: die phytophagen Cynipidae (Gallenbildner und Inquilinen) sowie die zoophagen Ibaliidae (parasitisch an Holzwespenlarven) und Figitidae (parasitisch an Dipterenlarven).\n\nZu den Cynipidae und den von ihnen bzw. ihren Larven hervorgerufenen Gallenbildungen an verschiedenen Pflanzen (bei deutlicher Bevorzugung von Quercus- und Rosa-Arten) und Pflanzenteilen (Blätter, Knospen, Stängel, Wurzeln u.a.) ist noch folgendes zu bemerken: Die Gallen sind meist von sehr charakteristischer, arttypischer Form und daher leicht zu erkennen. Früher wurden sogar oftmals Arten nur nach ihrer typischen Gallenform beschrieben und benannt, was bis zum Jahre 1930 zulässig und gültig war (ICZN, Art. 72.5). Dabei gibt es unter den Gallenbildnern an Eichen viele Arten mit Wechsel zwischen sexueller und agamer (parthenogenetischer) Generation (Heterogonie), wobei die jeweilige Generation unterschiedliche Gallen ausbildet, oft an verschiedenen Pflanzenteilen derselben Wirtspflanze, oder gar in Form eines Wirtswechsels an anderen Wirtspflanzen (Heterözie). Solche heterogenen Arten mit zyklischer Parthenogenese ( $\\mathrm{CP}=$ cyclical parthenogenesis) sind oftmals auch unter verschiedenen Namen bekannt, wie etwa die „Eichenbeeren-Gallwespe\" Neuroterus quercusbaccarum (= bisexuelle Form: ㅇ) an Blütenkätzchen und die „Eichenlinsen-Gallwespe\" Neuroterus lenticularis (= agame Form: ㅇ) an Blättern; dabei ist der jeweils ältere Namen wissenschaftlich priororitätsberechtigt. Als Inquilinen unter den Cynipidae sind hingegen die Vertreter der Tribus Synergini mit den Gattungen Ceroptres, Periclistus, Saphonecrus und Synergus bekannt. Die Bezeichnung Inquilinen bzw. „Einmieter\" oder „Einmietler\" ist dabei weniger harmlos als sie klingen mag, denn ihr Raumparasitismus führt in der Regel zum Tode der gallenbildenden ursprünglichen Gallwespenlarve.\nUnter den verschiedenen Gallenbildnern stellen die Gallwespen eine wesentliche, markante Gruppe. Ein Überblick über weitere Gruppen von tierischen Gallenbildnern (Zoocecidien) - wie vor allem Gallmilben, Gallmücken, Gallenläuse und Blattwespengallen - und deren Vorkommen in Südtirol, wird in einer gesonderten Arbeit gegeben, in der auch die historische Entwicklung der Gallenkunde (Cecidologie) dargestellt wird (vgl. Hellrigl 2008b).\n\n--- Seite 5 ---\n# 2 Zielsetzung, Material und Methode \n\nZielsetzung der vorliegenden Studie war, eine Übersicht zu erlangen über den aktuellen Kenntnisstand der Vorkommen von Gallwespen in der Region Südtirol-Trentino. Ausgangspunkt waren dabei die typischen Gallenbildungen der einzelnen Arten, anhand deren diese relativ sicher erkennbar sind. Das zugrunde liegende Material stützt sich zunächst auf die Auswertung vorhandener Literaturangaben. Für Südtirol waren dies vor allem die alten Fundangaben von Dalla Torre (1892-1896) über „die Cecidien Tirols\", mit 25 Arterwähnungen - davon 16 aus Südtirol. Für das angrenzende Gebiet von Trentino wurden in den Arbeiten von Bezzi (1899: Cecidiologia Trentina) und Cobelli (1903: Imenotteri del Trentino) insgesamt 23 Gallwespenarten behandelt (Tab. 1). An neueren Quellen lagen nach eigenen Beobachtungen 12 Artangaben aus Südtirol vor: Hellrigl (1996: Tierwelt Südtirols). Der Ausgangsstand zu Beginn der vorliegenden Studie betraf somit insgesamt 41 Cynipiden aus der ganzen Region, davon jeweils 24 Arten aus Südtirol und für Trentino (vgl. Tab. 2).\nMit der systematischen Erhebung von GallwespenGallen war im Sommer/Herbst 2004 begonnen worden, wobei von Juli/Aug. bis Okt./Nov. zahlreiche Gallen gesammelt und in Aufzucht genommen wurden. Die Freilanderhebungen wurden im März/ April 2005 wieder aufgenommen und in den Folgejahren jeweils über die ganze Saison fortgesetzt, mit Abschluß im Dezember 2008. Ein weiteres Ziel der Untersuchungen war, durch Aufzuchten unter Freilandbedingungen (Überwinterung im Freien) neue Erkenntnisse zu gewinnen über die Bionomie der Gallwespen und ihrer Synergisten und Parasitoiden. Die Freilanderhebungen im Trentino erfolgten teilweise in Zusammenarbeit mit den dortigen Kollegen Dr. Paolo Ambrosi und Dr. Cristina Salvadori (Istituto Agrario S. Michele), jene in Bozen mit Dr. Stefano Minerbi (Landesforstinspektorat) und Förster Alberto Fostini (Forststation Kaltern). Bei den Felderhebungen der Jahre 2005/06 waren auch die Gallen-Spezialisten Dr. Heiko Bellmann und Dipl.-Biol. Ralf Lauterbach (Univ. Ulm) mehrmals beteiligt; desgleichen 2006/08 mein langjähriger Mitarbeiter Georg v.Mörl und 2008 wiederholt auch Klaus Schanung (Brixen).\n\nDie Bestimmung der gesammelten Gallen, die durchwegs auch fotografisch dokumentiert wurden, erfolgte mittels der zitierten einschlägigen Fachliteratur, insbesondere den Standardwerken von Buhr (1965) und Nieves-Aldrey (2001), jene der gezogenen Imagines - Gallenbildner und Inquilinen - mit den Bestimmungstabellen von Dalla Torre \\& Kieffer (1910) und Nieves-Aldrey (2001). Die zahlreichen aus Gallen geschlüpften Parasitoiden (vor allem Chalcidoidea: Eurytomidae, Torymidae, Ormyridae, Pteromalidae, Eupelmidae, Eulophidae) konnten bisher erst zum Teil bestimmt werden. Gallen und Zuchtmaterial sind in coll. Hellrigl (Brixen) aufbewahrt.\nDie Anzahl erfaßter Gallwespen (Cynipoidea) für die Region Trentino-Südtirol konnte auf 103 Taxa angehoben werden: 1 Ibaliidae +72 Gallenbildner +16 Synergisten +14 parasitoide Figitidae. Von diesen Arten sind 62 Neufunde für die Region. Für Südtirol und Trentino sind nunmehr jeweils 73 bzw. 76 Arten bekannt, davon zwei Drittel Neumeldungen.\nTrotz dieser erheblichen Verbessung des Kenntnisstandes blieben einige weitere Gallwespenarten, für die Vorkommen in unserer Region zu erwarten sind, weiterhin unerfasst. Zur Erleichterung künftiger Beobachtungen und Anregung zu gezielter Suche, wurden in der vorliegenden Studie neben den bisher erfassten Arten noch rd. 50 weitere Taxa mit angeführt und besprochen; davon könnten einige für hier noch zu erwarten sein, während die übrigen zur Unterscheidung und Abgrenzung genannt werden. Die Nummern und Namen der noch nicht nachgewiesenen Arten sind in eckigen Klammern gesetzt.\nAls Grundlage für die aktualisierte Nomenklatur und Synonymie wurde der \"Fauna Iberica\" von NievesAldrey (2001) sowie im Internet der Fauna Europaea (2005/07) gefolgt. Die englische Bezeichnung der Gallennamen erfolgte nach UK-Checklist for Cynipoidea. Ein besonderes Augenmerk wurde auf Synonymie-Angaben gelegt, da diesbezüglich auch noch in rezenten Arbeiten, wie etwa der Checklist Italiens (Pagliano 1995), einige Verwirrung und Doppelgleisigkeit herrscht.\n\n--- Seite 6 ---\nGrößter Wert wurde auf eine reichhaltige Bebilderung gelegt; diese dient einerseits der faunistischen Dokumentation und andererseits der Illustration zur Erkennung der diversen Gallenformen. Die Bilder zur regionalen Dokumentation stammen fast ausschließlich vom Verfasser selbst; jene zur Illustration von Arten die in der Region bisher fehlten, wurden von jeweils genannten Bildautoren, insbesondere Dr. Heiko Bellmann (Ulm) und Dr. Hans-Jürgen BuHR (Berlin) zur Verfügung gestellt.\n\nMit dem vorliegenden Bericht über heimische „Gallwespen\" - dem bereits Neubearbeitungen über „Gallmücken\" (SkuhravÁ, Skuhravy \\& Hellrigl 2001),,Gallmilben\"(Hellrigl 2003/06) sowie „Gallenläuse\" (Hellrigl 2004/06) und Blattwespengallen (Hellrigl 2006) vorangegangen waren - wird die Würdigung und Revision der Cecidien-Trilogie von Dalla Torre (1892-96), über die bedeutendsten Gruppen gallenbildender Arthropoden in Tirol, vervollständigt und vorerst abgeschlossen.\n\nTab. 1: Übersicht der früheren Meldungen aus Trentino: Bezzi (1899) und Cobelli (1903)\n\n| Artnamen: valid name | Bezzi 1899: TN | Cobelli 1903: TN | sonstige: |\n| :--: | :--: | :--: | :--: |\n| Fam. Cynipidae |  |  |  |\n| Andricus curvator | A. curvator: (1) | A. curvator |  |\n| Andricus glandulae | - | A. glandulae |  |\n| Andricus kollari | Cynips kollari: (2) | Cynips kollari |  |\n| Andricus quercuscalicis | - | Cynips calicis |  |\n| Andricus quercusradicis | - | A. trilineatus |  |\n| Biorhiza pallida | Biorrhiza terminalis: (2) | B. terminalis |  |\n| Diastrophus rubi | Diastrophus rubi: (1) | Diastroph. rubi: (Bezzi) |  |\n| Diplolepis eglanteriae | Rhodites eglanteriae: (2) | Rhodites eglanteriae |  |\n| Diplolepis nervosus | Rhodites rosarum: (4) | Rh. rosarum: (Bezzi) |  |\n| Diplolepis rosae | Rhodites rosae: TN | Rh. rosae |  |\n| Diplolepis spinosissimae | Rhodit. spinosissimae: (1) | Rh. spinosissimae: (Bezzi) |  |\n| Dryocosmus nervosus | - | Dryocosmus nervosus |  |\n| Neurot. quercusbaccarum | Neurot. baccarum: (1) <br> = N. lenticularis: $(1,3)$ | Neurot. baccarum: (Bezzi) <br> $=$ N. lenticularis: (Bezzi) |  |\n| Synerg. gallaepomiformis | - | Synergus vulgaris |  |\n| Synergus reinhardi | - | Synergus reinhardi |  |\n| Trigonaspis megaptera | - | Trigonaspis megaptera |  |\n| Fam. Ibaliidae |  |  |  |\n| Ibalia leucospoides | - | - | MADL 1992: TN |\n| Fam. Figitidae |  |  |  |\n| Eucoila floralis Dahlb. | - | Eucolia floralis Dahlb. | fehlt: Pagliano i.l. 2004 |\n| Eucoila maculata | - | Eucolia maculata |  |\n| Figites coriaceus Dahlb. | - | Figites coriaceus Dahlb. [? = Figites nitens Hartig] | fehlt: Pagliano i.l. 2004 <br> sensu Pagliano i.l. 2004 |\n| Figites scutellaris | - | Figites scutellaris |  |\n| Trybliographa rapae | - | Eucolia insignis |  |\n| Trybliogr. subnebulosa | - | Eucolia subnebulosa |  |\n| Trybliographa trichopsila | - | Eucolia trichopsila |  |\n| SUMME: 24 Arten | 9 Arten | 23 Arten | 1 Art |\n\n--- Seite 7 ---\n(Tab.1) Die nach älteren Angaben aus Trentino erfassten 24 Arten Cynipoidea, werden hier dargestellt:\nFundortangaben aus Trentino bei Bezzi (1899):\n(1) Mollaro /Val di Non. - (2) Cusiano/Val di Sole. - (3) Rovereto Finonchio. - (4) Bordala Vallagarina (= Isera/Rovereto). -\nFundortangaben Trentino bei Cobelli (1903): Keine näheren Angaben; teilw. zitiert nach Bezzi (= Bz).\n\n## Anmerkung:\n\nAus Trentino wurden an Gallwespen bisher nur die älteren Angaben von BeZZI (1899), mit 9 Arten, und von Cobelli (1903), mit 23 Arten, bekannt - sowie eine rezentere Artangaben von MadL (1992) nach G. Pagliano (i. litt. 2004). - Davon sind 2 Artangaben von Cobelli (1903)\nfraglich, Eucolia floralis Dahlb. und Figites coriaceus Dahlb., da diese Arten nur aus Schweden bekannt sind und fraglich aus Österreich. - Beide Arten wurden 1846 beschrieben von Andreas Gustav DahlbOM (1808-1859), Professor für Entomologie in Lund (Schweden). Die fragliche Patria-Angabe \"? Austria\" in Fauna Europaea, bezieht sich offenbar auf diese Angaben von Cobelli (1903) aus Trentino, welches ja bis 1918 noch zu Österreich gehörte. - In Checklist Ital. (Pagliano 1995) fehlen diese beiden Arten; auch in der von G. Pagliano mitgeteilten Trentino-Artenliste (i. lit. 15.07.2004) fehlt Eucoila floralis Dahlb. 1846, während anstatt Figites coriaceus Dahlb. 1846 (s. Cobelli 1903) eine Figites nitens Hartig genannt wird; diese letztere soll aber nach Fauna Europaea (Database 2007) nur in Deutschland und (fraglich) in N-Europa (? Finnland,? Schweden, ? Rußland) vorkommen und in Italien fehlen; die Angaben Cobelli's bleiben fraglich.\n\n# 3 Erforschungsgrad der Gallwespen in Italien und Trentino-Südtirol \n\nDer Erforschungsgrad der Gallwespen in Italien ist derzeit noch unzureichend und lückenhaft. In der Checklist der Fauna Italiens (Pagliano 1995) werden aus Italien 174 Arten Cynipoidea angeführt, doch beruhen diese Angaben größtenteils auf älteren Literaturquellen, wie De Stefani (1894-1897) aus Sizilien, Massalongo (1891-1896) aus dem Veneto, sowie GrAFFE (1905) aus der Umgebung von Triest. ,,Dall'inizio del secolo nessun entomologo italiano si è occupato di questa superfamiglia sotto il profilo tassonomico e faunistico\"(PaGliano 1995). Während aus Sizilien immerhin 80 Arten angeführt werden, sind es aus Sardinien gar nur 2 Arten: Andricus theophrasteus (Trotter 1902) sowie der dortige Endemit Liebelia cavarai Kieffer 1903; dies weist auf ein regionales Missverhältnis hin. Unter diesen Voraussetzungen ist es erstaunlich, dass in der Checklist Italiens (1995) überhaupt so viele Arten zusammenkamen. Allerdings sind davon 23 Arten (Cynipidae) zu streichen, da es sich um doppelt erwähnte Synonyme handelt. Die effektive Artenzahl Italiens - nach dem berichtigten Stand von 1995 - beläuft sich somit auf rd. 150 Cynipoidea. Davon entfallen (nach neuer Einteilung)\nauf: Ibaliidae 2 Arten (1,3\\%), Cynipidae 125 Arten (82,7\\%), und Figitidae 24 Arten (16\\%).\nEin Vergleich mit \"Fauna Iberica\" (NievesAldrey 2001), in der aus Spanien insgesamt 290 Cynipoidea angegeben werden: Ibaliidae 1 Art ( $0,3 \\%$ ), Cynipidae 140 Arten ( $48,3 \\%$ ), und Figitidae 150 Arten ( $51,7 \\%$ ), verdeutlicht, dass das große Erfassungsdefizit bei den Gallwespen Italiens vor allem bei den parasitisch lebenden Figitidae liegt, deren Anteil in Spanien über die Hälfte der Gallwespenarten beträgt, hingegen in Italien bislang nur bei $16 \\%$ liegt. Dies bestätigt auch ein Vergleich mit der Fauna Schwedens, wo 246 Arten Cyniopoidea angeführt werden (Catalogus cynipoideorum sueciae); davon sind 177 Figitidae (i.w.S.) aber, dem nördlichen Klima entsprechend, nur 65 Cynipidae.\nAuch bei den Inquilinen-Arten (Tribus Synergini) besteht ein gewisses Missverhältnis: aus Italien werden 20 Arten angeführt (d.h. $16 \\%$ der Cynipidae), hingegen sind es in Spanien 32 Arten (d.h. $23 \\%$ der Cynipidae). Dies bedeutet, dass aus Italien bisher zwar relativ viele gallenbildende CynipidaeArten bekannt wurden, hingegen noch zu wenig\n\n--- Seite 8 ---\nZuchtmaterial erfasst ist, sowohl was die gallenmitbewohnenden Inquilinen anbelangt und noch mehr was die rein parasitisch lebenden Figitidae betrifft.\nIn stärkerem Maße gilt dieses Erfassungsdefizit für die Gallwespenfauna von Südtirol-Trentino, von wo bisher erst 41 Arten erfaßt waren. Diese betrafen hauptsächlich gallenbildende Formen, die schon von Dalla Torre (1892-96), Bezzi (1899) und Cobelli (1903) erwähnt wurden. Hingegen finden sich im systematischen Standardwerk über „Cynipidae\" von Dalla Torre \\& Kieffer (1910) meist nur großräumige Verbreitungsangaben; nur 2 Arten werden speziell auch aus Tirol angeführt. Bei Anfrage an den italienischen Hymenopterologen Guido Pagliano (Mus. Sc. Naturali, Torino) hinsichtlich des Erfassungsstandes der Gallwespen in Trentino-Südtirol, teile dieser mit (15.07. 2004): ,,Si può constatare che purtroppo i dati riferiti al Trentino sono molto scarsi. Sarebbe utile e importante fare delle raccolte mirate alla conoscenza della fauna dei Cinipidi che ivi è certamente molto ricca\". Segnalo comunque i dati in mio possesso per il Trentino-Alto Adige: Es folgte eine Liste von 24 Arten, darunter 22 Arten die schon Cobelli (1903) aus Trentino angeführt hatte (vgl. Tab. 1). Bei dieser prekären Kenntnislage schien es notwendig eine Standortsbestimmung der faunistischen Situation der Gallwespen in Südtirol-Trentino\nvorzunehmen, auch unter Anpassung an die aktuelle Nomenklatur und Einbeziehung der rezenten Fundnachweise des Verfassers in den Jahren 2004-2008. Damit wurde ein großer Fortschritt erzielt gegenüber der Artenliste in der „Tierwelt Südtirols\" (Hellrigl 1996), wo auch die alten Angaben von Dalla TorRe (1892-96) für Südtirol noch fehlten.\nHinsichtlich der alten Angaben für Trentino brachte zunächst Bezzi (1899) eigene Fundangaben für 10 Taxa ( 5 von Quercus, 4 von Rosa, 1 von Rubus), mit Gallendiagnosen unter Referenz auf Abbildungen von C. B. Massalongo [1893: Le galle nella flora italica (Entomocecidii): 301 p., 40 tavole]. Zweifel an der Richtigkeit der Zuordnung bestehen kaum, wenngleich das Fehlen einiger heute im Trentino häufigen Arten, wie Andricus caputmedusae und A. quercustozae, zunächst verwunderlich erscheint. Im Gegensatz zu Bezzi bringt Cobelli (1903: 165) für Trentino nur eine unkommentierte Auflistung von 23 Arten (ohne Fundorte), für 5 davon wird als Quellenreferenz Bezzi (= Bz) genannt.\nAls (vorläufiges) Endergebnis der gegenständigen Gallenerhebung 2004-2008 ergab sich als Befund: Erfasst aus der Region: 103 Arten Cynipoidea [72 Gallenbildner + 31 Inquilinen \\& Parasiten]; Erfasst aus Südtirol: 73 Arten Cynipoidea [51 Gallenbildner + 22 Inquilinen \\& Parasiten]; Erfasst aus Trentino: 76 Arten Cynipoidea [56 Gallenbildner + 20 Inquilinen \\& Parasiten].\n\n--- Seite 9 ---\nTab. 2: Übersicht der erfaßten Gallwespen aus Südtirol-Trentino: [Stand: Nov. 2008]\n\n|  Gallwespen (1) | Südtirol : (1) 23 spp. |  |  | Trentino : (1) 29 spp. |  |   |\n| --- | --- | --- | --- | --- | --- | --- |\n|  Artnamen: Cynipidae 1 [Gallenbildner] | Dalla Torre: 1892-1910 | Hellrigl: 1984-1997 | Hellrigl: 2004/08 | Bezzi:\n1899 | Cobelli:\n1903 | Hellrigl: 2004/08  |\n|  Fam. Cynipidae |  |  |  |  |  |   |\n|  Andricus amblycerus | - | - | - | - | - | $[+] 2007 / 08$  |\n|  Andricus amenti\n$=$ A.giraudianus | - | - | - | - | - | $[+] 2007 / 08$  |\n|  Andricus aries | - | - | x: import. | - | - | -  |\n|  Andricus burgundus | - | - | x: 2005 | - | - | -  |\n|  Andricus caliciformis | - | - | - | - | - | $[+] 2007 / 08$  |\n|  Andricus callidoma | - | - | x: import. | - | - | -  |\n|  Andricus caputmedusae | - | [He 1996] | x: 2005/08 | - | - | x  |\n|  Andricus conglomeratus | - | - | x: import | - | - | $[+] 2007$  |\n|  Andricus conificus | - | - | - | - | - | $[+] 2007 / 08$  |\n|  Andricus coriarius | - | - | x | - | - | x  |\n|  Andricus corruptrix | - | - | x: [import] | - | - | $[+] 2007 / 08$  |\n|  Andricus curvator | $[\\mathrm{N}-\\mathrm{Ti}]$ | - | x | x | x | x  |\n|  Andricus cydoniae | - | - | - | - | - | $[+] 2007 / 08$  |\n|  Andricus fecundator [= quercusgemmae L.] | x | He 1996 | x | - | - | x  |\n|  Andricus galeatus | - | - | - | - | - | $[+] 2007 / 08$  |\n|  Andr. gallaeurnaeformis | - | - | - | - | - | x  |\n|  Andricus gemmeus | - | - | - | - | - | $[+] 2007 / 08$  |\n|  Andricus glandulae | - | - | x | - | x | -  |\n|  Andricus grossulariae $\\varnothing \\varnothing$\n$[=$ Andricus mayri $\\varnothing \\varnothing]$ | - | - | - | - | - | $\\begin{aligned} & {[+] 2007 / 08} \\ & \\text { x } 2004 \\end{aligned}$  |\n|  Andricus infectorius | - | - | x: 2004/08 | - | - | $[+] 2004 / 08$  |\n|  Andricus inflator $\\varnothing \\varnothing$\n$[=$ Cynips globuli $\\varnothing \\varnothing]$ | $[\\mathrm{N}-\\mathrm{Ti}]$ | He 1996 | $\\begin{aligned} & \\text { x: } \\ & \\text { x: } 2007 / 08 \\end{aligned}$ | - | - | $[\\mathrm{x}] 2008$  |\n|  Andricus kollari | - | He 1996 | x | x | x | $[+] 2004 / 08$  |\n|  Andricus legitimus | - | - | x | - | - | -  |\n|  Andricus lignicolus | - | - | x | - | - | x  |\n|  Andricus lucidus $\\varnothing \\varnothing$\n$[=$ A. aestivalis $\\varnothing \\varnothing]$ | - | - | - | - | - | $\\begin{aligned} & \\text { x } 2005 \\ & [+] 2008 \\end{aligned}$  |\n|  Andricus multiplicatus | - | - | - | - | - | $[+] 2007$  |\n|  Andricus paradoxus | - | - | x | - | - | -  |\n|  Andricus polycerus | - | - | x: [import] | - | - | $[\\mathrm{x}] 2008$  |\n|  Andricus pseudoinflator | - | - | x: | - | - | -  |\n|  Andricus quercuscalicis | - | * [Osttirol] | x: import. | - | x | -  |\n|  Andricus quercusradicis | $[\\mathrm{N}-\\mathrm{Ti}]$ | - | x | - | x | -  |\n|  Andricus quercusramuli | - | - | x | - | - | -  |\n|  Andricus quercustozae | - | [He 1996] | x: 2006/08 | - | - | $[+] 2004 / 08$  |\n|  Andricus seckendorffi | - | - | - | - | - | $[+] 2007$  |\n|  Andricus sieboldii [= A. testaceipes auct.] | $[\\mathrm{N}-\\mathrm{Ti}]$ | - | [?] | - | - | [?]  |\n|  Andricus solitarius | x | - | x | - | - | x  |\n|  Andricus truncicolus | - | - | - | - | - | $[\\mathrm{x}] 2008$  |\n\n--- Seite 10 ---\n| Gallwespen (2) | Súdtriol : (2) 28 spp. |  |  | Trentino : (2) 27 spp. |  |  |\n| :--: | :--: | :--: | :--: | :--: | :--: | :--: |\n| Artnamen: Cynipidae 2 [Gallenbildner] | Dalla Torre: 1892-1910 | Hellrigl: 1984-1997 | Hellrigl: 2004/08 | Bezzi: <br> 1899 | Cobelli: <br> 1903 | Hellrigl: <br> 2004/08 |\n| Aphelonyx cerricola | - | - | - | - | - | [+] 2007 |\n| Aulacidea hieracii | $[\\mathrm{N}-\\mathrm{Ti}]$ | - | $x$ | - | - | - |\n| Aylax minor | - | - | $x$ | - | - | [+] 2006 |\n| Aylax papaveris | - | - | x: 2008 | - | - | - |\n| Biorhiza pallida | $x$ | He 1996 | $x$ | $x$ | $x$ | $x$ |\n| Callirhytis glandium | - | - | - | - | - | [+] 2007 |\n| Callirhytis rufescens | - | - | - | - | - | [+] 2007 |\n| Cynips agama | $x$ | - | [x] 2007 | - | - | [x] 2008 |\n| Cynips cornifex | $x$ | - | $x$ | - | - | $x$ |\n| Cynips disticha | - | - | $x$ | - | - | - |\n| [Cynips divisa] | $[\\mathrm{N}-\\mathrm{Ti}]$ | - | - | - | - | - |\n| [Cynips longiventris] | - | - [errata] | * [Osttirol] | - | - | - |\n| Cynips quercus | $x$ | - | $x$ | - | - | $x$ |\n| Cynips quercusfolii | $x$ | He 1996 | $x$ | - | - | - |\n| Diastrophus rubi | $[\\mathrm{N}-\\mathrm{Ti}]$ | He 1997 | * [Osttirol] | $x$ | $x$ | [Mus. Rov.] |\n| Diplolepis eglanteriae | $[\\mathrm{N}-\\mathrm{Ti}]$ | - | $x$ | $x$ | $x$ | - |\n| [Diplolepis centifoliae] | - | - | [?] 2008 | - | - | - |\n| Diplolepis mayri | $x$ | - | $x$ | - | - | - |\n| Diplolepis nervosus | $x$ | - | $x$ | $x$ | $x$ | $x$ |\n| Diplolepis rosae | $x$ | He 1996 | $x$ | $x$ | $x$ | - |\n| Diplolepis spinosissimae | $x$ | - | $x$ | $x$ | $x$ | - |\n| Dryocosmus nervosus | - | - | - | - | $x$ | - |\n| Dryocosmus kuriphilus | - | - | [x] 2007/08 | - | - | [x] 2005/08 |\n| Isocolus scabiosae | - | He 1996 | - | - | - | - |\n| [Isocolus jaceae] | - | - | * [Osttirol] | - | - | - |\n| Liposthenes glechomae | $x$ | - | $x$ | - | - | - |\n| Neuroterus albipes | $[\\mathrm{N}-\\mathrm{Ti}]$ | - | [x] 2006 | - | - | [+] 2005/08 |\n| Neuroterus anthracinus | $x$ | - | $x$ | - | - | $x$ |\n| Neuroterus aprilinus [= petioliventris Htg.] | - | - | [x] 2006 | - | - | [+] 2008 |\n| Neuroterus minutulus | - | - | - | - | - | [+] 2008 |\n| Neuroterus numismalis | $x$ | He 1996 | $x$ | - | - | [+] 2007 |\n| N. quercusbaccarum $\\triangleleft \\delta^{\\circ}$ [= N. lenticularis $\\triangleleft \\notin$ ] | - | He 1996 | $x$ | $x$ | $x$ | $x$ |\n| Neuroterus saliens [= N. glandiformis $\\triangleleft \\delta^{\\circ}$ ] | - | - | - | - | - | [+] 2007 |\n| Neuroterus tricolor | $[\\mathrm{N}-\\mathrm{Ti}]$ | - | [x] 2006 | - | - | [+]2005/08 |\n| Pseudoneur. macropterus | - | - | $x$ | - | - | [+] 2007 |\n| Phanacis hypochoeridis | - | - | [x] import. | - | - | - |\n| Plagiotrochus australis | - | - | - | - | - | [x] 2006/08 |\n| Trigonaspis megaptera | - | - | - | - | $x$ | - |\n| Trigonaspis synaspis | $x$ | - | $x$ | - | - | $x$ |\n| Xestophanes potentillae | - | - | $x$ | - | - | - |\n\n--- Seite 11 ---\n| Gallwespen (3) | SÜDtirol : (3) 14 spp. |  |  | Trentino : (3) 12 spp. |  |  |\n| :--: | :--: | :--: | :--: | :--: | :--: | :--: |\n| Artnamen: Cynipidae 3 [Inquiline Gallwespen] | Dalla Torre: <br> 1892-1910 | Hellrigl: <br> 1984-1997 | Hellrigl: <br> 2004/08 | Bezzi: <br> 1899 | Cobelli: <br> 1903 | Hellrigl: <br> 2004/08 |\n| Ceroptres cerri | - | - | [?] 2005 | - | - | $[+] 2007$ |\n| Ceroptres clavicornis | - | - | [x] 2008 | - | - | $[+] 2007 / 08$ |\n| Periclistus brandtii | - | - | x | - | - | - |\n| Synergus apicalis | - |  | [x] 2008 | - | - | [x] 2008 |\n| Synergus clandestinus | - | - | x | - | - | - |\n| Synergus crassicornis | - | - | x 2007 | - | - | - |\n| [Synergus flavipes] | - | - | [?] | - | - | [?] |\n| Synerg. gallaepomiformis <br> $=$ Synergus vulgaris | - | - | [x] 2006 |  |  |  |\n| Synergus hayneanus | - | - | [x] 2007 | - | - | $[+] 2007$ |\n| Synergus pallicornis | - | - | [x] 2006 | - | - | $[+] 2007$ |\n| Synergus pallidipennis | - | - | - | - | - | $[+] 2008$ |\n| Synergus pallipes <br> $=$ S. albipes, S. nervosus | - | - | [x] 2006 | - | - | [x] 2008 |\n| Synergus physoceras | x D.T. 1910 | - | [x] 2005 | - | - | - |\n| Synergus thaumacerus | - | - | [x] 2004 | - | - | $[+] 2007 / 08$ |\n| Synergus reinhardi | - | - | [x] 2006 | - | x | $[+] 2006$ |\n| Synergus umbraculus | - | - | [x] 2005 | - | - | $[+] 2007 / 08$ |\n| Synophrus politus | - | - | - | - | - | $[+] 2006 / 07$ |\n\n\n| Gallwespen (4) | SÜDtirol : (4) 8 spp. |  |  | Trentino : (4) 8 spp. |  |  |\n| :--: | :--: | :--: | :--: | :--: | :--: | :--: |\n| Ibaliidae + Figitidae [Zoophage Gallwespen] | Dalla Torre: 1892-1910 | Hellrigl: 1984-1997 | Hellrigl: <br> 2004/08 | Bezzi: <br> 1899 | Cobelli: <br> 1903 | Hellrigl: <br> 2004/08 |\n| Fam. Ibaliidae |  |  |  |  |  |  |\n| Ibalia leucospoides | - | He 1984 | [x] | - | - | Madl, 1992 |\n| [Ibalia rufipes drewseni] | [N-Ti: Ra] | - | [?] | - | - | - |\n| Fam. Figitidae |  |  |  |  |  |  |\n| Aspicera scutellata | - | [Pe 1965] | x | - | - | - |\n| Eucoila floralis Dahlb. | - | - | - | - | x | - |\n| Eucoila maculata | - | - | - | - | x | - |\n| Rhoptromeris heptoma | - | [Pe 1964] | x | - | - | - |\n| Trybliographa glottiana | - | [He 1992] | x | - | - | - |\n| Trybliogr. longicornis | - | [Pe 1967] | x | - | - | - |\n| Trybliogr. melanoptera | „Tirol\" | - | [?] | - | - | - |\n| Trybliographa nigripes | - | [Pe 1961] | x | - | - | - |\n| Trybliographa rapae | - | - | [?] | - | x | - |\n| Trybliogr. subnebulosa | - | - | - | - | x | - |\n| Trybliographa trichopsila | - | - | - | - | x | - |\n| Amphitectus areolatus | - | [Pe 1965] | x | - | - | - |\n| Figites coriaceus Dahlb. | - | - | - | - | x | - |\n| Figites scutellaris | - | - | - | - | x | - |\n\n--- Seite 12 ---\n# 4 Zoogeographie \n\nZoogeografische Betrachtungen spielen bei der Faunistik der Insekten eine wichtige Rolle. Bei den in Europa vorkommenden Gallwespen-Arten, die der paläarktischen Fauna angehören, ist bei ihrer Verbreitung zu unterscheiden zwischen Nordeuropa ( $\\mathrm{N}=$ Skandinavien inkl. Finnland), Mittel- oder Zentraleuropa ( $\\mathrm{Z}=$ nördlich der Linie BordeauxVenedig; inkl. Dänemark und Britische Inseln $=$ UK), Südeuropa ( $\\mathrm{S}=$ südlich der Linie BordeauxVenedig); Südosteuropa ( $\\mathrm{SE}=$ östlich von Nizza) und Südwesteuropa (SW = westlich von Nizza) (Chinery 1987).\nWichtig ist insbesondere die Unterscheidung zwischen SE-Europa (südost-mediterran) und SWEuropa (west-mediterran). Die Fauna Südtirols gehört nach obiger Definition und Differenzierung zwischen Mittel- und Südeuropa hauptsächlich zur Fauna Mitteleuropas (Hellrigl 1996); hingegen gehören die hier und im Trentino mit einfließenden mediterranen Faunenelemente zur Fauna SüdostEuropas. Auch innerhalb des Alpenbogens liegt Südtirol zur Gänze im Bereich der Ostalpen, deren höchste Erhebung der Ortler ( 3899 m ) im Westen des Landes ist. Über geomorphologische, botanische und faunistische Differenzierungen zwischen Ostund Westalpen hatte Schmölzer (2001) berichtet.\nDas Verbreitungsgebiet vieler Gallwespen liegt im östlichen und südöstlichen Europa: Ost-Österreich, Tschechoslowakei, Ungarn, Rumänien, mit den Karpathen als natürliche nordöstliche Barriere; dann auch Bulgarien, den Balkan, Griechenland, Italien, über Kleinasien, teilweise bis Israel und Iran. Besonders auffällig ist dies u.a. bei der Andricus-kollari-Artengruppe, die über ein Dutzend Arten umfaßt (vgl. Tab. 3). Diese Verbreitung erklärt sich aus dem Vorkommen der alternierenden, bisexuellen Generation, welche sich an Zerreiche (Quercus cerris) entwickelt (Bellido et al. 2003: p.173). Einen Sonderfall bildet dabei die verbreitete Andricus kollari, die auch in Gebieten gefunden wird, fernab von Q. cerris; dasselbe wurde auch bei A. lignicolus u.a. später beobachtet (Eigenbeobachtung).\n\nDie Region Trentino-Südtirol liegt im submediterranen Grenzbereich. Auch in Südtirol strahlen noch viele südliche Faunenelemente ein, deren\nbekannteste sind der Italienskorpion (Euscorpius italicus), der Kiefernprozessionsspinner (Thaumetopoea pityocampa) und die Smaragdeidechse (Lacerta viridis), die ihre Verbreitungsgrenze im Großraum Brixen haben, begrenzt im Norden von Franzensfeste (mit dem Wipptal) und bei Aicha/ Schabs (Beginn des Pustertales). Im Trentino finden sich bereits deutlich mehr mediterrane Elemente als in Südtirol, vor allem im südlichen Teil, d.h. südlich einer Linie: Valsugana, Trento, Tione (Hellrigl 2006). Dies ist durch die wärmere, südlichere Lage bedingt und, damit zusammenhängend, durch floristische Vorkommen von Wirtspflanzen, die dort noch stellenweise vorkommen, aber in Südtirol bereits fehlen, wie Zerreiche, Steineiche und Ölbaum.\nBesonders relevant für die Prov. Bozen-Südtirol ist das Fehlen der Zerreiche (Quercus cerris) und der immergrünen Steineiche (Quercus ilex), mit den an ihnen lebenden Gallenbildnern (Gallwespen und Gallmücken). Diese zwei Eichenarten, von denen besonders die ursprünglich südost-mediterrane Zerreiche (\"Turkey Oak\") reich an wirtsspezifischen Gallwespen ist (z.B. Aphelonyx cerricola, Andricus cydoniae, A.grossulariae, A. multiplicatus, Dryocosmus nervosus, Neuroterus lanuginosus, N. minutulus, N. saliens, Pseuoneuroterus macropterus, Synophrus politus etc.), bzw. den Alternativwirt eines obligatorischen Generartionswechsels vieler weiteren Arten bildet (vgl. Tab. 3), kommen in Südtirol nicht natürlich vor (ausgenommen angepflanzte Einzelbäume: z.B. in Castelfeder); sie finden sich erst weiter südlich in den Provinzen Trient und Verona (vgl. Kap. 4.2).\nDie meisten Gallen findet man in den Eichenwäldern und dabei hat manche Quercus-Art wie Quercus petraea ( $=$ sessiliflora), robur, pubescens und besonders Quercus cerris eigene Gallenarten. Wie GrÄFfE (1905: 8) in seiner „Cynipinen-Faunistik Triests\" berichtet, finden sich in der Umgebung Triests, namentlich auf dem Karste, alle diese Eichenarten, doch sind hier Quercus robur und cerris vorwaltend. Die Flaum- oder „Wolleiche\" Q. pubescens findet sich häufig in den Karstdolinen; auch die immergrüne Steineiche Quercus ilex kommt bei Nabresina und Duino vor.\n\n--- Seite 13 ---\nDie Übereinstimmung der Gallwespen-Fauna von Triest/Istrien mit der von Trentino/Südtirol liegt unerwartet hoch bei $75 \\%$; d.h. nur $1 / 4$ der vom Triestiner Karst nachgewiesenen insgesamt 53 Arten fehlen bisher in unserer Region: außer Cynips longiventris meist mediterrane Arten wie: A. coronatus, A. crispator, A. dentimitratus, A. glutinosus, A. hartigi, A. hystrix, A. korlevici, A. stefanii, A. trotteri, Chilaspis nitida. Diese große Ähnlichkeit der Fauna ist durch die Präsenz der gleichen Eichenarten bedingt, wenngleich die Stieleiche Quercus robur in Trentino-Südtirol weit schwächer vertreten scheint. In Südtirol herrscht bei weitem die Traubeneiche Q. petraea vor, im Trentino hingegen mehr die Flaumeiche und an felsigen Hängen des Etsch- und Sarcatales lokal auch die Steineiche Q. ilex.\n\n### 4.1 Die Bedeutung der Zerrreiche (Quercus cerris) für die Verbreitung der Gallwespen\n\nDiese Zerrieiche (Quercus cerris) - die man auch als „Mutter der Eichengallen\" bezeichnen kann - hat ihre natürliche Verbreitung im südöstlichen, submediterranen Gebiet (Abb. I). Natürliche Vorkommen erstrecken sich in der ganzen Türkei (\"Turkey oak\") bis zum Schwarzen Meer, in Südosteuropa über die Balkanhalbinsel und über ganz Italien, bis hin zum östlichen Südfrankreich. Sie fehlt auf der Iberischen Halbinsel, in Korsika und Sardinien. In Mitteleuropa liegen natürliche Vorkommen im Tessin, Trentino, Mähren, Ungarn, Niederösterreich und Steiermark. In England, NW-Frankreich und weiten Teilen Mitteleuropas ist die Zerrieiche nur eingebürgert. Einige Arten der A. kollari-Gruppe haben sich in Teilen Europas erst verbreitet, nachdem dort Zerreichen eingeführt und angepflanzt wurden (vgl. Stone et al. 2001).\nDie wichtige Rolle, welche die Zerrieiche (Q. cerris) als Zwischenwirt der Sexualgeneration von Eichengallwespen, bei der Verbreitung von Eichengallen in Europa spielt, wurde erst bekannt nachdem BeyeRINCK (1896: Über Gallenbildung und Generationswechsel bei Cynips calicis) davon berichtet hatte. BEYERINCK wies nach, dass die agame Cynips calicis\n\nBurgsdorf-Wespe, mit den \"Knoppern\" an Stieleiche, in Generationswechsel steht mit einer Zerreichenwespe, der sexuellen Andricus cerri Beyerinck (1895). Bereits zuvor hatte Beyerinck (1880: Ein Beleg zu der von Dr. Adler entdeckten Heterogenie von Cynipiden) auf diesen von Adler (1877) erstmals in Europa festgestellten Generationswechsel bei Eichen-Cynipiden hingewiesen (vgl. Kieffer 1914: 17). - Noch Riedel (1910: 55-56) berichtet darüber als „ein bis jetzt einzig dastehender Fall, dass erstens überhaupt eine Cynips-Art in Generationswechsel steht, und dass zweitens Wespen, die an Gallen von Stieleiche (Qu. pedunculata) stammen, ihre Eier auf der Zerrieiche, und umgekehrt Zerreichenwespen ihre Eier auf Stieleiche ablegen. Doch Beyerinck (1902: Über die sexuelle Generation von Cynips kollari) hatte dies noch für eine zweite Cynips-Art nachgewiesen, die agame C. kollari, deren sexuelle Generation Andricus circulans Mayr 1870 („Vogelnestgalle\" an Zerrieiche) sein würde (vgl. Kieffer 1914: 57). - Inzwischen wurden noch andere Eichengallwespen mit Gene-rations- und Wirtswechsel bekannt (vgl. Kieffer 1914: 17), für weitere Arten wird er vermutet (vgl. Tab.3). - Andererseits mehren sich in letzter Zeit aber die Anzeichen, wonach es offenbar Ausnahmen von dieser strengen heterogenen Generationsbindung geben muß - vielleicht in Form wiederholter parthenogenetischer Generationsfolgen. Im Laufe der vorliegenden Untersuchung wurden in Süd- und Osttirol mehrfach lokale Vorkommen von Arten festgestellt, wie Andricus kollari (Eisacktal, Osttirol), A. quercuscalicis (Osttirol, Kärnten), A. coriarius und A. lignicolus (Eisacktal), die es hier wegen Fehlens der Zerrieiche gar nicht geben sollte.\nIn SW-Europa, wo die Zerrieiche nicht mehr vorkommt - und von der Korkeiche (Quercus suber) ersetzt wird (Abb. II), wie auf der Iberischen Halbinsel, fehlen rd. 25-30 der in SE-Europa an Zerreichen gebundenen Gallwespen. In Spanien sind 12 der sonst an Quercus cerris gebundenen Arten auf Korkeiche (Quercus suber) übergegangen (vgl. Tab.3), als ersatzweisen Alternivwirt der bisexuellen Generation. Auch aus Sizilien berichet De Stefani (1897: 169) über A. grossulariae an Quercus suber.\n\n--- Seite 14 ---\nDie Zerreiche bevorzugt sommerwarme, nährstoffreiche Böden. Sie hat eine große ökologische Amplitude und kommt sowohl auf Kalk- wie auf saurem Silikatgestein vor. Sie steigt von der Ebene bis in mittlere Gebirgslagen bis 1250 Meter hoch. Die Zerreiche bildet Mischwälder mit der Flaumeiche, der Mannaesche, der Hopfenbuche und anderen Laubbaumarten sowie auch Kiefern u.a. (Hecker 2006).\n\nDie Zerreiche ist einhäusig und blüht im Mai, die Eicheln reifen im zweiten Jahr im September bis Oktober. Die Eicheln sind bis drei Zentimeter lang und sitzen bis zur Hälfte in der stachligen Cupula. Das Mannbarkeitsalter (Blüte und Fruktifizierung) wird erst mit 30-40 Jahren erreicht; dies ist von Bedeutung, da meist erst zu diesem Zeitpunkt ihre Funktionsfähigkeit als Zwischenwirt erreicht wird.\n\nDie Zerreiche ist ein wichtiges Waldgehölz in Südund Südosteuropa; sie wird oft als Niederwald (Ceduo) zur Brennholzgewinnung bewirtschaftet. Viele alte Zerreichenbestände (z.B. im Wienerwald) sind durch Weingärten ersetzt worden. In Mitteleuropa ist die Zerreiche auch ein beliebter Parkbaum; dort findet sie sich häufig in Mischung mit Stieleiche (Quercus robur).\nIm Gegensatz zur Prov. Bozen-Südtirol befindet sich die Zerreiche bereits im südlichen Trentino, in Vallagarina und im Gardaseegebiet in einem schmalen natürlichen Verbreitungsareal und wurde auch forstwirtschaftlich gefördert, so dass es dort sogar kleine Bestände gibt (z.B. Val Lagarina, Pomarolo etc.). Jedenfalls bewirkt diese Präsenz der Zerreiche im Trentino, das dortige Vorkommen einiger in Südtirol - vor allem im Eisacktal fehlender Gallwespenarten (vgl. Tab. 3).\n![img-2.jpeg](img-2.jpeg)\n\nAbb. I:\nVerbreitungsareal der\nZerreiche: (aus Fenaroli\n\\& Gambi 1976: p.348;\nnach Meusel, 1965)\n![img-3.jpeg](img-3.jpeg)\n\nAbb. II:\nVerbreitungsareal der\nKorkeiche: (aus Fenaroli\n\\& Gambi 1976: p. 339\nnach Metro, 1958)\n\n--- Seite 15 ---\nTab.3: Gallwespen und Zerreiche (Quercus cerris)\n\n| Fam. Cynipidae <br> [Arten mit Bezug zu Q. cerris] | Clade | Q. cerrisZyklus | Fehlt Spanien wie Q. cerris | im Etschtal mit Q. cerris | im Eisacktal ohne Q. cerris |\n| :--: | :--: | :--: | :--: | :--: | :--: |\n| Andricus amblycerus | [1] | $[+]$ | x | $+$ ! TN | - |\n| Andricus aries | [1] | $+$ | x | [?] [möglich] | [+] import* |\n| Andricus burgundus | (4) | $[+]$ | [an Q. suber] | $+$ ! Castelfed. | - |\n| Andricus caliciformis | [1] | $[+]$ | x | $+$ ! TN | - |\n| Andricus caputmedusae | (3) | $[+]$ | x | $+$ ! TN + BZ | [+] import* |\n| Andricus conglomeratus | (4) | $[+]$ | x | $+$ ! TN | [+] import* |\n| Andricus conificus | [2] | $[+]$ | x | $+$ ! TN | - |\n| Andricus coriarius | (4) | $[+]$ | [an Q. suber] | $+$ ! | [+] import* |\n| [Andricus coronatus] | (3) | $[+]$ | x | [?] [möglich] | - |\n| Andricus corruptrix | [1] | $+$ | x | $+$ ! | [+] import* |\n| Andricus cydoniae | [2] | $+$ | x | $+$ ! TN | - |\n| [Andricus dentimitratus] [= viscosus Nieves-Aldrey | (3) | $[+]$ | [? an Q. suber] | [?] [möglich] | - |\n| Andricus galeatus | [1] | $[+]$ | x | $+$ ! TN | - |\n| [Andricus gallaetinctoriae] [? = Andricus sternlichti] | [1] | $[+]$ | [ostmediterran] [kleinasiatisch] | $\\begin{aligned} & \\text { [no] } \\\\ & \\text { [no] } \\end{aligned}$ | $\\begin{aligned} & \\text { [no] } \\\\ & \\text { [no] } \\end{aligned}$ |\n| Andricus gemmeus | [2] | $+$ | [an Q. suber] | $+$ ! TN | - |\n| [Andricus glutinosus] | (3) | $[+]$ | x | [?] [möglich] | - |\n| [Andricus hartigi] | [2] | $+$ | x | [?] [möglich] | - |\n| Andricus truncicolus | [2] | $[+]$ | x | $+$ ! TN | - |\n| [Andricus hispanicus] <br> = Andricus kollari minor | [1] | [?] | [an Q. suber] endemisch | [no] | [no] |\n| [Andricus hungaricus] | (3) | $+$ | x | [no] | [no] |\n| [Andricus hystrix] | [2] | $[+]$ | x | [?] [möglich] | - |\n| Andricus infectorius | [1] | $[+]$ | x | $+$ ! TN + BZ | [+] import* |\n| Andricus kollari | [1] | $+$ | [an Q. suber] | $+$ ! TN + BZ | [+] import* |\n| Andricus lignicolus | [1] | $+$ | x | $+$ ! TN | $+$ ! |\n| Andricus lucidus $Q Q$ $[=$ A. aestivalis $\\varnothing \\varnothing]$ | (5) | $\\begin{aligned} & + \\\\ & + \\end{aligned}$ | $\\begin{aligned} & \\mathrm{x} \\\\ & \\mathrm{x} \\end{aligned}$ | $\\begin{aligned} & +! \\text { TN } \\\\ & +! \\text { TN } \\end{aligned}$ | $\\begin{aligned} & \\text { [+] import* } \\\\ & \\text { - } \\end{aligned}$ |\n| Andricus mayri $Q Q$ $[=$ A. grossulariae $\\varnothing Q]$ | (5) | $\\begin{aligned} & + \\\\ & + \\end{aligned}$ | [an Q. suber] | $\\begin{aligned} & +! \\text { TN } \\\\ & +! \\text { TN } \\end{aligned}$ | - |\n| Andricus seckendorffi | (5) | $+$ | x | $+$ ! TN | - |\n| Andricus polycerus | (4) | $[+]$ | x | $+$ ! TN + BZ | [+] import* |\n| [Andricus mitratus] | (3) | [?] | x | [?] [möglich] | - |\n| Andricus quercuscalicis | (3) | $+$ | x | $+$ TN | [+] import* |\n| Andricus quercustozae | (3) | $[+]$ | [an Q. suber] | $+$ ! TN + BZ | [+] import* |\n| Aphelonyx cerricola |  | $+$ | x | $+$ ! TN | - |\n| Callirhytis glandium |  | $+$ | [an Q. suber] | $+$ ! TN | - |\n| Callirhytis rufescens |  | $+$ | [an Q. suber] | $+$ ! TN | - |\n| Ceropters cerri |  | $+$ | [an Q. suber] | $+$ TN | - |\n| Dryocosmus nervosus |  | $+$ | x | $+$ TN | - |\n| Dryocosmus kuriphilus | $=$ | [ohne Zykl] | $=$ | [Castanea] | - |\n| Neuroterus minutulus |  | $+$ | x | $+$ TN | - |\n| Neuroterus lanuginosus |  | $+$ | x | ? [möglich] | - |\n| Neuroterus saliens [= glandiformis] |  | $+$ | [an Q. suber] | $+$ ! TN | - |\n| Pseudoneuroterus macropterus |  | $+$ | x | $+$ ! TN + BZ | - |\n| Synophrus politus |  | $+$ | [an Q. suber] | $+$ ! TN | - |\n\n[1] A. kollari clade (A. kollari species-group). - [2] A. hartigi clade. - [3] A. quercuscalicis clade. -\n[4] A. coriarius clade (distinct species-group). - [5] A. lucidus clade. - [clades: nach Stone et al. 2007]\n$[+]=$ vermuteter Zwischenwirt $Q$. cerris $+!=$ Eigenfunde K. Hellrigl\n$(+)$ import* $=$ von Stadtgärtnerei Brixen rezent mit Alleebäumen aus Toskana und Veneto importiert;\n\n--- Seite 16 ---\n### 4.2 Die Verbreitung der Zerreiche (Quercus cerris) in der Region TrentinoSüdtirol\n\nInteressante Aspekte ergaben sich bei den Unter suchungen in Trentino und Südtirol hinsichtlich der Vorkommen und Verbreitung der Zerreiche (Quercus cerris) mit deren spezifischen Gallwespenfauna. Im Südtiroler Unterland ging das einzige bekannte Vorkommen einer einzelnen mächtigen alten Zerreiche (Ø 100 cm ) im Eichenhain (Quercus pubescens) von Castelfeder/Auer ganz offensichtlich auf künstliche Anpflanzung vor vielen Jahrzehnten zurück.\nZunächst lag die Vermutung nahe, dass ähnliche Verhältnisse einer künstlichen Einbringung in relativ rezenter Zeit (etwa Anf. 20.Jh.) auch für Trentino gelten könnten. Dafür sprach vor allem der Umstand, dass Angaben über einige sehr auffällige und unübersehbare, an Zerreiche als Zwischenwirt gebundene Gallen, wie die „Medusenhauptgalle\" (Andricus caputmedusae) und „Kugelkronengalle\" (Andricus quercustozae), die heute dort häufig sind, in alten Trentiner Gallen-Faunistiken unerwähnt blieben (vgl. Bezzi 1899; Cobelli 1903).\nIm Laufe meiner 5jährigen Untersuchung stellte sich aber immer deutlicher heraus, dass im südlichen Trentino eine derartige Fülle von spezifisch an Zerreiche gebundenen Gallwespen-Arten vorkommt, die nur mit natürlicher Ausbreitung und Zuwanderung von Süden her erklärbar schienen. Nach einer Anfrage an die forstliche Arbeitsgruppe der Versuchsanstalt S. Michele a.A., übermittelte mir Kollegin Dr. Cristina Salvadori eine rezentere Publikation von F. Prosser (1993) über das Vorkommen von Quercus cerris im Trentino: F. Prosser 1993: Segnalazioni Floristiche Tridentine II: 5. Quercus cerris L. - Ann. Mus. civ. Rovereto, Vol. 8 (1992): 178-181. - Diesen Ausführungen folgen wir:\nNach Prosser (1993) lässt sich, aufgrund von reliktären Vorkommen, der Verlauf der Ausbreitung der Zerreiche bei ihrem Vordringen gegen Norden im Trentiner Etschtal verfolgen. Beginnend beim Veroneser Hügelland, vor allem den Moränen von Rivoli Veronese, wurden zunächst die Hang-Terrassen des östlichen Monte Baldo erreicht, in Höhenlagen um 500 m (Piano dei Dazi, I Piani, Piazzine). Weiter nördlich finden sich dann die Vorkommen auf den\n\nHügeln im Süden und Osten von Rovereto, sowie im Etschtal bis Volano und Calliano. - Noch weiter nördlich (ca. 13 km ) taucht die Zerreiche dann sporadisch bei Trient auf und reicht vielleicht sogar hinauf bis Lavis. Die Hauptverbreitung der Zerreiche im Trentino umfaßt somit die Vallagarina, das ist der südliche Abschnitt des Etschtales (valle dell'Adige). Die Val Lagarina beginnt südlich von Trento, bei Besenello, und reicht flußabwärts bis zur Veroneser Grenze, bei Borghetto/Avio. In Val Lagarina ist der mediterrane Charakter und Einfluß stärker ausgeprägt als im oberen Etschtal nördlich von Trient.\nAn detaillierteren Angaben führt F. Prosser (1993: 178-181) an: An den östlichen Abhängen des Mte. Baldo: häufig am Piano dei Dazi ( 1 km N von Mama d'Avio); vereinzelt (4 Ex) auf der Südseite der Val Sobia (480-550 m); bei Piazzina (Brentonico), $1,7 \\mathrm{~km}$ NNE von Pilcante/Ala, stellenweise häufig mit teilweise schönen stattlichen Exemplaren (Ø bis 40 cm ), auch Richtung Castel Saiori, 650-670 m. Häufig im Wald von Piani (hier bei 692 m einige Bäume mit Durchmesser von 70 cm ), $1,5 \\mathrm{~km}$ NE von Sabbionara d'Avio, 500-700 m. - [Im Süden von Rovereto in Wäldchen von Levini di Marco, unterhalb der Dinosaurierfährten (Mitt. Salvadori 2008)]. - Im SE von Rovereto zwischen S.Anna und Brentegam (Val Scodella, 422 m , bis Maso Brentegano, 350-450 m); sicher spontan bei Dossi (Bosco dell Città) zwischen Rovereto und Volano, 275-285 m. - [Hierzu ist zu bemerken, dass im „Bosco della Città\" von Rovereto-Dossi, wo ich ab 2005 öfters gesammelt habe, die beiden größten mir dort bekannten Zerreichen, am Straßenrand, vermutlich künstlich angepflanzt worden sein dürften].\nAls noch günstiger hat sich die gegenüberliegende (rechte) Seite des Etschtales herausgestellt, wegen ihrer SE und S Exposition. Hier gibt es Populationen im N und NE von M. Carpeneda (Val di Gresta, SW von Valle S. Felice [comune di Mori]), sporadisch über eine Strecke von ca. $700 \\mathrm{~m}, 420-485 \\mathrm{~m}$. Weiters zwischen Ravazzone und Isera, sporadisch und sicher spontan auf einer Strecke von 500 m am Grunde der Tälchen NW der Höhen 365 und 307. - Aus der Gegend von Pomarolo nennt Prosser ein nicht näher definiertes Vorkommen: $1,5 \\mathrm{~km}$ im N von Nomi, in der Lokalität Servis, in 610-630 m.\n\n--- Seite 17 ---\nOffenbar an derselben Lokalität, bei PomaroloSavignano: Lok. Servis (IT-04), aber etwas höher gelegen, nämlich $680-700 \\mathrm{~m}$, fanden sich bei rezenten Forstlichen Monitoring-Erhebungen zahlreiche Zerreichen [vgl. Ambrosi \\& Salvadori 2004: Monitoraggio integrato in foreste alpine. - Stud. Trent. Sci. Nat., Acta Biol., 81 (2004), Suppl.1: 21-30]. In diesem Monitoring-Areal von Pomarolo/Servis (IT-04) führte ich auch mehrjährigen Untersuchungen über Eichengallen durch. Das Grundgestein bilden hier Jura- und Kreide-Kalke, wie auch im Gebiet von Levini di Marco (südl. Rovereto) mit den dort im Kalk-Sediment eingeprägten 200 Mill. Jahre alten Dinosaurier-Fährten, unterhalb davon ebenfalls Zerreichen festgestellt wurden (Mitt. C. Salvadori). - Hingegen geht Prosser davon aus, dass die Zerreiche an saure Böden gebunden sei (die sie im Moränenschutt vorfindet) und Kalk eher meide.\nIm Etschtal, NW von S. Cecilia (bei Volano), verbreitet von 270 bis 320 m . - Auch bei Piazze, 1 km NW Calliano, im N-S Talverlauf, über mindestens $1,2 \\mathrm{~km}$, von 249 bis fast 561 m ; stellenweise häufig.\nDass die Vorkommen der Zerreiche im unteren Etschtale (= Val Lagarina) spontanen Ursprungs sind, darauf weist nach Prosser (l.c.) nicht nur die große Anzahl von Exemplaren hin (oft auch in wenig anthropisierten Gegenden), sondern auch die an der Basis häufig gekrümmte Stammform (auch bei vielen der ältesten Bäumen) deutet auf einen Ursprung durch Schösslinge hin. - Dies scheint nach eigenen Beobachtungen auch in Pomarolo-Servis (680-700 m) der Fall zu sein, wo viele Bäume mit Zwillings- bis Vierlingswuchs von der Basis an ausgebildet sind. Es könnte dies allenfalls auch mit der früheren Art der Nutzung zusammenhängen, die nach Prosser vormals durch kurze Umtriebzeiten der Niederwälder gekennzeichnet war und die verhinderten, dass die Zerreichen Fruktifizierungsalter erreichten. Letzter Umstand mag auch beigetragen haben, dass zu junge Zerreichen - mit den noch fehlenden typischen Eicheln und Fruchtbechern von früheren Botanikern übersehen wurden.\nDass die südliche, ostmediterrane und ursprünglich kleinasiatisch-pontische Zerreiche (\"Turkey oak\") im Trentino ihre nördliche Verbreitungsgrenze bei Trient erreicht, ist schon durch alte Meldungen von\n\nDalla Torre \\& Sarnthein (1909) bekannt, wo sie als selten in den Wäldern bei Margone (Vezzano, Valle di Laghi) angegeben wird. Von hier wird auch noch später von einem stattlichen fruktifizierenden Exemplar berichtet (Dalla Fior 1962; Prosser 1993: 179).\nAn weiteren Lokalitäten bei Trient werden später nach F. Prosser (1993) Vorkommen an den Hängen des Doss S. Rocco (= Bosco della Città), zwischen Casteller und Maso Panizza (oberhalb der Straße nach Valsorda) angegeben, sowie eine Meldung bei Gocciadoro. Vom Dosso di San Rocco-Casteller, ober Villa Cavazzani (,,busa dei castagnari\"), rezent auch von Förstern bestätigt; ebenso südlich von Trient, bei Ravina, an der Forststraße eine große Zerreiche (pers. Mitt. C. Salvadori 2008).\nDie Meldungen aus Trient-Umgebung beziehen sich nach Prosser jeweils auf wenige Exemplare, über deren effektiven Status (spontan oder angepflanzt) nichts bekannt wurde. Diese Vorkommen aus Trient erscheinen völlig disjunkt gegenüber jenen des Veroneser Abschnittes des unteren Etschtales, zwischen Rivoli Veronese und Monte Baldo, sowie den anschließenden Abschnitt der Val Lagarina bis Volano und Calliano. Für die Val Lagarina bei Rovereto hält Prosser die Vorkommen zwischen Ravazzone und Marano (cit. Marchesoni 1958) als wahrscheinlich original. Er würde dies auch für Trient sowie eine weitere Fundangabe aus Lavis (cit. Dalla Torre 1920: 31) nicht ausschließen, doch scheinen mir diese nördlichsten Vorkommen im Trentino eher auf künstliche Einbringung hinzudeuten, ebenso wie die künstlich angepflanzte alte Zerreiche im Südtiroler Etschtal in Castelfeder.\nAn weiteren Gebieten mit Standorten von Zerreiche im Trentino führt F.Prosser (1993: 181) noch an: Valle delle Chiese (cf. Dall Torre \\& Sarnthein) mit Infiltration auch bis Tiarno in Val di Ledro. - In den Giudicarie inferiori rezent beobachtet bei Condino, entlang der Straße die nach Brione hinauf führt (Mischwald von Zerreiche und Edelkastanie) (pers. Mitt. C. Salvadori 2008). - In Judikarien dringt die Zerreiche aber noch weiter nördlich der Mündung der Val Daone bis mindestens Roncone vor (ProsSER, l.c.). Hier 1 km im NNE von Roncone, 350 m SW der loc. Lodino, um 950 m Seehöhe; hier stärker verbreitet auf den SE Hängen eines Hügels 500 m im NE von Roncone (in 934 m Höhe). - Noch wenig\n\n--- Seite 18 ---\nbekannt und untersucht sind Infiltrationen entlang des Sarca-Tales, mit Angaben für die Lokalitäten Romarzolo (di Arco), Pietramurata (Valle di Laghi), Monte Brione bei Riva und zwischen Pregasina und Malga Paler (HAMAN 1989: cit. Prosser).\nAuch für Loppio gibt es eine Angabe (Wagenitz 1951: „qua e là nella boscaglia submediterranea\"). - Prosser vermutet, dass die Zerreiche von Süden her nicht ins Sarcatal gelangt sein könnte, da die aus Kalkgestein bestehenden Steilhänge des Garadsees wenig geeignet für Ablagerungen von silikathaltigem Moränenschutt und somit für Ansiedlung von Zerreichen-Populationen wären. - Interessant ist ein vermutliches Reliktvorkommen bei Lomaso: zwischen Vigo Lomaso und Lundo, im ENE von\n\nCastel Spine, 4 Ex (davon zwei mit Ø 40 cm und Höhe von 20 m ), 640-660 m, anscheinend spontan. Hier könnte die Einwanderung vom Sarcatal über die Val Lomasona oder wahrscheinlicher über das untere Judikarien erfolgt sein.\nVon diesen Zerreichen-Vorkommen im Trentino habe ich 2005-2008 erst zwei näher untersucht: Rovereto-Dossi (Bosco della Città) und PomaroloServis (IT-04). Beide Lokalitäten zeigen einen hohen Vorkommens- und Übereinstimmungsgrad an cerris-gebundenen Gallwespen (vgl. Tab. 3). Eine Bestätigung dieser Nachweise auch für die übrigen Quercus-cerris-Standorte im Trentino ist zu erwarten, ebenso wie das Auftauchen weiterer, bisher noch nicht erfasster Arten.\n\n# 5 Zur Verbreitung, Abundanz und Populationsdynamik der Gallwespen \n\nIm Zuge der vorliegenden 5jährigen Erhebungen über Gallwespen in Südtirol-Trentino, Frühjahr 2004 bis Herbst 2008, ergaben sich wiederholte Beobachtungen zur wechselhaften Populationsdynamik einiger Arten. Zunächst war aufgefallen, dass von Untersuchungsbeginn 2004/05 an, aber auch schon Jahre zuvor, 1992-1999, die im südlichen Trentino mehrfach vorgefundenen Gallen von Andricus caputmedusae sowie Andricus quercustozae in den alten Trentino-Faunistiken von Bezzi (1888) und Cobelli (1903) nicht angeführt waren. Nachdem es sich dabei um große, unübersehbare und unverwechselbare Gallen handelt, gab es dafür zunächst keine andere Erklärung als dass seinerzeit (d.h. um 1900) im Gebiet von Rovereto-Pomarolo möglicherweise noch keine Zerreichen (als Zwischenwirte der bisexuellen Gallwespen-Generation) vorkamen bzw. angepflanzt worden waren. Dies hat sich dann allerdings nicht bestätigt, nachdem Untersuchungsberichte von Prosser (1993) vorliegen, wonach die Zerreiche im südlichen Trentino natürlichen Ursprungs sein sollte (vgl. Kap. 4.2).\nIm Herbst 2004 fanden sich jedenfalls in den Trentiner Eichengebieten bei Rovereto-Dossi ( 350 m ) und Pomarolo-Servis ( 700 m ) - wo Quercus cerris vorkommt - an Flaumeichen nicht selten Medusen-haupt-Haargallen von A. caputmedusae und Kronen-\n\nKugelgallen von A. quercustozae. Auffällig häufig waren diese Haargallen und Kugelgallen im Stadtwald von Rovereto, wo es mehrfach Eichen mit 50-100 frischen „Medusenhaupt\"-Gallen gab, oft vergesellschaftet auch mit Kugelgallen von A. quercustozae. Hier wurden im Sommer 2005 zahlreiche alte wie frische Gallen gesammelt (Abb. IVa).\nDiese Situation begann sich ab Herbst 2006 zu ändern, indem dort nur mehr ein einziger mit Gallen stark besetzter Baum vorgefunden wurde. Diese im Absterben begriffene Eiche blieb auch im Herbst 2007 der einzige stark befallene Baum, mit jeweils 100 alten Gallen beider Arten (Abb. IVb). Sonst wurden hier im Stadtwald nur mehr relativ wenige der auffälligen Haargallen beobachtet und insgesamt nur 1 Dutzend frischer Kugelgallen von A. quercustozae, ein deutlicher Populationseinbruch. Allerdings fanden sich an den Zweigen mehrerer Eichen auffallend viele verkümmerte Junggallen von A. quercustozae mit InquilinenBesatz (Fluglöcher!).\nGegenteilig war die Populationsentwicklung, 5 km weiter nördlich, in Pomarolo-Servis ( 700 m ) verlaufen. Hier waren seit 1992 auf einer MonitoringFläche (IT-04) alljährlich Gallen dieser beiden Arten sporadisch an Q. pubescens beobachtet worden. Eine quantitative Erhebung im Herbst 2007,\n\n--- Seite 19 ---\n![img-4.jpeg](img-4.jpeg)\n\nAbb. III: Übersichtskarte: „Südtirol\" (Prov. Bozen) und „Trentino\" (Prov. Trento)\n\n--- Seite 20 ---\nam 14.- 28.10.07, bestätigte hier das Vorkommen zahlreicher Gallen dieser beiden Arten: Haargallen von A. caputmedusae fanden sich überall zahlreich an den Flaumeichen, an manchen Bäumen weit über 100. Viele Haargallen lagen frisch abgefallen am Boden unter den Bäumen. Auch A. quercustozae war zahlreich vertreten (Abb. Va); an einer jüngeren Flaumeiche zählte ich an die 50 Gallenkugeln, davon 8 Gallen auf einem einzigen Zweig; an Zweigen von $50-60 \\mathrm{~cm}$ Länge fanden sich öfters 1 Dutzend und mehr Gallen (Abb. Vb).\nAnders war die Populationsentwicklung im Südtiroler Unterland, im Eichenhain Castelfeder $(400 \\mathrm{~m})$. Hier waren am 28.04.2005 an Flaumeichen nur einzelne Haargallen von A. caputmedusae gefunden worden. Am 10.08.2005 fanden sich einige abgefallene alte Haargallen am Boden unter Eichen, sowie etwa 30 frische Haargallen an einer kleineren Flaumeiche ( 6 m ), in Sichtweite einer großen Zerreiche. Dies waren die ersten Freilandnachweise für A. caputmedusae in Südtirol. Im Sommer 2007 wurde bei genaueren Kontrolle und Zählung eine starke Befallszunahme evident. An vielen kleineren Eichen fanden sich je 1-2 Dutzend Medusen-haupt-Gallen, an größeren Eichen viele Dutzend Gallen pro Baum, teilweise schon abgefallen am Boden. Besonders an Bäumen neben der Zerreiche massenhafter Befall mit hunderten von Gallen (Abb. VI).\nEin Befallsbezug von A. caputmedusae zur Zerreiche, als Zwischenwirt für die unbekannte Sexualgeneration, war offenkundig. An den Flaumeichen fanden sich auch Gallen von drei weiteren Arten, deren Sexualgenerationen ebenfalls an Q. cerris gebunden sind, nämlich: A. kollari, A. infectorius und A. coriarius. - Hingegen waren Kugelgallen von A. quercustozae in Castelfeder bis Herbst 2007 noch keine festgestellt worden; mit ihrem erst 2008 nachgewiesenen Neuauftreten war aber zu rechnen.\nAuch bei anderen Arten sind Populationsschwankungen festzustellen, so etwa bei Andricus kollari und A. infectorius in Castelfeder. Von ersterer wurden im Herbst 2004 nur alte Gallen gefunden, in den Jahren 2005 bis 2008 dann auch zahlreiche frische Gallen, Tendenz zunehmend. Bei der \"kleinen Färbergalle\" A. infectorius gab es im Jahre 2005 hier Massenbefall mit starken Angriffen durch Vögel; im Jahre 2007/08 dann deutlich rückläufige Tendenz,\naber Befall noch immer stärker als im Trentino (Rovereto, Pomarolo), wo beide Arten, A. kollari und A. infectorius, 2004-2007 eher vereinzelt gefunden wurden; dort war aber 2008 eine deutliche Befallszunahme zu verzeichnen (vgl. Abb. 50, 52).\nDie Häufigkeitsschwankungen von Kugelgallen sind teilweise auch bedingt durch äußere Umstände, die zu einer Lichtstellung mit vermehrter Bildung von Adventivknospen führen. Dazu könnte es kommen durch Abschneiden von Zweigen mit Gallen, oder durch starkes Schneiteln von Ästen. Letzteres war im Winter 2007/08 in Castelfeder der Fall, wo eine total zurückgestutzte Eiche (Abb. VII) im Juli 2008 plötzlich erstmals mit kollari-Gallen an den Schößlingen übersäht war (Abb. VIII). Über eine Häufung von Knospen-Kugelgallen an solchen Eichensträuchern, die vom Weidevieh verbissen worden sind, berichtet auch Riedel (1910: 19).\nBemerkenswert sind auch festgestellte Häufigkeitsschwankungen bei Neuroterus numismalis. Deren „Napfgallen\" waren früher im Eisacktal häufig zu finden, in letzter Zeit aber seltener (kein Fund 2005, Einzelfund 2006). Auch in Castelfeder war diese Art 2006/07 selten (2006 ein Blatt mit 1 Galle; 2007 wenige Blätter mit einigen Gallen) und ebenso im Trentino, bei Pomarolo-Servis am 14.10.2007, erwies sich ein Einzelblatt mit wenigen Seidenknopfgallen als Erstnachweis. Im Folgejahr 2008 war diese Galle dann überall, im Trentino, Castelfeder und Eisacktal/Brixen relativ zahlreich.\nEin ausgeprägtes Nord-Südgefälle in ihrer Abundanz zeigt die „Eichenblattgalle\" Cynips quercusfolii, die im Eisacktal im Raum Brixen ein richtiges Masseninsekt ist (Abb. IX). Hingegen wird sie nach Süden zu deutlich seltener, so dass in Castelfeder nur wenige Exemplare gefunden wurden (Hellrigl 2005/07), während aus Trentino bisher keine Meldungen vorliegen, wenngleich sie im nördl. Trentino (wie etwa im Nonsberg) kaum fehlen dürfte. Auf diesen Rückgang im Süden weist bereits Kieffer (1901: 635) hin, indem er von Dryophanta folii schreibt: \"Manque probablement dans l'Europe méridionale. Malpighi, Massalongo, Trotter, Licopoli et De Stefani n'en font pas mention pour l'Italie.\" Auch die „Zweizellengalle\" Cynips disticha, die im Eisacktal regelmäßig vereinzelt vorkommt, wurde im Unterland bei Castelfeder sowie im Trentino bisher nicht gefunden. Das Gegenteil ist bei\n\n--- Seite 21 ---\nCynips quercus der Fall, die im Süden bei Rovereto, Pomarolo und Castelfeder regelmäßig in Einzelexemplaren gefunden wird, während aus dem Eisacktal nur eine alte Meldung (von 1894) aus dem untersten Talabschnitt bei Atzwang vorliegt und sie im mittleren und oberen Eisacktal offenbar gänzlich fehlt.\nIn der Region Trentino-Südtirol nicht vorzukommen scheint hingegen die schöne „Eichen-Ziergalle\" Cynips longiventris, die es in Osttirol (Lienz) an Stieleiche gibt (Abb. 87). Sie war seinerzeit irrtümlich von Hellrigl (1996) aus Brixen Umg. gemeldet worden, in Verwechslung mit ungewöhnlich gefärbten Gallen von C. quercusfolii. Ihr Fehlen in Südtirol erscheint ebenso rätselhaft, wie das von Cynips divisa, die aus Nordtirol von Stieleichen (Q. robur) bekannt und auch sonst in Mitteleuropa nicht so selten ist. Auch für Cynips agama liegt von hier eine alte Meldung vor (Dalla Torre 1894), ebenfalls von Stieleiche.\nTatsächlich bevorzugen einige Gallwespenarten die Stieleichen ( $Q$. robur), die in Südtirol weitgehend fehlen, denn hier kommen fast nur Traubeneichen (Q.petraea) und Flaumeichen ( $Q$. pubescens) vor. Auch die Eichenknoppern-Gallwespe, die mancherorts in Deutschland in solchen Mengen vorkommt, dass sich die Äste mit den befallenen Eicheln bis zum Boden biegen (pers. Mitt. H. Bellmann, 2006), bevorzugt Stieleichen. Das Fehlen von A. quercuscalicis im Südtiroler Eisacktal, mit Ausnahme einiger eingeschleppter Exemplare an importierten (am Herkunftsort infizierten) Stieleichen (Abb. X), ist wohl hauptsächlich bedingt durch fehlendes Vorkommen der Zerreiche als Zwischenwirt. Dieses hat im Eisacktal auch das Fehlen einer Reihe weiterer Gallwespenarten zur Folge, welche in ihrer alternierenden bisexuellen Generationsfolge ebenfalls an Zerreiche ( $Q$. cerris) gebunden sind. - Einige dieser Gallwespen bzw. deren Gallen wurden hier gelegentlich mit importierten angepflanzen Stieleichen aus der Toskana temporär in Brixen eingeschleppt, wie etwa Andricus aries, A. caputmedusae, A. conglomeratus, A. corruptrix, A. coriarius, A. kollari, A. lucidus, A. polycerus, A. quercustozae und A. quercuscalicis, konnten sich hier im Eisacktal aber nicht dauerhaft etablieren. Es ist bezeichnend, dass viele der Arten mit Bezug zur Zerreiche (Tab.3) in Spanien fehlen (Nieves-Aldrey 2001),\nwährend sie im südlichen Trentino, wo es Zerreichen gibt (Vallagarina, Rovereto, Pomarolo), vorkommen und dort eine größere Artenvielfalt als in Südtirol bedingen (Tab. 2). Einige dieser Trentiner Zerreichen-Gallwespen sind mediterran, wie Andricus conificus, A cydoniae, A. truncicolus, A. quercustozae, Aphelonyx cerricola, Dryocosmus nervosus, Pseudoneuroterus macropterus, Synophrus politus; sie fehlen in den Zerreichen-Gebieten in Deutschland (vgl. Pfützenreiter 1958).\nZusammenfassend kann man sagen, dass es bei der Verbreitung und Populationsdynamik der Gallwespen erhebliche Unterschiede gibt, die teils örtlich bedingt sind, teilweise auch zeitlich variieren. So berichtet der Gallwespenspezialist Th. Hartig (1841: 324) von interessanten Beobachtungen über die „Zweikammern-Eichengalle\": „Cynips disticha Hartig 1840 war im Sommer 1839 [bei Braunschweig] so selten, dass ich auf meinen Exkursionen, selbst da, wo ich im Sommer 1838 die ersten mir zu Gesicht gekommenen Gallen in geringer Menge fand, kein Exemplar entdecken konnte. Im Sommer 1840 fand sich diese Galle auf einmal in so ungeheurer Menge auf den Blättern 4 bis 10jähriger Eichen, dass ich mit geringer Mühe 140 Kubikzoll sammeln lassen konnte. Da der Kubikzoll im Durchschnitte 200 dieser kleinen Gallen fasst, so erhielt ich pptr. 28000 Gallen. Im Durchschnitt lieferte jede dritte Galle ein Wespe, die übrigen kamen entweder gar nicht aus oder lieferten Parasiten.\"\nEine wesentliche Rolle kommt bei der wechselhaften Populationsdynamik auch der Parasitierung zu. So ergab eine Beobachtung, die Prof. J. Kieffer in den Wäldern von Bitsch i. Lothringen an Cynips (Diplolepis) quercusfolii während einer Reihenfolge von 14 Jahren fortgesetzt hatte, den Beweis, dass die Parasiten der Gallwespen ihre in der Erhaltung des natürl. Gleichgewichtes bestehende Aufgabe auch wirklich erfüllen: Im Jahre 1883 traten die Gallen dieser Wespe so massenhaft auf, dass die Eichenzweige sich unter ihrer Last neigten. Ein 10 cm langer Zweig trug 5 Blätter mit 28 Gallen, ein anderer, $11,5 \\mathrm{~cm}$ lang, trug 7 Blätter mit 46 Gallen. An einem einzelnen Blatt wurden 16 Gallen gezählt, dasselbe wog $31,70 \\mathrm{~g}$; das Gewicht der Gallen allein war 18 mal so groß wie das des Blattes; die bestentwickelten Gallen waren zu 1-8 auf einem Blatt.\n\n--- Seite 22 ---\nAus mehreren Hunderten der gesammelten Gallen kam kein einziger Gallenbildner zum Vorschein, sondern nur Parasiten. Im folgenden Jahre 1884 waren diese Gallen-Bildungen plötzlich äußerst selten geworden. Ziemlich häufig traten sie wieder in den Jahren 1885 und 1886 auf, sehr häufig im Jahre 1887, häufig noch 1888 bis 1889, ziemlich häufig von 1890-1894, sehr selten im Jahre 1895, im folgenden Jahre 1896 konnte ich kein einziges Exemplar auffinden (Kieffer 1914: 35). [vgl. hierzu den Entwicklungsgang in Südtirol: Nr. 89].\nDieses Beispiele unterstreichen die Wichtigkeit, dass Untersuchungen über Gallwespen und deren Gallen möglichst in mehrjährigen Folgen durchgeführt werden. Nur so kann man zu Aussagen über Häufigkeit und Wechsel in der Abundanz kommen.\nEinen nicht unwesentlichen Einfluß auf die Abbundanz mancher Gallwespenarten scheinen auch die menschlichen Sammeltätigkeiten der Gallen zu haben. Bei einer Untersuchung in der Türkei (Klein Asien), über das dort auch heute noch üblichen Sammeln von Eichengallen als forstwirtschaftlicher Nebenerwerbszweig, wurde festgestellt, dass dabei zu wenig auf Nachhaltigkeit geachtet werde durch richtige Abstimmung von Zeitpunkt des Sammeln und Ort Lagerung der Gallen (Eroğlu 2000):\n\"Gall production in Turkey is still far from what is expected because of inefficient gall harvesting strategies. Galls collected in an area are not usually kept or stored in a close vicinity of woodlands so as to give the adults a chance to go back to the woodlands for their next generation. Early harvest or early removal of galls results in not only the loss of crop but also the reduction in the population of gall wasps. Gall inducers do not move from place to place seeking food as to other phytophagous insects, but remain stationary and create highly nutritious food at their feeding sites.\"\nEs fällt bei uns weiters auf, dass einige Gallwespen, mit Gallenbildung an krautigen Pflanzen, speziell an Korbblütlern (Asteraceae) und Lippenblütlern (Lamiaceae) - in Italien und Südtirol bisher fehlen. Es handelt sich dabei um Arten der Tribus Aylacini mit westmediterraner Verbreitung wie: Isocolus lichtensteini an Centaurea aspera, Aulacidea\nfollioti an Sonchus asper, Timaspis phoenixopodos an Lactuca viminea - letztere rezent in Sizilien gefunden (Turrisi \\& Pagliano 2004). - Auch weitere Arten mit west- bis mitteleuropäischer Verbreitung fehlten bisher in Italien und Südtirol, wie Phanacis centaureae an Flockenblume (Centaura sp.), Timaspis lampsanae an Rainkohl (Lapsana communis), oder Timaspis lusitanica an BlasenPippau (Crepis vesicaria). Einige weitere hier noch fehlende Arten sind zu erwarten, wie Liposthenes kerneri an Katzenminze (Nepeta: Lamiaceae) und Phanacis hypochoeridis an Ferkelkraut Hypochoeris (Asteraceae).\nErhebliche Fortschritte in der Erfassung der Tribus Aylacini [Nr. 01-17] wurden hingegen rezent aus Friaul-VG gemeldet durch E. Tomasi (2007: 131), der aus den \"Prealpi Giulie\" ein gutes Dutzend Neufunde für diese Region und teilweise auch für Italien auflistet.\nHinsichtlich ihrer Häufigkeit und weiten Verbreitung in Südtirol wären folgende Arten vorrangig zu nennen: Diplolepis rosae (= Rosen-Bedeguar), D. eglanteriae, Cynips quercusfolii, Biorhiza pallida, Neuroterus anthracinus, N. aprilinus, N. quercusbaccarum, Andricus fecundator, A. solitarius. Die wirtschaftliche Schädlichkeit, die durch Gallwespen entstehen kann, erscheint relativ gering. Schäden mit Absterbensfolge von Kronenteilen an Zerreichen wurden im Trentino durch Aphelonyx cerricola, Andricus cydoniae und Pseudoneuroterus macropterus beobachtet, solche an Flaumeichen durch Andricus caputmedusae und A. quercustozae (vgl. Eiche: Abb. IV) und teilw. auch A. kollari. Als schädlich an jungen Eichenheistern, sowohl im Freiland als auch in Pflanzgärten, wird Andricus sieboldi genannt (Riedel 1910: 18), für den von hier aber noch keine Nachweise vorliegen. - Auch Biorhiza pallida wird bei gelegentlichem Massenauftreten als schädlich angegeben, da viele Maitriebe unentwickelt bleiben (Altum 1874, cit. Riedel 1910: 18). - Als wichtiger, rezent eingeschleppter Schädling der Edelkastanie gilt die asiatische „Kastaniengallwespe\" Dryocosmus kuriphilus; diese kann in den italienischen Einschleppungsgebieten verheerende Schäden verursachen (Abb. 91).\n\n--- Seite 23 ---\n![img-5.jpeg](img-5.jpeg)\n\nAbb. IVa: Gallenstrauch Rovereto 2005:\nA. quercustozae (alt)\n![img-6.jpeg](img-6.jpeg)\n![img-7.jpeg](img-7.jpeg)\n\nAbb. IVb: Gallenbaum Rovereto 2007:\nA. quercustozae + A. caputmedusae\n![img-8.jpeg](img-8.jpeg)\n\nAbb. Va: Gallenbaum Pomarolo 2008\n![img-9.jpeg](img-9.jpeg)\n\nAbb. Vb: Gallenzweig Pomarolo 2007\n\n--- Seite 24 ---\n![img-10.jpeg](img-10.jpeg)\n\nAbb. VI: A. caputmedusae Castelfeder (Fotos oben und Mitte)\n\nAbb. VII: A. kollari-Stutzeiche Castelfeder (Frühjahr)\n( beide Fotos unten)\n![img-11.jpeg](img-11.jpeg)\n![img-12.jpeg](img-12.jpeg)\n![img-13.jpeg](img-13.jpeg)\n\n--- Seite 25 ---\n![img-14.jpeg](img-14.jpeg)\n\nAbb. VIII: Kollari-Galleneiche Castelfeder (Juli)\n\nAbb. IX: Massenbefall quercusfolii (Brixen 2008) (Foto oben r. und Mitte r.)\n\nAbb. X: „Knopperngallen\" - Brixen (Fotos unten)\n![img-15.jpeg](img-15.jpeg)\n![img-16.jpeg](img-16.jpeg)\n![img-17.jpeg](img-17.jpeg)\n![img-18.jpeg](img-18.jpeg)\n\n--- Seite 26 ---\n# 6 Historische und wirtschaftliche Bedeutung der Gallen \n\nEichengallen fanden schon in ältesten Zeiten Verwendung zu verschiedenen Zwecken, vor allem in therapeutischer Heilkunde, als adstringierendes Mittel gegen Fieber, Zahnweh u.a., wie von Theophrastos, Hippocrates, Plinius u.a. beschrieben, und speziell auch zum Färben. Nach Theophrastos wurden Eichengallen von den alten Griechen zum Schwarzfärben der Wolle und wollener Stoffe gebraucht. Die damals gebräuchlichste Art erhielt daher auch den Namen „Färbergalle\" gallatinctoria. Noch häufiger wurden Eichengallen zur Herstellung schwarzer Tinte gebraucht; bereits im Altertum war im südöstlichen Mediterranean die Herstellung von Tinte aus Eichengallen bekannt. Bis Mitte des 20. Jh. waren Schreibtinten in Europa „Eisengallus-Tinten\", d.h. aus Galläpfeln von Eichen gewonnene gallus-gerbsäurehaltige Extrakte (pulversiert und in Wasser gelöst), die mit einem Eisensalz (Chloride oder Sulfate) versetzt wurden (gallussaures Eixenoxyd).\n„Der am meisten geschätzte Gallapfel war die Aleppo-Galle (Diplolepis gallae-tinctoriae), die in der Türkei, in Syrien und Persien in solcher Menge gesammelt wurde, dass die Provinz Aleppo allein noch vor etwa 150 Jahren [um 1864] jährlich 10.000 - 12.000 Zentner exportieren konnte. Weniger geschätzt war die südeuropäische Cynips tinc-toria-nostra [später geführt als Cynips infectoria Htg.], bekannt aus Sizilien (durch De Stefani), aus Norditalien als \"Galle d'Istrie\" (Hartig und Trotter), aus Südfrankreich (De Fonscolombe) und aus Niederösterreich (Mayr, Wachtl), sowie die in Mit-tel- und Südeuropa häufige Cynips kollari-Galle\" (Kieffer 1901: 567-568; 1914: 37).\nEbenfalls bereits seit dem Altertum bekannt war die Eignung gewisser Gallen für die Gerberei. Die zu diesem Zwecke gebrauchten Gallen waren die von Cynips gallae-tinctoriae, C.kollari, C.lignicola, C.hungarica und C. insana sowie besonders die „Knoppern\", d.h. die Gallen von Cynips quercuscalicis. Letztere wurden besonders in Ungarn, Bosnien, Serbien, Griechenland und Kleinasien gesammelt (Abb. X); ein Baum soll dabei jährlich 6-10 Zentner Gallen geliefert haben, so dass diese Eichen den Hauptreichtum mancher Gutsbesitzer bildeten (Kieffer 1914: 37).\n\nBis in die Neuzeit wurden daher Eichengallen, wegen ihres hohen Gerbstoffgehaltes, in der Gerberei, Färberei und zur Tintenfabrikation verwendet. Besonders für Österreich und die LavanteLänder waren sie damals (Ende des 19. Jh.) von erheblicher wirtschaftlicher Bedeutung (Trotter 1904). So wurden z. B. von 1882-1885 in Österreich, dem damaligen hauptsächlichen Erzeuger-, Verwendungs- und Umschlagsland rd. 26000 t aus anderen Ländern eingeführt und ca. 43000 t nach westlichen Ländern ausgeführt (Escherich 1942, cit. Gauss 1982).\nDer Gerbstoffgehalt schwankte bei den damaligen Handelssorten erheblich nach Gallenart, Herkunft, Gallenbesatz, Witterung und Sammelzeit. Bei „Knoppern\" von Andricus quercuscalicis lag er bei etwa $30 \\%$, bei Levantiner-Gallen von A. gallaetinctoriae erreichte er bis zu $60 \\%$. Der Preis für 100 kg Rohknoppern betrug damals (Ende 19. Jh.) in Deutschland etwa 15 Goldmark, für gemahlene Ware um $40 \\%$ mehr. Die besten Gallensorten wurden in Ungarn, Nord- und Mitteljugoslawien geerntet und in den großen Eichenwaldungen teilweise sogar kultiviert (Gauss 1982).\nBei der damaligen Bedeutung der Knoppern und anderen Eichengallen für die Gerberei, wurde sogar vorgeschlagen, die Zerreiche in mittel-, west- und nordeuropäischen Eichenbeständen beizumischen, um teure Einfuhren einzusparen. Über diese bereits im Kap. 4 erwähnte bedeutsame Rolle, welche die Zerreiche (Q. cerris) als obligatorischer Zwischenwirt der Sexualgeneration von Eichengallwespen, bei der Verbreitung von Eichengallen in Europa spielt, wußte man allerdings erst zu Beginn des 20. Jh. Bescheid, nachdem BeYERINCK (1896) darauf hingewiesen und darüber berichtet hatte.\n\nDie Ernte und der Handel mit Eichen-Gallen aus südosteuropäischen Herkunftsländern kam erst ab den 1920er Jahren, durch neuartig (tw. synthetisch) hergestellte Gerb- und Färbstoffe, fast völlig zum Erliegen (SchimitscheK 1944). Er bleibt aber weiterhin von historischem Interesse, da er auch waldbaulich die heutige weite Verbreitung der Zerreiche in Mittel- und Nordeuropa mit erklärt.\nEin weiterer kulturhistorisch interessanter Aspekt war die frühere Verwendung von Eichengallen zur\n\n--- Seite 27 ---\nBeleuchtung. Dazu brannten die alten Griechen in ihren Lampen nach Theophrastos eine schwarze harzige und eine kugelige, hartkernige, mit einem wollartigen Haarbüschel versehene Galle. Letztere wurde nach (Kieffer 1914: 37) später als die Galle von Cynips theophrastea erkannt (ein flaumiger bis 5 cm langer Beutel umhüllt eine harte, frei rollende innere Larvenkammer). Hingegen blieb erstere Galle noch rätselhaft; sie soll nach Plinius oftmals die Grösse eines Apfels erreichen, aus Kleinasien herstammen und geeignet sein, auch ohne Öl in den Lampen zu brennen. Nach dieser Beschreibung kann es sich m.E. wohl nur um die sog. „Sodomsäpfel\" der Bassorah-Galle Cynips insana handeln. Theophrastos von Eressus (371-286 v. Chr.), ein bedeutender Naturwissenschaftler und Philosoph von der griechischen Insel Lesbos (NE-Aegeis, vor der Küste Kleinasiens) und Zeitgenosse von Aristoteles (384-322 v. Chr.), befasste sich extensiv mit Eichen in seinen botanischen Schriften. Detailliert befasste er sich auch mit Eichengallen und beschrieb die äußeren Merkmale von 10 Gallen die von Eichen erzeugt werden und die sich folgenden Arten zuordnen lassen (nach G. Senn: 1942): (Abb. XI-XX)\n1.Aleppo gall (Cynips tinctoria), 2. Bassorah gall (Cynips insana), 3. Mulberry gall (Cynips caliciformis), 4.Phallus gall (Cynips quercus-tozae), 5. Felted or Woolly gall (Andricus theophrasteus), 6. Hairy Honey gall (Andricus lucidus), 7. Axillary (or Hop) gall (Andricus fecundator), 8. Crumpledleaf gall (Andricus multiplicatus), 9. Currant (or Translucent, watery leaf) gall (Neuroterus baccarum), 10. The doubtful gall by Cynips kollari. Die richtige Identifizierung einige dieser Eichengallen des Theophrastus wurden später von manchen\n\nAutoren, Übersetzern und Kommentatoren angezweifelt, wie etwa von Amigues (1989), welche die Nr. 7 und Nr. 9 infrage stellte und letztere als „durchscheinend, wässerig\" beschriebene Blattgalle eher auf Dryophanta folii (= C. quercusfolii) passend erachtete, hingegen an Cynips kollari nicht zweifelte.\nIch würde eher die Richtigkeit von Nr. 3 \"Maulbeergalle\" anzweifeln, da die dafür angegebene Cynips caliciformis eine kleine, unscheinbare, wenig bekannte Galle ist, die kaum Aufmerksamkeit findet, im Gegensatz zu der auch in Kleinasien häufigen \"Cynips calicis\" (Andricus quercuscalicis) (Abb. X). Bei Nr. 7 käme als \"Currant-gall\" (= JohannisbeerenGalle) wohl auch Andricus grossulariae in Betracht (Nr. 47). Auch fehlt in der obigen Liste die „Baumwollgalle\" von Andricus quercusramuli, die nach Kieffer (1901: 409) „bereits von Théophrast beobachtet wurde und später von Marchand (1692: 71)\".\n\nLiteratur: Senn G., 1942: Oak galls in the Historia Plantarum of Theopharstus. - Roy.Soc.Edin.60: 343-355. - Amigues S., 1988, 1989, 1993, 2003: Notes. In: Amigues (translator and commentator): Théophraste, Recherches sur les Plantes, I-IV. Paris [in ancient Greek with French translation]. Thanos C.A. 2005: Theophrastus on Oaks. Botanika Chronika, 18 (1): 29-36. - Trotter A., 1904: Alcune notizie sulle noci di galla del commercio. Marcellia, 3: 146-151. - Kieffer, J.J. 1914: Die Gallwespen (Cynipidae). - In: Schröder, Ch.: Die Insekten Mitteleuropas insbesondere Deutschlands, Bd. 3: Hymenopteren (Dritter Teil): 1-94. - Franckh, Stuttgart.\n\n--- Seite 28 ---\n![img-19.jpeg](img-19.jpeg)\n\nFig. 133.\nG. gallae-tinctoriae, Galle ( $1 / 4$ ).\n![img-20.jpeg](img-20.jpeg)\n![img-21.jpeg](img-21.jpeg)\n\nAbb. XI: Aleppo gall (Cynips tinctoria) Färbergalle (oben I.)\nAbb. XII: Bassorah gall (Cynips insana) Sodomsapfel (oben r.)\nAbb. XIII: Mulberry gall (Cynips caliciformis) Maulbeergalle (Mitte I.)\nAbb. XIV: Phallus gall (Cynips quercus-tozae) Phallusgalle (Mitte r.)\nAbb. XV: Felted or Woolly gall (Cynips\ntheophrastea) - verfilzte od. Wollgalle (unten)\n\n--- Seite 29 ---\n![img-22.jpeg](img-22.jpeg)\n\nAbb. XVI: Hairy Honey gall (Andricus lucidus) - Haarige Honiggalle (beide Fotos oben)\n\nAbb. XVII: Axillary (or Hop) gall (Andricus fecundator) - Artischocken- od. Hopfengalle\n![img-23.jpeg](img-23.jpeg)\n\nAbb. XIX: Currant (or Translucent, watery leaf) gall (Neuroterus baccarum) - BeerenBlattgalle\n![img-24.jpeg](img-24.jpeg)\n\nAbb. XVIII: Crumpled-leaf gall (Andricus multiplicatus) - zerknüllte Blättergalle [aus Henschel]\n\n--- Seite 30 ---\n![img-25.jpeg](img-25.jpeg)\n\nAbb. XXa: Cynips kollari \\& „Knoppergalle\"\n![img-26.jpeg](img-26.jpeg)\n\nAbb. XXb: Cynips kollari - Murmelgalle\n\n# 7 Geschichte der Gallenkunde (Cecidologie) \n\nDer Begriff „Pflanzengallen\" (Cecidien) war bereits im Altertum geläufig und wurde im vorderasiatischen und griechischen Kulturkreis verwendet. Die alten Griechen bezeichneten solche Auswüchse an diversen Pflanzenteilen als \"Kekis\" (\"das Hervorquellende\"), im Lateinischen wurden sie später als \"galla\" bezeichnet, ein Begriff der auch in den modernen Sprachen erhalten blieb. Früher betrachtete man alle Gallen als eine Art „Nuß-Frucht\" der jeweiligen Pflanze; diese Begriffe haben sich in einigen Sprachen bis in die Neuzeit erhalten, so etwa im Englischen \"gall-nuts\", französisch \"Noix de galle\" oder italienisch \"Noci di Galle\". - Die eigentliche wissenschaftliche Gallenkunde begründet dann erst Marcello Malpighi (1628-1694), Arzt aus Bologna und Begründer der mikroskopischen Anatomie. In seinem zweibändigen Werk „Anatomes plantarum\" (London, 1687) werden unter dem Kapitel \"De Gallis\" [Tom 2: 112-132] erstmals verschiedene Gallformen und Details gründlich untersucht, voneinander abgegrenzt, kurz lateinisch beschrieben und abgebildet: „Morbosis frequenter tuberescentibus tumoribus, quos Gallarum nominibus exponemus\". Von den auf XII Bildtafeln dargestellten 72 Figuren Malpighi's, lassen sich heute rd. 45 verschiedene Gallenformen unterscheiden, der Großteil davon (rd. $75 \\%$ ) Gallwespen betreffend. Weiterhin steht im Mittelpunkt dieser Abhandlung die Erkenntnis,\ndass jede Gallbildung - Gallae sunt morbosi plantarum tumores - durch Insekten oder Parasiten ausgelöst wird. Auf Malpighi und seinem bedeutenden Landsmann und Zeitgenossen Francesco Redi (1626-1697) aus Pisa, folgten im 17./18. Jh. eine Reihe weiterer namhafter Naturwissenschaftler, die sich auch intensiv mit Gallenbildungen befassten: R.-A. F. de Réaumur (1683-1757), A. J. Rösel von Rosenhof (1705-1759), É. L. Geoffroy (17251810), A.F.de Fourcroy (1755-1809), G. Olivier (1756-1814), J. C. Fabricius (1745-1808) u.a.\n\nZu einer entscheidenden Zäsur mit Neubeginn kam es dann vor 250 Jahren, im Jahre 1758, mit der Editio decima von Linné's „Systema Naturae\", dem Beginn der wissenschaftlichen zoologischen Nomenklatur, begründet durch Carl von Linné (1707-1778). Bis dahin waren keine gültigen wissenschaftlichen Namen verfügbar, doch waren die Werke einiger der älteren Autoren - insbesondere F. Redi (1668), de Réaumur (1737) und Rösel von Rosenhof (1755) - derart vorzüglich mit naturgetreuen Bildern und Stichen illustriert, dass sie eine einwandfreie Erkennung der Artzuordnung ermöglichten und zudem bei den späteren Artbeschreibungen, z.B. durch Linné 1758 oder Geoffroy \\& Fourcroy (1762 u. 1785), teilweise sogar als Bildreferenz angeführt waren.\n\n--- Seite 31 ---\nEs ist bemerkenswert, dass viele der auf alten Abbildungen des 17./18.Jh. erkennbaren und unterscheidbaren Gallen erst gegen Mitte des 19.Jh. wissenschaftlich benannt und beschrieben wurden. Besonderen Anteil daran hatte Forstrat Theodor Hartig (1805-1880), der in seinen Abhandlungen „Über die Familie der Gallwespen\" (1840, 1841, 1843) dazu schreibt: „Schon von Malpighi besitzen wir eine treffliche Arbeit hierüber, die jedoch dadurch außer Acht gekommen ist, dass sie weder von Linné noch von Fabricius benutzt wurde, wie dies mit den, gleichfalls reichhaltigen Arbeiten Reaumur's, Roesel's, Frisch's und andern der Fall war. \"\nTatsächlich beruft sich Hartig in seinen „Gallwespen\" auf 16 Gallenabbildungen von Malpighi, das ist etwa die Hälfte der zuordenbaren GallwespenAbbildungen Malpighi's (vgl. Hellrigl 2008b). Einen vielleicht noch größeren Schatz an Gallendarstellungen stellen die qualitativ besonders hervorragenden Abbildungen im Nachlaß von Francesco Redi aus Pisa dar, die um 1666-1667 in Zusammenarbeit mit dem Florentiner Kunstmaler Filizio Pizzichi entstanden waren. Dieser Hort schlummerte über 300 Jahre unbeachtet als Manuskript von F. Redi in den Archiven der „Biblioteca Nazionale Centrale di Firenze\" bzw. der „Biblioteca\n\n## 8 Artenliste Cynipoidea\n\n## Fam. Cynipidae - Gallwespen i.e.S.\n\nIn Mitteleuropa über 100 Arten, als phytophage Gallenbildner (ca. $75 \\%$ ) oder deren Inquilinen. In Südeuropa werden für Spanien ca. 125 Arten angegeben, in Italien ebenfalls ca. 125 (nach Bereinigung der Synonyme in Checklist Ital. 1995). Ein Vergleich der angeführten Arten in \"Fauna Iberica\" (Nieves Aldrey 2001) mit \"Fauna Italiana\" (Pagliano 1995) zeigt, dass 53 Cynipidae-Arten ( $42 \\%$ ) der Fauna Italiens in Spanien fehlen; ein deutlicher Hinweis auf die faunistischen Unterschiede zwischen SW-Europa und SE-Europa. Dieser Unterschied ist bei den Gallwespen besonders durch das Fehlen der aus dem SE stammenden Zerreiche (Quercus cerris) in SW-Europa maßgeblich bedingt (vgl. Kap. 4: Zoogeographie; Tab. 3).\n\nMarucellina di Firenze\" und wurde erst vor rd. 20 Jahren von Lucia Tongiorgi-Tomasi entdeckt und 10 Jahre später gehoben und durch einen hervorragenden Text- und Bildband von W. Bernardi, G. Pagliano, L. Santini, F. Strumia, L. TongiorgiTomasi \\& P. Tongiorgi (1997) der Wissenschaft öffentlich zugänglich gemacht.\nMit Forstrat Theodor Hartig aus Braunschweig, dem eigentlichen Begründer der Systematik, wurde eine neue Periode eröffnet. In Deutschland schrieben über Gallwespen auch noch Schenck, Ratzeburg, Reinhard und Förster, in Österreich Giraud und Kollar, in Schweden Dahlbom und Thomson; hinzu kamen weitere Autoren in Nordamerika (USA). - Schon eine Generation später folgte ein Übergang zur klassischen Moderne, beginnend mit den gediegenen Arbeiten von Gustav Mayr (1830-1908) in Wien, in denen die Systematik weiter entwickelt und die Biologie sorgfältiger ergründet wurde. Zu erwähnen sind außerdem Dalla Torre und Kieffer, Adler, Schlechtendal, Beyerinck, Tschek, Wachtl, sowie italienische Autoren wie Massalongo, Trotter und De Stefani. - Damit haben wir eine Überleitung zur aktuellen Neuzeit, mit Autoren und Themen, die aus dem Literaturverzeichnis ersichtlich.\n\n## A. Gallenbildende Gallwespen\n\nTribus Aylacini: Nr. 01-17\nDie Arten aus dem Verwandtschaftskreis der Tribus Aylacini [Aulacidea, Aylax, Cecconia, Diastrophus, Isocolus, Liposthenes, Neaylax, Phanacis, Timaspis, Xestophanes] sind gekennzeichnet durch Gallenbildung an krautigen oder holzigen Pflanzen, die nicht zur Gattung Rosa, Acer und Quercus gehören. Entwicklungszyklus ist bisexuell und univoltin; kein Generations- und Wirtswechsel.\nDas Hauptproblem bei Suche und Auffindung all dieser an krautigen Pflanzen (Asterceae, Lamiaceae) lebenden Gallwespen der Tribus Aylacini liegt in der Erkennung ihrer Wirtspflanzen.\n\n--- Seite 32 ---\nGenus Aulacidea Ashmead 1897\nArten sind gebunden an Kompositen der Gattungen: Hieracium, Tragopogon, Scorzonera, Sonchus.\n\n01 Aulacidea [= Cynips] hieracii (Linnaeus 1758) [= Aulacidea hieracii (Bouché 1834) auct.]\nIn ganz Europa verbreitete, gemeine Art (Kieffer 1901: 307-311); es gibt dazu eine große Anzahl von Synonymen: Aylax sabaudi Hartig 1840, = Aulax artemisiae Thomson 1877, = crassinervis Thomson 1877, = foveiger Thomson 1877, = graminis Cameron 1875, = pigeoti Kieffer 1898, = schlechtendali Rübsaamen 1896. - Die \"Habichtskraut-Gallwespe\" verursacht an Habichtskraut (Hieracium sp., Asteraceae) eine ovoidale od. walzenförmige, bis 40 mm lange, mehrkammerige Galle im oberen Teil des Stängels. [Linné (1758: 553, n. 2), benannte die Galle zuerst: \"Cynips hieracii, habitat in Hieracii murorum galla caulina hirta.\" - Riedel 1910: 64, Taf. 5, Fig. 79. - Nieves-Aldrey 2001: 120, 522; Aulacid. hieracii (L.), Fig.120N. - Redfern et al. 2002: 344, A. hieracii (Bouché), Fig. 370].\nVon Dalla Torre (1892: 131-132) als Galle von Aulax hieracii Bouché mehrfach aus angrenzenden Gebieten Nordtirols gemeldet: im Ötztal an Hieracium albidum und bei Trins im Gschnitztal an H. alpinum (Löw, 1884); bei Innsbruck an H. murorum (April 1883, Peyritsch). - In Europa weit verbreitet (Dalla Torre \\& Kieffer 1910: 685); auch aus N-Italien angegeben [Checkl. Ital. 1995: 15/01].\nNach Tomasi (2007: 131) in den Prealpi Giulie an Hieracium pilosella, zusammen mit der folgenden.\nDie Art war in Südtirol-Trentino übersehen worden. Rezenter Erstnachweis für Südtirol: St. Anton bei Kaltern, 510 m, 27.07.2004, Galle an Habichtskraut Hieracium (leg. M. Skuhravá, coll. Hellrigl).\n[02] [Aulacidea pilosellae (Kieffer 1901)]\nAn „Langhaarigem Habichtskraut\" (Hieracium pilosella: Asteraceae) - bzw. dem als Synonym geltenden „Kleinen Habichtskraut\" Pilosella officinarum - kommen in Britannien und Mitteleuropa noch zwei weitere Arten vor: Aulacidea pilosellae (Kieffer 1901), mit eiförmigen Blattgallen entlang einer Mittelrippe im Spätsommer/Herbst (Riedel 1910: 65, Taf. 6, Fig. 80); [vgl. Bellmann: Foto 2006]; sowie Aulacidea subterminalis Niblett 1946,\nmit kugeligen Gallen am Stängel nahe der Blattrosette. [Nieves-Aldrey 2001: 121-122, 523, Figs. 120 A-B, D; Redfern et al. 2002: 344-345, Figs. 369, 373]. - Diese beiden Arten wurden aus Italien und Südtirol noch nicht bekannt.\n[03] [Aulacidea tragopogonis (Thomson 1877)]\nVerursacht an Wiesen-Bocksbart (Tragopogon pratensis: Asteraceae) unregelmäßig-höckerige, mehrkammerige Anschwellungen an der Stängelbasis oder den Wurzeln [Riedel 1910: 65, Taf. 6, Fig. 82; Nieves-Aldrey, 2001: 117, 522; Fig. 119 I; Redfern et al. 2002: 460, Fig. 950; p. 487: Plate 5.3]. - Checklist Ital. (1995: fehlt). - Weite Verbreitung in Mitteleuropa (Britann., Österr., Deutschl., Polen, Schweden, Spanien), lokal oft häufig (z.B. Ulm: Foto und persönl. Mitt. H. Bellmann, 2006). Von E. Tomasi (2007: 131) aus Friaul-VG von den \"Prealpi Giulie\" gemeldet, an Tragopogon pratensis. - In Südtirol zu erwarten (ebenso die Gallmücke Contarinia tragopogonis Kieff).\n[03B] [Aulacidea scorzonerae (Giraud 1859)]\nBekannt nur aus Österreich und Ungarn, nicht in Italien [Fauna Europaea 2007]. - Bildet 4-6 cm lange spindelförmige Stängelschwellungen, innen mit vielen kleinen kugeligen Gallen, an Österreichischer Schwarzwurzel Scorzonera austriaca [Kieffer 1901: 320-21, Aulax scorzonerae; Galle Pl.IX, Fig. 3]. Rezent von E. Tomasi (2006: 71) aus Trieste, Dolina, Moccò, 29.05.1993 (Foto) gemeldet, sowie aus Friaul-VG (2007: 131 \\& 164: Foto) von den \"Prealpi Giulie\" an Scorzonera austriaca (Asteraceae). - Vorkommen auch in SüdtirolTrentino scheint möglich.\n\nGenus Aylax Hartig 1840\nDie Gattung Aylax (= Aulax auct.) diente lange Zeit als Sammelbecken von sehr heterogenen Arten (Nieves-Aldrey 2001: 150). Indessen wurden einige vormals unter Aylax spp. geführte Arten in andere Gattungen gestellt (Isocolus, Liposthenes, Neaylax, Phanacis, Timaspis). Nieves-Aldrey (1994) zählt in Spanien nur mehr die an Fruchtkapseln von Mohn (Papaver) lebenden Arten zu Aylax.\nAuf gesamteuropäischer Ebene bedarf die Gattung Aylax einer dringenden Revision. Es werden hier weiterhin zahlreiche im 19.Jh. beschriebene\n\n--- Seite 33 ---\neuropäische Arten als Ballast mitgeschleppt, die nach den früheren Kurzbeschreibungen nicht mehr identifizierbar sind. Davon zählte schon Kieffer (1914: 54) als \"unsichere Arten\" aus Deutschland auf: Aylax parvula Schenck 1863, A.patens Hartig 1841, A. punctata Hartig 1840, A. rufiventris Schenck 1863, A. subterranea Hartig 1843, A. syncrepida Hartig 1841, an deren \"Status uncertain\" sich bis heute nichts geändert hat, und von denen, da sie späteren Bearbeitern unbekannt blieben, als „Vorkommen\" nur ihre Terra typica (Deutschland) aufscheint. Dasselbe gilt weiters für zwei nur aus der Czech Republic bekannte Taxa: Aylax trachelii Kirchner 1855 und A. verbasci Kaltenbach 1872, eine aus Italien A. picridis Kruch 1891, sowie zwei aus Frankreich: Aylax onobrychidis Kieffer 1895 und A. crassinervus Kieffer 1902 [vgl. Fauna Europaea 2007].\n\n## 04 Aylax minor Hartig 1840\n\n- Kleine Mohngallwespe\n\nDie \"Kleine Mohngallwespe\" verursacht unscheinbare Gallenbildung in Fruchtkapseln von Mohn, Papaver sp. (Papaveraceae), ohne auffällige Verformung der Kapseln; Befall erkennbar an den kleinen Ausfluglöchern. - [Nieves-Aldrey, 2001: 152, 525; Fig. 118 C-D, 135 E; Redfern et al. 2002: 372, Fig. 508; Buhr 1965: Nr. 4544; Riedel 1910: 62, Taf. 5, Fig. 72]. - Checklist Ital. (1995: 16/03).\nArt mit weiter Verbreitung (Britann., Frankr., Österr., Deutschl., Polen, Schwed., Italien, Spanien); A. minor fand ich am 04.08.2006 im Trentino/ Veneto in Anzahl bei Monte di S.Ambrogio Veronese. Die reifen Mohnkapseln waren hier nachträglich von einer kleinen südlichen Bodenwanze (Oxycarenidae), Brachyplax tenuis (Mulsant \\& Rey), zahlreich besiedelt worden (leg. Hellrigl, det. E. Heiss).\nIn Südtirol wurde Aylax minor in Tschötsch ( 750 m ) gefunden; befallene Kapseln von Klatschmohn (Papaver rhoeas) mit Fluglöchern der Gallwespen, an Wiesentrockenhang, 03.08.2007 (leg. G. v. Mörl). Eine weitere, der „kleinen Mohngallwespe\" nahe stehende Art, Aylax (Barbotinia) oraniensis Barbotin 1964, ist mediterran verbreitet, auch in Italien [vgl. Nieves-Aldrey, 2001: 146-149; Fig. 118 E].\n\n05 Aylax papaveris (Perris 1840) - Mohngallwespe Bei der \"Mohnkapselgallwespe\" kommt es zu Gallenbildung in Fruchtkapseln von Mohn, Papaver sp. (Papaveraceae), mit starker Anschwellung und Deformierung der Kapseln. Scheidewände auf kurze Leisten reduziert oder fehlend; im Inneren der Kapsel üppiges Wuchergewebe mit eingebetteten hartwandigen Gallen. [Buhr 1965: Nr. 4543; Nie-VES-AldREY, 2001: 152, 525; Fig. 118 A-B, 135 F; Riedel 1910: 61, Taf. 5, Fig. 71; Redfern et al. 2002: 372, Fig. 506-507; p. 487: Plate 5.4]. - Art mit weiter Verbreitung (Britann., Frankr., Österr., Deutschl., Polen, Schwed., Spanien), lokal oft häufig (z.B. in Ulm: persönl. Mitt. H. Bellmann, 2006). - Checklist Ital. (1995: fehlt). - Neu für Italien.\nNeufund für die Region Südtirol-Trentino und für Italien: Brixen-Kranebitt, Weinbergweg ( 600 m ), am Wegrand zahlreiche stark angeschwollene und deformierte Mohnkapseln (Abb. 5a), mit einzelnen harten Gallen und weißlichen Larven von A.papaveris im kompakten Wuchergewebe (Abb. 5b), 16.06.2008 (leg. Klaus \\& Max Schanung, det./Foto K. Hellrigl). - Aus befallenen deformierten Mohnkapseln schlüpften ab 30.06.08 mehrere Exemplare $(1,5,5)$ der spezifischen Parasitenwespe Ormyrus papaveris (Perris 1840), die bisher aus Italien nicht bekannt war (Fauna Europaea 2007). - In einigen deformierten schmäleren Gallen fand sich auch Mischbefall mit Mohnkapselgallmücke, Dasineura papaveris (Winnertz 1853), mit zahlreichen orangeroten Larven (Abb. 5d) und massenhaftem Schlüpfen der Gallmücken in den Zuchtdosen am 20.06.2008. Befall von Mohn-Gallmücke war in Südtirol bei St.Anton/Kaltern, 580 m , am 27.07.2004 von M. Skuhravà (2005) registriert worden; möglicherweise lag auch damals Mischbefall mit Mohn-Gallwespe vor, die im Frühjahr erscheint. Zu erwarten auch im Vinschgau an Mohn der Eisenbahnböschungen bei Naturns. - Im Trentino ist A. papaveris zu erwarten bei Pomaro-lo-Savignano in den Klatschmohnvorkommen am Straßenrand.\n\nGenus Diastrophus Hartig 1840\nGallen an Rosaceen der Gattung Rubus und Potentilla.\n\n--- Seite 34 ---\n## 06 Diastrophus rubi (Bouché 1834)\n\n- Brombeerrutengallwespe\n\nErzeugt vielkammerige, 3-8 cm lange zylindrische Stängelgallen ( $\\varnothing 1 \\mathrm{~cm}$ ) an Ruten von Brombeersträuchern (Rubus caesius, \"Rubus fructicosus\" auct.); einfacher Zyklus mit Männchen und Weibchen. [Buhr 1965: Nr. 5886, T. 19, Fig. 322; ZahradniK 1985: 89; ChinerY 1987: 227; Csóka 1997: 132; Redfern et al. 2002: 425, Fig. 772; Riedel 1910: 60, Taf. 5]. - Checkl. Ital. (1995: Nr. 21/01): N-Ital. In Friaul-VG aus Triest-Dolina, 09.01.1994 (Foto), gemeldet von Tomasi (2006: 73); sowie in den Prealpi Giulie Tomasi (2007: 131), von Rubus caesius und auch Rubus idaeus genannt.\nVon Dalla Torre (1892: 151) als Diastrophus rubi Htg. an \"Rubus fructicosus\"aggr. aus N-Tirol (Paschberg) angegeben. - In Südtirol wurde an hohen, dickstängeligen und kräftig langstacheligen Brombeersträuchern, wie z.B. „Furchenbrombeere\" (R. sulcatus), bisher vergeblich nach Diastrophus rubi gesucht. Auch die an Himbeerstauden (Rubus idaeus) häufig anzutreffenden Stängelgallen der Gallmücke Lasioptera rubi fanden sich hier nie an „Brombeeren\".\nVon Bezzi (1899) wurde Diastr. rubi aus Trentino im Val di Non bei Mollaro ( 470 m ) an Rubus caesius [= bereifte Brombeere] gemeldet, zusammen mit der Himbeerrutengallmücke Lasioptera rubi. - Die Angabe von Bezzi (Bz) wird zitiert von Cobelli (1903: 165); ein Gallenbeleg von Diastrophus rubi, mit außen aufgeklebten geschlüpften Gallwespen, findet sich im Naturkunde-Museum Rovereto (vid. Hellrigl 2007). - Die zigarrenförmigen Gallen an Brombeer-Trieben waren mir auch in Südtirol untergekommen, früher bei der Suche nach Prachtkäfern (Coroebus rubi, Agrilus aurichalceus).\nAuch in Osttirol sind die trockenen, hellgrauen Gallen der Brombeerruten-Gallwespe (Abb. 6a) nach A. Kofler (2007) im Winter an laublosen Zweigen zu finden und nicht selten (z.B. bei Leisach, rechter Drauweg). Gallen von Diastrophus rubi finden sich in Lienz/Osttirol - zusammen mit kugeligen, rindenbraunen Gallen der Gallmücke Lasioptera rubi (Fotos) - an niederen, kurz- und weichstacheligen, dünnen Brombeerruten ( $\\varnothing 2-4 \\mathrm{~mm}$ ) von Rubus caesius. Diese Beobachtung bei einem gemeinsamen Lokalaugenschein im Okt. 2008 führte zur Erkenntnis, dass die Art nicht generell an\n„Brombeeren\" zu suchen ist, sondern speziell an der auch hier in Südtirol vorkommenden dünnrutigen „bereiften Brombeere\" Rubus caesius, aus deren Gallen sie schon Hartig (1840: 194; 1843: 411) bei Hannover und in der Umgebung Brauschweigs gezogen hatte.\n[07] [Diastrophus mayri Reinhard 1876]\nErzeugt länglich-wulstige, spindelförmige Stängelverdickungen (long. $10-30 \\mathrm{~mm}$; $\\varnothing 5-15 \\mathrm{~mm}$ ) im oberen Teil der Sprossachse von Silber-Fingerkraut Potentilla argentea L. - [BuHR 1965: Nr. 5166, T. 13: Fig. 200; Riedel 1910: 60, Taf. 5, Fig. 68; Bellmann 2006: pers. Mitt. und Foto].\nIn weiten Teilen Europas nachgewiesen (Buhr 1965), insbesondere aus Frankreich, Deutschland und Ungarn bekannt. Fehlt in Checklist Ital. (1995); könnte aber auch für die Schweiz, Österreich und Südtirol zu erwarten sein, wo die Wirtspflanze kollin bis subalpin vorkommt.\n\n## Genus Isocolus Förster 1869\n\nDie Arten sind gebunden an Kompositen der Gattung Centaurea (Flockenblume) u.a. Asteraceae.\n\n## 08 Isocolus scabiosae (Giraud 1859)\n\n[= Aulax scabiosae (Giraud 1859) auct.]\n[= Isocolus rogenhoferi Wachtl 1880]\nDie Skabiosen-Gallwespe I. scabiosae verursacht große knotenförmige mehrkammerige Gallen am Stängel von Centaurea scabiosa (Asteraceae). Nach Nieves-Aldrey (2001: 522) ist I. rogenhoferi Wachtl ein Synonym zu I. scabiosae, doch werden beide oft noch als getrennte Taxa geführt; es gibt auch kleine reiskornähnliche Gallen in Blütenköpfen von Centaurea scabiosa, an der Innenseite der Hüllenblättchen, in denen sich eine etwas kleinere Form entwickelt (= rogenhoferi).\n[Riedel 1910: 62, Taf. 5, Fig. 74 (Aulax scabiosae); Riedel 1910: 63, Taf. 6, Fig. 77 (A. rogenhoferi); Buhr 1965: Nr. 1583, 1603 (scabiosae); Nr. 1621, 1640 (rogenhoferi); Redfern et al. 2002: 305, Fig. 188 (scabiosae); 306, Fig. 196 (rogenhoferi); Bestimmungsschlüssel vgl. Kieffer 1914: p.5254].\nIn Checklist Ital. (1995: 16/05) als Aylax rogenhoferi (Wachtl) aus N-Italien erwähnt; ihre Verbreitung reicht von Schweden über Mitteleuropa bis Spanien.\n\n--- Seite 35 ---\nSolche Stängelgallen (Nieves-Aldrey 2001: 107, 521; Fig. 120 K) oder angeschwollene Blütenköpfe wurden auch in Brixen Umg. beobachtet (Hellrigl 1996: 690, als Aylax scabiosae Giraud). Auch in Osttirol, in Lienz Umgeb., seit 1985-2002 öfters aus Blütenköpfen von Centaurea (Flockenblume) gezogen (leg./coll. A. Kofler, vid. Hellrigl).\n[09] [Isocolus jaceae (Schenck 1863)]\nBildet Fruchtgallen in den Blütenköpfchen von Wiesenflockenblume Centaurea jacea und Centaurea nigra (Asteraceae). Es kommt zu einer Vergallung der „Achänen\", den einsamigen Schließfrüchten der Korbblütler (Asteraceae). [Riedel 1910: 63, Taf. 6, Fig. 76; Redfern et al. 2002: 306, Fig. 195].\nAls Synonyme werden von MAYR angegeben: Aylax patens Hartig 1841, Aulax affinis Schenck 1863.\nDiese kleinere Art gilt als selten und ist in Britannien, Frankreich, Deutschland, Polen, Österreich verbreitet; fehlt hingegen in Spanien und in Checklist Italien (1995). - In Osttirol, in Lienz Umgeb. bei Nörsach, am 27.02.2002, 2 Ex. aus Blütenköpfen von Centaurea gezogen (leg. A. Kofler). Aufgrund dieses Vorkommens sollte die Art auch in Südtirol (z.B. Pustertal) zu erwarten sein.\n\nIn Österreich gibt es noch eine Isocolus serratulae (Mayr 1882) mit Gallen an Serratula heterophylla.\nFür Südtirol und Italien kaum zu erwarten ist die mehr im Westen (Britann., Lothringen, Spanien) verbreitete Isocolus fitchi (Kieffer 1898). An Centaurea scabiosa Gallen in Form erbsenförmiger Anschwellungen der Mittelrippe oder des Blattstieles [Riedel 1910: 64, Taf. 5, Fig. 78 (Aulax fitchi)].\n\n## Genus Liposthenes Förster 1869\n\nGallen an Arten der Gattungen Glechoma und Nepeta.\n\n10 Liposthenes glechomae (Linnaeus 1758)\n$[=$ Aulax latreillei Kieffer 1898]\nVerursacht an Blättern von Gundermann oder Gundelrebe (Glechoma hederacea) [Fam. Lamiaceae] kugelige, einkammerige, stachelbeerartig dicht behaarte, grüne bis rötliche Gallen ( $\\varnothing 6-17 \\mathrm{~mm}$ ), die im Herbst reifen [vgl. Riedel 1910: 62, Taf. 5, Fig. 73; Pellizzari 1988: 62; Chinery 1987: 227, als Liposthenus latreillei. - CsóKA 1997: 56; NieVes-\n\nAldrey 2001: 132, 523; Fig. 118 N). - In Checklist Italien (1995: 16/02; 26/01) für N-Italien doppelt geführt als Aylax latreillei (Kieff.) und Liposthenes glechomae (L.). In Friaul-VG aus Triest-Dolina, 12.06.1993, gemeldet von Tomasi (2006: 74).\n\nDalla Torre (1892): Gallen von Aulax glechomae Htg. an Glechoma hederacea L., Sigmundskron bei Bozen (Mayr 1874: 90); auch mehrfach in N-Tirol gefunden. - Südtirol rezent: Pustertal, Sand in Taufers, $900 \\mathrm{~m} ; 04.07 .2003$, div. Gallen an Glechoma (M. Skuhravá: pers. Mitt.). - Rezente Nachweise auch in Osttirol: Lienz (A. Kofler, 2007) (Abb. 10). Keine Nachweise aus Trentino bekannt.\n[11] [Liposthenes kerneri (Wachtl 1891)]\n[= Aulax kerneri Wachtl 1891]\nVerursacht an Katzenminze, Nepeta sp. (Lamiaceae), kugelige Blüten-Fruchtgallen ( $\\varnothing 5 \\mathrm{~mm}$ ) mit vergrößertem Kelch; Gallenreife VII.-VIII., Wespe im Frühjahr, univoltin. - [Wachtl 1891: 277-281, Taf. 2; Buhr 1965: Nr. 4406, Aylax kerneri; NievesAldrey 2001: 134, 524; Fig. 118 L, 136 B]. Verbreitung M- und S-Europa: Österr., Ungarn, Rumän., Italien, Spanien, Ukraine, Krim, Kleinasien (Fauna Europaea 2007). - Checklist Ital. (1995: fehlt). Südtirol: In Brixen Umg. trotz gezielter Suche bisher nicht entdeckt, doch vielleicht zu erwarten.\n\nGenus Neaylax Nieves-Aldrey 1994\nEinige Arten der früheren Großgattung Aylax Hartig 1840 (= Aulax auct.), wurden neuerdings in andere Gattungen gestellt. Darunter auch die Gattung Neaylax mit Gallenbildung an Salbei (Salvia):\n[12] [Neaylax (= Aulax) salviae (Giraud 1859)]\nNeaylax salviae verursacht Blüten-Gallen an Gar-ten-Salbei Salvia officinalis (Lamiaceae); die aus Fruchtknoten und Blütenboden gebildete Galle ist kugelig, knollig, erbsengroß, mit mehreren Innengallen [Riedel 1910: 66, Taf. 6, Fig. 85]. Die Art wird in Checklist Ital (1995: 16/06) für N-Italien angegeben. Möglicherweise handelt es sich um (teilweise) Verwechslung mit der folgenden Art:\n[12b] [Neaylax verbenacus (Nieves-Aldrey 1988)] [= Isocolus verbenaca], lebt an Eisenkraut-Salbei Salvia verbenaca und Wiesen-Salbei, Salvia pratensis, (Nieves-Aldrey 2001: 126, Figs. 118 p-Q). In\n\n--- Seite 36 ---\n„Fauna Europaea\" (2007) wird als Verbreitung von N. salviae Deutschland, Italien, Slovenien angegeben (fehlt in Britannien, Österreich, Spanien), hingegen für $N$. verbenaca Portugal, Spanien und Itali-en-Festland (fehlt aber in Checklist Ital. 1995). Von E. Tomasi (2007: 131) rezent als \"Neaylax salviae\" aus Friaul-VG von den \"Prealpi Giulie\" gemeldet, an Salvia pratensis; jedoch nach dieser Wirtspflanze wohl eher $\\boldsymbol{N}$. verbenacus. - Beide Taxa wurden aus Südtirol noch nicht bekannt.\n\n## Genus Phanacis Förster 1860\n\n[13] [Phanacis centaureae (Förster 1860)]\nVerursacht unauffällige Stängel-Gallen an Flockenblumen Centaura spp. [C. ornata, C. scabiosa, C. aspera] (Asteraceae); [Riedel 1910: 63, Taf. 5, Fig. 75. Redfern et al. 2002: 305, Fig. 187. NievesAldrey, 2001: 168, 526; Fig. 120 G-H]. - Verbreitet in Mittel- und Westeuropa (Britannien, Frankreich, Deutschland, Polen, Schweden, Spanien). - Checklist Ital. (1995: fehlt). Die von E. Tomasi (2007: 131) rezent aus Friaul-VG von den \"Prealpi Giulie\", als \"Phanacis centaureae (Förster)\" an Centaurea jacea gemeldet Art, ist wahrscheinlich auf Isocolus jaceae zu beziehen.\nDiese und einige weitere verwandte Arten mit west- bis mitteleuropäischer Verbreitung fehlen bisher in Italien und Südtirol, wie etwa Phanacis taraxaci (Ashmead 1897) an Löwenzahn, Taraxacum [Redfern et al. 2002: 453, Fig. 912], bisher nur aus Britannien bekannt; zu verifizieren eine rezente Meldung für Ph. taraxaci von Tomasi (2007: 131) von den \"Prealpi Giulie\" an Taraxacum officinale.\n\nWeiters fehlen bisher Phanacis caulicola (Hedicke 1939) - an Natterkopf-Bitterkraut, Picris echioides L. [Redfern et al. 2002: 377, Fig. 531] - bekannt aus Britannien, Polen, Spanien. - Möglicherweise zu Phanacis zu stellen ist nach Nieves-Aldrey (2008) eine Art, die in Italien an Picridium vulgare gefunden und als Aylax picridis Kruch 1891 beschrieben wurden (vgl. Checkl. 1995: Nr.16/05).\n\nWeitere Phanacis-Arten kommen in Südeuropa (Sizilien, Spanien) an Bitterkraut Picris sp. (Asteraceae) vor (Nieves-Aldrey et al. 2008).\n\n14 Phanacis hypochoeridis (Kieffer 1887)\n[Syn. = Phanacis seriolae Stefani 1903]\nErzeugt an Ferkelkraut Hypochoeris radicata (Asteraceae) große mehrkammerige Gallen $(10 \\times 60 \\mathrm{~mm})$ in auffälligen Stängelverdickungen [vgl. Chinery 1987: 227; Nieves-Aldrey 2001: 173, 526; Fig. 119d, 137c; Redfern et al. 2002: 349, Fig. 392; Buhr 1964: Nr. 3386 Aulacidea hypochoeridis]. - Aus einer im Juni 2003 in Sardinien (S. Teodoro) gesammelten Stängelgalle (leg./ Foto: G. v. Mörl: Abb. 14) schlüpften bei Aufzucht in Brixen einige Gallwespen und Parasitoiden (Abb. 14b).\nAus Italien (Checklist 1995: Nr. 16/01; 29/02) doppelt angeführt: vom Norden (Aylax hypochoeridis) sowie vom Süden und Sizilien (Phanacis hypochoeridis); bisher nicht aus Sardinien bekannt. Von E. Tomasi (2007: 131) aus Friaul-VG von den \"Prealpi Giulie\" gemeldet, an Hypochoeris maculata. Verbreitungsangaben sind widersprüchlich: nach Kieffer (1901: 300-01) in Britannien, Deutschland, Österreich, Frankreich, Italien (selten); nach Nieves-Aldrey (2001: 174) in Europa weit verbreitet, gemeine Art in Spanien; wurde auch nach Australien eingeschleppt und ist dort fest etabliert. Nach Riedel (1910: 65, Taf. 6, Fig. 83) selten in Lothringen (Kieffer) und Schlesien; auch in Britannien selten (Redfern et al. 2002: 349). - In „Fauna Europaea\" (2007) nur von der Iberischen Halbinsel, den Britischen Inseln und vom Kontinent nur aus Polen angegeben.\n\n## Genus Timaspis Mayr 1881\n\n[15] [Timaspis (= Phanacis) lampsanae (Perris 1873)]\nVerursacht an Rainkohl Lapsana communis (Asteraceae) mehrkammerige Gallen ( $10 \\times 60 \\mathrm{~mm}$ ) in breiten Stängelverdickungen [Riedel 1910: 65, Taf. 6, Fig.81; Redfern et al. 2002: 355, Fig. 418; Foto: Bellmann 2006], sehr ähnlich denen von Phanacis hypochoeridis (Kieff.) an Ferkelkraut. - Diese und weitere Arten mit west- bis mitteleuropäischer Verbreitung fehlen bisher in Italien und Südtirol, wie: [15b] Timaspis cichorii (Kieffer 1909) mit StängelGallen an Wegwarte Cichorium intybus, bekannt aus Frankreich, Ungarn, Polen, Spanien [NievesAldrey 2001: 162, 526; Fig. 119 A-B]. Diese beiden\n\n--- Seite 37 ---\nArten wurden von E. Tomasi (2007: 131) rezent aus Friaul-VG von den \"Prealpi Giulie\" gemeldet.\nWeiters könnten zu erwarten sein: Timaspis lusitanica Tavares, an Blasen-Pippau Crepis vesicaria, bekannt aus Frankreich, Deutschland, Ungarn, Portugal und Spanien; oder Timaspis sonchi (Stefani 1900) an Acker-Gänsedistel Sonchus arvensis, bekannt aus Sizilien und Britannien [Redfern et al. 2002: 448, Fig. 888]; oder Timaspis phoenixopodos Mayr 1882 an Ruten-Lattich, Lactuca viminea, westmediterran: Frankreich, Spanien, Portugal, Marocco und rezent auch Italien (Pagliano 2004) nachgewiesen. Timaspis spp. waren früher teilweise unter Phanacis spp. geführt [Checklist Ital. 1995].\n\nGenus Xestophanes Förster 1869\nGallenbilung an Rosaceen der Gattung Potentilla.\n16 Xestophanes potentillae (De Geer 1773)\nVerursacht Gallen in Form länglicher Stengel- und Wurzelverdickungen an Kriechendem Fingerkraut, Potentilla reptans (Rosaceae). [BuHR 1965: p. 887, Nr. 5168; T. 13, Fig. 202; Nieves-Aldrey 2001: 142, 524; Fig. 121 L-M; Redfern et al. 2002: 394, Fig. 628; Riedel 1910: 61, Taf. 5, Fig. 69]. - Art mit weiter Verbreitung in West-, Mittel- und Nordeuropa. Fehlt angeblich in Ungarn.\nIn Checklist Ital. (1995: Nr. 32/01) für N-Italien angegeben. - Südtirol: Nach gezielter Suche erstmals rezent nachgewiesen in Tschötsch ( 750 m ) bei Brixen, am 15.08.2005; an Wegböschungsvegetation in Bachnähe, zahlreiche Gallenkomplexe (mit Larven) an Stängeln und Wurzelausläufern von Potentilla reptans (leg. Hellrigl \\& G. Mörl) (Abb. 16). Ende Aug. 2005 auch in einem Garten in Brixen-Stadt ( 550 m ) gefunden (G.v.Mörl \\& R. Sinischalchi). - Neumeldung für Südtirol.\n[17] [Xestophanes brevitarsis (Thomson 1877)]\n(= tormentillae Schlechtendal 1880)\nBisher in Italien und in Südtirol noch nicht nachgewiesen - aber zu erwarten - ist diese seltenere Art, welche kleine kugelige, oft gehäufte Stängelgallen (meist in Nähe der Wurzel) an Gem. Fingerkraut Potentilla erecta erzeugt und ähnliche Verbreitung hat wie die vorige. [BuHR 1965: p. 887, Nr. 5171; T. 13, Fig. 201; Nieves-Aldrey 2001: 144, 524;\n\nFig. 121 K; Redfern et al. 2002: 394, Fig. 627; Riedel 1910: 61, Taf. 6, Fig. 70]. - Von E. Tomasi (2007: 131) zusammen mit voriger Art rezent aus Friaul-VG von den \"Prealpi Giulie\" an Potentilla gemeldet.\n\nTribus Diplolepidini: 18-22\nGenus Diplolepis Geoffroy 1762\n[= Rhodites Hartig 1840]\nAlle Diplolepis-Arten (vormals Rhodites) verursachen Gallen ausschließlich an Rosa spp. (Rosaceae).\n\n18 Diplolepis eglanteriae (Hartig 1840)\nVerursacht an Blättern wilder Rosen kleine kugelige, erbsenförmige, dickwandige, einkammerige Gallen ( $\\varnothing 5-8 \\mathrm{~mm}$ ), von gelblichgrüner bis rötlicher Färbung und glatter Oberfläche (= \"Smooth Pea Gall\"), oft mehrere nebeneinander, meist blattunterseits (Abb. 18). Der Name leitet sich her von der Weinrose Rosa eglanteria (= rubiginosa). - [BuHR 1965: p. 1031, Nr. 5855; Redfern 2002: 424].\nVon Dalla Torre (1892: 150) nur aus TN und N-Tirol (Innsbruck) gemeldet (Rhodites eglanteriae Htg.). - Nach Bezzi (1899) im Trentino, an Rosa canina und R. tomentosa, bei Cusiano (Val di Sole); idem Cobelli (1903) im Trentino. - In Friaul-V.G. von Triest-Monrupino, 30.10.1994 (Foto), angegeben von Tomasi (2006: 73). - Checkl. Ital. (1995: 22/01): N- und S-Italien.\nIn Südtirol weit verbreitet, nicht selten an verschiedenen Wildrosen: im Vinschgau bei Allitz, 900 m ; im Eisacktal: Völs, 900 m , und Raas, 830 m , VII. 1999 (leg. Hellrigl); Forstgarten Aicha, 750 m, Rosa pimpinella, VII. 1999 (leg. Hellrigl); Vahrn, 700 m , an Rosenwildling im Hausgarten, 29.07.2004 (Foto Hellrigl). Oberbozen, 1200m, 24.07.2004; Mölten, Etschblick, 1050m, 04.08.2004, div. Gallen (leg. M. Skuhrava); Ulten: St. Gertraud, 1500 m, 09.07.2005 (leg. M. Skuhrava).\n\nBrixen Umg.: Milland ( 550 m ), Köstlan ( 600 m ), Raas Raier-Moos ( 830 m ), Vahrn-Raudegg ( 830 m ) an Wildrosen (R. rubiginosa, R. pendulina, R. pimpinellifolia, R. arvensis, R. canina) in Anzahl, VIII. 2004 (leg./Foto Hellrigl \\& Mörl). SpondinigLeiten, 1250 m , an Wildrosen, div. rote Gallen\n\n--- Seite 38 ---\nD. eglanteriae, 19.10.2004 (Hellrigl). - Aus Gallen von Vahrn und Raas (besonders an Rosa pendulina) auch mehrfach kleine parasitierende Torymidae [vereinzelt: Torymus rosarum (Hoffmeyer, 1929)] und Eurytomidae [sehr zahlreich: Eurytoma rosae Nees, 1834] gezogen (leg. Hellrigl, VIII.-X. 2004).\n\nIm Frühjahr 2005, Mitte Juni/Anf. Juli, bei Elvas $(800 \\mathrm{~m})$ zahlreich (ca. 60 Blattgallen); am 17.06.05 bei Aicha-Spinges ( 850 m ); nicht selten in Brixen-Milland, am 04.07.05. - Im Herbst 2005 (Ende Sept./Anf.Okt.) vereinzelt bei Raas ( 830 m ), da meist schon abgefallen; Tschötscher-Heide ( 750 m ), an Wildrosenblättern 10 frische Gallen; Brixen-Köstlan, 8 Gallen ( $3-5 \\mathrm{~mm}$ ); Aicha-Spinges, 12 Gallen ( $2-5,5 \\mathrm{~mm}$ ) (leg. Hellrigl). Im Gegensatz zum Frühjahr, fanden sich die frischen Herbstgallen meist blattoberseits. - An denselben Lokalitäten wurden Blattgallen auch in den Folgejahren 2006/07 regelmäßig angetroffen, aber kaum gesammelt: Aicha-Spinges ( 830 m ), 06.09.2006, am Waldrand 8 Gallen (leg. Hellrigl); Brixen-Köstlan ( 600 m ), 18.07.2007, Gärtnerei an Wildrosen: 10 Blätter mit 15 Gallen (leg. Hellrigl). - Mitte Juni 2008 Raas-Raier Moos, 830 m, 12 Blätter mit rd. 60 Kugelgallen (4-6 pro Blatt); Aicha-Spinges, 19.06.-25.07.2008, an Wildrosen am Waldrand 5 Blätter mit insgesamt 25 Gallen, div. Fotos (leg. Hellrigl). - Neumeldung für Südtirol. Im Unterland und Trentino fand ich die Art nie.\n\n18b Diplolepis centifoliae Hartig 1840\nSehr ähnlich und von D. eglanteriae kaum unterscheidbar ist die kugelige Blattgalle ( $\\varnothing 5-6 \\mathrm{~mm}$ ), von D. centifoliae. Diese soll hauptsächlich an Kulturrose Rosa centifolia vorkommen [Riedel 1910: 60, Taf. 6, Fig. 66, Rhodites centifoliae Htg.); die Kugelgalle wird beschrieben als glatt oder fein gehöckert, mit kurzen Haarpapillen bedeckt [Riedel 1910: 60; Redfern et al. 2002: 424]. Eine auf diese Beschreibung passende Galle fand ich am 15.10.08 bei Raas-Raier Moos (Abb. 18B), doch ist unsicher ob es sich tatsächlich um diese Art oder möglicherweise um eglanteriae oder nervosa handelt.\n\n19 Diplolepis mayri (Schlechtendal 1877)\nVerursacht an Zweigen von Wildrosen kugelige, weichstachelige Gallen von ca. $1 \\mathrm{~cm} \\varnothing$, meist zu\nmehreren, traubig $\\pm$ dicht nebeneinander; Färbung grün bis rot, später hellbraun verholzt; die Gallen sind $\\pm$ dicht mit langen, weichen Dornen besetzt, später $\\pm$ kahl. - [Abb.: Buhr 1965: T. 18, Fig. 313; Pellizzari 1988: 133; Csóka 1997: 130/131; Bernardi et al. 1997: 208, Fig. 52.; Bellmann 1999: p.257; Nieves Aldrey 2001: 264-267; Fig. 121D, 138B; Redfern 2002: 423, Fig. 761].\nCheckl. Ital. (1995: Nr. 22/02): N-Ital. - In FVG vom Triestiner Karst angegeben von GrÄFFE (1905: 52, Rhodites mayri Schlechtental; Cecidothek FVG): „Die Art ist eher selten wie gemein bei Triest.\" Hier zahlreiche Meldungen von Tomasi (1996: 52, Nr. 74). Wird auch aus Toskana angegeben.\nDalla Torre (1896) meldet Gallen von Rhodites mayri Schlecht. an Rosa canina, Meran-Untermais, 12.11.1893 (W. Magnus). - Die Art ist hier offenbar recht selten. Rezente Nachweise: Triebgallen an wilden Rosen, Aicha-Spinges, $850 \\mathrm{~m}, 11.07 .1999$, große traubige Gallengruppe (leg./Foto Hellrigl), stark parasitiert durch Torymus bedeguaris (geschlüpft: 05.-15.08.1999). -Ebendort am 30.10.2004 einige weitere Zweiggallen an Wildrosen am Waldrand (leg./Foto Hellrigl): an zahlreichen untersuchten Sträuchern wurden bei 4 Wildrosen verholzte Gallen (z.T. noch stachelig) an 6 Zweigen gefunden; an drei Zweigen bildeten die Gallen traubige Klumpen von jeweils 6-10 Einzelgallen (Abb. 19).\nTschötsch ( 750 m ), am 10.04.2005, an abgestorbenem Rosenzweig eine vorjährige Komplexgalle $(3 \\times 2.7 \\mathrm{~cm})$, bestehend aus 8 traubig verwachsenen Gallen (leg. Hellrigl \\& Mörl). Brixen-Elvas $(800 \\mathrm{~m})$, eine alte Galle $(3.2 \\times 2.3 \\mathrm{~cm})$ bestehend aus 13 traubige verwachsenen Einzelgallen, an Wildrosen zusammen mit unzähligen Gallen von Dipl. rosae, 15.04.2005 (leg. Hellrigl). - Vinschgau: Kortsch, Sportplatz, 12.06.05, an Wildrose eine frische rote stachelige Galle (Foto H. Bellmann). - Aicha-Spinges, $850 \\mathrm{~m}, 17.06 .2005$, an 3 Rosensträuchern 6 alte Gallen (davon eine große glatte) und 2 kleine neue Gallen (noch grün); ebendort: 11.10.2005, an 2 Wildrosen weitere 2 Stachelgallen, eine noch grün (leg./Foto Hellrigl). Neustift, 700 m , 03.09.2005, Stachelgalle an Wildrose (leg./Foto Hellrigl). - Aicha-Spinges ( 850 m ) 06.09.2006, 7 Gallen von D. mayri an Wildrosen; AichaSpinges, 19.06.2008, an 2 Wildrosen drei frische rote stachelige Gallen (leg./Foto K. Hellrigl); hier\n\n--- Seite 39 ---\nam 11.09.2008, eine große braune „Traubengalle\", über 8 cm reichend, bestehend aus 2 Gruppen von 5 Einzelgallen ( 3 cm ) und 10 Einzelgallen $(3,5 \\mathrm{~cm})$, mit Fluglöchern Parasiten [Foto]. Unterland: Castelfeder ( 400 m ), 24.09.2006, 2 Gallen an Wildrosen (Foto); hier auch am 19.10.2008, an Wildrosenstrauch 2 Gallenkomplexe mit 5 Gallen ( $28 \\times 25 \\times 15 \\mathrm{~mm}$ ) und 4 Gallen ( $25 \\times 25 \\times 20 \\mathrm{~mm}$ ) (leg./foto Hellrigl).\n\n20 Diplolepis nervosa (Curtis 1838)\n[= Rhodites rosarum Giraud 1859]\nVerursacht an Blattunterseite wilder Rosen einkammerige, erbsenförmige Gallen, von gelblichgrüner bis rötlicher Färbung, ähnlich denen von D. eglanteriae, aber derb bestachelt; die langen spikeartigen Fortsätze oft sternförmig angeordnet [ChinERY 1987: p. 227; NieVes-AldREY 2001: 260; Fig. 121H; Redfern 2002: 423-424, Fig. 762, 765]. - Die Art wird oft noch als Diplolepis rosarum geführt [Pellizzari 1988: 135; Csóka 1997: 128; Checklist Ital., 1995: Nr. 22/04].\nDalla Torre (1892:150): Galle von Rhodites rosarum Gir. an Rosa canina, Bozen (Kravogl 1887: p. 68). - Bezzi (1899): Trentino an Rosa canina, selten bei Bordala ( 1000 m ) in Vallagarina; als Rhodites rosarum zitiert von Cobelli (1903: 165) für Trentino nach Bezzi (= Bz), ohne Fundortangabe. Rezente Fundbestätigung für Trentino: RoveretoDossi, 04.08.2006, eine einzelne Galle (leg. Irene Bellmann, vid. Hellrigl); ebenso Monte di S.Ambrogio/Negrar (VR) (leg. H. Bellmann, coll. Hellrigl). Die typische Galle ist auch in Südtirol sehr selten; nur ein rezenter Nachweis bekannt: Auer, 370 m , an R. canina, 31.07.2004 (coll. Hellrigl, leg. M. Skuhravá \\& V. Skuhravy,). (Abb. 20). -Allerdings gibt es neben der typischen bestachelten Gallenform auch eine untypische stachellose Form, die von den glatten Gallen von D. eglanteriae nicht unterscheidbar ist [Nieves-Aldrey 2001: 260, 551].\n\n21 Diplolepis rosae (Linnaeus 1758)\nDie „Gemeine Rosengallwespe\" ist die häufigste unserer Rosen-Gallwespen und in Südtirol eine der häufigsten Gallwespen überhaupt. Bildet an Trieben von Wildrosen auffällige, $\\pm$ große „Haargallen\" (bis faustgroß), die als „Schlafapfel\" oder „Bedeguar\" bezeichnet werden (\"Rose bedeguar\")\nund im verholzenden Inneren viele Kammern enthalten (Abb. 21). - Ital. Checkl. [1995: Nr. 22/03]: ganz Italien. In FVG vom Triestiner Karst zahlreiche Meldungen durch GrÄFfE (1905: 51, Rhodites rosae): „sehr häufig bei Triest und viele Rosensträucher ganz bedeckt von den Gallen.\" Ebenso Tomasi (1996: 53, Nr. 75; 2006: 74, Cecidothek FVG: Udine). Bernardi et al. 1997, 104: Toskana, Piemont, Lombardei, Ligurien, Emilia Romagna, Veneto, Friuli-V.G., Trentino-A.A., Latium und Sizilien.\nDalla Torre (1892: 150): Rosenbedeguar von Rhodites rosae L. ist die gemeinste und auffälligste Galle in Tirol; D.T. (1896: 154) Rhodites rosae an Rosa canina, Kastelruth 28.07.1894. - Bezzi (1899): auch im Trentino überall gemein, bis über 1000 m S.H. - Hier auch rezent bei Pomarolo, Sommer 2003, einzelne Haargallen (leg. P. Lorenzi, Mus. Rovereto: vid. Hellrigl).\nHellrigl (1996): Rosengallwespe; im Eisacktal, Brixen Umg., an Rosa canina häufig. Hellrigl (1997: 66, Abb. 7: „Schlafäpfel\" (Bedeguare): Milland/Brixen, Okt. 1988. - Weitere „Haargallen\" an Wildrosen: Vahrn, Atzwang, Schlanders, Laas, u.a.o.: sehr häufig (leg. Hellrigl, 1998/99); Neustift, im Mai 1998-2000, in Anzahl aus Bedeguaren gezogen, zusammen mit der Inquiline Periclistus brandtii (Ratzb.) und div. Parasitoiden, wie der häufigen, metallisch bunten Langstacheligen Rosenerzwespe Torymus bedeguaris (L.) (Torymidae), der Gelben Rosenschlupfwespe Orthopelma mediator (Thunberg 1822) (Ichneumonidae) sowie den Rosenerzwespen Eurytoma rosae Nees, 1834 (Eurytomidae) und Pteromalus bedeguaris (Thomson, 1878) (Pteromalidae).\nIm VIII. 2004 Brixen Umg.: Milland ( 550 m), Köstlan ( 600 m ), Elvas ( 850 m ), Feldthurns ( 800 m ), Raas Reier-Moos ( 830 m ), Vahrn-Raudegg ( 830 m ) an Wildrosen in großer Anzahl, (leg. Hellrigl \\& Mörl). Mahr ( 550 m ), unterhalb Tschötsch, Wildrosenstrauch mit 24 großen Bedeguaren, 20.10.2004 (Foto: Hellrigl). - Vinschgau: Vetzan und Tartsch (800-1100 m), IX. 2004 (Hellrigl); Goldrain, 900 m , an Wildrose große Haargalle, 19.10.04 (leg./Foto: Hellrigl \\& Unterthurner). - Neustift ( 600 m ), 20.03.05, fünf große „Haargallen\" $(\\varnothing=7-9 \\mathrm{~cm})$ (Hellrigl \\& Mörl); daraus schlüpften ab 10.04.2005 zahlreiche Imagines der Gallwespe sowie div.\n\n--- Seite 40 ---\nparasitische Hymenopteren (Orthopelma mediator, Pteromalus hedeguaris u.a.). - Im gesamten Gebiet in Tal- und Mittelgebirgslagen auch in den Folgejahren ungemein häufig, oft geradezu massenhaft (Brixen Umg.). Im Herbst 2007 mancherorts (z.B. Elvas) sehr viele auffallend kleine Haargallen an Wildrosen, teilweise auch an den Blättern. Auch im Juni 2008 zahlreich in Brixen Umg. bei Elvas, Raas, Tschötsch; am 11.09.08 sehr viele Gallen aller Größen bei Aicha-Spinges, Neustift und Elvas. Weit seltener scheint die Rosengallwespe im Trentino zu sein, ich selbst konnte sie dort in den Jahren 2004-08 bei Rovereto und Pomarolo nie beobachten.\n\n22 Diplolepis spinosissimae (Giraud 1859)\nVerursacht an Blättern von wilden Rosen einkammerige, $\\pm$ kugelige, gelbgrüne bis rötliche Gallen, ohne Behaarung, die auf beiden Blattseiten hervortreten: blattunterseits grün und halbkugelig, blattoberseits kalottenartig rötlichbraun, recht deutlich erkennbar (Abb. 22). Der Name leitet sich her von Rosa spinosissima (= R. pimpinellifolia). - Die nur 3-6 mm großen, unauffälligen glatten Gallen können auf dem Blatt, am Blattrand, an Blattstielen etc. auftreten und variable Form aufweisen [BuHR 1965: 1030, Nr. 5851; T. 19, Fig. 316; Pellizzari 1988: 136; Csóka 1997: 128; Nieves-Aldrey 2001: Fig. 135H; Redfern et al. 2002: 424, Fig. 763]. [Checkl. Ital., 1995: Nr. 22/05]. - Bernardi et al. (1997: 144, Fig. 24): Toskana, Piemont, Ligurien, Veneto, Trentino-Alto Adige. - In Friaul-V.G. aus Triest-Aurisina, 20.06.1993 (Foto), erstmals angegeben von Tomasi (2006: 74).\nDalla Torre (1892): Blattgallen von Rhodites spinosissimae Gir. an Rosa canina, Bozen (Kravogl 1887: 68). - D.T., 1892, 1894, 1896: Auch in N-Tirol, bei Innsbruck, Hötting, Rinn-Sistrans. - Bezzi (1899): im Trentino an Rosa canina, bei Mollaro/Val di Non und bei Termenago im Val di Sole in 1200 m. - Von Cobelli (1903: 165) für TN nach Bezzi (= Bz) zitiert.\nRezente Nachweise in Südtirol: Brixen-Milland, Eisackdamm ( 550 m ): an vereinzelten niederen Wildrosen zahlreich in verschiedensten Formen (rundlich-bauchig, ovoidal, spindelig) an Blättern und Blattstielen (Abb. 22), 08.08.2004 (leg./Foto Hellrigl); an diesen Rosen auch Blattfalten-Gallen der Rosengallmücke Wachtliella rosarum. Raas-\n\nRaier Moos $(830 \\mathrm{~m})$, an einzelnen Wildrosen in Anzahl; meist an Einzelblättern mehrere Gallen, 10.08.2004 (leg./Foto Hellrigl). Auch 2005 in Brixen-Milland (04.07.2005) und Raas-Raier Moos (25.09.05) lokal vereinzelt (leg. Hellrigl); AichaSpinges ( 850 m ), 17.06.2005, ca. 22 Gallen; Elvas $(850 \\mathrm{~m})$ : an Wildrosen: 1 Zweig mit 4 Gallen an Blättern, 03.07.2005 (leg./Foto Hellrigl). In den Folgejahren (2006/07) nicht weiter gezielt gesucht, daher wenige Funde: Brixen-Köstlan, 18.07.2007, Gärtnerei an Wildrosen: 7 Blätter mit 12 Gallen D. spinosissimae. Im Frühjahr 2008 Gallen nur lokal in Raas-Raier Moos $(830 \\mathrm{~m})$, an einzelnen Wildrosen, bodennah (bis Knie- bzw. Hüfthöhe) 5 Blätter mit insgesamt 15 Gallen, 18.06.2008 (Fotos); bei Aicha-Spinges ( 850 m ), am 25.06.2008 zwei Blätter mit einigen frischen Gallen (leg./Foto Hellrigl).\n\n## Tribus Pediaspini: Nr. 23\n\n## Genus Pediaspis Tischbein 1852\n\n23 [Pediaspis aceris (Gmelin 1790) ㅇ]\n[Syn.: Cynips pseudoplatani Meyer 1779]\n[agam = Pediaspis sorbi Tischbein 1852]\nDie Ahorngallwespe verursacht in der agamen Generation an Wurzeln von Bergahorn (Acer pseudoplatanus) mehrkammerige, unregelmäßig geformte, bräunliche Gallenkomplexe (Abb. 23). - Sexualgeneration mit grünlich-rötlichen, dünnwandigen, etwas fleischigen Kugelgallen an Blattunterseite (Abb. 23b) (bisweilen auch an Früchten); von Inquilinen besetzte Gallen haben eine unregelmäßig gehöckerte Form und werden holzig (Mitt. \\& Foto: H. Bellmann, 2005).\n\nDie Art ist in Europa (ohne Norden) verbreitet (Gauss 1982; Csóka 1997: 40) und wird auch aus Spanien gemeldet (Nieves-Aldrey 1999; 2001: p. 269, 532). Die oft gehäuft auftretenden Kugelgallen an Blättern von Bergahorn sind in Mitteleuropa (z.B. Deutschland: bei Ulm; Österr.: am Mondsee) mitunter VI-VII nicht selten (Mitt. H. Bellmann, 2005). Aus Bitsch i. Lothringen wurden die Gallen schon von Kieffer (1914: 23) als „stellenweise massenhaft an Acer pseudoplatanus auftretend\" angegeben. - In Checklist Italiens (1995: 28/01) für\n\n--- Seite 41 ---\nN-Italien angeführt [als P. pseudoplatani (Mayer)]. - In Friaul-VG von Tomasi (2006: 75) aus Udine, Savogna, Massaris, 760 m , gemeldet, VI. 1994.\nIn Südtirol in langjähriger Beobachtung nie gefunden; Vorkommen daher kaum zu erwarten.\n\nTribus Cynipini: Nr. 24-106\nArtenreichste Tribus; umfaßt die durchwegs an Eichen lebenden Arten (\"oak gall wasps\") der Gattungen Andricus, Aphelonyx, Biorhiza, Callirhytis, Chilaspis, Cynips, Dryocosmus, Neuroterus, Pseudoneuroterus, Plagiotrochus, Trigonaspis u.a. Die Entwicklung verläuft in der Regel mit Wechsel von agamer und bisexueller Generation, mit Wirtswechsel [Ausnahme: Dryocosmus kuriphilus, welche an Edelkastanie lebt].\n\nGenus Andricus Hartig 1840: Nr. 24-76\n00 [Andricus aestivalis Giraud 1859]\n\n- see: Nr. 55 Andricus lucidus (Hartig 1843)\n\n00 [Andricus ambiguus (Trotter 1899)]\n\n- see: Nr. 35 Andricus corruptrix (Schlecht. 1870)\n\n24 Andricus amblycerus (Giraud 1859)\nHenschel (1888: Taf.I, Fig. 10: Cynips amblycera) Nur die agame Generation ist bekannt, welche Knospengallen an Quercus robur, Q. pubescens und Q. petraea erzeugt. Bildet an Zweigspitzen dünner Seitentriebe kleine, paarig bis sternförmig verzweigte „Zwillings\"-Gallen ( $\\varnothing=8-10 \\mathrm{~mm}$ ), mit $\\pm$ symmetrischer Anordnung von mehreren dicken, kegelförmigen Fortsätzen (zu 3 oder 4 , selten zu 2, 5 oder 6), diese $\\pm$ zugespitzt nach außen gerichtet, jeweils 3-5 mm lang; Larvenkammern einzeln, quereiförmig [Henschel 1888: Taf. I, Fig. 10, C. amblycera; Dalla Torre \\& Kieffer 1910: 418, Fig. 123-124; Buhr 1965: 944: Nr. 5459; Csóka 1997: 76-77]. - Die unbekannte Sexualform wird auf Quercus cerris vermutet (Bellido et al. 2003: 177-180).\nVerbreitung: Ost- und SE-Europa (Österreich, Ungarn, Balkan); auch in Italien (Checklist 1995: Nr. 20/02, Cynips amblycera); fehlt in W-Europa, Spanien, Frankreich. - Im Triestiner Karst von GrÄFfE (1905: 18-19) gemeldet mit Gallenbeschreibung, nicht häufig an Axillarknospen von Quercus\npubescens; Fundorte und Belege in Cecidothek FVG (cit. Tomasi 1996: 25; 2006: 11, 19, 72).\nNeu für Trentino und die Region. In Südtirol bisher nicht beobachtet; aber in Castelfeder zu erwarten. Rezente Neufunde im Trentino: Pomaolo-Servis (IT-04: 700 m ), 14.10.2007, 10 alte Gallen (leg. Hellrigl \\& Mörl) (Abb. 24) zusammen mit 4 alten Gallen von A. galeatus und 6 Gallen A. kollari an niederem Eichengebüsch ( $Q$. pubescens) unter einer Zerreiche (Fotos Eicheln). Hier auch am 19.07.08 an Flaumeichengebüsch 2 alte Knospengallen mit Flugloch, sowie am 07.09.2008 drei alte Knospengallen an Zweigen mit A. lignicolus (leg. Hellrigl \\& Mörl). Am 12.10.2008 drei ungeschlüpfte Knospengallen an Zweigen mit A. lignicolus (2) bzw. A. quercustozae (1), leg. Hellrigl \\& Schanung (Abb. 24b).\n\n25 Andricus amenti Giraud 1859 ? 9\n=A. giraudianus Dalla Torre \\& Kieffer 1910, 99\n$=$ A. callidoma auct., nec Hartig 1841, agam\nErzeugt in der agamen Generation an Flaumeiche (Q. pubescens) blattwinkelständige, langgestreckte, spindelförmige Gallen; Spindelgalle dünn, $\\pm$ langgestielt, mit oder ohne Längskiele, grün oder rot; Galle und Stiel mit kurzen oder langen, abwärts gerichteten Haaren besetzt; Reife im Oktober. [DALLa Torre \\& Kieffer 1910: 499, Fig. 255: A. giraudianus. - Buhr 1965: 935, Nr. 5428; Csóka 1997: 78-79; Melika et al. 2000: 267, Fig. 4a-d, 4e-g; Redfern et al. 2002: 416, Fig. 731, A. amenti, ? 9 ]. - Bisexuelle Generation (A. amenti, ? 9 ) an Blütenkätzchen von $Q$. petraea und $Q$. pubescens.\nVerbreitung: Süd(ost)europäische Art, deren Gallen vereinzelt aus Österreich (Niederösterreich), Ungarn, Italien, Bulgarien und Kleinasien erwähnt werden. Auch aus Südfrankreich nachgewiesen (Foto H. Bellmann, persönl. Mitt.). Vorkommen in Spanien unsicher [Nieves Aldrey 2001: 416, 541, A. giraudianus]. - Aus Italien (Checkl. Ital. 1995: Nr. 13/25) angeführt, doch ohne Fundangabe.\nErstnachweis für die Region Trentino-Südtirol: Pomarolo-Servis (IT-04: 700 m), 14.10.2007, agame Spindelgalle (long. 14 mm ; Galle ohne Stiel: 8 mm ) an Q. pubescens (Abb. 25a) (Nov. 2007 schlüpften aus dieser Galle bei Aufzucht 4 Synergus gallaepomiformis); auch an zwei weiteren Flaumeichen noch 2 Spindelgallen ( $9-11 \\mathrm{~mm}$ ), leg. Mörl \\& Hellrigl\n\n--- Seite 42 ---\n(Abb. 25b). Drei frische, unreife Spindelgallen (Fotos) fanden sich hier am 12.10.2008 an Eichenzweigen (leg. Hellrigl \\& Schanung) (Abb. 25c).\nUnterscheidet sich von der „Großen Spindelgalle\" (A. callidoma) durch meist geringere Größe und durch die stärkere, deutlich rückwärts gerichtete Behaarung, sowie durch spätere Erscheinungszeit erst im September (letzteres gilt allerdings auch für die „Kleinen Spindelgalle\" A. malpighii Adler).\n\n00 [Andricus anthracinus (Curtis 1838):\nsee Nr. 91: Neuroterus anthracinus (Curtis 1838)\nSyn.: Andricus ostreus (Hartig 1840)\n\n- \"Oyster-gall\"\n\nFür die Erreger von „Austerngallen\" an Eichenblättern (\"Oyster-gall causer\") wird neuerdings als Synonymie angeben: Andricus anthracinus ( $<=$ Andricus ostreus). - Die Art war bereits von Giraud (1859) als N. ostreus zur Gattung Neuroterus gestellt worden, was sich erst in letzter Zeit allgemein durchsetzte. Heute wird sie als Neuroterus anthracinus geführt (Nieves-Aldrey 2001: Fauna Iberica, p.427; 542; Redfern 2002: British Plant Galls, p.413), mit A. ostreus als Synonym. - In Checklist Fauna Ital. (1995) scheint nur Andricus ostrea (Htg.) auf, während A. anthracinus fehlt.\n\n26 Andricus aries (Giraud 1859)\n[= Cynips aries Giraud 1859] - „Bockshorngalle\" Andricus aries [\"Ramshorn gall causer\"] bildet zusammen mit A. amblycerus (Giraud), A. corruptrix (Schlecht.) und A. galeatus (Giraud) eine Untergruppe innerhalb der Andricus kollari-Artengruppe an Eichen [vgl. Bellido et al. 2003; Csóka 1997: 76-77 (amblycerus), 94-95 (galeatus)]. Die 4 Arten werden in Checklist Ital. (1995) auch für Italien angegeben (teilweise unter Cynips), in Südtirol fehlten sie bisher; ebenso fehlen sie mit der Zerreiche in Spanien [Nieves-Aldrey 2001].\nDie Art war lange nur durch die agame Generation bekannt, welche die auffälligen „Bockshorngallen\" besonders an Zweigen von Stieleiche (Quercus robur) erzeugt; experimentell konnte WALKER (2001) aber eine Sexualgeneration an kleinen Knospengallen von Zerreiche nachweisen. (cit. Bellido et al. 2003: 184). - Verbreitung: Östliches und südliches Europa. - In Checklist Ital. (1995: Nr. 20/04, Cynips aries) ohne Verbreitungsangaben.\n\nGallen von Andricus aries [\"Galla a cornetto\"] wurden aus Italien aus der Toskana von Q. pedunculata ( $=$ Q. robur) bekannt (Bernardi et al. 1997: 118, Fig. 11).\nUnerwartet wurde $A$. aries rezent auch in Südtirol im Eisacktal gefunden, an aus der Toskana importierten und hier im Frühjahr 2006 angepflanzten 6-8 m hohen Stieleichen (Q. robur ,Fastigiata`): am nördl. Eisackufer in Brixen, 26.11.2006, 1 Galle (long. 5 cm ) mit Flugloch (leg. Hellrigl) (Abb. 26). Einige weitere verkürzte ein- oder zweihornige Gallen (long. 12-15 mm) aus dem Vorjahr fanden sich hier an nachgepflanzten Stieleichen Anf. Aug. 2008 (leg. Hellrigl \\& Mörl); sie sind vermutlich ebenfalls hierher zu beziehen (Abb. 26b). - Die Art ist hier aber nicht heimisch und kann im Eisacktal nicht Fuß fassen, da hier die Zerreiche fehlt, als Zwischenwirt der sexuellen Generation. Auch die von der agamen Form bevorzugt Stieleiche Quercus robur ist in der Region Südtirol-Trentino wenig verbreitet. Ein Freilandvorkommen im südlichen Trentino, bei Rovereto-Pomarolo, wo inzwischen schon A. amblycerus, A. corruptrix und A. galeatus mehrfach nachgewiesen wurden, scheint möglich.\n\n27 Andricus burgundus Giraud 1859 ㅇ\nSüdliche Art (benannt nach Burgund, Mittelfrankreich); Verbreitung: Frankreich, Österreich, Ungarn, Spanien, Portugal, Sizilien [Fauna Europaea 2007]. - In Checklist Ital. (1995: Nr. 13/05) aus Sizilien gemeldet. - Sexualgeneration mit kleinen eiförmigen Gallen an Kätzchen von Q. cerris, in Spanien an Q. suber [Nieves-Aldrey 2001: 413]. Wurde früher für bisexuelle Generation von A. infectorius Htg. ( $=$ A. tinctoriusnostrus Stef.) gehalten (BuHR 1965: 987; Beyerinck in Dalla Torre \\& Kieffer 1910: 421); später als eigene Art geführt, mit unbekannter agamer Generation (Melika et al. 2000: „The bisexual generation induces catkin galls on $Q$. cerris only\"). - Nach neuen Erkenntnissen (Stone et al. 2007) handelt es sich bei A. burgundus um eine morphologisch nicht unterscheidbare \"sexual adult morphospecies\", als deren zugehörige Gegenstücke mehrere agame Andricus-Arten in Betracht kommen (hauptsächlich aus dem Andricus hartigi- und Andricus coriarius-clade, hingegen nicht aus dem Andricus kollari-clade, zu dem auch A. infectorius gehört).\n\n--- Seite 43 ---\nNach Buhr (1965: Nr. 5610) ist \"A. burgundus Giraud\" eine nur selten gefundene, vorwiegend südeuropäische Wespe. Die „Seltenheit\" ist wohl bedingt durch die Kleinheit ( 2 mm ) und Unscheinbarkeit der eiförmigen bis spitzkegeligen gelben, kahlen, glänzenden Gallen, die meist zu mehreren in den offenen Blütenknospen der Kätzchenspindel stehen. Im Südtiroler Unterland fand ich Kätzchengallen am 28.04.2005 im Eichenhain Castelfeder an blühender Zerreiche, deren Blätter erst teilweise entfaltet und noch nicht ausgehärtet waren. Die Bestimmung der kleinen Gruppe von 6-8 zitronengelben Gallen nach den Tabellen von BuHR (1965: 985-988: Gallen an männlichen Blütenständen von Quercus cerris) ergab Andricus burgundus Gir. (Abb. 27). - Erstmeldung für Südtirol und Norditalien.\n\n28 Andricus caliciformis (Giraud 1859)\nNur die agame Generation ist bekannt, mit kleinen Kugelgallen an Knospen div. Eichen, Quercus spp. Die blattwinkelständige Galle ist nur erbsengroß ( $7-10 \\mathrm{~mm}$ ), ähnlich einem rundum geschlossenen Eichelbecher, außen regelmäßig gefeldert, die kurz schuppenförmig behaarten Felder mit je einem kleinen nackten Wärzchen in der Mitte (vgl. Dalla Torre \\& Kieffer 1910: 421, Fig. 136).\nDie anfangs grüne, dann hellbraune bis beigefarbene, innen harte Galle, mit eingebetteter, dickwandiger, einkammeriger Innengalle wurde auch als „Maulbeergalle\" (Mulberry gall) bezeichnet. Sexualgeneration vermutlich an Q. cerris (BelliDO et al. 2003: 188). Verbreitung im südöstlichen Europa: Österreich, Bulgarien, Croatien, Ungarn, Rumänien, Moldavien, Jugoslavien, Italien. - Fehlt im Westen in Frankreich, Spanien usw. - In Checklist Ital. (1995: Nr. 20/06, Cynips caliciformis): Sizilien und N-Italien. - Im Triestiner Karst ist nach GräFfE (1905: 22; T. II, n. 10): die kleine runde Galle von Cynips caliciformis Gir., die einer abortierten Eichelfrucht gleicht, an der der Becher oben geschlossen ist, um Triest nicht häufig und leicht zu übersehen. Fundbelege von GrÄFFE 1905 u.a. in der Cecidothek FVG des Museums Triest werden von Tomasi (1996: 25, n. 19; 2006: 20, 72) zitiert.\nErste sichere Nachweise für Trentino gelangen bei Pomarolo-Servis (IT-04: 700 m ) am 28.10.2007, mit zwei diesjährigen Gallen ( $\\varnothing 9 \\mathrm{~mm}$ ) mit Flugloch\n(Abb. 28) an Flaumeiche (leg. Hellrigl \\& Mörl), sowie eine im Habitus identische ältere Galle ( $\\varnothing 9.5 \\mathrm{~mm}$ ). Vier weitere vorjahrige gelbliche Gallen (Ø 9-10 mm), alle mit Ausflugloch (Abb. 28b), fanden sich hier an Kronenzweigen der Flaumeichen am 25.04.2008 (leg. Hellrigl \\& Mörl); vier frische Gallen (Ø 9.5; 8.0; 7.5; 7.0; 6.0 mm ) wurden hier dann am 27.07.2008 an einem hohen Eichenast gefunden, (leg. Hellrigl \\& Schanung) (Abb. 28c). Daraus schlüpften Aug./Sept. eine Imago (Abb. 28d) und 2 Parasitoiden (Ormyrus sp. ㅇ). Es liegen somit aus Trentino bisher 11 sichere Gallenbelege vor (coll. K. Hellrigl), sowie einige ältere Gallenbelege, die nicht eindeutig zuordenbar waren [14.10.2007, 2 alte Gallen ( $9-10 \\mathrm{~mm}$ ) mit Flugloch, an Quercus pubescens (leg. Hellrigl \\& Mörl)]. Die Gallen haben eine optimale Mimese und sind mit ihrer höckerigen Felderung und passenden Größe und Farbe kaum zu unterscheiden von Eichelbechern. Diese „sitzenden\" Gallen unterscheiden sich deutlich von den „gestielten\" runzeligen „Feigen\"-Gallen von Andricus infectorius, die im selben Gebiet und auch in Castelfeder vorkommen.\n\n29 Andricus callidoma (Hartig 1841)\n\n- Spindelgalle - [agam = A. giraudi Wachtl 1882]\n( $4 \\varnothing=$ A. cirratus Adler 1881\n- Zottige Blütengalle)\n\nBildet in der agamen Generation an Jahrestrieben von Stiel- und Traubeneichen eine spindelförmige Galle (bis 25 mm ), die auf langem dünnem Stiel aus einer Blattachselknospe herauswächst (\"Stalkedspindle causer\"). Die „gestielte Spindelgalle\" hat einige kielartige Längsrippen; anfangs gelbgrün oder rötlich, später braun, oft mit weißem Haarbelag. Galle ab Ende Mai/Juni, im Spätsommer abfallend („Große Spindelgalle\").\nDie Galle wurde schon abgebildet von Malpighi (1687:Fig. 44). - Sexualgeneration: \"Zottige Blütengalle\". - [vgl.: Pfützenreiter 1958: Nr. 20, Abb. 15 ( $4{ }^{\\circledR}$ Große Spindelgalle); Nr. 54, Abb. 45 ( $4{ }^{\\circledR}$ Zottige Blütengalle); BuHR 1965: 935, Nr. 5427; T. 15: Fig. 231; Csóka 1997: 78; Nieves-Aldrey 2001: 369, 537; Figs. 128C, 141G; Redfern et al. 2002: 405, Fig. 684].\nIn Europa weit verbreitet, aber nicht häufig. In Checklist Ital. (1995: Nr. 13/24) für N-Italien angegeben (A.giraudi Wachtl). - In FVG vom Triestiner\n\n--- Seite 44 ---\nKarst von GrÄFFE (1905: 61, A. giraudi) gemeldet; (cit. Tomasi 1996: p. 94, Andricus girardi Wachtl). Aus Südtirol rezent neu nachgewiesen: Brixen, nördl. Eisackufer, an Stieleiche die im Mai 2008 aus Toskana importiert und angepflanzt worden war, am 08.08.2008, 1 Spindelgalle an Zweig mit Galle von Andricus kollari (Abb. 29), (leg. Hellrigl).\nAnmerkung: Ähnliche agame Spindelgallen sind: die \"Mittlere Spindelgalle\" A. amenti Giraud 1859 (= A. giraudianus Dalla Torre \\& Kieffer) [Abb.: Csóka 1997: 78-79] und die \"Kleinen Spindelgalle\" A. malpighii Adler 1881 (= nudus Adler 9.5), sowie die \"Blüten-Spindelgalle\" A. seminationis (Giraud 1859) [vgl. Pfützenreiter 1958: Nr. 52, Abb. 46; Csóka 1997: 114-115; Redfern et al. 2002: 416, Fig. 732]. - Nach Hartig (1841:336) sind die Spindelgallen von Cynips callidoma, die er bis dahin nur als Larven kannt, oft von Inquilinen Ceroptres clavicornis und Synergus sp. bewohnt.\n\n30 Andricus caputmedusae (Hartig 1843)\n[Cynips caput-medusae Hartig 1843: 401;\n$=$ Cynips gallae-cristatae Henschel 1876]\nDie agame Generation bildet an Zweigen von Quercus auffällige „Haargallen\", die aus zahlreichen dünnen, verästelten und gekrümmten, knäuelig verworrenen Auswüchsen bestehen, welche von einer zentralen, einzelligen Galle an einer Eichel ausgehen (Henschel 1888: Fig. 28). Die „Medusenhaupt\"-Galle (Ø 3-7 cm) ähnelt einem Rosen-Bedeguar (Diplolepis rosae). - Sexualgeneration nicht bekannt, vermutlich an Zerreiche (Quercus cerris). - Mehr in SE-Europa und südl. Mitteleuropa verbreitet. [vgl. Della Beffa 1961: 932, Fig. 1342; Pellizzari 1988: 96; Csóka 1997: 122]; fehlt in Spanien (Nieves-Aldrey 2001).\nDie seltsame Haar-Galle war schon von Malpighi [1687: Fig. 34] abgebildet; Hartig (1843) hatte sie von Kollar aus Wien und von v. Siebold aus Istrien erhalten.\nAus N-Italien gemeldet (Checklist 1995: Nr. 13/06). Nach GrÄFFE (1905: 13, Taf. II, n. 13, Cynips caputmedusae) bei Triest „an einzelnen Bäumen des Karstes zuweilen in großen Mengen vorhanden\". Hingegen wird A. caputmedusae später von E. ToMASI $(1996,2006,2007)$ aus Friaul-VG und Triest nicht mehr namentlich genannt, doch beziehen sich seine eigenen zahlreichen Fundangaben unter\n\"Andricus quercusramuli L.\" (1996: 35-36, Nr. 42; 2006: 69) auf Verwechslung mit A. caputmedusae, wie aus Gallenbeschreibung, den späten Funddaten sowie den zitierten Abb. \"Tab C-7\" hervorgeht.\nIn Trentino-Südtirol zahlreiche rezente Funde. Hier seit einigen Jahren recht häufig in Gebieten wo auch Zerreichen (Q. cerris) vorkommen: In PomaroloServis, im Monitoring-Areal (IT-04: 700 m ) an Q. pubescens, im August 1999-2002, alljährlich an einigen Eichen Medusenhaupt-Gallen registriert (vid. S. Minerbi); Pomarolo, Sommer 2003, div. Haargallen (leg. P. Lorenzi, Mus. Rovereto).\nBei Rovereto-Dossi ( 350 m ) an Q. pubescens und Q. petraea nicht selten: XL/XII. 2004, 15 Haargallen (leg.Ambrosi, coll. Hellrigl). Die Imagines (sehr ähnlich A. quercustozae) schlüpften in IndoorZucht bereits im Jänner 2005. Im selben Gebiet („Bosco della Città\") am 05.04.2005 zahlreiche vorjährige Gallen in Kronen der Eichen sowie abgefallen am Boden: 50 Ex. (leg. Ambrosi, Salvadori \\& Hellrigl); hier am 01.09.2005 frische Gallen an zahlreichen Eichen (an einigen Bäumen 50-100 Gallen), oft vergesellschaftet mit A. quercustozae, 30 Gallen gesammelt (leg. Salvadori \\& Hellrigl); viele Haargallen hier am 25.09.2005 beobachtet und fotografiert (Hellrigl \\& Bellmann), (Abb. 30). Auch im südlichen Gardaseegebiet im Veneto, bei Cavaion und Caprino Veronese, ist an strauchigen Eichen die Befallskombination A. caputmedusae \\& A. quercustozae häufig anzutreffen (Hellrigl \\& Sinischalchi).\nDas Schlüpfen der Imagines von A. caputmedusae, nach Überwinterung der Gallen auf Freiluftbalkon in Brixen, erfolgte im Frühjahr 2006 vom 10.20.März, um die Mittagszeit (11-15h) bei Schlüpftemperaturen von $10^{\\circ}-17^{\\circ} \\mathrm{C}$; bei Tagestemperaturen: Minima: $-2^{\\circ}$ bis $+8^{\\circ} \\mathrm{C}$; Maxima: $+10^{\\circ}$ bis $+20^{\\circ} \\mathrm{C}$. Innerhalb von 2 Wochen schlüpften insgesamt $20 \\leftrightarrows \\forall$ A. caputmedusae. Das Schlüpfen der Wespen erfolgte um einige Tage (ca. 1 Woche) früher als bei A. quercustozae. Bemerkenswert ist, dass die auffälligen Gallen bisher aus Trentino nicht erwähnt worden waren; Neumeldung für Trentino.\nAus Südtirol waren „Medusenhaupt-Eichengallen\" bisher nur vom Forstgarten Aicha bekannt, an aus der Toskana importierten Eichen, 14.11.1988, leg. H. Gruber/Foto K. Hellrigl (Hellrigl 1996: 690; 1997: 66, Abb. 7,3). Die Art kann sich aber im\n\n--- Seite 45 ---\nGroßraum Brixen, wegen Fehlens von Zerreiche als Zwischenwirt der Sexualgeneration, nicht halten. Dies bestätigten kontrollierte Aussetzungsversuche bei Neustift (Schießstand), wo am 19.03.06 an Traubeneichen Zuchtexemplare von A. caputmedusae (10 ㅇ) aus Rovereto lebend angesetzt wurden. Erwartungsgemäß verlief dieser Freilandzuchtversuch wegen des fehlenden Zwischenwirtes erfolglos und es kam zu keinen Gallenbildungen.\nErste Freilandvorkommen in Südtirol wurden im Unterland, in Castelfeder ( 400 m ) bei Auer am 28.04.-12.05.2005 festgestellt: vereinzelte Gallen an älteren Flaumeichen in Nähe einer großen Zerreiche (leg. K. Hellrigl \\& Förster A. Fostini). Hier am 10.08.2005 einige weitere abgefallene alte Haargallen am Boden unter vier Eichen, sowie zahlreiche frische Haargallen (grünlichgelb mit geröteten Spitzen) an einer kleineren Flaumeiche, in Sichtweite einer einzelnen großen Zerreiche. An dieser Flaumeiche wurden im August 2005 an die 30 frische Haargallen gezählt und fotografiert (Abb. 30 a, b).\nIm Jahre 2006 wurden bei Kontrollen in Castelfeder am 24.09.2006 sowie in Rovereto am 04.08.2006, jeweils einzelne frische Belege von MedusenhauptGallen gesammelt, aber keine näheren Beobachtungen zur Populationsentwicklung gemacht. Eine spätere Erhebung am 16.09.2007 ergab, dass es in Castelfeder im Laufe der letzten zwei Jahre zu einer drastischen Befallszunahme gekommen war. An vielen Flaumeichen, die vorher keinen oder nur vereinzelten Besatz mit A. caputmedusae-Gallen aufgewiesen hatten, fanden sich jetzt ein bis mehrere Dutzend Medusenhaupt-Gallen pro Baum. Besonders krass war die Situation in Nähe der einzelnen großen Zerreiche ( $\\varnothing 100 \\mathrm{~cm}$ ), wo die Flaumeichen mit hunderten von Medusenhaupt-Gallen gespickt waren (Abb. 30 c d). Diese lokale Häufung (Abb. VIc) bestätigt die vermutliche Bindung der unbekannten Sexualgeneration an die Zerreiche, die ihrerseits vom Befall der agamen Haargallen völlig verschont blieb.\nDie Befallsstärke in Castelfeder wurde noch evidenter im Frühjahr 2008; bei einer ersten Kontrolle am 3. März waren die noch unbelaubten Eichenkronen gespickt mit „Haargallen\" (Abb. VIb) und der Boden unter den Eichen war übersäht und förmlich bedeckt von „Medusenhauptgallen\" (Abb. VIa). Bei\neinem weiteren Besuch am 22.06.2008 fanden sich noch immer zahlreiche vorjährige Gallen an den Bäumen, wenngleich die meisten schon abgefallen waren; daneben fanden sich im Kronenlaub, an jungen Eichelbechern, bereits sehr zahlreich kleine purpurote „Kronenansätze\" ( $4-5 \\mathrm{~mm}$ ) von neuen Junggallen von A. caputmedusae (Foto). - Auch in Pomarolo fanden sich am 19.-27.07.2008 noch alte Haargallen an den Bäumen und am Boden; die rötlichen Junggallen maßen erst $10-15 \\mathrm{~mm} \\varnothing$ (Foto). Die ersten ausgewachsenen Medusenhauptgallen gab es in Pomarolo Anf. Sept. 2008 (Foto). - Bei einer weiteren Kontrolle am 12.10.2008 wurden hier 36 reife Haargallen am Boden und an den Zweigen gesammelt (leg. Hellrigl): davon wurden 12 Gallen am 15.10.08 geöffnet; sie enthielten in der Gallenkammer: Puppen dunkel, schlüpfreif 5 ( $42 \\%$ ); Imago frisch geschlüpft 1 ( $8 \\%$ ); Larven lebend 3 (25\\%); Larven vertrocknet 2 (16\\%); Parasitenlarve 1 (8\\%). Auch in Castelfeder waren am 20.10.2008 sechs Medusenhauptgallen zur Kontrolle geöffnet worden; sie enthielten 5 dunkle Puppen sowie 1 frische Imago.\nDie Entwicklungsdauer der Gallen beträgt somit 3 Monate: Anf. Juni bis Anf. Sept. - Was in der Zwischenzeit geschieht, d.h. nach der Schlüpfperiode der agamen $\\square$ - von Mitte/Ende Februar bis Mitte/Ende März [imJahr 2008: 17. Febr.- 18. März.: 79 Zuchtexemplare - synchron mit 90 Zuchtexemplaren von A. quercustozae], ist noch zu erforschen. In dieser zweimonatigen Intervallzeit (Mitte März bis Mitte Mai) kommt es wohl zur Ausbildung einer Sexualgeneration. Eine neue agame Generation ist bei A. caputmedusae jedenfalls gebunden an die Bildung von kleinen Jungeicheln (als Ansatzpunkt), was erst ab Ende April/Anf. Mai der Fall ist.\nZu einer gegenteiligen Populationsentwicklung wie in Castelfeder war es im Trentino bei Rovereto gekommen. Dort hatte sich im ,Bosco della città‘ der extrem starke Befall vom Herbst 2005 (Fotos Hellrigl \\& Bellmann) bereits im Folgejahr 2006 deutlich abgeschwächt (vid. Hellrigl \\& Bellmann: 04.08.2006). Im Herbst 2007 war dann dieser Befall durch A. caputmedusae sowie A. quercustozae hier nahezu völlig zusammengebrochen, so dass am 03.10.2007 hier nur mehr 1 Baum (absterbend) mit vielen A. caputmedusae und A. quercustozae (Fotos) aufzufinden war (Abb. IVb). Dieser drastische\n\n--- Seite 46 ---\nRückgang ist besonders im Falle der vormals hoch in den Baumkronen massenhaft vorhandenen Medusenhaupt-Gallen recht rätselhaft. - Hingegen wurde in einem nahen Gebiet, 5 km weiter nördlich, bei Pomarolo-Servis (IT-04: 700 m ), nur 11 Tage später am 14.10.07, weiter massenhafter Befall von A. caputmedusae und A. quercustozae festgestellt. An manchen Eichen wurden an die 100 MedusenGallen gezählt, am Boden wurden unter 2-3 Eichen 35 abgefallene Haargallen gesammelt (Hellrigl \\& Mörl); weitere 75 abgefallene MedusenhauptGallen wurden hier am 28.10.2007 unter den Eichen aufgesammelt und zur Feststellung der Parasitierung und der natürlichen Erscheinungszeit in Freilandaufzucht genommen, in einigen fanden sich bereits schlüpfreife Puppen und fertige Imagines.\nBei A. caputmedusae kann es offenbar lokal zu starken Gradationsschwankungen kommen; auch zeichnet sich eine Ausbreitungstendenz nach Norden ab. Unerklärlich blieb die fehlende Erwähnung von caputmedusae-Gallen in den älteren Faunistiken (Bezzi, Cobelli) des Trentino.\n\n31 Andricus conglomeratus (Giraud 1859)\n[= Cynips cincta Hartig 1879, cit. Wachtl 1882]\nBildet in der agamen Generation an den Zweigen vornehmlich strauchiger Eichen (Quercus petraea, Q. pubescens, Q. robur) $\\pm$ kugelige bis birnenförmige, sitzende Gallen von Größe einer Erbse bis einer Olive ( $8-13 \\mathrm{~mm}$ ), die an Triebspitzen meist in Gruppen zu 3-5 auftreten (Henschel 1888: Fig. 6). Die Gallen haben eine oft etwas abgeplattete längliche Form, besonders wenn mehrere eng zusammenstehen und sich berühren (Abb.31). Die Galle anfänglich glatt, grün mit schwarzer Spitze, dann braun, später runzelig dunkelrostbraun; die Wand ist derb porös, holzig, wie bei den ähnlich harten Gallen von A. lignicolus; die Kammer ist mehr randwärts gelegen. Die Galle hat zwei übereinander liegende hart- und hellwandige Zellen; die untere schmal birnenförmig gekrümmte nahe und parallel zur Basis, die obere kugelige, aus der später das Flugloch austritt, in der Nähe einer warzenförmig vorragenden Stichnarbe, die meist distal oder lateral auftritt. - Sexuelle Generation vermutlich an Zerreiche.\n\nNur wenige Autoren weisen auf die unauffällige Zweizelligkeit der Galle hin (Melika et al. 2000: 268-269, Fig. 9a, b). Im Gegensatz zu den unverkennbaren, grünen, deutlich genabelten Junggallen [Redu: Gallozzole lisce con puntolina: (Bernardi et al. 1997: 222, Fig. 57)] sind die älteren Gallen von A. conglomeratus oft nicht leicht zu unterscheiden von anderen Kugelgallen. Sie sind zu verwechseln mit atypischen kleinen Gallen mit Fremdbesatz von Andricus kollari oder mit \"Holzkugelgallen\" von A. lignicolus [für solche würde ich auch die \"conglomeratus\"-Gallen halten, die bei Bernardi et al. (1997: 180, Fig. 40; und 184, Fig. 42) abgebildet sind].\nIm südöstl. Mitteleuropa und S-Europa verbreitet; in Deutschland selten [Buhr 1965: 938: Nr. 5436; Riedel 1910: 36, Taf. 3, Fig. 15]; in Ungarn an jungen Bäumen und Stockausschlägen häufig (Csóka 1997: 90/91); fehlt in Spanien. - Checklist Ital. (1995: Nr. 13/09): Sizilien, N-Italien. Im Triestiner Karst (GrÄFfE 1905: 19, Taf. I, n.6: Cynips conglomerata); Gallenbelege vom Küstenland in Cecidothek GrÄFfE 1905 (Mus. Triest); idem: Tomasi (1996: 25-26, n. 20; 2006: 19, 66). - Bernardi et al. (1997: 222, Fig. 57; 223, Fig.c.64): Toskana, Pisa; Zapparoli (1997: 315): Insetti di Roma, Orto Botanico (Villa Corsini).\nFür Trentino wurden Gallen erstmals im Herbst 2007 bei Rovereto nachgewiesen, am 03.10.2007 ein Flaumeichen-Strauch mit mehreren Gallen (Foto Hellrigl), sowie am 24.04.2008 in Pomarolo (alte Galle: $9 \\times 12 \\mathrm{~mm}$ ). Fehlt bisher im Südtiroler Unterland bei Castelfeder an Flaumeichen. Hingegen fanden sich unerwartet im Eiscktal mehrmals vorjährige Gallen in Brixen, am nördl. Eisackufer, an neu angepflanzten, aus der Toskana importierten, 6 Meter hohen Stieleichen (Q. robur): am 30.11.06 zwei Gallen ( $\\varnothing=9 \\times 11 ; 12 \\times 14 \\mathrm{~mm}$ ) (Abb.31a), zusammen mit einigen alten Igelgallen von A. lucidus und Kugelgallen von A. kollari (leg. Hellrigl \\& Mörl); sowie am 04.08.2008 nochmals 15 dieser conglomeratus-Gallen mit folgenden Maßen: $\\varnothing=9 \\times 10 ; 9 \\times 11 ; 9 \\times 12 ; 9 \\times 12 ; 10 \\times 10$; $10 \\times 10 ; 10 \\times 10 ; 10 \\times 12 ; 10 \\times 12 ; 10 \\times 12 ; 10 \\times 12$; $11 \\times 13 ; 11 \\times 13 ; 12 \\times 14 ; 10 \\times 13 \\times 15 \\mathrm{~mm}$ (Abb. 31b); schließlich noch am 15.11.2008 eine frische Galle ( $15 \\times 13 \\mathrm{~mm}$ ) an einer gepflanzten Jungeiche aus dem Veneto (Abb. 31c).\n\n--- Seite 47 ---\n32 Andricus conificus (Hartig 1843)\nBildet in der agamen Generation an Adventivknospen von Ästen oder Stämmen von Eichen (Quercus petraea, pubescens, robur) stumpf kegelförmige Gallen ( $10-15 \\mathrm{~mm}$ ). Die breit aufsitzende, einkammerige Galle ist anfangs hell mit feiner violetter Zeichnung, später grau-bräunlich gefärbt und verholzt, mit deutlicher Längsstreifung. - [Kieffer 1901: 541, XXV, Fig. 10; Buhr 1965: 932, Nr. 5416; T. 15, Fig. 229; Pellizzari 1988: 97; Csóka 1997: 9293]. - Sexualgeneration vermutlich an Zerreiche. Die Galle war von Kollar [in Wien] an den Stämmen von Quercus pedunculata und Q.pubescens gefunden und Hartig übermittelt worden, der Wespe und Galle als \"Cynips conifica Kollar (in litt.)\" beschrieb [vgl. Hartig 1843: 402-403]. - Im südöstl. Mittel- und SE-Europa verbreitet: Österreich, Ungarn, Polen, Rumän., Bulgar., Italien, Jugosl., Ukraine; fraglich in Frankreich, fehlt in Spanien. In Checkl. Ital. (Pagliano 1995: Nr. 13/10) aus N-Italien gemeldet; von H. Bellmann 1989 in Istrien Kroatien, bei Marcana beobachtet (pers. Mitt.). Am Triestiner Karst schon von GrÄffe (1905: 15-16, Taf. II, n. 14) gemeldet: „Bei Triest ist Cynips conifica selten und fand ich nur wenige Stücke auf dem Karstplateau bei Reppentabor; einzeln an mehrjährigen Ästen von Quercus pubescens.\" Fundangaben \"Monrupino, Rupigrande, 1905 Gräffe\" und Triest/ Dolina 1993 zitiert von Tomasi (1996: 26, n. 21; 2006: 20, 66). Die Art ist auch aus Mittelitalien (Prov. Chieti) dokumentiert (Pellizzari 1988: 27). Rezente Erstnachweise für Region TrentinoSüdtirol: TN, Pomaolo-Servis (IT-04: 700 m ), 14.10.2007, 3 Gallen (11-13 mm) in Mannshöhe an Ästen (Ø 6-23 mm) von Q. pubescens, leg. Hellrigl \\& Mörl (Abb. 32a, b). Die drei Gallen entsprachen der aus Italien (leg. Trotter) beschriebenen var. longispinus Kieffer 1901, die sich von der typ. Form durch einen spitz auslaufenden, bisweilen $\\pm$ abgebogenen Endteil unterscheiden; diese Varietät kommt auch in Ungarn vor und wurde teilweise als ssp. geführt. Weitere Funde in Pomarolo: am 25.04.2008 (leg. Hellrigl \\& Mörl) zwei vorjährige Gallen ( $8-10 \\mathrm{~mm}$ ) mit Flugloch (var. longispinus), an Kronenzweigen von Flaumeichen (Abb. 32c, d).\nSchließlich wurde in Pomarolo-Servis am 07.09.2008 noch eine farbenprächtige, frische Galle der stumpfkegeligen Form ( $11 \\times 11 \\mathrm{~mm}$ ) an einer\nstrauchigen Flaumeiche (in 1,5 m Bodenhöhe) gefunden (leg. Mörl \\& Hellrigl) (Abb. 32e, f); daraus schlüpfte am 25.09 .08 vorerst nur ein Einmieter, Synergus umbraculus $\\stackrel{*}{=}$. - An denselben Eichen fand sich häufiger auch der ähnliche Andricus truncicolus, dessen leicht zerfallenden Außengallen Anlaß zur Verwechslung geben könnten (vgl. Nr. 73). Die Wespen dieser und verwandter Arten erscheinen angeblich im März.\n\n## 33 Andricus coriarius (Hartig 1843)\n\nDie agame Generation bildet an Zweigen div. Eichen unregelmäßig geformte Gallen von 10-30 mm $\\varnothing$, mit zahlreichen rinderhornartig gekrümmten, bis 5-15 mm langen Fortsätzen. Die anfangs (im Aug.) grünliche, später hellbraune Galle enthält mehrere Kammern bzw. Fluglöcher. Es ist nur die agame Form bekannt [vgl.: Zahradnik 1985: 79; Pellizzari 1988: 98; Csóka 1997: 88/89; Melika et al. 2000: 269, Fig. 11; Nieves-Aldrey 2001: 393, 539; Figs. 127 E, 142 C]. - Sexuelle Generation vermutlich an Q. cerris zu erwarten, bzw. in Spanien auf Q. suber [Nieves-Aldrey 2001: 394-395]. Von Marokko über Spanien, Südeuropa und südöstl. Mitteleuropa (Österr., Ungarn, Czechien, Rumän., Jugosl.) bis Kleinasien verbreitet; fehlt in Britannien [Redfern et al. 2002]. Die nicht häufige, offenbar mehr südliche Art fehlt auch in den Gallwespenfaunistiken Deutschlands von Riedel (1910) und Kieffer (1914), ebenso erwähnt sie Buhr (1965: Nr. 5466) nicht für Deutschland.\nIn Checklist Ital. (1995: Nr. 13/12): N-Italien und Sizilien. - Zapparoli (1997: 316) Mittelitalien: Gli Insetti di Roma, Orto Botanico (Villa Corsini). - Bernardi et al. (1997: 128, Fig. 16) geben sie an aus Toskana und Ligurien. - Locus typicus: Triest-Istrien (Hartig 1843: 421); am Triestiner Karst später von GrÄfFe (1905: 17-18, Taf. I, n. 1) und Tomasi (1996: 26-27, n. 22) bestätigt. GrÄFFE (1905: 18) berichtet darüber: „Man findet diese Gallen von Cynips coriaria sehr häufig an den Wolleichen [gemeint ist Flaumeiche Quercus pubescens] des Karstes, indessen eigentümlicher Weise nur periodisch. Es gibt Jahre, wo man dieselbe vergebens sucht und nur verwitterte alte Gallen findet.\" Neumeldung für Südtirol und Trentino: hier meist in Gebieten mit Zerreiche. In Südtirol rezent mehrfach in Castelfeder, an Zweigen von\n\n--- Seite 48 ---\nFlaumeichen, in Nähe einer großen Zerreiche, gefunden: 12.05.- 07.07.2005: drei kleine vorjährige Gallen; 10.08.2005: 4 alte Gallen (Abb. 33b) und 2 frische, grüne Gallen (Abb.33a). - Später noch öfters Gallen im Eichenhain von Castelfeder, an großen Flaumeichen (Q. pubescens): 24.09.2006, an 4 Bäumen 9 Gallen (10-25 mm); 16.09.2007 an div. Eichen insgesamt 15 Gallen: ganz kleine bis ziemlich große (Abb. 33) (leg./det. Hellrigl); am 17.08.2008: 6 alte Gallen und 2 frische grüne (leg. Hellrigl \\& K. Schanung). - Typische Gallenkombinationen an den Bäumen oder Zweigen waren: A. coriarius + A. solitarius + A. caputmedusae + A. infectorius + A. kollari.\n\nIm Eisacktal - wo die Zerreiche fehlt - ist mir diese Galle im Freiland nie untergekommen. Einziger Nachweis aus Brixen war am 26.11.2006 eine Galle (leg. Hellrigl \\& Mörl), an einer im Frühjahr aus Toskana importierten, als Alleebaum angepflanzten Stieleiche. Allerdings wurde am 16.08.2008 auch bei Feldthurns/Drumbichl ( 800 m ) im Freiland eine vorjährige Galle an Traubeneiche gefunden (leg. K. Schanung, vid. Hellrigl); dies würde obligatorischen Wirtswechsel mit Zerreiche ausschließen.\nIm Trentino: Rovereto, Bosco della città ( 350 m ), alte Galle ( $16 \\times 24 \\mathrm{~mm}$ ) an Zweig Q. pubescens, 05.04.2005 (leg. Ambrosi \\& Hellrigl); ebendort: an Flaumeiche, ein Zweig mit 3 Gallen, 25.09.2005 (leg. Bellmann \\& Hellrigl); 04.08.2006 hier vereinzelt weitere Gallen; ebenso am 03.10.2007 eine alte Zwillingsgalle $(20+20 \\mathrm{~mm})$ sowie eine schöne frische Galle ( 30 mm ) von ungewöhnlicher ziegelroter Färbung und eigenartiger Form (Abb.33c) (leg. Hellrigl). - Pomarolo-Servis (IT-04: 700 m), 14.-28.10.2007, 10 Gallen an Quercus (leg. Hellrigl \\& G.v.Mörl); ebendort 24.04 .08 zehn vorjährige Gallen und 02.06.2008 weitere 6 alte Gallen (leg. Hellrigl \\& K. Schanung). - In den Untersuchungsjahren 2005-2008 haben sich ziemlich einige Gallenbelege von A. coriarius für das Südtiroler Unterland und Trentino angesammelt; zusammen rd. 100 Belege (in coll. Hellrigl). - Kleinere Gallen mit kurzen „Hörnern\" („Teufelsköpfe\") oft nicht leicht zuzuordnen, da eventuell verwechselbar mit A. amblycerus oder mit A. corruptrix. - Gallen aus Castelfeder, Rovereto und Pomarolo waren mitunter stark parasitiert von der Torymidae Megastigmus dorsalis (Fabr.) (leg./det. Hellrigl: 20.05.2008).\n[34] [Andricus coronatus (Giraud 1859)]\n$[=$ Cynips coronaria Stefani 1897]\n[= Cynips glutinosa var. coronata Mayr]\nVerursacht in der agamen Generation an Zweigen strauchartiger Eichen (Quercus spp.) kronenförmige, anfänglich rote, $\\pm$ klebrige Gallen, $8-15 \\mathrm{~mm} \\varnothing$, bzw. 6-12 mm hoch [BuHR 1965: Nr. 5462; ChinerY 1987: 228; Pellizzari 1988: 99; Csóka 1997: 88]. Fehlt in Spanien (Nieves-Aldrey 2001).\nBei Henschel (1888: Taf. I, Fig. 9 Cynips glutinosa) finden sich C. corontata (u. rechts) gemeinsam mit C. mitrata (u. links) und der Stammform C. glutinosa (oben) unter einem Namen abgebildet (Abb. 34).\nIn Mittel- und SE-Europa verbreitet: Österreich, Ungarn, Italien, Sizilien, Balkan, Rumänien, Ukraine.\nCheckl. Ital. (1995: Nr. 13/13) N-Italien, Sizilien (Stefani); Mittelitalien: Rom (Zapparoli 1997: 316, Gli insetti di Roma).\nVom Triestiner Karst von Gräffe (1905: 16-17, C. glutinosa Giraud var. coronata Mayr; Taf. I, n. 2) aus S. Pelagio und Basovizza (leg. Gräffe 1905: Cecidothek) gemeldet; nebst einigen rezenten Funden von Tomasi (1996: 27, n. 23; 2006: 66) zitiert. Vielleicht auch im Süden der Region zu erwarten.\n\n35 Andricus corruptrix (Schlechtendahl 1870)\n[= Cynips ambigua Trotter 1899] - „Zipfelgalle\"\n[= Andricus ambiguus (Trotter)]\nVerursacht in der agamen Generation an Knospen junger Eichentriebe (Quercus robur, Q. petraea, Q. pubescens) $4-6 \\mathrm{~mm}$ hohe bauchige harte Gallen, oben 2 bis 5 stumpfzipfelige Fortsätze („Zipfelgalle\"). Die Galle ist der von A. amblycerus ähnlich, hat aber kürzere, dickere Fortsätze, die breit abgerundet sind und nicht mit einer Spitze, sondern mit einem Wärzchen enden (Abb. 35). Bisweilen kommen auch knospenähnliche, spitzzipfelige Gallen vor (Abb. 35); die Wespen schlüpfen ab Mai-Juni.\nSexualgeneration mit eiförmigen Knospengallen an Zerreiche (Q. cerris). - [Dalla Torre \\& Kieffer 1910: 421, Fig. 138-139; BuHR 1965: 99 Nr. 5458 (corruptrix), Nr. 5460 (ambiguus); 99 Nr. 5567 (corruptrix); Pfützenreiter 1958: Nr. 16, Abb. 11 (99 Zipfelgalle); Nr. 19b (99); Redfern et al. 2002: 403, Fig. 673 (99); 405, Fig. 682 (99); MeliKa et al. 2000: 267, Fig. 2a-c (ambiguus), 269, Fig. 13 (corruptrix); Bellido et al. 2003: 188-190].\n\n--- Seite 49 ---\nWeite Verbreitung in Europa (Bellido et al. 2003); fehlt in Spanien (Nieves-Aldrey 2001). - In Checklist Ital. (1995) doppelt angeführt: als Andricus corruptrix (Nr. 13/14) ohne Fundangabe, und als Cynips ambigua (Nr. 20/01) aus N-Italien (Verona: cit. Dalla Torre \\& Kieffer 1910: 421).\nAus Triest Umgeb. wird Cynips ambigua von GrÄFfE (1905) nicht angeführt. Später drei Meldungen von \"Andricus (Cynips) ambiguus (Trotter)\" vom Triestiner Karst (1991/92) durch E. Tomasi (1996: 24, Nr.17); die hierzu zitierte Abb. \"Tab. C-12\" bezieht sich allerdings nicht auf diese Knospengalle, sondern auf eine ganz andere Blattgalle [= Cynips longiventris]. - Später führt Tomasi (2006: 67-71) dieses Taxon unter zwei Namen an: Cynips ambigua Trotter bzw. Andricus corruptrix (Schlecht.), aus Triest-Dolina 23.08.1992 bzw. Duino-Aurisina 17.05.1994; [diese Angaben sind zu verifizieren]. War in Südtirol-Trentino zu erwarten, in Gebieten wo auch Quercus cerris vorkommt. Erstnachweis gelang im Trentino bei Pomarolo-Servis (IT-04: 700 m ), am 28.10.2007, zwei mehrzipfelige Gallen ( 6 mm ), an einer strauchigen Flaumeiche, an der sich auch Gallen von Andricus kollari und A. quercustozae fanden (leg. Hellrigl \\& Mörl). Sechs weitere vorjährige Gallen ( $\\varnothing 6-7 \\mathrm{~mm}$ ), noch ungeschlüpft (Abb. 35), fanden sich hier am 25.04.2008 zusammen mit $A$. quercustozae an Kronenzweigen von Flaumeichen (leg. Hellrigl \\& Mörl). Aus den Gallen schlüpften die ersten drei agamen Weibchen am 10.-11.05.2008 (Abb. 35e). Eine weitere Galle mit frischem Flugloch hier am 02.06.08 an Eichenzweig mit Galle von A. quercustozae; weiters am 19.07.08 zwei alte Knospengallen mit Flugloch und am 12.10.2008 drei frische ungeschlüpfte Knospengallen (leg. Hellrigl \\& Schanung). Schließlich noch ein Nachweis in Castelfeder, 22.06.2008, 1 Galle an Flaumeiche. Erstmeldung für Südtirol und Trentino.\nZahlreiche, meist vorjährige Gallen (ca. 40 Ex.), an dünnen Zweigen oft zusammen mit Kugelgallen von Andricus kollari (Fotos), fanden sich am 04.06.08.2008 in Brixen (nördl. Eisackufer) an einer im Mai 2008 aus Veneto (Bassano) importierten, angepflanzten 5 Meter hohen Stieleiche (Q. robur) (leg. Hellrigl \\& Mörl). Davon schlüpften aus drei diesjährigen Gallen (Abb. 35b) am 02.Sept. 2008 drei Wespen von A. corruptrix (Abb.).\n\n36 Andricus curvator Hartig 1840 ㅇo\n\n- „Blasengalle\"\n[= Cynips axillaris Hartig 1840 - „Haarnadelgalle\"]; [agam = Cynips collaris Htg. 1840 - „Kragengalle\"] Die sexuelle Generation bildet an Eichenblättern erbsengroße, beidseitig hervortretende Blasengallen mit kleiner Innengalle; bewirkt oft auch Blattstielu. Triebkrümmungen (\"Curved-leaf gall causer\"). Die agame Generation bildet kleine unauffällige einkammerige Knospengallen („Kragengalle\") an jungen Eichentrieben (\"Collared-bud gall causer\") [= Andricus collaris (Htg.)]. - [PfÜTZENREITER 1958: Nr. 28, Abb. 22 (agam: Kragengalle); Nr. 32, Abb. 25 (Blasengalle); Nr. 9, Abb. 6 (f.axillaris Htg. - Haarnadelgalle); BuHR 1965: Nr. 5483, T. 16, Fig. 251; Pellizzari 1988: 100; Csóka 1997: 100; NieVes-Aldrey 2001: 353, 535; figs. 130A, 140F; Redfern et al. 2002: 402, Fig. 669]. Die Blasengallen der bisexuellen Generation finden sich schon bei RÉaUMUR 1737 (T. 39: Fig. 5) abgebildet; wurde später auch als Cynips roeselii Dahlbom 1842 (nom. nudum) benannt.\nVon Dalla Torre (1896) mehrfach aus Nordtirol genannt, Gallen an Q. pedunculata: Eichenwald bei Stams und Volderwald bei Hall, Sept. 1894. - Von Bezzi (1899) auch aus Trentino gemeldet, bei Mollaro ( 470 m ), Val di Non. - [Checklist Ital. 1995: Nr. 13/16]. - Am Triestiner Karst durch GrÄFfE (1905: 61, Andricus collaris Htg.) genannt; auch von Tomasi (1996: 27, n. 24; 2006: 22, 67) zitiert. Bernardi et al. 1997: 108: Toskana, Trentino-A.A., Friaul-V.G., Veneto, Emilia-Romagna, Ligurien, Latium, Sizilien. - In Südtirol bei Montiggl Blattgallen an Eichengebüsch, 23.04.2004 (S. Minerbi: Abb.36a); ebenso in Kastelbell, 15.05.2004 (S. Minerbi). - Montiggl (IT-02), 28.04.2005, (Abb.36b) viele Gallen an Q. petraea (leg. Hellrigl \\& A. Fostini). Im Trentino: Pomarolo-Servis (IT-04), 14.10.2007, Haarnadel-Gallen, leg. Hellrigl \\& G. v. Mörl.\n[37] [Andricus crispator Tschek 1871] ㅇo\n[= Andricus adleri Mayr 1880]\nBildet an den Blättern von Quercus cerris langovale ( $2,5 \\mathrm{~mm}$ hohe - $1,5 \\mathrm{~mm}$ breite), senkrecht zur Blattfläche stehende, lang behaarte Gallen. Zuerst saftig, grün oder rot, später trocken und gelblich. In der Regel gehäuft auf den Spreiten der meist\n\n--- Seite 50 ---\nstark verkrüppelten Blätter. - [BuHR 1965: Nr. 5589; Checkl. Ital. 1995: Nr. 13/15, Sizilien]. - Wird für Österreich, Ungarn, Rumänien und Sizilien angegeben (H. BuHR 1965: 982); vom Triestiner Karst von GräFfE (1905: 43-44, Andricus adleri) gemeldet, „nur einmal in einer Doline bei Nabresind [Aurisinia] an einem Strauch der Zerreiche\"; (vgl. Tomasi 1996: 24). - Rezent von Dr. H.-J. Buhr auch in SWSlowenien, bei Sezena, 12.06.2005 gefunden. Das Vorkommen in der Höhe von Triest lässt auch ein Vorkommen im Trentino möglich erscheinen.\n\n## 38 Andricus cydoniae (Giraud 1859)\n\nBildet in der bisexuellen Generation an Sprossachsen bzw. an Triebspitzen von Zerreiche (Q. cerris) ansehnliche Gallenkörper an den Spitzen der Triebe, bis 15-20 mm lang, unregelmäßig rundoval, im Frühjahr grün, später dunkelbraun, schwach behaart, holzig, teilweise überdeckt von verkrümmten bzw. abgestorbenen Blättern (Abb. 38). Galle mit einer großen, oben breit offenen Höhlung, an deren Grund zahlreiche eiförmige Innengallen vorragen. - Agame Generation nicht bekannt; als solche kommen eventuell in Betracht A. hartigi oder Andricus truncicolus (vgl. Stone et al. 2007: 9).\nNach der etwas diffusen Gallenbeschreibung von BuHR (1965: 969) läßt sich die Galle in den Merkmalen und auch im jahreszeitlichen Verlauf kaum unterscheiden von Andricus multiplicatus (Nr. 55); die Gallen dieser beiden Arten dürften wohl öfters miteinander verwechselt worden sein. - [H. BuHR 1965: 969: Nr. 5544. - Csóka 1997: 100/101. Melika et al. 2000: 270, Fig. 17. - H.-J. BuHR 2007: www/Pflanzengallen.de: Griechenland, Euböa, Eretria, 06.06.2004, Galle an Caucasischer Eiche.]. Verbreitung: Österreich, Ungarn, Czechien, Südosteuropa, Italien. - Fehlt in Spanien.\nChecklist Ital. (1995: Nr. 13/17): N-Italien, Sizilien. Im Triestiner Karst nach GräFfE (1905: 42): „Gallen von A. cydoniae an Zweigen von Quercus cerris sind keine häufige Erscheinung bei Triest.\" ToMaSI (1996: 28; 2006: 22) zitiert Funde von Gräffe (1905), sowie (2006: 67, Eigenfund von 1995).\n\nErstnachweis für Region Trentino-Südtirol: Poma-rolo-Servis (IT-04: 700 m ), 14.10.2007, an strauchigen Zerreichen (Q. cerris) 24 alte, braune Gallen, leg. Hellrigl \\& Mörl (Abb. 38). - Anfang Juni 2008 hier dann 1 Dutzend frische grüne Gallen (Abb. 38),\nmit noch relativ kleinen Larven in den Zellen (leg. Hellrigl \\& Schanung); daraus schlüpften bis Ende Juni nur zahlreiche Parsitoiden [Ormyridae: Ormyrus pomaceus (Geoffroy 1785) = Ormyrus punctiger Westw.], keine Gallwespen. Weitere 20 braune Gallen wurden am 19.07.08 gesammelt (Abb. 38), sowie am 12.10.08 an unteren Kronenästen älterer Zerreichen 2 verholzte Galle vom Frühjahr (Fotos) sowie 2 ältere Gallen vom Vorjahr (leg./Foto Hellrigl).\n[39] [Andricus dentimitratus (Rejtö 1887) Balas 1941]\n$=$ Cynips mayri Kieffer 1897 [nec Wachtl 1879]\n= Diplolepis tojae (F.) Fonsc. 1832, nec Fabr. 1793;\n[= Andricus viscosus Nieves-Aldrey 1986]\nDie agame Generation bildet an Eichenzweigen (Quercus robur, Q. pubescens, Q. petraea u.a.) auffällige, den Fruchtbecher von Eicheln weitgehend umfassende Gallen (Buhr 1965: p. 967, Nr. 5538). Die Gallen sind holzig, braunrot glänzend und klebrig, bis 25 mm hoch und 20 mm breit; sie haben die Form eines Hutpilzes mit am Rand grob gezahnter Krone (= ,,dentimitratus\") [vgl. Pellizzari 1988: 27, 101. - Csóka 1997: 122 (A. viscosus). - Bernardi et al. 1997: 190, Fig. 44. - Melika et al. 2000: 270, Fig. 18. - Nieves-Aldrey 2001: (A. viscosus) p. 404, 539; Figs. 127 H-I, 144 D].\n\nDie Galle wurde bereits von Olivier (1791: 281282) beschrieben als \"Schirmgalle\" (\"Diplolepe de la galle en parasol\") Diplolepis umbraculus Olivier (umbraculum $=$ Sonnenschirm) aus der Provence (leg. D'Anthoine), doch handelt es sich bei der beschriebenen geschlüpften Wespe nicht um den Gallenverursacher sondern um eine Inquiline, später benannt als Synergus umbraculus (Olivier 1791). In Österreich selten, häufiger in Ungarn, Balkan, Italien, S-Frankreich und Spanien (Buhr 1965). - In Checklist Ital. (1995: Nr.13/18) ohne Fundangaben [A. dentimitratus (Balas 1940)]; aus Sizilien von De Stefani 1897 [= Cynips mayri Kieff.] zahlreich an Q. robur gemeldet; dort auch von Buhr (1965) genannt; nach Schimitschek (1944: 298, Cynips mayri Kieff.) in der Türkei im Belgrader Wald an Quercus conferta. - Italien-Festland von Pellizzari (1988: 27) aus Abruzzen (Monteodorisio/Chieti: VIII.1986) belegt; von Zapparoli (1997: 316) Gli Insetti di Roma: Orto Botanico (Villa Corsini)\n\n--- Seite 51 ---\n1992; von Bernardi et al. (1997: 190) aus Toskana (Calci/Pisa, 1996). Vom Triestiner Karst von Tomasi (1996: 28, Nr. 26; 2006: 67, Cecidothek FVG) gemeldet. - Für die Region Trentino-Südtirol ist diese auffällige, mediterrane Art allenfalls für das südliche Trentino zu erwarten.\n\n40 Andricus fecundator (Hartig 1840)\n$=$ Andricus fecundatrix var. (Hartig 1840: 189) $ᄋ$\n$=$ Andricus fecundatrix (Hartig 1841: 335) $ᄋ ㅇ$\n$=A$. foecundatrix (Hartig 1840) auct. [misspelling]\n[ $ᄋ$ = pilosus Adler 1881]\nVerursacht in der agamen Generation „Hopfenzapfen\"- oder „Artischocken\"-Gallen an Quercus (\"Artichoke or hop-gall causer\"); [BuHR 1965: 934, Nr. 5425 „Eichenrose\", T. 14, Fig. 224; Zahradnik 1985: 79; Chinery 1987: 226; Amann 1990: 86; Csóka 1997: 90; Melika et al. 2000: 270, Fig. 19; Nieves-Aldrey 2001: 359, 535; figs.; Redfern et al. 2002: 405, Fig. 686]. - Sexualgeneration in kleinen behaarten Gallen an männlichen Blütenkätzchen: pilosus Adler (\"Hairy-catkin gall causer\"). [PpützenREITER 1958: Nr. 14, Abb. 9 ( $ᄋ$ Eichenrose); Nr. 56, Abb. 43 ( $ᄋ$ Blütengalle)].\nDie unverkennbare „Artischocken-Galle\" od. „Eichenrose\" war schon von den älteren klassischen Autoren (Malpighi 1687, Réaumur 1737, Rösel 1747) abgebildet worden; später wurde die Art von Linné (1758: 554, Nr. 8) nach der Galle als \"Cynips Quercus gemmae\" benannt, mit Referenz auf die Abb. bei RÉaumur (1737: T. 43) sowie Bezug auf Linné's: Fn. svec. [1746: 288] n. 948: \"Tenthredo gallae imbricatae: Habitat in Quercus gemma terminali, in gallam imbricatam tumescente\". Die Zuordnung dieser Gallenbeschreibung zur „ArtisChocken-Galle\" steht außer Frage. Dies bestätigt auch Hartig (1840: 189) als er die Imagines dieser Art beschrieb und \"Cynips fecundatrix\" benannte. Checklist Ital. [1995: Nr. 13/19, A. fecundator (Hartig)]. - Bernardi et al. (1997: 124, Fig. 14, A. fecundator) Toskana, Piemont, Veneto, Ligurien, Emilia Romagna, Sizilien. - Für FVG und den Triestiner Karst wird die Art mit den \"Eichenrosen\" erstmals von Tomasi (2006: 67) erwähnt (1994).\nDalla Torre (1892, 1896): Gallen von Andricus fecundatrix Htg. an Q. pedunculata: Bozen (G. Mayr) und an Q. pubescens: Atzwang, 24.07.1894. - D.T. (1892-96): Solche „Eichenrosen\" auch mehrfach in\n\nN-Tirol und Osttirol. - Zahlreiche rezente Nachweise aus ganz Südtirol und Trentino:\nHellrigl (1996: 690; 1997: 66, Abb. 7, Fig. 1-2): „Artischocken\"-Gallen an Quercus pubescens, Latsch 13.08.1992; Ritten, 1200 m, 16.07.1992 (leg./Foto Hellrigl). - Ritten: Oberbozen, Klobenstein, 1150-1250m, an Quercus petraea, zahlreich 03.08.1999; Raas-Elvas bei Brixen, 800 m , 23.09.1999, häufig an Eichen; Dorf Tirol, VIII.1999, häufig (leg. Hellrigl). Tschögglberg, Vöran, 19.08.1999, an Quercus (leg. R. Franke); Mölten, 1050 m , an Q. pubescens, 04.08.2004, hier zusammen mit der inquilinen Gallmücke Clinodiplosis cilicrus (Kieff.) (leg. et comm. M. Skuhrava).\nNeustift $(750 \\mathrm{~m}), 17.10 .2004$ sowie 20.07.24.09.2005, einzelne Gallen an Q. petraea (leg. Hellrigl). - Tschötsch ( 750 m ), einige alte Gallen an Q. pubescens, 10.04.2005 (leg. Hellrigl \\& Mörl); Tschötscher Heide, $750 \\mathrm{~m}, 14.09 .-07.10 .05$, einige Gallen an Quercus; ebenso Feldthurns, 800 m , 11.09.05; Kranebitt-Krakofl, 650m, 18.08.05; Gufidaun, $730 \\mathrm{~m}, 05.09 .2005$, einige Gallen an Q. petraea (leg. Hellrigl). Aicha-Spinges, 850 m , 11.10.05, zwei voll „aufgeblühte\" Gallen (Abb. 40) und 8 noch geschlossene (leg./Foto Hellrigl); ebendort 2 Zweige Q. petraea mit 3 Artischockengallen (1-2-3 cm), 06.09.2006. Brixen-Tschötscher Heide ( 750 m ), 03.-30.09.2006, an Traubeneiche 5 Gallen (leg./Foto Hellrigl).\nIn Brixen, nördl. Eisackuferstraße, am 26.11.2006, an aus der Toskana (Pistoia) importierten, 6-8m hohen Stieleichen, 10 alte Gallen von A. fecundator (leg. Hellrigl \\& Mörl). Hier am 04.08.08 mehrere frische, große Artischockengallen ( $\\mathrm{L}=25 \\mathrm{~mm}$, $\\mathrm{D}=15 \\mathrm{~mm}$ ), die kurz vor dem Aufblühen und Abfallen standen (Fotos), an im Mai 2008 nachgebesserten Stieleichen aus Bassano (leg. Hellrigl \\& Mörl). Im Sept. 2008 öfters einzelne große Artischockengallen in Brixen Umgeb. bei Albeins, Neustift, Elvas, Feldthurns, Tschötsch (Hellrigl \\& Schanung).\nAuch im Etschtal bei Montiggl (IT-02) und Castelfeder, 28.04.2005, einige alte Gallen an Q. petraea/ pubescens; ebenso bei Pinzon, 450 m , VII. 2005 (leg. Hellrigl); hier auch in den Folgejahren 2006/07. In Eichengebieten in Südtirol sind „Hopfengallen\" regelmäßig anzutreffen, aber meist nur vereinzelt. Trentino: Pomarolo-Savignano, Monitoring-Fläche\n\n--- Seite 52 ---\n(IT-04: 700 m ), Gallen an Q. pubescens, X. 2004 (leg. Ambrosi \\& Hellrigl). - Rovereto-Dossi, Bosco d. città, $350 \\mathrm{~m}, 05.04 .2005$ und 01.09.2005, einzelne Gallen an Q. pubescens (leg. Hellrigl \\& Salvadori); hier auch im VIII. 2006 und 03.10.2007 vereinzelte Gallen (leg. Hellrigl). - In Pomarolo-Servis (IT-04), 14.10.2007, 3 alte Gallen (leg. Hellrigl \\& Mörl). Hier auch am 19.-27.07.2008, an div. Flaumeichen zahlreiche frische, noch geschlossene, 1-2 cm große Artischockengallen (Abb. 40), oft zeilig untereinander (leg. Hellrigl \\& Schanung); ebenso am 07.09.08 an die 20 große „Hopfengallen\" und am 12.10.08 eine am Boden liegend (leg. Hellrigl \\& Mörl).\n\n## 41 Andricus galeatus (Giraud 1859)\n\nNur die agame Generation bekannt, welche Knospengallen an den Triebspitzen div. Eichen verursacht. Die Galle ist $8-10 \\mathrm{~mm}$ hoch, doppelstöckig und scharf quergeteilt: der untere rundovale Teil braunrot ( 3 mm ), darüber zwiebelförmig aufsitzend ein hohler Oberteil ( $5-7 \\mathrm{~mm}$ ) mit schopfartigen Fortsätzen („Turbangalle\": Abb.41); Gallen im Hochsommer. - [Buhr 1965: 943, Nr. 5456. Pellizzari 1988: 102. Csóka 1997: 94. Bernardi et al. 1997: 194, Fig. 46. Melika et al. 2000: 270, Fig. 20].\nVerbreitet in Österreich, Ungarn, Südost-Europa, Balkan, Italien, Sizilien. - Fehlt im Westen: Britannien, Frankreich, Spanien sowie Zentraleuropa: Deutschland, etc. - Checklist Ital. (1995: Nr. 13/20): Sizilien, N-Italien. Vom Triestiner Karst von GrÄFFE (1905: 22; T. II, n. 11: Cynips galeata) von Q.pubescens gemeldet: „die höchst auffallend gebildete Galle ist recht selten.\" GrÄFFE in Cecidothek FVG, cit. Tomasi (1996: 28, n. 27; 2006: 11, Fig. 4). Bernardi et al. (1997: 194) ganz Italien.\nRezente Erstnachweise für die Region Trentino-Südtirol: Pomarolo-Servis (IT-04: 700 m): 14.10.2007, 4 Gallen, leg. Hellrigl \\& Mörl (Abb. 41b) zusammen mit 10 Gallen von $A$. amblycerus und 6 Gallen A. kollari an niederem Eichengebüsch (Q.pubescens) unter einer Überhälter-Zerreiche; PomaroloServis: 28.10.2007, 2 alte Gallen an Triebspitze von Eiche, neben zwei vorjährigen Gallen von Andricus quercustozae, leg. Hellrigl \\& G. v. Mörl (Abb. 41c). Hier auch am 19.07.2008 an Flaumeiche, in 2,5 Meter Höhe, eine vorjährige Galle, sowie an niederem Eichenbusch ( 50 cm Bodenhöhe) eine frische Galle (Abb. 41 d ), long. $9 \\mathrm{~mm}, \\varnothing 5 \\mathrm{~mm}$,\naus der am 13.08.08 die Imago schlüpfte; weiters am 27.07.2008 an Flaumeiche eine frische Galle ( $3+7 \\mathrm{~mm}$ ) in Hüfthöhe, daraus Imago am 08.08.2008 (Abb. 41e); sowie an einem Strauch eine frische Drillingsgalle (leg./Foto Hellrigl), daraus Imagines am 15.08.08 (K. Schanung). - Hier auch am 07.09.2008 weitere 2 Gallen mit frischem Flugloch (Hellrigl \\& Mörl). - Die Galle ist ein sehr charakteristisches Element der südlichen Trentiner Fauna und bestätigt die faunistische Übereinstimmung und Zugehörigkeit dieser Region zum südosteuropäischen Verbreitungstypus. Eine Wirtswechselbeziehung (Sexualgeneration) mit Q. cerris wird vermutet. Im Etschtal/Unterland vielleicht auch für Südtirol (Prov. Bozen) zu erwarten.\n\n42 [Andricus gallaetinctoriae (Olivier 1791)] - „Aleppo\"- oder „Levantinische Galle\"\n[= Cynips infectorius auct. p.p., nec Hartig 1843]; Die klassische „Färbergalle\" C. gallaetinctoriae, altbekannt als „Aleppo\"- oder „Levantinische Galle\", ist eine letzthin öfters missdeutete Art, die wegen Unklarheiten bei Beschreibung, Interpretierung und Verbreitung von Pujade-Villar, Bellido et al. $(2002,2003)$ als \"nomen dubium\" angesehen wurde. Die hauptsächlichste Verwechslung dieser Art bestand mit der südosteuropäischen Cynips infectoria Hartig 1843, neuerdings vielleicht auch mit der nahöstlichen Andricus sternlichti Bellido et al. 2003.\nBereits Hartig (1843: 400) erwähnt \"Cynips tinctoria\" als Erzeugerin der bekannten levantischen Galläpfel. Terra typica ist die „Levante\" (östliches Mediterranean), insbesondere N-Syrien (Haleb = Aleppo) und Kleinasien (Asia Minor), von wo sie Olivier (1801: 252) später ausdrücklich erwähnt. Zunächst aber hatte Olivier (1791: 281) in seiner Originalbeschreibung der Galle von Diplolepis gallae tinctoriae bemerkt: \"La même espèce de galle qui nous vient du Levant, \\& la seule qu'on emploie dans le commerce, se trouve dans les provinces méridionales de la France, quoique plus petite. L'insecte, également plus petit, qui sort de la dernière, est le même que celui du levant, comme je m'en suis convaincu.\" - [\"The same species of gall that comes to us from Levant, and which is employed in commerce, was also found in the Meridional provinces of France, but they are smaller.\"\n\n--- Seite 53 ---\n(cit. Bellido et al. 2003: 193)]. - Die Bemerkung Olivier's (1791), über Vorkommen einer kleineren Form von Galle und Insekt dieser „Levante-Galle\" auch in den südlichen Provinzen Frankreichs, wird auch zitiert von Kieffer (1901: 567) und folgendermaßen kommentiert: \"Cette remarque s'applique sans doute à la variété nostra De Stefani.\" Ebenso wie De Stefani, Wachtl u.a. hält Kieffer (1901: 568) die kleinere \"tinctoria nostra\"-Galle (Ø 7-15 mm) nicht nur für eine Varietät von \"tinctoria Ol.\" (Ø 15-20 mm) sondern für eine eigene Art, mit Verbreitung in Niederösterreich (Mayr, Wachtl), Ungarn (Paszlavszky), Istrien (Trotter), Sizilien (De Stefani) und Südfrankreich (De Fonscolombe).\nWie die Bezugnahme von Olivier (1791) auf die Abbildung von Reaumur (1737: Mém. Ins. T.3, Pl.35, Fig.5) zeigt, gibt es im mittleren Mediterraneum (Südfrankreich, Italien) offenbar ähnliche Gallen.\nDie Beschreibung von Reaumur's Fig. 5 (Tafel 35), einer \"Holzkugelgalle\" [galle en boule de bois] bei der Größenangaben leider fehlen, wo aber auf deren vorstehende \"vier, fünf oder sechs, mehr oder weniger große \"Tuberkeln\" mit denen sie gespickt ist\" hingewiesen wird, deutet am ehesten hin auf Andricus quercustozae, deren auffällige, großen Gallen Reaumur (1737) sonst nirgendwo abbildet. Eine andere Galle wurde später von Hartig (1843: 421) als \"Cynips infectoria\" beschrieben. Terra typica dieser kleineren Galle [Ø 7-15 mm] ist Istrien bzw. Triest (das bis 1918 zu Österreich gehörte). Diese Zweiggalle an Quercus pubescens aus Triest war unter dem Namen „Istrische Galle\" im Handel (GrÄFfE 1905: 20-21: Cynips tinctoria Ol. var. nostra De Stefani).\nDie größere Levante-Galle beschreiben Dalla TorRe \\& Kieffer (1910: 420) als C. gallae-tinctoriae (Ol., 1791), als ,,orientalische oder levantische Galläpfel\", aus West-Asien und Ost-Europa (Ungarn, Türkei, Griechenland) von div. Eichen (Q. aegilops, $Q$ infectoria, $Q$. pedunculata), mit kugeliger Form (Fig. 132-133) und Ø 15-20 mm der harten, schweren Gallen, die ohne Runzeln, mit rundlichen warzigen Erhabenheiten mehr oder weniger besetzt sind (vgl.Abb. XI; 42b).\nDer Beschreibung von C. gallaetinctoriae entspricht auch eine weitere, rezent aus dem nahen Osten (Türkei, Israel und Iran) neu beschriebene\n\nArt, A. sternlichti Bellido et al. 2003, welche Gallen an Quercus infectoria, $Q$ boissieri (= Israelian oak) und Q.komarovii bildet, die nach Größe (Ø 13-20 mm) und Form [Bellido et al. 2003: Fig. 76] weitgehend identisch erscheinen mit gallaetinctoriae. - Von C. gallaetinctoriae (Ol.) sagen Dalla Torre \\& Kieffer (1910: 420): „Galle $15-20 \\mathrm{~mm} \\varnothing$; reift im Herbst, fällt zum größten Teil im Winter ab.\" Analog äußert sich auch BuHR (1965: 939, Nr. 5439) zu A. gallaetinctoriae.\nDie Gallen von A. infectorius (Hartig 1843) [= Cynips tincoria-nostras Stefani 1886], welche Dalla Torre \\& Kieffer (1910: 420-421, Fig. 134-135) als Cynips infectoria Hartig 1843 aus Österreich, Ungarn, Istrien, Süd-Frankreich, Italien, Sizilien und Klein-Asien angeben, mit agamer Gallenbildung an Quercus lusitanica, Q. pedunculata, Q. pubescens und Q. sessiliflora, sind kleiner, nur $7-15 \\mathrm{~mm}$, bräunlichgelb, von groben und unregelmäßigen Runzeln durchzogen, am Grunde etwas verschmälert. Abbildungen der unverkennbaren Galle von A. infectorius (Htg.) sind bei Bernardi et al. (1997: 102-103, 148: Fig. 26A) fälschlich als \"Cynips gallaetinctoriae (Ol.)\" bezeichnet.\nDiese sogen. „Kleine Färbergalle\" wurde erstmals von Th. Hartig (1843: Z. Ent. Germar, p. 421) als C. infectoria Htg. von C. tinctoriae (Oliv.) unterschieden: „Diese neue Eichengalle (C. infectoria ?), welche Herr Professor von Siebold aus Triest erhielt und die besondere Beachtung verdient, ist ähnlich der des levantischen Gallapfels; sie ist regelmäßig kugelförmig, 1/3-2/3 Zoll dick, von sehr festem gerbstoffreichem Parenchym, mit centraler runder Larvenkammer ohne Innengalle; diese Gallen entspringen der Spitze weisswolliger Eichentriebe.\nDer wesentlichste Unterschied dieser Galle von der C. tinctoria ist die Bekleidung mit einer dicken Oberhaut, die nach dem Eintrocknen sich faltig zusammengezogen zeigt.\" Die Größenangaben von Hartig [1/3-2/3 Sachsen-Zoll = 7,8-15,7 mm] entsprechen den Angaben von Dalla Torre \\& Kieffer (1910) für C. infectoria-Gallen [7-15 mm]. Die „kleine Färbergalle\" oder „Istrische Galle\" A. infectorius (Htg.) ist somit deutlich kleiner als die „Levantinische\" oder „große Färbergalle\" A. gallaetinctoriae (vgl. BuHR 1965: 939, Nr. 5438, 5439) dies bestätigen auch Vermessungen für $A$. infectorius aus Südtirol (Grafik 1).\n\n--- Seite 54 ---\nAn pharmako-botanischen Angaben über die „Aleppo-Gallen\" finden sich im Internet folgende: (http://www.pharmakobotanik.de/systematik/ 6droge-f/gallae.html)\nStammpflanze: Quercus infectoria Olivier 1801 (Syn. Quercus lusitanica Webb); wenige Meter hoher Strauch oder Baum: Galleiche; Färbereiche, Gallapfel-Eiche, Levantinische Galleiche.\nEnglisch: Aleppo oak, Asian holly-oak, Gall oak. Verbreitung: Ägäis, Kleinasien, Zypern, Israel, Vorderasien.\nDroge: Die aus den Laubknospen durch Eiablage der Gallwespe Andricus gallae-tinctoriae Oliv. (= Cynips tinctoria Hartig) entstandenen Gallen.\nBeschreibung der Droge: Kugel- oder birnenförmige, sehr harte, spröde, relativ schwere, kurz gestielte, etwas glänzende Gebilde mit einem Durchmesser von 1,5 bis $2,5 \\mathrm{~cm}$. Die obere Hälfte ist sehr unregelmäßig und weitläufig mit spitzigen Höckern und Falten besetzt, die untere häufiger glatt. Das weite Flugloch befindet sich in der Mittelzone. Neben den meist strohgelben bis gelblichroten Gallen mit Flugloch kommen oft auch grünliche ohne Flugloch vor. Die Beschreibung der „ausgesprochen harten, spröden Aleppogallen mit nahezu kugelförmigen Gestalt\" wird illustriert durch 2 Fotos von Aleppogallen [aus dem Hum-boldt-Museum Berlin] von Thomas Schöpke (www. plant-pictures.com) welche gut der Fig. 132 sowie den Größenangaben von Cynips gallae-tinctoriae bei Dalla Torre \\& Kieffer (1910: 420) entsprechen (Abb.42b).\nDrei typische Gallenkugeln (Ø 15-16 mm) solcher „Levantinischen Färbergallen\" befanden sich auch im „Pharmazie-Museum Peer in Brixen\" (Abb. 42) in den dortigen Lagerbeständen zusammen mit vielen Gallen von A. quercustozae, die gelegentlich ersatzweise Verwendung fanden. Im Gegensatz zu den leichten Schwammkugelgallen von A. quercustozae und A. kollari, die im trockenen Zustand nur bis zur Hälfte eingetaucht im Wasser schwimmen, sind die „Levantegallen\" auffallend schwer und versinken im Wasser wie ein Stein.\nFotoabbildungen dieser „türkischen\"- oder „Levantegallen\" (Cynips gallae tinctoria Ol.) finden sich auch bei Schimitschek (1944: Forstinsekten der Türkei und ihre Umwelt: 293, Abb. 210).\n\nGroße Ähnlichkeit mit A. gallaetinctoriae hat die Galle von A. sternlichti Bellido et al. (2003: 214, Fig. 76).\nDie „Levantinischen Färbergalle\" gehört zu den ältesten bekannten Gallen und wurde schon von Theophrastos (ca. 300 v. Chr.) erwähnt (vgl. Abb. XI). Ausführlich über diese \"galle di Aleppo, galle di Smirne, oppure anche galle di Levante, galle turche, etc.\" und ihre frühere Bedeutung als Export und Handelsware berichtet A. Trotter (1904: Alcune notizie sulle noci di galla del commercio. Marcellia, 3: 146-151).\nVon Schimitschek (1944: 292-293) wird als Verbreitung von Cynips gallae-tinctoriae (Ol.) angegeben: Südosteuropa, Anatolien, Südwestasien; in Anatolien sehr häufig. Die Gallwespe ruft die bekannten „Türkischen Gallen\" hervor, hauptsächlich an der strauchartigen „Galleiche\" Quercus infectoria; mitunter aber auch an Q. pedunculata [=Q. robur] und Q. aegilops. - Die „türkische Galle\" oder „Levantegalle\" ist eine Knospengalle, die sich entwickelt aus der Knospenmitte. Der Durchmesser der Galle beträgt $15-20 \\mathrm{~mm}$. Die Galle ist fahlbraun bis fahlgelb, ohne Runzeln, besitzt aber warzige Höckerchen [Abb. 210]. Die Reife der Galle tritt im Herbst ein. - Im alten Orient spielten die Levantegallen eine große Rolle im Wirtschaftsleben, in der Gerberei, in der Heilkunde und der Färberei von Geweben, als Beize und später bei der Bereitung von Tinten. Die „türkische Galle\" war seit jeher wegen ihres hohen Gerbstoffgehaltes sehr geschätzt und ein wirtschaftlich wichtiger Handelsartikel. Die „türkische Galle\" oder „Levantegalle\" bildete auch noch in der ersten Hälfte des 20. Jh., wegen ihres hohen Gerbstoffgehaltes (rd. $60 \\%$ ), einen wichtigen Handels- und Ausfuhrartikel.\nBerichtet wird über diese Galle auch in Encyclopaed. Britannica 1911, $11^{\\text {th }}$ Ed.: \"Common gallnuts\", nut-galls, or oak-galls, the Aleppo, Turkey, or Levant galls of commerce (Ger. Gallapfel, levantische Gallen; Fr. noix de Galle), are produced on Quercus infectoria, a variety of Q. lusitanica, by Cynips tinctoria, or C. gallae-tinctoriae Oliv. Aleppo galls (gallae halepenses) are brittle, hard, spherical bodies, ridged and warty on the upper half, and light brown to dark greyish-yellow within. What are termed \"blue\", \"black\", or \"green\" galls contain the insect; the inferior \"white\" galls, which are lighter\n\n--- Seite 55 ---\ncoloured, and not so compact, heavy or astringent, are gathered after its escape (see Fig. i.).\nAuch Eroglu 2000 [Harvesting of non Wood Forest Products] berichtet über Gallen in der Türkei:\nIn Turkey approximately 20 species of cynipid wasps induce galls on the oaks of Turkey. (Acatay 1943; Schimitschek 1944; Alkan 1952; Karaca 1956; Baş 1973; Ekici 1975; Eroğlu 1977; Çanakçioğlu \\& Mol 1998; Eroğlu 2000). In the last 10 years, the income portion of the gall exportation in Turkey's non-wood forest products has been $0.74 \\%$ on average. This number indicates that, while it has the potential of providing the people living in rural areas and having low life standards with an important source of income, gall production in Turkey is still far from what is expected because of inefficient gall harvesting strategies. The vast majority of oak galls are of no particular economic significance. Because of their high tannin contents, galls of A. gallaetinctoriae and $A$. kollari have been utilized for thousands of years. A. gallaetinctoriae is found over much of Turkey where the two host oak groups occur together naturally in large areas. In gall developing areas, negative effects of human being and grazing have a great role on gall production. Galls collected have not been kept in a close vicinity of woodlands. Early harvest of galls results in not only the loss of crop but also the reduction in the population of the gall wasps. Larval stage is lasted about two months, from early June to late August or to the beginning of September. Gall formation period lasts about from mid June to beginning of July, so immature galls are found from mid-July to early September. Pupation generally begins in mid-August when the color of gall changes from light green to white, and lasts about 15 to 25 days. There is an interaction between the color of gall and the development of the gall wasps in it.\nThe galls which are indigo-blue in color generally include young larvae. The mature larvae can be found in the green or light green galls. White galls include pupae or adults gnawing an exit hole. In the following days, especially after a rain, color becomes reddish. Galls of A. gallaetinctoria are commonly harvested in July and August, when they are indigo-blue or light green. Adult exiting from galls collected in different years and places showed that the adult emerging period begins in\nearly September and lasts until late October (Ekici 1975; Eroğlu 1997). However emergence of adults was not observed in the galls collected before late July. - Walls of mature galls are 5-6 mm in thickness and can not be crushed without a stroke of a hammer. In gall harvesting, the galls collected should be kept in the vicinity of the production area until wasps exit the galls. [Eroglu 2000].\nNeuerdings wurden gesicherte alte Erkenntnisse infrage gestellt. So hatte noch Csóka (1997: 28) in seinem exzellenten Bildband der Gallen Ungarns (Plant galls) geschrieben: \"Galls were also used in the manufacture of writing inks, the most popular species for this purpose being Andr. gallaetinctoriae and Andr. tincoriusnostras. Both of this species have this usage described in their scientific names\". - Im Herbst 2007 teilte Dr. Csóka (Budapest), auf meine Anfrage über die Verbreitung dieser beiden Gallen in Ungarn, dann überraschend mit: \"Andricus gallaetinctoriae (Olivier) is synonym of A. infectorius (Htg.)\". - Nachdem zuvor auch Melika, Csóka \\& Pujade-Villar (2000: 265-296) noch A. gallaetinctoriae (Fig. 21) und A. infectorius (Fig. 58) artlich und gallenmäßig unterschieden hatten, ging dieser Sinneswandel auf eine neuere Arbeit von Bellido, Ros-Farré, Melika \\& Pujade-Villar (2003) zurück, in der \"gallaetinctoriae Oliv.\" zum \"nomen dubium\" erklärt und entsprechende Umbenennungen vorgenommen wurden (p. 193): \"The analysis of galls and adult wasps of the asexual \"Andricus gallaetinctoriae\", collected by authors in Hungary, Romania, and Ukraine, and also material deposited in the HNHM (Budapest) showed, that they all belong to Andricus infectorius. Thus, in many earlier publications they were incorrectly referred to A. gallaetincoriae (Ambrus 1974, Balás 1941, Méhes 1943, Melika et al. 2000 etc.).\"\nDie in der Folge daraus abgeleitete Synonymie \"A. gallaetinctoriae - infectorius\", muss aufgrund der unterschiedlichen Größenverhältnisse der Gallen sowie der nicht übereinstimmenden Phänologie der Gallen als auch der Imagines [vgl. Trotter 1904] äußerst fraglich erscheinen. Die ganze Diskussion und Argumentation, die Bellido et al. (2003) um die Frage aufbauen, ob mit „Levante\"-Aussage von Olivier (1791) nicht vielleicht der „Süden\" Frankreichs gemeint gewesen sein könnte, die letztlich dazu geführt, dass sie \"gallaetinctoriae Oliv.\"\n\n--- Seite 56 ---\nzum \"nomen dubium\" erklärten, ist jedenfalls nicht überzeugend. Vielmehr scheint sicher, dass die echte \"Levantegalle\" A. gallaetinctoriae in Frankreich gar nicht vorkommt [vgl. Kieffer 1901: 566-568] und vermutlich auch nicht in Ungarn.\nZusammenfassend kann man zu den harten, schweren „Aleppogallen\" (A. gallaetinctoriae) sagen, dass ihre Form mehr kugelig ist ( $\\varnothing=15-20-25 \\mathrm{~mm}$ ), ihr Stielansatz nur kurz und ihre Oberfläche $\\pm$ glatt, weitläufig mit Höckern besetzt. Sehr ähnlich die \"light-brown, cream-coloured\" A. sternlichti-Galle, für die als Verbreitung angegeben wird: \"Turkey, Iran, Lorestan, Greece, and probably in Bulgaria\" (in litt. J. PuJADE-VILLAR: 27.09.2007); letztere fehlt in Ungarn (CsóKA: 10.12.2007: \"We do not have A. sternlichti here\") und zweifellos auch in Italien. Im Gegensatz zu gallaetinctoriae-sternlichti stehen die Gallen von A. infectorius ( $=$ Cynips nostras Stefani 1886, = Cynips tinctoria var. nostra Kieffer 1901, = Cynips tinctorianostras Trotter 1903), die ebenfalls sehr hart aber signifikant kleiner sind ( $7-15 \\mathrm{~mm}$ ); ihre Form ist birnen- oder feigenförmig, ihr Stielansatz in der Regel lang und deutlich ausgeprägt (= pedunculatae), ihre Oberflächenstruktur mehr faltig. Wie schon der öfters verwendete Name „nostra\" besagt, hielten die Autoren diese kleinere Galle für eine mehr im südlichen Europa (Balkan, S-Frankreich, Italien, Sizilien) heimische Art.\nNach Trotter (1904: 147) kommt Cynips tinctoria nostras (\"galla d'Istria\") außer in Südeuropa auch im Orient vor. Dabei ist die Terra typica IstrienTriest von A. infectorius (Htg.), von der syrischen Terra typica von A. gallaetinctoriae, Aleppo (Arabic: Halab), über 2000 km entfernt. Wo die Verbreitungsgrenzen bzw. Überschneidungsgebiete dieser beiden Färbergallen effektiv liegen ist derzeit nicht bekannt. Diesbezügliche Verbreitungsangaben aus „Fauna Europaea\" (2007) sind nicht verwendbar, da dort offenbar 2-3 Arten miteinander vermischt sind. Aus Italien sind mir keine A. gallaetinctoriae bekannt, alle so bezeichneten Gallen die mir unterkamen waren A. infectorius oder A. lignicolus.\nAm kompetentesten erscheinen die alten Angaben von Trotter (1904): \"In conclusione, la noce di galla per eccellenza, è quella prodotta dalla Cynips tinctoria, notevole per il suo peso specifico, superiore a quello di qualunque altra galla di Quercus, e per la ricchezza in tannino ( $50-60 \\%$ ). Da sola\nessa costituisce un importante ramo di commercio, nell'Asia minore, nella Siria, nel Kurdistan, nella Mesopotamia etc. In Europa la si riscontra assai di raro (Turchia, Grecia), in Italia non credo sia mai stata positivamente trovata. Ciò malgrado, appunto per la sua importanza industriale, è una galla notissima, descritta e figurata nei trattati più diversi. Chi la vorrà poi vedere, e toccare con mano, potrà trovarla nella Cecidotheca italica (fasc. VIII, n. 177) rappresentata nelle sue 3 varietà commerciali. Questa galla comincia a svillupparsi in primavera e raggiunge la sua maturità in agosto. L'insetto esce dalla fine di agosto alla metà di settembre. La raccolta delle noci di galla ha luogo tra luglio ed agosto, od anche sino a metà di settembre, secondo le località, cosicchè l'insetto ha tutto l'agio di poter uscire.\"\n\"I centri di produzione, in Asia Minore, sono molti e tutti mandano il lor prodotto a Smirne e Trebizonda. Nella Siria, le località che adunano maggior prodotto sono Killis, Aintab, Merasch, di dove poi sono mandate ad Aleppo per essere vendute e quindi ad Alessandretta per essere imbarcate. Nel Kurdistan, le località principali sono Seert, Mardin, Diarbekir, Malatia, Kurkuk. Nella Mesopotamia, sono Urfa (l'antica Edessa), Curguse, Mossul, Baghdad\".\n\"Le vere galle della Cynips tinctoria, di qualità scelta, sono commercialmente suddivise nelle 3 seguenti categorie: Galle nere (Greco: Kekides maurai; Turco: Civat mazi), Galle verdi (Kekides chloroinai; Ghiescil mazi), Galle bianche (Kekides leukai; Behaz mazi). - La varietà del colore dipende dall'epoca in cui se ne fa il raccolto; le nere e le verdi si raccolgono prima della uscita dell'insetto, le galle bianche sono invece quelle raccolte più tardi, quando sono già state abbandonate dal loro produttore. Le più apprezzate sono le galle nere, il cui costo, quando son giunte ad un porto italiano o francese, è di circa 130-135 Lire il quintale.\"\n\n43 Andricus gallaeurnaeformis (Fonscolombe 1832) [= Cynips urnaeformis Giraud 1859, Mayr 1882] [ㅇ= Andricus sufflator Mayr 1882] (sex.)\nVerursacht in der agamen Generation auf der Blattunterseite von Flaumeichen (Quercus pubescens) eine Verdickung der Mittelalter; daraus entspringen seitlich - gruppenweise oder einzeln - kleine olivgrüne Gallen ( $2,5-3,5 \\mathrm{~mm}$ ), länglich-zylindrisch bis eiförmig (oben abgestutzt), anfangs glänzend-glatt,\n\n--- Seite 57 ---\nmeist rot überlaufen, später bauchig mit ausgeprägter Längsrippung („Urnengalle\"). - [BuHR 1965: 958, Nr. 5502; Malpighi 1687: Fig. 20; Reaumur 1737: Pl. 35, Fig. 6-7; Kieffer 1901: 399, A. urnaeformis Mayr; Csóka 1997: 104-105; Nieves-Aldrey 2001: 350, 535; figs. 132 D-F, 140 E]. - Sexualform (A. sufflator Mayr) verursacht kleine, rundliche Parenchymgallen [Buhr 1965: Nr. 5487; Kieffer 1901: 401]. - Von SW-Europa (Spanien, Portugal, Frankreich) über das südl. Mitteleuropa (Österreich, Umgarn) und SE-Europa (Italien, Balkanhalbinsel) bis Ukraine verbreitet; fehlt in Deutschland und England. - In Italien im Norden (Checkl. 1995: Nr. 13/21). Im Triestiner Karst von GrÄFfE (1905: 33-35; Cecidothek FVG) gemeldet: A. urnaeformis - sufflator ist bei Triest nicht häufig anzutreffen; (Funde cit. Tomasi 1996: 29, n. 28; 2006: 22, 67). Für die Region Trentino-Südtirol erstmals neu nachgewiesen: „urnenförmige Gallen\" fanden sich im Trentino bei Pomarolo-Servis, im Monitoring-Areal (IT-04: 700 m ) an wenigen Blättern von Quercus pubescens, am 14.10.2004 (leg. Hellrigl \\& Ambrosi); meist 1-3 Gallen an der Mittelrippe eines Blattes (auch am Blattstiel, nahe der Blattbasis), seltener auf einem Blatt 5-7 Gallen. - Die reifen, harten Gallen werden später rotbraun und lösen sich leicht aus ihrem Ansatzpunkt an der Mittelrippe. Das Blatt krümmt sich an der Befallsstelle einwärts, die Gallen stehen innen im gekrümmten Teil (Abb. 43).\nEinige weitere Gallen fanden sich bei Rovereto-Dossi ( 350 m ) an 3 alten Eichenblättern am 05.04.2005 (leg. Hellrigl); ebendort: am 25.09.2005, 3 Blätter von $Q$. pubescens, mit frischen grünen Gallen (leg. R. Lauterbach, Foto H. Bellmann \\& K. Hellrigl). - In Pomarolo-Servis (IT-04) fanden sich Fundbestätigungen am 14.10.2007, ein Eichenblatt mit 2 kleinen, olivgrünen Gallen (leg. Hellrigl \\& Mörl) (Abb. 43b), sowie am 12.10.2008, drei Blätter von $Q$. pubescens mit mehreren kleinen, frischen, grünen bis roten Urnengallen (leg. Hellrigl \\& Schanung) (Abb. 43c). Keine Nachweise bisher aus Südtirol.\n\n44 Andricus gemmeus (Giraud 1859)\n[= Aphilothrix kirchsbergi Wachtl 1876 ㅇ ㅇ]\nBildet in der agamen Generation an jüngeren Stämmen oder stärkeren Ästen von Eichen (Q. robur, Q. petraea, Q. pubescens) einzeln oder\ngruppenweise rundliche Gallen ( $3-5 \\mathrm{~mm}$ ), die aus schlafenden Augen hervorgehen; bisweilen auch an jüngeren Ästen oder niedrigen Zweigen. Die mit roten, kräftigen Papillen besetzten Gallen ab August, bei Reife im Oktober abfallend [Buhr 1965: Nr. 5421, 5457. Kieffer 1901: 481-483; Pfützenreiter 1958: 109-111, Fig. 23, 23a (A. kirchsbergi $=$ gemmea Gir.). Csóka 1997: 90-91. Melika et al. 2000: 272, Fig. 23]. - Die bisexuelle Generation bildet an Zerreiche ( $Q$. cerris) kleine $\\pm$ kugelige Gallen [3-8 mm] mit verkümmerten Blattschöpfen (Mitt./Foto H. Bellmann); Gallenreife erfolgt im Frühjahr [Buhr 1965: 970: Nr. 5546. Pfützenreiter 1962].\nVerbreitung: Württemberg, E-Österreich, Czech., Ungarn, SE-Europa, Italien. - In Spanien u. Portugal vermutl. mit Q. suber als Zwischenwirt [NievesAldrey 2001: 388-390, 538; Fig. 128 i, i; 143 g]. Checklist Ital. (1995: Nr. 13/22, A. gemmea Giraud) aus Sizilien angegeben (De Stefani); aber auch in Italien-Festland (Trotter). - In FVG eine Angabe aus Triest/Dolina, 23.11.1994 (Tomasi 2006: 68). Rezent erstmals auch im Trentino nachgewiesen: Pomarolo-Servis (IT-04: 700 m ) am 14.10.2007, eine kleine Blattschopf-Galle ( $9 \\varnothing$ ) an Trieben von Quercus cerris, sowie 2 papillöse Gallen ( $\\varnothing 4 \\mathrm{~mm}$ ), an dünnen Zweigen von Q. pubescens (leg. Hellrigl \\& Mörl) (Abb. 44). Hier eine weitere papillöse Zweiggalle ( $\\varnothing 5 \\mathrm{~mm}$ ) an Flaumeiche, am 19.07.2008 (leg. Hellrigl \\& Schanung) (Abb. 44b), sowie am 07.09.08 zwei Zweig Gallen ( $\\varnothing 3-4 \\mathrm{~mm}$ ) in 15 cm Bodenhöhe an Eichenstrauch mit C. cornifexBefall (leg. Hellrigl \\& Mörl) (Abb. 44c). - Neumeldung für die Region.\n\n45 Andricus glandulae (Hartig 1840)\n( $9 \\varnothing=$ A. xanthopsis Schlechtendal 1883)\nBildet in der agamen Generation im Spätsommer an Trieben von Quercus (petraea, pubescens, robur) in Blattachseln $\\pm$ glocken- bis kegelförmige Knospengallen mit abwärts gerichteter samtartiger weißer Behaarung (BuHR 1965: 942, Nr. 5450; T. 15: Fig. 241, 242;), bekannt als „Glocken- od. Eichelgalle\" [\"Thatched gall causer\"]; in der Sexualgeneration ( $=$ A. xanthopsis Schlecht.) unscheinbare eiförmige Gallen an männlichen Blütenständen (Buhr 1965: 965: Nr. 5531). - [Dalla Torre \\& Kieffer 1910: 500, Fig. 256; Pfützenreiter 1958:\n\n--- Seite 58 ---\nNr. 23, Abb. 17; Csóka 1997: 76; Melika et al. 2000: 272, Fig. 24; NieVes-ALdReY 2001: 417, 541; figs. 128 d-e; Redfern et al. 2002: 407, Fig. 694].\nIn Mittel-, West- und Südeuropa verbreitet, aber wenig häufig, lokal vorkommend. Fehlt in Checklist Italiens (1995), wurde aber aus Trentino schon von Cobelli (1903: 165) gemeldet (A. glandulae Schk.). Erstnachweise für Südtirol: Klausen/Gufidaun (730m), 05.09.2005, 1 Galle (long. 8 mm ) an Zweig von Q. petraea, leg./foto K. Hellrigl (Abb. 45). An dieser Traubeneiche fanden sich an Blättern auch Gallen von C. disticha (5), C. quercusfolii (div.), N. anthracinus (div.), A. lenticularis (div.) und an Zweigen A. fecundator (2). - Brixen/Tschötscher Heide ( 730 m ), 14.09.2005, an Q. pubescens eine entwickelte Galle ( 8 mm ) an Endknospe und 3 Gallen unfertig (Abb. 45b), aus Seitenknospen hervorbrechend (leg./foto Hellrigl); eine der Junggallen war am 07.10.2005 voll entwickelt ( 9 mm ); an dieser strauchartigen Flaumeiche vergesellschaftet mit A. solitarius (1), C. disticha (2), C. quercusfolii (div.), N. anthracinus (div.), N. lenticularis (div.), A. fecundator. - Tschötscher Heide ( 750 m ), 20.09.2005, an mannshoher Flaumeiche, 1 Galle ( 8 mm ) an Seitenknospe in Blattachsel, war Anf. Okt. abgefallen.\nNeustift-Schießstand ( 700 m ), 22.10.2005, an Zweigen strauchartiger Eichen (Q. petraea) 2 Gallen: eine von Vogel geöffnet ( 8 mm ), 1 Galle intakt ( 9 mm ). - Weitere Funde: Tschötscher Heide ( 750 m ), 03.09.2006, an Q. petraea, 1 Galle unreif; Neustift (650-700m), 05.09.2006, an Q. petraea, 5 Gallen ( 2 Gallen reif + 3 Gallen unreif). Tschötscher Heide ( $730-750 \\mathrm{~m}$ ), 30.09.2006: 2 Gallen; 10.10.06, 1 Galle (rötlich: Foto). - Neu für Südtirol: 5 Fundstellen mit insgesamt 17 Gallen (leg./ Foto Hellrigl). Die Art scheint gar nicht so selten, doch sind die Gallen schwer zu entdecken (meist an strauchartigen Eichen, mehr im Halbschatten, oft in Sichthöhe) und fallen teilweise schon eher frühzeitig im September ab. - Neu auch für Osttirol: Lienz Umgeb./Nörsach, 16.03.1991, 19 (leg. A. Kofler, vid. Hellrigl).\n\n46 [Andricus glutinosus (Giraud 1859)]\n[= Cynips tergestensis Kieffer 1905, in Gräffe 1905a]\n[nec Cynips glutinosa (Giraud) var., Gräffe 1905]\n\nAgame Generation bildet an Zweigen von Eichen (Q. petraea, pubescens, robur u.a.) urnenförmige, bis 10 mm lange, am Grunde breit aufsitzende, den Zweig seitlich $\\pm$ umfassende einzellige Gallen; frisch gelb bis rot und klebrig; Reife im Herbst, Wespe im Frühjahr. - [H. BuHR 1965: 943: Nr. 5454. Csóka 1997: 96-97. Melika et al. 2000: 272, Fig. 25. H.-J. BuHR 2007: Burgenland, 04.06.2005]. - Verbreitung: Österreich, Ungarn, Tschechien, SEEuropa. - In Checklist Ital. (1995) doppelt angeführt: (Nr. 20/12, Cynips glutinosa Giraud 1859, N-Italien u. Sizilien; Nr. 20/23, Cynips tergestensis Kieffer 1905, aus N-Italien: [Triest = Tergestina]). - Nahe bei Triest fand E. GrÄFfE (1905a: 370, C. tergestensis Kieffer) die Wespen, die Kieffer für eine neue Art hielt und beschrieb, im März 1904 fertig in den Gallen vor, sehr lokal bei Glanz, in Lokalität Bubna. - In einer vorhergehenden Arbeit hatte E. GrÄFfE (1905: p. 16, C. glutinosa Giraud; Taf. I, n. 2) schon über \"C. glutinosa\" berichtet, deren Gallen sich bei Triest nur sehr vereinzelt an den Eichen des Karstes finden; doch war damit, wie GrÄFfE (1905: 17) präzisiert, die \"Varietät coronata Mayr\" gemeint, die er bis dahin allein bei Triest vorfand, und die heute als eigene Art gilt [vgl. Nr. 34 Andricus coronatus Gir.]. Später von TOMASI (2006: 72-73) als Cynips glutinosa Gir. bzw. C. tergestinus Kieff. aus Triest Umg. ( 500 m ) genannt.\nFrüher wurde \"Cynips glutinosa\" als Art mit 3 Varietäten aufgefaßt und abgebildet [vgl. Abb. Nr. 34: Henschel 1888: Taf. I, Fig. 9]. Die Bezeichnung \"glutinosa\" weist auf die klebrige Oberfläche dieser Gallen hin. - In Mitteleuropa angeblich verbreitet und oft häufig; von hier noch nicht bekannt.\n\n47 Andricus grossulariae Giraud 1859 98 [see $57=$ Andricus mayri (Wachtl 1879)]: agam\n\nVon A. grossulariae war bis vor kurzem nur die Sexualgeneration bekannt, die an männlichen Blütenständen von Quercus cerris (in Sizilien und Spanien an Q. suber) gehäuft vorkommende, auffällige rote, kugelige Gallen ( $\\varnothing 5-6 \\mathrm{~mm}$ ) erzeugt, die an Johannisbeeren erinnern: \"Johannisbeergallen\". [Buhr 1965: Nr. 5608; T. 18, Fig. 305; Pellizzari 1988: 121; Csóka 1997: 118; Melika et al. 2000: 272, Fig. 26; NieVes-ALdReY 2001: 409, 540; figs. 122A, 144F; Redfern et al 2002: 415, Fig. 725].\n\n--- Seite 59 ---\nErst kürzlich wurde als zugehörige agame Form Andricus mayri (Wachtl) identifiziert (Walker 2002: cit. British Plant Gall Society, Redfern et al. 2002: 415); [vgl. Fauna Europaea: database 2007]. In Checklist Ital. (1995: Nr. 13/27) wird diese bisexuelle Form aus Sizilien und N-Italien angegeben, ebenso wie die agame Form [A. mayri Wachtl], die noch als eigene Art geführt wird (1995: Nr. 13/37). In Sizilien fand De Stefani (1897: 169) A. grossulariae an Korkeiche (Q. suber) ,,Le vecchie galle ho trovato comunissime su tutti i sugheri di quella contrada, una grande quantità era caduta al suolo\" - hingegen nennt er von dort die [zugehörige] agame Galle von Andr. mayri nur von Q. robur (p. 166). Vom Triestiner Karst werden A. grossulariae-Gallen bereits von GrÄFFE (1905: 61, Nachtrag) erwähnt, später von Tomasi (1996: 29, Nr. 30; 2006: 68, Cecidothek) mehrfach an Quercus cerris gemeldet. Nach Bernardi et al. (1997: 164) sind „Johannisbeergallen\" auch aus Toskana, Latium, Apulien (Gargano: Foresta Umbra) sowie Trentino-Südtirol bekannt.\nIn unserer Region vorerst nur im Trentino (Rovereto Umg.) beobachtet. - Rezent bei PomaroloServis (IT-04: 700 m ), am 28.10.2007, 5 Gallen (Ø 6 mm ) an vertrockneten Eichel-Fruchtbechern von Zerreiche (Abb. 47) (leg. Hellrigl \\& Mörl). - Im Gegensatz zu anderen Gallwespen, welche im Frühjahr weißliche beerenförmige Gallen an männl. Blütenständen von Eichen bilden (die bald wieder abfallen, wie A. quercusbaccarum), werden die anfangs (ab Mitte Mai) roten Beerengallen von A. grossulariae später braun und verholzen und bleiben auch nach dem Ausfliegen der Imagines im Juni oft noch lange am Baum. Im Frühjahr 2008 konnten wir diese Gallen bei Pomarolo aber nicht finden: am 25.April hatten die Zerreichen noch keine Blätter oder Blüten ausgetrieben; im verregneten Mai konnte nicht kontrolliert werden und am 2. Juni fanden sich keine Blütenkätzchen mehr. Die kugeligen Gallen sind in einer konischen Spitze ausgezogen, an deren Ende sich eine runde Öffnung befindet (Abb. 47b).\n\n48 [Andricus hartigi (Hartig 1843)]\n[= Cynips Hartigii Kollar (in litt.) Hartig]\nVerursacht in der agamen Generation an Ästen von Eichen (Quercus petraea, Q.pubescens, Q. robur)\nkugelige Gallen, deren äußere Oberfläche von vielen gestielten, pyramidenförmigen, am Ende deutlich zugespitzten Fortsätzen gebildet wird, die den inneren etwa erbsengroßen Gallenkörper verdecken. Das insgesamt bis walnußgroße, graue, morgensternartige Gebilde ( $\\varnothing 15-30 \\mathrm{~mm}$ ) erinnert an eine exotische Frucht (Abb.48a,b). Hartig (1843: 404) vergleicht die Galle (Ø über 1 Zoll = 2,5-3 cm) mit dem Zapfen von Cupressus. Hartig (1843) hatte die Art beschrieben als \"Cynips Hartigii Kollar (in litt.)\": unter diesem Namen erhielt er die Wespe und deren schön gebauten Gallenwuchs durch Mittheilung des Herrn Kollar (Wien), welcher sie an Aesten der Quercus sessiliflora entdeckte.\nGallen von Mai bis Winter, nicht abfallend, Wespen im Frühjahr. [vgl. Buhr 1965: 932, Nr. 5419. Csóka 1997: 92/93. Melika et al. 2000: 272, Fig. 27. Pellizzari 1988: 103]. Bernardi et al. 1997: 212213, Fig. 53 u. Pl. c.59: F. Redi (Abb. 48a). Kieffer 1901: 529-530, Pl. X, Fig. 6, Cynips hartigi Htg. (Abb. 48b). - Verbreitung: Österr., Czech., Slovakai, Ungarn, SE-Europa, Ukraine.\nCheckl. Ital. (1995: Nr. 13/28) N-Italien, Sizilien. Pellizzari (1988: 27) Foresta Umbra, 1986. Zapparoli (1997: 316) Mittelitalien: \"Insetti di Roma\", Orto Botanico (Villa Corsini). Bernardi et al. (1997: 212): Friaul-V.G., Toskana, Latium, Sizilien. - FVG: im Triestiner Karst und den Karnischen Voralpen von GrÄFfE (1905: 13-15: in Istrien bei Volosca) und Tomasi (1996: 30, Nr. 31; 2006: 20, 68) gemeldet. - Ist im Zusammenhang mit Zerreiche auch im Trentino zu erwarten. - Die ähnliche, halb so große Galle von A. truncicolus (Nr. 71) wurde hier bereits rezent nachgewiesen.\n[00] [Andricus hispanicus (Hartig 1856)]\n[= Cynips kollari minor Kieffer 1900]\nVikariierende Art zu Andricus kollari; vertritt diese auf der Iberischen Halbinsel (Spanien, Portugal) und in Südfrankreich (Bellido et al. 2003: 194195; Pujade-Villar et al., 2003) und verursacht identische Kugelgallen. - Von manchen Autoren nur als ssp. von A. kollari betrachtet [Kieffer 1901: 570, Pl. X, Fig. 6, Cynips kollari var. Minor Kieff. - Dalla Torre et Kieffer 1910: 419, Fig. 127B, 128-129, C. kollari minor. - Nieves-Aldrey 2001: 395, 539]. - Als Zwischenwirt der sexuellen Generation tritt anstelle der in diesen Gebieten in\n\n--- Seite 60 ---\nSW-Europa fehlenden Zerreiche ( $Q$. cerris) die dort verbreitete Korkeiche (Quercus suber) [vgl. auch Abb. I und II].\n[48c] [Andricus hungaricus (Hartig 1843)]\nBildet in der agamen Generation an vorjährigen Trieben von Stieleichen (Q. robur) große Kugelgallen (bis 40 mm ) mit höckeriger Oberfläche und einer kleinen losen Innengalle (ähnlich wie bei $A$. quercustozae und A. quercuscalicis). Die Galle reift im Herbst und fällt ab, die Wespe (Weibchen) schlüpft erst im folgenden Frühjahr, im Febr./März. Artbeschreibung von Hartig (1843: 403) nach 2 Gallen von Q.pedunculata [= robur] aus Ungarn, übersandt von Kollar, und der daraus gezogenen Wespe.\nDie wärmeliebende Art ist in Ungarn („Große ungarische Galle\") und Südost-Europa verbreitet [BuHR 1965: Nr. 5440; Zahradnik 1985: 80, Fig. 2-3; Csóka 1997: 94; Melika et al. 2000: 272, Fig. 28]. Kieffer 1901: 552, Cynips hungarica Htg., Pl. XII, Fig. 8 (Abb. 48c). - Vereinzelt in Niederösterreich, Ungarn und Czechien. - Fehlt nach Checklist Ital. (1995) in Italien, wird in Fauna Europaea (2007) aber für Italien angegeben, was allerdings sehr fraglich erscheint.\n[49] [Andricus hystrix Trotter 1897] Kieffer 1897 In der agamen Generation Gallen an Seitenknospen der Zweige strauchartiger Eichen (Quercus petraea, Q. pubescens, Q. robur, Q. cerris), besonders an bodennahen Trieben. Der kleine kugelige Gallenkörper mit zahlreichen spitzen, 3-4 mm langen Fortsätzen bedeckt; Gesamtdurchmesser 1 cm . - [Dalla Torre \\& Kieffer 1910: 500, Fig. 259; Pellizzari 1988: 104; Csóka 1997: 86/87; Melika et al. 2000: 272, Fig. 29]; [vgl. H. Bellmann Foto 2006].\nVerbreitet in SE-Europa (Ungarn, Rumänien, Balkan, Italien), sporadisch in Mitteleuropa; fehlt in Deutschland, Österreich, Spanien. - In N-Italien (Checkl. 1995: Nr. 13/29); bei Mailand, Verona (Dalla Torre \\& Kieffer 1910). FVG: vom Triestiner Karst von GräffE (1905: 61, Nachtrag) gemeldet und mehrfach belegt (Cecidothek FVG); cit. Tomasi (1996: p.30-31; p.94; 2006: 22, 68). - Vorkommen im Trentino sind zweifellos zu erwarten.\n\n50 Andricus infectorius (Hartig 1843)\n\n- kleine Färbergalle, \"Istrische Galle\"\n\nSyn.: Cynips tinctoria-nostras Stefani 1886 [Kieffer 1901]\n[= A. gallaetinctoriae auct., nec (Olivier)]: vgl. Nr. 42 Verursacht in der agamen Generation an Eichenzweigen (Q. pubescens, Quercus petraea, Q. robur) an Seitenknospen kleine kugelige, $\\pm$ konisch gestielte Gallen (Ø 8-15 mm), mit unregelmäßigen, groben, höckerigen Runzeln, der Form nach einer Feige oder Birne ähnlich: „Istrische Färbergalle\" (Abb. 50). Larvenkammer groß, zentral, rund-oval quer, $4.2 \\times 5.5 \\mathrm{~mm}$, mit heller harter Schutzschicht (diese mit dem braunen, harten Gallengewebe verwachsen); Ausflugloch der Wespe seitlich, relativ groß. - Diese sogenannte „Kleine Färbergalle\" wurde von Forstrat Th. Hartig (1843: Ztschr. Ent. Germar, p.421) als Cynips infectoria beschrieben und von C. tinctoriae (Oliv.) unterschieden. Spätere Beschreibungen der Galle sind auch eher dürftig (Kieffer 1901: 567-568; Dalla Torre \\& Kieffer 1910: 420; Buhr 1965: 939, Nr. 5438) weshalb die Unterscheidung gegenüber A. gallaetinctoriae (Oliv.) [„Färbergalle od. Levantinische Galle\"], mit größeren Gallen (Ø 15-20 mm), ohne Vergleichsmaterial schwierig ist.\nSexualgeneration ist offenbar an Zerreiche ( $Q$. cerris) gebunden und verursacht dort kleine eiförmige Kätzchengallen (Melika, Csóka \\& Pujade-Villar 2000: 273). Als zugehörige Sexualgeneration der agamen A. infectorius hatte bereits Beyerinck (in: Dalla Torre \\& Kieffer 1910: 421) vermutete: „Andricus burgundus Giraud 1859 ㅇ. ${ }^{\\text {® }}$, , mit Kätzchengallen an Q. cerris/suber (Buhr 1965: 987). Die Beziehung zu A. burgundus wurde neuerdings infrage gestellt (Stone \\& Cook 1998; Bellido et al. 2003: 199). Nach neuen Erkenntnissen (Stone et al. 2007) handelt es sich bei A. burgundus um eine morphologisch nicht unterscheidbare \"sexual adult morphospecies\", als deren Pendants mehrere agame Andricus-Arten in Betracht kommen (aus dem Andricus hartigi- und coriarius-clade, hingegen nicht aus dem Andricus kollari-clade, zu dem auch A. infectorius gehört).\n\nAls Verbreitung von $A$. infectorius wird allgemein angegeben SE-Europa (Balkan: Kroatien, Jugoslavien, Griechenland, Rumänien; sowie Italien, Sizilien) und das östliche Mitteleuropa (Österreich,\n\n--- Seite 61 ---\nUngarn, Slovakei, Tschechien, Polen, Ukraine) sowie Kleinasien; sie fehlt in SW-Europa (Spanien, Portugal) und Britannien, wird aber aus Süd-Frankreich genannt. Nach Kieffer (1901: 567-568) war die südeuropäische Cynips tinctoria-nostra De Stef. [nomen nudum] (= Cynips infectoria Htg.), bekannt aus Sizilien (durch De Stefani), aus Norditalien als \"Galle d'Istrie\" (Hartig und Trotter), aus Südfrankreich (De Fonscolombe) und aus Niederösterreich (Mayr, Wachtl). Nach Trotter (1904: 147) kommt Cynips tinctoria nostras (\"Galla d'Istria\") auch im Orient vor.\nIn Checklist Ital. (1995: Nr. 13/30) für N-Italien angeführt; von Bernardi et al. 1997: 102, Fig. 4; 148, Fig. 26A (fälschlich als Cynips gallaetinctoriae) aus Sizilien u. N-Italien genannt, aus Toskana (Pisa) abgebildet. - FVG: im Triestiner Karst von GrÄFFE (1905: 20-21, C. tinctoria var. nostra De Stefani) gesammelt; unter dem Namen „Istrische Galle\" im Handel. (vgl. Tomasi 1996: 37, n. 46; 2006: 68; Andricus tinctoriusnostrus, Syn.: Cynips tinctoria Oliv. var. nostra $=$ Cynips infectoria Htg.): ,,galla globosa di 10-15 mm di diametro con protuberanze irregolarmente distribuite sulla superficie.\"\nRezente Artnachweise auch für Südtirol und Trentino.\n\n## Beschreibung und Form der Gallen:\n\nHartig [1843: 421], der die Galle durch Prof. von Siebold aus Triest (Locus typicus) erhalten hatte, beschreibt Cynips infectoria als regelmässig kugelförmig, 1/3-2/3 Zoll dick $[=7,8-15,7 \\mathrm{~mm}]$, von sehr festem gerbstoffreichem Parenchym, mit centraler runder Larvenkammer ohne Innengalle. Als wesentlichsten Unterschied dieser kleineren Galle von der C.tinctoria, bezeichnet Hartig \"die Bekleidung mit einer dicken Oberhaut, die nach dem Eintrocknen sich faltig zusammengezogen zeigt.\"\n\nEine völlig übereinstimmende Beschreibung liefert später aus Triest auch GrÄFFE (1905: p.20-21, Cynips tinctoria Ol. var. nostra Destefani $=$ Cynips infectoria Htg.) von dieser im Handel als „Istrische Galle\" bekannten Art: „Die Galle, aus Seitenknospen von Quercus robur und pubescens entstehend, ist rundlich, beerenförmig, gegen den Ansatzpunkt stark verschmälert, wodurch die Galle birnenförmig wird. Anfangs grün, glatt, wird die Galle bald holzig,\nvon gelbroter Farbe, während ihre Außenfläche sich unregelmäßig runzelt, auch stärker hervortretende Falten und einzelne kleine Höcker zeigt.\nDie geringere Größe (vgl. Grafik 1), der birnenförmige Habitus sowie die faltige Oberflächenstruktur der Galle sind die drei Hauptmerkmale, die auch bei den hiesigen $A$. infectorius am meisten auffallen. Diese Übereinstimmung mit den Triestiner Gallen von Th. Hartig lässt keine Zweifel offen, dass es sich hierbei um dieselbe Galle handelt. Dies wird noch unterstrichen durch weitere Befunde, bei denen eine Reihe südlicher Arten, welche in Triest bzw. im Hinterland in Istrien an Eichen vorkommen, wie die von Hartig (1843) ebenfalls von dort beschriebenen: A. coriarius (Htg.), A. caputmedusae (Htg.), A. infectorius (Htg.), \"Cynips argentea Htg.\" (= A. quercustozae), oder den von Dalla Torre (1892) aus Istrien erwähnten Andricus lignicolus (Htg.), ebenso wie den aus Istrien bekannten A. conificus (Htg.) und A.truncicolus (Giraud), inzwischen sämtliche auch aus dem Südtiroler Unterland bzw. Trentino nachgewiesen sind.\nDie Gallen von $A$. infectorius finden sich häufig vergesellschaftet mit solchen von Andricus kollari, von denen sie sich durch ihre Runzelung, eine meist deutlich gestielte Feigenform und die geringere Größe ( $8-15 \\mathrm{~mm}$ ) unterscheiden. Die Galle von $A$. infectorius (Htg.) lässt sich leicht als „Feigengalle\" charakterisieren, da sie mit ihrem in der Regel gestielten, konischen Gallenfuß einer Feige ähnelt (Abb.50). Die Gallen sind anfangs (Ende Juni/Anf. Juli) hellgrün (Abb. 50a), ab Mitte August werden sie gelbbraun, mit helleren oder dunkleren runzeligen Leisten und Höckern besetzt; alte (oft sehr harte) Gallen sind rostrot bis dunkelbraun und verbleiben - entgegen Literaturangaben - auch nach dem Winter oft noch jahrelang am Baum. Die Oberfläche solcher alten schwarzbraunen Gallen ist kaum mehr runzelig und ihre Form regelmäßiger kugelig, als jene der mit ihnen an denselben Zweigen vorkommenden frischen, hellbraunen Gallen. Dieser Unterschied im Aussehen der beiden Gallenformen kommt durch natürliche Quellung alter Gallen an den Zweigen im feuchten Herbst- und Winterwetter zustande. Das von Hartig (1843: 421) beschriebene „faltige Zusammenziehen der Oberhaut\" frischer Gallen läßt sich - wie Versuche ergaben - durch Quellung trockener Gallen\n\n--- Seite 62 ---\nim Wasser wieder teilweise rückgängig machen, wobei die Gallendicke um rund 1 mm zunimmt (Abb. 50c).\n\nDer von Hartig (1843) bei Beschreibung seiner „Istrischen Galle\" vergebene Artnamen \"infectoria\" ist sehr unglücklich gewählt, da irreführend. Diese Istrische Galle findet sich in SE-Europa vornehmlich an Flaumeiche, Quercus pubescens, und hat hier mit der echten Galleneiche, Quercus infectoria Olivier 1801, offenbar kaum zu tun. Vielmehr ist die klassische, nahöstliche, immergrüne Galleiche (Gall oak, Asian holly-oak, Cyprus oak, AleppoEiche, etc.) Quercus infectoria die Stammpflanze der \"Levantinischen Färbergalle\" oder \"Aleppogalle\" Cynips gallaetinctoriae (Olivier 1791). Die Verbreitung von Quercus infectoria erstreckt sich vom östlichen Mittelmeergebiet (Griechenland, Türkei, Zypern, Israel, Jordanien, Libanon, Syrien) über Armenien und den Irak bis zum Iran. - Hingegen hatte Hartig (1843: 421) von seiner Cynips infectoria geschrieben: \"Diese Gallen entspringen der Spitze weisswolliger Eichentriebe, deren Art ich nicht näher zu bestimmen vermag.\" [N.B.: dabei handelt es sich zweifellos um die in Triest/Istrien in den Karstdolinen verbreitete \"Wolleiche\" oder Flaumeiche, Quercus pubescens (vgl. GrÄFFE 1905)].\n\n## Vorkommen und Erscheinungszeit:\n\nIn Südtirol wurde A. infectorius erstmals 2005 im Eichenhain von Castelfeder bei Auer-Montan von mir nachgewiesen ( $350-400 \\mathrm{~m}$ ). Hier fanden sich Gallen in Anzahl an Flaumeichen, vergesellschaftet mit Kugelgallen von Andricus kollari, in näherer Umgebung einer einzelnen alten Zerreiche.\nAm 28.04.2005 wurden 30 ältere Gallen (Ø 1013 mm ) mit Flugloch gesammelt, sowie 2 frischere, vorjährige Gallen mit Ø 15-15.5 mm (Abb. 50d); weitere alte Gallen wurden am 12.05.2005 gefunden (leg. Hellrigl \\& Fostini). Erst Anfang Sommer, am 07.07.2005, fanden sich frische, grünliche Gallen von $A$. infectorius ( $\\varnothing$ 8-11 mm) an den Zweigen, vergesellschaftet mit größeren frischen, schon hellbraunen Gallen von A. kollari. In den kollari-Gallen waren bereits Puppen vorhanden, hingegen fanden sich in den infectorius-Gallen erst halbwüchsige Larven, von denen bei Weiterzucht (infolge Austrocknung) nur wenige zum Schlüpfen\nkamen. Einen Monat später, am 10.08.2005 fanden sich in den inzwischen gereiften „Feigengallen\" von $A$. infectorius bereits fertige Puppen. Die Gallen waren zahlreich vorhanden an den älteren und auch jüngeren Flaumeichen; an einem einzigen Zweig ( $\\varnothing 1 \\mathrm{~cm}$ ) von 1 Meter Länge fanden sich 20 frische und 7 alte infectorius-Gallen. Von Eichenzweigen wurden an die hundert reife infectorius-Gallen gesammelt; in Freilandzuchtkäfigen schlüpften daraus vom 12.08.-17.09.2005 die Gallwespen, mit Schlüpfmaximum vom 25.08.-11.09.2005 ( 79 von 90 Ex ). Auch am Boden lagen unter einigen Eichen zahlreiche Gallen, die durch Vögel (vermutlich Kleiber - Sitta europaea) geöffnet waren; es wurden 340 dieser aufgehackten Gallen gesammelt (Abb. XXI: Fig. 7-10).\nWeitere Gallen von $A$. infectorius wurden in Castelfeder in den zwei Folgejahren 2006/07 beobachtet. Am 24.09.2006 fanden sich zahlreiche infectoriusGallen an den Eichen; von 128 gesammelten diesjährigen Gallen waren bereits 106 geschlüpft ( $82,8 \\%$ ) und 22 noch nicht, da wohl parasitiert ( $17,2 \\%$ ). Es wurden 100 diesjährige Gallen (mit Flugloch) vermessen (Ø 9-14 mm) (vgl. Grafik 1).\nEbenso wurden am 16.09.2007 in Castelfeder überall an Eichen $A$. infectorius-Gallen gefunden, etwas weniger zahlreich als im Vorjahr; 105 Gallen wurden vermessen (vgl. Grafik 1). Am Probebaum Nr. 1 fanden sich am Boden 15 Gallen (von Vögeln aufgehackt) und an den Zweigen 35 frische Gallen (18 mit Flugloch - 17 ohne Flugloch); auch an anderen Bäumen überall zu finden (insgesamt wurden 54 Gallen gesammelt: 24 mit Flugloch - 30 ohne Flugloch). Die Parasitierung war höher als in den Vorjahren: bei den geschlüpften 42 Gallen ( $=47 \\%$ ) waren viele Ausfluglöcher kleiner (von Parasitoiden oder Inquilinen), daneben auch ein hoher Anteil noch nicht geschlüpfter Gallen ( $47=53 \\%$ ).\nDieser Trend einer zunehmenden Parasitierung setzte sich in Castelfeder auch im Jahre 2008 fort. So wurden bei einer Abschlusskontrolle nach Saisonsende am 19.10.2008 40 diesjährige Gallen von A. infectorius gesammelt, davon waren: mit großem Flugloch regulär geschlüpft $6(15 \\%)$, mit kleinerem Flugloch durch parasit. Metastigmus $9(22 \\%)$, mit sehr kleinem Flugloch von Inquilinen 5 (13\\%), ohne Flugloch ungeschlüpft $20(50 \\%)$; bei letzteren handelt es sich wohl um parasitierte Gallen.\n\n--- Seite 63 ---\nDieser herbstliche Freilandbefund entsprach den Zuchtergebnissen von Castelfeder im Sommer 2008: hier waren am 22.06.08 an vielen Eichen hellgrüne Junggallen $(\\varnothing=8-11 \\mathrm{~mm})$ beobachtet worden, doch war der Besatz wenig gehäuft. Die Vermessung einiger gesammelten Gallen ergab $(\\varnothing \\times \\mathrm{H}): 8 \\times 10 \\mathrm{~mm} ; 9 \\times 10 ; 10 \\times 11 ; 10 \\times 11$; $10,5 \\times 12 \\mathrm{~mm}$; einige Gallen befanden sich bereits in der grün-braunen Verfärbungsphase (Fotos); alle gesammelten unreifen Gallen schrumpften bald ein und starben ab. Am 17.08.08 wurden weitere 102 diesjährige Gallen gesammelt (teilweise noch grün und glatt, teilweise schon hellbraun und faltig) sowie zum Vergleich 42 alte vorjährige Gallen. Die glatten grünen Gallen (Fotobelege) schrumpften innerhalb eines Tages stark ein und bildeten die typische faltige Oberfläche.\nEine Endkontrolle dieser 102 infecorius-Gallen vom 17.08.08 aus Castelfeder ergab im Oktober 2008: regulär geschlüpft 12 ( $12 \\%$ ), parasitierte Gallen geschlüpft 36 ( $35 \\%$ ), Gallen ungeschlüpft 54 (53\\%). Dieses Zuchtergebnis vom Sommer 2008 entspricht voll und ganz der Freilanderhebung im Herbst. Die Vergleichsanalyse mit 42 alten Gallen des Vorjahres (gesammelt am 17.08.08) ergab bei diesen: geschlüpft $50 \\%$, parasitiert $43 \\%$, ungeschlüpft $7 \\%$. - Die Hauptparasitoioden waren, ähnlich wie bei Andricus kollari: Ormyrus sp. und Megastigmus sp., sowie als Inquilinen Synergus umbraculus.\nBei dieser Art hat sich somit eine interessanter Wandel vollzogen: während im 1.Jahr 2005 der weit überwiegende Mortalitätsfaktor von infecto-rius-Gallen räuberische Vögel waren, hingegen Parasitierung kaum ins Gewicht fiel, mit einer regulären Schlüpfrate gesammelter Gallen von rd. $90 \\%$, schien es jetzt umgekehrt. Es steht fest, dass die Parasitierung rasant zugenommen hat; warum andererseits die räuberische Tätigkeit der Vögel abgenommen hat ist unklar. Es wurde aber auch beobachtet, dass an manchen Zweigen mit Gallenbesatz im Juni (Fotos), sich im August keine Gallen mehr fanden.\nWeit seltener als im Südtiroler Unterland bei Castelfeder war A. infectorius im Trentino vertreten. Hier wurden bei Rovereto-Dossi, im „Bosco della città\" ( 350 m ), erstmals am 25.09.2005 einige diesjährige Gallen von A. infectorius an Flaumeichen\n\n- in Nähe von 2 Zerreichen - gefunden (10 Ex. leg. Irene Bellmann \\& K. Hellrigl), davon 5 bereits mit Wespenflugloch. Weitere 7 Gallen ( $\\varnothing 10.5$ bis 12.5 mm ) fanden sich hier am 03.10.2007, davon 5 mit frischem Ausflugloch sowie einige noch ungeschlüpfte Gallen aus denen am 25./26.05.2008 $5 \\varnothing$ der Inquiline S. reinhardi schlüpften. Auch in Pomarolo-Servis wurden am 14.10.2007 an Eichenzweigen 2 Gallen (mit Flugloch) gefunden (leg. Hellrigl).\nIm Sommer 2008 ergaben sich noch folgende Befunde für A. infectorius: Pomarolo, 19.07.2008, wenige kleine Kugelgallen (grün); weiters 27.07.2008: 7 kleine Kugelgallen (grün) gesammelt ( $D=8,9,10$, $11,11,13,14 \\mathrm{~mm}$ ); 07.09.2008: 13 Gallen (schlüpfreif); 12.10.2008: 7 Gallen, davon eine verwachsen mit einer Galle von A. lignicolus (Abb. 54b1), 5 Gallen ungeschlüpft, 2 Gallen geschlüpft. - Schließlich fanden sich auch in Brixen (nördl. Eisackufer), am 04.08.2008, an den Zweigen von im Mai d. J. frisch angepflanzten, aus Veneto (Bassano) importierten, 6 m hohen Stieleichen (Q. robur), neben diversen alten auch einige frische, noch grüne infectoriusGallen (leg. Hellrigl \\& Mörl).\nDie hier und im folgenden Abschnitt näher erörterten kontroversen Angaben zum Bau der Gallen sowie die unterschiedlichen Angaben diverser Autoren zur Phänologie ihrer jeweiligen \"A. infectorius\" sind wohl Hinweise, dass damit verschiedene Arten gemeint sein müssen. Die mehrfach geäußerte Aussage einiger namhafter Autoren, betreffend Ungarn: \"Galls mature in October and fall from the tree in winter (Ambrus 1974); according to the studied material, adults emerge in the next spring\" (BELLIDO et al. 2003: 199); bzw. \"The unisexual galls [A. infectorius (Hartig 1843)] mature in October, the adults overwinter in galls and emerge following spring\" (Melika, Csóka, Pujade-Villar 2000: 273) - trifft jedenfalls für echte \"Istrische\" A. infectorius-Gallen [= \"Triestiner Galle\" gemäß der Beschreibung Hartig (1843: 421)] für Südtirol-Trentino nicht zu. Auch Csóka (briefl. 2007) bestätigt auf Anfrage: In Hungary most of the A. infectorius emerges in spring.\nIm Gegensatz dazu liegt in Südtirol-Trentino die Erscheinungszeit der A. infectorius im Spätsommer: Mitte Aug. bis Mitte/Ende September. In Südtirol-Trentino sind bei $A$. infectorius die Gallen\n\n--- Seite 64 ---\nAnf. Juli noch unausgewachsen und grün, mit halbwüchsigen Larven. Anf. August sind die Gallen ausgewachsen und hellbraun, bereits mit Puppen; Schlüpfen der Gallwespen 12.08.-17.09.2005, mit Schlüpfmaxiumum vom 25.08.-11.09.2005 ( 79 von $90 \\square$ ); Ende Sept. waren die meisten Imagines geschlüpft ( $82,8 \\%$ ). Die Gallengröße liegt bei (Ø 8 - 16 mm ). Auch im Jahre 2006 waren hier von den zu Herbstbeginn, am 24.09.2006, gesammelten 128 diesjährigen Gallen 106 schon geschlüpft $(82,8 \\%)$ und die 22 ungeschlüpften Gallen waren parasitiert ( $17,2 \\%$ ). Dasselbe Bild ergabe sich in den Folgejahren, wo Ende September nur mehr bereits geschlüpfte diesjährige infectorius-Gallen gefunden wurden, oder aber ungeschlüpfte mit Parasitoiden besetzte, welche als Larven überwinterten.\n\nDie fast anhaftenden Gallen fallen im Winter nicht vom Baum ab, sondern verbleiben in der Regel mehrere Jahre an den Zweigen, außer sie werden vorzeitig von räuberischen Vögeln abgeschlagen und geöffnet, dann oft massenhaft am Boden unter Eichen. (siehe: Nr. 50 A. infectorius). Es besteht der Verdacht, dass es sich bei einigen der angeblich erst im \"Oktober\" reifenden und im Winter abfallenden \"infectorius-Gallen\" (mit Wespenschlüpfen im \"Frühjahr\") - in Wirklichkeit um Verwechslung mit A. lignicolus handeln könnte!\nIm Gegensatz zu A. infectorius und zu A. gallaetinctoriae, welche beide früh reifende Gallen sind, d.h. grüne Färbung im Frühsommer, Gallenreife und Wespenschlüpfen im Aug./Sept., ist die \"Holzkugelgalle\" von A. lignicolus eine jahreszeitlich späte Galle - d.h. grüne Färbung Mitte Aug. bis Mitte Okt., Gallenreife Mitte/Ende Oktober. Die jahreszeitlich späte Reife der Gallen im Okt. stimmt überein mit den Angaben von Dalla Torre \\& Kieffer (1910: 420). Die Überwinterung (als Larve) erfolgt immer in den Gallen, das Schlüpfen der Wespen im nächsten Frühjahr erfolgt von Ende Mai bis Ende Juni. Die lignicolus-Gallen (besonders parasitierte) haben ähnlich A. infectorius-Gallen oft eine stark runzelige, mehr buckelige bis warzige Oberfläche; im Gegensatz zu infectorius-Gallen sind sie aber nur mit einem kurzen und locker sitzenden Stiel am Zweig befestigt und fallen leicht ab.\n\n## Analyse zum Bau der Gallen:\n\nDie Galle besteht aus sehr hartem, festem Gewebe und läßt sich nicht schneiden (im Gegensatz zu A. kollari-Gallen). Der spätere seitliche Ausbohrgang aus der zentralen Larvenkammer wird bereits von der heranwachsenden Larve vorbereitet, indem dieser Gang mit helleren, relativ lockeren, fein säge- späneartigen, radial strukturiert von der Kammer wegführenden Partikeln verschlossen ist, so dass sich die schlüpfende Wespe nicht durch das beinharte Gallengewebe nagen muß, wozu sie kaum imstande wäre. Ein prädisponierter Ausbohrgang findet sich sogar auf beiden gegenüberliegenden Seiten der zentralen ovoidalen Larvenkammer angelegt (Abb. XXI). Eine solche Vorbereitung einer Larvenkammer mit doppeltem „soften\" Ausbohrgang wurde bisher von keiner anderen Gallwespengalle bekannt.\nDas helle, faserige Verschlussmaterial der beidseitig angelegten Ausbohrgänge entsteht aus einer verbreiterten, gelockerten Fortsetzung der schmalen hellen Schutzschicht der Gallenkammer (Abb. XXI).\nDiesen Umstand eines vorgefertigten weicheren Ausbohrganges machen sich auch räuberische Vögel zunutze, indem sie genau an der Stelle, wo der Gang nahe der Oberfläche endet, die harte Oberschicht bzw. dicke Gallenhaut - die an diesen Stellen ein wenig aufgebeult ist (Abb. XXI) - aufhacken und trichterförmig erweitern, um sich dann durch den Gang hindurch - mittels Zunge oder Schnabel - die Larve oder Puppe aus der zentralen Kammer zu holen. Dabei kommt es auch vor, dass wenn die räuberischen Vögel auf einer Seite nicht zurecht kommen, es dann nochmals auf der gegenüberliegenden Seite der Galle versuchen; solche Gallen weisen dann 2 aufgehackte Löcher auf. Eine andere Methode der spechtartigen Vögel ist, die harte Galle durch einen gezielten, kräftigen Schnabelhieb zu spalten, um so an die zentrale Larvenkammer zu kommen (Abb. XXI). Diese Spalttechnik läßt sich auch mit Meisel und Hammer, mit einem kurzen Schlag, nachvollziehen. Sie ist praktisch die einzige Möglichkeit, um die beinharten dabei recht spröden Gallen mühelos entzwei zu kriegen.\nWenn man die „Feigengallen\" von A. infectorius in einer durch die beiden seitlichen Ausbeulungen verlaufenden Schnittsebene spaltet, so werden\n\n--- Seite 65 ---\ndie locker verstopften Ausbohrgänge sichtbar, die von der in dieser Ebene bzw. Ansicht ovoidalen Gallenkammer wegführen (Abb. XXI); in anderen Schnittebenen hingegen erscheint die Gallenkammer „rund\", wie in der Literatur stets angegeben. Gallen von A. infectorius aus Südtirol (Castelfeder) und daraus im VIII/IX. 2005 geschlüpfte agame Weibchen waren im Herbst 2005 an den Spezialisten Dr. Juli Pujade-Villar (Univ. Barcelona) zur Überprüfung geschickt worden; sein Befund (pers. com.: 19.10.-02.11.2005) lautete: \"The $A n$ dricus infectorius (adult material) is really close to this species, but I am not sure that this material belongs to this species because the galls are not typical of $A$. infectorius. Some of the galls you sent me do not have the characteristic vitreous tissue, but only part of it; therefore they are softer that normal. That is why I said that they were anormal infectorius, and so, I will send part of the material to my colleague [George Melika] that knows very well this species.\"\nDas Problem bei dieser Aussage ist, dass Dr. PujadeVillar zu jener Autorengruppe gehört, die vor 5 Jahren zunächst Andricus gallaetinctoriae (Oliv.) zum \"nomen dubium\" erklärt und damit vorerst eliminiert hatten [Bellido, Ros-Farré, Melika \\& Pujade-Villar 2003: 192-214]-unter gleichzeitiger Beschreibung einer neuen, nahestehenden Art: Andricus sternlichti sp.n. aus Nahost; [nach Beschreibung der Galle (p.213), ihrer Größe (13-20 mm) und Foto (Fig. 76) m.E. nur ein Synonym].\n\nAbb. XXI: Abbildungen zur Beschreibung der Galle\n![img-27.jpeg](img-27.jpeg)\ngrüne infecorius-Gallen (07.07.05)\n\nDiese plötzlich fehlende Verfügbarkeit von \"Andricus gallaetinctoriae\" führte dazu, dass einige der Gallenmerkmale übertragen wurden auf Andricus infectorius; dies endete letztlich in einer Synonymisierung der beiden Taxa. Maßgeblich ist aber auszugehen von der originalen Beschreibung HarTIGs von C. infectoria (\"faltige Oberfläche\" - \"festes Parenchym\") und seinen Größenangaben ( $8-15 \\mathrm{~mm}$ ) - und nicht von dem, was spätere Autoren hinzu interpretiert haben [\"characteristic vitreous tissue\"]; von letzterem war weder bei Hartig (1843:421) die Rede, noch später bei Kieffer (1901: 567-568), der solche Gallen aus Sizilien von De Stefani und aus Norditalien von Trotter erhalten hatte.\nSpäter kam J. Pujade-Villar noch zum einem nachträglichen abschließenden Befund (27.09.2007) über die im Herbst 2005 übersandten Gallen und geschlüpften Wespen Südtiroler A. infectorius:\n\"According to our opinion these galls are Andricus sternlichti. G. Melika informs me, that sometimes the galls are much smaller than the \"typical\" sternlichti.\" - Diese letzte Aussage ist völlig indiskutabel.\nIn Südtirol-Trentino gibt es keine Andricus gallaetinctoriae (Oliv.) und noch weniger eine Andricus sternlichti - auch wenn ich diese beiden für mögliche Synonyme halte. Unsere heimische Galle ist zweifellos $A$. infectorius (Htg.) und entspricht exakt der Beschreibung der \"Triestinergalle\" Hartigs. Damit stellt sich aber die Frage, was mit \" $A$. infectorius\" s. Bellido et al. 2003 gemeint sein mag?\n![img-28.jpeg](img-28.jpeg)\ngrüne infecorius-Gallen \\& alte kollari-Galle\n\n--- Seite 66 ---\n![img-29.jpeg](img-29.jpeg)\nreife infecorius-Gallen (26.09.05)\n![img-30.jpeg](img-30.jpeg)\ninfectorius-Gallen mit Flugloch: 27.09.06\n![img-31.jpeg](img-31.jpeg)\n\nGallen zahlreich unter Eiche am Boden\n![img-32.jpeg](img-32.jpeg)\nalte infecorius-Galle\n![img-33.jpeg](img-33.jpeg)\ngespaltene infectorius-Galle: idem 16.10.06\n![img-34.jpeg](img-34.jpeg)\nvon Vögeln aufgehackte Gallen: 08.10.2005\n\n--- Seite 67 ---\n![img-35.jpeg](img-35.jpeg)\ngespaltene Galle mit seitlichen \"soft\"-Gängen\nidem: Vögel geöffnet am \"soft\"-Ausgang\n![img-36.jpeg](img-36.jpeg)\n\n51 Andricus inflator Hartig 1840 9\n$-\\text { „Kohlrabigalle\" }$\n(agam: Cynips globuli Htg. 1840)\n\n- „Grüne Kugelgalle\"\n\nVerursacht in der agamen Generation im Spätsommer an Eichen (Quercus spp.) kugelige, grüne Knospengallen (\"Globular gall causer\"); die dunkelgrünen außen fleischigen, innen hartwandig holzigen Kugel-Gallen (4-6 mm), an der Spitze mit einer kleinen gelben Warze, treten an den Zweigspitzen aus einer Knospe hervor, basal sind sie zur Hälfte von den Knospenschuppen umhüllt (Abb. 51b); die Gallen im Herbst abfallend. - In der Sexualgeneration im Frühjahr keulige Triebanschwellungen (\"Twig gall causer\"), meist mit normalen Blättern besetzt, als frische Junggallen im Frühjahr als „Kohlrabigallen\" bezeichnet (Abb. 51a); vergallte Sproßspitzen später oft absterbend (Abb. 51); [BuHR 1965: Nr. 5381, 5402, T. 14, Fig. 220 9; Nr. 5443, T. 15, Fig. 239 9; PfütZENReiter 1958: Nr. 10, Abb. 7 (sex.); Nr. 24, Abb. 18 (agam: Grüne Kugelgalle); Pellizzari 1988: 105; Amann 1990: 87; Csóka 1997: 98-99; Melika et al. 2000: 273, Fig. 30; Redfern et al. 2002: 402, Fig. 668].\nIn Mitteleuropa verbreitet und häufig (BuHR 1965: 925); in Spanien durch A. pseudoinflator Tavares vertreten (Nieves-Aldrey 2001: 535). - In Italien (Checklist 1995: Nr.13/31, A. inflator Htg.);\n\nBernardi et al. (1997: 182: Fig. 41): bekannt aus Sizilien, Latium, Toskana, Emilia-Romagna, Veneto, Friaul-V.G. - Im Triestiner Karst von GräFfE (1905: 36, A. globuli Htg. - inflator Htg.) an Quercus robur, sessiliflora, pubescens gesammelt (vgl. ToMASI 1996: 31; 2006: 22, 68, Cecidothek FVG).\nVon Dalla Torre (1894: 14; 1896: 152) Gallen von Andricus inflator Htg. aus N-Tirol angeführt an Quercus pedunculata (Volderwald bei Hall; Kematen) sowie Gallen von Andricus globuli Htg., vom Eichenwald bei Stams, Sept. 1894. - Neu für Trentino.\nIn Südtirol wurden einzelne inflator-Gallen am Ritten an Q.petraea beobachtet (Hellrigl 1996). Verholzte vorjährige Gallen im IV. 2005 auch bei Brixen an Eichen in Tschötsch (Abb. 51), Neustift (700 m), sowie Elvas ( 800 m) 2 Gallen, 15.04.2005. Diese alten verholzten 9 -Gallen (vgl. Redfern et al. 2002: 402, Fig. 668) sind hier aber nur sporadisch zu finden und täuschen somit eine scheinbare „Seltenheit\" dieser ansich recht häufigen bisexuellen Frühjahrs- bzw. agamen Herbstart vor. - Häufiger und leicht kenntlich fanden sich große verholzte inflator-Gallen an Stieleichen, endständig an Zweigspitzen [Fotos: $10 \\times 7,10 \\times 7,10 \\times 9,11 \\times 10$, $12 \\times 8 \\mathrm{~mm}$ ], Ende Okt. 2008 in Osttirol, bei Schloß Bruck in Lienz, (leg. A. Kofler \\& K. Hellrigl). [vgl. auch: Nr. 62: A. pseudoinflator].\n\n--- Seite 68 ---\nAuch frische „Kohlrabigallen\" der bisexuellen Generation fanden sich im Frühjahr 2005 stellenweise zahlreich an einzelnen strauchartigen Q. petraea am 28.04.2005 in Montiggl ( 560 m ) auf der Forstlichen Monitoring-Fläche (IT-02), leg./Foto Hellrigl \\& Fostini (Abb. 51a). - „Grüne Kugelgallen\" im Herbst wurden zahlreich beobachtet am 24.09.2006 in Castelfeder an Zweigen älteren Flaumeichen (50 Gallen) und vereinzelt am 25.09.06 in Elvas/Brixen, 850 m , an junger Quercus petraea: 6 Gallen. - Am 11.09.2008 fand ich ,,grüne Kugelgallen\" auch im Eisacktal bei Aicha-Spinges ( 850 m ), an Traubeneiche $(2,5 \\mathrm{~m})$, rd. 1 Dutzend Gallen von C.globuli ( $\\varnothing 5 \\mathrm{~mm}$ ), die Hälfte davon schon abgefallen bzw. abfallend. Auf der Tschötscher Heide ( 750 m ) am 12.09.08 nur 2 globuli-Gallen (an Q. pubescens und Q. petraea); vereinzelte globuli-Gallen am 17.09.08 an Eichen in Albeins/Schottergrube ( 700 m ).\nDie „grünen Kugelgallen\" [C. globuli] sind im Herbst nur 1-2 Monate vorhanden, da sie leicht abfallen und oft auch von Meisen aufgehackt werden (Foto). Ende Aug. 2008 bzw. Mitte Sept. 2007 waren in Castelfeder noch keine neuen Gallen zu finden gewesen.\nIm Herbst 2008 konnten „grüne Kugelgallen\" erstmals auch für das Trentiner Etschtal nachgewiesen werden: am 07.09.08 in Pomarolo-Servis ( 700 m ) einige Dutzend „globuli\" an Q.pubescens und ebenso mehrere Gallen bei Rovereto-Dossi ( 350 m ) gefunden (leg. Hellrigl \\& Mörl). - Überraschend war, dass sich in Pomarolo-Servis ( 700 m ) einen Monat später, am 12.10.2008, noch immer zahlreiche globuli-Gallen (bis zu Ø 6-7 mm) an den Eichenzweigen fanden (Abb. 51), sodass mühelos 80 grüne Kugelgallen gesammelt werden konnten (leg. Hellrigl \\& Schanung). - Auch im Südtiroler Unterland, bei Castelfeder fanden sich ,,grüne Kugelgallen\" am 19.10.08 noch zahlreich im ganzen Eichenhain an älteren Eichen; etwa ein Drittel der Gallen waren schon abgefallen (leere Knospenhüllen), es wurden 2 Dutzend Gallen als Belege und zur Aufzucht der Gallwespen gesammelt (leg./Foto Hellrigl).\n\n52 Andricus kollari (Hartig 1843) $9 \\div$\n\n- \"Marble gall\"\n[= C.quercusgemmae Christ 1791, nec Linné 1758]\n( $9 \\delta=$ A. circulans Mayr 1870) - „Vogelnestgalle\"\n\nAgame Generation mit großen, glatten, dickwandigen Kugelgallen ( $\\varnothing 15-25 \\mathrm{~mm}$ ) an Eichenzweigen (Q.petraea, Q.pubescens, Q. robur), oft mehrere beisammen (Marble gall = Murmel-Gallen). Das Gewebe der anfangs grünen, bei Reife hellbraunen, äußerlich recht festen Galle ist etwas schwammig („Schwammkugelgalle\"), sie lässt sich mit dem Messer zerschneiden; trockene Gallen sind leicht und schwimmen im Wasser. Die holzigen Zweig Gallen wurden schon von RöSEL (1755: T.35,36) unverkennbar abgebildet, worauf sich auch Linné (1758: 554, n. 6) bei der Beschreibung dieser Galle von \"Cynips quercus-petioli\" bezog; [da die von Linné beschriebene Wespe aber nicht der Gallenerzeuger war, sondern eine Inquiline, war dieser früher oft verwendete Name für die Gallwespenart ungültig].\nWespe und Galle wurden erstmals nomenklatorisch gültig von Hartig (1843: 403-404) als \"Cynips Kollarii m.\" beschrieben, nach Exemplaren aus der Umgegend Wiens, die Kollar übermittelt hatte. Die Art ist benannt nach Vincenz Kollar (17971860), damals Custos, später ab 1851 Vorstand des zoologischen K. K. Hof-Naturaliencabinets [heute Nat. Hist. Mus. Wien], dem Hartig die Kenntnis bzw. Belege von 1 Dutzend weiteren, der von Hartig 1843 beschriebenen Gallwespenarten verdankte.\nSexualgeneration ( $=$ A. circulans Mayr) mit unscheinbaren Knospengallen („Vogelnestgallen\") an Q. cerris. - In Mitteleuropa, beim Fehlen von Q. cerris, oft nur eine parthenogenetische, agame Generation (Gauss 1982: 243). [Della Beffa 1961: 931; Pfützenreiter 1958: Nr. 18, Abb. 13 (99) Schwammkugelgalle); Nr. 19 Abb. 14 (98) Vogelnestgalle); Buhr 1965: 937, Nr. 5434; T. 15, Fig. 237; Zahradnik 1985: 81; Chinery 1987: 226; Pellizzari 1988: 106; Csóka 1997: 96; MeliKa et al. 2000: 273, Fig. 31; Nieves-Aldrey, 2001: 395, 539; Fig. 129 P; Redfern et al. 2002: 404, Fig. 677-678; Bellido et al. 2003: 200-205].\nIn Checklist Ital. (1995: Nr. 13/08 als A. circulans und 13/32 als A. kollari); aus N-Italien und Sizilien gemeldet; ZaPparoli (1997: 316) Mittelitalien: \"Gli Insetti di Roma\", Orto Botanico (Villa Corsini); auch in der Toskana (Bernardi et al. 1997: 98). - FVG: vom Triestiner Karst und den Karnischen Voralpen von GrÄFfE (1905: 21, T. II, n. 12) und Tomasi (1996: 31; 2006: 20, 68, Cecidothek FVG)\n\n--- Seite 69 ---\nzahlreich gemeldet. Nach GrÄFfE (l.c.) „sind die Gallen von Cynips kollari in allen Eichenwäldern des Karstes häufig anzutreffen, meist an kleineren Bäumen von Quercus pubescens und sessiliflora, die oft viele Gallen beisammen tragen. Sehr häufig finden sich in den kugelrunden, glatten Gallen Synergusarten als Einmietlerlarven, die in großen dreieckigen Kammern liegen, die fächerförmig um die eingegangene Larvenkammer des Erzeugers liegen, der dabei zugrunde geht. Das Ausschlüpfen der Wespe geschieht noch im Herbste, die Einmietler erscheinen aber erst im nächsten Frühjahre.\"\nAuch im Trentino: nach Bezzi (1899) an Quercus pedunculata und Q. sessiliflora, bei Cusiano (Val di Sole) und im ganzen Gebiet. Aus Südtirol liegen Belege von kollari-Gallen vom Etschtal-Unterland aus den 1980er Jahren vor: 3 Gallen (20-22 mm), leg. Hellrigl; 2 Gallen (Ø 21 mm ), leg. S. Minerbi. Im Eisacktal im Großraum Brixen, wo die Zerreiche fehlt, kommt A. kollari nur sporadisch in parthenogenetischer, agamer Generation vor. Von hier aus Brixen Umg. angegeben (Hellrigl 1996: 690), doch später jahrelang keine kollari-Gallen an Eichenzweigen festzustellen. Erst kürzlich neue Freilandfunde von Gallen im Eisacktal, bei Aicha $(740 \\mathrm{~m})$ am 12.11.2007, in Bestand von Traubeneichen, 1 Galle ( $\\varnothing 18 \\mathrm{~mm}$ ) an Zweig und 3 Gallen (Ø 15-17 mm) an Stockausschlag am Stammfuß (Hellrigl \\& Förster De Luca) (Foto). - Auch im Überetsch, bei Kaltern-Feldschon ( 450 m ), fanden sich neben der Straße an 6 Meter hohen Traubeneichen (Q. petraea $=$ Q. sessiliflora), am 12.05.2005, neben einigen Biorhiza pallida, 6 vorjährige kolla-ri-Gallen [Ø 18-21 mm] (leg. Hellrigl \\& Förster A. Fostini); auch in diesem Gebiet kommen keine Zerreichen vor.\nIm Eisacktal fanden sich im Herbst 2006 in BrixenStadt zahlreiche kollari-Gallen an einigen rezent aus der Toskana importierten und hier als Alleebäume angepflanzten Stieleichen der Pyramidenform (Quercus robur ,Fastigiata'). Hier wurden am 26.11.2006 am nördl. Eisackufer (C. Battisti-Str.), 105 kollari-Gallen gesammelt und vermessen (leg. Hellrigl \\& Mörl). Diese Gallen waren insgesamt etwas kleiner (Ø 12-25 mm; meist 18-20 mm) als heimische kollari-Gallen aus Castelfeder (Abb. 52b); Gallen unter Ø 15 mm waren meist parasitiert oder von Inquilinen besetzt (mehrere kleine Fluglöcher),\nnur $30 \\%$ waren regulär geschlüpft (d.h. ein großes Flugloch). - Bei Nachkontrolle von vier im Mai 2008 nachgepflanzten, 6 Meter hohen Stieleichen dieser Allee wurden, neben weiteren alten Kugelgallen, am 15.06.08 bereits erste grüne Gallen von A. kollari (Ø 15 mm ) und A. infectorius (Ø 10 mm ) festgestellt (Einschleppung als Junggallen mit den im Frühjahr aus Bassano neu importierten Eichen). Bei späteren Kontrolle dieser nachgepflanzen Stieleichen wurden am 04.08.2008 in Brixen noch weitere dunkelbraune vorjährige Gallen (Ø 18-23 mm) gefunden, sowie 36 frische Gallen (Ø 15-22 mm), zu $84 \\%$ bereits hellbraun verfärbt - zu $16 \\%$ noch grün (leg. Hellrigl \\& Mörl). Aus diesen Gallen schlüpften die Wespen von Ende Aug. bis Mitte/ Ende Sept., die vier letzten am 24.-27.09.2008.\nRezente Belege für Südtirol liegen insbesondere vom Eichenhain in Castelfeder ( 400 m ) bei Auer vor, wo ab 28.04.-12.05.2005 zahlreiche alte kol-lari-Gallen (Ø 20-23 mm) an Flaumeichen (in Nähe einer einzelnen großen Zerreiche: Ø 100 cm ) gesammelt wurden (leg. Hellrigl \\& A. Fostini). An Zweigen der Flaumeichen fanden sich vergesellschaftet auch zahlreiche alte Gallen von A. infectorius. Bei einer späteren Kontrolle, am 07.07.05, wurden auch frische kollari-Gallen vorgefunden, teilweise noch grün, aber größtenteils bereits hellbraun ausgefärbt (Abb. 52). Es wurden 38 Gallen gesammelt, aus denen vom 01.-05.08.2005 die ersten 5 Wespen schlüpften. Bei Nachkontrolle, am 10.08.2005, wurden weitere 27 frische Gallen gesammelt, davon 3 bereits geschlüpft. In Weiterzucht schlüpften aus den 65 Gallen bis Ende Aug. 53 A. kollari, weitere $6 \\bigcirc$ bis Mitte September. Die kollari-Gallen aus Castelfeder im Jahre 2005 enthielten nur vereinzelt Parasitoiden, wie z.B. Megastigmus stigmatizans. In den beiden Folgejahren 2006/07 ergaben sich im Eichenhain Castelfeder b. Auer folgende Befunde: 24.09.2006: zahlreiche alte Gallen von Andricus kollari sowie 16 diesjährige Gallen (Ø 21-23 mm); vergesellschaftet: sehr viele Andricus infectorius, meistens geschlüpft; 128 Ex.: 106 geschl. (82,8\\%); 22 parasitiert ( $17,2 \\%$ ); einige Haargallen von A. caputmedusae; 9 Gallen von A. coriarius an 4 Bäumen; 16.09.2007: 140 diesjährige Gallen von A. kollari (Ø 16-28 mm), davon 50 am Baum (meist geschlüpft) und 90 am Boden (meist aufgehackt von Vögeln).\n\n--- Seite 70 ---\nZu einer starken Populations- bzw. Befallszunahme von A. kollari kam es im Eichenhain im Sommer 2008. Mit induziert war diese durch eine radikale Zusammenstutzung einer alten Flaumeiche, die am 03.03.2008 ein klägliches Bild bot (Abb. VII). Überraschenderweise fanden sich dreieinhalb Monate später, am 22.06.2008, an dieser „geschneitelten\" Eiche (an deren Zweigen im Vorjahr keine kollari-Galle vorhanden waren), an neuen Johannistrieben zahlreiche kollari-Gallen (Abb. VIII). Auch wiesen einige weitere Flaumeichen, im näheren und weiteren Umkreis einer großen Zerreiche, erhöhten Gallenbesatz auf. Interessant war, dass zu dem frühen Zeitpunkt zu Beginn des Sommers, der Großteil der noch grünen kollari-Gallen bereits voll ausgewachsen schien; an einem Baum fanden sich rd. 20 Gallen $(\\varnothing=20-25 \\mathrm{~mm})$; an weiteren Bäumen 10 grüne Gallen $(\\varnothing=18,20,22,22,23$, $23,23,24,25,29 \\mathrm{~mm}$ ) sowie zum Größenvergleich 5 braune vorjährige Gallen ( $17,20,21,22,23 \\mathrm{~mm}$ ). Allerdings schrumpften einige gesammelte grüne Gallen in den folgenden Tagen rasch ein; nur die innere Zelle war bereits ausgehärtet und enthielt die ausgewachsene Gallwespenlarve (keine Puppe). Die erste fertige kollari-Gallwespe fand sich in einer Galle am 21.07.2008 in einer Galle (Foto). Wie bereits die Zuchten des Jahres 2005 gezeigt hatten war mit dem Schlüpfen der Gallwespen von A. kollari erst ab Anfang August zu rechnen.\n\nEinen Monat später, am 17.08.08, waren hier die kollari-Gallen alle schon hellbraun verfärbt; von 126 an Zweigen gesammelten Gallenkugeln waren $46(=36,5 \\%)$ bereits ausgeflogen, mit kollari-Flugloch. Dabei wiesen 7 Gallen neben einem großen Gallwespen-Flugloch noch ein zweites, gleich groBes Flugloch auf; dieses stellte sich bei später als Flugloch der Grabwespe Pemphredon austriaca heraus, die speziell kollari-Gallen besiedelt und deren Schwammgewebe mit Grabgängen durchzieht.\nDas Schlüpfen der agamen Weibchen von A. kollari setzte sich den ganzen August bis Ende September fort ( 26 Wespen +9 Parasitoide), in zeitlicher Übereinstimmung mit den kollari-Gallen anderer Standorte, wie Pomarolo, Rovereto und BrixenStadt (hier nur Gallen an importierten Eichen). Die letzten lebenden $A$. kollari fanden sich in den Zuchtkäfigen (im Freien) am 27.09.-05.10.2008; einzelne davon lebten noch bis Mitte Oktober.\n\nEine Überraschung im Schlüpfverlauf der kollariGallen aus Castelfeder im Jahre 2008 war der hohe Anteil ungeschlüpfter Gallen; dieser lag mit 45 Gallen ( $36 \\%$ ) deutlich höher als jener der parasitierten 9 Gallen ( $7 \\%$ ) durch Megastigmus stigmatizans, M. dorsalis, Torymus nitens und Ormyrus pomaceus. Einige am 01.10.08 probeweise geöffnete ungeschlüpfte kollari-Gallen enthielten ausgewachsene Larven, doch konnte nicht ermittelt werden ob dies Larven der Gallwespe oder eines Parasitoiden waren. Es kommt mitunter vor, dass von Gallwespen welche normalerweise im Herbst schlüpfen, ein Teil der Population erst im nächsten Jahr schlüpft, doch hatte ich dieses bei A. kollari bisher nie beobachtet; auch GrÄFFE (1905) gibt aus Triest für Cynips kollari nur „Ausschlüpfen der Wespen im Herbst an.\" Hingegen berichtet M. Riedel (1910: 37) aus Deutschland über C. kollari: „Die Wespe kriecht noch im Herbst oder im Juni des nächsten Jahres aus den im Spätherbst reifen Gallen aus.\" Dasselbe bestätigt Gy. СsóкA auch für Ungarn (in litt. 2008): \"A. kollari asex galls emerge regularly in late July, but sometimes only next spring, etc.\"\nEine entsprechende Nachkontrolle in Castelfeder nach Saisonsende im Herbst 2008 sollte zeigen, wie die Verhältnisse vergleichsweise unter Freilandbedingungen abgelaufen waren. Am 19.10.2008 wurden hier 48 kollari-Gallen an alten Flaumeichen gesammelt, darunter auch zwei große Gallengruppen mit 8 Gallen ( $50 \\times 40 \\mathrm{~mm}$ ) und mit 11 Einzelgallen ( $75 \\times 55 \\times 50 \\mathrm{~mm}$ ), leg./Foto Hellrigl (vgl. Abb.). Der Anteil regulär geschlüpfter Gallen betrug 33 ( $69 \\%$ ), jener der parasitierten $1(2 \\%)$, die ungeschlüpften Gallen lagen mit $14(29 \\%)$ im ähnlichen Bereich (ca. ein Drittel) wie bei den Zuchten.\nDie A. kollari-Gallen im Eichenhain Castelfeder konzentrierten sich auf wenige zerstreute Flaumeichen ( $Q$. pubescens), im weiteren Umkreis einer einzelnen alten Zerreiche ( $Q$. cerris) (vgl.Abb. VII). Keinerlei Befallsspuren wiesen hingegen einige hier angepflanzte alte Amerikanische Roteichen auf. In alten verlassenen Gallen hatten sich in großer Anzahl Ameisen eingenistet, vor allem die „Stöpselkopfameise\" Camponotus truncatus (zahlreich in vielen Gallen), seltener die Rotköpfige Stechameise Cremastogaster scutellaris, vereinzelt auch kleine Leptothorax-sp. und 1 Camponotus fallax (Nyl.). - Auch Grabwespen hatten sich öfters in\n\n--- Seite 71 ---\nverlassenen kollari-Gallen eingenistet: so wurden am 10.-20.05.2007 zwölf Pemphredon austriaca (Kohl 1888) [= Diphlebus austriaca Kohl 1888] daraus gezogen (Hellrigl 2006: Auftreten seltener Ameisen in Südtirol-Trentino, p. 405). Noch häufiger waren diese auf $A$. kollari-Gallen spezialisierten Grabwespen (Pagliano \\& Negrisolo 2005: 466/67) hier im Jahre 2008, was eine nähere Beobachtung ihrer Lebensweise ermöglichte. Von der Grabwespe besiedelten Gallen sind daran zu erkennen, dass sie neben dem großen Gallwespen-Flugloch noch ein zweites, gleich großes Flugloch aufweisen. Solche Gallen mit 2 großen Fluglöchern waren im Inneren von Gängen der Grabwespe Pemphredon austriaca durchzogen, welche offenbar durch das Ausflugloch der Gallwespe eingedrungen war, dann im Inneren Gänge gegraben (Abb. 52a) und darin ihre Brut abgelegt und mit eingetragenen Blattläusen versorgt hatte. Die Larven der Grabwespe sind rosafarben (Abb. 21.08.08). Vom 18.08.08 bis Anf. Sept. schlüpften weitere 15 Imagines von P. austriaca.\nBei einer abschließenden Herbstkontrolle in Castelfeder, am 19.10.2008, waren unter 33 geschlüpften kollari-Gallen bei 6 Gallen die Gallwespen-Ausfluglöcher mit durchsichtigen Sekretdeckeln der Grabwespen verschlossen, die sich zur Überwinterung in die Galle zurückgezogen hatten.\nZu Statistikzwecken wurden im Jahr 2005350 kollari-Gallen ( 270 alte +80 frische) aus Südtirol (größtenteils aus Castelfeder) vermessen, mit Durchmessern von $14-27 \\mathrm{~mm}(67 \\%$ mit Ø $21-23 \\mathrm{~mm})$ und 2006/07 weitere 185 Gallen, insgesamt somit 535 Gallen (Grafik 3). Hinzu kamen 2006/08 nochmals rd. 400 Gallen aus Brixen/Stieleiche und Rovereto sowie Castelfeder/Flaumeiche (Grafik 4). Im Trentino rezente Funde bei Pomarolo-Servis (IT-04: 700 m ) Okt. 2004, 4 Gallen an Q. pubescens (leg. Ambrosi \\& Hellrigl). Hier bei Pomarolo-Savignano, Monitoring-Areal, am 14.10.2007, 13 Gallen an Q. pubescens, sowie 28.10.2007, 14 Gallen mit Flugloch (leg. Hellrigl \\& Mörl). Im Sommer 2008 hier relativ häufig (leg. Hellrigl \\& Mörl \\& Schanung): ebenso wie in Castelfeder bei Montan waren auch in Pomarolo-Servis die kollari-Gallen Ende Juli 2008 noch grün; am 19.07.08 wurden 10 Gallen gesammelt ( $\\varnothing=20,20,21,21,22,22$, $23,23,23,24 \\mathrm{~mm}$ ) und am 27 . Juli 10 weitere ( $\\varnothing=$ $14,15,15,19,20,20,21,21,24,27 \\mathrm{~mm}$ ). Später,\nam 07.09.08, fanden sich dann reife hellbraune Gallen (10 Ex.), wenige schon geschlüpft; insgesamt schlüpften die Wespen aus Pomarolo-Servis bis 05.10.2008.\n\nRovereto, Bosco della città ( 350 m ), am 05.04.2005, ein Eichenzweig mit 4 Gallen (12-16 mm) und ein weiterer mit 7 Gallen (leg. Ambrosi, Salvadori \\& Hellrigl); 2 Gallen (10-19 mm) am 03.10.2007 (leg. Hellrigl). Rovereto-Dossi: 07.09.2008, 12 Gallen (leg. Hellrigl \\& Mörl) vier Wespen und 2 Parasitoide (Megastigmus) schlüpften daraus am 19.09.08, 23.09.08 und 27.09.2008.\n\nInsgesamt ist $A$.kollari derzeit in Trentiner Fundgebieten mit Zerreichen nicht besonders häufig, trotz letzthin zunehmender Tendenz, jedenfalls weit seltener als $A$. quercustozae. Einige dieser rezenten Gallenfunde aus Trentino entsprachen untypischen kollari-Gallen, die Fremdbesatz (Inquilinen/Parasitoiden) aufweisen und dabei kleiner bleiben, mit mehr warziger oder höckeriger Oberfläche (vgl. Buhr 1965: 937; Pellizzari 1988: 106). Auf solche kollari-Gallen mit Fremdbesatz, die vor allem bei Inquilinen meist mehrkammerig erscheinen, hatten schon Dalla Torre \\& Kieffer (1910: 419) hingewiesen. Sogar schon Reaumur (1737: Memoires Insectes, Tom. 3) zeigt anhand seiner Abb. (Pl.41, Fig. 7-9) von „Holzkugelgallen\" [deux galles ligneuses] unverkennbarer kollari-Gallen (Fig. 7) die Unterschiede auf, zwischen einer parasitierten, höckerigen mehrkammerigen Galle (Fig. 8) und einer normalen, regulär geschlüpften, einkammerigen (Fig. 9); desgleichen auch RöSEL (1755): T. 35 normal, T. 36 mehrkammerig und parasitiert. - Solche Gallen mit Fremdbesatz sind oft nicht leicht zu unterscheiden von ähnlichen Gallen kleinerer Arten, insbesondere solchen von Andricus conglomeratus (vgl. Bernardi et al. 1997: 186, Fig. 43).\n[00] [Andricus korlevici Kieffer 1902]\nTaxon mit unsicherem Status, bisher nur bekannt aus Croatia/Italien [cit. Fauna Europaea 2005/07]. Die Galle wird als ähnlich zweigeteilt beschrieben, wie die Galle von Andricus galeatus (Nr.41). In Checklist Ital. (1995: Nr. 20/16, Cynips korlevici): N-Italien. In FVG vom Triestiner Karst zwei Gallenmeldungen von GrÄFFE (1905: 61, Nachtrag: Cynips korlevici Kieffer); Cecidothek FVG: S. Pelagio und Basovizza, leg. Gräffe (cit. Tomasi\n\n--- Seite 72 ---\n1996: 47, n. 66: Cynips korlevici Kieff.). - Gallen von C. korlevici in histor. Cecidothek von E. GrÄFFE 1905 (Mus. Triest) abgebildet bei E. Tomasi (2006: p. 11, Fig. 4; p. 19) neben Gallen von Cynips amblycera und Cynips galeata - alle vom selben Fundort im Triestiner Karst: „Carso S. Dorigo\". - Die dort abgebildete korlevici-Galle würde ich für identisch mit \"C. amblycera\" halten. - Status uncertain.\n\n53 Andricus legitimus Wiebes-Rijks 1980\nDie „Eichensamengallwespen\" bildet im Endokarp von Eicheln diverser Eichen eine einzelne Zelle (im Gegensatz zu mehrkammerigen Zellen von Callirhytis spp.). Von ihrem regelmäßigen Inquilinen Synergus clandestinus Weld 1952 besetzte Eicheln sind aber ebenfalls mehrkammerig [vgl.: Nieves-Aldrey 2001: 418, Fig. 125 D-E; Redfern et al. 2002: 418, Fig. 741]. - Verbreitung: Britannien, Bulgarien, Frankr., Ungarn, Irland, Spanien, Niederlande [Fauna Europaea 2007]; wohl noch weiter verbreitet in Europa - wo auch Synergus clandestinus gemeldet wird. - Fehlt in Checklist Ital. (1995).\nBefallene Eicheln werden in Britannien als häufig angegeben und ebenso in Spanien. Dennoch gilt die Art als sehr selten, da befallene Eicheln nur zu einem minimalen Anteil den Gallenbildner ergeben, sondern meist sekundär vom Inquilinen Synergus clandestinus besiedelt werden.\nIm Laufe dieser Untersuchung konnte die Art erstmals auch für Südtirol und Italien neu nachgewiesen werden: Aicha ( 740 m ), in Baumbestand von Traubeneichen, am 12.11.2007, eine verkümmerte Eichel im Fruchtbecher ( $\\varnothing 9 \\mathrm{~mm}$ ) mit 2 kleinen Ausfluglöchern nahe am Kelchrand (leg. Hellrigl \\& Förster De Luca). Die geöffnete Eichel zeigte 2 Zellen, jeweils mit Ausflugloch, von Gallwespen Andricus legitimus und Synergus clandestinus - beide neu für Italien und Südtirol. Neben der Eichel mit 2 Zellen fand sich noch eine gleiche Zwillingseichel mit nur einem kleinen Flugloch (vgl.Abb. 53).\n\n## 54 Andricus lignicolus (Hartig 1840)\n\n- „Holzkugelgalle\"\n\nBildet in der agamen Generation kugelige, rauhe Gallen an Nebenknospen von Eichenzweigen (Q.petraea, Q. pubescens, Q. robur); vornehmlich an strauchartigen Eichen und Stockausschlägen.\n\nDie holzigen Gallen sind viel kleiner (8-10-13 mm) als die von A. kollari; ihre Oberfläche mehr buckelig und rissig (\"knobbly Cola-nut Gall\"), frisch oft netzartig aufgerauht [vgl. Abb: Zahradnik 1985: 83]. Die Artbeschreibung durch Hartig (1840: 207) war nur nach der Galle erfolgt (Loc. typicus: Berlin); die Wespe beschrieb Hartig (1843: 402) später nach Belegen, welche Kollar in der Umgebung Wiens recht häufig an Q.pedunculata, sessiliflora sowie pubescens gefunden und übermittelt hatte. Die Wand der „Holzkugelgalle\" ist holzig, die Innenmasse rostrot bis schokoladebraun, mit der hellen und schmalen Schutzschicht der meist etwas basalen Larvenkammer dicht verwachsen; Gallenreife im Spätherbst, Imago im Mai/Juni des 2. Jahres [DALLa Torre \\& Kieffer 1910: (Cynips lignicola Htg.) 419-420, Fig. 130, 131; Riedel 1910: 36, Taf. 3, Fig. 14; BuHR 1965: Nr. 5435 (ㅇo); Pfützenreiter 1958: Nr. 17, Abb. 12 ( $Q$ Holzkugelgalle); Csóka 1997: 98/99; Melika et al. 2000: 273, Fig. 32, unisexual; Redfern et al. 2002: 404, Fig. 680 ㅇo]. Sexualgeneration [A. vanheurni Doct. v. Leeuw. \\& Dekh. 1958] angeblich in Knospengallen nur an Q. cerris [Buhr 1965: p. 938, 976, Nr. 5568; Bellido et al. 2003: 205-209]. - In Mittel- und SE-Europa verbreitet; häufig in Wien, Ungarn und England; fehlt in Spanien (wie Q. cerris).\nVon Dalla Torre (1892: 147) als Knospengalle von Cynips lignicola Htg. an Quercus aus Istrien (Peyritsch) gemeldet; keine Fundangaben aus Tirol. Vom Triestiner Karst auch von GrÄFFE (1905: 20, Taf. I, n. 7: Cynips lignicola Htg.) von Quercus robur und sessiliflora gemeldet und beschrieben; div. Funde von GrÄFFE 1905, in Cecidothek FVG (Mus. Triest), zitiert von Tomasi (1996: 32, Nr. 35). Ein noch von Tomasi (l.c.) als \"Andricus lignicola Htg.\" erwähnter Eigenfund aus Triest, M. Cocusso, XI.1992, ist gemäß Gallenbeschreibung und Abb. „Tab. D-3\" (p.133) an Quercus cerris, nicht hierher zu beziehen, sondern betrifft wohl Aphelonyx cerricola. - In N-Italien (Checkl., 1995: Nr. 13/33); auch in Mittelitalien: Zapparoli (1997: 316): \"Gli Insetti di Roma\", Orto Botanico (Villa Corsini).\nDie oft zu zweit oder dritt an Triebspitzen auftretenden Gallen (Abb.54) sind eventuell verwechselbar mit solchen von A. infectorius oder von A. conglomeratus, worauf schon GrÄFFE (1905: 20)\n\n--- Seite 73 ---\nhinweist. So halte ich etwa die Gallenabbildungen von \"A. conglomeratus\" bei Bernardi et al. (1997: 180, Fig. 40; p. 184, Fig. 42) aus Toskana (Livorno, Pisa) eher für „Holzkugelgallen\" von A. lignicolus. - Die Gallen von A. lignicolus können in Größe und Form sehr vielgestaltig und variabel sein, selbst an ein und demselben Fundort (vgl. Gallen aus Rovereto, Pomarolo, Neustift); mit Sicherheit sind sie oft nur beim Aufspalten an ihrer rostroten bis dunkelbraunen, dichten Innenmasse zu unterscheiden von A. conglomeratus, A. infectorius, A. kollari.\n\nDie ersten gesicherten Nachweise von A. lignicolus für Südtirol-Trentino gelangen im Herbst 2006/07: Erstnachweis in Südtirol am 10.10.2006 bei Brixen, in Tschötscher-Heide ( 750 m ): an einer strauchartigen, mannshohen Traubeneiche (Q.petraea) am Wegrand fanden sich 4 Zweige mit 15 Gallen von A. lignicolus (Abb. 54): 1. Zweig 1 Galle ( $10.5 \\times 11 \\mathrm{~mm}$ ), 2. Zweig 3 Gallen ( $10 \\times 10$; $10.5 \\times 11 \\mathrm{~m} ; 11 \\times 11.5$ ), 3. Zweig 6 Gallen ( $9 \\times 9$; $10 \\times 10.5 ; 10.5 \\times 10.5 ; 10 \\times 11 ; 11 \\times 11.5 ; 11 \\times 12 \\mathrm{~mm}$ ), 4. Zweig mit 5 Gallen, davon 1 Drilling (belassen). Zwei Gallen wurden zur Überprüfung der exzentrischen, hell gerandeten Larvenkammer aufgespalten (Abb. 54). Nach Überwinterung der Gallen am Freiluftbalkon schlüpften daraus 5 Wespen am 04.-10.06.2007 (Fotos) sowie einige Parasitoide. Dieser durch eindeutige Gallen und Imagines gesicherte Nachweis gab zunächst Rätsel auf, da im ganzen Gebiet der Fundstelle nur buschartige Trau-ben- und Flaumeichen sowie alte Edelkastanien vorkamen, hingegen die Zerreiche völlig fehlte, die als Zwischenwirt der Sexualgeneration dienen soll. Bei Nachsuchen im Okt. 2007 und im Sept. 2008 fanden sich hier keine weiteren Gallen mehr. Überraschend fanden sich aber am 20.09.2008 weitere Befallsstellen von A. lignicolus auf der anderen gegenüberliegenden Talseite bei Neustift-Sonnleiten (700-750 m), wo es ebenfalls keine Zerreichen gibt, insgesamt 30 Gallen an 4 Traubeneichen-Sträuchern (leg./Foto K. Hellrigl \\& K. Schanung):\n1.) Neustift-Steinraffler ( 750 m ):\n1.Strauch (kniehoch): 11 Gallen (vorjährig), an 5 dünnen Zweigen: $(1+2+2+3+3)$, Gallendurchmesser einheitlich klein ( $\\varnothing 7-8 \\mathrm{~mm}$ ), Fluglöcher einheitlich groß ( 2 mm ); davon 2 Meter entfernt: 2. Strauch (mannshoch): 4 Gallen (vorjährig),\ntypische Form, an 3 Zweigen: $(1+1+2)$, Durchmesser normal ( $\\varnothing 9-10 \\mathrm{~mm}$ ), 2 Fluglöcher groß ( 2 mm ), eines klein ( 1 mm ), eines fehlt;\n2.) Neustift-Schießstand ( 700 m ):\n3. Strauch (mannshoch): 8 Gallen (vorjährig), typische Form, an 4 Zweigen: $(1+1+3+3)$, Durchmesser normal bis groß ( $\\varnothing 9,5-11 \\mathrm{~mm}$ ), 4 Fluglöcher klein $(0,5-1 \\mathrm{~mm})$, parasitiert, 4 Gallen ohne Fluglöcher (parasitiert); unmittelbar angrenzend: 4. Strauch (mannshoch): 7 Gallen (vorjährig) an 5 benachbarten Zweigen: $(1+1+1+2+2)$, untypische Form mit stark gefältelter Oberfläche, Gallen sehr ähnlich den „Feigengallen\" von A. infectorius, ab nur wenig gestielt und innen völlig anders; Gallendurchmesser groß (Ø 11-12,5 mm), 2 Fluglöcher groß ( 2 mm ), 4 Fluglöcher klein ( $0,5-1 \\mathrm{~mm}$ ) parasitiert, 1 Galle ohne Flugloch (parasitiert).\nDiese mehrfach belegten Nachweise von A. lignicolus im Brixner Talkessel, wo die Zerreiche fehlt, lassen Zweifel daran aufkommen ob diese Art in der Sexualgeneration tatsächlich nur an Q. cerris gebunden sein soll. Vielleicht liegt hier ein ähnlicher Fall vor wie bei A. kollari, welche ebenfalls in Gegenden vorkommen kann wo Zerreiche als Zwischenwirt fehlt. Hingegen konnte ich in Castelfeder, wo A. kollari und A. infectorius häufig sind, die „Holzkugelgallen\" ebenso wie A. conglomeratus, bisher nie finden. Allerdings gibt es dort, wegen starker Ziegenweide, kaum strauchartige Eichen. Der erste gesicherte Nachweis in Trentino erfolgte am 03.10.2007 bei Rovereto-Dossi, Bosco della città ( 350 m ), an strauchartigem Unterwuchs von Flaumeichen ( $Q$. pubescens) am Weg- bzw. Waldrand. An einer mannshohen Eiche fanden sich 3 Gallen (Ø 11-13,5-13,5 mm) (Abb. 54a), an einem weiteren hüfthohen Strauch ebenfalls 3 Gallen (Ø 9-9-9,5 mm) (vgl.Abb. 54a). Alle 6 Gallen waren noch unausgereift und von hell gelblichgrüner Färbung; zwei Gallen lösten sich beim Transport vom dünnen Zweigansatz (Abb. 54a). Später schrumpften alle unreifen Gallen etwas ein und bildeten außen eine buckelige Oberfläche aus (Abb. 54a). Aus diesen lignicolus-Gallen schlüpften Anf./Mitte Juni 2008 nur Inquilinen (Synergus umbraculus) und Parasitoide.\nAuch in Pomarolo-Servis (IT-04), am 14.10.2007, 2 frische Gallen (Ø 8-11,5 mm) an Q.pube-scens-Strauch (leg./Foto Hellrigl \\& Mörl); aus\n\n--- Seite 74 ---\ndiesen Gallen schlüpften vom 15.-29.06.2008 zwei A. lignicolus $\\vee$ (Abb.54). Weitere 3 Gallen (Ø 8-9, 5-13 mm) fanden sich hier am 28.10.2007 (Fotos); diese Gallen schrumpften später ein, mit stark runzeliger Oberfläche, ähnlich A. infectoriusGallen (im Gegensatz dazu aber nur kurz gestielt); bei Kontrollöffnung einer der Gallen am 29.06.08 fand sich eine $\\vee$-Puppe von A. lignicolus ( 5 mm ) mit bereits dunkel verfärbten Augen (Abb.54).\nDie jahreszeitlich späte Reife der Gallen im Okt. 2007 stimmt mit den Angaben von Dalla TorRE \\& KIEFFER (1910: 420). Dies bestätigte sich auch im Sept./Okt. 2008, als zunächst am 07.09.2008 in Pomarolo-Servis, in Umgeb. von Zerreichen, an denselben Flaumeichensträuchern wie im Vorjahr, zahlreiche größtenteils noch grüne Gallen von $A$. lignicolus gefunden wurden (leg./Foto Hellrigl \\& Mörl); die Gallen waren erkennbar an ihrer buckeligen bis warzigen Oberfläche und mit einem nur kurzen, locker sitzenden Stiel am Zweig befestigt. Im Gegensatz zu den hier gleichzeitig vorkommenden, aber kräftig gestielten und bereits voll ausgereiften Runzelgallen von A. infectorius, waren die lignicolus-Gallen auch innen noch völlig unreif (Abb. 54): auf einen breiten, rostrotbraunen äußeren Rand, folgte deutlich abgesetzt ein doppelt so breiter heller noch ausgefüllter Innenteil (außen mit einer schmalen hellen Schutzschicht), in dessen Zentrum sich eine noch winzig kleine Larve ( $<1 \\mathrm{~mm}$ ) in einer schwach ausgeprägter Zelle befand. Es ist zu befürchten, dass von 30 gesammelten Gallen, mit Ø 7-13 mm (die meisten Gallenmaßen 10-11-12 mm, die kleineren 7-8 mm), nur wenige zur fertigen Aufzucht gelangen werden, da sie zu frühzeitig und unreif gesammelt wurden. Auch 1 Monat später, am 12.10.2008, wurden hier weitere 5 lignicolusGallen gesammelt: 3 Gallen waren noch grün [ $\\mathrm{D}=$ $12 ; 12,5 ; 13,5 \\mathrm{~mm}$ ] und 2 Gallen waren runzelig/ kupfrig, davon eine Galle ( 11 mm ) zusammen mit Galle von A. amblycerus, und die andere ( 10 mm ) zusammen mit A. infectorius. (Abb. 54b).\nDrei eigenartige vorjährige Gallen (Ø 7-8 mm) hatte ich am 24.04.08 in Pomarolo an einem Flaumeichenstrauch gesammelt; trotz ungewöhnlich rotbrauner, recht glatter Oberfläche konnte es sich nur um A. lignicolus handeln (Abb. 54). Eine der 3 Gallen hatte eine geschrumpfte, gefältelte Oberfläche\nund war parasitiert; aus den beiden glatten Gallen schlüpften am 31.05.2008 jeweils ein großes agames Weibchen von A. lignicolus (Foto 54). Die Größe der Ausbohrlöcher entsprach mit Ø 1,95 mm [= 1 Linie] den Angaben von Hartig (1840: 207208): „Harte, holzige, einkammerige, kugelrunde Gallen, mitunter traubenförmig zu 4-5 Stück an den Seiten der Eichentriebe. Sie beherbergen eine der größten Gallwespen, denn die Fluglöcher derselben messen 1 Linie im Durchmesser.\" Neu für Südtirol-Trentino: insgesamt an die 100 sichere Gallennachweise (Grafik 2), 10 Wespen (coll. Hellrigl).\n\n55 Andricus lucidus (Hartig 1843)\n[= A. lucidus erinaceus Kieffer 1901]\n[= $\\& 0$ A. aestivalis Giraud 1859]\nDie Art wurde bereits von Malpighi (1687: Fig. 52) abgebildet, doch erstmals gültig beschrieben von Hartig (1843: 405) als \"Cynips lucida Kollar (in litt.)\"; Kollar fand die Gallen auf Querc. pubescens.\nBildet in der agame Generation an Zweigen von Eichen (Quercus pubescens, Q. petraea, Q. robur) haselnußgroße Igel-Gallen (\"Hedgehog gall\"). Die kugelige, mehrkammerige holzige Galle ist dicht bedeckt mit zahlreichen dünnen, geraden, 4-8 mm langen, radiär igelig abstehenden Stachelfortsätzen, deren Spitze keulenartig etwas verdickt ist. Eine transparente Substanz am Ende der Kolbenfortsätze gibt der anfänglich grünen Galle ein glänzendes Aussehen. - [Buhr 1965: Nr. 5541; Pellizzari 1988: 108; Bernardi et al. 1997: 120, Fig.12; Csóka 1997: 86/87; Redfern 2002: 403, Fig.675; Dalla Torre \\& Kieffer 1910: 503, Fig. 268 (A. lucidus lucidus), Fig. 269 (A. lucidus erinaceus)]. Auch Buhr (1965: 946) unterscheidet zwischen der größeren A. lucidus lucidus Htg. (Nr. 5464) und einer kleineren Gallenform, A. lucidus erinaceus Kffr. (Nr. 5465), mit Fortsätzen von 2-4 mm. - Die Sexualgeneration (bekannt als A. aestivalis Giraud) bildet üppige Büschel von Gallen an Kätzchen-Stielen von Q. cerris (vgl. Redfern et al. 2002: 415, Fig. 726; Bernardi et al. 1997: 160, Fig. 32). - Fehlt in Spanien, wo auch die Zerreiche fehlt. - Die agame und die bisexuelle Generation werden oft noch als verschiedene Arten geführt (vgl. Pagliano 1995,\n\n--- Seite 75 ---\nBernardi et al. 1997). - In Mittel- u. Südosteuropa verbreitet; mehrfach aus Italien gemeldet [Checkl. Ital., 1995: Nr. 13/35 a+b (A. lucidus + erinaceus) und Nr.13/02 (A. aestivalis)]. In Italien bekannt aus Toskana, Friaul-V.Giulia, Veneto, Ligurien, Emilia-Romagna, Lazio und Sizilien (Bernardi et al. 1997: 120, Fig. 12). - Mittelitalien: A. lucidus lucidus: \"Gli Insetti di Roma\" (Zapparoli 1997: 316). - FVG: vom Triestiner Karst ältere und rezente Fundangaben der agamen Form (A. l. lucidus) durch GrÄFFE (1905: 39-40, T. II, n. 5) und Tomasi (1996: 33; 2006: 21, 69), sowie der sexualForm (A. aestivalis) durch Tomasi (2006: 66).\nIm Trentino wurde A. lucidus (agam) erst rezent neu nachgewiesen: Rovereto ( 350 m ), Eichenwald, zwei alte Gallen (erinaceus) an Q. pubescens, 05.04.2005 (leg. C. Salvadori \\& K. Hellrigl) (Abb. 55). - Hier weitere 2 Gallen am 25.09.2005 an Quercus (leg. Hellrigl \\& H.Bellmann). - In Pomarolo-Servis (IT-04: 700 m ), 14.10.2007, 7 Gallen an Q. pubescens, davon an zwei Zweigen 3 frische Gallen vergesellschaftet mit 3 Gallen von A. quercustozae, leg. Hellrigl \\& Mörl (Abb. 55). Hier weiters am 19.07.2008 an Flaumeiche vier vorjährige Stachelgallen und am 26.07.08 noch 3 Gallen an Eiche mit zahlreichen Gallen von A. quercustozae (leg./Foto Hellrigl). Hier am 07.09.2008 noch eine vorjährige sowie 3 frische grüne Igelgallen (Ø 15-18 mm), davon zwei an Zweig mit $A$. quercustozae und eine angewachsen an Medusenhauptgalle (vgl. Abb.); einige frische grüne A. lucidus-Gallen waren noch nicht ganz ausgereift und wurden belassen. Weitere 6 diesjährige Stachelgallen wurden in PomaroloServis am 12.10.2008 gesammelt, davon eine noch grün und mit klebrigen Stacheln (leg. Hellrigl \\& Schanung). - Die Igelgallen im Trentino haben einen Durchmesser von 11-18 mm (meist 15-16 mm); hingegen sah ich lucidus-Gallen aus Ravenna (S. Lorenzo, Fraz. di Lugano: leg. C. Salvadori, 2005) von doppeltem Gesamtdurchmesser ( 32 mm ) und einer Stachellänge bis 8 mm (vgl. Abb. 55b).\nDie bisexuelle Generation, A. aestivalis Giraud $Q \\stackrel{\\sim}{\\sim}$, wurde erstmals bei Pomarolo-Servis (IT-04), am 12.10.2008, 2 Gallen ( $30 \\times 25 \\mathrm{~mm} ; 17 \\times 15 \\mathrm{~mm}$ ) an unteren Kronenästen höherer Zerreichen gefunden (leg. Hellrigl \\& Schanung). Wahrscheinlich ist diese Galle im Frühjahr hier gar nicht so selten, doch\nwegen ihrer anfänglich grünen Färbung kaum zu entdecken, später nach Reifung und Bräunung bricht der Stiel der Büschelgalle leicht ab und sie fällt zu Boden; man müsste sie dort suchen (Abb. 55a).\nErstmeldung der Art für die Region TrentinoSüdtirol: im Trentino sind Igelgallen etabliert an Standorten wo auch Zerreiche vorkommt (Rovereto, Pomarolo). In Südtirol im Freiland wohl nur zu erwarten im Eichenhain von Castelfeder, doch dort noch nicht nachgewiesen. In Südtirol einmal temporär eingeschleppt in Brixen (wo Zerreiche fehlt), an angepflanzten Stieleichen (Abb. XVIa) am nördl. Eisackuferweg 12.11.2006, 4 Igelgallen von A. lucidus (leg. Hellrigl \\& Mörl); die Stieleichen (Quercus robur ,Fastigiata') waren im Frühjahr 2006 aus Toskana (Pistoia) importiert worden.\n[56] [Andricus malpighii (Adler 1881)\n\n- Kleine Spindelgalle]\n( $Q \\stackrel{\\sim}{\\sim}=$ Andricus nudus Adler 1881\n- Kleine Nacktgalle)\n\nBildet in der agamen Generation an Eichen (Quercus robur, Q. petraea, Q. pubescens) eine A. callidoma ähnliche, aus einer Knospe hervorgehende, spindelförmige Galle ( $6-10 \\mathrm{~mm}$ ); im Gegensatz zur langgestielten Galle von A. callidoma, ist die „Kleine Spindelgalle\" aber $\\pm$ sitzend (\"Malpighi's gall\"). Galle erscheint erst im September.-[vgl. Abb.: BuHR 1965: p. 935; T. 15: Fig. 232; PfütZEnReiter 1958: Nr. 21 ( $Q$ Q Kleine Spindelgalle); Nr. 55 ( $Q$ Q Kleine Nacktgalle); Nieves Aldrey 2001: 367; Figs. 128 L, 141 F; Redfern et al. 2002: 405, Fig. 685]. - Sexualgeneration (A. nudus) kleine eiförmige Gallen an den Blütenkätzchen von Q. petraea [Dalla Torre \\& Kieffer 1910: 489-490, Fig. 234 (A. nudus), Fig. 235 (agam. Gen.: A. malpighii); vgl. Melika et al. 2000: 275, Fig. 34].\nIn Mittel-, Süd- und W-Europa weit verbreitet. In Checklist Ital. (1995: Nr. 13/39, als A. nudus) für N-Italien angegeben. In FVG: vom Triestiner Karst wenige Angaben über Knospengallen von Andricus malpighii - nudus an Quercus durch GrÄFFE (1905: 37-38) zitiert von Tomasi (1996: p.34, Nr. 39).\nIn FVG auch vom \"Parco Naturale Regionale Prealpi Giulie\" gemeldet (Tomasi 2007: 131). Diese Art sollte in Südtirol-Trentino ebenfalls zu erwarten sein.\n\n--- Seite 76 ---\n57 Andricus mayri (Wachtl 1879) [agam] [Syn. = Andricus panteli Kieffer 1897]; [= Andricus panteli fructuum Trotter 1899]\n9. Andricus grossulariae Giraud 1859: valid name Systematik, Synonymie, Verbreitung und Bionomie von Aphilothrix mayri Wachtl 1879 wurden erst rezent abgeklärt. Bis vor kurzem war von Andricus mayri nur die agame Form identifiziert, die an Zweigen (seltener an Früchten) div. sommergrüner Quercus spp. eine mehrkammerige Galle bildet, von der breite, $\\pm$ konische, 5-15 mm lange, längsgestreifte Fortsätze ausgehen; die Gallen sind anfangs grün und glänzend-klebrig. Im Unterschied zu den grazilen Igel-Gallen von A. lucidus (Htg.) setzen die Fortsätze breit an der Gallenbasis an, wo sie sich berühren bzw. durch Furchen getrennt sind, um sich dann distal zu verjüngen. Die sich später schwärzenden und schrumpfenden Spitzen können anfangs kolbig verbreitert sein [vgl. Nieves-Aldrey 2001: p. 630, Fig. 142 B. - Csóka 1997: 116-117. Redfern et al. 2002: 415, 419, Fig. 743 (als A. grossulariae Gir. $89=A$. mayri Wachtl 99 ].\nBuHR (1965: p. 946) gibt eine analoge Beschreibung der Galle von A. panteli Kffr. (Nr. 5467) und weist auf die recht ähnliche, jedoch kleinere Galle von A. mayri (Nr. 5522) hin. [Dalla Torre \\& Kieffer 1910: 502-503, Fig. 264-265 (A. panteli), Fig. 267 (A. mayri)]. Nieves-Aldrey (2001: 391, 538; Fig. 127 C-D, 142 B) zieht beide Taxa als Subspezies zusammen: die f. typica soll mehr mittel-europäisch (Österr., Ungarn, Rumänien), die größere forma panteli circummediterran verbreitet sein.\nDie Sexualgeneration von A. mayri war lange unerkannt. Rezent wurde von engl. Autoren (WALKER 2002) als zugehörige Sexualform A. grossulariae Giraud 1859 festgestellt, welche Johannisbeeren ähnelnde Gallen an Blütenkätzchen von Quercus cerris bildet [British Plant Gall Society; Redfern 2002]. Dadurch ergibt sich als Synonymie: Andricus grossulariae ( $<=$ Andricus mayri).\nIn Checklist Ital. (1995) sind A. mayri und A. panteli sowie A. panteli fructuum als getrennte Taxa aus N-Italien angeführt (Nr.13/37 u. 13/41) und ebenso A. grossulariae [sexual] als eigene Art (Nr. 13/27). FVG: vom Triestiner Karst einige Fundangaben der agamen A. mayri durch GrÄFFE (1905: 40-41): ,,A. lucidus und A. mayri sind nicht seltene Arten\nbei Triest, die Gallen finden sich an den Eichen bei Prosecco, Basovizza etc.\"; zitiert von Tomasi (1996: 33, n. 37), der 2006: 69 von Triest nur A. panteli anführt. Später wurde hier auch die damals noch unerkannte Sexualform A. grossulariae Giraud gefunden und gemeldet GrÄFFE (1905: 61) und Tomasi (1996: 29; 2006: 68). Bernardi et al. 1997: 164, Fig. 34, A. grossulariae: Toskana, Trentino-Alto Adige, Lazio, Sicilia.\nDie agame Form [A. mayri] wurde rezent im Trentino nachgewiesen: Rovereto, Eichenwald ( 350 m ), eine Galle an Q. pubescens, XII. 2004 (leg./Foto C. Salvadori) (Abb.57). Weitere 7 Gallen ebendort am 05.04.2005 (leg. Salvadori \\& Hellrigl), zusammen mit Gallen von A. lucidus und A. quercustozae.\nDie Gallen aus Rovereto gehören zur kleineren Form und entsprechen im Aussehen und gemeinsamen Vorkommen mit $A$. quercustozae den Gallen von Nieves-Aldrey (2001: 630: Fig. 142 B). Drei Galle fanden sich jeweils verwachsen mit Gallen von $A$. caputmedusae an Fruchtbechern von Eicheln (Abb. 57b). Aus den Zuchten schlüpften einige Inquilinen (18.09.05). Eine weitere Galle fand ich hier am Zweig von Q. robur, 25.09.2005. - Die agame A. mayri aus Rovereto ist neu für Trentino; in Pomarolo wurde bisher nur die Sexualform gefunden und im Südtiroler Unterland fehlen beide Generationen noch. - Besprechung der Sexualgeneration: siehe Andricus grossulariae Giraud 1859 [vgl. Nr.45].\n[58] [Andricus mitratus (Mayr 1870)]\n[= Cynips glutinosa var. mitrata Mayr]\nVerursacht in der agamen Generation an Zweigen von Eichen (Quercus spp.) flach hutförmige Gallen, anfänglich rot $\\pm$ klebrig, 8-14 mm Ø, bzw. 6-10 mm hoch; unterer Teil hutkrempenartig flach ausgebreitet, zentral aufgesetzter schmälerer Oberteil stumpf kegelförmig [vgl. Buhr 1965: 5455; Della Beffa 1961: 933, Fig. 1345; Csóka 1997: 76/77; Melika et al. 2000: 275, Fig. 36]. - Verbreitung: Mittel- und SE-Europa, bis Klein-Asien: Österreich, Ungarn, Polen, Bulgarien, Rumänien, Griechenland, Italien, Ukraine. - Fehlt in Spanien und Frankreich.\nCheckl. Ital. (1995: Nr. 20/19, C. mitrata Mayr) N-Italien; vielleicht auch im Trentino zu erwarten. Fehlt offenbar in Triest/Istrien, wo GrÄffe (1905: 17) nur \"Cynips glutinosa var. coronata Mayr\" [= Andricus coronatus Gir.] vorfand, hingegen nie\n\n--- Seite 77 ---\n\"Cynips glutinosa var. mitrata Mayr\". Auch Tomasi (1996: 27-29) nennt aus Triest nur A. coronatus mit der von GrÄFFE (l.c.) verwendete Synonymangabe \"Cynips glutinosa var.\" Eine spätere Meldung von Tomasi (2006: 73, Cynips mitrata Mayr), Triest, Duino-Aurisina, 04.04.1994 (Foto), wäre zu überprüfen und verifizieren.\nDie Bezeichnung \"glutinosa\" ist ein Hinweis, dass alle diese Gallen - einschließlich der echten \"C. glutinosa\" - eine klebrige Oberfläche haben. Bei Henschel (1888: 128/129, Fig. 9. Cynips glutinosa) finden sich alle 3 Formen unter einem Namen abgebildet: Fig. 9. oben: C.glutinosa, unten rechts: C.corontata, unten links: C.mitrata. (siehe Abb.Nr.34).\n\n59 Andricus multiplicatus Giraud 1859 9\nDie bisexuelle Generation bildet büschelige Gallen an Triebspitzen von Zerreichen (Quercus cerris). Galle unregelmäßig, bis 25 mm breit, aus der verbreiterten Triebspitze und erweiterten Blattpolstern hervorgehend. Anfänglich (im Mai) gelblichgrün und weich, ab Juni/Juli Galle dunkelbraun und hart, stark behaart, oft völlig von einem Schopf reduzierter Blätter umgeben. Galle im Spitzenteil mit verkümmerten, frühzeitig vergilbenden Blättern, besonders an strauchartigen Zerreichen. - [BuHR 1965: p. 969, Nr. 5543; Pellizzari 1988: 122, Fig.; Bernardi et al. 1997: 142-143, Fig. 23, 24c; Meliкa et al. 2000: 275, Fig. 37]. - Verbreitung: Österreich, Ungarn, Czech., Ital., SE-Europa bis Kleinasien. Fehlt in Spanien.\nIn Checklist Ital. (1995: Nr.13/38) für N-Italien angegeben; Bernardi et al. (1997): Toskana, Veneto, Friaul-Venezia Giulia, Liguria, Emilia Romagna, Sizilien. - Vom Triestiner Karst nicht häufig an Zerreiche durch GrÄFFE (1905: 42-43) gemeldet: „Die Galle hat einige Ähnlichkeit mit der von A. cydoniae, sie gleicht auf den ersten Blick einem zusammengebogenen, aneinandergepreßten Blätterschopf.\" Tomasi (1996: 33, n.38; 2006: 22, 69, Cecidothek FVG) meldet von dort weitere Funde.\n\nNur wenige Autoren berichten über diese wohl oft mit A. cydoniae (vgl. Nr. 35) verwechselte Galle. Die Art war auch für das südliche Trentino, wo Zerreiche vorkommt, zu erwarten. Wurde erstmals bei Pomarolo-Servis (IT-04), am 28.10.2007, 1 Galle\n(40 x 25 x 25 mm ) an Triebspitze von Zerreiche, gefunden (Hellrigl \\& Mörl) (Abb. 59). - Erstmeldung für Trentino und die Region.\n\n60 Andricus paradoxus (Radoszkowski 1866) [= Cynips albopunctata Schlechtendal 1870] Die agame Generation der „Weißfleckigen Eichengalle\" bildet an Knospen vorjähriger Eichentriebe (Quercus petraea, Q. pubescens, Q. robur) schlank eichelförmige bis zylindrisch-walzige, glatte Gallen (bis 8 mm ) von olivgrüner Färbung mit weißlichen Längsflecken. Gallen erscheinen schon zeitig im April/Mai und fallen (nach Eintrocknung) bald ab. - [Buhr 1965: 936, Nr. 5431, T. 15: Fig. 234; Pfützenreiter 1958: 108, Nr. 26, Abb. 21; Meliкa et al. 2000: 275-276, Fig. 38; Nieves Aldrey 2001: p.365; 536; Figs. 128 x, 141 e; Redfern et al. 2002: 408, Fig. 695 (A. albopunctatus)]. - [Sex. Gen. = 98 A. barbotini Folliot 1964]. - In Europa weit verbreitet, aber meist zerstreut vorkommend. In Checklist Ital. (1995: Nr. 13/03) nur für Sizilien angegeben (als A. albopunctatus Schlecht.).\nKieffer (1914: 43) gibt für A. lambertoni Kieff. 1897 eine von albipunctatus abweichende Galle „nicht abfallend, holzig\" an (Taf. I, Abb. 16), sowie: Eistiel 9 mal so lang wie der Eikörper (p. 61).\nErstnachweis für N-Italien und Südtirol-Trentino: Montiggl, 600 m , Monitoringareal (IT-02) an Quercus petraea, 12.05.2005, 4 Gallen (leg. K. Hellrigl \\& A. Fostini) (Abb. 60). An dieser strauchigen Eiche fanden sich auch Gallen von A. quercusramuli. Aus den Gallen schlüpften am 25.-26.05.2005 div. Inquilinen und Parasitoiden (1 Synergus gallaepomiformis +16 S. umbraculus +10 Eulophidae).\n\n61 Andricus polycerus (Giraud 1859)\n[Syn.: = Cynips subterranea Giraud 1859;\n$=$ Cynips trinacriae Stefani 1906]\nBildet an Zweigen von Eichen (Q. robur, Q. petraea, Q. pubescens) verkehrt kegelförmig bis glockige Knospengallen, 12-15 mm lang, oberes Ende breit abgeflacht und etwas konkav, mit $\\pm$ scharfem Rand und einigen auswärts gerichteten spitzen holzigen Zipfeln (Abb. 61). Die agame holzige Galle ist anfänglich grün; sie reift im Spätsommer/Herbst und hat dann braune bis rotbraune Färbung; mit großer kugeliger Innengalle. Über eine Sexualgeneration und deren Gallen ist nichts bekannt.\n\n--- Seite 78 ---\n[BuHR 1965: 945, Nr. 5463, T. 15: Fig. 243-245; CsóKA 1997: 82; Bernardi et al. 1997: 114, Fig. 9; 122: Fig. 13; MeliKa et al. 2000: 276, Fig. 40]. - Südliche bis mitteleuropäische Art. - Verbreitung: Österreich, Ungarn, Tschechien, Slowakei, Deutschland, Polen, Rumänien, Bulgarien, Griechenland, Italien [Fauna Europaea: 2007]; fehlt in Britannien, Nord- und SW-Europa (Schweiz, Frankreich, Spanien).\nIn Checklist Ital. (1995: Nr. 13/42) wird A. polycerus (Gir.) für N-Italien und aus Sizilien angegeben, sowie unter drei weiteren Synonymen für Sizilien: Nr. 13/52 A. subterranea (Giraud 1859), Nr. 13/55 A. transversa (Kieffer 1900), Nr. 13/57 A. trinacriae (Stefani 1906). - In Italien bekannt auch aus Latium, Toskana, Emilia-Romagna, Ligurien, Veneto, Friaul-Venezia Giulia (Bernardi et al. 1997: 100). In FVG vom Triestiner Karst Gallenangaben von Q. pubescens durch Gräffe (1905: 18, Taf. II, n. 3): „Die kurzgestielte, glockenförmige Galle von Cynips polycera ist bei Triest auf dem Karste ziemlich selten zu finden.\" Tomasi (1996: 35, Nr. 41) zitiert Funde von Gräffe 1905 nach Gallenbelegen der Cecidothek FVG (vgl. Tomasi 2006: 20, 69-70) nebst weiteren eigenen Fundbelegen.\nWar aus der Region Trentino-Südtirol bisher nicht bekannt gewesen. Hier erstmals gefunden im Zuge einer rezenten Neuanpflanzung von Alleebäumen am nördlichen Eisackufer in Brixen-Zinggen, wo im Frühjahr 2006 einige Stieleichen (Pyramidenform: Q. robur ,Fastigiata‘) aus einer Baumschule in der Toskana (Pistoia) importiert worden waren: es fanden sich an diesen 6-8 m hohen Bäumen im Herbst (26.11.2006) zahlreiche Gallen hier bisher nicht heimischer Gallwespen (siehe auch: Andricus aries, A. coriarius, A. kollari, A. lucidus, A. quercustozae), darunter auch Andricus polycerus: 1 Zweig mit 3 Gallen und 1 Zweig mit 4 Gallen (leg. Hellrigl \\& Mörl). - Vier weitere vorjährige polycerus-Gallen (10-15mm) fanden sich hier in Brixen (nördl. Eisackufer) am 04.08.2008, an im Frühjahr 2008 nachgepflanzten, aus der Veneto stammenden Stieleichen (Quercus robur) (leg. Hellrigl \\& Mörl) (Abb.61). - Unerwartet wurde A. polycerus dann noch am 17.08.2008 auch im Südtiroler Unterland in Castelfeder nachgewiesen (leg. Hellrigl \\& Schanung): 7 vorjährige Gallen ( $9-12 \\mathrm{~mm}$ ) an abgestorbenen dünnen Zweigen einer Flaumeiche in Sichtweite einer großen Zerreiche\n(Abb.61b). Damit war der Nachweis erbracht, dass die Art in der Region Trentino-Südtirol, in Gebieten mit Zerreiche, auch bodenständig vorkommt. Es gelang dann noch ein weiterer Nachweis für Trentino: am 07.09.2008 bei Rovereto-Dossi (Bosco della città) eine teilweise noch grüne Galle ( 11 mm ) am Zweig einer Flaumeiche, leg. Mörl \\& Hellrigl (Abb. 61c).\n\n62 Andricus pseudoinflator Tavares 1901\nEin umstrittenes Taxon, das von Tavares 1901 aus Spanien beschrieben wurde und von NievesAldrey (2001: 359) als auf die iberische Halbinsel beschränkt gehalten wird, kommt dort verbreitet an Quercus faginea ( $=$ Q. pubescens) vor. Von anderen Autoren wird pseudoinflator für ein mögliches Synonym von A. inflator gehalten (so z.B. Mielka et al. 2000: 276, für Ungarn). Nach Buhr (1965) eine seltene, südeuropäische Art, die auch für das südliche Mitteleuropa angegeben wird (z.B. Ungarn: Balas 1941; Polen: Kierych 1971). - In Fauna Ital. (1995: Nr. 13/44) nur für Sizilien angeführt. - In Fauna Europaea (2007) nur für die iberische Halbinsel (Andorra, Portugal, Spanien) und Frankreich angegeben, hingegen als fraglich für Sizilien, Ungarn und Polen.\nDie Galle der bisexuellen Generation an Triebenden von Eichenzweigen ( $Q$. pubescens, $Q$. robur) ist nach BuHR (1965: 925, Nr. 5382) sehr ähnlich der von $A$. inflator, aber deutlich kleiner (nur bis 6 mm lang und 5 mm dick) - gegenüber der inflator-Galle, die 15 (20) mm lang und 8 (10) mm dick ist; d.h. mit dick keulenförmiger Anschwellung, in der Mitte mit länglichem, schmalen, zuletzt oben offenem Kanal, an seinem Grunde eine kleine, ovale, nur am oberen Ende freie Innengalle.\nIn Südtirol fand ich am 17.08.2008 in Castelfeder/ Auer an einer Flaumeiche mehrere dünne Zweige deren Blattstielbasen auffällig angeschwollen und filzig behaart waren, sowie am oberen Ende der Anschwellung ein offenes Loch hatten, das sich unten als zylindrischer Gang fortsetzte (vgl.Abb. 62). Ungewöhnlich war auch, dass diese Gallen sich nicht wie bei inflator endständig an der Zweigspitze befanden [vgl. Nr. 51], sondern reihig mehrere Blätter untereinander längs der Sprossachse betrafen: an 7 Zweigen fanden sich jeweils 3 solcher Gallen, insgesamt 20 Gallen. Die Größe der Gallen lag\n\n--- Seite 79 ---\nmit 6-7 mm Länge und $5 \\mathrm{~mm} \\varnothing$ deutlich unter den angegebenen bzw. selbst gesammelten Gallen von A. inflator [vgl. Nr. 51]; ich halte diese Gallen für solche von A. pseudoinflator.\n[63] [Andricus quadrilineatus Hartig1840]\n[= A. ambiguus Schenck 1863;\nA. verrucosus Schenck 1863];\n[= Cynips marginalis Schlechtendal 1870]\n( $9 \\delta$ = Andricus kiefferi Pigeot 1900)\nDie agame Generation bildet an Blütenkätzchen von Eichen (Q. petraea, Q. robur) kleine ovoidale, längsgefurchte „Runzelige Blütengallen\" (3-4 mm), in der UK-List of Cynipidae als \"Furrowed-catkin gall causer\" bezeichnet; bisweilen an Eichenblättern auch kegelförmige „gerillte Blattrandgallen\" (= Cynips marginalis Schlechtd.); Gallenreife im Mai. [Buhr 1965: Nr. 5477; T. 16, Fig. 250: „gerillte Blattrandgallen\"; Nr. 5527; T. 17, Fig. 281 (2) „runzelige Blütengallen\"; Pfützenreiter 1958: Nr. 51, Abb. 44; Csóka 1997: 116/117; Melika et al. 2000: 276, Figs. 42; Nieves-Aldrey 2001: 362, 536; Figs. 126 O-P, 141 D; Redfern et al. 2002: 416, Fig. 733. - H.-J.Buhr: 2007: \"Runzelige Blütengalle\", Foto: Bellmann, Ulm, Mai 2006]. - Sexualgeneration mit „glatten Blütengallen\" an Blütenkätzchen von Q. robur [Nieves-Aldrey 2001: 363; Figs. 126 I]; Zyklus mit fakultativer Heterogenie.\nMehr in Nord- und Mitteleuropa verbreitet, örtlich oft in Anzahl (Buhr 1965: 964: Nr. 5527); teilw. auch in Südeuropa (Spanien, Italien), in weit südlichen Regionen oft fehlend [Kieffer 1901: 463, Andricus marginalis Adl.; D. T. \\& Kieffer 1910; Nieves-Aldrey 2001], wie etwa am Balkan. - Fehlt in Checkl. Ital. (1995). - Eine rezente Meldung von Tomasi (2007: 131) aus den Prealpi Giulie ist noch zu verifizieren.\nSollte in Südtirol zu erwarten sein, wurde hier aber trotz gezielter Suche im Apr./Mai 2005/06 weder im Unterland (Castelfeder) oder Überetsch (Kaltern), noch im Eisacktal (Brixen Umg.) gefunden und ebensowenig 2007/08 im Trentino bei Rovereto und Pomarolo.\n\n64 Andricus quercuscalicis (Burgsdorff 1783) $9{ }_{9} 9$ [= Cynips calicis Burgsdorff (Hartig 1843)]\n(9) Cynips cerri Beyerinck 1895) = A. beyerincki Trotter 1899\n\nDie agame Generation erzeugt an den Früchten von Stieleichen (Quercus robur) wuchernde Gallenbildungen mit 5-7 Längskielen, sog. „Knoppern\", die vom Fruchtbecher der Eicheln ausgehen und oft die ganze Eichel bedecken: „Knopperngallwespe\" (= \"Knopper gall causer\"). Die Knoppergalle ( $\\varnothing$ 15-25 mm) ist anfänglich grün mit glänzendklebriger Oberfläche, Ende August wird sie braun und fällt mit der Eichel ab. [Della Befra 1961: 933, Fig. 1344; Buhr 1965: Nr. 5537, T. 17, Fig. 285; Pfützenreiter 1958: 122-123, Nr. 58-59, Abb. 47 (sex.), 49 (agam); Gauss 1982: 252; Zahradnik 1985: 83; Chinery 1987: 228; Amann 1990: 87; Csóka 1997: 124-125; Melika et al. 2000: 276, Fig. 43; Redfern 2002: 418, Fig. 742]. - Sexualgeneration: kleine, eiförmige Blütengallen im Staubbeutel der Blütenspindel, an Quercus cerris.\nIn West-, Mitteleuropa sporadisch, in Südosteuropa und Kleinasien weit verbreitet; auch in Italien (Checklist 1995: Nr. 13/45, sowie 13/04 als A. beyerincki); Bernardi et al. (1997: 106): Toskana, Piemont, Trentino-A.A., Emilia Romagna, Sizilien. - Fehlt mit Q. cerris in Spanien (Nieves-Aldrey 2001). - Seltsamerweise wird die Art vom Triestiner Karst nicht gemeldet, obschon dort in den Eichenwäldern die Wirtsarten Quercus robur und cerris vorwaltend sind (GrÄFfE 1905; Tomasi 1996). Später bringt Tomasi (2006: 70) aus FVG eine Meldung aus Udine, Cividale, Bosco Romagno, 150 m , Bertrandi, 11.08.1999. - Dalla Torre (1892-96) erwähnt sie nicht aus Tirol; von Cobelli (1903: 165) für Trentino angeführt (als Cynips calicis), doch wurden aus Trentino (Rovereto, Pomarolo) bisher keine rezenten Funde bekannt, wohl auch weil es dort kaum Stieleichen gibt, die nach Hartig (1843: 400) u.a. Autoren bevorzugt werden.\n\nUnerwartet gelang in Südtirol ein rezenter Neunachweis in Brixen (nördl. Eisackufer), am 06.08.2008, zehn frische grüne, lackglänzend klebrige Knopperngallen von 25 mm (Abb. 64a) an im Mai 2008 aus Bassano importierten, hier angepflanzten, 6 m hohen Stieleiche (Q. robur) (leg. Hellrigl \\& Mörl). Ein natürliches Vorkommen in Südtirol ist fraglich, da hier sowohl Zerreiche als Zwischenwirt weitgehend fehlt und andererseits auch die Stieleiche, als typische Trägerin der Knoppern, nur sehr sporadisch vorkommt, bzw. rezent eingeführt wurde. Knoppern können nach Riedel (1910: 56) u.a. nur\n\n--- Seite 80 ---\ndann entstehen, wenn in der Nähe der Stieleichen sich auch Zerreichen befinden. Möglicherweise ist diese „Wirtswechselbindung\" aber weniger rigoros als meist angenommen; d.h. sie kommt nach Möglichkeit zwar regelmäßig zustande, kann aber bei Fehlen des bisexuellen Zwischenwirtes (Zerreiche) auch in Form agamer, parthenogenetischer Generationen fortgeführt werden. Solches ist schon lange bekannt bei Andricus kollari-Gallen und ist mir selbst in Brixen Umgeb., wo Zerreiche fehlt, sowohl bei A. kollari untergekommen, als auch bei dem ebenfalls wirtschaftselnden Andricus lignicolus. Mancherorts in M.E. oft massiver Befall, wie etwa 2006 in Stuttgart (Rosensteinpark), wo die Zweige der Stieleichen durch das Gewicht der KnoppernGallen teilweise bis zum Boden herab hingen (pers. Mitt. H. Bellmann, 2007). Auch in Österreich fand ich in Kärnten, am Millstätter-See, Ende Aug. 2008 zahlreiche frisch abgefallene Knoppern-Gallen unter einer alten Stieleiche im Park am See ( 600 m ). In fünf Tagen wurden hier 425 Knoppern gesammelt (Abb.64b), dabei gab es in Millstatt keine Spur von Zerreiche.\nErgänzend dazu teilt Mag. Dr. Helmut Zwander (Botaniker und Präsident des Naturwiss. Vereins Kärnten) Herrn Dr. Kofler Mitte Nov. 2008 mit, dass in Südkärnten rezent sehr zahlreiche (Tausende) dieser „Koppern-Gallen\" an vielen Stieleichen (Quercus robur) beobachtet wurden, wobei an sämtlichen Fundorten in Kärnten keine Quercus cerris wächst! (Briefl. Mitt. von Dr. A. Kofler: 22.11.08).\n\nDasselbe berichtete zuvor Dr. A. Kofler aus Lienz/ Osttirol (i. litt. 08.10.08), wo sich bei Schloß Bruck unter Stieleichen (Abb. 64c) zahlreiche Knoppern fanden (Erstnachweis für Osttirol); hier sammelten wir gemeinsam noch Ende Okt. 2008 an die 50 Knoppern unter den Stieleichen, dabei keine Spur von Zerreiche. - Die harte Knopperngalle enthält innen eine lose, erbsenförmige Innengalle ( $\\varnothing 5 \\mathrm{~mm}$ ), in der die (oft) schon im Herbst entwickelte Gallwespe sitzt, die nach Überwinterung im Febr./März schlüpft. Ende des 19.Jh. hatten die „Knoppern\" wegen ihres hohen Gerbstoffgehaltes eine große Bedeutung für die Gerberei und und der Handel mit ihnen stellte einen wichtigen Wirtschaftsfaktor dar.\n\n65 [Andricus quercuscorticis (Linnaeus 1761) $90^{\\circ}$ (= Cynips corticis Hartig 1840)\n\n- Große Rindengalle;\n\nVerursacht in der agamen Generation an Eichen (Q.petraea, Q.pubescens, Q. robur) kegelförmige, nicht längsgefurchte Gallen [im Gegensatz zur „Gefurchten Kegelgalle\" Andricus sieboldi (Htg.) $=$ A. testaceipes auct, nec Hartig] an überwallten Rindenverletzungen dicker Stämme und stärkeren Zweigen (\"Bark-gall causer\"). - Gallen der Sexualgeneration klein, unauffällig, an Jungtrieben (\"Budgall causer\"). - [BuHR 1965: 924, Nr. 5379; p. 927, Nr. 5391; p. 972, Nr. 5553 A.; PfütZenreiter 1958: Nr. 3, Abb. 3 (agam); Gauss 1982: 249; NievesAldrey 2001: 375, 537; Fig. 125 h; Redfern et al. 2002: 400, Fig. 663; H.-J.BuHR 2007: Pflanzengallen, \"Große Rindengalle\" (Foto: H. Bellmann, Ulm, XI.2006)]. - In weiten Teilen West- und Mitteleuropas verbreitet, aber nur lokal häufiger. Fehlt in Checklist Italiens (1995). - Auch aus Tirol und Österreich bisher keine Meldungen bekannt.\n\n66 Andricus quercusradicis (Fabricius 1798)\n$=$ Cynips quercus radicis Bosc 1794: Journ. Phys. Fig.- Große Eichen-Wurzelgalle: Ref.: Réaum. 1737: T. 44 - Senior name: A. (Cynips) radicum (Geoffroy 1785: 385)\n$=$ Cynips radicis Hartig 1841 (agam);\n$[=$ A. trilineatus Hartig 1840: 191 (sex.)]\n[= 9 9 Andricus noduli Hartig 1840: 191]\n[= 9 Andricus petioli Hartig 1843: 407]\nVerursacht in der agamen Generation an Eichen (Q.petraea, Q.pubescens, Q. robur) vielkammerige, bis 7 cm große, kartoffel- od. trüffelähnliche Wurzelgallen (\"Truffle gall causer\") nahe der Oberfläche am Stammfuß. - Gallen der Sexualgeneration ( $=$ A. trilineatus Htg. $=$ A. noduli Htg.), im Juni-August, in verbreiterten knotigen Triebdeformationen (\"Knot gall causer\"). - [Сsока 1997: 80-81; RedFERN et al. 2002: 400, Fig. 661 (99 \"truffle gall\"), 402, Fig. 670 (9 \" \"knobbly gall\")]. - Nach PfütZENREITER 1958: Nr. 1, Abb. 1 agam; Nr. 7, Abb. 5; BuHR 1965: 927; T. 15: Fig. 226; Gauss 1982: 247, Fig. 106; Meliкa et al. 2000: 277, Figs. 45a-c (bisex. gen.), Figs. 45d-e (agam. gen.); Nieves-Aldrey (2001: 379, 538) u.a. ist die „Eichen-Knötchengalle\" A. trilineatus Htg. die Sexualform der „Großen\n\n--- Seite 81 ---\nEichen-Wurzelgalle\" A. quercusradicis F. - Die von Kollar [in Wien] aus den Blattstielen der Stiel- und Traubeneiche gezogene \"Andricus petioli Kllr. (in lit.)\" (1) [Hartig 1843: 407] wurde von Kieffer (1901) und Mayr (1870) als Synonym der sex. Form von A. quercusradicis angesehen.\nIn Checklist Ital. (1995: Nr. 13/46 und 13/56) werden A. quercusradicis und A. trilineatus als getrennte Taxa geführt. Aus Triest/Istrien wird die Art von Gräffe (1905) und Tomasi (1996) nicht erwähnt; erst später erfolgen Meldungen für FVG aus Triest, Bosco Farneto (12.04.1995) (Tomasi 2006: 69) sowie den Prealpi Giulie (Tomasi 2007: 131). Von Dalla Torre (1894) Gallen von Andricus trilineatus Htg. aus N-Tirol angegeben von Quercus pedunculata: Volderwald bei Hall, Sept. 1893. Von Cobelli (1903: 165) als A. trilineatus Htg. auch aus Trentino angeführt. Beide Gallenformen sollten in der Region Südtirol-Trentino nicht selten sein.\nRezente Nachweise von „Knötchengallen\" (am Zweig, auch auf Blattstiel übergreifend) in Südtirol: Neustift, an Q.petraea, Okt. 2004 und Tschötsch, Q. pubescens, VI. 2005 (leg. Hellrigl) (Abb. 66); auch Pinzon-Montan, 10.07.2005, an Q.petraea, 2 befallene Zweige (leg. Hellrigl). - Nach den typischen „Wurzelgallen\" der agamen Generation (mit den Fingern zu ertasten im Boden am Stammfuß jüngerer Eichen) wurde hier bisher noch nicht gezielt gesucht [vgl. H. Bellmann: Foto 2006].\nAnmerkung: Bei Beschreibung der Wespe und Galle beruft sich Fabricius 1798 auf eine bereits 4 Jahre frühere homonyme Benennung von Bosc 1794. Es ist müßig zu überprüfen ob diese Beschreibung vielleicht ein Nomen nudum war, denn es gibt noch einen älteren binomialen Namen für die Gallenbeschreibung: Cynips radicum (Geoffroy in Fourcroy 1785: 385, n. 17), wo für diese \"Cinips de la galle ligneuse des racines\" als Loc. angegeben wird: Insectum incognitum, Galla sola noscitur. - Diese Galle hatte zuvor bereits Geoffroy (1762: 302) nomenklatorisch ungültig beschrieben als 17. \"Cynips gallae ligneae radicum\", unter Referenz auf die Abb. von „Réaumur 1737: T. 44: Fig. 6-8\", in der eben diese „Große Eichenwurzelgalle\" unverkennbar abgebildet ist. Vor 1930 waren Artbeschreibungen nur nach den Gallen aber gültig (ICZN).\n\n67 Andricus quercusramuli (Linnaeus 1761) 98 [= Teras amentorum Htg. 1843, sex.]\n„Baumwollgalle\"\n[= C. autumnalis Hartig 1840, agam]\n„Weißfußgalle\"\nSexualgeneration im Frühjahr in wattigen, gelblichweißen „Baumwollgallen\" an männlichen Eichenkätzchen (\"Cotton-wool gall causer\"). - [vgl.: ChinerY 1987: p. 228; BuHR 1965: T. 17, Fig. 276; Pfützenreiter 1958: 108, Nr. 27, Abb. 20 (agam); Csóka 1997: 120; MeliKa et al. 2000: 277, Fig. 46a (bisex. gen); Nieves-Aldrey 2001: 370; Figs. 126 L, 141 H; Redfern et al. 2002: 407, Fig. 691 (99 autumnalis), 415, Fig. 727 (ơ9 \"cottonwool gall\")]. - Agame Generation bildet im Herbst an jungen Trieben von Traubeneiche (Q.petraea) Knospengallen (\"The autumn-gall causer\"); die länglichovale Galle glatte ( 5 mm ) teilweise von Knospenschuppen verhüllt, im oberen Teil glänzend grün bis rotbraun, im verjüngten unteren Teil weiß gefärbt („Weißfußgalle\") [Abb.: Bellmann 2006].\nDie nicht häufige Art wird auch aus N-Italien gemeldet (Checkl. Ital.,1995: Nr. 13/47). Aus Triest Umg. werden „Baumwollgallen\" von GrÄFfE (1905: 35-36, Andricus autumnalis - ramuli) hie und da in den Waldungen kleiner Eichenbäume bei Muggia und Noghera gemeldet. Hingegen sind zahlreiche weitere Fundangaben aus Triest/FVG durch E. Tomasi (1996: 35-36, Nr. 42: sub \"A. quercusramuli\") alle auf Verwechslung mit A. caputmedusae zu beziehen, wie aus der Gallenbeschreibung und Abb. \"Tab. C-7\", sowie den jahrezeitl. Funddaten hervorgeht. Auch Tomasi's Literaturzitat \"GräFfE (1905: Taf. II, n. 13)\" betrifft nicht \"A. quercusramuli\" sondern A. caputmedusae; desgleichen spätere Meldungen aus Triest/Dolina (Tomasi 2006: 69) sowie den Prealpi Giulie (Tomasi 2007: 131).\n\nDie auffälligen „Baumwollgallen\" im Frühjahr wurden rezent auch in Südtirol gefunden, einmal bei Montiggl, Monitoring-Areal (IT-02: 550 m ), einige Gallen (Abb. 67) an strauchartiger Q.petraea, 28.04.2005 (leg. Hellrigl \\& Fostini); aus 3 gesammelten Gallen schlüpften bei der Aufzucht nur Parasitoide (Eulophidae). - Neu für Südtirol; auch im Trentino zu erwarten!\n\n--- Seite 82 ---\n68 Andricus [Cynips] quercustozae (Bosc 1792)\n$=$ Cynips quercustojae Bosc: Fabricius 1793\n(lapsus);\n[Cynips tozae (Bosc) auct. $=$ C. argentea Hartig 1843]\nDie agame Generation verursacht 2-4 cm große harte Kugelgallen (im oberen Drittel mit kreisförmig angeordneter Höckerreihe oder Stachelkrone) an Zweigen von Quercus pyrenaica ( $=Q$. toza), Q.pubescens, Q. petraea, Q. robur. Die unverkennbaren Gallen (\"Phallus gall\") anfangs gelblichgrün, außen klebrig, im August verholzend und kastanienbraun, ältere Gallen $\\pm$ silbergrau ( $=$ C. argentea Htg.). - Sexualgeneration nicht bekannt, vermutlich an Quercus cerris/suber. - [Buhr 1965: p.937, Nr. 5433; 5453; Csóka 1997: 82-83; Pellizzari 1988: 110; Nieves-ALDREY 2001: 401, 539; 127 J-K, 142 D-E; Melika et al. 2000: 279, Fig. 47]. - Checkl. Ital. (1995: Nr. 13/48; 20/03) als A.quercustozae und Cynips argentea Htg. - Bernardi et al. (1997: 116, Fig. 10): ganz Italien.\nDie große Galle wurde schon von Malpighi [1687: Fig.48-49] unverkennbar abgebildet, Hartig (1843: 401-402) hatte Wespe und Galle von Kollar von Q. pubescens aus Wien Umg. und von v. Siebold aus Istrien erhalten und als \"Cynips argentea m.\" beschrieben.\nDie im südlichen Mitteleuropa und in ganz Südeuropa von Spanien bis zum Balkan sowie auch in der Türkei (Schimitschek 1944) verbreitete stattliche Eichenzweig-Gallwespe wird von Dalla Torre (1892-96) aus Tirol nicht erwähnt und auch von Bezz1 (1888) und Cobelli (1903) nicht aus Trentino. Es ist bemerkenswert, dass diese älteren Autoren keine Angaben über die unverwechselbaren Gallen der heute im südlichen Trentino relativ häufigen A. quercustozae sowie A. caputmedusae bringen. Hingegen nennt sie Hartig (1843: Cynips argentea), ebenso wie A. caputmedusae (Htg.), von Q. pubescens aus Wien (Kollar) und Istrien (von Siebold). Später vom Triestiner Karst zahlreiche weitere Gallenmeldungen von Quercus durch GrÄFfE (1905: p. 12, Cynips tozae Bosc; Taf. II, n. 7): „In großer Anzahl an den Wolleichen, die in den Karstdolinen wachsen, wie bei Orlek und Nabresina.\" Von hier auch von Tomasi (1996: 36, n. 43) sowie Tomasi (2006: 20, 70) angeführt.\n\nEs fällt auf, dass im Trentino Gallen von A.quercustozae (ebenso A. caputmedusae) dort häufiger sind, wo in der Umgebung Q. cerris vorkommt, die als Zwischenwirt der noch unbekannten Sexualgeneration gilt. Im Trentino ist A.quercustozae rezent nicht selten: im Gardaseegebiet, am Hang des Mte. Baldo, über Malcesine, 3 Gallen ( $25-28 \\mathrm{~mm} \\varnothing$ ) an Eichenzweigen, 25.07.2004, leg. G. v. Mörl. - Erstnachweis in Pomarolo-Servis, MonitoringFläche (IT-04: 700 m ), an Q. pubescens, VII.1992, div. Gallen, sowie X.2004, 1 Galle (Ø 30 mm ) (leg. Hellrigl). In Pomarolo, Sommer 2003, div. Kugelgallen, auch an Zweigen zusammen mit Gallen von A. caputmedusae, A. kollari, A. lucidus (leg. P.Lorenzi, Mus. Rovereto: vid./det. Hellrigl).\nHäufig im Eichenwald bei Rovereto ( 350 m ) an Q. pubescens und Q.petraea, XI/XII. 2004 (40 Gallen leg. P.Ambrosi), daraus im Febr. 2005 einige Imagines und Inquilinen geschlüpft (leg./ coll. Hellrigl).\nIm Stadtwald Rovereto ( 350 m ) wurden am 05.04.2005 zahlreiche alte Gallen an den Eichen beobachtet und an die 100 Gallen aller Größe (von parasitierten Junggallen - von 9-15-18 mm - bis zu reifen Altgallen von 20-25-30-35 mm Ø) gesammelt (leg. C. Salvadori \\& P.Ambrosi \\& K. Hellrigl). Die Gallen fanden sich an niederem Eichengebüsch und auch an hohen Bäumen bis deren Wipfelbereich dort oft vergesellschaftet mit Gallen von A. caputmedusae. An einer buschartigen mannshohen Eiche wurden über 80 alte Gallen gezählt (Abb. IVa). Aus diesen vorjährigen Gallen schlüpften bei Aufzucht keine Gallenbildner mehr, sondern nur Inquilinen und Parasitoiden. Unter den Parasitoiden waren im VII. 2005 auffällig 7 Ex der großen Chalcidide Megastigmus stigmatizans. - In alten verlassenen Gallen hatten sich auch zahlreiche Ameisen eingenistet: div. Gallen waren besiedelt von Dolichoderus quadripunctatus und Camponotus (Colobopsis) truncatus (bis 30 Ex in einer Galle, ca. $15 \\%$ mit „Stöpselkopf\" = Türschließermorphe); in einigen Gallen auch Nestkolonien von Leptothorax affinis.\nZahlreiche frische Gallen von A.quercustozae (vereinzelte noch grün) fanden sich hier weiters am 01.09.2005 (75 Ex. leg. C. Salvadori \\& K. Hellrigl) und am 25.09.2005 (50 Ex. leg. et Fotos Hellrigl \\& H. Bellmann); die Vermessung von\n\n--- Seite 83 ---\n233 Gallenkugeln ( 95 frische +138 alte) ergab eine Größenverteilung von 14-38 mm Ø (Grafik 5+6). Das Schlüpfen der Imagines von A. quercustozae, nach Freiland-Überwinterung der Gallen am Balkon in Brixen, erfolgte im Frühjahr 2006 vom 10.03. bis 26.03.06, jeweils um die Mittagszeit (11-15h) bei Schlüpftemperaturen von $8^{\\circ}-10 / 14^{\\circ}-17^{\\circ} \\mathrm{C}$; bei Tagestemperaturen: Minima: $-2^{\\circ}$ bis $+8^{\\circ} \\mathrm{C}$; Maxima: $+10^{\\circ}$ bis $+20^{\\circ} \\mathrm{C}$. Innerhalb dieser 2 Wochen schlüpften insgesamt $62 \\leftrightarrows$ A. quercustozae.\nBei einer folgenden Untersuchung in Rovereto am 04.08.2006 wurden weiterhin zahlreiche Gallen von A. quercustozae und A. caputmeduasae beobachtet, sowohl alte als auch frische, doch wurden nur einzelne Belege zur Dokumentation gesammelt (leg./ foto K. Hellrigl \\& H. Bellmann).\nHingegen war bei einer späteren Untersuchung in Rovereto am 03.10.2007 ein auffälliger Befallsrückgang zu verzeichnen, von dem neben A. quercustozae auch A. caputmedusae stark betroffen war. Von A. quercustozae wurden nur 10 frische Gallen an 4 Bäume gefunden und zudem 30 alte Gallen zur Vermessung gesammelt (leg. Hellrigl). Es wurde im ganzen Gebiet nur ein einziger alter absterbender Baum gefunden, an dem sich noch massenhaft alte Gallen von A. quercustozae und A. caputmedusae fanden (vgl.Abb. IVb). Diese Eiche war am 07.09.2008 bereits gefällt und entfernt (Parkplatz!), der Gallenbesatz von A. quercustozae und A. caputmedusae war hier weiterhin ziemlich schwach.\nDie Ursache des starken Rückganges bei A. quercustozae in Rovereto blieb unerklärlich, zumal sich auch die Parasitierung in Grenzen hielt. Im Vorjahr waren aus A. quercustozae-Gallen 22 Eulophidae geschlüpft und einige Eurytomidae: Sycophila biguttata (Swed. 1795) und Eurytoma brunniventris; weiters schlüpften an Inquilinen $5 \\leftrightarrows+3 \\varnothing$ Synergus pomaeformis (23.07.06) und 28.06.-10.07.07 aus Junggallen 15 Synergus hayneanus (Ratzeb. 1833). - Noch unerklärlicher war der starke Rückgang bei A. caputmedusae-Gallen, die in den beiden vorhergehenden Jahren (2005/06) zu vielen Hunderten in den Eichenkronen hingen (vgl. Fotos) oder abgefallen unter den Eichen am Boden herumlagen.\nIm Gegensatz dazu stand eine weitere Beobachtung, 2-3 Wochen später, nur 5 km weiter nördlich bei Pomarolo-Savignano, Lokal. Servis, wo am\n14.-28.10.2007 massenhafter Befall von A. caputmedusae und A. quercustozae festgestellt wurde. Hier wurden an manchen Flaumeichen an die 100 Medusenhaupt-Gallen und über 1 Dutzend Gallen von A. quercustozae gezählt (Hellrigl \\& Mörl). An einzelnen Zweigen fanden sich oft bis zu 8-12 Gallen (vgl.Abb. Va). Zu Untersuchungszwecken (Vermessung der Gallen und Feststellung von Erscheinungszeit und Parasitierung) wurden am 14.-28.10.2007 190 Gallenkugeln von A.quercustozae gesammelt. Die Gallwespen waren in der zentralen Larvenzelle im November bereits fertig entwickelt, schlüpften aber im Herbst noch nicht.\nNach Überwinterung der Gallen unter Freilandbedingungen in Brixen, begann das für März erwartete Schlüpfen der Imagines von A. quercustozae bereits Ende Februar 2008: am 24.02.2008 fanden sich bei $+2^{\\circ}$ bis $12^{\\circ} \\mathrm{C}$ Außentemperatur (Schlüpftemperatur $6-10^{\\circ}$ ) und $65 \\%$ Luftfeuchte bereits $45 \\nmid 2$ A. quercustozae in der Zuchtkiste, das war die Hälfte aller bis zum 18.03.08 geschlüpften $90 \\nmid 2$. Am 3. März 2008 wurden $32 \\nmid 2$ lebend nach Pomarolo zurückgebracht und dort wieder ausgesetzt.\nBei einer späteren Freilandkontrolle in Pomarolo am 25.04.2008 wurden im Untersuchungsgebiet (IT-04: 700 m ) nochmals 150 vorjährige Gallen gesammelt, alle bereits mit Fluglöchernder Gallwespen. Oberhalb des forstlichen Monitoringareals ( 750 m ) wurde ein angrenzender Flaumeichen-Bestand untersucht, mit massenhaftem Besatz von A.quer-custozae-Gallen (Abb. Vb). Auch von diesem Platz wurden nochmals weitere 350 geschlüpfte ,,tozae\"Gallen zur Vermessung gesammelt (Grafik 6). An Inqulinen schlüpften von Anf. Mai bis Ende Juli 2008 hauptsächlich Synergus umbraculus.\nBei zwei weiteren Kontrollen in Pomarolo, am 19.-27.07.08, hatten die frischen, klebrigen, gelblichen Junggallen inzwischen Durchmesser von 5-10 mm erreicht (Fotos); daneben fanden sich noch 50 alte Gallenkugeln an den Zweigen. - Bei späteren Kontrollen in Pomarolo-Servis ( 700 m ) am 07.09.2008 waren die meisten quercustozae-Gallen bereits fertig ausgewachsen (Hellrigl \\& Mörl), einige davon noch grünlich und außen klebrig (Abb. 68b). Im Vorjahr war hier noch am 28.10.07 eine einzelne grüne Galle gefunden worden (Foto). Am 12.10.2008 waren die quercustozae-Gallen\n\n--- Seite 84 ---\nbereits alle kastanienbraun ausgefärbt; es wurden 15 frische Gallen gesammelt und 20 abgefallene alte Gallen vom Boden aufgelesen.\nIn Südtirol kam A. quercustozae im Freiland bisher nicht natürlich vor. Bereits vor einigen Jahren waren in Südtirol im Forstgarten Aicha, XI.1988, einige Gallen (Ø 27-34 mm) an aus der Toskana importierten Eichenzweigen gefunden und gemeldet worden (Hellrigl 1997: p. 65, Abb. 6). Die Art konnte sich im Eisacktal im Raum Brixen aber wegen des Fehlens von Zerreiche noch nicht halten. Dies bestätigten auch kontrollierte Aussetzungsversuche bei Neustift-Schießstand, wo am 19.03.2006 an Traubeneichen Zuchtexemplare von A. quercustozae (20 ㅇ) und A. caputmedusae (10ㅇ) lebend angesetzt wurden. Erwartungsgemäß verlief dieser Freilandzuchtversuch wegen des Fehlens des Zwischenwirtes Zerreiche erfolglos und es kam zu keinen Gallenbildungen dieser beiden Arten. Zu einer weiteren Freilandeinschleppung war es im Frühjahr 2006 im Brixen-Stadt gekommen, mit aus der Toskana stammenden und hier angepflanzten Stieleichen; an diesen Quercus robur ,Fastigiata‘ wurden im Nov. 2006 unter anderen auch 3 Gallen von A. quercustozae gefunden (Mörl \\& Hellrigl).\n\nAnders hingegen die Situation im Etschtal-Unterland, wo zu vermuten war, dass A. quercustozae vom Süden her wahrscheinlich bald bis Castelfeder bei Auer vordringen und Fuß fassen würde können, ähnlich wie dies hier in den letzten Jahren mit der verwandten $A$. caputmedusae der Fall gewesen war.\nTatsächlich bestätigte sich diese Vermutung in Castelfeder am 17.08.08, als hier an einer Flaumeiche, in 50 Meter Entfernung von einer mächtigen Zerreiche (Ø 100cm), 4 Gallen von A. quercustozae gefunden wurden (leg. K. Hellrigl \\& K. Schanung). Drei dieser Gallen (Ø 25; 28; 29 mm ) waren frische Gallen des Vorjahres, deren Wespen im Frühjahr (Febr./März) 2008 geschlüpft waren (Abb.68c). Eine weitere Galle (Ø 18 mm ) vom selben Baum war schon einige Jahre alt und von Vögeln stark beschädigt. Damit war der Nachweis erbracht, dass A. quercustozae vom Süden her bereits bis Südtirol natürlich vorgedrungen ist; mit einer Befallsausweitung in Castelfeder ist zu rechnen.\n[69] [Andricus rhyzomae (Hartig 1843)]\n[= Cynips rhizomae Schenck 1863;\n$=$ Andricus rhizomatis Dalla Torre 1893]\nSeltene, der A. sieboldi nahestehende Art mit abgerundeten, kegelförmigen agamen Rindengallen am Grunde von Eichenstangen; junge Gallen mit fleischiger Hülle, $\\pm$ gerötet, später braun holzig, nur am Grunde mit Längsfurchen; späteres Flugloch meist am Scheitel der 4-5 mm hohen Kegelgalle [BuHR 1965: 924, Nr. 5377 ㅇ, T. 14, Fig. 219; Redfern et al. 2002: 401, Fig. 665; Meliкa et al. 2000: 279, Fig. 48]. - (Abb. 69: aus Henschel 1888: Fig. 4).\nIn Europa weite Verbreitung vom Norden (Skandinavien) bis nach S-Europa (Rumänien, Kroatien, Spanien), aber anscheinend nicht häufig. - Checklist Ital. [1995: Nr. 13/49, als A. rhizomae (Htg.)] aus Sizilien. - Mir kam diese von Quercus petraea, Q. robur u.a. gemeldete Art bisher nicht unter.\n[70] [Andricus sieboldi (Hartig 1843)]\n[= Cynips corticalis Hartig 1840]\n$=$ C. quercuscorticis auct., nec. L. 1761;\n$=$ Andr. testaceipes auct., nec Hartig 1840\nBei dieser Art gibt es einige nomenklatorische Verwirrung, denn bei vielen (auch neueren) Autoren scheint sie als „A. testaceipes (Htg.)\" auf (u.a. Nie-VES-ALdREY 2001: pp. 376-379, 537-538), doch ist der gültige Name nach Fauna Europaea (database 2005/07) offenbar A. sieboldi (Htg. 1843).\nDie agame Generation erzeugt kegelförmige, rötliche Rindengallen an der Basis von Eichenschösslingen und Stockausschlägen, die im Gegensatz zu den ähnlichen Gallen von Andricus quercuscorticis (L.) aber längsgefurcht sind („Gefurchte Kegelgalle\" - \"Red barnacle-gall causer\"); Flugloch seitlich. Die bodennahen Gallen sind oft mit einem Erdmantel (erzeugt von Ameisen: Lasius sp.) überzogen und verdeckt (H. Bellmann: persönl. Mitt., Foto: VIII.2006, als A. testaceipes). - Sexualgeneration erzeugt Verdickungen der Blattadern (\"Leaf-vein gall\"). Diese „Blattwulstgallen\" der Mittelrippe sind oft kaum unterscheidbar von den „Knötchengallen\" der Sexualgeneration von A. quercusradicis. - [\"A. testaceipes (Htg.)\": PfütZENREITER 1958: Nr. 5, Abb. 4 (agam); Nr. 6 u. Nr. 30 (sex.); BuHR 1965: Nr. 5378 ㅇ, T. 14, Fig. 215; Nr. 5473 ㅇ, T. 15, Fig. 226-27; Gauss 1982: 249, Fig. 108;\n\n--- Seite 85 ---\nAmann 1990: 87; Csóka 1997: 84/85; Melika et al. 2000: 279, Fig. 53; Nieves-Aldrey 2001: (sex) Figs. 130 K-L; (agam) Figs. 125 f-G; Redfern et al. 2002: 401, Fig. 664 ( $\\&$ ) ; 409, Fig. $700(\\& \\delta$ ) $]$.\nIn Europa ist $A$. sieboldi weit verbreitet, von Skandinavien bis S-Europa (Ungarn, Italien, Spanien). In N-Deutschland fand H. Bellmann (pers. Mitt.) frische „Gefurchte Kegelgallen\" (\"A. testaceipes\") an Eichenschösslingen im Aug. 2006 in der Lüneburger Heide (Abb. 70b).\nIn Checklist Ital. (1995: Nr. 13/53) als ,, A. testaceipes\" aus Sizilien gemeldet. Aus FVG vom Triestiner Karst eine Gallenangabe (23.08.1992) durch E. Tomasi (1996: p.37, Nr. 42; 2006: 70, Andricus testaceipes Htg. = A. sieboldi Htg.). - Dalla Torre (1894: 14; 1896: 152) meldet Gallen von Andricus testaceipes Htg. mehrfach aus N-Tirol von Quercus pedunculata und Q. sessiliflora: Volderwald bei Hall, Hötting u.a., Juli/Sept. 1893/94. - Die Art sollte auch in S-Tirol zu erwarten sein.\n\n## 71 Andricus seckendorffi (Wachtl 1879)\n\n[= Andricus magrettii Kieffer 1897]\nDie Art ist über Anatolien, die europäische Türkei (Belgrader Wald) und Niederdonau ( $=$ Niederösterreich) verbreitet (Schimitschek 1944: 303); in Südosteuropa aus Österreich, Ungarn, Griechenland, Italien gemeldet (Fauna Europaea 2007). Sollte auch im FVG und Trentino vorkommen.\nVerursacht in der agamen Generation Gallen am Fruchtbecher von Quercus petraea ( $=Q$. sessiliflora). Die kugeligen, vielkammerigen, holzigen Gallen ( $\\varnothing 10-24 \\mathrm{~mm}$ ) sind denen von A. lucidus und $A$. mayri recht ähnlich und wie diese mit ringsum radial gestellten, 2-4 mm langen, etwas eingekrümmten, am Ende zugespitzten, roten, klebrigen Fortsätzen versehen. Die Eichel im betroffenen Fruchtbecher ist meist verkümmert (Dalla Torre \\& Kieffer 1910: p. 501, Fig. 261-263). - Fehlt in Checkl. Ital. (1995), kommt aber in Italien vor. Aus FVG meldet Tomasi (2006: 70) die Art als „neu\" aus Gorizia/Grado an Q. petraea (22.07.2000). Im Trentino fand ich bei Pomarolo (IT-04: 700 m ) am 28.10.07 eine Galle am Fruchtbecher von Q. petraea, die dieser Art zuzuordnen sein dürfte (Abb. 71); Durchmesser mit stacheligen Fortsätzen 15 mm , holziger Gallenkörper 10 mm , mit einem Flugloch.\n\nAls Synonym gilt neuerdings die aus Kleinasien (Smyrna) beschriebene A. magrettii Kieffer, deren rundliche, holzige Galle an Quercus sp. als vielkammerig (Ø 25-30 mm), kahl, glänzend, netzförmig gefeldert beschrieben wird [Dalla Torre \\& Kieffer 1910: 505, Fig. 271-272; Melika et al. 2000: 279, Fig. 50a-b; Kieffer 1901: Pl. XX, Fig. 8].\n[72] [Andricus seminationis (Giraud 1859)]\n$=$ Cynips inflorescentiae Schlechtendal 1870\nBildet an männlichen Blütenkätzchen von Eichen (Q. robur, Q. petraea) langgestielte spindelförmige gerippte, zerstreut behaarte Gallen [vgl. Redfern et al. (2002: 416, Fig. 732)], die leicht zu unterscheiden sind von den ungestielten und unbehaarten Blütengallen, welche Andricus quadrilineatus verursacht [vgl. Redfern et al. (2002: 416, Fig. 733)]. - Die Art hat eine weite Verbreitung in Europa, fehlt aber bisher in Italien. - Sie ist aus der Region wohl sicherlich zu erwarten.\n\n73 Andricus solitarius (Fonscolombe 1832)\n[ $\\& \\delta=$ A. occultus Tschek 1871]\n[= Cynips ferruginea Hartig 1840: 189]\nAgame Generation verursacht an Zweigen von Quercus petraea, Q. pubescens, Q. robur einkammerige, spindelförmige Knospengallen, 7-10 mm, von vogelkopfähnlicher Form, bedeckt mit einem dichten rötlichen Haarfilz, der später abfällt („Hairyspindle gall causer\"). - Sexualgeneration mit kleinen roten, rundlichen Gallen an Blütenkätzchen. - [Dalla Torre \\& Kieffer 1910: 498, Fig. 254; Pfützenreiter 1958: Nr. 22, Abb. 16; Buhr 1965: 936, Nr. 5430, T. 15; Csóka 1997: 78-79; Melika et al. 2000: 280, Fig. 55; Nieves-Aldrey 2001: 384, 538; Redfern et al. 2002: 407, Fig. 693].\nN-Italien (Checkl. 1995: Nr. 13/50). In FVG am Triestiner Karst an Q. pubescens und sessiliflora, nach GräffE (1905: 38-39, Taf. II, n. 8); cit. Tomasi (1996: 37; 2006: 22, 70, Cecidothek FVG).\nDalla Torre (1894: 14) erwähnt Gallen von Andricus solitarius Fonsc. an Quercus pedunculata, Bozen (G. Mayr). - Zahlreiche Rezente Funde aus Südtirol: Naturns ( 700 m ), Q. pubescens, zwei alte „Vogelkopfgallen\", XI. 2004 (leg. Hellrigl). Tschötsch ( 750 m ) bei Brixen, 5 Gallen (vom Vorjahr) an Q. pubescens, 10.-23.04.2005 (Hellrigl \\& Mörl); Neustift ( 750 m ), einige alte Gallen an\n\n--- Seite 86 ---\nQ. petraea, ebenso Elvas ( 800 m ), 16.04.2005 (leg. Hellrigl). Die Art findet sich an den Zweigen häufig zusammen mit Gallen von Biorhiza.\nIm Eichenhain von Castelfeder ( 400 m ) bei Auer am 12.05.2005 zahlreiche vorjährige „Vogelkopf\"Gallen (ca. 40) an Zweigen alter Flaumeichen, zusammen mit Gallen von A. kollari (leg. Hellrigl \\& Fostini); hier weiter häufig am 10.08.2005 (Abb. 73). - Zahlreiche Gallen im Mai in Montiggl (IT-02) an Q. petraea; in Pinzon-Montan (450m), 10.07.2005, div. Gallen an Q. pubescens (leg. Hellrigl). - Sommer/Herbst 2005 viele Gallenfunde im Eisacktal: Tschötsch: 17.08.-07.10.05 (2 Dutzend Gallen); Neustift, 20.07.- 24.09.05 (div.); Elvas, 21.09.2005. - Auch in den Folgejahren bei Neustift, 21.05.06, 1 Zweig mit 3 alten Gallen (Fotos); Eisacktal: 3.-15.11.07: vereinzelte bei Aicha, Elvas, Neustift, Tschötsch. - Unterland: Castelfeder 24.09.06: div. „Vogelkopfgallen\"; 16.09.07: vereinzelt; hier ebenso am 17.08.08, 2 Dutzend alter Gallen. Die Art ist in Südtirol weit verbreitet und häufig (Abb. 73).\nNeumeldung für Trentino: Im Trentino vereinzelt bei Rovereto, 25.09.2005 und 04.08.2006 (leg. Hellrigl \\& Bellmann), sowie 03.10.2007, mehrere alte Gallen (leg. Hellrigl). Auch in Pomarolo-Servis (IT-04: 700 m ), 14.-28.10.2007, an Flaumeichen vereinzelt, 12 Gallen (leg. Hellrigl \\& Mörl); ebenso im Frühjahr 2008. Die meisten Gallen, die man findet sind alt, glatt und mit rundem Flugloch. Frische Gallen sind wollig rotbraun behaart und finden sich ab Juni/Juli: z.B. Tschötsch, 25.06.08, eine Galle ( 10 mm ) mit ausgewachsener Larve in der harten Gallenkammer (Foto Hellrigl), Elvas, 07.07.08, idem 2 Gallen. Pomarolo, 19.07.2008, frische wollige Vogelkopfgalle neben Junggalle von Medusenhaupt (leg./ Foto Hellrigl \\& Schanung), sowie am 07.09.08, 10 Gallen (leg. Hellrigl \\& Mörl) und einige weitere am 12.10.08.\n[74] [Andricus stefanii (Kieffer 1897)]\nDie Galle ähnelt entfernt A. polycerus (Gir.), von welcher sie MéHES (1953: Nouvelles galles du chene, se présentant très rare. Ann. Hist. nat. Mus. Hungar., 3. 183-189), der sie vereinzelt in Istrien fand und C. keszthelyensis benannte, artlich verschieden hielt [BuHR 1965: 945, Nr. 5463A]. Die gestielte\nagame Knospengalle gleicht in Seitenansicht einem kleinen trompetenförmigen, gelben Pilz und kommt zusammen mit A. quercustozae an Flaumund Stieleichen vor [Kieffer 1901: Pl. XI, Fig.12]. - In Sizilien gemein an niederem Eichengebüsch [,, ... sempre nelle macchiette cespugliose sul Q. robur e pubescens\"] nach De Stefani (1897: 159), dem zu Ehren sie von Kieffer als Cynips stefanii benannt wurde. - Nieves-Aldrey (2001) führt A. stefanii ebenso wie A. polycerus in seiner „Fauna Iberica\" nicht für Spanien an. Eine alternierende Sexualgeneration ist an Zerreiche zu vermuten.\nDie Art hat ein typisches südosteuropäisches Verbreitungsmuster, das von Ungarn über den Balkan (Bulgarien, Griechenland) bis Italien und Sizilien reicht. Sie kommt auch in der europ. Türkei (Belgrader Wald) und Anatolien an div. Quercus vor (Schimitschek 1944: 296, Fig. 215, Cynips). - In Checkl. Ital. (Pagliano 1995: Nr. 13/51) für N-Italien und Sizilien angegeben. In FVG am Triestiner Karst von GrÄFFE (1905: 61, Nachtrag, Cynips stefanii Kieffer) zweimal gefunden (Cecidothek FVG: S. Pelagio und Basovizza, leg. Gräffe), an denselben Fundorten wie Cynips korlevici Kieff. (vgl. Tomasi 1996: 48-49, n. 69, Cynips stefanii Kieff.; Tomasi 2006: 21, 70, Andricus stefanii Kieff.). In Istrien/ Kroatien bei Abbazia (= Opatija) auch von MéHES gemeldet (1953, C. keszthelyensis). - Bernardi et al. (1997: p. 116-117, c. 11 Fig. XX; 178: Fig. 39) melden sie auch aus Toskana: Bolgheri (Livorno) 1984 [L. Santini]. - Aufgrund der Fundnachweise aus Triest/Istrien könnte ein Vorkommen auch im südl. Trentino zu erwarten sein.\n[00] [Andricus tomentosus (Trotter 1901)]\nBildet an Quercus sp. kegelförmige Knospengallen bis 2 cm Länge; die Galle ist dicht filzig rostrot behaart; an der Basis verbreitert sie sich und umfasst den Zweig [Schimitschek 1944: 207, Fig. 216: Cynips tomentosa Trotter]. - Verbreitung in Südosteuropa: Bulgarien, Rumänien, Griechenland, Korfu, Ungarn, Dalmatien, Jugoslavien - bis in die europ. Türkei (Belgrader Wald) und Anatolien. - In Ungarn nur in Köszeg Mts. gefunden (Melika et al. 2000: 282, Fig. 59). Fehlt in Italien; in unserer Region nicht zu erwarten.\n\n--- Seite 87 ---\n[75] [Andricus trotteri Kieffer 1898]\nVerursacht in der agamen Generation kleine holzige Gallen ( $2-3 \\mathrm{~mm}$ ) an den Seitenknospen der Zweige von Quercus pubescens und Q. robur. (Dalla Torre \\& Kieffer 1910: 505, Fig. 273-274; Meliкa et al. 2000: 282, Fig. 60). - Verbreitung: Italien, Ungarn. - Checkl. Ital. (1996: Nr. 13/58): N-Italien. In FVG vom Triestiner Karst von Gräffe (1905: 61, Nachtrag) gemeldet; nur wenige Gallenfunde (Cecidothek FVG, Museum Triest: S. Pelagio und Basovizza, leg. Gräffe), an denselben Fundorten wie Cynips korlevici Kieff. und Cynips stefanii Kieff. (cit. Tomasi 1996: Nr. 47, p. 38 u. 94), [vgl. Tomasi 2006: p. 22 u. 70]. - Vorkommen im südlichen Trentino könnte möglich sein.\n\n76 Andricus truncicolus (Giraud 1859)\nBildet in der agamen Generation an Ästen von Quercus petraea, Q. pubescens, Q. robur kugelige, holzige, erbsengroße einkammerige Gallen, die mit plattenartig erweiterten Fortsätzen abgedeckt sind [vgl. Buhr 1965: Nr. 5420; Meliкa et al. 2000: 282, Fig. 61; Kieffer 1901: Pl. X, Fig. 7]. Die mit weißem kurzem, gekräuseltem Haarfilz bedeckten holzigen Gallen an den Zweigen fallen durch ihre äußerlich helle, mehlig-weißliche Färbung auf; die Galle ist im Habitus ähnlich A. hartigi, doch viel kleiner; die gestielten Fortsätze, die den Gallenkörper schildpattartig abdecken, sind in der basalen Hälfte der Galle polygonal, nur kurz zugespitzt, (nicht pyramidenförmig verbreitert wie bei $A$. hartigi); auf der oberen Hälfte der Galle bilden die Schildplatten lange gleichschenkelige Dreiecke, bis zum Scheitel hin zusammenneigend (Abb. 76). - Bisexuelle Generation nicht bekannt; als solche könnte eventuell Andricus cydoniae in Betracht kommen (Stone et al. 2007: 9). - Verbreitung: Österreich, Ungarn, Italien durch SE-Europa (Kroatien, Jugoslavien, Bulgarien, Rumänien, Ukraine) bis Kleinasien. In Checklist Ital. (1995: Nr. 13/59): N-Italien. Mittelitalien (Zapparoli 1997: 316): \"Insetti di Roma\", Orto Botanico (Villa Corsini). In FVG: vom Triestiner Karst liefert Gräffe (1905: 15, Taf. II, n. 3), eine treffende Beschreibung und Abbildung der erbsengroßen, grauen Galle von Cynips truncicola und bezeichnet sie „im Wald Farnetto oder Boschetto bei Triest auf $Q$. robur häufig vorkommend.\"\n\nEbendort zitiert von Tomasi (1996: 38, Nr.48); Tomasi (2006: 71, Triest-Duino: 1994).\nDie Art war für Trentino zu erwarten. Erstnachweis für die Region gelang in Pomarolo-Servis (IT-04: 700 m ) am 25.04.2008 an Kronenzweigen (Ø 9-12 mm) von Flaumeichen, in der Nähe von Zerreichen, 10 Gallen (leg. Mörl \\& Hellrigl): jeweils zwei ältere Zwillingsgallen mit rundem Ausflugloch, sowie am Stamm einer Flaumeiche ( $\\varnothing 15 \\mathrm{~cm}$ ) auf engem Raum, 6 alte zerfallende Einzelgallen, davon 5 mit Flugloch und eine mit toter Wespe in der verschlossenen holzigen Innengalle. Diese Gallen waren zunächst für zerfallende Gallen von A. conificus gehalten worden, der an denselben Eichen vorkam, und konnten erst durch einen weiteren Fund einer frischen Galle (Abb. 76) von A. trunciculus, am 19.07.2008, dieser Art richtig zugeordnet werden (leg. K. Schanung \\& det. Hellrigl). - Gleichzeitig wurden hier an Ästen und Zweigen von Flaumeichen noch fünf weitere alte kleinere „Furchengallen\" (Ø 5-7-9 mm) gefunden, die ebenfalls zu dieser Art gehören. Hinzu kam eine frische, stark gefurchte graue Galle (Ø 9-10 mm) die gänzlich von Blattläusen bedeckt war, erst nach deren Entfernung wurde die Gallenstruktur sichtbar (Fotos). Die Blattläuse waren stark parasitiert von Blattlausschlupfwespen (Aphidiidae), aus denen in Anzahl Imagines schlüpften.\nDie bis erbsengroße, $\\pm$ kugelige Galle von $A$. truncicolus besteht aus einer äußeren grauen, polygonal gefurchten Hülle und einer hellen, holzigen Innengalle mit unregelmäßig spießiger Oberfläche (Abb. 76). Beim Vertrocknen der Galle beginnt die Außenhülle entlang von vorgegebenen Furchen aufzureißen, so dass sich die einzelnen Placken (meist) leicht von der Innengalle lösen (vgl. Abb.). Die Galle selbst bildet sich an adventiven (= schlafenden) Knospen, entweder am Stamm oder häufig an dickeren Ästen, seltenere auch an dünneren Zweigen (div.Fotos K. Hellrigl).\nIn Pomaolo-Servis wurden am 27.07.08, bei gezielter Suche an Ästen und Stämmen von Flaumeichen in randständiger, mehr halbschattiger Lage, weitere 31 Gallen A.truncicolus gefunden (leg. Hellrigl \\& K. Schanung). Eine Analyse und Vermessung von insgesamt 38 gesammelten Gallen (teils frisch, teils alt) ergab folgendes Bild: rd. $50 \\%$ aller Gallen\n\n--- Seite 88 ---\nfanden sich an Stammrinde jüngerer Flaumeichen $(\\varnothing 10-15 \\mathrm{~cm})$; die andere Hälfte fand sich zu zwei Dritteln an dickeren Ästen (Ø 10-15-20 mm) und zu einem Drittel an dünneren Zweigen (Ø 3 -8mm). Die Außenmaße der Gallen waren: $\\varnothing=7-11 \\mathrm{~mm}$, $\\mathrm{H}=6-10 \\mathrm{~mm}$; die Maße der holzigen Innengallen betrugen $\\varnothing=5-8 \\mathrm{~mm}$. Zwei weitere Gallen $(\\varnothing=8 \\mathrm{~mm})$ wurden hier am 07.09 .08 gefunden, an einer strauchartigen Flaumeiche, an der sich auch eine frische Galle von A. conificus fand (leg. Mörl \\& Hellrigl). - Schließlich fanden sich hier am 12.10.2008 noch eine kleine Einzelgalle (Ø 4,5 mm) sowie eine Gruppe von 4 kleinen Gallen (Ø 4-5 mm). Diese Gallen waren wie die normalen Außengallen außen mit weißem, filzigem Belag (Aussehen wie mit Mehl bestäubt), aber wesentlich kleiner (Fotos); es handelte sich um halbwüchsige Gallen, deren Außenhülle und die damit verwachsene Innengalle noch relativ weich und nicht verholzt waren; die Larve in der großen zentralen Larvenkammer war schon ziemlich groß und wohlgenährt.\nNormalerweise sind die Gallen Ende Juli ausgewachsen und beginnen in der Außenhülle aufzureissen, welche dabei teilweise abfällt. In dieser Phase ist die Galle sehr anfällig gegen oberflächliche Schimmelbildung; die hellen Schimmelfäden fallen wegen der weißlichen filzigen Haarbedeckung der Außenhülle kaum auf. Die spießige helle Innengalle ist beinhart und lässt sich nur schwer mit einem Ritzmesser außen anschneiden. Im Inneren befindet sich eine große rundliche Gallenkammer. In vier am 30./31.Juli angeschnittenen Gallen fanden sich in 3 Zellen parasitoide Erzwespen (frisch geschlüpfte Imago sowie 2 Puppen einer blauen Torymus), nur die 4. Zelle enthielt eine ausgewachsene große Gallwespenlarve, die am 20.09.08 als Puppe mit dunklen Augen entwickelt war. Am 15.10.08 war in dieser Galle die frisch entwickelte Imago vorhanden (Abb. 76), aber noch nicht schlüpfbereit. Im Freiland sollen die Gallwespen erst nach Überwinterung in der Galle im März erscheinen.\n\n## [00] Andricus spp.\n\nEinige weitere Andricus-Arten, aus dem pontischen südosteuropäischen Raum: Österreich, Ungarn, Rumänien, Moldavien etc. fehlen bisher in Italien. Dazu sind folgende zu rechnen: Andricus serotinus (Giraud 1859), Andricus superfetationis (Giraud\n1859), Andricus vindobonensis Müllner 1901. Letztere Art meldet Tomasi (2006: 71) allerdings als „neu\" aus Triest/Dolina an Q. cerris (12.06.1993).\n\nEinige weitere südliche Andricus-Arten sind aus S-Italien bekannt, doch ist mit ihrem Vorkommen in der Region nicht zu rechnen; es sind dies u.a.: Andricus curtisii (Müller 1870) [= Cynips mediterranea Trotter 1901] aus Griechenland, Italien; Andricus theophrasteus (Trotter 1902): Italien, Jugoslavien. (vgl.Abb. XV: Foto G. Stone, Internet)\n\nGenus Aphelonyx Mayr 1881 - Cynipini\n77 Aphelonyx cerricola (Giraud 1859)\nBildet in der agamen Generation an dünneren Zweigen (5-12 mm) von Zerreiche (Q. cerris) rundliche, 10 bis 30 mm große, den Zweig $\\pm$ umfassende Gallen, diese anfangs blassgrün und kurzfilzig behaart, später bräunlichgelb/ockerfarben und kahl. Manchmal mehrere Gallen eng beieinander, dann gegenseitig abgeplattet oder verwachsen. Im Inneren eine Innengalle, Gallenreife und Wespen im Herbst. [Buhr 1965: 971, Nr. 5549; Pellizzari 1988: 123; Bernardi et al. 1997: 108, Fig. 7B; 162, Fig. 33; Csóka 1997: 100/101; Melika et al. 2000: 282, Figs. 63a-b; Redfern et al. 2002: 401, Fig. 666]. - Sexualgeneration nicht bekannt.\nVon Österreich und Ungarn durch SE-Europa bis Kleinasien verbreitet; in Britannien seit 1997. Fehlt im Westen: in Spanien, Frankreich etc.\nChecklist Ital. (1995: Nr. 14/01) für N-Italien genannt. In FVG vom Triestiner Karst diverse Gallenangaben von GrÄFFE (1905: 23-24, Taf. II, n. 2): Apheloniyx cerricola war nicht häufig bei Triest, doch fand Dr. Eduard Gräffe eine größere Anzahl Gallen an den mit Zerreichen bewachsenen Dolinen und dem Plateau des Karstes bei Opcina, Reppentabor, Orlek, Basovizza; (vgl. Tomasi 1996: 39; 2006: 21, 71).\nAuf A. cerricola zu beziehen ist auch eine Angabe von Tomasi (1996: 32, als „Andricus lignicola\") vom Triestiner Karst (XI.1992), gemäß Gallenbeschreibung und Abb. „Tab. D-3\" an Quercus cerris. Bernardi et al. (1997: 162) Italien: Friaul-Venezia Giulia, Veneto, Ligurien, Emilia Romagna, Toskana. Zapparoli (1997: 316) Mittelitalien: \"Insetti di Roma\", Villa Ada, 1993.\n\n--- Seite 89 ---\nNeumeldung für die Region Trentino-Südtirol: Pomarolo-Servis (IT-04: 700 m), 14-28.10.2007, 18 Gallen ( $10-30 \\mathrm{~mm}$ ) an jüngeren strauchartigen Zerreichen (Q. cerris), leg. Hellrigl \\& Mörl (Abb. 77). Aus den Gallen schlüpften Nov. 2007 zahlreiche Ameisen (Camponotus truncatus) sowie 1 Eurytoma; bei weiterer Indoor-Aufzucht im Jan./Febr. 2008: 28+18 Synergus thaumacerus (leg./det. Hellrigl).\nEine frische hellgrüne Galle ( $18 \\times 20 \\mathrm{~mm}$ ) fand sich hier am 19.07.08 am Ast von junger Zerreiche (Abb. 77b) und am 27.07.08 eine kleine Galle ( 12 mm ) an niederem Zweig (leg. Hellrigl \\& Schanung). Hier weitere 5 Gallen (9-11-12-20$22 \\times 16 \\mathrm{~mm}$ ), teilweise schon braun verfärbt, an strauchartiger Zerreiche am 07.09.2008 (leg. Hellrigl \\& Mörl), daraus schlüpften am 15.11.2008 wieder einige Synergus thaumacerus $(28+78)$. Weitere Gallen am 12.10.08, an den unteren Kronenästen größerer Zerreichen: 4 Zweige mit 12 frischen Gallen: [A ( $30 \\times 25)+(21 \\times 19 \\mathrm{~mm})$ : beide doppelt; B $(27 \\times 27)+(15 \\times 12 \\mathrm{~mm}) ; C(28 \\times 28)+(14 \\times 12)+$ $(16 \\times 14)+(17 \\times 14)+(8 \\times 7)+(5 \\times 4)+(4 \\times 3 \\mathrm{~mm})$; C ( $25 \\times 20 \\mathrm{~mm})$ ]; sowie 2 alte Gallen ( $31 \\times 28 \\mathrm{~mm}$ ). - Insgesamt liegen mir aus Trentino bisher rd. 40 Gallen vor (Abb. 77).\n\nGenus Biorhiza Westwood 1840 - Cynipini\n78 Biorhiza pallida (Olivier 1791)\n\n- \"Schwammapfel\" - \"galles en pomme\"\n[Réaumur 1737: Ins. 3, T.41, Fig. 1-5: ]\n[88 Cynips quercusterminalis Fabricius 1798;\n$=$ Teras terminalis Hartig 1840]\n[98 Cynips aptera Bosc 1791]\n- „Eichen-Wurzelgalle\"\n\nVerursacht in der Sexualgeneration im Frühjahr an Zweigspitzen von Eichen (Quercus sp.) auffällige, vielkammerige Knospen-Schwammgallen (Ø 2-4 cm), von anfangs rötlich-weißer bis gelblicher (Ende Mai) und zuletzt brauner bis schwarzer Färbung, die als „Eichapfel\" [\"galles de chêne en pomme\"] bekannt sind (,Oak-apple causer\"). - Die agame Generation bildet im Sommer unterirdische einkammerige Wurzelgallen, oft traubig gehäuft („Kleine Eichen-Wurzelgalle\"). - [BuHR 1965: Nr. 5432; T. 15, Fig. 235; Pfützenreiter 1958: Nr. 2,\n\nAbb. 2 (agam); Nr. 15, Abb. 10 (sex.); ChinerY 1987: 229; Amann 1990: 87; Csóka 1997: 80; Melika et al. 2000: 282, Figs. 64; Nieves-Aldrey, 2001: 486, 547; Fig. 128]. - Checkl. Ital. (Pagliano 1995: Nr. 17/02); Bernardi et al. (1997: 138, Fig. 21) ganz Italien. In FVG vom Triestiner Karst zahlreiche Meldungen der häufigen Gallen durch GrÄFFE (1905: 24-27, Taf. I, n. 8; Cecidothek) und Tomasi (1996: 40-41, n. 52; 2006: 21, 71).\nDalla Torre (1896): Galle Biorrhiza terminalis Fabr. an Quercus pubescens, Atzwang 24.07.1894. - D.T. (1894-96): an Q.pedunculata mehrfach aus N-Tirol angeführt. - Nach Cobelli (1903: 165), als Biorhiza terminalis, auch im Trentino. Diverse Nachweise aus Südtirol: Gauss (1982: 243) berichtet über eine Untersuchung 1976 von 12 Schwammgallen von B. pallida aus dem Sarntal, die 185 normal geflügelte Weibchen ergaben (hingegen keine brachypteren oder apteren 99 , wie im Schwarzwald). -\nAuch ich sah in Südtirol-Trentino in der bisexuellen Generation stets nur voll geflügelte 88 und 99; dasselbe berichtet Dr. E. GrÄFFE (1905: 26) von der geschlechtlichen Biorhiza-Generation in Triest/ Istrien: „Die Flügel der hiesigen südlichen Form sind stets wohl entwickelt, während in Mitteleuropa die Weibchen von B.pallida oft flügellos oder mit kurzen, verkümmerten Flügeln auftreten.\"\nHellrigl (1996): Biorhiza pallida, agame Generation: Brixen-Köstlan 31.12.1963, flügelloses Weibchen (= aptera Bosc 1791) in Laubstreu (A. v. Peez). - Forstgarten Aicha, 1990, Zweiggallen Sexualgeneration an Q. pubescens (leg. Hellrigl). Kaltern, div. schwarze „Schwammgallen\" an Eichen, Aug. 2004 (leg. A. Fostini). - Neustift-Schießstand, 650-700 m, 17.10.2004, Zweiggallen an Traubeneichen; Franzensfeste 750 m , Okt. 2004, 5 Gallen an Q. petraea (leg. Hellrigl). Vinschgau: Goldrain, 900 m , 16 Gallen an Q. pubescens, 19.10.04 (leg. Minerbi \\& Hellrigl); Naturns, 700 m , eine alte Galle, XII. 2004.\n2005 fanden sich in Südtirol frische unreife Zweiggallen ab Ende April und dann Mitte/Ende Mai (bereits fertig ausgebildet): bei Montiggl ( 560 m ) an Q.petraea, bei Kaltern ( 450 m ) und Castelfeder $(400 \\mathrm{~m})$ an Q.pubescens (leg. Hellrigl \\& Fostini); sowie Neustift ( 700 m ) an Q.petraea. Das Schlüpfen der Sexualgeneration (98) aus\n\n--- Seite 90 ---\nfrischen, gelben Zweig Gallen erfolgte Ende Mai (27.05.- 02.06.2005). - Aus alten vorjährigen, schwarzen Gallen (von Gallwespen bereits verlassen) schlüpften im Frühjahr noch zahlreiche Parasitoide [u.a. Chalcidide-Eulophidae: Aprostocetus biorrhizae (Szelényi 1941)]. - Zweig Gallen von Biorhiza sind in Südtirol an xerothermen Hängen im Eisackal und Etschtal weit verbreitet. Auf der Tschötscher-Heide ( 750 m ) bei Brixen wurden am 10.04.2005 an zwei freistehenden strauchartigen Traubeneichen an 7 Zweigen 15 alte schwarze Gallen gesammelt. An weiteren Eichen in Tschötsch fanden sich am 24.05.2005 bereits neue hellbraune Gallen (Abb. 78): an 24 Zweigen 40 Schwammgallen (leg. Hellrigl \\& Mörl). - Aus diesen „Eichäpfeln\" schlüpften aber keine Gallwespen, da deren Brutzellen von fetten Rüsselkäfer-Larven zerstört waren, die das Innere der Schwammgallen aushöh1ten und sich vom 28.05.-06.06.05 zahlreich aus den 40 Gallen ausbohrten ( 60 Rüßlerlarven). Es handelte sich um den Rüßler Curculio (= Balaninus) villosus F., dessen Larven bis zum Juni in den frischen Gallen der Schwamm-Gallwespe, Teras terminalis, auf Eichen leben (Reitter 1916: 189; PfützenreIter 1958: 100). Diese Rüsselkäfer sind in Südtirol (Bozen, Moritzing, Meran, Gratsch) häufig ab Mitte April auf Eichengebüsch zu finden.\nAls weitere lästige Inquilinen in den Biorhiza-Gallen traten regelmäßig Kleinschmetterlings-Raupen auf, die am Gallengewebe fraßen und dieses verunstalteten. Es handelte sich dabei um einen Wickler (Lepidoptera, Tortricidae) der Gattung Pammene. - CsóKA \\& SzabóKY (2005) führen aus Ungarn unter 308 Schmetterlingsarten aus 32 Familien, die dort an Eichen fressen, auch 6 Pammene-Arten an. Von diesen Arten kommen für unser Gebiet in Betracht: Pammene albuginana (Guenée 1845), Pammene amygdalana (Duponchel 1843), Pammene gallicolana (Lienig et Zeller 1846).\nZahlreiche Vorkommen von Biorhiza-Gallen fanden sich im Mai 2006, in Neustift-Sonnleiten ( 700 m ) an Traubeneichen-Gebüsch: am 03.05.2006 waren die rosaroten Gallen bereits $10-25 \\mathrm{~mm}$ groß (Foto); bei einer Kontrolle am 17.05.2006 wurden an dem Gebüsch 2 Dutzend schöner Biorhiza-Gallen gezählt und fotografiert (Abb. 78b); an den noch weichen Eichenblättern fanden sich auch div. Beeren-Blattgallen von N. quercusbaccarum (Ø max: 9-9.5 mm).\n\nBei einer späteren Kontrolle am 05.08.2006 wurde dieser schöne ergiebige Eichen-Standort zerstört vorgefunden (vid. Hellrigl \\& Bellmann), durch Rodung der jungen Eichen zwecks Errichtung eines weithin sichtbaren „flammenden\" Holzkreuzes anläßlich der Herz-Jesu-Feuer (25.06.2006); ein rücksichtsloser Umweltfrevel (Fotos).\nAn weiteren Funddaten für Gallen von Biorhiza aus Südtirol-Trentino wurden registriert: Unterland: Montan-Pinzon, $450 \\mathrm{~m}, 10.07 .2005,1$ Galle an Q. petraea. Castelfeder, 24.09.2006, 1 Galle an Q. pubescens; idem 16.09.2007, einige Gallen; idem 17.08.2008, wenige Gallen. - Rovereto: 04.08.2006, vereinzelte Gallen. - Brixen-Stadt, am 26.11.06, 2 Gallen an importierten Stieleichen aus der Toskana (Hellrigl \\& Mörl). Aicha ( 740 m), 12.11.07 an Traubeneichen, 4 Gallen (Först. De Luca \\& Hellrigl). - Rovereto, 03.10.2007, 2 Zweig Gallen (leg. Hellrigl). Pomarolo-Servis (IT-04: 700 m), 14.-28.10.07, ca. 15 Zweig Gallen an Flaumeichen, sowie eine alte Zweiggalle an Zerreiche (leg. Hellrigl \\& Mörl).\nIm Frühjahr 2008 wurden im Trentino am 25.04.08 bei Pomarolo ( 700 m ) frische, rötliche Gallen beobachtet und fotografiert ( $\\varnothing 1 \\mathrm{~cm}$ ), am 02.06.2008 wurden bereits div. ausgehärtete hellbraune Gallen gefunden und am 19.-27.07.08 zahlreiche schwarze Gallen (leg. Hellrigl \\& Schanung). Weitere Gallen wurden hier und in Rovereto-Dossi auch am 07.09.08 gesammelt (leg. Hellrigl \\& Mörl).\n\nAuch in Südtirol fanden sich am 10.05.2008 auf Tschötscher Heide ( 750 m ) 20 frische, rot angelaufene Gallen von $1-1,5 \\mathrm{~cm}$, max. 2 cm ; (Abb. 78); zahlreiche kleine hellbraune Gallen zum selben Zeitpunkt auch bei Neustift-Sonnleiten. - Am 23.05.08 waren die Gallen in Tschötsch am Übergang in die hellbraune Aushärtungsphase, die größte hatte einen Durchmesser von 28 mm erreicht (Foto); aus dieser eingetragenen Galle schlüpften am 12.-18.06.2008 zahlreiche geflügelte Imagines Biorhiza pallida ( 88 Ex.: $87 \\leftrightarrows+1 \\varnothing$ ). Bemerkenswert das hier festgestellte sehr unausgeglichene Geschlechtsverhältnis: es ist bekannt, dass aus einzelnen Gallen nur Weibchen oder Männchen hervorgehen, aus anderen (viel seltener!) beide Geschlechter (vgl. Pfützenreiter 1958: 100; Nieves Aldrey 2001: 490). Die Männchen haben stets voll entwickelte Flügel (wie bei uns auch die $9 \\leftrightarrows$ der\n\n--- Seite 91 ---\nbisexuellen Generation). - Zahlreiche Gallen an Trauben- und Flaumeichen fanden sich Anf. Juli 2008 und auch noch Mitte Sept. bei der Schottergrube in Albeins/Brixen (vid./leg. K. Schanung \\& Hellrigl). - Bisher kaum gesucht wurde hier nach Wuzelgallen [Abb. 78] der agamen, ungeflügelten $4 \\square$-Generation.\n\n## Genus Callirhytis Förster 1869\n\n- Eichensamen-Gallwespen\n\nDiese Gattung ist mit zahlreichen Arten hauptsächlich in Nordamerika vertreten (Kieffer 1901).\nDie Situation der in Europa von Eichen gemeldeten „Eichensamengallwespen\" der Gattung Callirhytis ist noch unklar und revisionsbedürftig. Von den in Fauna Europaea (2007) angeführten 6 Taxa, sind drei vermutlich nur Synonyme ( $=$ Callirhytis hartigi Förster 1869, Callirhytis meunieri Kieffer 1902, Callirhytis bella (Dettmer 1930) - und bei den 3 übrigen [Callirhytis glandium (Giraud), C. erythrocephala (Giraud), C. rufescens (Mayr)] erhebt sich die Frage ob es sich um eine, oder um zwei bzw. drei valide Arten handelt. - Am ehesten scheint C. rufescens eine zweite Art zu sein. Callirhytis sp. sind hauptsächlich von Zerreiche bekannt, seltener von anderen Eichen. Zwischen Callirhytis sp. und der Wirtsart Quercus cerris besteht nach eigenen Beobachtungen ein ökologisches Gleichgewicht: obschon der Prozentsatz von Eichensamengallwespen befallener Eicheln sehr hoch sein kann (z.B. lag in TN bei Pomarolo im Okt. 2007 bei rd. $60 \\%$ ), bleiben durch saubere „Abkapselung\" der Befallsstelle\ndie intakten Teile der Keimblätter (Endokarp) der Eicheln unbeeinträchtigt und weiterhin keimfähig. Dies bestätigte ein Keimversuch mit 138 Eicheln von Q. cerris aus Pomarolo, die Ende Okt. 2007 zu jeweils 2 Eicheln in 70 Pflanztöpfchen gesetzt wurden; davon trieben $82(=59 \\%)$ Zerreichen aus. Dieses Jahr, Mitte Nov. 2008, ergab eine Untersuchung der inzwischen teilweise verrotteten Eicheln in den Pflanztöpfchen, dass die abgekapselten steinharten Befallsplacken unversehrt und intakt waren und in den darin eingebetteten harten Larvenkammern durchwegs lebende Larven enthielten (Abb. 79a).\nDaneben war in Pomarolo auch aufgefallen der geringe Befallsanteil der Eicheln durch Eichensa-men-Rüssler (Curculio sp. = Balaninus sp.) sowie Eichel-Wickler (Laspeyresia splendana Hbn.), der zusammen nur bei rd. $11 \\%$ lag. Der Befall durch Eichensamen-Rüssler, welche die Eicheln meist weitgehend zerstören, ist bei anderen Eichenarten (Q. pubescens, Q. robur, Q. petraea) deutlich höher; so waren im IX. 1966 in Castelfeder/Auer aus einer vergleichbaren Menge gesammelter Eicheln in größerer Anzahl Curculio glandium Marsh. 1802 und Curculio elephas (Gyll. 1836) gezogen worden. Diesen Befund bestätigte auch eine Vergleichsanalyse vom Herbst 2007 an Eicheln aus Neustift, welche an Trauben- und Flaumeiche einen Befallsanteil von Rüssler plus Eichel-Wickler von $45 \\%$ ergab (vgl. Tab.4). Es stellt sich die Frage ob und inwieweit Callirhytis-Befall (Abb. 79a) den schädlicheren Rüsselkäfer-Befall (Abb. 79b) verhindern kann?\n\nTab. 4\n\n| Eicheln Befallszustand | Pomarolo: 31.10 .2007 <br> Quercus cerris $-\\mathrm{N}=100$ |  | Neustift: 03.11.2007 $-\\mathrm{N}=200$ <br> Quercus petraea et pubescens |  |\n| :-- | :--: | :--: | :--: | :--: |\n| Gallwespen: Callirhytis | 59 | $59 \\%$ | - | - |\n| Rüsselkäfer: Curculio sp. | 7 | $7 \\%$ | 67 | $33,5 \\%$ |\n| Wickler: Laspeyresia sp. | 4 | $4 \\%$ | 22 | $11,0 \\%$ |\n| Vertrocknete Eicheln | - | - | 47 | $23,5 \\%$ |\n| Eicheln ohne Befall | 30 | $30 \\%$ | 64 | $32,0 \\%$ |\n| Summe | 100 | $100 \\%$ | 200 | $100 \\%$ |\n\n--- Seite 92 ---\n79 Callirhytis glandium (Giraud 1859) $2 \\varrho$\n( $20^{\\circ}=$ C. aestivalis Nieves-Aldrey 1992)\nBei der Gallenbildung der agamen Generation in den Eicheln von Quercus cerris wird das Endokarp der Eichel (im Spätsommer/Herbst) mehr weniger ausgedehnt in eine hart zementierte Masse verwandelt, in der die einzelnen hartschaligen Gallenkammern eingebunden stecken (Abb. 79). Die harten schildartigen Placken mit den eingeschlossenen Gallen lassen sich leicht und sauber vom Endokarp ablösen, welches außer einer Minderung an Masse keinen erkennbaren Schaden nimmt.\nVergallte Eicheln sind oft $\\pm$ verbeult, gelegentlich aufplatzend: „Eichensamengallwespe\" (Abb. 79a). [BuHR 1965: Nr. 5605; Nr. 5536; Pfützenreiter 1958: 125, Nr. 60; Abb. 50 a-b-c; Meliкa et al. 2000: 283, Figs. 65a-c; Kieffer 1901: Pl. XIV, Fig. 7]. Manche Abbildungen und Beschreibungen des Befalls von Callirhytis sp. mit verkümmerten Eicheln, die im weitgehend geschlossen bleibenden Fruchtbecher sitzen sind etwas irreleitet (vgl. BuHR 1965: T. 17, Fig. 284; Redfern et al. 2002: 418, Fig. 740; Pfützenreiter 1958: 125, Nr. 60; Abb. 50a), denn die meisten befallenen Eicheln erreichen normale Größe, weisen aber außen $\\pm$ deutliche Ausbeulungen oder andere Unregelmäßigkeiten auf (Abb. 79a). Befällt auch Quercus suber \\& Quercus ilex [Nie-Ves-Aldrey 2001: 326, 534; Fig. 122b; Redfern et al. 2002: 418]. - Wespen der agamen Generation schlüpfen erst nach 2-4 Jahren (gemäß 2jährig alternierenden Eichel-Samenjahren). Die Larven überdauern die Diapause im Boden in ihren ein-\nzementierten harten Gallenkammern. - Bisexuelle Generation an Eichenschößlingen.\nVerbreitung in Mittel- und Südeuropa, im natürlichen Vorkommensgebiet der Zerreiche (BuHR 1965: 986): Austria, Britann., Frankr., Polen, Ungarn, Italien, Kroatien, Rumänien, Ukraine, Portugal. - An Quercus suber in Spanien lokal oft häufig (Nieves-Aldrey 2001: 329); von Q. suber auch aus Südfrankreich und Sizilien gemeldet (Kieffer 1901: 386). - In Checklist Ital. (1995: Nr. 13/26 u. 18/01) nur doppelt aus Sizilien angeführt [als Andricus glandium Giraud, = Callirhytis glandium (Giraud)]. - War auch für Trentino und das Südtiroler Unterland zu erwarten.\nIm Herbst 2007, einem reichen Eichelsamenjahr, im Trentino bei Pomarolo-Servis (IT-04: 700 m ), wurden am 14.-28.10.2007 zahlreiche Eicheln von Zerreiche eingesammelt und untersucht (Hellrigl \\& Mörl); in vielen Eicheln (vor allem solchen normaler Größe) wurde Befall dieser Eichelgallwespe (d.h. harte Placken mit eingebundenen Gallen) gefunden (Abb. 79a). Die Befallsspuren waren weitaus häufiger als Befall durch Eichelrüßler Curculio glandium (vgl. Tab. 4). Im folgenden Herbst 2008 war die Produktion an Eicheln wesentlich schwächer ausgefallen und erwartungsgemäß sank auch der Anteil befallener Eicheln durch Callirhytis sp. von vormals $59 \\%$ auf nur mehr $19 \\%$, während sich der Befallsanteil durch Eichelrüßler (Curculio sp.) auf $14 \\%$ verdoppelte; auch der Anteil gesunder Eicheln verdoppelte sich von einem Drittel im Vorjahr, auf nunmehr zwei Drittel (vgl. Tab. 5).\n\nTab. 5\n\n| Eicheln Befallszustand | Pomarolo: 15.10 .2008 <br> Quercus cerris $-\\mathrm{N}=80$ | Pomarolo: 31.10 .2007 <br> Quercus cerris $-\\mathrm{N}=96$ [100] |  |  |\n| :-- | :--: | :--: | :--: | :--: |\n| Gallwespen: Callirhytis | 15 | $19 \\%$ | 59 | $59 \\%$ |\n| Rüsselkäfer: Curculio sp. | 11 | $14 \\%$ | 7 | $7 \\%$ |\n| Eicheln ohne Befall | 54 | $67 \\%$ | 30 | $30 \\%$ |\n| Summe | 80 | $100 \\%$ | 96 | $96 \\%$ |\n\nNeufund für die Region; wohl auch in Rovereto. In Castelfeder fanden sich 2007/08 an einer großen Zerreiche $(\\mathrm{D}=100 \\mathrm{~cm})$ nur wenige reife Eicheln; diese ergaben negativen Befund. Auch eine Untersuchung von Eicheln (Q.petraea, Q. pubescens) im Eisacktal, bei Neustift am 03.11.2007, verlief\nbezüglich Callirhytis negativ; dafür gab es hier starker Befall durch Rüßler und Wickler (Tab. 4).\nDie ebenfalls in Eicheln von Q. cerris Gallen bildende Callirhytis erythrocephala (Giraud 1859), mit angeblich ähnlicher Verbreitung, wird von einigen Autoren als Synonym von C. glandium gehalten\n\n--- Seite 93 ---\n(Redfern et al. 2002: 418, Fig. 740); vergallte Eicheln [angeblich] aus dem Fruchtbecher oft kaum hervortretend. Die nur aus Deutschland gemeldete Callirhytis hartigi Förster 1869 wird ihrerseits als Synonym von C. erythrocephala angegeben [cit. Fauna Europaea 2007].\n\n80 Callirhytis rufescens (Mayr 1882) ơ\n[ㅇo = C. glandulosa Weld 1939)]\nDie Unterscheidung dieser „Eichensamengallwespe\" von der vorhergehenden scheint nicht im Befall anderer Eichenarten zu liegen (Q. robur, Q. petraea, Q. pubescens), wie vermutet wurde (vgl. BuHR 1965: Nr. 5536) denn sie befällt in der agamem Generation ebenfalls hauptsächlich Quercus cerris, Q. suber und Q. ilex. Der hauptsächliche Unterschied besteht nach Nieves-Aldrey [2001: 332, 552] darin, dass in den befallenen Eicheln die Gallen in Form von Einzelzellen, wenn auch aneinander angrenzend, gebildet werden, die an der Oberfläche des Endokarps der Eichel liegen. Die Zellen sind subsphärisch oder unregelmäßig polyedrisch, von glatter Oberfläche oder häufig auch warzig. Diese Zellen liegen unterhalb der Außenschale der Eichel [Nieves-Aldrey 2001: p. 565, Fig. 122 c; p. 628, Fig. 140D]. - Sexualgeneration ähnlich der von C. glandium, mit kleinen Larvenkammern in Zweigen [Nieves-Aldrey 2001: 330, 534; Figs. 122c, 130I-J]\nCircummediterrane Verbreitung: aus Spanien, Frankreich, Italien, Griechenland und Türkei bekannt (Nieves-Aldrey 2001: 332) auch Ungarn und Portugal. - Fehlt in Checklist Ital. (1995), obschon aus Italien die Co-Typen der agamen Generation C. glandulosa Weld stammen. - Erstnachweis für die Region Trentino-Südtirol: In Pomarolo-Servis (IT-04: 700 m ) wurde im Okt. 2007 in gesammelten Eicheln von Zerreiche neben zahlreichen unverkennbaren Gallen von Callirhytis glandium - mit eingebetteten Gallen in steinharten EndokarpPlacken - vereinzelt auch Anhäufungen von einzelnen kleinen ( $2-3 \\mathrm{~mm}$ ), eiförmigen, harten Gallen unter der Schale gefunden (Abb. 80) - ohne Einbindung in größere, harte Endokarp-Placken (leg. Hellrigl \\& Mörl). Einige befallene Eicheln fanden sich hier auch im Folgejahr, am 12.10.2008 (leg. Hellrigl \\& Schanung). - Ich halte diese Gallen für zu dieser Art gehörend, doch sind die Untersuchungen noch nicht fertig abgeschlossen. - Eine weitere in Eicheln\nvorkommende Eichensamengallwespen ist Andricus legitimus Wiebes-Rijks (siehe Nr. 53).\n\n## Genus Chilaspis Mayr 1881\n\n[81] [Chilaspis mayri (Müllner 1901)]\nDie Dryocosmus Giraud 1859 nahestehende Gattung Chilaspis Mayr 1881 ist in Europa mit 2 Arten vertreten, die an Quercus cerris gebunden sind; Verbreitung südöstl. Mitteleuropa und SE-Europa. Die Art wurde beschrieben als Dryocosmus mayri Müllner 1901 (Verh. Ges. Wien. 51 (3): 525-527) und erst rezent in die Gattung Chilaspis Mayr 1881 gestellt: [Pujade-Villar, Ros-Farré \\& Melika 2003: Revision of the Genus Chilaspis Mayr 1881 (Hymenptera: Cynipoidea, Cynipidae). Ann. Soc. Entom. France, (n.s.), 2003, 39 (2): 167-178]. Von Melika et al. 2000: Checklist of oak gall-wasps of Hungary noch als Dryocosmus mayri geführt (p. 284; Figs. 75).\nBewirkt in den Blattknospen vorjähriger Triebe von Quercus cerris kugelige, erbsengroße, glatte oder kantige, blassgrüne, teilweise schwärzlichrote Gallen, die mit glänzendem, klebrigen Überzug versehen sind und deren bräunliches, schwammiges Paranchym mehrere hellere, hartwandige Innengallen zeigt. Häufig verwachsen mehrere Gallen zu unregelmäßigen bis kirschgroßen Gebilden. Nach dem Ausfliegen der Imagines (ơ) im Mai, schrumpfen die Gallen und fallen ab (Dalla Torre \\& Kieffer 1910: 383). - Eine agame Generation ist unbekannt.\nLocus typicus: Austria, Nieder-Österreich: Rekawinkel (div. Gallen NHMW: 14.05.1896 an Q. cerris; Ibidem: 2 Gallen 23.05.1896); sonst noch gemeldet aus Ungarn und Griechenland (Korfu) [vgl. BuHR 1965: Nr. 5563 Knospengallen ơ; Nr. 5570 Blattgallen ơ; Pujade-Villar et al. 2003]. - Die Art gilt als selten, doch wurden ihre Gallen an Zerreichen (2. Mai-Hälfte) wohl auch zu wenig gesucht.\n[82] [Chilaspis nitida (Giraud 1859) (agam)] [= Chilaspis loewii Wachtl 1882] (sexual form) BuHR 1965: Nr. 5578 ㅇo: kugelige Gallen unterseits an Blättern der Zerreiche (Taf. 17, Fig. 289-290). Galle langoval, 4-6 mm, mit kurzen, dichtstehenden Sternhaaren besetzt, grün, später graubraun,\n\n--- Seite 94 ---\ndickwandig; mit einer oder zwei ovalen Kammern. Galle Ende Aug., im Okt. ausgewachsen, abfallend.\nBuHR 1965: Nr. 5606 o -Generation in Kätzchengallen an Zerreiche: bildet erbsen- bis walnussgroße, rundliche, wollbüschelartige Ballen, die aus $\\pm$ zahlreichen kleinen länglichen Einzelgallen bestehen. Entsprechend der Zahl der meist zweikammerigen Einzelgallen ist die Gallenoberfläche facettenartig gefeldert; Haare in der Feldmitte schmutzig karminrot, zum Rande hin weißlich gefärbt. - Gallenreife im April, später abfallend. Diese Sexualgeneration wurde aus Wien (24.04.1882) als Chilaspis loewii Wachtl beschrieben (Wachtl 1882: Wiener Ent. Ztg. I., H.12, p.291-293, Abb. Fig. 2) und später als zugehörend zur agamen Chilaspis nitida Giraud erkannt (Schlechtendal 1888: Wiener Ent. Ztg. VII., H. 7, 245-246). [vgl. Kieffer 1914: p.45-46, Galle Nr. 77, 83; Taf. III. Abb. 5 u. 7; p. 64, Imagines; Meliкa et al. 2000: 283, Figs. 66a-b (bisex.), 66c-d (unisex)].\nVerbreitung: Österreich (Wien, Schönbrunn), Ungarn, Bulgarien, Rumänien; Deutschland (eingeschleppt: Botan. Gärten Halle und Jena). Auch aus N-Italien gemeldet: Checklist Ital. (1995: Nr. 19/01); in FVG vom Triestiner Karst einige Gallenangaben an Q. cerris von Tomasi (1996: 42, Nr. 55; Cecidothek; ebenso: 2006: 71, bei Triest/ Dolina am 08.11.1992). - Die Art scheint etwas häufiger und weiter verbreitet zu sein als die vorige; sie ist für Trentino (Rovereto, Pomarolo) wahrscheinlich zu erwarten.\n\n## Genus Cynips Linnaeus 1758\n\nCynips-Arten bilden in der agamen Generation durchwegs Gallen auf den Blättern von sommergrünen Eichen (Quercus petraea, Q. pubescens, Q. robur). Cynips-Arten zeichnen sich durch Abundanzen aus, die lokal und periodenweise recht unterschiedlich sein können.\n\n83 Cynips agama Hartig 1840\n( $90^{\\circ}=$ C. mailleti Folliot 1964)\nDie agame Generation verursacht auf Blattunterseite von Eichen (Quercus robur u.a.) kleine gelbliche, kugelige ( $\\varnothing 3-4 \\mathrm{~mm}$ ), etwas abgeflachte Erbsengallen [\"Yellow-pea gall\"]. - [Nieves Aldrey 2001:\n\n462; 133к, 146G]. Die Art gilt als nicht häufig; stellenweise fehlt sie (Pfützenreiter 1958: 128). Gallen von C. agama sind etwas abgeplattet, mehr ovoidal, mit dünner harter Wand und relativ großer Larvenkammer. Oberfläche glatt oder leicht höckerig; Färbung weißlich bis grünlich-gelb, Junggallen oft $\\pm$ gerötet, später bräunlich. Die Gallen sind punktförmig auf Blattnerven befestigt; meist gruppenweise zu mehreren (Buhr 1965: p.955; Nieves Aldrey 2001: p.463). Gallen reifen im August und fallen im Herbst mit den Blättern ab. Nach Buhr (1965) und Gauss (1982) in Mittel-, West- und Südeuropa an diversen Quercus; nach Nieves-Aldrey (2001: 464) in Spanien an Quercus robur. - Nach Fauna Europaea (database 2007) in Österr., Belg., Britann., Irland, Frankr., Deutschl., Polen, Ungarn, Kroat., Bulg., Ukraine, Spanien präsent. - Die Art wird in Checklist Italiens (1995) nicht erwähnt, wurde aber bereits von G. Mayr aus Bozen (seinerzeit bei Österreich) gemeldet.\nDalla Torre (1892; 1896): Blattgallen von Dryophanta agama Htg. an Quercus pedunculata [= Q. robur] in N-Tirol: Ambras, Okt. 1892; Hötting, Kematen u.a. Juli 1894.-DT. (1894: 14): Galle von Dryophanta agama Htg. an Quercus pedunculata [= Q. robur], Bozen (G. Mayr).\nIn Südtirol rezent sehr vereinzelt: Castelfeder am 16.09.2007, 2 Gallen auf Blatt von Q. pubescens (Abb. 83: leg. Hellrigl). Auch in Osttirol bei Dölsach an Q. robur, 02.11.2008, 3 kleine parasitierte glatte Erbsengallen, Ø 1.5-2 mm, blattunterseits an Blattader (leg. A. Kofler, det. Hellrigl). Auch für Trentino vermutlich neu nachgewiesen: am 19.07.2008 in Pomarolo-Servis ( 700 m ), auf Blattunterseite von Flaumeiche eine Galle ( $\\varnothing 4 \\mathrm{~mm}$ ), leg. K. Schanung \\& Hellrigl; die Junggalle (Abb. 83b).\nDie Gallen werden öfters verwechselt mit denen von C. disticha oder C. quercus. Auch die Fundangaben sub „Cynips agama\" aus FVG von Triest Umg. bzw. Gorizia-Turriaco (08.05.1986) durch Tomasi (1996: 45, Nr. 61; 2006: 71) scheinen zweifelhaft und bedürfen einer Überprüfung und Bestätigung. Seine Zitierung von Funden und Literaturangaben von „GRÄFfE (1905: 33, Taf. II, n. 6)\" - der die Art gar nicht erwähnte - ist zweifellos falsch und beruht auf Namensverwechslung mit dort genannten „Gallen der agamen Generation von Trigonaspis renummegaptera\" (GrÄFfE 1905: Tafel II., Fig. 6).\n\n--- Seite 95 ---\n84 Cynips cornifex (Hartig 1843)\nBildet in der agamen Generation auf der Blattunterseite von Q. pubescens auffällige hörnchenförmigen Gallen, mit 10-15 mm langen, anfänglich roten Auswüchsen; Hörnchengallen meist einzeln (1-4 Gallen pro Blatt), selten gehäuft (Abb. 84). Die Hörnchen-Blattgallen auf Querc. pubescens erzeugende Wespe ist eine Entdeckung von Kollar in der Umgegend Wiens, sie wurde von Hartig (1843: 406) beschrieben als \"C. carnifex Kollar\". - Sexualgeneration unbekannt. - [vgl.: Pellizzari 1988: 113; Csóka 1997: 106-107; Kieffer 1901: 636, Pl.XXIV, 4]. - In Europa weit verbreitet; fehlt in Spanien. - Checklist Ital. (1995: Nr. 20/07): N-Italien (Massalongo). FVG: im Triestiner Karst „seltenere Art\"; div. Meldungen von GrÄFfE (1905: 32, Taf. II, n. 4) und Tomasi (1996: 46; Tab. C-9; 2006: 21, 72).\nDalla Torre (1894) Galle von Dryophanta cornifex Htg., an Quercus pubescens, Bozen (G. Mayr). Rezent im Vinschgau am Naturnser Sonnenberg gefunden, oberhalb Staben, 650 m , an kleiner, 25 cm hohen Flaumeiche auf offenem Steppenrasen; einige Blätter waren dicht befallen: leg. et Foto Dr. Leo Unterholzner, 23.06.2004 (Abb. 84). - Vinschgau: Goldrain, 900 m , an Flaumeiche 2 Blätter mit je einer Hörnchengalle, 19.10.2004 (leg./Foto Hellrigl); Goldrain: Fallertal, 780 m , Waldrand an jungen Eichen, 6 Blätter mit 9 Gallen, 10.03.2006 (leg. Hellrigl). Laas-Eyrs, Leiten 900 m , an Flaumeiche $(30 \\mathrm{~cm})$ einige Blätter mit vielen großen Hörnchengallen, 20.08.2008 (leg./Foto S. Minerbi).\nTrentino: Rovereto-Dossi ( 350 m ), Bosco della Città, 01.09.2005: 5 Hörnchengallen an Blättern von Q. pubescens (C. Salvadori \\& K. Hellrigl); ebendort: an niederer Flaumeiche 3 Blätter mit je 1-2 Hörnchengallen, 25.09.2005, sowie am 04.08.2006, vereinzelte Gallen (Bellmann \\& Hellrigl). Unterland: Castelfeder, 16.09.2007, 1 Galle an Blatt von Flaumeiche (leg. Hellrigl); ebendort 17.08.2008 eine große Hörnchengalle an Blatt (leg. Hellrigl \\& Schanung). - In Pomarolo-Servis ( 700 m), im Okt. 2007 und Juni 2008 auf Blattunterseite von Flaumeiche vereinzelte kleine Gallen (leg. Hellrigl); hier am 19.07.2008 an 50 cm kleiner Flaumeiche starker Befall einiger Blätter, mit je 4-8 Hörnchengallen, von 12-14 mm Länge (Abb. 84c) (leg./ Foto Hellrigl \\& Schanung); hier am 27.07.08 eine\nweiterer niederer Strauch ( $30-40 \\mathrm{~cm}$ ), mit vielen Hörchengallen (Abb. 84c); diese rd. 50 „Hörnchen\" ( $7-10 \\mathrm{~mm}$ ) wiesen eineinhalb Monate später, am 07.09.2008, viele Ausfluglöcher von Parasitoiden auf. Am 12.10.2008 ein Eichenzweig mit zahlreichen Gallen sowie ein Eichenblatt mit einzelner großen Hörnchengalle; ebenso 1 Einzelgalle am 30.11.08 in Cavaion/Veronese (leg. Hellrigl). Neumeldung für Trentino.\n\n85 Cynips disticha Hartig, 1840\n\n- „Zweizellengalle\"\n\n( $9 \\delta=$ Cynips indistincta Niblett 1948)\nBildet in der agamen Generation an Blattnerven von Eichen (Q. petraea, Q. pubescens) kleine $\\pm$ kugelige/kegelstumpfförmige Gallen ( $4-6 \\mathrm{~mm}$ ), von gelblicher bis braunroter Färbung; Galle am oberen Ende etwas abgeflacht, oft $\\pm$ vertieft mit kleinem Höcker („Genabelte Eichenblattgalle\"). Die harten Gallen ähneln denen von Cynips agama, haben aber ober der Larvenkammer einen zweiten, tauben Hohlraum [„Two-cell gall causer\"]. - [vgl.: Buhr 1965: 950: Nr. 2476 (ơ); p. 955: Nr. 5493 (agam): T. 16: Fig. 257; Pfützenreiter 1958: Nr. 39, Abb. 31 ( $9{ }^{\\circ}$ Blattgalle); Melika et al. 2000: 283, Figs. 69a,b-d; Nieves Aldrey 2001: 470; Figs. 133 A-B, 147A; Redfern et al. 2002: 413, Fig. 719]. - Bisexuelle Generation mit eiförmigen Blattrandgallen (selten).\nIn Mittel- und Südeuropa weit verbreitet, aber nicht häufig (Buhr 1965; Nieves Aldrey 2001; Redfern et al. 2002). Auch aus N-Italien bekannt (Checkl. 1995: Nr. 20/08). In FVG: Triestiner Karst einige Gallenmeldungen durch GrÄFfE (1905: 31-32, Taf. II, n. 1, Dryophantha disticha): in Umgeb. von Triest selten zu finden; (cit. Tomasi 1996: 46, Nr. 64); Triest-Dolina, 1999 (Tomasi 2006: 72).\nIn Südtirol erstmals rezent nachgewiesen in Brixen-Kranebitt, Schloß Krakofl ( 650 m ), am 08.08.2005: 2 Gallen (agam) auf Blattunterseite von Q. petraea; weitere 2 Gallen ( $4-5 \\mathrm{~mm}$ ), mit Ausflugloch, am 18.08.05 (leg. K. Hellrigl \\& Dr. Volker Lutz). - Tschötscher Heide ( 750 m ), an Q. petraea, 10.04.2005, alte rostrote Galle an vorjährigen Blatt (leg. G. v. Mörl); 2 diesjährige Gallen ( $4-5 \\mathrm{~mm}$ ) an Q. petraea, 17.08.2005 (leg./Foto Hellrigl). Weitere agame Gallen fanden sich bei gezielter Nachsuche an jüngeren, strauchartigen Eichen in sonnigen\n\n--- Seite 96 ---\nRandlagen: Neustift, ober Schießstand ( 700 m ) an Q. petraea, 18.08.05, 2 Gallen (4-5.5 mm); ebendort: 03.09.05, 1 Blatt mit 4 Gallen sowie 2 Blätter mit je 2 Gallen, 14.-17.10.2005, 2 Gallen (leg./ Foto Hellrigl); Gufidaun ( 730 m ), an Q.petraea, 2 Blätter mit je 2 Gallen, 5.09.05 (leg. Hellrigl). Tschötscher Heide ( 750 m ), 14.09.05, an Q.pubescens und Q.petraea, 6 Blätter mit insgesamt 8 Gallen; ibidem: 20.09.05, 7 Blätter und 7 Gallen; ibidem: 30.09.05, 2 Gallen (5-6 mm) und 1 Galle ( 3 mm ); ibidem: 07.10.05, 10 Blätter (Q.pubescens und Q.petraea) mit insges. 12 Gallen (2-5.5 mm), davon 7 mit Ausflugloch; 12.09.08, 1 Blatt, 1 Galle. - Elvas ( 800 m ), 21.09.2005, an Q.petraea, 1 Blatt mit 2 Gallen; Aicha-Spinges ( 850 m ), 11.10.2005, an Q.petraea, 6 Blätter mit 11 frischen Gallen (max 4/Blatt), davon 8 Gallen ( $4.0-5.5 \\mathrm{~mm}$ ) und 3 kleine (2.5-3.5 mm). Neustift, 17.05.2006, an braunem Blatt 2 vorjährige Gallen (ungeschlüpft). AichaSpinges ( 830 m ), 06.09.2006, 11 Gallen (4 Blätter), Neustift ( 700 m ), 08.10.2006, 1 Galle; Tschötscher Heide ( 730 m ), 10.10.2006, 4 Gallen (3 Blätter); idem, 15.11.2007, 1 Galle an Blatt von Q.petraea (alle leg. Hellrigl).\nDie ersten hellgelben Gallen $(\\varnothing=2.5 \\mathrm{~mm})$ im Jahresablauf fand ich am 25.06.2008 an Eichenblättern auf der Tschötscher Heide, zusammen mit zitronengelben Junggallen von C. quercusfolii ( $\\varnothing=1.5-5.5 \\mathrm{~mm}$ ); ebenso einige frische, unausgehärtete Gallen bei Aicha-Spinges ( 850 m ). Ungewöhnlich zahlreich fanden sich Gallen von C. disticha am 11.09.2008 an strauchigen Q.petraea bei Neustift: 15 Blätter mit insgesamt 30 Gallen, davon 8 Blätter mit Einzelgallen, die übrigen mit jeweils 2 bis max 6/Blatt (Abb. 85). - Neu für Südtirol; im Unterland (Castelfeder) und Trentino bisher nicht beobachtet.\nIm mittleren Eisacktal sind die Gallen der agamen Generation ansich nicht selten [ca. 130 Gallen !], aber meist sehr zerstreut, einzeln auftretend und mühsam zu finden, da die Blattunterseiten abgesucht werden müssen. Die kugelig-kegelstumpfförmigen Gallen (Abb. 85a) anfangs gelblich, später rötlichbraun, finden sich wie C. quercusfolii an strauchartigen Eichen. Sie sind relativ klein und von harter Konsistenz beim Durchschneiden und haben eine doppelte Larvenkammer (Abb. 85b); die Larve (in unteren Zelle) ab Mitte Aug. bis Mitte Okt. bereits\nziemlich groß; ab Ende Aug. schon viele Gallen mit Ausflugloch im unteren Teil der Galle (vermutlich von Inquilinen oder Parasitoiden). Aus vorjährigen Gallen von C. disticha (Neustift) wurden am 11.05.2006 gezogen: die Parasitoiden Eurytoma brunniventris (2 ㅇ) und Ormyrus pomaceus (3ㅇ, $4 \\varnothing$ ) sowie die Inquiline Synergus nervosus (1ㅇ).\n[86] [Cynips divisa Hartig 1840 ㅇ]\n[ $9 \\varnothing=$ Spathegaster verrucosus Schlechtendal 1870]; [= Diplolepis schlechtendali Kieffer 1901] Bildet in der agamen Generation auf Blattunterseite von Eichen (Quercus) kugelige, glatte, harte „rote Erbsengallen\" [„Red-pea gall causer\"]. - Gallen rundlich-oval ( $\\varnothing 4-8 \\mathrm{~mm}$ ), oben und unten etwas abgeflacht; anfangs grün-gelblich, bald kräftig rot, später braun, glänzend (\"Braune Glanzgalle\"); fast holzig, relativ dünnwandig, Larvenkammer querlänglich. Meist in Gruppen zu mehreren an den Blattadern auf Blattunterseite; Entwicklung im Sommer; Reife im Herbst, mit den Blättern abfallend. - [BuHR 1965: Taf. 16, Fig. 258, 259; Pfützenreiter 1958: Nr. 37, Abb. 29 ( $2 \\varnothing$ Braune Glanzgalle); Csóka 1997: 106-107; Melika et al. 2000: 283, Figs. 70; Nieves Aldrey 2001: 133 I-J, 146 H]. - Sexualgeneration im Frühjahr an Eichen mit ovoidal-konische Warzengallen (,Red-wart gall causer\").\nIn Europa weit verbreitet; in Mitteleuropa örtlich nicht selten, Abundanz lokal und periodenweise recht unterschiedlich (Pfützenreiter 1958: 128); vereinzelter offenbar im Süden. (Abb. 86 )\nIn Norddeutschland (Braunschweig) fand Th. Hartig seinerzeit die agamen Gallen massenhaft und sammelte davon allein im Sommer 1840 rd. 28.000 Gallen, aus denen 10.000 Imagines schlüpften, alles $9 \\varnothing$ (Hartig 1843: p.398). - Von Dalla Torre (1894: 15; 1896: 153) werden Gallen von Dryophanta divisa Htg. mehrfach aus N-Tirol angeführt von Quercus pedunculata ( $=$ Q. robur): Volderwald bei Hall, Sept. 1893 und Eichenwald bei Stams, Sept. 1894.\nIn Osttirol rezent bei Dölsach/Arguntum an Q. robur, 23.07.2008, 5 gelbe, glatte Erbsengallen, Ø 6-7 mm (leg. A. Kofler, det. Hellrigl). Aus N-Italien gemeldet (Checkl. 1995: Nr. 20/09). In FVG von Triest Umg. Gallenmeldungen durch Tomasi (1996: 46-47, n. 65; Tab. C-10; 2006: 72,\n\n--- Seite 97 ---\nCecidothek FVG;), doch scheint eine Überprüfung angebracht, da die Galle öfters verwechselt wird und GrÄFFE (1905) die Art dort nicht meldet. - Aus Südtirol-Trentino sind mir keine Funde bekannt!\n\n87 [Cynips longiventris Hartig 1840]\n[ $9{ }^{\\circledR}=$ Spathegaster similis Adler 1881]\nDie agame Generation bildet im Sept. an der Blattunterseite diverser Eichen eine auffällige, kugelig abgeflachte Ziergalle ( $\\varnothing 6-10 \\mathrm{~mm}$ ), mit konzentrischen weißlichen Höckerreihen und dazwischen roten Streifen (= „Striped-pea gall\"); [vgl. Zahradnik 1985: 77; Amann 1990: 87; Csóka 1997: 108/109; Bellmann 1999: 255; Redfern et al. 2002: 414, Fig. 721]. - Sexualgeneration an Adventivknospen mit unauffälligen, grünlich-grauen, dicht weiß behaarten Knospengallen („Green velvet-bud gall\"). [Pfützenreiter 1958: Nr. 13 (9) Graugrüne Samtgalle); Nr. 36, Abb. 27 (Ziergalle); Riedel 1910: Nr. 10 Dryophanta similis Adl. 98, T. VI, 10; Nr. 33 Dryophanta longiventris Htg. 9, T.IV, 33].\nIn Nord-, Mittel- u. West-Europa weit verbreitet (Zahradnik 1985); Britannien, Irland, Frankreich, Belgien, Dänemark, Holland, Deutschland, Polen, Finnland, Schweden u.a.; im Süden offenbar selten; keine sicheren Nachweise in Spanien (Nieves Aldrey 2001: 458) und Italien (Checkl. 1995: 20/17). Es gibt aber alte Bildtafeln der Gallen von F. Redi (04.06.1667) aus Mittelitalien (Toskana, Etrurien) (Bernardi et al. 1997: 174-175, Fig. C 40). - In FVG wird die Galle von Tomasi (2006: 72) vom Triestiner Karst aus Duino-Aurisina, 14.06.2001, an $Q$. pubescens angegeben. Schon früher hatte dort Tomasi (1996: 24, 132: Tab. C-12) die Galle von C. longiventris abgebildet (Tab. C-12) aber fälschlich als „Andricus ambiguus\" bezeichnet. GrÄFFE (1905) nannte die Art aus Triest nicht.\n\nAuch Dalla Torre (1892-94) erwähnt die „Ziergalle\" nicht aus Tirol. - Vormalige Meldung von „Gestreifter Eichengalle\" aus Südtirol (Hellrigl 1996) beruhen auf früherer Fehlbestimmung atypischer, höckeriger Gallen von C. quercusfolii. In den letzten Jahren gelangen keine Fundnachweise im Eisacktal und im Unterland oder im Trentino; wahrscheinlich fehlt die Art hier.\nHingegen wird die „Eichenblatt-Ziergalle\" von A. Kofler (2007) aus dem angrenzenden Osttirol, vom „Lienzer Talboden: Sonnseite\" als nicht selten\nangegeben und abgebildet (in coll. A. Kofler); hier bei Schloß Bruck an Stieleiche (Q. robur) Ende Okt. 2008 noch drei unreife Gallen [3-6mm] mit konzentrischen Höckerreihen (leg. Hellrigl \\& Kofler). Solche unreife Junggallen (30.09.2008) kenne ich auch aus NW-Frankreich (Bretagne) (Abb. 87).\nHierher zu beziehen ist wohl auch jene Gallenbeschreibung, die LinNE (1767: p.918) unter „Cynips quercusinferus Lin.\" gibt: \"In Gallis foliorum Quercus globosis, opacis, rubris, pagine inferiori innatus, magnitudine Avellanae in Svecia vulgaris\". - Wie schon Hartig (1840: 204) vermutete, dürften die „einkammerigen, kuglichen, glanzlosen rothen, (haselnußgroßen, in Schweden gemeinen) Gallen auf der Unterseite der Eichenblätter die des Cynips longiventris sein\" - „hingegen gehört die [dazu] beschriebene Wespe wahrscheinlich [einem Inquilinen] der Gattung Synergus an.\"\n\n88 Cynips quercus (Geoffroy in Fourcroy 1785) $99[=$ Dryophanta pubescentis Mayr 1881]\n[= Spathegaster flosculi Giraud 1868] 98\nAgame Generation mit kugeligen Blattgallen an Q. pubescens u.a. Eichen; Sexualgeneration mit axillären Knospengallen. Die glatten und relativ harten, erbsengroßen Gallen ( $\\varnothing 5-10 \\mathrm{~mm}$ ) der agamen Generation, an Blattnerven auf der Unterseite von Eichenblättern, sind hell gelblich bis rosarot oder lila-violett, glanzlos und $\\pm$ weiß bereift; dickwandig, mit ziemlich hartem Gewebe und relativ großer Gallenkammer. Blattgallen ab Sommer, Gallenreife im Sept./Okt., fallen von den Blättern nicht ab. - [Buhr 1965: Knospengallen: Nr. 5413, 5446; Blattgallen: Nr. 5491; Nieves Aldrey 2001: 459, 545, 560; Figs. 133 m-n, 146 f; Kieffer 1901: 635-636, Dryophanta flosculi (sex.), D. pubescentis (agam)]. Südl. Mitteleuropa (Ost-Österreich, Ungarn), Südwest- u. Südosteuropa (Frankr., Spanien, Balkan).\nAngaben für Deutschland und Polen (Fauna Europaea 2007) erscheinen zweifelhaft, denn Riedel (1910: Dryophanta) und Kieffer (1914: Diplolepis) nennen sie nicht für Deutschland und auch Pfützenreiter (1958: 128) führt sie nicht vom untersuchten Favoritenpark (Ludwigsburg/Stuttgart). Häufiger in Südeuropa. In Checklist Ital. (1995) als Cynips flosculi Giraud (Nr. 20/10) und C. quercus\n\n--- Seite 98 ---\n(Nr. 20/21) sowie C. pubescentis (Nr. 20/20) als getrennte Taxa geführt und jeweils aus N-Italien und Sizilien angegeben.\nFVG: vom Triestiner Karst Gallenfunde durch GräFfE (1905: 31, Cecidothek FVG) „um Triest ist D. pubescentis - flosculi nicht sehr häufig zu finden.\" [Tomasi (1996: 47, n. 67, C. quercus)]. Später von Tomasi (2006: 73) aus Triest doppelt angeführt als C. pubescentis (16.07.2000) und C.quercus (17.10.1993). Bernardi (1997: 216, Fig. 55): N-Italien, Toskana, Sizilien.\nDalla Torre (1894: 15) Galle von Dryophanta pubescentis Mayr an Quercus pubescens, Bozen (G. Mayr). - Dalla Torre (1896: 153) idem: Atzwang 24.07.1894. - Die Art ist in Südtirol weit seltener als C. quercusfolii, deren Blattgallen deutlich größer ( $8-23 \\mathrm{~mm}$ ), dickwandig und saftig-fleischig sind, mit relativ kleiner zentraler Larven-Kammer. Cynips quercus wurde im mittleren Eisacktal - wo C. quercusfolii häufig ist - bisher nicht gefunden; wahrscheinlich fehlt sie im mittleren/oberen Eisacktal und im Pustertal. Rezente Funde nur vom Etschtal: Montan-Castelfeder und bei RoveretoPomarolo.\nNeumeldung für Trentino, mit rd. 50 rezenten Gallenbelegen (leg./foto K. Hellrigl):\nRovereto, Bosco della città ( 350 m), 05.04.2005, harte dickwandige Galle ( 9 mm ) an trockenem Blatt von Q. petraea; ebendort: 01.09.2005, an Q. pubescens 2 Blätter mit je einer frischen Galle ( $\\varnothing 8 \\mathrm{~mm}$, gelblich + violett), sowie 1 Blatt mit 3 abgeflachten Gallen ( $\\varnothing 5-6 \\mathrm{~mm}$, gelb, hartwandig); ebendort: 25.09.2005, 1 Blatt mit 5 Gallen sowie 4 Blätter mit je 1 Galle an Q. pubescens: Gallen gelblich-lila, matt, Ø 8 mm , hart und dickwandig. Weitere C. quercus-Gallen aus Trentino: Rovereto, 04.08.2006, an Flaumeiche 8 Gallen ( $\\varnothing=6.5 \\mathrm{~mm}$; 6.5 mm (jung); 8.5; 8.5; 9.0; 9.0; 9.0; 10 mm ) sowie 4 junge vertrocknete; Rovereto, 03.10.2007: 5 Gallen ( $7-8.5 \\mathrm{~mm}$ ) einzeln an Blättern (weiterhin keine C. quercusfolii). - Pomarolo-Servis (IT04: 700 m ): 14.10.2007, an Q. petraea 2 Gallen (Ø 7 mm ); ebendort, 28.10.2007, 11 Gallen (6; 6; $7 ; 7 ; 7 ; 7.5 ; 8 ; 8 ; 8 ; 8.5 ; 9.5 \\mathrm{~mm}$ ) teilweise auch an Blättern an bodennahen Zweigen (leg. Hellrigl \\& Mörl). Pomarolo-Servis: 19.07.08: 2 Blattgallen, jung ( $5-7 \\mathrm{~mm}$ ); 27.07.08: 2 Blattgallen ( $6-9 \\mathrm{~mm}$ ) (leg. Hellrigl \\& Schanung); ebendort: 07.09.2008:\n\n12 Blattgallen (4.5; 5; 6; 6; 6.5; 7; 7.5; 8; 8; 8; 8; 9 mm ) und am 12.10.08 drei Gallen (leg. Hellrigl \\& Mörl).\nIn Südtirol wenige Belege agamer Blattgallen im Eichenhain Castelfeder ( 350 m ) bei Auer-Montan, an Q. pubescens: 10.08.2005, 1 Galle ( 6 mm , gelb, hartwandig); 24.09.2006, 6 Gallen C. quercus $(\\varnothing=6 ; 7 ; 7 ; 8 ; 8 ; 8 \\mathrm{~mm})$, aber vergleichsweise nur wenige C. quercusfolii (4 Blätter mit 10 Gallen); 16.09.2007: keine C. quercus gesehen, dafür aber einzelne Blätter mit C. quercusfolii; am 17.08.2008: ein Blatt mit 2 Gallen C. quercus ( $7.0 ; 8.5 \\mathrm{~mm}$ ). - Von den rezenten 70 Gallenbelegen (agam) aus der Region stammen nur 10 aus dem Südtiroler Unterland (vgl. Grafik 7). Es fällt auf, dass die Art mehr im Süden vorkommt, wo C. disticha bisher gänzlich fehlt (Südtiroler Unterland, Trentino) und C. quercusfolii selten ist (Unterland) oder ebenfalls fehlt (Trentino).\nIn Gallenzuchten schlüpften von C. quercus aus Pomarolo 3 Imagines im Jan./Febr.2008; hingegen aus Blattgallen von Rovereto nur Parasitoiden: 10.05.24.06.2006, 10 Torymus cyaneus $(4 \\bigcirc+6$ 今́ $)$.\n\n89 Cynips quercusfolii Linnaeus 1758 99\n[= C.scaber Geoffroy 1785; = C.folii Hartig 1840]\n[= Diplolepis scutellaris Olivier 1791]\n[9@ = Spathegaster taschenbergi Schlechtendal 1870]\nDie agame Generation bildet im Sommer an der Unterseite von Eichenblättern kugelige, fleischige Blattgallen, von $10-22 \\mathrm{~mm} \\varnothing$, bekannt als „Gemeiner Gallapfel\" oder „Kirschgalle\" (= „Cherry gall\"). Die Gallen sind gelblich-grün, an der Sonne teilweise rot, später werden sie braun und schrumpfen. - Sexualgeneration bildet im April/Mai an schlafenden Knospen von Ästen und Zweigen kleine ( 3 mm ), eiförmige, rot-violette Samtgallen („Violet-egg gall\").- [Riedel 1910: Nr. 9 Dryophanta taschenbergi Schlecht., 9@, T. IV, 9; Nr. 33 Dryophanta folii L. 9, T. VI, 31; Pfützenreiter 1958: Nr. 11 (sex.); Nr. 25, Abb. 30 (agam); Buhr 1965: 954, Nr. 5490; T. 16: Fig. 255; Zahradnik 1985: 76-77; Amann 1990: 260; Nieves-Aldrey 2001: 455, 544; Fig. 133 c-d; Redfern et al. 2002: 413, Fig. 720]. In Europa weit verbreitet, hauptsächlich in Nordund Mitteleuropa, lokal oft häufig, doch gebietsweise recht unterschiedlich; seltener bis fehlend\n\n--- Seite 99 ---\nim Süden. Darauf weist bereits Kieffer (1901: 635) hin, indem er von Dryophanta folii schreibt: \"Manque probablement dans l'Europe méridionale. Malpighi, Massalongo, Trotter, Licopoli et De Stefani n'en font pas mention pour l'Italie.\" [Fehlt wahrscheinlich in Südeuropa. Malpighi, Massalongo, Trotter und De Stefani erwähnen sie nicht aus Italien].\nIn Checklist Ital. (1995: Nr. 20/22) nur aus N-Italien angegeben. - In FVG vom Triestiner Karst Meldungen durch Gräffe (1905: 29-30, Taf. I, n. 9, Dryophanta folii - taschenbergi Schlecht.) und Tomasi (1996: 48, n. 68; Tab. C-5), um Triest überall in Eichenwäldern.\nDalla Torre (1892:147; 1894:14) Gallen von Dryophanta folii an Quercus pedunculata: Atzwang, Aug. 1884 (Peyritsch); Bozen (G. Mayr); auch häufig in N-Tirol. Diese auffällige, in Südtirol häufige Art fehlt überraschend bei Bezzi (1899) und Cobelli (1903) für Trentino, was zunächst an Verwechslung denken ließ. Es zeigte sich aber bei den rezenten Untersuchungen, dass C.quercusfolii zwar im Eisacktal ab Hochsommer ungemein häufig ist, hingegen weiter im Süden, im Etschtal, bei Castelfeder und Neumarkt/Pinzon recht selten auftritt und bei Rovereto in allen Untersuchungsjahren 2005-08 überhaupt nie gefunden wurde!\nFrühere Meldungen: Hellrigl (1996): „Gemeine Eichenblattgallwespe\", in Südtirol weit verbreitet. Hellrigl (1997: 65: Abb. 6): Tschötsch/Brixen, Q. pubescens, 31.08.1990. - Ritten: Oberbozen, Klobenstein 1150-1250 m, Q. petraea, 03.08.1999 (leg. Hellrigl). - Tschögglberg, Vöran, 07.09.1998, an Quercus (leg. R. Franke). - Rezente Nachweise: Neustift-Raas, 17.10.2004, viele Gallen an Q.petraea (leg. Hellrigl) (Abb. 89). Tschötsch ( 750 m), 10.04.2005, an braunen Blättern von Q. pubescens zahlreiche alte Gallen (teils noch an den Zweigen, meist abgefallen am Boden); es wurden 70 Gallen (Ø 10-19 mm) gesammelt (leg. Hellrigl \\& Mörl). Bei Neustift-Schießstand ( 750 m), am 13.04.2005, 75 alte Gallen (Ø 9-20 mm) an Q.petraea, meist mit den Blättern abgefallen am Boden: 20 Blätter mit 1-2 Gallen, 10 Blätter mit 3-5 Gallen, 3 Blätter mit je 4-7 Gallen, einige Gallen lose am Boden; die größeren Gallen alle mit Ausflugloch. Elvas $(800 \\mathrm{~m}), 16.04 .2005$ an alten Blättern von Q.petraea, 45 vorjähr. Gallen (Ø 14-19 mm): 14 Blätter\nmit 1-2 Gallen, 8 Blätter mit 3-4 Gallen. Aus den Gallen schlüpften im April noch diverse Parasitoiden und Inquilinen.\n\n## a.) Entwicklung und Größe der agamen Kugelgallen\n\nIm Jahre 2005 fanden sich erste frische Gallen im Juli: 07.07.2005, bei Pinzon ( 450 m) an Q. petraea, 3 Gallen ( $7-9 \\mathrm{~mm}$ ); 20.-23.07.2005, Neustift ( 700 m ), Tschötsch ( 750 m ) und Aicha-Spinges ( 850 m): div. halbwüchsige Gallen (Ø 10 mm ). Anf./Mitte Aug. bereits größere Gallen (Larven in zentraler Kammer noch klein): am 15.-17.08.2005, Tschötsch ( 750 m ), an Q.petraea 35 Gallen (Ø 8-17 mm); 18.08.2005, Brixen/Kranebitt, Krakofl ( 650 m), an Q.petraea schon viele sehr große Gallen ( $\\varnothing$ bis 21 mm ) (leg./ Foto Hellrigl \\& V.Lutz).\n03.09.2005: Neustift/Schießstand ( 700 m), Gallen massenhaft an Q.petraea (max 8 Gallen/ Blatt); insgesamt 108 Gallen ( $\\varnothing 10-20 \\mathrm{~mm}$ ) auf 50 Blättern gesammelt (Larven bereits relativ groß); 05.09.2005: Gufidaun ( 730 m ), einige groBe Gallen (eine bereits mit Puppe); 14.09.2005: Tschötsch ( 750 m ), an Q. pubescens und Q.petraea insgesamt 106 Gallen (Ø 8-22 mm: $50 \\%=\\varnothing 16-$ 19 mm ); Stichprobenuntersuchung von 8 Gallen (Ø 11-19 mm) ergab, daß bei $50 \\%$ bereits Puppen mit verfärbten Augen vorhanden waren, bei der anderen Hälfte verpuppungsreife Larven; ibidem: 20.09.05: auf 20 Blättern 28 Gallen (Ø 8-19 mm). Elvas ( 800 m ), 21.09.05: 58 Blätter von Q. petraea, mit 98 Gallen (Ø 8-22 mm). Vinschgau: Vetzan, $750 \\mathrm{~m}, 29.09 .2005$, einige Gallen an Q.petraea.\nWeitere [569] Blattgallen im Herbst 2005 wurden zur Vermessung gesammelt, vornehmlich an Q.petraea: Tschötscher-Heide ( 750 m ): 01.10.05 [157] und 07.10.05 [101]; Neustift ( 700 m ): 24.09.05 [67], 30.09.05 [108] und 14.10.05 [119]; Aicha-Spinges ( 850 m ): 11.10.05 [17]. - Eine Vermessung von 821 reifen Gallen (Mitte Sept. bis Mitte Okt. 2005) aus Brixen Umg. ergab Durchmesserverteilung von 8-23 mm mit Maximas von 15-19 mm Ø (Grafik 8). Kleinere Gallen ( $<8 \\mathrm{~mm}$ ), meist mit höckeriger Oberfläche, wurden nicht berücksichtigt, da sie in der Regel durch Parasitierung oder Absterben der Larven zurückgeblieben sind; nur einmal fand sich in einer kleineren Galle ( $\\varnothing 6 \\mathrm{~mm}$ ) eine voll entwickelte Wespe von C. quercusfolii (24.10.2005).\n\n--- Seite 100 ---\nZweck dieser Vermessung war: 1.) Feststellung der Größenverhältnisse und allfälliger Trends bzw. Unterschiede in verschiedenen Lokalitäten; 2.) Abgrenzung der Gallen von C. quercusfolii gegenüber solchen von Trigonaspis synaspis und eventuell von Cynips quercus. - Die Untersuchungsreihe ergab eine eindeutige Abgrenzung gegenüber den deutlich kleineren Trigonaspis synaspis (vgl. Grafik 8); hingegen konnten die völlig anders aussehenden und viel kleineren Gallen von C. quercus (Grafik 7) im Eisacktal überhaupt nicht gefunden werden, ebensowenig „Gestreifte Ziergallen\" der hier auch fehlenden Cynips longiventris. Bemerkenswert ist, dass im Eichenhain von Castelfeder/Montan am 10.08.05 nur vereinzelt Gallen von C. quercusfolii gefunden wurden und ebenso bei späteren Kontrollen am 16.09.07 und 23.06.08. Hingegen waren im Eichenwald von Rovereto, trotz sorgfältiger Suche am 01.09.05 und 25.09.2005, keine Gallen von $C$. quercusfolii zu finden; statt diesen fanden sich hier an Eichenblättern vereinzelt Gallen von Cynips quercus. Dasselbe wiederholte sich in den Folgejahren im Trentino bei Rovereto und Pomarolo, wo sich keine C. quercusfolii fanden, wohl aber regelmäßig C. quercus (siehe dort).\n\n## b.) Imagines der agamen Generation (Blattgallen)\n\nDie ersten Imagines der agamen Generation fanden sich im Herbst ab Ende Sept. 2005 in den Gallen. Eine Stichprobenuntersuchung am 15.10.2005 von 20 Gallen (Ø 8-19 mm) von Neustift-Schießstand $(700 \\mathrm{~m})$ ergab in 13 Gallen (Ø 10-19 mm) schon fertige Imagines ( $65 \\%$ ), meist mit bereits begonnenem bis fast fertigem Ausbohrgang; 1 Galle (Ø 12 mm ) mit verpilzter Puppe; 2 Gallen (Ø 14-16 mm) enthielten reife Larven, 2 Gallen (Ø 11-15 mm) Larven mit Ektoparasiten-Larven, 2 Gallen (Ø 8-10 mm) mit halbwüchsigen Larven. - Eine weitere Stichprobe aus Neustift am 22.10.2005, von 25 Gallen (Ø 10-20 mm), ergab in 15 Gallen (Ø 14-20 mm) bereits lebende Imagines ( $60 \\%$ ) mit fertigem Ausbohrkanal bis zur Epidemis; in 5 Gallen (Ø 12-17 mm) waren größere Larven in zentraler Kammer, in 5 Gallen (Ø 10-14 mm) kleinere Larven mit Ektoparasitoiden-Larven.\nDie weitere Entwicklung und das Schlüpfen der Gallwespen verliefen rascher als erwartet. Nachdem\ndie ersten fertigen Wespen in den Gallen schon seit 22.-28.10.2005 bis 16.11.2005 (Neustift) vorgefunden wurden, erfolgte der Schlüpfbeginn aus den im Freien am Balkon in Plastikdosen aufbewahrten Gallen am 28.11. bis 02.12.05, als die ersten $7 \\square$ außen am Türrahmen hochkrochen (bei Außentemperatur: $+1^{\\circ}$ bis $-3^{\\circ} \\mathrm{C}$ ). Am 3. Dez. fanden sich um 11 Uhr , bei $+3 / 4^{\\circ} \\mathrm{C}$ und Schneefall, am Zuchtbalkon $26 \\square$ C. quercusfolii. Vom 4.-6. Dezember schlüpften bei Temperaturen von $+2^{\\circ}$ bis $+5^{\\circ} \\mathrm{C}$, und teilweisem Schneefall, weitere 55 Gallwespen. Am 19.12.05 saßen am Balkon (bei $-4^{\\circ} \\mathrm{C}$ ) 32 Gallwespen bewegungslos in den Zuchtdosen, wurden ins Zimmer geholt aber sogleich beweglich.\nAm 03.01.2006 waren weitere C. quercusfolii am Balkon frei geschlüpft (Dose 1: 66 ㅇ); [Foto lebender Wespen im Glas]; bis 10.01 .06 schlüpften nochmals 81 Wespen. - Insgesamt waren somit im Schlüpfzeitraum vom 28.11.05-10.01.2006 [43 Tage $=6$ Wochen] am Freibalkon 269 C. quercusfolii geschlüpft; dabei waren zahlreiche weitere aus den teilweise offen gelassenen Zuchtdosen entkommen (vgl. Anzahl Fluglöcher in den Gallen). - Bei späteren Kontrollen der 5 Überwinterungsdosen zeigte sich, dass nach dem 10.01.2006 keine weiteren Wespen mehr geschlüpft waren! Die letzten Wespen wurden 18.-26.02.06 lebend im Zuchtglas gesehen; 1 Ex lebte noch am 25.03.06 (ca. 3 Monate).\nZum Vergleich mit den Ergebnissen der Herbst-/ Winterzucht 2005/06, wurde im Frühjahr 2006 eine Freilanderhebung in Brixen-Umgebung durchgeführt. In Neustift wurden am 19.03.2006 vom Boden 140 Blattgallen von C. quercusfolii aufgesammelt; davon waren: mit Flugloch 40 Gallen ( $28,6 \\%$ ), geschlossen $55(39,3 \\%)$, von Vögeln aufgehackt mit lebenden Larven $20(14,3 \\%)$, von Vögeln aufgehackt leer $25(17,9 \\%)$. Das heißt insgesamt waren 65 Gallen ( $46,4 \\%$ ) leer ( 40 mit Flugloch +25 aufgehackt) und 75 Gallen enthielten noch lebende Larven, bei denen es sich - wie die Nachzucht ergab - durchwegs um Parsitoiden und vereinzelt umd Inquilinen handelte. Insgesamt schlüpften aus den besetzten Gallen noch 79 Hymenopteren: 14 Inquilinen (Synergus gallaepomaeformis ㅇ) und 4 Arten von Parasitoiden ( $65 \\mathrm{Ex}=82 \\%$ ): 5 Eurytomidae: Eurytoma brunniventris (4ㅇ) und Sycophila biguttata (1ㅇ), sowie 2 Arten Torymidae\n\n--- Seite 101 ---\n(66\\% 99): 51 Torymus nitens und 9 Torymus cyaneus (leg./det. Hellrigl); T. cyaneus findet sich nur selten bei C. quercusfolii (hingegen regelmäßig bei C. quercus).\nEine Vergleichszählung am 25.03.06 mit der Balkonzucht von C. quercusfolii $(\\mathrm{N}=820)$ ergab: Gallen mit Flugloch ( $381=46,5 \\%$ ), Gallen ohne Flugloch ( $439=53,5 \\%$ ); geschlüpfte Wespen vorgefunden (in Zuchtgläsern): 198 99 - weitere 183 99 sind entkommen (Gallen in offenen Behältern). Diesen Vergleichszahlen ist zu entnehmen, dass die Anzahl „leerer\" Gallen - d.h. regulär geschlüpfter plus von Vögeln (erfolgreich) geräuberten - in der Zucht und im Freiland mit jeweils rd. $46 \\%$ gut übereinstimmten; die Mortalität durch räuberische Vögel liegt bei rd. $18 \\%$.\nEin analoges Bild ergab sich beim Schlüpfverlauf von C. quercusfolii im Herbst/Winter 2006/07. Der Befall war im im Herbst 2006 wiederum außergewöhnlich stark gewesen, so dass sich massenhaft \"Kirschgallen\" an den Eichenblättern fanden, z.B. in Tschötsch, am 03.09.2006 an 4 benachbarten Blättern 18 Gallen (Foto), und in Elvas am 10.10.06 an einem Zweig über 3 Dutzend Gallen (Foto). Etwa 120 Blattgallen, die im Sept./Okt. 2006 in Brixen Umg. bei Neustift, Tschötsch und Elvas gesammelt worden waren (vgl. „Forest Observer\" 2006: p. 477-479) wurden in Aufzucht genommen.\n\nDas Schlüpfen aus den Gallen am Freiluftbalkon begann am 30.11.2006 bei $+4^{\\circ} \\mathrm{C}$; bis zum 31.12.06 waren bei Temperaturen von $-1^{\\circ} \\mathrm{C}$ bis $+9^{\\circ} \\mathrm{C}$ [vorherrschend +2 bis $4^{\\circ} \\mathrm{C}$ ] $38 \\varrho \\varrho$ geschlüpft. Weitere $23 \\varrho \\varrho$ schlüpften vom 1.-10.Jan. 2007; nach dem 10.01.2007 schlüpften keine weiteren Exemplare mehr.\nInsgesamt waren somit 61 Imagines (99) geschlüpft; am 29.01.2007 wurden noch 16 lebende Wespen gezählt; 24 Ex waren zuvor am 23.12.2006 an Stieleichen im Lidopark ausgesetzt worden und weitere 20 Ex am 16.01.2007, jeweils bei Temperaturen um $+2^{\\circ} \\mathrm{C}$.\nBei der Endkontrolle wurden noch 51 ungeschlüpfte C.quercusfolii-Gallen gezählt; d.h. rd. $55 \\%$ der 112 Gallen waren regulär geschlüpft, aus den übrigen schlüpften später nur mehr Parasitoide (Torymus sp.) und Inquilinen (Synergus sp.). Die Schlüpfspanne von C. quercusfolii 2006/07 hatte 41 Tage betragen [30.11.06-10.01.07], die im Vorjahr\n\n2005/06 währte 43 Tage [28.11.05 - 10.01.06] und die zuvor im Jahre 2004/05 ebenfalls 43 Tage [15.12.04 - 27.01.05]. Daraus ergibt sich im dreijährigen Mittel eine Schlüpfperiode von ziemlich genau 6 Wochen.\nIm Sommer 2007 war der Befall in Brixen-Umg. weiterhin stark, etwas schwächer als im Vorjahr; dafür fanden sich in Castelfeder, am 16.09.2007, mehr Gallen (wenige Bäume, an einzelnen Blättern aber 2-5 Gallen) als in früheren Jahren; kein Befall weiterhin in Rovereto/Pomarolo zu beobachten.\nDie Befallsstärke in Brixen-Umg. zeigte sich auch an einem Traubeneichen-Strauch bei Elvas ( 800 m ), bei dem am 08.11.2007 an einem Zweig von 20 cm Länge 43 Gallen gezählt wurden (vgl.Abb. 89).\nIm Herbst/Winter 2007/08 waren Anfang/Mitte Nov. 2007 in Brixen Umgeb. bei Elvas, Neustift, Aicha und Tschötsch wiederum 140 „Kirschgallen\" von C.quercusfolii gesammelt worden. Das Schlüpfen aus den Gallen am Freiluftbalkon (nach Kälteperiode vom 13.-18. Nov. mit bis $-5^{\\circ} \\mathrm{C}$ ) begann am 30.11.2007 nachmittags bei $+4^{\\circ} \\mathrm{C}$ mit 3 Imagines. Bis Mitte Dezember schlüpften noch vereinzelt weitere Gallwespen; die letzte C.quercusfolii am 05.01.2008 - die Schlüpfspanne betrug 37 Tage. Die Mortalität war relativ hoch infolge starker Parasitierung. Insgesamt schlüpften aus den Gallen noch 80 Hymenopteren: 3 Inquilinen (Synergus sp.) und 2 Arten parasitoider Torymidae (64 Ex): 52 Torymus nitens ( $81 \\%$ ) und 12 Torymus cyaneus ( $19 \\%$ ); letztere war dabei nur am Fundort Elvas vertreten.\nIm Jahr 2008 war für die Blattgallen von C.quercusfolii in Südtirol folgender Verlauf zu verzeichnen: erste kleine Kugelgallen an der Unterseite der Blätter, fanden sich ab Ende des Frühjahrs im Eisacktal: 18.06.08, bei Raas ( 830 m ) an Traubeneichen vereinzelt, ebenso bei Elvas am 23.06.08, sehr kleine Gallen ( $1-2 \\mathrm{~mm}$ ) an den Seitenadern; Tschötscher Heide, am 25.06.2008, relativ zahlreich und durchwegs noch klein (Ø 1.5 - 3.0 - 5.5 mm ) an Flaumund Traubeneiche (Fotos Hellrigl). - Unterland: Castelfeder an Flaumeiche, 22.06.2008, sporadisch kleine Gallen ( $6-9 \\mathrm{~mm}$ ) auf Blattunterseite (Fotos). Die kleinen Junggallen fallen auf durch gekörnte Oberfläche und zitronengelbe Färbung.\nAm 17.08.08 wurde in Castelfeder ein Eichenblatt mit mehreren bereits größeren Gallen (Ø 15-16mm)\n\n--- Seite 102 ---\ngesammelt (Foto Hellrigl); die Art war hier aber weiterhin nur spärlich vertreten. Im Trentiner Etschtal (Pomarolo und Rovereto) nach wie vor kein Nachweis. - Zahlreiches Vorkommen, wie bereits in den letzten Jahren, wurde hingegen im Eisacktal registriert, an den üblichen Plätzen bei Aicha-Spinges $(850 \\mathrm{~m})$, Elvas $(850 \\mathrm{~m})$, Tschötscher Heide $(750 \\mathrm{~m})$ und Neustift ( 700 m ) fanden sich am 10.-12.09.08 größtenteils ausgewachsene Gallen von 12-24mmØ; meist mehrere Gallen (2-8) pro Eichenblatt.\nEine Kontrolle am 15.09.2008 von 12 quercus-folii-Gallen (Ø 13-21 mm) aus Tschötsch ergab: 1 Junglarve abgestorben $(\\varnothing=13 \\mathrm{~mm}), 1$ Junglarve mit Ektoparasit $(\\varnothing=14 \\mathrm{~mm}), 4$ Altlarven verpuppungsreif (Ø 16 - 20 mm ); in 6 von 12 Gallen fanden sich bereits frische Puppen mit dunklen Augen, zwei dieser 6 Puppen waren sogar schon zur Gänze dunkel verfärbt und schlüpfreif (Abb. 89).\nBei einer weiteren Kontrolle in Neustift, am 20.09.08, fanden sich erste fertige Wespen in den Gallenkammern. Zur Ermittlung des Anteils bereits entwickelter Gallwespen in den Zellen, wurden am 30.09.08 in Neustift ( 700 m ) 200 quercusfolii-Gallen gesammelt und untersucht [Ø 12 - 24 mm$]$ : Lebendrate: 96 [ 80 Wespen +16 Puppen] $=48 \\%$; parasitiert: 40-66 $=20-33 \\%=1 / 4$ bis $1 / 3$; Mortalität: 38 Ex. $=19 \\%$ $=$ ca. $1 / 5$; d.h. 6 Larven waren verschimmelt und 32 Larven in braunen, mit Fraßgängen durchzogenen Gallen waren durch Rüßlerlarven zerstört worden - vermutlich den Eichengallenbohrer, Archarius (Curculio) pyrrhoceras (Marsham, 1802). Neben dem hohen Anteil bereits fertig entwickelter Wespen in den Gallen, war überraschend, dass Ende Sept./Anf. Okt. einige bereits begonnen hatten, den Ausbohrgang von der Larvenkammer zur Oberfläche zu nagen (Foto). Zwei Monate später, am 30.11.08 lebten noch sämtliche Imagines in Gläsern im Freien am Balkon; und auch am 31.12.2008 wurden von den letzten verbliebenen 20 Wespen noch 15 lebend vorgefunden ( $75 \\%$ ).\nErstaunlich war, dass nach einem bereits seit 5 Jahren anhaltendem Massenbefall, noch immer eine ungebrochen hohe Lebendrate mit relativ geringer Parasitierung festzustellen war. Bemerkenswert ist weiters, dass die im Herbst des regenreichen Jahres 2008 gesammelten 200 Gallen von C. quercusfolii signifikant größer waren als die Gallen des Trockenjahres 2005 (vgl. Grafik 8).\n\n## c.) Gallen und Wespen der bisexuellen Generation\n\nBereits Forstrat Theodor Hartig hatte seinerzeit in Niedersachsen (Braunschweig) die agamen Blattgallen von „Cynips folii\" massenhaft gesammelt (ca. 4000 Gallen), und daraus „Wespen weiblichen Geschlechts erzogen\". Die Weibchen von C.folii schreiten nach dem Auskommen aus der Galle sogleich zum Ablegen der Eier (Hartig 1843: p.398-400).\n\nDiese „Herbst/Winter\"-Wespen $ᄋ ㅇ$ bewirken durch Eiablage die Bildung von eiförmigen, violetten Samt-Gallen [„Violett velvet-galls\"] der Sexualgeneration an schlafenden Knospen an der Rinde älterer Stämme (vgl. BuHR 1965: 931, Nr. 5414; T. 14: Fig. 222-223). Im Eisacktal fand ich diese kleinen „violetten Samtgallen\" nach gezielter Suche Ende April (25.04.2007) bei Neustift und Elvas hauptsächlich an dünneren Zweigen (Ø 2-7 mm) von niederem Eichengebüsch (Q. petraea); sie sind an den Eichenstockausschlägen nur schwer zu entdecken (Abb. 89a).\n25.04.2007: Neustift-Sonnleiten ( 700 m ): Samtgallen C. quercusfolii an schlafenden Knospen: 1 Galle an Eichenstamm, sowie 37 Gallen ( $3 \\times 2.2 \\mathrm{~mm}$ ) an 4 Jungtrieben (Ø 2-7 mm); gleichzeitig auch einzelne Gallen von Neuroterus aprilinus und mehrere Blätter mit Beerengallen von $N$. quercusbaccarum. 27.04.2007: Elvas ( 800 m ), an Jungeiche (Höhe 50 cm : Foto) ca. 100 „Samtgallen\", meist an dünnen Zweigen (Ø 1-3 mm, max. 6-12 mm), etwa $30-50 \\%$ erst aus den Knospen hervorbrechend (außen mit Knospenschuppen), ganz vereinzelt schon Fluglöcher; sonst hier nur Beerengallen von N. quercusbaccarum an Blütenkätzchen \\& Blättern. 28.04.-01.05.07: Elvas, aus 5 Samtgallen erste ¿̊ g geschlüpft; 03.05.07: aus „Samtgallen\" von Cynips quercusfolii Neustift: 1 ㅇ Mesopolobus fasciiventris.\n19.05.07: bei einer Schlüpfkontrolle der C.quer-cusfolii-Samtgallen wurden div. weitere Parasitoide vorgefunden: Eurytomidae: 8 Ex, Eupelmidae: 3 Ex; [Eurytoma brunniventris; ? Sycophila iracemae; ? Eupelmus annulatus]; bei späteren Kontrolle der Knospen-Samtgallen aus Elvas, Ende VI.2007, wurden 9 tote Parasitoiden vorgefunden: 1 Encyrtus; 5 Eupelmus sp. ơ; 3 Eupelmella (Macroneura) vesicularis (Retz.) [mit Stummelflügeln] = Eupelmus\n\n--- Seite 103 ---\nvesicularis (Retzius 1783) [valid name] = albitarsis Costa $1888=$ maculipes Walker 1837.\nDie Parasitierung bei den Knospengallen der Sexualgeneration ist somit relativ hoch. Hingegen lag die Parasitierung bei den „Kirschgallen\" der agamen Generationen 2004-2006 und 2008 unter $50 \\%$. Doch hat es den Anschein, als ob sich auch bei den „Kirschgallen\" der Anteil an Fremdbesatz (Inquilinen, Parasitoide) jahreweise stark ändern könnte; solches zeichnete sich zumindest im Herbst 2007 ab, bei einer nur schwachen Schlupfrate der Gallwespen im Dezember/Jänner (siehe oben). Ähnliches berichtet über die agamen Kugelgallen an Blättern aus Bitsch i. Lothringen auch Kieffer (1914: 35).\n\nGenus Dryocosmus Giraud 1859\n[00] [Dryocosmus australis Mayr 1882]\nsee: Nr. $92=$ Plagiotrochus australis (Mayr 1882)\n[00] [Dryocosmus mayri Müllner 1901]\nsee: Nr. $81=$ Chilaspis mayri (Müllner 1901)\n90 Dryocosmus nervosus (Giraud 1859)\n= Spathegaster nervosus (Giraud 1859) 9\n= Dryocosmus cerriphilus Giraud 1859 9 (agam)\nDie Sexualgeneration erzeugt Blattgallen auf Quercus cerris: Gallen kugelig, 5-8 mm, beidseitig auf den Blättern gleichmäßig vorspringend (grün, dickwandig). Die agame Generation ( $=D$. cerriphilus Giraud) erzeugt blassgrüne bis rötliche, kugeligeiförmige, einkammerige Gallen ( 5 mm ), mit klebriger Oberfläche, die in Vielzahl dichtgedrängt aus Zweiganschwellungen von $Q$. cerris hervorbrechen (vgl. Henschel 1888: Fig. 2; Kieffer 1901: Pl. XX, Fig. 1; Dalla Torre \\& Kieffer 1910: 382, Abb. 81].\nIn Mitteleuropa (Österr., Ungarn, Rumänien) nachgewiesen (BuHR 1965: Nr. 5551 99; Nr. 5584 9 ); von Csóka (1997) für Ungarn getrennt angeführt als D. cerriphilus (p.102-103) und D. nervosus (p. 110-111) an Q. cerris. Fehlt in Spanien (NievesAldrey 2001).\nIn Italien aus Vallombrosa (Toskana) bekannt (DALLa Torre \\& Kieffer 1910: 383, D. cerriphilus); von Cobelli (1903: 165) als D. nervosus aus Trentino angeführt (ohne Fundangabe), in Checklist Ital. (1995: Nr. 23/02) nur als D. cerriphilus genannt\n(N-S-Italien). - Im Trentino sicherlich bei Rovereto zu finden; in Südtirol - wegen Bindung der Art an Zerreiche - allenfalls in Castelfeder zu erwarten. Ähnliche Blattgallen an Quercus ilex erzeugt Sexualgeneration von Plagiotrochus australis (Mayr).\n\n91 Dryocosmus kuriphilus Yasumatsu 1952\n\"Cinipide galligeno del Castagno\"\nDie aus N-China stammende „Kastaniengallwespe\" lebt an Edelkastanie (Castanea crenata, C. vesca, C. sativa und Hybriden), an deren Knospen, Trieben und Blättern sie grünliche bis rötliche, mehrkammerige Gallen (Ø 5-20 mm) erzeugt. Gallenbildung erfolgt im Frühjahr, wobei auch Triebe und einzelne Blätter in die Galle mit einbezogen werden (Abb. 91). Aus den Blasengallen schlüpfen Ende Juni/Juli agame Weibchen. Es ist nur eine agame Generation bekannt, deren Weibchen im Juli ihre Eier an die Knospen ablegen; die Eientwicklung verläuft zunächst verzögert und verborgen, erst im nächsten Frühjahr kommt es zu einer raschen weiteren Larvenentwicklung und Gallenbildung. Dieser bedeutsame Schädling der Esskastanien („Oriental Chestnut Gall-Wasp\") mit weiter Verbreitung in Asien (Japan: seit 1940) und USA (seit 1974) wurde rezent in Europa eingeschleppt und 2002 erstmals in N-Italien in Piemont, im Hügelland südlich von Cuneo, festgestellt (Bosio \\& Brussino 2005).\nEine Gefahr weiterer Ausbreitung ist besonders durch Versand von jungem Pflanzmaterial gegeben, weshalb die Pflanzenschutzämter sorgfältige Überprüfung von solchem Material (besonders aus Piemont) dringend empfehlen\n(http://www.sito.regione.campania.it/agricoltura /difesa/dryocosmus.htm:\n„Un nuovo nemico per i castagneti\"). Allerdings mit wenig Erfolg, denn der Schädling war inzwischen bereits in andere Regionen Italiens verschleppt worden, wie Lombardei, Veneto, Toskana, Latium, Kampanien, neuerdings (21.05.2008) auch am Appenin in der Emilia-Romagna.\nIn Trentino-Südtirol war eine Einschleppung schon seit Jahren erwartet worden, was sich dann 2007 bestätigte. Im Trentino war im Juni 2007 in Valsugana, bei Civezzano und Pergine, erstmals Befall festgestellt worden, an jungen chinesischen Hybridkastanien, die am Markt in Caldonazzo gekauft wurden. Bei Nachsuche fanden sich an der lokalen\n\n--- Seite 104 ---\nBefallsstelle auch verlassene vorjährige Gallen, die vom gekauften infizierten Pflanzmaterial - mit Herkunft eines Pflanzgartens aus Piemont - stammten [Salvadori, Maresi, Tessari 2007: Il cinipide galligeno del castagno. - Terra Trentina, 2007: 53 (9): 24-29]. - Zu einem ähnlichen Verlauf kam es in Südtirol, wo die Art im Frühjahr 2008 bei Terlan festgestellt wurde (vgl. „Alto-Adige\" 22.05.2008, Nr. 121, p. 9; „Dolomiten\", 22.05.2008, Nr. 117, p. 26: Terlan: Ein gefährlicher Schädling, die „Kastaniengallwespe\" in Südtirol entdeckt).\nDer Befall wurde am 19. Mai 2008 in Terlan, an der Gemeindegrenze zu Mölten von Bauern gefunden. Auf einer abgegrenzten Befallszone wiesen insgesamt rd. 20 Bäume Befallssymptome auf. Laut Angaben des Besitzers wurde der Schädling wahrscheinlich mit infiziertem Pflanzmaterial bereits vor 2 oder 3 Jahren eingeschleppt. Er hatte damals 2 Bäume auf einem Josefi-Markt im Trentino (in Caldonazzo?) gekauft. Die infizierten Jungbäume sind später eingegangen; der Schädling hat sich in einer begrenzten Zone ausgebreitet. An manchen Trieben waren leere Gallen aus dem Vorjahr festzustellen. Der Befallsherd wurde durch Gesundschneiden der Bäume (vgl. Abb. 91a) ausgemerzt (pers. Mitt. Dr. Konrad Mair, Amt für Obst- u. Weinbau /Bozen).\nEin weiterer Befallsherd im Trentino wurde am 3. Mai 2008 in Judikarien bei Storo, an der Provinzgrenze zu Brescia, entdeckt. Der Befall war wesentlich stärker und großflächiger - ca. 4 Hektar, von $400-750 \\mathrm{~m}$ Seehöhe bei Lodrone/Riccomassimo - und zudem waren erstmals alte Kastanienbäume mitbetroffen. Bei einem gemeinsamen Lokalaugenschein am 03.06.2008 (C. Salvadori, G. Maresi \\& K. Hellrigl) wurden neben den unzähligen frischen Gallen (vgl. Abb. 91b) auch viele alte Gallen gefunden, die einen Erstbefalls- bzw. Einschleppungstermin auf zumindest das Jahr 2005 rückdatieren ließen. - Der unternommene Versuch eines mechanischen „Gesundschneidens\" der Bäume scheint bei diesem Befallsausmaß wenig erfolgversprechend. In den Kontrollzuchten schlüpften die Wespen ab 30.06.08 bis Ende Juli. - Als spezifischer Gegenspieler tritt in Südkorea die Torymidae Torymus sinensis Kamijo auf, die in Japan erfolgreich zur biologischen Bekämpfung eingesetzt wurde.\n\nGenus Plagiotrochus Mayr 1881\n92 Plagiotrochus australis (Mayr 1882)\n[= Dryocosmus cabrerae Kieffer 1901] agam\nSexualgeneration verursacht an Quercus ilex und Q. coccifera im Frühjahr rundliche einkammerige Gallen ( $5-8 \\mathrm{~mm}$ ) an Blättern [vgl.: Pellizzari 1988: 129, Dryocosmus; Bernardi et al. 1997: 170, Fig. 37; 198, Fig. 48, Dryocosmus]; die agame Generation (=D. cabrerae) an Quercus ilex, verursacht an Zweigen und Ästen buckelig aufgetriebenes Rindengewebe, in dem sich kleine Larvenkammern bilden, oftmals in Anzahl gehäuft. - [Dalla Torre \\& Kieffer 1910: 602; Buhr 1965: 927, Nr. 5389 A; NieVes-Aldrey 2001:301, 533; Fig. 123 ১-к, 124 к-ь, $138 \\mathrm{o}, 139 \\mathrm{n}]$.\nMediterrane Art: in Südeuropa (Spanien) teilweise häufig. - In Checklist Ital. (1995: Nr. 23/01) als Dryocosmus australis angeführt; in Italien aus Toskana und Emilia-Romagna gemeldet Bernardi et al. (1997: 170). - Mittelitalien: Zapparoli 1997, 316 \"Insetti di Roma\", Villa Borghese u.a., 1992-94. In FVG von Tomasi (2006: 74) als Dryocosmus australis Mayr aus Triest-Muggia, 20.05.1995, von Quercus ilex angegeben.\nDie Art war in unserer Region wegen ihrer Wirtsbindung an Quercus ilex [= leccio] im Trentino zu erwarten, nicht in Süd-tirol. Im Trentino, am Lago Toblino, in den dortigen weitläufigen Quer-cus-ilex-Buschwaldbeständen im Sommer 2006 erstmals von Cristina Salvadori (Versuchsanstalt S. Michele) nachgewiesen: 2 Gallen an Blättern, zusammen mit starkem Befall der Gallmilbe Aceria (= Eriophyes) ilicis (Canestrini 1890). Beide Arten hier im VI./VII. 2008 mehrfach wiederbestätigt (leg./det. Hellrigl). Die Wespen fliegen bereits ab Anfang/Mitte Juni, die auf beiden Blattseiten halbkugelig hervortretenden glatten, grünen bis rötlichen Gallen (Abb. 92) bleiben noch eine Zeitlang gut sichtbar bevor sie vertrocknen. - In den Gallen entwickeln sich interessante Parasitoiden (z.B. Torymus flavipes, T. notatus) und spezifische Inquilinen (Synergus ilicinus Barbot. 1972, S. plagiotrochi Nieves-Aldrey \\& PujadeVillar 1987); letztere bisher nur aus Frankreich und Spanien bekannt, könnten aber auch für Italien zu erwarten sein.\n\n--- Seite 105 ---\n[00] [Plagiotrochus coriaceus (Mayr 1882)]\n[= Andricus coriaceus Mayr 1882]\n[= Andricus pseudococcus Kieffer 1902]\nBekannt aus Andorra, Spanien, Frankreich, Italien (terra typica). - Die der vorigen nahe stehende Art ist ebenfalls an Quercus ilex und Q. coccifera gebunden; verursacht kleine, deutliche pustelförmige Gallen an den Blättern [Nieves-Aldrey 2001: 316, 534, Gallae Figs. 124A, 140A]. - In Checkl. Ital. (1995: Nr. 13/11) als Andricus coriaceus Mayr 1882 aus Sizilien gemeldet; rezent auch für N-Italien aus FVG von Tomasi (2006: 69) als Andricus pseudococcus Kieffer 1897 aus Triest, Duino-Aurisina, 25.05.2000 von Quercus ilex angegeben. - Könnte vielleicht auch im Trentino zu erwarten sein.\n[93] [Plagiotrochus quercusilicis (Fabricius 1798)]\n$[=$ kiefferi Marchal 1897; = kiefferianus Tavares 1901]\n$[=$ A. ilicis Lichtst. 1877; = cocciferae Lichtst. 1877;\n$=$ P. emereyi Mayr 1882, = P. fusifex Mayr 1882]; Sexualgeneration verursacht an Quercus ilex und Q. coccifera an Blättern große, auffällig rote, flachovoidale vielkammerige Gallen, die auf beiden Blattseiten hervortreten und einen Großteil des Blattes einnehmen [Kieffer 1901: 603; Pl.XXI, Fig. 2-3; Bernardi et al. 1997: 166, Fig. 35; 192, Fig. 45]. - Die agame Generation (= kiefferianus) bildet Zweiganschwellungen mit zylindrisch-wulstigen, vielkammerigen Gallen ( $30 \\times 15 \\mathrm{~mm}$ ). - [Dalla Torre \\& Kieffer 1910: 389, Fig. 90; Nieves-Aldrey 2001:312, 533; Figs. 123 H-I, 124 B-D, 138 E, 139 E]. Die Gallenbildungen (Zweiganschwellungen) sind ähnlich denen von Pseudoneuroterus macropterus an Zerreichen (vgl. Nr. 104).\nMediterrane Art, mit Hauptverbreitung im SW: Portugal, Spanien, S-Frankreich und Italien. In Checklist Ital. (1995: Nr. 30/01 und 30/02) doppelt angeführt (als P. kiefferianus und P. quercusilicis). In Italien aus den südlichen und mittleren Regionen bekannt, u.a. Marken (Senigallia) und Toskana (Bernardi et al. 1997: 166). Wegen Bindung an die Wirtspflanze Quercus ilex allenfalls im Trentino zu erwarten (z.B. Valle dei Laghi), aber nicht in Südtirol.\n\nGenus Neuroterus Hartig 1840\n[94] [Neuroterus aggregatus (Wachtl 1880)]\n= Spathegaster aggregata Wachtl 1880\nVerursacht gehäuft auftretende, kleine eiförmige Gallen an stärkeren Zweigen oder älteren Stämmen von Quercus cerris. Gallen ( 2 mm ) grünlich, auch $\\pm$ gerötet, dünnwandig; Gallenreife dieser bisexuellen Generation Mitte Mai, agame Generation nicht bekannt [Buhr 1965: 972, Nr. 5555 ơ]. - Aus Österreich beschrieben [Wachtl: cit. Kieffer 1901: 673; Pl. XV, Fig. 11], auch aus Ungarn nachgewiesen [Méhes 1943, Ambrus 1957, 1959; Melika, Csóka \\& Pujade-Villar 2000: Check-list oak gall wasps of Hungary: 284-285, Figs. 77a-c] sowie aus N-Italien gemeldet [Checkl. 1995: Nr. 27/01]. - Aus Triest zu erwarten und auch aus Trentino.\n\n95 Neuroterus albipes (Schenck 1863) $90^{\\circ}$\n[ $99=$ laeviusculus Schenck 1863 (Mayr)]\nDie agame Generation verursacht an Eichen auf der Blattunterseite glatte, unbehaarte, flach schüsselförmige Gallen mit aufgebogenem Rand („Smoothspangle gall\"); die 4 mm großen, gelblich-grünen oder rosa bis purpurroten Schüsselchen oder „Krempengallen\" (Rand beim Vertrocknen unregelmäßig hochgebogen) sind fein radial gestreift, anfangs oberseits mit vereinzelten Sternhaaren, später kahl; sie fallen im Herbst ab [vgl. Buhr: 1965: Nr. 5496; Taf. 17, Fig. 264-266, N. laeviusculus, Krempengalle; Redfern et al. 2002: 412, Fig. 714; H.-J. Buhr (Pflanzengallen: Newsletter 2006): N. laeviusculus, Krempengalle]. - Sexualgeneration im Frühjahr mit winzigen ovalen ( $1-2 \\mathrm{~mm}$ ), gelblichen, abstehend behaarten Gallen ( $=$ „Schenck's gall causer\") an Blatträndern, am Ende eines Seitennervs des Blattes aufsitzend und Einbuchtungen verursachend. - [Pfützenreiter 1958: 114-116, Nr. 42-43, (laeviusculus) Abb. 32 (agam), 33 (sex.); Kieffer 1901: 647; Pl. XIX, Fig. 6; Buhr: 1965: Nr. 5474, Nr. 5571; Chinery 1987: 227; Nieves-Aldrey 2001: 446, 544; Figs. 131 N-Q, 146 B-C].\nIn Europa weite Verbreitung; agame Linsengallen lokal oft in Massen. - Aus Nord-Italien gemeldet [Massalongo] (Checklist Ital., 1995: Nr. 27/02); neben f. typ. auch N. albipes reflexus Kieffer 1901. Von Dalla Torre (1894: 14) aus N-Tirol angeführt als Gallen von Neuroterus laeviusculus Mayr,\n\n--- Seite 106 ---\nan Quercus pedunculata: Volderwald bei Hall, 12. Sept. 1893 (vom selben Fundort \\& Datum auch Gallen von Neuroterus lenticularis Mayr). - Diese agame Form wurde in Südtirol erstmals am 24.09.2006 in Auer-Castelfeder an Flaumeichen nachgewiesen, wenige Gallen (leg./det. Hellrigl) (Abb. 95b, gelbe); ebenso im Trentino bei Rovereto am 15.09.2005 an Q. petraea [„flache Schüsselgalle\"] (Abb. 95b). Hingegen wurde die als var. reflexus Kieffer bekannte Form, mit dreiecksförmig aufgebogenen Rändern (vgl. Pfützenreiter 1958: 114, Abb. 32; Bellmann 1999: 256, Abb. 5), hier nie beobachtet. - Die Blattrandgallen der bisexuellen Frühjahrsgeneration [= Nominatform N. albipes] fand ich am 02.06.2008 mehrfach an Blättern von Zerreichen in Pomarolo-Servis ( 700 m ); aus 2 Dutzend gesammelten Gallen (Abb. 95a) einige Imagines bereits geschlüpft, weitere Wespen und Parasitoide schlüpften daraus anfangs Juni. In Pomarolo am 12.10.2008 auch agame Linsengallen an Blättern, teilweise parasitiert von Torymus flavipes; weitere bisexuelle Blattrandgallen an Zerreiche. Einige Blattrandgallen auch in Castelfeder an Flaumeichen, am 22.06.08 (leg. Hellrigl). Hier am 19.10.08 auch vereinzelte agame Linsengallen; desgleichen am 20.10.08 in Atzwang, dort parasitiert von Ormyrus sp..\n\n96 Neuroterus anthracinus (Curtis 1838)\n[= Cynips ostria Hartig 1840] - Austerngalle\n[= Neuroterus ostreus Giraud 1859]\n( $\\delta^{\\text {® }}=$ Neuroterus furunculus Beyerinck 1882);\nDie agame Generation bildet blattunterseits an Blattnerven von Quercus kleine kugelige gelbgrüne Gallen (Ø 1-3 mm) mit rötlichen Punkten, die in zwei kleinen schalenförmigen Scheiden stecken, wie die Perle in einer Austernschale („Oyster-gall causer\"). [Pfützenreiter 1958: Nr. 8 ( $9{ }^{\\text {® }}$ Furunkelgalle); Nr. 33, Abb. 26 ( $9{ }^{\\circledR}$ Austerngalle); BuHR 1965: Nr. 5479, T. 16, Fig. 246; Pellizzari 1988: 109 (Andricus ostrea Htg.); CsÖKA 1997: 104 (Andricus anthracina); Nieves-Áldrey 2001: 427; Fig. 132c, 145 n; Redfern et al. 2002: 413, Fig. 718 (Neuroterus anthracinus)]. - In Checklist Ital. (1995: Nr. 13/40) für N-Italien angeführt (Andricus ostrea Htg.). In FVG: vom Triestiner Karst durch GrÄFfE (1905: 41) und Tomasi (1996: p.34, Nr. 40) als Andricus ostreus (Giraud) gemeldet.\n\nAus Tirol schon lange bekannt: Dalla Torre (1894: 14) Gallen von Andricus ostreus Gir. an Quercus pedunculata, Bozen (G. Mayr). - D.T. (1896): N-Tirol, an Q. pedunculata, Stams, Sept. 1894.\nDie kleinen Gallen sind nach eigenen Beobachtungen in Südtirol an Eichen allgemein verbreitet und im Sommer recht häufig an den Hauptnerven auf der Blattunterseite zu finden (Abb. 96); die Gallen fallen bald ab, so dass im Spätsommer/Herbst meist nur mehr ihre basalen Halterungsklappen (hellbraun, rechteckig) aus der Mittelrippe herausragten (vgl. Abb. 96b).\nVinschgau: bei Goldrain ( 900 m ), am 19.10.2004 an einer Traubeneiche 10 Blätter mit insgesamt 15 Einzelgallen (leg. Hellrigl); die kleinen Gallen (jeweils 1-3 pro Blatt) größtenteils schon abgefallen. Eisacktal: Tschötscher Heide ( 750 m ), an Q.pubescens, am 20.10.2004, 15 Blätter mit insgesamt 26 Gallen (1-4 pro Blatt), meist nur mehr die basalen Halterungsklappen am Mittel nerv vorhanden; Neustift-Raas ( 750 m ), 17.10.2004, an Q. petraea 20 Blätter, mit insgesamt 34 Gallen (1-5 pro Blatt), nur noch 5 Gallen anhaftend, sonst nur mehr basale Scheiden vorhanden (leg./Foto Hellrigl).\nAuch in den Folgejahren 2005-2008 erwiesen sich die Austerngallen als die wohl häufigsten und weit verbreitetsten Gallwespen-Gallen an Eichen (Quercus petraea, Quercus pubescens) in Südtirol. Reife Gallen fanden sich besonders im Juli (07.07.2005 in Pinzon und Castelfeder), vereinzelt auch noch im August (10.-20.08.2005 in Castelfeder, KranebittKrakofl, Neustift) und Anf. Sept. (03.09.2005 Elvas, div. Gallen, leg. Hellrigl). - Ab September nur mehr vereinzelt noch anhaftende Gallen an Eichenblättern zu finden: Tschötsch ( 750 m ), 14.09.2005; hier auch 30.09.2006: 1 große Galle; Neustift ( 700 m ), 21.-30.09.2005 (leg. Hellrigl); Aicha-Spinges ( 830 m ), 06.09.2006, N. anthracinus (abfallend); viele Gallen frisch abgefallen. - Unterland: Castelfeder: 24.09.2006, sehr viele Austerngallen, meist schon abgefallen ( 1 Zweig mit 31 abgefallenen Gallen plus 2 vollen und 2 parasitierten Gallen); ebendort: 16.09.2007, zahlreiche Klappen, aber Gallen schon abgefallen, desgleichen 19.10.2008 (leg. Hellrigl). Halteklappen der Austerngallen an den Hauptblattadern sind sogar noch im Winter/ Frühjahr an abgefallenen braunen Blättern zu finden.\n\n--- Seite 107 ---\nGallen waren in allen Untersuchungsjahren (2004-2008) in Südtirol überall an Eichen festzustellen. Etwas weniger häufig sind „Austerngallen\" im Trentino, wo sie bisher nicht gemeldet waren. Rezent mehrfach bei Rovereto, „bosco della città\" (350m), 25.09.2005 (div.), 04.08.2006 (div.), 03.10.2007 div. Klappen an Blättern von Flaumeichen (leg. Hellrigl). Auch in Pomarolo-Servis (IT-04: 700 m), am 14.10.2007, vereinzelt Klappen an Eichenblättern (leg. Hellrigl \\& Mörl). Hier auch im Sommer 2008 am 19.07.2008 einige Eichenblätter mit noch leeren Klappen von Austerngallen auf der Blattunterseite (leg. Hellrigl \\& Schanung). - Im Eisacktal, bei Aicha-Spinges ( 850 m ), erste frische Jahres-Gallen am 25.07.2008 an vielen Blättern von junger Traubeneiche; pro Blatthauptader fanden sich durchschnittlich 6 Halterungsklappen, davon einige noch leer und andere mit frischen, aber noch unreifen Gallen (leg./Foto Hellrigl). Frische Halteklappen an grünen Blättern (noch ohne Gallen!) fanden sich Mitte Juli 2008 zahlreich an Traubeneichen in Albeins und Neustift (K. Schanung \\& Hellrigl). Bei Atzwang zahlreiche Gallenspuren (Klappen und Gallen) noch am 20.10.2008 an Q. petraea; es waren dies hier die häufigsten Gallwespengallen an Eichen. Auch in Osttirol erwiesen sich Ende Okt. 2008 bei Lienz (Schloß Bruck, Lavant, Nikolsdorf) „Austerngallen\", deren Klappen sich überall zahlreich an Blättern von Stieleichen (Q. robur) fanden, als häufigste Gallwespengallen (leg. Kofler \\& Hellrigl).\n\n97 Neuroterus aprilinus (Giraud 1859)\n\n- „Aprilgalle\"\n[= Spathegaster aprilinus Giraud 1859 ㅇ 2 ]\n[= Spathegaster petioliventris Hartig 1840: 194 ㅇ 2 ]\n$=$ Neuroterus petioliventris (Hartig 1840) (sex.)\n$=$ Neuroterus politus Hartig 1840: 193 (agam)\n$=$ Neuroterus bipunctatus Hartig 1841: 339 (agam)\n$=$ Neuroterus rubeculus Hartig 1841: 339 (agam)\n$=$ Neuroterus nitens Hartig 1841: 339 (agam)\n$=$ Neuroterus schlechtendali Mayr 1870 ㅇ ㅇ\nBildet in der bisexuellen Generation an Knospen von Quercus spp. blasige Knospengallen (Abb. 97), die zeitig im Frühjahr (Anfang April) erscheinen und bald wieder verschwinden (Mitte Mai). Diese als „Aprilgalle\" [= Neur. aprilinus, N. petioliventris] bezeichnete Galle entsteht durch Umwandlung\nder inneren Knospenschuppen junger Eichentriebe und erreicht $8-10 \\mathrm{~mm}$ Größe; die Wespen (ㅇ ㅇ ) schlüpfen Ende April/Anf. Mai. - In der agamen Generation werden wenig später an Blütenkätzchen kleine wulstige Gallen ( $1-1.5 \\mathrm{~mm}$ ) aus Staubblättern in Staubbeuteln gebildet. - [Kieffer 1901: 662-665; Pl.XIV, Fig. 6; Pfützenreiter 1958: Nr. 25, Abb. 19 (ㅇ Aprilgalle); Nr. 50, Abb. 48 (ㅇ Blütengalle); Buhr 1965: Nr. 5426 ( $\\triangle$ N. aprilinus, N. petioliventris), Nr. 5530 ( $ᄋ$ Kätzchengallen), T. 17, Fig. 282; Csóka 1997: 84-85 (N.petioliventris); Nieves Aldrey 2001: 433, 542 (N. aprilinus); RedFERN et al. 2002: 407, Fig. 687 ( $\\&$ N. aprilinus); 417, Fig. 735 (ㅇ). - Die „Aprilgallen\" waren schon von Malpighi (1687: Fig. 30-31) und RéaUMUR (1737: Pl. 43, Fig. 1-3) abgebildet worden. Die agame Generation wurde später von Hartig (1840: 193; 1841: 339) unter vier verschiedenen Synonymen beschrieben, deren zugehörige Imagines Hartig jeweils Mitte/Ende Aug. bei Braunschweig in Eichenbeständen gefangen hatte. Hingegen wurde die bisexuelle Generation [Spathegaster petioliventris Hartig 1840: 194 ㅇ] von ihm in der letzten Hälfte Mai in Eichenbeständen bei Berlin in großer Menge gefangen. Die Art scheint öfters unter diesem ansich prioritätsberechtigen aber weniger aussagefähigen Namen auf. Neuerdings wird sie auch als N.politus Hartig 1840 geführte (Melika et al., 2000: 288, Fig. 86); dieses weitere Synonym ist - gegenüber der bisexuellen „Aprilgeneration\" - insofern verwirrend, als es zur agamen Sommergeneration gehört, die erst „Mitte August in Eichenbeständen gefangen\" wurde (Hartig 1940: 193).\nWeite Verbreitung in Europa. - Checklist Ital. (1995: 27/03) für N-Italien angegeben (N. aprilinus).\nIn FVG vom Triestiner Karst Gallenbeschreibung und Meldungen durch GrÄFFE (1905: 45-46, N. schlechtendali Mayr - aprilinus Schlecht.) im April an Quercus pubescens seltener an sessiliflora. Fundangaben von GrÄFFE 1905: cit. Tomasi (1996: 71, Nr. 107; Neuroterus petioliventris Htg.).\nDiese Art war aus Trentino-Südtirol bisher nicht gemeldet. In Südtirol erstmals ober dem Schießstand Neustift ( 700 m ) am 03.05.2006 an frisch ausgetriebenem jüngeren Eichengebüsch (Quercus petraea) 24 Knospengallen (Abb. 97), die meisten davon bereits mit Flugloch der Gallwespe (eine Galle noch geschlossen, mit Parsiten-Larve). Zahlreiche\n\n--- Seite 108 ---\nweitere, an den Zweigen belassene Knospengallen waren 2 Wochen später (17.05.2006) völlig verschwunden und der Befall nicht mehr erkennbar. - Auch in Montiggl, Monitoring-Areal ( 600 m ), waren Knospengallen (mit Ausflugloch) dieser Art bereits am 20.04.2006 an Q. petraea in Anzahl gefunden und fotografiert worden (Foto S. Minerbi, det. Hellrigl). Auch im Frühjahr 2007 fanden sich bei Neustift am 25.04.2007 wiederum Gallen von N. aprilinus; gleichzeitig zeigten sich an Eichenblättern auch Beerengallen (sexual) von N. quercusbaccarum und an Eichentrieben Knospengallen (sexual) von C. quercusfolii (= Samtgallen).\nIm Trentino wurden Knospengallen von N. aprilinus nach gezielter Suche erstmals am 25.04.2008 bei Pomarolo-Servis gefunden. Die Vegetation war nach anhaltend kaltem verregnetem April weit zurück, so dass die Blattknospen der Eichen erst am Austreiben waren und die Blütenknospen noch gar nicht. Es fanden sich nur vereinzelt befallene Knospengallen; aus gesammelten Zweigen mit treibenden Knospen schlüpften bis zum 5. Mai 16 Imagines von N. aprilinus ( $50 \\%$ ㅇ) sowie 8 Synergus apicalis (leg./ det. Hellrigl). - Bei einer Kontrolle am 03.05.2008 in Neustift-Brixen fanden sich an austreibendem Eichengebüsch (Q. petraea) 24 Knospengallen der Gallwespe bereits mit Flugloch (Abb. 97a); aus eingetragenen Zweigen schlüpften in zwei Tagen 8 Imagines (5 ơ, 3 ㅇ: Fotos). Die „Aprilgallen\" von N. aprilinus sind in Südtirol-Trentino Ende April/ Anf. Mai offenbar verbreitet und häufig; nach den kleinen agamen Blütengallen im Mai/Juni war hier bisher nicht gesucht worden.\n[00] Neuroterus glandiformis (Giraud 1859) see: 102 Neuroterus saliens (Kollar 1857)\n[98] [Neuroterus lanuginosus Giraud 1859]\nVerursacht an Zerreiche (Q. cerris) auf der Blattunterseite dick scheibenförmige, rundliche Linsengallen (Ø 4 bis 6 mm ) deren Oberfläche mit langen seidigen Haaren von weißlicher bis rosa Färbung dicht bedeckt ist. Die einzeln oder meist auch zu mehreren auftretenden „Haargallen\" dieser agamen Generation erscheinen im Aug./Sept. und fallen im Okt. ab. - Sexualgeneration nicht bekannt.\n[Kieffer 1901: 666; Pl. XVII, Fig. 5; Buhr 1965: 980, Nr. 5580; T. 17, Fig. 291-292; Pellizzari 1988:\n\n124, Fig.; Bernardi et al. 1997: 152, Fig. 28]. Von Nieder-Österreich durch SE-Europa bis Kleinasien verbreitet. - Fehlt in Spanien. - Checkl. Ital. (1995: Nr. 27/05): Sizilien; dort fand sie De Stefani (1897: 168) an Korkeiche (Q. suber). Bernardi et al. (1997: 152): auch in der Toskana. - Die Art sollte auch in N-Italien vorkommen und ist im südlichen Trentino an Zerreichen zu erwarten (vgl. Abb. 98). FVG: aus Triest-Dolina, an Quercus cerris, 07.09.1994 von Tomasi (2006: 74) gemeldet. In Istrien auch Bellmann leg./Foto: 30.08.2008.\nDie Galle ist nicht zu verwechseln mit den ebenfalls an Zerreiche vorkommenden und teilweise auch pelzig behaarten Gallen von drei Gallmücken (Cecidomyiidae): Dryomyia circinnans (Gir.), die schon in Rovereto gefunden wurde (vgl. Hellrigl 2004), sowie Janeta cerris (Kollar) und Janeta homocera (F. Löw), die bei Pomarolo-Servis recht zahlreich vorkommen (leg./det. Hellrigl 2007/08).\n\n## 99 Neuroterus minutulus Giraud 1859\n\nDie agame Generation bildet an den Blättern von Zerreiche (Q. cerris) blattober- bzw. blattunterseits [„blattunterseits\": seltener nach BuHR 1965 - hingegen üblicherweise nach Melika et al. 2000: 286], an schwächeren Nerven vorkommend, kleine ( $\\pm 1.5 \\mathrm{~mm}$ ) kugelige Gallen, mit kurzen abgerundeten, bei der Reife roten Höckern dicht besetzt; Galle ab IX, reift im X-XI [Buhr 1965: p. 978, Nr. 5576; Kieffer 1901: 672; Pl. XVII, Fig. 3; MeLIKA et al. 2000: Fig. 83]. - Verbreitung: Österreich, Ungarn, Bulgarien, Rumänien, Griechenland, Italien und Israel; fehlt mit der Zerreiche in Spanien; auch keine Meldungen aus Britannien, Frankreich und Deutschland (Kieffer 1914; Fauna Europaea 2007).\n\nNach Checkl. Ital. (1995: Nr. 27/07) in N-Italien (Trotter). - War im südlichen Trentino bei Rovereto und im Gardaseegebiet zu erwarten. Hier gelang ein Erstnachweis bei Pomarolo-Servis (IT-04: 700 m ) am 12.10.2008, an unteren Ästen größerer Zerreichen: einige Blätter mit einzelnen bis mehreren Gallen (Ø 1-2 mm) blattunterseits, leg./det. Hellrigl \\& K. Schanung (Abb. 99). - An den Zerreichen fanden sich weiters: Aphelonyx cerricola, Andricus aestivalis, A. cydoniae, Synophrus politus, Neuroterus saliens sowie zahlreich die 2 Gallmückenarten: Janeta homocera (F. Löw) und Janeta cerris\n\n--- Seite 109 ---\n(Kollar); hingegen konnte Neuroterus lanuginosus, dem die eigentliche Suche gegolten hatte, nicht gefunden werden. Die winzigen Gallen werden wohl auch oft übersehen; bei flüchtiger Betrachtung mit bloßem Auge eventuell zu verwechseln mit Gallen von Janeta cerris, die auf der Blattunterseite aber einen kleinen hellen Haarpolster ausbilden und auf der Blattoberseite halbkugelige gelbe, glatte Pusteln, während bei $N$. minutulus auf der anderen Blattseite nichts zu erkennen ist (Abb. 99). - Es war dies der hundertste Gallwespen-Artnachweis für die Region Trentino-Südtirol. - Von Tomasi (2006: 74) wird die Art auch aus Triest/Dolina gemeldet, doch fälschlich von Quercus petraea angegeben.\n\n100 Neuroterus numismalis (Geoffroy in Fourcroy 1785) $Q$ - Seidenknopfgalle, N. numismatis Olivier 1790;\n$[=$ N. reaumurii Hartig 1840, N. defectus Hartig 1840];\n[ $Q$ = Cynips vesicatrix Schlechtendal 1870]\nVerursacht an sommergrünen Eichen (Q. pubescens, Q. petraea, Q. robur) kleine Blattgallen: in der agamen Generation blattunterseits hellbraune „Napfgallen\" oder „Seidenknopfgallen\" (Ø bis 4 mm ) mit wulstigem Rand ( $=$,,Silk-button gall\"), in der bisexuellen Generation hellgrüne, blasenartig gewölbte Pustelgallen (= „Blister-gall causer\"). - In Europa im gesamten Verbreitungsgebiet der Eichen.\n[Riedel 1910: Nr. 37 N. numismalis Oliv. $Q$ ㅇ, Nr. 45 N. vesicator Schl. $Q$ 今; Pfützenreiter 1958: Nr. 40, Abb. 34 ( $Q$ 今 Grüne Pustelgalle), Nr. 41, Abb. 35 ( $Q$ Q Seidenknopfgalle); Zahradnik 1985: 85; ChInERY 1987: 227; Pellizzari 1988: 115; Amann 1990: 87; Bellmann 1999: 257; Csóka 1997: 112; Meliкa et al. 2000: 286, Fig. 84; Nieves-Aldrey 2001: 444, 544; Redfern et al. 2002: 412, Fig. 713; Kieffer 1901: 656; Pl. XIX, Fig. 8]. Die Gallen dieser Art werden schon von Malpighi (1687), Redi (1668) und Réaumur (1737) abgebildet. - Checkl. Ital., (1995: Nr. 27/08): aus Sizilien und Nord-Italien bekannt: Toskana, Piemont, Friaul-V.Giulia, Veneto, EmiliaRomagna (Bernardi et al. 1997: 202, Fig. 49). In FVG aus Triest Umg. nach GrÄFFE (1905: 47-48, Cecidothek FVG): bei Triest nicht häufig zu finden; hier auch von Tomasi (1996: 70, Nr. 106; 2006: 74) gemeldet.\n\nAus Südtirol schon lange bekannt, im Trentino rezent beobachtet. Die „Grünen Pustelgallen\" ( $Q$ 今) sind schwer zu entdecken und leicht zu übersehen, während die oft gehäuften „Seidenknopfgallen\" im August gut sichtbar sind, aber ab Mitte September leicht abfallen. - Dalla Torre (1894) meldet „Napfgallen\" von Neuroterus numismalis Ol. an Quercus pedunculata aus Bozen (G. Mayr), sowie „Blasengallen\" von Neuroterus vesicator Schlecht. an Quercus pedunculata, Bozen (G. Mayr).\nHellrigl (1996): Napfgallen von N. numismalis (Geoffr.) an Q. pubescens und Q. petraea: Brixen Umg.: Elvas, Raas, Tschötscher Heide, Aicha; Kaltern, Montiggl. - Ritten: Oberbozen, Klobenstein 1150-1250 m, an Querc. petraea, 03.08.1999 (leg. Hellrigl) (Abb. 100). - N. numismalis: Tschögglberg, Vöran, 07.09.1998, an Quercus (leg. Franke: pers. Mitt.); Mölten, 1050 m , an Q. pubescens, 04.08.2004 (leg. M. Skuhravá). - „Münzengallen\" in Südtirol früher regelmäßig zu finden, in den letzten Jahren seltener (keine Funde 2005, vereinzelt 2006). Neustift-Schießstand, 05.08.2006: 1 Blatt mit 1 Galle (leg. H. Bellmann). Unterland: Castelfeder, 24.09.2006, 1 Blatt mit 1 Galle (leg. Hellrigl); dann aber im Folgejahr, am 16.09.2007, in Castelfeder an Flaumeichen mehrere von N. numismalis befallene Blätter, mit $\\pm$ zahlreichen, leicht abfallenden Napfgallen (Abb. 100). - Im Frühjahr 2008 erste Junggallen an einigen Blättern in Castelfeder am 22.06.08 (Fotos); am 17.08.08 waren die „Münzengallen\" dann sehr zahlreich. - Mehrere Blätter mit frischen „Seidenknopfgallen\" fanden sich am 04.08.2008 in Brixen (Eisackufer) an kürzlich angepflanzten, Stieleichen (Q. robur) aus Bassano (leg./ foto Hellrigl).\nTrentino: Erstmeldung aus Pomarolo-Servis (IT-04: 700 m ), 14.10.2007, 1 Blatt mit Seidenknopf-Gallen (leg. Hellrigl \\& Mörl); hier dann am 27.07.08 einige Flaumeichen-Blätter mit jungen „Seidenknopfgallen\" und am 07.09.2008 zahlreiche Blätter mit Gallen (leg. Hellrigl \\& Mörl).\n[00] Neuroterus petioliventris (Hartig 1840) see: 97 N.aprilinus (Giraud 1859); = N. politus Hartig 1840;\n\n--- Seite 110 ---\n101 Neuroterus quercusbaccarum (L. 1758) 90\n$=$ C. baccarumquercus Geoffroy in Fourcroy 1785\n$=$ Cynips quercus-pedunculi Linnaeus 1758: n. 7\n$=$ C.pedunculiquercus Geoffroy in Fourcroy 1785\n$=$ Cynips interruptrix Hartig 1840 - Blattgallen:\n\n- vgl. Reaumur 1737, 3, Tab. 37, Fig. 10, 11 [90]:\n„galles en groseilles\" - Johannisbeergallen\n= Spathegaster interruptor Hartig 1841: 341 (1843)\n= Spathegaster baccarum (L.) Hartig 1841: 341\n= D. lenticularis Olivier 1791: agam - \"Linsengalle\"\n- Syn.: Diplolepis flavipes Olivier 1791\n$=$ Neuroterus malpighii Hartig 1840: 192, agam\nDie agame Generation bildet im Sommer/Herbst unterseits an Eichenblättern linsenförmige, gelbliche bis rötliche Gallen, mit braunen Sternhaaren, sog. „Eichenlinsengallen\" („Common spangle gall\"). - Gallen der Sexualgeneration im Mai kugelig beerenartig, gelbgrünlich, fleischig-saftig durchscheinend, an Blütenkätzchen der Eiche, sog. „Johannisbeergallen\" („Currant gall\"; ,,galles en groseilles\"); diese namensgebenden „Beerengallen\" (= ,,baccarum \") nur kurze Zeit im Frühjahr - häufig auch an Unterseite der Blätter (oberster Teil der grünen Kugelgalle durchwächst dabei das Blatt). Deutsche Benennung „Eichen-Linsengallwespe\" nach der häufigen agamen Linsengalle ( $=$,, lenticularis\"). - [Kieffer 1901: 649, baccarum L. (sex.), 652, lenticularis Ol. (agam); Riedel 1910: Nr. 46 N. baccarum L., 90, Nr. 39 N. lenticularis Oliv., 99; Pfützenreiter 1958: 117, Nr. 44, 45, Abb.36, 42; Buhr 1965: Nr. 5481, 5499, 5521, 5582, T. 16; Zahradnik 1985: 85; Chinery 1987: 227; Amann 1990: 87; Csóka 1997: 112-113; MeLika et al. 2000: 288, Fig. 87; Nieves Aldrey 2001: 441, 543; Figs. 126A-B, 131 F-J; Redfern et al. 2002: 411 Fig. 711, 412 Fig. 715, 416 Fig. 734].\nDie beiden Generationsformen („Beerengallen\" und „Linsengallen\") und deren artliche Zusammengehörigkeit wurden lange nicht erkannt bzw. verwechselt, was zu zahlreichen Synonymen führte. Eine Synonymie stammt von Linné selbst, der die Gallen der Sexualgeneration im Frühjahr zuerst als „Beerengalle an Blättern\" beschrieb „Cynips quercus-baccarum Linn. 1758: 553, Nr. 4\" und eine Seite später nochmals als „Beerengallen an männl. Blütenständen\": „Cynips quercus-pedunculi Linnaeus 1758: 554, Nr. 7\"; allerdings scheint die dort\nbeschriebene Wespe (? Inquiline) nicht identisch mit der ersteren.\nChecklist Ital. [1995: Nr. 27/09]: N und Sizilien. In FVG vom Triestiner Karst zahlreiche Meldungen von Linsengallen durch GrÄFFE (1905: 46, Taf.I, n. 4-5) und Tomasi (1996: 71, n. 108; 2006: 75). Nach Bezzi (1899), als Neuroterus baccarum L. und N. lenticularis Oliv., an Quercus auch im Trentino (Mollaro); idem Cobelli (1903: 165). - Dalla Torre (1892: 147): als „Blütengalle\" von Neuroterus baccarum L. an Q. pedunculata um Innsbruck zieml. häufig; DT. (1894, 1896): als „Blattgallen\" von N. lenticularis Htg./Mayr aus N-Tirol (bei Hall u. Stams) von Q. pedunculata gemeldet.\n„Linsengallen\" (agam) (Abb. 101b): Hellrigl (1996; 1997: p. 65, Abb. 6, Fig. 3-4) Elvas/Brixen, an Quercus, 22.09.1989; Forstgarten Aicha, X. 1990 (Foto Hellrigl); Ritten: Oberbozen, 1220 m, an Q. petraea, 03.08.1999; Neustift, 600-700 m, 23.09.1999 und 17.10.2004 an Q.pubescens und Q. petraea. Vinschgau: Vetzan, $750 \\mathrm{~m}, 30.09 .2004$, an Q. petraea. - Im Sommer 2005 „Linsengallen\" ab Anf. Juli (noch klein) bis Mitte Aug. (halbwüchsig): Pinzon-Montan, $450 \\mathrm{~m}, 10.07 .05$; Castelfeder, 10.08.05, an Q. pubescens; Brixen-Krakofl, 650 m , 08.08.05, zahlreich an Blättern von Q. petraea (Volker Lutz \\& K. Hellrigl); Tschötsch, 16.08.05, div. (leg. Hellrigl). - Größere Gallen ab Sept.: Gufidaun, $730 \\mathrm{~m}, 05.09 .2005$ und Feldthurns/Drumbichl, $800 \\mathrm{~m}, 11.09 .05$. Häufig an Blattunterseite der Blätter, besonders an niederem, halbschattigem Eichengebüsch, bei Neustift-Schießstand, 700 m , 03.-24.09.2005, sowie Elvas, $800 \\mathrm{~m}, 21.09 .2005$ (Foto) und Tschötsch, $750 \\mathrm{~m}, 15 .-30.09 .05$. Auch im Trentino: Rovereto-Dossi, 350 m , am 01.-25.09.2005 und ebenso am 04.08.2006 an Eichen (leg. Hellrigl).\nIm Herbst 2006: zahlreiche Linsengallen auf der Tschötscher Heide ( 750 m ), 03.-30.09.06 (Fotos); in Castelfeder, 24.09.06, einige Blätter von Flaumeiche mit Gallen; Elvas/Brixen, 25.09.06, zahlreich an Q. petraea; hier waren am 10.10.06 fast alle „Linsengallen\" schon abgefallen. - Im Jahr 2007: Brixen Umg., Tschötsch, Neustift, Elvas, AichaSpinges, ab August überall anzutreffen. Unterland: Castelfeder, 16.09.2007 an Flaumeichen, einige Blätter mit Gallen. - Trentino: Rovereto-Dossi, 03.10.2007 div. Blätter mit zahlreichen Linsengallen\n\n--- Seite 111 ---\nvon N. quercusbaccarum (= lenticularis); Pomaro-lo-Servis: 14.-28.10.2007, jeweils 10 Blätter mit Linsengallen. Nach Überwinterung der „Linsengallen\" im Freien, schlüpften daraus agame Weibchen Anf. Apr. 2008. Nach Olivier (1791: 281) beginnen die „D. lenticularis\" an den ersten schönen Frühlingstagen zu schlüpfen. - Im Frühjahr 2008 fanden sich Junggallen (rosa Haarbüschel) an Blättern in Castelfeder am 22.06.08; zu einem massenhaften Abfallen reifer, schon gequollener „Linsengallen\" kam es hier dann am 19.10.2008; besonders auf felsigem Untergrund fielen die zahlreichen Gallen am Boden auf.\n„Beerengallen\" (sexuelle Gen.) wurden hier ab Frühjahr 2005 gezielt gesucht (Abb. 101a) und erwiesen sich als überaus häufig an Blütenkätzchen und Blättern von Q.petraea bei Neustift/Schießstand ( 700 m ) 20.-22.05.2005, ca. 300 „Beerengallen\" ( $\\varnothing$ meist $6-8 \\mathrm{~mm}$; max $9-10 \\mathrm{~mm}$ ) gesammelt ( $60 \\%$ an Blütenkätzchen, $40 \\%$ an Blättern), leg./ Fotos Hellrigl. Befallen waren vor allem randständige, besonnte, mehr strauchartige Traubeneichen. Weniger häufig auf der Tschötscher-Heide ( 750 m ) an Q.petraea: am 24.05.2005 wurden 50 Beerengallen gesammelt ( $70 \\%$ an Blütenkätzchen, $30 \\%$ an Blättern). - Viele Beerengallen an Kätzchen waren am 20.-24. Mai bereits abgefallen, aber wenige bereits mit Fluglöchern der Gallwespen, die ab 22.-25. Mai in den Aufzuchten in Anzahl aus Beerengallen zu schlüpfen begannen (sex ratio 1:1). Im Frühjahr 2006 wurden Beerengallen bei NeustiftSonnleiten ab 03.05 .06 beobachtet; am 17.05.06 hatten die größten Ø 9-9.5 mm erreicht; am 20.23.05.06 schlüpften aus Blüten- und Blattgallen einige Gallwespen ( $N$. quercusbaccarum $0^{7} 9$ ). -Im Frühjahr 2007 wurden erste Beerengallen bei Neustift am 25.04.07 an mehreren Blättern beobachtet, und bei Elvas am 27.04.07 einige Beerengallen an Blütenkätzchen und Blättern.\nIm Frühjahr 2008 wurden Beerengallen an Blütenständen und Blättern von Eichen am 23.05.08 in der Tschötscher Heide bei Brixen ( 750 m ) beobachtet und gesammelt (Fotos); zu dem Zeitpunkt waren die männlichen Blütenkätzchen, die seit 2 Wochen blühten, schon großteils verblüht; einige Beerengallen wiesen bereits frische Ausfluglöcher der Gallwespen auf (Foto), weitere Imagines ( $0^{7} 9$ ) schlüpften daraus am 24.-25.05.08. Die\n\nErscheinungszeit der „Beerengallen\" reicht somit, je nach Höhe und Witterungsverlauf, von Ende April bis Ende Mai; dann zerfallen sie oder fallen ab. Allerdings bleiben parasitierte Beerengallen an Blättern oft noch längere Zeit als hellbraune, dünnschalige „Kugelgallen\" am Blatt haften und können dann verwechselt werden mit den ähnlichen „Borstigen Kugelgallen\" von Neuroterus tricolor. Eine alte hellbraune doppelte Beerengalle, einmal mit Flugloch blattunterseits, einmal oben, fand ich am 22.06.2008 auf Flaumeichenblatt in Castelfeder (leg./Foto Hellrigl). Fünf vertrocknete hellbraune Beerengallen (Ø 3,0-4,5-5,5 mm) fanden sich am 25.06.2008 auf der Tschötscher Heide (Fotos), daraus schlüpften nach 3 Tagen 5 Inquiline Synergus pallipes Htg. (= albipes Htg., nervosus Htg.).\n\n102 Neuroterus saliens (Kollar 1857)\n[Syn. = Neuroterus saltans Giraud 1859]\n[90 = Spathegaster glandiformis Giraud 1859]\nVerursacht in der agamen Generation an Quercus cerris [bzw. in Spanien an Q. suber] auf Blattadern und Blattstielen kleine grüne oder gelbe bis rotbraune, ovoidal-spindelförmige Gallen ( $2-3 \\mathrm{~mm}$ ), einzeln oder zu mehreren der Länge nach anliegend [Csóka 1997: 102/103; Melika et al. 2000: 288, Figs. 88; Nieves Aldrey 2001: 431, 542; Figs. 122 I-J]. Die Gallen erscheinen im Sept. und springen bei Reife im Okt. ab, wie Vinz. Kollar (Vorstand des zoologischen Hof-Naturaliencabinets Wien) 1857 entdeckt hatte; auch gelöste Gallen können bei Berührung infolge ruckartiger Bewegungen der Larven springen ( $=N$. saltans Giraud 1859) [Buhr 1965: 971; Nr. 5552, 5574; Kieffer 1901: 669, N. saltans Gir. (agam); 674, N. glandiformis Gir. (bisex.); Pl. XVII, Figs. 2, 7]. - Sexuelle Frühjahrs-Generation mit Gallen welche Fruchtbechern von Zerreichen sehr ähneln (= glandiformis) [vgl. Henschel 1888: Fig. 29; Bellmann: Foto 2006]; diese war lange nicht erkannt (Nieves Aldrey 2001: 432-433; Figs. 122 H, 145 D), so dass die Art auch in Checkl. Italiens (1995: Nr. 27/04 und 27/11) noch unter beiden Namen getrennt aufscheint. Als „N. glandiformis (Gir.)\" auch aus Toskana gemeldet (Bernardi et al. 1997: 164-165). Verbreitung circummediterran, bis Mitteleuropa einstrahlend. In FVG aus Triest-Monrupino, an Quercus cerris, 30.10.1994, von Tomasi (2006: 75) gemeldet. War\n\n--- Seite 112 ---\nauch für Trentino zu erwarten und wurde hier am 14.10.2007 bei Pomarolo-Servis ( 700 m ) gefunden (leg. Hellrigl \\& Mörl); an einem jungen Zerreichentrieb waren einige kleine, rötlich-gelbe agame Gallen der Länge nach angeheftet, doch ging der unscheinbare Beleg vor der Fotodokumentation verloren. Hier wurden im Folgejahr 2008 am 7. Sept. vier weitere hellgelbe Spindelgallen ( 3 mm ) gefunden, die sich bald rötlichbraun verfärbten (Abb. 102), jeweils einzeln anliegend an der Hauptblattader bzw. am Blattstiel von Zerreichenblättern (leg. Hellrigl \\& Mörl). Weitere Belege fanden sich in Pomarolo am 12.10.2008 (leg. Hellrigl): 1 frische Galle an Hauptblattnerv auf Blattunterseite sowie 2 parasitierte Gallen (mit Ausflugloch) am Blattstiel von Zerreiche (Abb. 102). - Erfolglos verlief hingegen im Sommer (27.07.08) die Suche nach eichelbecherartigen „Zottengallen\" ( $\\delta^{\\circ}$ ), da es nicht möglich war alle in Betracht kommenden „Eichelbecher\" von Zerreiche näher zu untersuchen.\n\n103 Neuroterus tricolor (Hartig 1841)\n(ㅇ) Spath. tricolor Hartig 1841)\n\n- Borstige Kugelgalle\n(ㅇ) N. fumipennis Hartig 1841)\n- Kleine Linsengalle\n\nVerursacht in der agamen Generation an Blattunterseite von Quercus-Arten kleine, schälchenförmige Linsengallen, mit erhabenem, hehaartem Rand („Cupped spangle gall causer\"); Gallen ähneln denen von N. albipes. - Sexualgeneration mit kleinen behaarten Erbsengallen („Hairy-pea gall causer\"); kugelig, Ø 4-6 mm, mit 1-2 mm langen feinen Haaren reichlich besetzt, Gallenreife im Juni. [Riedel 1910: Nr. 47 N.tricolor (sex.) Taf.IV.; Nr. 40 N. fumipennis (agam) Taf.IV.; Kieffer 1901: 644645; (sex.): Pl. XVIII, Fig. 5; N. fumipennis (agam): Pl. XIX, fig. 5; BuHR 1965: Nr. 5482; Pfützenreiter 1958: 117, Nr. 46-47, Abb. 37 (sex.), 38 (agam); Melika et al. 2000: 288, Figs. 89; Nieves-Aldrey 2001:436, 543; Figs. 131 A-C, E, 145 E-F; Redfern et al. 2002: 412, Fig. 716].\nN-Italien (Checklist 1995: Nr. 27/11). Von Dalla TorRe (1894) aus N-Tirol angeführt als Gallen von Neuroterus fumipennis Htg., an Q.pedunculata u. Q. sessiliflora: Volderwald bei Hall, Juli 1893. In FVG rezent aus Triest Umgeb. an Quercus petraea, 17.07.2000, von Tomasi (2006: 75) gemeldet.\n\nDie Art war für Südtirol-Trentino zu erwarten. Einzelne Linsengallen an Eichen bei Rovereto im Sept. 2005; öfters auch im Südtiroler Unterland, Castelfeder/Auer an Q. pubescens, 24.09.2006, flache rötliche Linsengallen an Blättern älterer Eichen (Abb. 103). Die „kleinen Linsengallen\" [mit erhabenem, behaartem Rand] traten auch im Mischbefall mit den häufigen großen Linsengallen von N.quercusbaccarum ( $=$ N. lenticularis) auf. Während sich die „kleinen Linsengallen\" leicht von „großen Linsengallen\" (N. lenticularis) unterscheiden lassen, erscheint eine Abgrenzung gegenüber „Krempengallen\" (N. laeviusculus) problematisch. Die Abgrenzung dieser agamen Linsengallen wird besser zu verifizieren sein.\nAuch bei der Identifizierung „Borstiger Kugelgallen\" der Sexualgeneration ( $\\varnothing$ 3-5 mm) gab es Probleme. Im Gegensatz zu den kugeligen, saftig durchscheinenden Frühjahrs-Blattgallen von N. quercusbaccarum, sind diese „Borstengallen\" nicht durchscheinend und mit $\\pm$ langen borstigen weißen oder roten Haaren dicht besetzt (PfützenreITER 1958; NieVES-ALDREY 2001). Bei manchen braunen kurzborstigen „Kugelgallen\" (VI.2008) blieb die Frage offen, ob sie zu N. tricolor oder zu N.quercusbaccarum zu stellen seien (vgl. Abb. 103).\n\n## Genus Pseudoneuroterus Kinsey 1923\n\n104 Pseudoneuroterus macropterus (Hartig 1843) Bildet in der agamen Generation an Trieben von Quercus cerris walzenförmige, vielkammerige Gallen; junge Zweige in einer Länge von 10-50 mm allseitig auf das 2-4fach des normalen Umfangs angeschwollen; im Holzteil der Galle eingesenkt zahlreiche langovale, zum Mark senkrecht stehende Kammern mit je einer Larve [vgl. Buhr 1965: p. 970, Nr. 5548]. Ein Foto einer Zweiggalle aus dem österr. Burgenland (Doberling/Oberwart, 05.06.05) bringt Dr. H.-J. Buhr (www.pflanzengallen.de).\nDie Wespe wie deren Galle an Quercus cerris war eine Entdeckung von Kollar in Wien, von dem sie Hartig (1843: 407) erhielt und Wespe und Galle als \"Cynips macroptera Kollar\" beschrieb.\nDie Art wird aus Österreich, Ungarn [vgl. Melika et al. 2000: 286, Fig. 82, Neuroterus macropterus], Bulgarien, Rumänien, Kroatien, Griechenland,\n\n--- Seite 113 ---\nItalien angegeben, fehlt aber in Deutschland (Fauna Europaea 2005). Sie fehlt auch in Spanien (wie die Zerreiche), doch werden dort ähnliche Gallen von Plagiotrochus-Arten an Quercus ilex und Q. coccifera hervorgerufen [Nives-ALdREY 2001: 312, 533; Figs. 123 H-I, 124 B-D, 138 E, 139 E]. - Kieffer 1901: 667; Pl. XVII, fig. 6; Dalla Torre \\& Kieffer (1910: 322) nennen die Art Neuroterus macropterus (aus Verona: Massalongo) und erwähnen weiters sehr ähnliche Gallen (1910: p.389, Fig. 90), mit länglicher Zweiganschwellung an Q. coccifera, Q. ilex und $Q$. suber, aus S-Frankreich und Spanien, verursacht durch Plagiotrochus kiefferianus Tav., die sie als agame Generation zu P. quercusilicis (F.) gehörend betrachten. [vgl. Nr. 93].\nIn Checklist Ital. (1995: Nr. 27/06, Neuroterus macropterus) für N-Italien angegeben. - In FVG aus Triest Umg. Meldungen durch GrÄFFE (1905: 48-49; Neuroterus macropterus; Cecidothek FVG): Anschwellung junger Asttriebe von Quercus cerris. [cit. Tomasi 1996: 70, Nr. 105; 2006: 23, 74].\nAus Südtirol-Trentino erstmals rezent nachgewiesen: bei Castelfeder ( 400 m ): mehrfach alte Gallen an Zweigen einer großen Zerreiche: 28.04.2005, 1 Zweig mit 3 Gallen ( $20 \\times 10 ; 22 \\times 8 ; 21 \\times 12 \\mathrm{~mm}$ ), 2 Zweige mit jeweils einer Galle ( $17 \\times 10$; $35 \\times 13 \\mathrm{~mm}$ ); ebenda am 10.05.2005 eine weitere frische Galle ( $30 \\times 10 \\mathrm{~mm}$ ) mit Blattschöpfen (Abb. 104), aus der Inquilinen schlüpften (leg. Hellrigl). Weitere Funde: Castelfeder, 24.09.2006, an großer Zerreiche, 3 Zweige mit 6 alten verholzten Gallen: 1 Zweig mit 1 Galle ( $15 \\times 11 \\mathrm{~mm}$ ), 1 Zweig mit 2 Holzgallen ( $19 \\times 10 ; 18 \\times 10 \\mathrm{~mm}$ ) und 1 Zweig mit 3 Gallen ( $20 \\times 10 ; 20 \\times 10 ; 35 \\times 15 \\mathrm{~mm}$ ); ebenso 17.08.2008 3 Holzgallen. Insgesamt: 15 Zweig Gallen aus Südtirol (leg./Foto Hellrigl).\nErwartungsgemäß wurden Gallen auch im Trentino gefunden: Pomarolo-Servis (IT-04), 14.10.2007, an niederen, jüngeren Zerreichen zahlreiche alte verholzte Zweig Gallen (Abb. 104b); es wurden 1 Dutzend Gallen als Belege gesammelt (leg. Hellrigl \\& Mörl). Weitere 12 alte verdickte Zweig Gallen an strauchigen Zerreichen wurden am 19.07.08 gesammelt (leg. Hellrigl \\& Schanung). Einige unterständige jüngere Zerreichen waren durch starken Befall weitgehend am Absterben. - Neu für die Region.\n\nGenus Trigonaspis Hartig 1840\n[105] Trigonaspis megaptera (Panzer 1801) $9{ }_{0}^{2}$ [= Trigonaspis crustalis Hartig 1840: 195, 0] [= Cynips renum Hartig 1840: 208, agame Galle] Verursacht in der agamen Generation auf der Blattunterseite von Quercus an den Blattadern kleine hellgrüne, nierenförmige Gallen ( $=$ Cynips renum Hartig); Gallen erst im Herbst, Ende Sept./Okt., oft zahlreich an jüngeren Stockausschlägen ( $=$,„Kidney gall causer\"). - Sexualgeneration im Frühjahr mit erbsengroßen, kugeligen, saftig-fleischigen, wach-sig-weißlichen bis rosa Gallen (=\"Pink-wax gall\"), im Mai-Juni an schlafenden Knospen am Stamm, oft auch an Schößlingen bis 12 cm Bodenhöhe. [Kieffer 1901: 576-580; Pl. XX, Fig. 9 (megaptera), Fig. 3 (renum); Riedel 1910: Nr. 8 T. megaptera 90 , Taf. III; Nr. 30 T.renum ㅇ, Taf. IV; Pfützenreiter 1958: Nr. 11, Abb. 8 (90) Korallengalle); Nr. 34, Abb. 28 (99 Nieren-Blattgalle); Buhr 1965: Nr. 5412, 5441 (Kugelgalle 09); 5480 (NierenBlattgalle 99); Nieves-Aldrey 2001: 479; 546; 575: agame Nierengallen, Fig. 132i; Redfern et al. 2002: 404, 412; Figs. 679, 717; Melika et al. 2000: 289, Fig. 91].\nDie Sexualgeneration und deren Gallen wurden von Hartig (1840: 195) als Trigonaspis crustalis beschrieben: „Anfang Juni aus weichen, saftigen, kugelrunden, rosenrothen Erbsen- bis Haselnussgroßen Gallen, theils in den Rindenritzen alter Eichen, teils aus Lateralknospen junger Eichenpflanzen; besonders häufig an Wassereichen. Auch Gallen, welche scheinbar aus der Rinde hervorbrechen, haben zur Basis eine schlafende Knospe, weshalb man die Galle nur an untern Stammteilen findet. \"\nVon Frankreich über Britannien, Deutschland, Dänemark, nördl. Mitteleuropa bis Fennoskandinavien verbreitet; auch in Österreich und Ungarn, SE-Europa, Balkan und N-Italien; fraglich in Spanien. Aus Italien (Checkl. Ital., 1995: Nr. 31/01) vom Norden (und wohl fälschlich auch Sizilien) gemeldet. Auch aus Rom eine alte Meldung: Villa Borghese 1895 (Zapparoli 1997: 316): \"Insetti di Roma\". Aus Triest wenige Angaben durch GrÄFFE (1905: 27-28, Taf. II, n. 6): „Trigonaspis renum-megaptera [agam: Taf. II, Fig. 6] ist selten in der Umgeb.\n\n--- Seite 114 ---\nTriests und gehört mehr nördlicheren Breiten.\" Von Cobelli (1903: 165) aus Trentino angeführt (ohne Fundangabe), doch ist Verwechslung mit der folgenden Art möglich. Die erbsenförmigen Gallen der Sexualgeneration („Pink-wax galls\") sind nach Buhr (l.c.), Kieffer (l.c.) und Nieves-Aldrey (2001: 479) nicht unterscheidbar von der folgenden Art Trigonaspis synaspis. - Die unverkennbaren agamen „Nierengallen\" (Cynips renum) an Blättern im Herbst konnten hingegen in Südtirol und im Trentino bisher nicht gefunden werden (Abb.105).\n\n106 Trigonaspis synaspis (Hartig 1841)\n[= Apophyllus synaspis Hartig, 1841: 340 (agam)]\n[ $9 \\delta=$ T.megapteropsis Wriese in Kieffer, 1901]\nBildet in der agamen Generation kugelige Gallen auf der Blattunterseite von Eichen (Quercus spp.), vornehmlich in Bodennähe. Die gelblich-weißen bis rötlichen Gallen sind fleischig-dickwandig, mit $\\pm$ glatter Oberfläche und kugelig rund ( $\\varnothing$ bis 8 mm ); in Färbung, Form und Größe sind sie sehr ähnlich den Erbsengallen von Diplolepis eglanteriae (an Rosen) und treten oft in starker Anhäufung auf der Unterseite der Eichenblätter an Blattadern auf (Abb. 106). Die agamen Gallen reifen [nach NievesAldrey (2001: 477) sowie eigenen Beobachtungen] im Sept. und fallen dann von den Blättern ab.\nDie Angaben zur Phänologie der Gallen und Imagines sind in der Fachliteratur sehr widersprüchlich. Hartig (1841:340) hatte im Zuge der Erstbeschreibung von Apophyllus synaspis folgende Angaben gemacht: „Im Frühjahr im hiesigen Forstgarten [bei Braunschweig] auf der Unterseite der Blätter junger einjähriger Eichen in großer Menge kugelrunde, grüne, glatte Saftgallen, die ausgewachsen einen Durchmesser von 2-2,5 Linien erreichten $(=4-6 \\mathrm{~mm})$, schon im Juni abfielen und auf der Erde liegend eine schöne rote Farbe erhielten. Diesen Gallen entschlüpften schon Ende Juni und im Juli die Wespen und zwar nur (flügellose) Weibchen, obgleich ich viele Hundert Exemplare zur Verwandlung gebracht habe: Long. lin. 2/3-1; Thorax formicaeformis, abdomine angustior, alis nullis. \" [agame Generation];\nNach Kieffer (1914: 46, 57) „erscheint die agame Galle von Trig. synaspis im Mai und fällt ab im Juni, doch die flügellose agame Imago erscheint erst im folgenden Dezember oder Januar.\" Kieffer (1901:\n\n581-582; Pl. XVIII, Fig. 10): auch nach Trotter in Italien, agame Wespen im Dezember - Januar.\nNach der Bestimmungstabelle von Buhr (1965: 954) - der offenbar den Angaben von Hartig folgt - sollen agame Gallen angeblich nur im Frühjahr und Vorsommer vorhanden sein. Ich selbst fand die agamen Blattgallen von Trig. synaspis hier immer nur im Spätsommer und Herbst.\nEine frühere Erscheinungszeit trifft offenbar nur für die Gallen der geflügelten Sexualgeneration an Adventivtrieben und Wurzelausläufern im Bodenbereich zu [vgl. Nieves Aldrey 2001: Fig. 133 e-f, 147 n ]; dies gilt anscheinend für alle europäischen Trigonaspis-Arten. Auch Kieffer (1914: p. 20) gibt in seiner Übersicht der Arten mit Generationswechsel als Erscheinungszeit für die Sexualgeneration von Trig. megapteropsis Wriese „Mai\" an, und desgleichen für Trig. megaptera Panz.\nGallen der sexuellen Generation [Nieves Aldrey 2001: Figs. 125k, 147c] bilden sich an adventiven Knospen nahe dem Boden, an der Stammbasis größerer Bäume, oder an Jahrestrieben oder Ausläufern, welche halbbedeckt von Erde oder Fallaub bleiben. Die Gallen der bisexuellen Generation entwickeln sich in div. Quercus und können (z.B. in Spanien) lokal häufig auftreten, wenngleich schwierig zu entdecken (aus Südtirol nicht bekannt!). Die Gallen sind von unregelmäßig kugeliger Form, mit Durchmesser bis 10 mm ; die Färbung weißlich oder rötlich, die Gewebestruktur saftig. Sie erscheinen einzeln oder in Gruppen. Im Inneren eine weite Larvenkammer mit relativ breiter Wand.\nIn Europa weit verbreitet, aber nicht häufig; aus N-Italien bekannt (Checkl. Ital. 1995: Nr. 31/02). In FVG vom Triestiner Karst Meldung durch GrÄFFE (1905: 61, Nachtrag: Trigonaspis synaspis Hart.). Eine alte Meldung aus Südtirol: Dalla Torre (1892): Blattgallen an Quercus sessiliflora, Bozen (Mayr 1882: p.31). Zu diesen synaspis-Gallen aus Tyrol bemerkt Mayr (l.c.): „zwei dieser Gallen enthielten im Inneren, Mitte November, die lebenden Cynipiden\" - und erwähnt: „nach Hartig soll das Insekt im Juni oder Juli des 1. Jahres schlüpfen\". Kieffer (1901: 582) ergänzt hierzu, dass er selbst synaspis-Gallen ( $\\varnothing 6-7 \\mathrm{~mm}$ ) aus Italien von Trotter erhalten hatte, und dieser betont habe, dass diese Gallwespe ihre Galle im Dezember und im Januar verlässt. Die Angabe Hartig's erscheint somit irrig.\n\n--- Seite 115 ---\nVon Dalla Torre \\& Kieffer (1910) wird aus Bozen die spezifische Inquiline Synergus physoceras Hartig (Männchen mit starker Verdickung des 3.F-Gliedes) angeführt.\n\nRezent wurden in Südtirol die kugeligen Blattgallen (Ø 3-8 mm) erstmals Mitte Okt. 2004 in Anzahl bei Neustift ( 750 m ) an Quercus petraea gefunden (leg./det. Hellrigl); die grünlich-gelben, seltener roten Erbsengallen fanden sich nur an einzelnen Eichenschößlingen (von Bodennähe bis Hüfthöhe), dort aber in größerer Anhäufung; meist an mehreren Blättern, mit 10 bis 24 Erbsengallen\npro Blatt (Abb. 106). Aus am 17.10.2004 und bis Ende Oktober gesammelten Gallen schlüpften bei Indoor-Aufzucht bereits im Nov./Dez. 2004 zahlreiche spezifische Inquilinen (Synergus physoceras, S. thaumacerus u.a.) und Parasitoiden (Eurytomidae: Eurytoma sp., Torymidae: Torymus sp., Pteromalidae: Mesopolobus sp.). Vereinzelt fanden sich Gallen auch in der Tschötscher-Heide ( 750 m ) an bodennahen Eichenschößlingen, am 20.10.2004 (leg. Hellrigl). Insgesamt wurden im Herbst 2004 an die 500 Gallen gesammelt und in Aufzucht genommen (vgl. Tab.6)\n\nTab. 6\n\n| Gallen-Zucht: ex <br> Trigonaspis synaspis | Cynipidae: <br> Synergus sp. | Eulophidae \\& <br> Eupelmidae | Eurytomidae <br> Eurytoma sp. | Pteromalidae <br> Mesopolobus* | Torymidae \\& <br> Ormyridae |\n| :-- | :-- | :-- | :-- | :-- | :-- |\n| 04.11. - 31.12.2004 <br> ex gallae: 189 Ex | 90 | 3 | 53 | $24^{*}$ | 19 |\n| 30.10. - 30.12.2005 <br> Herbstzucht: N $=251$ | 71 | 1 | 141 | $5^{*}+7$ | 26 |\n| 01.05. - 30.05.2006 <br> Frühj.Zucht: N $=118$ | 79 | - | 25 | $1^{*}+9$ | 4 |\n| SUMME: N $=558$ | $240(43,0 \\%)$ | $4(0,7 \\%)$ | $219(39,2 \\%)$ | $46(8,3 \\%)$ | $49(8,8 \\%)$ |\n\nBei Synergus spp. handelte es sich größtenteils um Synergus physoceras ( $0^{7} 0^{7} 73 \\%, 9^{9} 9^{7} \\%$ ) und einzelne S. thaumacerus; bei Eurytomidae: Eurytoma brunniventris; bei Ormyridae: Ormyrus pomaceus; bei Torymidae: Torymus sp.; die Pteromalidae umfassten 30 Mesopolobus fasciiventris ( 25 ơ, 5 ㅇ) und 16 Arthrolytus (Anarthrolytus) sp. cf. nanus; die Eupelmidae 19 Eupelmus uruzonus; Eulophidae: 3 Aulogymnus sp. cf. gallarum.\n\nBei weiteren Untersuchungen im Folgejahr, Aug./ Sept./Okt. 2005, fanden sich wiederum zahlreiche Gallen an bodennahen Schößlingen und Stockausschlägen von Q. petraea bei Neustift (650-700 m), oberhalb des Schießstands und unterhalb Steinraffler. Vom 18.08. und 24.09.05 bis 22.10 .05 wurden hier insgesamt über 1000 Gallen gesammelt und davon 878 Gallen vermessen (Grafik 9).\nNur sporadisch fanden sich Gallen an niederem Eichengebüsch auf der Tschötscher Heide ( 750 m ):\n01.10.05 (10 Blätter), 04.10.05 (6 Blätter), 07.10.05 (4 Bl.), 11.10.05 (4 Bl./10 Gallen); nur vereinzelt (2 Blätter mit einigen Gallen) am 25.09.2005 auch im Eichenwald von Rovereto (leg. Hellrigl).\nDie Untersuchungen wurden im Sommer/Herbst 2006 fortgeführt, wobei wiederum zahlreiche Gallen gesammelt wurden: bei Neustift/Steinraffler, 05.08.2006, 1 Eichenschößling mit T. synaspis; ebenso Neustift, 05.09.2006: diverse T. synaspisGallen (bis 7.5 mm ); sowie 08.10.2006, 14 Blätter mit Trigonaspis-Gallen. Auch Brixen-Mahr ( 650 m ), 03.09.2006: T. synaspis-Gallen (Q. petraea): 1 Blatt 17 x 10 cm (Foto). Brixen Umg., Tschötscher Heide ( 750 m ), 30.09.2006: 1 Blatt mit 7 T. synaspis (Foto); ibidem: 09.10.2006: 1 Blatt mit Gallen T. synaspis (leg./Foto Hellrigl) (Foto). Auch in den Folgejahren 2007/08 fanden sich an den bisherigen Fundplätzen im Eisacktal weiterhin Gallen von T. synaspis (agam), allerdings immer erst ab September (vgl. Befallsanalyse). (Abb. 106).\n\n--- Seite 116 ---\nBeobachtungen zur Lebensweise und zum Vorkommen der Gallen von Trigonaspis synaspis: Ansammlungen von Gallen dieser Art an Stockausschlägen von Traubeneiche ( $Q$. petraea), wurden erstmals am 17.10.2004 bei Neustift-Steinraffler ( 750 m ) zufällig entdeckt (leg./Foto Hellrigl). Entlang eines Waldweges und einer kleineren Schlaglichtung in einem Kiefernwald mit Eichenunterwuchs, fanden sich die kleinen kugeligen Gallen (Ø 3-8 mm) mehr weniger gehäuft und zahlreich an der Unterseite der Blätter von Quercus petraea, vornehmlich an üppigen Stockausschlägen (Johannistriebe) in halbschattigen Lagen, mit $\\pm$ dichtem grasigen bzw. krautigem Bodenbewuchs, in relativ geringem Bodenabstand von $20-50 \\mathrm{~cm}$ Höhe (Abb. 106). Diese Gallen unterschieden sich deutlich von den im selben Gebiet häufig an jungen Eichen vorkommenden, ebenfalls kugeligen Blattgallen von Cynips quercusfolii, welche ja bedeutend größer sind ( $8-23 \\mathrm{~mm}$ ) und meist weniger zahlreich pro Blattfläche. Nur ausnahmsweise wurden Blätter mit T. synaspis-Gallen in Hüft- bis Schulterhöhe gefunden. Besonders auffällig war, dass befallener Jungwuchs und Stockausschläge von Eichen fast durchwegs starken Befall von Eichen-Mehltaupilz (Microsphaera alphitoides) an den oberen Blättern aufwiesen (vgl. Abb.). Für das epidemische Auftreten dieses Mehltaupilzes sind bestimmte Witterungsbedingungen erforderlich: Die Entwicklung des Pilzes erfolgt am besten auf wüchsigen Pflanzen mit starkem Johannistrieb und ausgeglichener Wasserund Nährstoffversorgung (Schwerdtfeger 1981: 87-88).\nTrotz ihres auffälligen Aussehens und dichten Gallenbesatzes bereitete eine Identifizierung der Gallen zunächst Schwierigkeiten, da diese Gallen in einschlägigen Bestimmungsbüchern entweder fehlten (z.B. Redfern et al. 2002: 413-414), oder der Zeitpunkt ihres Auftretens nicht für Herbst sondern für das Frühjahr angegeben war (z.B.: Riedel 1910: Nr. 8B T.megapteropsis ㅇ; Nr. 32 T. synaspis ㅇ, Taf.IV; Buhr 1965: 954). Auch die verfügbaren Bilder von Blattgallen (Melika et al. 2000: 289, Fig. 92; Nieves Aldrey 2001: Figs. 133 e-f, 147 в) entsprachen nicht den in Neustift/Südtirol beobachteten dichten Befallsbildern. Hinzu kam, dass aus der Aufzucht hunderter im Herbst 2004 gesammelter Gallen keine Imagines der agamen Gallenerzeuger\n(aptere $Q$ ) schlüpften, sondern nur zahlreiche Inquilinen (Synergus spp.) und Parasitoiden (Eurytomidae, Torymidae und Pteromalidae). Die über 500 Parsiten und Inquilinen schlüpften teils im Herbst als auch im Frühjahr (vgl. Tab. 6).\nSpeziell waren es gerade diese Inquilinen, mit einem Besetzungsgrad der Gallen von ca. $40 \\%$, welche die Richtigkeit der Diagnose bestätigten, da darunter vor allem zwei unverkennbare Arten vertreten waren, Synergus physoceras und S. thaumacerus, die als typisch für Trigonaspis spp. angegeben werden (Nieves Aldrey 2001: 246, 476, 600).\n\n## Befallsanalyse:\n\nIm Spätsommer/Herbst 2005 wurden speziell wüchsige Stockausschläge und Johannistriebe von Traubeneichen mit Mehltaubefall näher untersucht. Auf einer vorjährigen Schlagfläche bei Neustift ( 700 m ), mit üppigen Eichenstockausschlägen und Jungwuchs, bestätigte sich der bisherige Befallsbefund an zahlreichen Stockauschlägen mit deutlichem Mehltaubefall und grasigem Unterwuchs (Abb. 106). Eine genaue Analyse befallener Eichenschößlinge durch T. synaspis brachte aufschlußreiche Befunde:\n1.) Gallenbefall fand sich fast nur an niederen Eichenschößligen (Basis Ø: 3-4 mm) sowie an bis zu hüfthohen Stockausschlägen (Basis Ø: 5-9 mm).\n2.) An niederen Eichenschößlingen von $10-20 \\mathrm{~cm}$ Länge - unter Deckung höherer Stockausschläge - erreichte die Gallenbildung auch die oberen Blätter.\n3.) Bei Stockausschlägen von 30-50 cm Länge, umfasste die Gallenbildung meist Blätter im mittleren Abschnitt, während der apikale sowie der basale Teil der Schößlinge befallsfrei waren (Abb.).\n4.) Bei Stockausschlägen von $60-100 \\mathrm{~cm}$, waren oft auch längere Triebabschnitte befallen; am 17.10.2004 fand sich ein Stockausschlag von 1 m Länge, mit dichtem Befall über 60 cm Länge (Abb. 106a).\n5.) Die Befallsverhältnisse wurden an 25 Eichenschößlingen und Stockausschlägen, mit Trieblängen von $10-60 \\mathrm{~cm}$ (Durchnitt 33 cm ) erhoben. Der Basisdurchmesser der befallenen Triebe lag bei 3-6 mm (selten 7-9 mm); an den Trieben waren etwa $40 \\%$ der Blätter befallen.\n\n--- Seite 117 ---\n6.) Neben Befall an Bodenschößlingen, wurde am 17.10.2005 auch eine Befallsstelle in Schulterhöhe gefunden ( 22 befallene Blätter), an Seitenzweig (Länge $45 \\mathrm{~cm}, \\varnothing 7 \\mathrm{~mm}$ ) einer strauchigen Q. petraea.\n7.) Der Befall ist trotz dichter Gallenbildung an der Blattunterseite leicht zu übersehen und meist nur bei gezielter Suche zu entdecken. So hatte eine gründliche Suche am 24.09.2005 auf einer Schlagfläche in Neustift zahlreiche befallene Eichenschößlinge und rd. 400 Gallen ergeben. Bei Nachsuche am 14.10.2005 am selben Platz wurden nochmals eben soviele befallene Triebe und Gallen gefunden.\n8.) Die Blattgallen sind von kugeliger Form (Erbsengallen - \"Pea galls\"): als kleine Junggallen ( 1 mm ) anfänglich gelb, sich bald $\\pm$ intensiv rot färbend (2-3.5 mm), später rot-gelbe Färbung (3-4.5 mm), als reifende Gallen gelblich bis grünlichgelb (4-8 mm); zum Schluß werden sie braun (vgl.Abb.) und fallen leicht ab. - Die Kugelgallen sind sehr ähnlich denen von Diplolepis eglanteriae (an Wildrosen), aber im Gegensatz zu diesen fleischig-dickwandig und mit kleineren Larvenkammer; äußerlich erscheinen sie ebenfalls hart (innen aber schwammig-fleischig); reife Gallen fallen leicht von den Blättern ab, da die etwas konisch vorragende Gallenbasis nur punktförmig an den Blattnerven befestigt ist. Die Gallenbildung erfolgt stets blattunterseits, hauptsächlich entlang des Hauptnervs oder stärkerer Seitennerven. Die Gallenanhäufung ist meist sehr dicht, wobei am selben Blatt bzw. Blattnerv kleinere und größere Gallen gemeinsam vorkommen (können) (vgl.Abb. 106).\n9.) Bei der Vermessung von Trigonaspis-Blattgallen aus Neustift vom $24.09 .05[\\mathrm{~N}=400]$ und vom 14.10.05 $[\\mathrm{N}=478]$ wurden nur gelbliche und braune, reif erscheinende glatte Gallen berücksichtigt, hingegen keine kleineren oder noch weichen unreifen, roten bzw. rotgelben Gallen unter $3 \\mathrm{~mm} \\varnothing$. 10.) Verwechslungsmöglichkeit der glatten, runden Blattgallen besteht mit Gallen folgender Arten:\nCynips quercus: Gallen größer, meist um 8 mm , matte Färbung, sehr hartwandig, mit differenzierter, größerer, $\\pm$ querovaler Larvenkammer; mehr vereinzelt und meist an bodenferneren Blättern;\nCynips quercusfolii: Gallen sind deutlich größer (8-23 mm); meist weniger zahlreich pro Blattfläche;\nkleine (1-3 mm) Junggallen von C. quercusfolii mehr zitronengelb und mit höckeriger Oberfläche; Cynips agama: Gallen kleiner (bis 4 mm ), hart und dünnwandig, mit höckeriger Oberfläche.\nCynips divisa: Gallen nicht kugelrund, sondern $\\pm$ abgeflacht, glatt-glänzend, Larvenkammer queroval; Cynips disticha: Gallen nicht kugelrund, $\\pm$ kegelstumpfförmig, Larvenkammer zweizellig;\n11.) Eine Aufzucht der agamen, flügellosen T. synas-pis-Weibchen aus den Herbstgallen ist schwierig, da diese stark von Parasitoiden und Inquilinen besetzt sind. Unter diesen sind besonders zahlreich Eurytomidae vertreten (Tab. 6) und unter den Synergisten spezifische Arten wie Synergus physoceras, deren Männchen am unförmig verdickten, blasenartigen 3. Fühlerglied erkennbar sind (Abb. 124).\n12.) Die von einigen Autoren angeführten Vorkommen von agamen T. synaspis-Gallen im Frühjahr und Vorsommer [Hartig 1841: 340; Riedel 1910: 44; Buhr 1965: 954] wurden in Südtirol nie beobachtet. Die jahreszeitlich frühesten Gallenfunde an den Blättern erfolgten in Neustift am 20.07.05 bzw. Tschötsch am 21.07.05 (blattunterseits wenige kleine Trigonaspis), dann in Neustift am 05.08.06 (1 Eiche mit Trigonaspis) bzw. 18.08.05 (5 kleine unreife Gallen: 2-3 mm; 7 mittlere Gallen: 5-6 mm; 10 Gallen: $7-9 \\mathrm{~mm}$ ); häufiger waren die Gallen erst ab Anf. Sept. bis Ende Oktober zu finden. Ende Aug. und Anfang Sept. sind die Gallen meist gelblichgrün, ab Mitte/Ende Sept. bis Mitte Okt. finden sich immer mehr braune Gallen; doch auch Mitte Okt. finden sich noch pralle gelbgrüne Gallen, wie etwa im ersten Jahr am 18.10.2004 (vgl. Abb. 106 div.). Negativen Befund erbrachte eine frühe Kontrolle am 15.07.2008, an allen bisherigen Fundorten in Brixen Umg.; es fanden sich dabei nur mittelgroße gelbe Gallen von Cynips quercusfolii (vgl. Nr. 89). Hingegen wurden 2 Monate später, bei einer Kontrolle derselben Fundorte am 12.09.2008, mehrfach Gallen von T. synaspis gefunden: in Tschötsch ( 750 m ) im Unterwuchs ein Eichenschößling mit einigen Gallen und in Neustift ( 700 m ) 3 Eichenschößlinge mit vielen Gallen (reife Gallen teilw. schon abfallend: $\\varnothing 7-8 \\mathrm{~mm}$ ). In Mahr/Brixen fanden sich am 15.09.08 an den Blättern einer 2 Monate zuvor negativ befundenen, kniehohen Traubeneiche nunmehr in Anzahl millimetergroße gelbe synaspis-Gallen (Abb.106); auch in Neustift ( 750 m ) an mehltaubefallenen\n\n--- Seite 118 ---\nEichenschößlingen, am 20.09.08, 3 Zweige (mit Gallen: 4-6-7-8 mm), sowie div. Zweige mit vielen kleinen Gallen (1-2 mm).\n\n## Diskussion:\n\nDie vorliegenden Eigenbeobachtungen stimmen völlig überein mit den Angaben von Nieves-Aldrey (2001: 477-479) zur Entwicklung und Gallenbildung von T. synaspis: Die Gallen der agamen Generation sind von regelmäßig kugeliger Form, glatter Oberfäche und variabler Färbung, von gelblich bis rötlich; sie bilden sich auf den Blattadern an der Unterseite der Blätter, hauptsächlich an den tieferen, bodennahen Abschnitten. Ein Querschnitt durch die Galle zeigt eine innere zentrale Larvenkammer, umgeben von von weichem Gewebe (Fig. 133 F). Sie beginnen ihr Wachstum und ihre Entwicklung im Sommer und reifen schon im September; nach ihrer Reife fallen sie von den Blättern ab und setzten ihre Entwicklung im Boden fort. Die fertigen Insekten - mit flügellosen agamen Weibchen - erscheinen Ende Herbst oder zu Beginn des Winters. Ebenso wie die Gallen der Sexualgeneration, bilden sie sich an Eichen; sie sind aber wenig häufig. - Die Gallen beider Generationen, besonders die der bisexuellen, beherbergen aufgrund ihrer halbunterirdischen Lage, eine interessante, großteils spezifische Gemeinschaft von Inquilinen der Gattung Synergus und parasitischen Chalcididen.\nDie Gallen der bisexuellen Generation entwickeln sich nach Nieves-Aldrey (l.c.) von April an und reifen im Mai oder Juni, um bald darauf die Insekten schlüpfen zu lassen. Nach dem Schlüpfen der geflügelten Wespen, vertrocknen die Gallen und verschwinden, mit Ausnahme der vom spezifischen Parasitoiden Torymus fastuosus befallenen, dessen Imagines erst im folgenden Frühjahr erscheinen.\nRätselhaft sind die unterschiedlichen Angaben zur Phänologie der agamen Blattgallen von Trigonaspis synaspis. Insbesondere passt die einleitend besprochene Beobachtung und Angabe von Hartig (1841: 340) über eine Gallenbildung bereits im Frühjahr, mit anschließendem Wespenschlüpfen der flügellosen agamen Weibchen im Juni/Juli, nicht ins übrige Gesamtbild und speziell zur hiesigen Situation.\nEs scheinen dabei jedenfalls die „agamen Frühjahrsgallen\" von Hartig die Ausnahme von der Regel zu sein, wie folgende Ausführungen verdeutlichen.Nieves-Aldrey (2001: 473) gibt in seinem\n\nBestimmungsschlüssel für die „agamen Formen\" der fünf europäischen Trigonaspis-Arten, davon 3 Arten mit endemischer ibero-mauritanischer Verbreitung, folgende übereinstimmende Merkmale an: Flügellose Weibchen; Gallen erscheinen zur Sommerzeit an den Blattadern der Unterseite der Blätter [Äpteros. Agallas de aparición estival en las nervaduras del envés de las hojas. Formas ágamas (sólo $\\odot$ )]. Hinsichtlich der sommerlichen Entwicklung der agamen Gallen wird für alle fünf Trigonaspis-Arten einheitlich präzisiert, dass die „Gallen zu Beginn des Herbstes reifen\"; das Schlüpfen der apteren agamen Weibchen wird mit „Herbst oder Beginn des Winters desselben Jahres\" angegeben (Nieves-Aldrey 2001: 470-484). Die agamen Blattgallen der europäischen TrigonaspisArten unterscheiden sich deutlich voneinander [vgl. Nieves-Aldrey 2001: p. 473 (Bestimmungsschlüssel); p. 635: Fig. 147 B-D-E-F (Farbfotos)].\nMeine Eigenbeobachtungen wurden bestätigt, indem der bekannte spanische Gallwespen-Spezialist J.L. Nieves-Aldrey (Madrid) hinsichtlich Phänologie der agamen Blattgallen von Trig. synaspis zu gleichen Ergebnissen und Aussagen gekommen war. Dennoch schickte ich ihm einige Fotos meiner Trigonaspis synaspis-Gallen vom Oktober 2004, deren Richtigkeit er mir am 28.03.2005 bestätigte:\n„Thanks for your interesting message. After the attached nice photographs, I am almost sure that the galls belong to Trigonaspis synaspis agamic generation. The galls are usually found under leaves situated near the ground or in lower parts of the oaks. The galls are superficially similar to C. divisa or C. agama galls, but they are much more regular and soft. Furthermore, they have an inner central cell more or less well individualized. The associated inquiline and parasitoid galls of the galls of agamic generations of Trigonaspis is very specific, especially regarding the inquilines. It seems that you have reared Synergus physocerus but the identification should be checked. This species was recently collected also from Hungary. - Best wishes Jose Luis Nieves-Aldrey.\"\nEine Überprüfung der Originalbeschreibung der nur aus Deutschland [Aachen] angegeben Trigonaspis foersteri Hartig 1841: 342 ( $\\delta^{\\text { }}$ ) ergab, dass es sich möglicherweise um das Hartig (1841: 340) unbekannte $\\delta$ seiner A. synaspis $\\odot$ (agam) handelt. [vgl. Hartig (1840: p. 195) Trigonaspis crustalis $\\delta^{\\text {® }}$ ].\n\n--- Seite 119 ---\n* Anmerkung:\nvon Dalla Torre (1892-96) und Bezzı (1899) verwendete ältere Namen für Eichen (Quercus):\nQuercus pedunculata $=$ Quercus robur Stieleiche\nQuercus sessiliflora $=$ Quercus petraea Traubeneiche\nQuercus pubescens $=$ Quercus pubescens Flaumeiche\n\nItaliensche Vulgärnamen für verschiedene Eichen (Quercus, Fagaceae):\nQuercus cerris - Zerreiche $=$ Cerro\nQuercus ilex - Steineiche $=$ Leccio\nQ. petraea $=$ Q. sessiliflora - Traubeneiche $=$ Rovere\n\nQuercus pubescens - Flaumeiche $=$ Roverella\nQuercus robur $=$ Q. pedunculata - Stieleiche $=$ Farnia\nQuercus suber - Korkeiche $=$ Sughera\n![img-37.jpeg](img-37.jpeg)\n\n--- Seite 120 ---\nAndricus kollari (2005/07)\n![img-38.jpeg](img-38.jpeg)\n\nAndricus kollari (2006/08)\n![img-39.jpeg](img-39.jpeg)\n\n--- Seite 121 ---\nAndricus quercustozae (2005)\n![img-40.jpeg](img-40.jpeg)\n\nAndricus quercustozae (2007)\n![img-41.jpeg](img-41.jpeg)\n\n--- Seite 122 ---\n![img-42.jpeg](img-42.jpeg)\n\nCynips quercusfolii (agam)\n![img-43.jpeg](img-43.jpeg)\n\n--- Seite 123 ---\nTrigonaspis synaspis (agam)\n![img-44.jpeg](img-44.jpeg)\nB. Inquiline Gallwespen: Synergini\n\nNr. 107-131\n\nSie werden in der Tribus Synergini Ashmead 1896 vereint und umfassen in Mittel- und Südeuropa insgesamt an die 50 Arten aus den hier angeführten 5 Gattungen. - G. Mayr hatte 1873 (Verh. zool.botan. Gesell. Wien, v. 22) auch 10 Arten Inquiliner Gallwespen („Einmiethler\": Tribus Synergini) beschrieben, von denen sechs heute noch Gültigkeit haben: Ceroptres cerri Mayr 1872, Saphonecrus undulatus Mayr 1872; Synergus radiatus, S. reinhardi, S. pallidipennis, S. variabilis Mayr 1873. - Der Besatz mit Inquilinen beeinträchtigt bzw. schädigt oft die Entwicklung der Gallenerzeuger.\n\n## Genus: Ceroptres Hartig, 1840\n\nAntennen der Weibchen mit 12-13 Fühlergliedern, bei den Männchen 14-15gliedrig;\n3 Arten, davon 2 auch in Italien (Checklist 1995); diese kommen auch im Trentino vor:\n\n107 Ceroptres clavicornis Hartig 1840\n(= Ceroptres arator Hartig 1841)\nHäufiger \"Einmieter\" (Inquiline) in Cynipidengallen an Quercus, besonders in „Kugelgallen\" von Andricus spp. [kollari], aus denen die kleinen Wespen (1-2 mm) öfters schlüpfen. - [Dalla Torre \\& Kieffer 1910; Pfützenreiter 1958; Nieves Aldrey 2001: 182, 527]. Art mit weiter Verbreitung in Europa. Auch aus N-Italien (Checkl. 1995: Nr. 33/01) gemeldet (C. arator Htg.).\nDie Art ist für die Region neu! - Im Trentino, bei Rovereto und Pomarolo: zusammen mit S. reinhardi aus Gallen von A. lignicolus, A. kollari und A. quercustozae gezogen (leg./det. Hellrigl 2007/08). Am häufigsten zog ich $9 \\div$ dieser kleinen Inquilinen (ca. $1 \\mathrm{~mm}=1 / 2$ Linie nach Hartig 1840) Ende Mai/ Anf. Juni 2008 (20 Ex.) aus vorjährigen Gallen von A. quercustozae aus Pomarolo (TN). - Einmal, am\n\n--- Seite 124 ---\n19.09.2008, auch aus einer Galle von A. infectorius aus Castelfeder. - Nach Hartig (1840: 197; 1841: 336, 343) ist Ceroptres claviconis [= C. arator Hartig 1841] oft auch Inquiline in Spindelgallen von A. callidoma und bei Andricus quercusradicis $(=$ A. noduli Hartig).\n\n108 Ceroptres cerri Mayr 1872\nArt mit weiter Verbreitung in Mittel- und Südeuropa: Österreich, Italien, Ungarn, Spanien [ NievesAldrey 2001: 184, 527]. - In Checklist Ital. (1995: Nr. 33/02) aus N-Italien angeführt.\nWie die vorige Art eine Inquiline in verschiedensten Eichengallen, aber mit der biologischen Unterscheidung, dass sie sich ausschließlich in Gallen entwickelt die an Zerreiche vorkommen, oder wo diese fehlt - wie in Spanien - an anderen circummediterranen Eichen (Q. suber, Q. ilex, Q. coccifera). - In den mittel- und südeuropäischen Zerreichengebieten, sind die bevorzugten Gallen jene von Neuroterus saliens, Pseudoneuroterus macropterus und Aphelonyx cerricola [Nieves Aldrey 2001: 185]. Nachdem diese letztgenannten Gallen an Quercus cerris im Trentino bei Pomarolo nicht selten sind, kommt C. cerri dort zweifellos vor. An gesammelten Gallen der genannten Arten fanden sich hier jedenfalls im Okt. 2007 div. Ausfluglöcher von Inquilinen und Parasitoiden (leg. Hellrigl \\& Mörl). Triest Umgeb. GrÄFfE (1905: 56): schmarotzt in den Gallen von Aphelonyx cerricola und Neuroterus macropterus, Andricus multiplicatus. - Wahrscheinlich war diese Art auch unter den Inquilinen, die im Juni 2005 aus frischer Zweiggalle von Pseudoneuroterus macropterus aus Castelfeder schlüpften.\n\n## Genus: Periclistus Förster, 1869\n\n3 Arten, davon 1 Art auch in N-Italien (Checklist 1995); diese kommt auch in Südtirol vor:\n\n109 Periclistus brandtii (Ratzeburg, 1832)\nAus N-Italien (Checklist 1995: Nr. 34/01) bekannt. - Die „Schwarze Rosengallwespe\" (P. brandtii), mit hyalinen hellen Flügeln, lebt als \"Einmieter\" (Inquiline) in den Gallen der „Gemeinen Rosengallwespe\" (Diplolepis rosae), deren Hinterleib im vorderen Teil rot gefärbt ist, sowie die Flügel\ngetrübt. Gemeinsam mit dieser öfters aus RosenBedeguaren gezogen: Brixen Umg., Neustift, V.1998, vereinzelt; 20.V. 2000 zahlreich (30 Ex); IV. 2005 einzeln; Vinschgau: Goldrain, 900 m , aus Rosenbedeguar, 03.-20.05.2005, 12 Ex (leg. Hellrigl). - Aus Triest Umg. GrÄffe (1905: 57) bei Zucht von Rhodites rosae-Gallen in großer Anzahl. - Auch in Osttirol bei Lienz Umg. mehrfach, 10 Ex, 1987-1998-2002 (leg. A. Kofler, vid. Hellrigl). - Neu für Südtirol und Osttirol.\n[110] [Periclistus caninae (Hartig, 1840)]\nÄhnlich der vorigen, doch Perapsiden unvollständig (nicht bis Vorderrand Mesonotum); Mesopleuren mit einer hellglänzenden, unpunktierten Stelle (nicht durchgehend gestreift). Lebt als \"Einmieter\" in den Gallen von Rosengallwespen (Diplolepis sp.), insbesondere D. eglanteriae (aber auch D. nervosa, D. centifoliae, D. spinosissimae); [vgl.: Dalla Torre \\& Kieffer 1910: 652; Nieves Aldrey 2001: 190, 527]. - Fehlt in Checklist Ital. (1995: Nr. 34/00); ist für Südtirol sicherlich zu erwarten.\n\nGenus: Saphonecrus Dalla Torre et Kieffer, 1910 Antennen der Weibchen mit 13 Fühlergliedern, bei den Männchen 14-15gliedrig. - 6 Arten, davon 2 auch in Italien (Checklist 1995); bisher nicht aus Südtirol-TN bekannt.\n[111] [Saphonecrus connatus (Hartig 1840)]\n[= Synergus erythroneurus Hartig 1840]\n[= Andricus petioli (Kollar in litt.) Hartig 1843]\nIn Europa weit verbreitet und relativ häufig - Inquiline bei diversen Gallenbildner an Quercus, insbesondere bei A. quercusradicis und Callirhytis sp. (Nieves-Aldrey 2001: 194, 527, 578). - Die Art wurde von Kollar bei Wien aus den Blattstielen der Stiel- u. Traubeneiche gezogen und von Hartig (1843: 407) als \"Andricus petioli Kllr. (in lit.)\" beschrieben. Dies war aber eine Inquiline und nicht der Gallenbildner, die Sexualform von Andricus quercusradicis, wofür sie lange gehalten wurde. Die Synonymie von A. petioli Htg. ergab eine Typenprüfung durch Pujade-Villar \\& Ros-Farré (2001). -Aus N-Italien (Checklist 1995: Nr. 35/01) bekannt. - Vorkommen in Südtirol-Trentino zu erwarten.\n\n--- Seite 125 ---\n[112] [Saphonecrus undulatus (Mayr 1872)]\n[= Synergus apertus Giraud 1911]\nIn Fauna Europaea (2007) nur für Österreich, Ungarn, Rumänien angeführt - in Checklist Ital. (1995: Nr. 36/15) als Synergus undulatus Mayr 1872 auch für N-Italien angegeben. Triest Umgeb. GrÄffe (1905: 56, Sapholytus undulatus Mayr): bewohnt die Galle von Aphelonyx cerricola. - Vorkommen im Trentino (Pomarolo u.a.) möglich und wahrscheinlich.\n\n## Genus: Synophrus Hartig 1843\n\n1 Art, diese auch in Italien (Checklist 1995); rezent auch im Trentino nachgewiesen.\nBildet als gallenerzeugende Art eine Ausnahme unter den sonst nur Inquilinen Synergini.\n\n## 113 Synophrus politus Hartig 1843\n\nDie interessante Art gehört taxonomisch zur Gruppe der Inquilinen (Tribus Synergini), bildet aber im Unterschied zu diesen eigene Gallen. Verursacht in der bisexuellen Generation an jüngeren Sprossen von Zerreiche (Quercus cerris) kugelige bis birnenförmige Zweig Gallen (Ø 6-8 mm bis 10-15 mm). Galle mit dem Zweig breit verwachsen; die dicke Wand mit einer äußeren, grünlichen Rindenschicht und einem breiteren, inneren, hellen harten Holzteil mit zentraler Kammer (eine Larve). Galle oft mit einigen kleinen Blättern oder verkümmerten Blattschöpfen; Reife im Herbst; nicht abfallend; Wespen erscheinen im Frühjahr. - [Buhr 1965: 974, Nr. 5561; p.979, Nr. 5579; Csóka 1997: 104; Melika et al. 2000: 289, Fig. 93]. - Verbreitung mediterran, teilw. südl. Mitteleuropa: Österreich, Tschechien, Ungarn, Balkan, Rumänien, Italien, Sizilien, Spanien, Portugal; fehlt in Frankreich, Deutschland.\nDie Gallwespe wurde von Kollar in der Umg. Wiens entdeckt (Locus typicus), und vom Entdecker unter dem Namen \"Cynips polita\" [= mit glänzendem Hinterleib] der Sammlung Hartigs übermittelt.\nHartig (1843: 411-412) beschrieb anhand dieser an Quercus cerris gesammelten Wespe und Galle seine neue Gattung Synophrus und benannte diese neue Art \"Synophrus politus Kllr. (in lit.)\".\nIn Checklist Ital. (1995: Nr. 37/01) aus N-Italien und Sizilien angegeben; Pellizzari 1988: 125; Bernardi\net al. 1997: 98-99, Fig. 2; ganz Italien. - In FVG vom Triestiner Karst diverse Meldungen durch GrÄFFE (1905: 50, Cecidothek FVG): „Galle von Synophrus ist an Quercus cerris nicht selten bei Triest, am Karste bei Repentabor, Bsovizza.\" Ibidem: Tomasi (1996: 86-87; 2006: 23, 75).\nAus Spanien ist nur eine Generation mit $9 \\varnothing$ an Quercus suber bekannt, die dort wesentlich größere, sehr hartholzige kugelige Gallen (bis 20 mm ) erzeugt [Nieves-Áldrey 2001: 202-205, 528; Figs. 55, 122 P, 137 E]. Eine solche große, offenbar von Quercus suber stammende Holzkugel-Galle (Ø 20 mm ) fand sich auch in den Lagerbeständen im historischen Pharmazie-Museum der „Brixner Stadtapotheke Peer\" (Abb. 113c): die runzelige rotbraune Rinden-Oberfläche der steinharten Galle (spez. Gew. 1,25) entsprach exakt einer Synophrus politus-Galle aus der „Allg. Encyklopedie der Forst- und Jagdwissenschaften\" (Henschel 1888: Bd.3, p. 128b: Fig. 14). Der aus Holz bestehende kugelige Gallenkörper war beim Eintrocknen der Galle bis zum inneren Kern hinein klaffend aufgespalten (Holztrockenriss, der dem Ausbohrgang der Gallwespe folgte), dieser Riss bildete sich auch bei mehrtägigem Aufweichen der Galle im Wasser nicht zurück. Die schwere Galle war mit einem festen holzigen Stiel (L 13 mm , D 3 mm ) am Zweig befestigt gewesen. Die ungewöhnliche Größe der spanischen Korkeichengallen, als auch die dort offenbar fehlenden Männchen, ließen eine Unterscheidung dieser Sonderform zu: * Proposed as: Synophrus politus var. subericolus\nDie typische Form von Synophrus politus wurde rezent auch im Trentino nachgewiesen: RoveretoDossi, Bosco della città ( 350 m ), 2 Zweig Gallen an junger Zerreiche, 25.09.2005 (leg. Irene Bellmann, Foto Heiko Bellmann \\& K. Hellrigl). Die größere, birnenförmige Zweiggalle ( $10 \\times 7 \\mathrm{~mm}$ ) im verholzten, harten Innenteil mit großer Gallenkammer und einer schlüpfreifen Puppe (Abb. 113a), aus der am 30.09.2005 eine Imago $\\varnothing$ schlüpfte, die im Okt. keine Anstalten machte sich aus der seitlich geöffneten Galle auszubohren [Foto: 10.11.05]; die Wespe überwintert offenbar in der Kammer (Abb. 113). Die kleinere, kugelige Zweiggalle ( $6 \\times 4 \\mathrm{~mm}$ ) enthielt im verholzten Inneren auch eine schwarze schlüpfreife Puppe, die am 06.10.05 eine Imago $\\varnothing$ ergab.\n\n--- Seite 126 ---\nFünf weitere kleine Gallen fanden sich auch bei Pomarolo-Servis (IT-04: 700 m ), am 14.10.2007 (leg. Hellrigl \\& Mörl), jeweils in den verbreiterten Zweigspitzen jüngeren Zerreichen (Foto); in einer am 20.10.2007 geöffneten holzigen Galle fand sich bereits die fertige Wespe ( $:^{\\text {® }}$ ). Im Folgejahr wurde hier am 07.09.2008 eine schöne große Galle ( $13 \\times 10 \\mathrm{~mm}$ ) an unteren Kronenästen einer größeren Zerreiche gesammelt (Abb. 113b); am selben Tag in Rovereto-Dossi an jungen Zerreichen weitere 4 kleine Gallen ( $6 \\times 5 ; 8 \\times 6 ; 8 \\times 7 ; 8 \\times 8 \\mathrm{~mm}$ ) und eine Zwillingsgalle ( $17 \\times 12 \\mathrm{~mm}$ ); alle Gallen (Abb. 113) waren von Trieben durchwachsen (leg. Hellrigl \\& Mörl). - Neu für Trentino und die Region.\n\n## Genus: Synergus Hartig 1840\n\nME rd. 30 Arten, davon 12 in Italien (Checklist 1995) gemeldet; 13 Arten in TN-Südtirol erfaßt. Die bisher nachgewiesenen und einige weitere noch zu vermutenden Inquilinen werden hier angeführt. - Antennen der Weibchen sind 14gliedrig, bei den Männchen 15gliedrig. [Artbestimmung mit den Tabellen von Dalla Torre \\& Kieffer (1910: 608-628) und Nieves-Áldrey (2001: 205-251)].\nHartig hatte (1843: 413-414) sechs Synergus-Arten neu beschrieben, davon gingen vier auf Entdeckungen von Kollar (Wien) zurück, der sie aus Gallen anderer Gallwespen gezogen und mitgeteilt hatte: S. socialis Kllr. (in lit.), S. flavipes Kllr. (in lit.), S. physoceras Kllr. (in lit.), S. melanopus m.: auch diese Wespe war eine Entdeckung von Kollar, der sie aus der Galle von \"Cynips lucida\" erzog.\nFür neue Synonymien der Inquilinen diente als Referenz: Pujade-Villar J, Melika G, Ros-Farré P, Acs Z \\& Csóka G., 2003: Cynipid inquiline wasps of Hungary, with taxonomic notes on the western palearctic fauna (Hymenoptera: Cynipidae, Cynipinae, Synergini). - Folia Entomol. Hungarica.\n[00] [Synergus albipes Htg. 1841 = S. nervosus Htg. 1840] see Nr.123: Synergus pallipes Hartig 1840\n\n114 Synergus apicalis Hartig 1841\nBekannt als Einmieter in Eichen-Gallen von A. fecundatrix (agam), A. quercusradicis (sex.), A. testaceipes (sex.), A. amblycerus, A. conglomeratus, A. lignicolus, Neuroterus albipes u.a. [Dalla Torre \\& Kieffer 1910: p.619: n.11]. - Weite\n\nVerbreitung : Britannien, Schweden, Deutschland, Schweiz, Österreich, Frankreich, Spanien. - War sicher auch in Italien und in unserer Region zu erwarten.\nRezente erste Fundnachweise aus TN: Pomarolo, wo ich Anf. Mai 2008 einige ( $3 \\mp@subsup{5}{}{\\prime}, 5$ ( $)$ ) winzige Exemplare (1.0-1.3-1.7 mm) aus „Aprilgallen\" von Neuroterus aprilinus [= petioliventris] erhielt.\nEbenso erhielt ich aus „Aprilgallen\" von Neustift am 06.05.08 ein $\\ddagger$ dieses winzigen Synergisten.\n\n115 Synergus clandestinus Weld 1952\nEntwickelt sich als Inquiline in verkümmerten Eicheln von Quercus, die von der Eichel-Gallwespe Andricus legitimus befallen sind. Die verkümmerten Eicheln ragen kaum über den Fruchtbecher heraus und weisen mehrere Zellen bzw. Ausfluglöcher der Inquilinen auf. - [vgl. Abb.:Nieves-Áldrey 2001: p. 222, 528; Fig. 125 D-E; Redfern et al. 2002: 418, Fig. 741]. - In Europa weit verbreitet Finnland, Niederlande, Frankreich, Deutschland, Ungarn, Polen, Spanien, Ukraine; in Britannien ist die Art gemein. - Sie fehlte bisher in Italien [nach Checklist Ital. (1995) und Fauna Europaea 2007], war aber für Italien und Südtirol-Trentino durchaus zu erwarten.\nIm Laufe der vorliegenden Untersuchung konnte die Art erstmals hier nachgewiesen werden: Aicha ( 740 m ), in Baumbestand von Traubeneichen, am 12.11.2007, eine verkümmerte Eichel im Fruchtbecher ( $\\varnothing 9 \\mathrm{~mm}$ ) mit 2 kleinen Ausfluglöchern von S. clandestinus (leg. Hellrigl \\& Förster De Luca). Die geöffnete Eichel zeigte 2 Zellen, jeweils mit Ausflugloch der Gallwespe (Abb. 115).\n\n116 Synergus crassicornis (Curtis 1838)\n$[=$ S. evanescens Mayr 1873]\nEinmieter in Eichen-Gallen von Andricus fecundatrix (agam), A. mayri, A. multiplicatus, A. kollari minor [= hispanicus], A. infectorius u.a. [Dalla Torre \\& Kieffer 1910: 617: n. 4: S. evanescens Mayr]. - Mittel und Süd-europa bis Spanien. In Checklist Ital. (1995: Nr. 36/03) für Sizilien angegeben; in Italien sicher auch am Festland zu erwarten sowie in der Region. - Erster Nachweis für Südtirol und die Region: Aicha-Spinges, 850 m , am 06.09.2006 an Zweigen von Q. petraea 3 Artischockengallen (1-2-3 cm) von Andricus\n\n--- Seite 127 ---\nfecundator gesammelt (leg./foto Hellrigl); daraus schlüpften im Frühjahr 2007 399 von Synergus crassicornis (leg./det. Hellrigl).\n[117] Synergus flavipes Hartig 1843\nHartig (1843: p. 413): leg. Kollar ex Galla „Cynips macroptera\" (wohl aus Österreich und Ungarn).\nBekannt als Einmieter in Eichen-Gallen von Pseudoneuroterus macropterus (Hrtg.) an Zerreichen in Niederösterreich (Wien) und Norditalien (Verona) [vgl. Dalla Torre \\& Kieffer 1910: p. 617: n. 5].\nIn Trentino (Pomarolo, Vallagarina) und Südtirol (Castelfeder) sicherlich in den dort häufig vorkommenden holzigen Zweiggallen von Pseudoneuroterus macropterus an Quercus cerris vorkommend.\n\n118 Synergus gallaepomiformis (Boyer de Fonscolombe 1832)\n[Syn.: *S. australis Hartig 1843, *S. basalis Hartig 1840, *S. palliceps Hartig 1841: *New synonyms in: (Pujade-Villar J, Melika G, Ros-Farré P, Acs Z \\& Csóka G: 2003). - [weitere Synonyme: Synergus bispinus Hartig 1841, S. erythrocerus Hartig 1841, S. facialis Hartig 1840, S. vulgaris Hartig 1840]. Häufige, in ganz Europa weit verbreitete Inquiline in Eichen-Gallen zahlreicher Gallwespen:\n$=$ S. australis Hartig 1843: 414, Nr. 37: aus den Triestiner Gallen „Cynips infectoria\" (v. Siebold leg.);\n$=$ S. basalis Hartig 1840 [vgl. Dalla Torre \\& Kieffer 1910: p. 626: n. 00], aus Andricus quercuscalicis.\n$=$ S. facialis Hartig 1840: In Checklist Italien (PagliAno 1995: Nr. 36/04) für Sizilien angegeben;\n$=$ S. palliceps Hartig 1841 [Dalla Torre \\& Kieffer 1910: p. 621: n.15]: als Einmieter in Eichen-Gallen von Andricus curvator (agam); Deutschland und Österreich.\n$=$ S. vulgaris Hartig 1840 [Dalla Torre \\& Kieffer 1910: p. 622/23: n. 18]. - Bekannt als Einmieter in Eichen-Gallen zahlreicher Gallwespen, mit weiter Verbreitung in Nord-, Mittel- und Südeuropa:\nA. callidoma, A. fecundatrix, A. inflator, A. solitarius, A. gallaeurnaeformis, A. quercuscalicis, A. caputmedusae, A. glutinosa, A. lignicolus, A. mitratus, A. gallaetinctoriae, A. infectorius, A. ostreus, A. glandulae, A. quercusradicis, Cynips qurcusfolii, C. disticha, Callirhytis glandium, Neuroterus lanuginosus, N.quercusbaccarum (sex.). Von Hartig\n(1840: 207) massenhaft aus Blatt-Beerengallen von N. quercusbaccarum (= Cynips interruptrix Hartig 1840) gezogen. - Auch von Cobelli (1903: 165) aus Trentino angeführt (Synergus vulgaris Hart.). - Triest Umgeb. Gräffe (1905: 55, S. vulgaris): in Gallen von A. lignicola, glutinosa-coronata und caputmedusae, sowie A. solitarius und urnaeformis.\nAls Synergus gallaepomiformis (Fonsc.) von Dalla Torre \\& Kieffer (1910: 621: n. 16) angeführt als Einmieter in Eichen-Gallen zahlreicher Gallwespen: Andricus paradoxus (= albopunctatus), A. quercusradicis, A. curvator, A. glandulae, A. fecundatrix, A. nudus, A. quercusramuli, A. seminationis, A. solitarius, A. glutinosus, A. coriarius, Cynips quercusfolii, Trigonaspis megaptera, Biorhiza pallida, Plagiotrochus gallaeramulorum, Neuroterus quercusbaccarum, N. tricolor etc. - Imago im Juni.\nIn Südtirol aus Zweiggallen von Biorhyza pallida gezogen (Tschötsch); ebenso aus A. glandulae (Neustift), sowie in A. paradoxus, 1 Ex. zusammen mit div. S. umbraculus, 26.05.2005 Montiggl (leg./ det. Hellrigl). Im Eisacktal, Neustift und Tschötsch, öfters in Eichen-Blattgallen von Cynips quercusfolii (agam), 2005/06/07 (leg./det. Hellrigl), sowie 2008 in Beerengallen von N.quercusbaccarum (sex.) jeweils an Traubeneiche (Quercus petraea). - Im Trentino bei Pomarolo-Savignano (IT-04) 4 Ex. aus Spindelgalle von Andricus amenti (= giraudianus) gezogen im Nov. 2007 (leg./det. Hellrigl).\n\n119 Synergus hayneanus (Ratzeburg 1833)\nBekannt als Einmieter in Eichen-Gallen von Andricus coronatus, A. lignicolus, A. mayri, A. stefanii, A. infectorius (= A. gallae-tinctoriae auct.) [vgl. Dalla Torre \\& Kieffer 1910: 616: n. 3]. - Niederösterr., Istrien, Italien, Spanien, Algerien. - Hartig 1843: 414, Nr. 37b: gemeinsam mit S. australis Htg. [= S. pallicornis Hartig 1841] aus den Triestiner Gallen „Cynips infectoria\" (v. Siebold leg.). - Syn.: $=$ rugulosus Hartig 1841; Syn.: = scaber Hartig 1856 [vgl. Dalla Torre \\& Kieffer 1910: 627: n. 00].\nWeit verbreitet in Süd- und Mittel-Europa; als Inquiline vornehmlich in verkümmerten holzigen Gallen von Andricus spp. [A. kollari, A. coriarius, A. quercustozae] an Quercus (Nieves-Aldrey 2001: 226, Fig. 64; Fig. 58f, ). - In Checklist Italiens (Pagliano 1995: 36/07) für N-Italien genannt.\n\n--- Seite 128 ---\nTriest Umgeb. GrÄfFe (1905: 54): schmarotzt in Gallen von Andricus lignicolus.\nNeu für die Region Trentino-Südtirol. Die Art wurde von mir am 28.06.-12.07.07 (20 2) gezogen aus verkümmerten vorjährigen Junggallen von $A$. quercustozae aus Rovereto; sie dürfte hier maßgeblich zum starken Befallsrückgang von A. quercustozae seit 2005 beigetragen haben, da bei einer Kontrolle am 03.10.2007 zahlreiche verkümmerte Junggallen derselben (Abb. 119), aber nur ganz vereinzelte Altgallen gefunden wurden. Sie kommt auch in Gallen von A. kollari in Castelfeder vor.\n[120] [Synergus incrassatus Hartig 1840]\nEinmieter in Eichen-Gallen der agamen Generation von Andricus quercuscorticis, A. quercusradicis, A. rhyzomae und A. testaceipes. Imago im April/Mai [vgl. Dalla Torre \\& Kieffer 1910: p. 619: n. 9].\nWeit verbreitet in Europa; in Deutschland aus A. kol-lari-Gallen bekannt (Pfützenreiter 1958); in Spanien kommt sie bei A. quercusradicis und A. quercuscorticis vor (Nieves-Aldray 2001: 580). - Fehlt in Checklist Italiens (Pagliano 1995: Nr. 36/00). - Vorkommen in der Region eher fraglich.\n*Syn.: = S. bipunctatus Hartig 1841 aus Schweden; = S. crassicornis Hartig 1843 aus Deutschland. [vgl. Dalla Torre \\& Kieffer 1910: p. 626: n. 00]. *New synonyms in (Pujade-Villar et al. 2003).\n\n121 Synergus pallicornis Hartig 1841\n[= pallidicornis D.T. 1893; = australis Hartig, 1843] Einmieter in Eichengallen von A. caputmedusae, A. coriarius, A. conglomeratus, A.glutinosus, A. hartigi, A. hungaricus, A. infectorius, A. kollari, A. lignicola, A. polycerus, A. quercuscalicis; Cynips agama, C. cornifex, C. disticha sowie agam. Gen. von: Cynips divisa, C. quercusfolii, C. quercus, C. longiventris und Trigonaspis synaspis. [Dalla Torre \\& Kieffer 1910: p. 624: n. 22]. - Verbreitung: Deutschland, Österreich, Schweiz, Frankreich, Italien, Spanien, Portugal, Britannien, Schweden.\nDie von Dalla Torre \\& Kieffer als fraglich angeführten Synonyme: (?) flavicornis Hartig 1840 und (?) nigripes Hartig 1840 sind nach Pujade-Villar et al. 2003 Synonyme von S. pallipes Hartig 1840.\nIn Checklist Ital. (1995: Nr. 36/10) für N-Italien genannt.- Nach Hartig (1843: 414, S. australis Htg.) erzog Prof. v. Siebold diese Wespe, gemeinschaftlich\nmit $\\boldsymbol{S}$. hayneana, aus den a.o. [vgl. p. 421] beschriebenen Triestiner Gallen von (C. infectoria) [=Andricus infectorius Htg.] und C. coriaria [=Andricus coriarius Htg.] etc. - Triest Umgeb. GrÄFFE (1905: 54): lebt in zahlreichen Eichengallen.\n\nNeu für Südtirol: Neustift, aus Gallen von Cynips quercusfolii gezogen, XI. 2004 (leg./det. Hellrigl). Ich erhielt diese Art ebenso aus A. coriarius-Gallen aus Castelfeder, sowie 2007 aus A. kollari-Gallen aus Pomarolo und 2006 in Brixen aus A. kollari von importierten Stieleichen aus der Toskana. Auch aus Callirhytis-Gallen in Quercus cerris-Eicheln zu erwarten (TN: Pomarolo: leg. Hellrigl, Okt. 2007) von denen sie in Deutschland angegeben wird [Pfützenreiter 1958: 124-125].\n\n122 Synergus pallidipennis Mayr 1873\nBekannt als Einmieter in Eichen-Gallen von Andricus conificus, A. coriarius, A. kollari und A. lignicolus [Dalla Torre \\& Kieffer 1910: p. 618: n. 7]. Verbreitung: Österreich, Ungarn, Spanien, Portugal. - Fehlte bisher in Italien, war jedoch in Trentino und Südtirol an Quercus sp. zu erwarten. Tatsächlich gelang ein Erstnachweis für Italien und die Region am 27.05.2008, bei Pomarolo (TN): $2 \\varnothing$ aus vorjährigen Eichengallen von Andricus quercustozae (leg. Hellrigl), gesammelt am 25.04.2008; in diesen Gallen vereinzelt, zusammen mit dem dort recht häufigen Synergus umbraculus. Bis Mitte Juni 2008 schlüpften noch weitere S. pallidipennis aus Gallen von Andricus quercustozae aus Pomarolo.\n\n123 Synergus pallipes Hartig 1840\n[Syn. = pallidipes Dalla Torre 1893,\n= erythrocerus Hartig 1841, = tristis Mayr 1873]\n[Syn.: *albipes Hartig 1841, *flavicornis Hartig 1840, *nervosus Hartig 1840, *nigripes Hartig 1840, *tscheki Mayr 1873, *variolosus Hartig 1841, *varius Hartig 1841]: *New synonyms in (Pujade-Villar, J, Melika, G, Ros-Farré, P, Acs, Z \\& Csoka, G 2003).\nIn ganz Europa: von Schweden bis Italien und Spanien, von Britannien bis Rumänien und Ukraine; [Verbreitung: Österr., Ungarn, Britann., Dänem., Frankreich, Deutschland, Polen, Italien, etc.] [123a] = *S. albipes Hartig 1841 [Dalla Torre \\& Kieffer 1910: 625: n. 24]. - Einmieter in Eichengallen von Andricus curvator (sex. Gen.) u.a.;\n\n--- Seite 129 ---\nweite Verbreitung in Europa (siehe bei Synonymen). Aus N-Italien (Checkl. 1995: Nr. 36/01) bekannt. - Im Frühjahr 2005 in Südtirol bei Montiggl (IT-02: 600 m ) aus Blasengallen von Andricus curvator gezogen (leg./det. Hellrigl). Neumeldung Südtirol. Auch Tschötscher Heide, am 28.06.2008, 5 Ex. (2 3 3) aus „, Kugelgallen\" von Neuroterus quercusbaccarum (?); ebenso Pomarolo 2 1 1. Juni 2008 aus „Beerengallen\" von Neuroterus sp. (leg./det. Hellrigl).\n[123b] = *S. nervosus Hartig 1840: 197 [Dalla Torre \\& Kieffer 1910: p.623: n. 19]. - Einmieter in Eichen-Gallen: Andricus quercusramuli, A. giraudianus, A. curvator, A. callidoma, A. inflator; A. glandulae, Trigonaspis megaptera (agam), Neuroterus quercusbaccarum (agam), Cynips quercusfolii (agam). - Verbreitung: Britannien, Schweden, Deutschland, Österreich u.a.. In Checklist Italiens (Pagliano 1995: 36/08) für N-Italien genannt. - Neu für Südtirol: Neustift, aus Gallen von Trigonaspis synaspis (Htg.) gezogen, XI. 2004 (leg./det. Hellrigl); ebenso 12 am 11.05.2006 aus Gallen von Cynips disticha; hier weiters auch aus Gallen von $N$. quercusbaccarum.\n$=$ S. pallipes Hartig 1840: $198=$ pallidipes Dalla Torre 1893 [Dalla Torre \\& Kieffer 1910: p.627]. Einmieter in Eichengallen [Linsengallen] von N. quercusbaccarum (agam). - Deutschland = S. tristis Mayr 1873 [Dalla Torre \\& Kieffer 1910: p. 623: n. 20]. - Einmieter in Eichengallen von: A. gallaeurnaeformis und A. ostreus. Imago im März und April. - Britannien, Österreich, Frankreich. Triest Umgeb. Gräffe (1905: 55, S. tristis Mayr): Andricus urnaeformis und Neuroterus ostreus. $=*$ S. tscheki Mayr 1873 [Dalla Torre \\& Kieffer 1910: p. 625: n. 23]. - Einmieter in Eichengallen von A. ostreus, A. polycerus, Cynips disticha, C. quercusfolii, Neuroterus saliens, N. quercusbaccarum, N. numismalis (agam) etc.\n$=*$ S. variolosus Hartig 1841 [Dalla Torre \\& Kieffer 1910: p. 627: n.00]. - Einmieter in Eichengallen von A. quercusramuli (agam). - Deutschland.\n$=*$ S. varius Hartig 1841 [Dalla Torre \\& Kieffer 1910: p. 624: n. 21]. - Einmieter in Eichengallen von Cynips agama und Trigonaspis megaptera (agam). - Österreich, Deutschland, Frankreich.\n\n124 Synergus physoceras Hartig, 1843\nVon Dalla Torre \\& Kieffer (1910: p. 625: n. 25) aus Bozen angeführt: Einmieter in den EichenGallen von Trigonaspis synaspis (agam) und auch Cynips quercusfolii (agam); Imago im Oktober. Niederösterreich (Wien), Tirol (Bozen). - Männchen mit starker Fühlerverdickung: 3.F.- Glied beim $\\delta$ sehr groß und stark aufgeblasen, nur in der proximalen Hälfte nach außen leicht ausgerandet [ 1.3 - 1.4 mm ]. - Hartig (1843: 413) erwähnt bei seiner Erstbeschreibung von \"Synergus physoceras Kollar (in lit.)\": Kollar erhielt die Wespe ( $\\delta^{\\text { }}$ ) aus kleinen runden Gallen an Blättern von Q. pubescens; [die Gallenbeschreibung entspricht Trigonaspis synaspis, vermutlich Wien]. Unklar ist, wieso Hartig bei der Beschreibung von einem „vierten stark verdickten Fühlerglied\" spricht [ $\\delta$ antennarum articulo quarto valde incrassato], denn die auffällige Verdickung betrifft das 3.F.Glied [1.Glied = Scapus, 2. Glied = Pedicellus, 3. Glied = erstes Geißelglied (Flagellomere 1)].\n\nIch erhielt diese kleine auffällige Art in Südtirol, bei Neustift ( 750 m ), aus Blattgallen von Trigonaspis synaspis (Htg.) an Stockausschlägen von Quercus petraea, XI-XII. 2004 in Anzahl; idem Herbst 2005 ab 30.10.-30.12.2005, sowie V.2006: insgesamt 240 Ex durch Zucht: vgl. Tab. 6 (leg./det. Hellrigl). - Sicherlich auch im Trentino zu erwarten und wohl weiter verbreitet als bekannt; in Fauna Europaea (2007): nur aus Österreich, Ungarn, Spanien gemeldet.\n[125] [Synergus radiatus Mayr 1873]\nBekannt als Einmieter in Eichen-Gallen zahlreicher Gallwespen: Andricus paradoxus (= albopunctatus), A. curvator, A. glandulae, A. quercusramuli (sex.), A. ostreus (agam), A. solitarius, A. coronatus, Neuroterus quercusbaccarum (sex.) [vgl. Dalla Torre \\& Kieffer 1910: p. 622: n. 17]. - Verbreitung: Britannien, Deutschland, Österreich, Ungarn, Frankreich, Italien und Sizilien [fehlt aber in Checklist. Ital.]. - Für die Region eventuell zu erwarten.\n\n126 Synergus reinhardi Mayr, 1873\nBekannt als Einmieter in Eichen-Gallen von A. caliciformis, A.quercuscalicis, A. caputmedusae, A. glutinosa, A. kollari, A. mitrata, A. quercustozae [vgl. Dalla Torre \\& Kieffer 1910: p. 616: n. 2].\n\n--- Seite 130 ---\nWeit verbreitet in Europa; als Inquiline vornehmlich in großen holzigen Gallen von Andricus spp. [besonders A. kollari] an Quercus spp. (Nieves-Aldrey 2001: 225, Fig. 59k). - In Checklist Italiens (PagliAno 1995: Nr. 36/12) für N-Italien genannt; in Triest Umgeb. GrÄFFE (1905: 54): schmarotzt in diversen Gallen; von Cobelli (1903: 165) aus Trentino angeführt (ohne Fundangabe).\nWurde 2006 von mir in kleinen verkümmerten Gallen von A. kollari festgestellt, an angepflanzten Stieleichen (aus der Toskana) am Eisackdamm in Brixen; ebenso auch an Flaumeichen bei Rovereto. Im Trentino wurden bei Roverto-Dossi am 03.10.2007 einige ungeschlüpfte Gallen von $A$. infectorius gesammelt, daraus schlüpften aus am 25./26.05.2008 5 今 von S. reinhardi. Ebendort war im Okt. 2007 auch ein Zweig mit fünf verkümmerten Junggallen von $A$. quercustozae gesammelt worden (Abb. 126); daraus schlüpften am 15.-22.07.08 sieben dunkle Weibchen $S$. reinhardi.\nDer Besatz mit Inquilinen beeinträchtigt bzw. schädigt meist die Entwicklung der Gallenerzeuger.\nWeiteres Zuchtmaterial aus Gallen von A. kollari und A. infectorius aus Castelfeder noch unbestimmt. In Südtirol-Trentino auch aus Gallen von A. caputmedusae zu erwarten [vgl. Dalla Torre \\& Kieffer 1910: p.616: n. 2]. Ebenso aus Callirhytis-Gallen in Quercus cerris-Eicheln (z.B. in TN: Pomarolo), von denen sie in Deutschland angegeben wird [PrÜTZENREITER 1958: 124-125].\n[127] [Synergus ruficornis Hartig 1840]\nEinmieter in Eichen-Gallen von Andricus inflator (agam) [= Cynips globuli], Neuroterus anthracinus (= A. ostreus), u.a. Imago im Februar [vgl. DalLa Torre \\& Kieffer 1910: 618: n. 8]. - Deutschl., Österreich, Ungarn, Britannien, Polen, Ukraine, Spanien etc. - Fehlt in Checkl. Italiens [1995]; sollte in der Region Trentino-Südtirol aber sicherlich zu erwarten sein, in Anbetracht der Häufigkeit der angegebenen Wirtsarten.\n\n128 Synergus thaumacerus (Dalman 1823)\nAn der auffälligen Fühlerverdickung der Männchen erkennbare Art; lebt als Inquiline bei Cynipiden [Dalla Torre \\& Kieffer 1910: p. 626: n. 26]. - 3. Glied beim $\\varnothing$ sehr groß und stark aufgeblasen, außen ausgehöhlt, so lang wie die 4 folgenden zusammen und 3 mal so dick wie dieselben. [ $\\varnothing$ 1.0-2.3 mm];\n\nBekannt als Einmieter in diversen Eichen-Gallen [Quercus sp. und Q.cerris] von: A.cydoniae, A.gemmeus Gir. (= A.singulus Mayr), A.gallaeurnaeformis ( $=$ A. sufflator Mayr), Aphelonyx cerricola, Dryocosmus nervosus, Neuroterus quercusbaccarum (sex.), N.tricolor, N. glandiformis, Trigonaspis megaptera (sex. \\& agam). - Weite Verbreitung in Europa: Schweden, Dänemark, Niederlande, Polen, Deutschl., Österr., Ungarn, Ukraine, Rumän., Bulgar., Griechenl., Italien, Frankr., Spanien, Portugal.\nIn Checklist Italiens (Pagliano 1995: Nr. 36/13) ohne Fundangabe. - Neu für Südtirol: bei Neustift (700 m), XI. 2004, vereinzelt aus Erbsengallen von Trigonaspis synaspis an Blättern von Quercus petraea gezogen (leg. Hellrigl). - Im Herbst 2007/08 erstmals auch aus Trentino bei Pomarolo-Servis nachgewiesen: aus Gallen von Aphelonyx cerricola an Zerreiche, schlüpften bei Indoor-Aufzucht in Brixen im Jan./Febr. 2008: $2 \\varnothing+1 \\vee$ Synergus thaumacerus (leg./det. Hellrigl) (Foto 128); desgleichen aus neuen Aphelonyx-Gallen vom 07.09.2008 (leg. Hellrigl \\& Mörl), schlüpften am 15.11.2008 wiederum $2 \\varnothing+7 \\vee$ Synergus thaumacerus (Foto 128b).\n[129] [Synergus tibialis Hartig 1840]\n[Syn.: = erythrostomus Hartig 1841, = immarginatus Hartig 1841, = rotundiventris Mayr 1872]:\nNew synonym in: Pujade-Villar, J, Melika, G, RosFarré, P, Acs, Z \\& Csóka, G 2003.\nDalla Torre \\& Kieffer 1910: p. 619: n.10: Synergus rotundiventris Mayr 1873. - Bekannt als Einmieter in den Gallen von Pseudoneuroterus macropterus (Hrtg.) an Q. cerris in Österreich, sowie bei Andricus quercusradicis (sex.) an Quercus pyrenaica in Spanien (Nieves-Aldrey 2001: 239). Verbreitung: Österr., Ungarn, Schweden, Britann., Niederlande, Ukraine, Spanien. - Fehlt bisher in Deutschland und Italien; ist aber im Trentino (Pomarolo) und Südtirol (Castelfeder) sehr wahrscheinlich an Quercus cerris zu erwarten.\n\n130 Synergus umbraculus (Olivier, 1791)\n(= S. orientalis Hartig, 1841; S. socialis Htg. 1843; S. melanopus Htg. 1843)\n\nEinmieter in Eichen-Gallen von A. fecundatrix, A. lucidus, A. mayri, A. amblycerus, A. quercuscalicis,\n\n--- Seite 131 ---\nA. caliciformis, A. caputmedusae, A. conglomeratus, A. coriarius, A. coronatus, A.glutinosus, A. hungaricus, A. kollari, A. lignicolus, A. polycerus, A. quercustozae, Trigonaspis mendesi. [Dalla TorRe \\& Kieffer 1910: p. 615: n. 1]; ganz Mittel- und S-Europa. - S. melanopus Htg. 1843: p. 414, Nr. 38: leg. Kollar, aus Gallen von: A. lucidus. - S. socialis Htg. 1843: p.413, Nr. 33: leg. Kollar, aus Gallen von: A. calicis, A. kollari, A. conificus.\nIn Checklist Italiens (Pagliano 1995: Nr. 36/14 und 36/09): N-Italien und Sizilien. GrAFFE (1905: 54, S. melanopus Htg.): Triest Umg. - In Spanien eine der häufigsten Inquilinen (Nieves-Aldrey 2001:231, 529). - Neu für Südtirol: Neustift (700 m), XI.2004, aus Gallen von Trigonaspis synaspis (Htg.); auch bei Montiggl, am 26.05.2005 aus Gallen von A. paradoxus an Q. petraea diverse S. umbraculus, (leg. Hellrigl). 2005/2008 aus Eichengallen in Castelfeder und Rovereto [A. coriarius, A. lucidus] (leg./ det. Hellrigl). - Neu für Trentino:\nIn Pomarolo-Servis (TN) schlüpfte S. umbraculus im Mai und Juli 2008 in Anzahl (ca. 100 Ex. in 2 Schlüpfwellen) aus Holzkugelgallen von Andricus quercustozae (leg./det. Hellrigl); die Wirts-Gallen waren teilweise schon im Okt. 2007 gesammelt worden, zum Teil erst im Mai-Juni 2008, nachdem alle A. quercustozae bereits geschlüpft waren. Am 25.09.2008 schlüpfte hier noch $1 \\delta$ aus einer prächtigen Galle von Andricus conificus. - Aus Deutschland (Favoritenpark/Stuttgart) wird S. umbraculus neben S. pallicornis und S. reinhardi auch als Inquiline von Callirhytis-Gallen in Q. cerrisEicheln angegeben [PfÜTZENREITER 1958: 124-125]; unter diesen Umständen vielleicht auch in den im Okt. 2007 häufigen (überliegenden) CallirhytisGallen in Q.cerris-Eicheln in Pomarolo zu erwarten.\n[131] Synergus variabilis Mayr 1873\nBekannt als Einmieter in Zerreichen-Gallen von Andricus grossulariae, Aphelonyx cerricola, Chilaspis nitida, Dryocosmus cerriphilus, Neuroterus lanuginosus, Pseudoneuroterus macropterus, Synophrus politus und der Gallmücke Dryomyia circinnans, stets auf Quercus cerris. - In Österreich und Ungarn, Bulgarien, Rumänien, Italien mit Sizilien [vgl. Dalla Torre \\& Kieffer 1910: p. 620: n. 12]. - Im Trentino (Rovereto, Pomarolo) sicher\nan Quercus cerris zu erwarten, vielleicht auch in Südtirol (Castelfeder).\n[00] [Synergus spp.]\nBei einigen weiteren Synergus-Arten, als Einmieter in Eichen-Gallen, ist deren Verbreitung in Europa noch zu wenig bekannt. Sie kommen für unsere Region vorerst kaum in Betracht, zumal einigen davon wohl als spezies inquirendae zu betrachten sein dürften:\nSynergus exaratus Hartig 1841: [Dalla Torre \\& Kieffer 1910: 627]. - Nur aus Deutschland bekannt;\nSynergus gallaepyriformis (Olivier 1791): [Dalla Torre \\& Kieffer 1910: 627]: Nur aus Südfrankreich bekannt (D'Anthoine) als Einmieter in EichenGallen (Q. pubescens) von Andr. callidoma. - [vielleicht identisch mit Synergus gallaepomiformis (Fonscolombe 1832) ?].\nSynergus gallaeviscosae (Fairmaire 1882): [Dalla Torre \\& Kieffer 1910: 627]. - Nur aus Frankreich bekannt als Einmieter in Eichen-Gallen (Q. pubescens) von Andricus mayri. - Nur aus Deutschland gemeldet ist: Synergus nigricornis Hartig 1841 Possible synonym of S. radiatus Mayr 1873.\nSynergus ilicinus Barbot. 1972 und Synergus plagiotrochi Nieves-Aldrey \\& Pujade-Villar 1987) sind spezifische Inquilinen von Plagiotrochus nervosus an Steineiche (Quercus ilex), die bisher nur aus Frankreich und Spanien bekannt sind.\n\n## C. Parasitische Gallwespen: Zoophage Cynipiden Nr. 132-150\n\n## Fam. Ibaliidae\n\nDie Gattung Ibalia Latreille 1802 umfaßt die größten Vertreter ( $10-15 \\mathrm{~mm}$ ) der Cynipoidea und ist in Europa mit 2 Arten vertreten, welche Larven von Holzwespen parasitieren.\n\n132 Ibalia leucospoides (Hochenwarth 1785)\n$[=$ Ichneumon cultellator Fabricius 1793]\n[= Ibalia arcuata Dalla Torre \\& Kieffer 1910]\nGroße Art (10-15 mm), Abdomen messerklingenartig komprimiert [vgl. früherer Name \"cultellator\":\n\n--- Seite 132 ---\nlat. cultellus $=$ Messerchen] (Abb. 132), Fühler des ㅇ 13gliedrig, beim $ơ 15$ gliedrig mit gekrümmtem 3. Fühlerglied. - Ibalia leucospoides wurde in Südtirol im Frühlingstal bei Kaltern, 10.08.-15.09.1983, von mir in Anzahl ( $10 \\delta+16$ ㅇ) aus toter Tanne mit starkem Befall von Holzwespen (Sirex cyaneus) gezogen (Hellrigl 1984, 1996, 1997: p. 64, Abb. 5: Fig. 4-5). Einzelne Exemplare auch bei Buchholz (13.07.1985, Hellrigl) und im Eisacktal bei Grasstein (07.08.1966, A. v. Peez). - Aus Trentino wurde die Art von Madl (1992) genannt (pers. Mitt. G. Pagliano, 2004). - Auch in Osttirol wurde diese Art von Dr. A. Kofler (Lienz) 17.06.- 26.08.1988 bei Gaimberg/Nußdorf in Anzahl ( $42 \\delta, 51$ ㅇ) aus Brennholz im Keller gezogen; weitere Einzelfunde aus Dölsach (1974: $1 \\delta$ in Fichte bei Paururus juvencus) und Lengberg/Nikolsdorf (1985 bis 1998: 5 ㅇ an Fichten-Rundholz); Einzelfunde auch aus dem angrenzenden Kärnten, bei Unterpirkach/Oberdrauburg, 16.07.2008 (leg. A. Kofler: pers. Mitt.).\n[132 B] Ibalia rufipes Cresson 1879 [= rufipes drewseni Borries 1891], eine zweite Art mit roten Hinterschenkeln, die aus Nord-Italien gemeldet ist (Checklist Ital. 1995: 01/02), wurde aus Südtirol noch nicht bekannt. Nachdem diese Art aber auch im Nordtiroler Pitztal, in den Ötztaler Alpen nachgewiesen wurde, ist mit ihrem Vorkommen in angrenzenden Gebieten Südtirols (z.B. Schnalstal, Vinschgau) unbedingt zu rechnen. In coll. Dr.A. Kofler (Lienz) befinden sich $2 \\delta+1$ ㅇ aus „Nordtirol, Ratter\"[als IbaliadrewseniBorries], welche J. Ratter (Innsbruck) im Pitztal bei Jerzens, am 09.6.1929 gesammelt hatte (pers. Mitt. Dr.A. Kofler). Es ist bemerkenswert, dass in „Fauna europaea\" (2007) beide Arten aus Österreich nicht genannt werden, wohl aber aus der Schweiz und aus Deutschland. Abb. 132: Ibalia leucospoides - Kaltern, ex Abies, Sept. 1983 (Hellr.)\n\nFam. Figitidae (inkl. Eucoilidae auct.)\nVon Figitidae i.w.S. sind weltweit ca. 1400 Arten beschrieben. Als parasitische Gallwespen leben sie zoophag und bilden keine Gallen. - Die Fauna Mitteleuropas dürfte etwa 100-150 Arten umfassen\n(in 5 Unterfamilien); aus Spanien sind 150 Arten bekannt (Nieves-ALdreY 2001). Die für Südeuropa zu erwartende höhere Artenzahl wird in Italien nicht annähernd erreicht, denn in der Checklist Italiens (1995) finden sich nur 24 Arten; dies ist ein Indikator für unzureichenden Erforschungsgrad. Aus der Region Südtirol-Trentino sind bisher wenige Arten erfaßbar, darunter einige zweifelhafte Angaben.\n\n## U.F. Anacharitinae\n\nDie Anacharitinae schmarotzen bei Netzflüglern (Neuropteren); Hauptwirte sind HemerobiidenLarven („Blattlauslöwen\"), doch möglicherweise werden auch Chrysopidae („Florfliegen\") befallen. Sie sind in Europa mit rund 20 Arten vertreten.\n[133] [Anacharis eucharioides (Dalman, 1818)]\n[Anacharis Dalman 1823 = Megapelmus Hartig 1840];\nIn Checklist Ital. (1995) aus N-Italien angegeben; könnte auch in Südtirol zu erwarten sein. In Osttirol aus Lienz, 16.02.2002, nachgewiesen (= Anacharis cf. typicus Walker) (leg. Kofler, det. Hellrigl). Eine verwandte Art, Anacharis (Aegilips) nitidula Dalm. 1823, wurde im Kärntner Gailtal bei Passau gefunden, 27.07.1993 (leg. A. Kofler, det. Hellrigl).\n\n## U.F. Aspicerinae\n\nDie Aspicerinae sind gekennzeichnet durch dornartig verlängertes Scutellum. Sie scheinen bevorzugt in Larven und Puparien von blattlausvertilgenden (aphidophagen) Syrphiden zu schmarotzen. Als häufigste Art in Mitteleuropa wird die aus div. Schwebfliegen gezogene Callaspidia defonscolombei Dahlbom 1842 angegeben.\n\n134 Aspicera scutellata (Villers, 1789)\nNach Fauna Europaea (2005) aus Südeuropa (Croatien, Italien, Frankr., Spanien) und N-Europa (Norwegen, Schweden) bekannt, fraglich in Deutschland und Österreich. - In Checklist Italiens (Pagliano 1995: Nr. 04/01) für N-Italien genannt. - Neu für Südtirol: Brixen: Kassianstraße, 22.VIII.1965, auf Fichte, $1 \\delta$ (leg. Peez; det. et coll. Hellrigl).\n\n--- Seite 133 ---\n## U.F. Eucoilinae\n\nBilden die umfangreichste Unterfamilie der parasitischen Cynipoidea und schmarotzen endoparasitisch bei Dipterenlarven, schlüpfen aber erst aus den Puparien der Wirte. Von den anderen Cynipoidea sind sie leicht durch den eigenartigen, napfförmigen Aufsatz am Scutellum zu unterscheiden.\nSie schmarotzen bei saprophagen Aas-, Dung- oder Pilze-bewohnenden Dipteren (Sarcophagidae, Drosophilidae, Sphaeroceridae, Sepsidae, Mycetophilidae etc.), ursprünglichere Arten (Kleidotoma spp.) bei stängel- oder wurzelbohrenden bzw. minierenden Wirten (Chloropidae, Agromyzidae, Anthomyidae). In der mitteleuropäischen Fauna dominieren neben Vertretern der Gattung Cothonaspis vor allem Kleidotoma-, Trybliographa- und LeptopilinaArten, über die aber aus Italien (Checklist 1995) und Südtirol noch kaum etwas bekannt ist. - Einige fragliche „Österreich\"-Angaben in Fauna Europaea (2007) könnten sich vermutlich auf alte Meldungen von Cobelli (1903: 165) aus Trentino (ohne nähere Fundangabe) beziehen, welches damals (bis 1919) noch zu Österreich gehörte, oder aber auch Fehldeterminationen sein.\n\n135 Eucoila floralis Dahlbom, 1846\nNach Fauna Europaea (Database: 2005) aus Schweden und ? Österreich bekannt. - Fehlt in Checklist Ital. (1995). - Eine alte Meldung von Cobelli (1903: 165) aus Trentino (ohne Fundangabe) könnte sich auf die fragliche „Österreich\"-Angabe beziehen oder eine Fehldetermination sein.\n\n136 Eucoila maculata (Hartig, 1840)\n[= Cothonaspis maculatus Hartig 1840: 201]\nIn Checklist Italiens (Pagliano 1995: 02/05) für N-Italien genannt; von Cobelli (1903) aus Trentino angeführt (ohne Fundangabe). - Nach Fauna Europaea (l.c.) aus Britann., Germ., Skandin. bekannt, aber fraglich für „Österr.\" [?], Frankreich, Italien, Tschechien, Solvakei.\n\n137 Rhoptromeris heptoma (Hartig 1840: 201)\n[= Cothonaspis eucera Hartig 1841]\nWichtiger Antagonist der an Getreide schädlichen Halmfliege Oscinella frit (Diptera: Chloropidae). Verbreitete europäische Art; fehlt in der Checklist\n\nItal. (Pagliano 1995). - Nach Fauna Europaea (l.c.) in ganz Mittel- und Nordeuropa, auch Schweiz und Italien. - Neu für Südtirol: Brixen, Eisackdamm, 23.08.1964, auf weißer Dolde, $1 \\varnothing$, 1 (leg. Peez; coll. Hellrigl).\n\n138 Trybliographa glottiana (Cameron 1883)\n[= Eucoila agaricorum Kieffer 1902]\nFindet sich im Herbst in Agaricus-Arten (Dalla Torre \\& Kieffer 1910: 140). - Fehlt in Checklist Ital. (1995). - Nach Fauna Europaea (l.c.) in Britannien, Frankreich, Schweden. - Neu für Südtirol: Brixen, St. Leonhard (1000m), 20.09.1992 (leg. Hellrigl), in Gemüsegarten div. $9 \\varnothing$ aus Champignons gezogen, wo sie an Pilzmückenlarven (Diptera: Mycetophilidae) parasitierten.\n\n139 Trybliographa longicornis (Hartig, 1840)\n[= Cothonaspis longicornis Htg. 1840: 201]\nNach Fauna Europaea (l.c.) in Österr., Deutschl., Frankr., Dänemark, Schweden. - Fehlt in Checklist Italiens (1995). - Neu für Südtirol: Brixen. Tschötscher Heide, 17.09.1967, auf Wiese gestreift, $1 \\varnothing$ (leg. Peez; det. et coll. Hellrigl), sowie fraglich: Brixen, Peitlerkofel, Halsl 1800 m , 05.VII.1959, $1 \\varnothing$.\n\n140 Trybliographa melanoptera (Hartig, 1843)\n[= Cothonaspis melanopterus Hartig 1843: 415]\nVon Dalla Torre \\& Kieffer (1910: 191) [als Hypolethria melanoptera (Htg.)] aus den österr. Alpen, Steiermark und Tirol, angeführt. - Fehlt in Checklist Ital. (1995). - Nach Fauna Europaea (l.c.) in Österr., Italien, Schweden; fraglich in Schweiz und Frankreich.\n\n141 Trybliographa nigripes (Giraud 1860)\n[= Adieris reclusa Förster 1869)\nNach Fauna Europaea (2007) in Österreich, Deutschland bekannt. - Fehlt in Checklist Italiens (1995). In Südtirol: Brixen, Gärtnerei Ebner, 19.03.1961, in altem Taubenmist, 2 (leg. Peez; coll. Hellrigl).\n\n142 Trybliographa rapae (Westwood, 1835)\n[Syn.: Eucoila insignis Giraud, 1860]\nDiese Art ist bekannt als Parasitoid der Kleinen Kohlfliege Delia brassica (Anthomyiidae) und daher von wirtschaftlicher Bedeutung. - In Checklist\n\n--- Seite 134 ---\nItal. (Pagliano 1995: Nr. 02/04) für N-Italien genannt (als Eucoila insignis Gir.). - Von Cobelli (1903: 165) aus Trentino angeführt (als Eucolia insignis, ohne Fundangabe); kommt sicherlich auch in Südtirol vor.\n\n143 Trybliographa subnebulosa (Giraud, 1860)\n[= Eucoila subnebulosa Giraud]\nNach Fauna Europaea (l.c.) nur aus Österreich und ? Tschechien bekannt, nicht in Italien. - In Checklist Italiens (Pagliano 1995: Nr. 02/06, als Eucoila) für N-Italien genannt; von Cobelli (1903) aus Trentino angeführt (ohne Fundangabe); damals (vor 1919) noch österreich. Territorium betreffend.\n\n144 Trybliographa trichopsila (Hartig, 1841)\n[= Cothonaspis trichopsila Hartig 1841: 356]\nNach Fauna Europaea (l.c.) aus Britann., Ungarn, Schweden bekannt, fraglich in Frankr., Deutschland, Österreich. - In Checklist Italiens (1995: Nr. 02/07) für N-Italien genannt (als Eucoila trichospila); von Cobelli (1903) aus Trentino angeführt (als Eucolia trichopsila Hart., ohne Fundangabe).\n\n## U.F. Figitinae\n\nDie Arten dieser relativ artenreichen Unterfamilie schmarotzen als solitäre Endoparasiten in den Larven höherer, meist saprophager Fliegen (Sarcophagidae, Calliphoridae, Muscidae, Anthomyiidae). Es werden aber auch phytophage bzw. räuberische Dipterenlarven (z.B. Syrphidae) befallen.\n\n145 Figites coriaceus Dahlbom, 1846\nNach Fauna Europaea (l.c.) nur in Schweden und ? Österr. - Fehlt in Checklist Ital. (1995); eine Meldung von Cobelli (1903: 165) aus Trentino (ohne Fundangabe) [damals österr. Territorium!]; wahrscheinlich bezieht sich die fragliche \"? Österr.\"Angabe auf diese Trentiner Fundmeldung.\n\n146 [Figites nitens (Hartig, 1843: 418)\n$=$ Psilogaster]\nNach Fauna Europaea (2007) „status uncertain\"; gemeldet aus Deutschland, ? Finnland, ? Schweden. In Checklist Italiens (Pagliano 1995: 09/02) für N-Italien genannt. Nach Pagliano (i.litt. 2004) von\n\nCobelli(1903) aus Trentino angeführt, doch scheint bei Cobelli (1903: 165) nur F. coriaceus auf.\n\n147 Figites scutellaris (Rossi, 1794)\n[= Cothonaspis scutellaris Htg. 1840: 200]\nNach Fauna Europaea (l.c.) in Österreich, Deutschland, Frankreich, Italien, Polen. - In Checklist Italiens (1995: Nr. 09/03) für N-Italien genannt; von Cobelli (1903: 165) aus Trentino angeführt (als F. scutellaris Latr., ohne Fundangabe); wohl auch in Südtirol zu erwarten.\n\n148 Amphitectus areolatus (Hartig 1840)\n[= Sarothrus areolatus Hartig 1840: 203]\nNach Fauna Europaea (l.c.) in Deutschland, Österreich, Italien, Britannien, Norwegen, Schweden. Fehlt in Checklist Ital. (1995). - Neu für Südtirol: Brixen: Kassianstraße, 5.IX.1965, auf Goldrute, 1. (leg. Peez; det./coll. Hellrigl). In Osttirol bei Lienz/ Nörsach, VII. 1990 (leg. A. Kofler, vid. Hellrigl).\n\n149 [Melanips opacus (Hartig 1840)]\n[= Scytodes opacus Hartig 1840: 202]\nWeit verbreitet, u.a. in Deutschland, Österreich und Italien. - In Checklist Ital. (1995) nur aus Sizilien angeführt, doch auch im Norden und in Südtirol zu erwarten. - In Osttirol mehrfach in Lienz Umgeb.: bei Lavant VI.1964, Gwabl/Ainet VI.1983, Peischlach VII. 1987 (leg. A. Kofler, vid. Hellrigl).\n\n## U.F. Charipinae (= Alloxystinae)\n\nDie Charipinae sind eine relativ artenreiche Unterfamilie, die als Primärparasitoiden von Blattfföhen (Psyllidae) leben, überwiegend jedoch Hyperparasitoiden von Blattläusen (Aphiden) und Cocciden sind. Ihrer Lebensweise entsprechend klein ist auch ihre Körpergröße, meist nur 1-1.5 mm. - Von Dalla Torre \\& Kieffer (1910: 280-288) werden aus Europa zahlreiche Charips-Arten (in Aphiden) angeführt; in Checklist Ital. (1995) werden nur 3 Arten genannt:\n\n150 [Alloxysta aphidicida (Rondani 1848)]\nNach Fauna Europaea (2007) „status uncertain\"; nur aus Italien gemeldet. - In Checklist Ital. (1995: Nr. 12/01, als Dilyta aphidicida) ohne Fundort-\n\n--- Seite 135 ---\nangabe - ebenso wie Alloxysta musti (Rondani 1875).\n\nParasitiert in Blattläusen (Aphiden) und dürfte nebst weiteren Alloxysta-Arten [= Charips auct., Dilyta Förster 1869] in Südtirol-Trentino sicherlich zu erwarten sein.\n\n151 [Alloxysta victrix (Westwood 1833)]\nFehlt nach Fauna Europaea in Italien; ist aber in Checklist (1995: Nr. 11/01) aus N-Italien gemeldet. - Aus dieser artenreichen Gattung sind aus Europa\nca. 75 Arten bekannt (Fauna Europaea 2007); in der UK-Checklist werden für Britannien 8 Arten angeführt, für Schweden (Catalogus cynepoideorum sueciae) werden sogar 24 Arten genannt. - Diese und weitere Alloxysta-Arten sind wohl auch aus Südtirol-Trentino zu erwarten. - In Osttirol wurde Charips victrix Westw., in Lienz Umg. bei Nörsach, 08.05.1996 gefunden (leg. Dr. A. Kofler), sowie eine weitere verwandte Charipinae, Phaenoglyphis xanthochroa Förster 1869, im Defereggental bei Dölach, 28.05.1989 (leg.A. Kofler, vid. Hellrigl).\n\n# Danksagung \n\nDas Studium und das Sammeln von Pflanzengallen ist eine komplexe Angelegenheit, die nur schwer für einen einzelnen allein zu bewältigen ist. So ist es mir angenehme Pflicht den vielen Freunden und Mitarbeitern zu danken, die beim Zustandekommen dieser Arbeit behilflich waren, angefangen von Literaturbeschaffung, über gemeinsame Sammelexkursionen bis hin zur Übermittlung von gesammelten Gallen und eigener Gallenbilder. - Für Beschaffung von Fachliteratur habe ich zu danken: Herrn Erich Bauer (Keltern), Heiko Bellmann (Ulm), Andreas Taeger (ZALF Müncheberg), der Bibliothek des Zool. Institutes der Univ. Innsbruck (Prof. Konrad Thaler und Prof. Wolfgang Schedl), Joachim Ziegler (Museum für Naturkunde, Humboldt-Universität Berlin), den Gallwespen-Spezialisten José Luis Nieves-Aldrey (Madrid), Juli Pujade-Villar (Barcelona) und György Csóka (Budapest) sowie dem Hymenopterologen und Ehrenkustos am Museo civ. Storia Nat. Torino, Guido Pagliano (Verfasser der Hymenopetern-Checklist Ital. 1995).\n\nEine große Hilfe bei gemeinsamen Sammelexkursionen waren die Trentiner Kollegen Paolo Ambrosi und Cristina Salvadori (Istituto Agrario S. Michele), die Südtiroler Förster Dr. Stefano Minerbi (Landesforstinspektorat Bozen), Alberto Fostini und Walter Cian (Forststation Kaltern), Pasquale De Luca (Forststation Brixen) sowie meine engeren Mitarbeiter Georg v. Mörl und Klaus Schanung (Brixen).\nEin langjähriger Mitstreiter bei vielen gemeinsamen Exkursionen und Lieferant von fachlichen Informationen und exzellenten Dokumentationsbildern von Gallen war schließlich Dr. Heiko Bellmann (Univ. Ulm), der mir auch freundlicherweise eine Reihe von Gallenbildern zum Abdruck überließ. Für die Druckerlaubnis einiger weiterer Bilder habe ich schließlich zu danken Herrn Dr. Hans-Jürgen Buhr (Fotogallerie Pflanzengallen, Berlin) sowie Dr. György Csóka (Forest research Institute, Budapest) und Dr. Graham Stone (Edinburgh University).\n\n--- Seite 136 ---\n# Zusammenfassung \n\n## Faunistik der Gallwespen (Hymenoptera: Cynipoidea) von Südtirol-Trentino (Nord-Italien)\n\nEin Überblick über Vorkommen von Gallwespen in Südtirol und Trentino wird gegeben. Schwerpunkt sind die typischen Gallen der einzelnen Arten, die beschrieben und abgebildet werden. Insgesamt werden 151 Arten behandelt, davon sind 103 Arten aus der Region nachgewiesen: 73 aus Südtirol sowie 76 aus Trentino (Tab. 2); ergänzend werden zusätzlich rd. 50 Arten mit angeführt zur Beurteilung möglicher weiterer zu erwartender Vorkommen.\nDas zugrunde liegende Material stützt sich zunächst auf Auswertung und Neubearbeitung älterer Fachliteratur, wie die Fundangaben von Dalla Torre (1892-1896) für 16 Arten in den „Cecidien Tirols\", sowie von Bezzi (1899: Cecidiologia Trentina) und Cobelli (1903: Imenotteri del Trentino) für das Gebiet von Trentino mit 24 Arten (Tab. 1). Hinzu kamen spätere Angaben für 12 Arten aus Südtirol von Hellrigl (1984, 1996, 1997): Ibalia leucospoides, Andricus caputmedusae, A. fecundator, A. inflator, A. kollari, A. quercustozae, Biorhiza pallida, Cynips quercusfolii, Diplolepis rosae, Isocolus scabiosae, Neuroterus numismalis, N. quercusbaccarum.\nIn den letzten 5 Jahren, 2004-2008, folgten schließlich umfassende gezielte Untersuchungen des Verfassers über Cynipiden-Gallen in Südtirol und Trentino, die zahlreiche Neufunde erbrachten und die erfaßte Artenzahl für die Region von bisher 41 spp. auf nunmehr 103 Arten anhoben, was mehr als eine Verdoppelung darstellt. Außerdem wurden an die 4500 Gallen vermessen und die Größenverhältnisse grafisch dargestellt (Grafik 1-9). In die Erhebungen wesentlich mit einbezogen wurden die forstlichen Versuchsflächen eines internationalen \"Integrated MonitoringProgramms\" mit den regionalen Standorten eines „Quercetum pubescentis\" in Montiggl (IT-02) bei Kaltern (BZ) und in Pomarolo (IT-04) bei Rovereto (TN).\nVon zehn bisher nur bei Dalla Torre (1892-96) aufscheinenden Arten: Andricus ostreus, Andricus solitarius, Cynips agama, Cynips cornifex, Cynips quercus, Diplolepis mayri, Diplolepis spinosissimae, Liposthenes glechomae, Trigonaspis synaspis, Synergus physoceras, konnten alle rezent bestätigt werden.\n48 Arten werden neu aus Südtirol angeführt: Andricus aries, A. burgundus, A. callidoma, A. conglomeratus, A. coriarius, A. corruptrix, A. curvator, A. glandulae, (A.globuli), A. infectorius, A. legitimus, A. lignicolus, A. paradoxus, A. polycerus, A. pseudoinflator, A. quercuscalicis, A. quercusradicis, A. quercusramuli, Aulacidea hieracii, Aylax minor, Aylax papaveris, Ceroptres claviconis, Cynips disticha, Diastrophus rubi, Diplolepis eglanteriae, Dryocosmus kuriphilus, Neuroterus albipes, N. aprilinus, N. tricolor, Pseudoneuroterus macropterus, Phanacis hypochoeridis, Periclistus brandtii, Synergus apicalis, S. clandestinus, S. crassicornis, S. gallaepomiformis, S. hayneanus, S. pallicornis, S. pallipes (= albipes, nervosus), S. reinhardi, S. thaumacerus, S. umbraculus, Xestophanes potentillae sowie sechs parasitische Figitidae.\n52 Arten sind neu für Trentino: Andricus amblycerus, A. amenti (= giraudianus), A. caliciformis, A. caputmedusae, A. conglomeratus, A. conificus, A. coriarius, A. corruptrix, A. cydoniae, A. fecundator, A. galeatus, A. gallaeurnaeformis, A. gemmeus, A. grossulariae (=A. mayri + panteli), A. infectorius, A. inflator (= globuli), A. lignicolus, A. lucidus (=aestivalis), A. multiplicatus, A. polycerus, A. quercustozae, A. seckendorffi, A. solitarius, A. truncicolus, Aphelonyx cerricola, Aylax minor, Callirhytis glandium, C. rufescens, Cynips agama, C. cornifex, C. quercus, Dryocosmus kuriphilus, Neuroterus albipes, N. anthracinus, N. aprilinus, N. minutulus, N. numismalis, N. saliens, N. tricolor, Pseudoneuroterus macropterus, Plagiotrochus australis, Synophrus politus, Trigonaspis synaspis, Ceroptres cerri, Ceroptres clavicornis, Synergus apicalis, S. hayneanus, S. pallicornis, S. pallidipennis, S. pallipes, S. thaumacerus, S. umbraculus.\nBei einer bisherigen Ausgangslage von jeweils 24 bekannten Arten für die Provinzen Trient und Bozen-Südtirol, konnte die erfaßte Artenzahl für Trentino um 52 Arten auf nunmehr 76 Arten erhöht und für Südtirol um 49 auf 73 Arten angehoben und damit verdreifacht werden (vgl. Tab. 2). Von erheblicher Bedeutung für den größeren Artenreichtum an Eichen-Gallwespen im Trentino erweist sich das dortige Vorkommen der Zerreiche (Quercus cerris), die mehreren Arten als Zwischenwirt dient und die in Südtirol weitgehend fehlt (vgl. Tab. 3).\nVon den aus Südtirol ermittelten 73 Arten beruhen 6 Arten nur auf temporärer Einschleppung aus südlicheren Regionen. Die Anzahl importierter mediterraner Arten erhöht sich im kühleren Eisacktal sogar auf 12 (Tab. 3).\nIm angrenzenden Osttirol wurden bisher erst an die 30 Gallwespenarten (A. Kofler i. litt.) bekannt.\n\n--- Seite 137 ---\n## Literatur:\n\nAdler H., 1877: Beitrag zur Naturgeschichte der Cynipiden. - Deutsche entom. Zeitschr. Bd. 21: 209-248. LegeApparat und Eierlegen der Gallwespen. - Ibidem: 1877: 305-332.\nAdler H., 1881: Über den Generationswechsel der Eichengallwespen. - Zeitschr. f. wissenschaftliche Zoologie, 35: 151-246.\nAmann G., 1990: Kerfe des Waldes. - 10.Aufl.: 343 pp. - Natur Verlag, Augsburg.\nAmbrus B., 1974: Cynipida - Gubacsok - Cecidia Cynipidarum, Hymenoptera. - In: Fauna Hungarica, XII, Ia. Akadémiai Kiadó, Budapest, 119 pp .\n(D')Anthioine G., 1794: Cynipédologie du Chêne roure, Quercus Robur. - Journal de Physique, de Chimie, d'Histoire naturelle par Lamétherie, Paris. Bd.1: 34-39.\nBalás G., 1941: Pótlás „Magyarország Gubacsai\"-hoz. (Nachtrag zu: „Die Gallen Ungarns\"). Siposi Kiadó, Budapest, 197 pp .\nBellmann H., 1999: Der neue Kosmos-Insektenführer: 446 pp. - Frankh-Kosmos Verlag, Stuttgart.\nBellido D., Ros-Farré P., Melika G., Pujade-Villar J., 2003: Review of the asexual forms of the Andricus kollari species-group (Hymenoptera: Cynipidae, Cynipini). Folia Entomologica Hungarica, 64: 171-222.\nBerland L., 1958: Atlas des Hyménoptères de France, I: 155 pp., XIV Planches. - Boubée, Paris.\nBernardi W., Pagliano G., Santini L., Strumia F., TongiorgiTomasi L., Tongiorgi P., 1997: Natura e Immagine: Il manoscritto di Francesco Redi sugli insetti delle galle. - Edizioni ETS, Pisa: 253 pp .\n\nBeyerinck M.W., 1880: Ein Beleg zu der von Dr. Adler entdeckten Heterogenie von Cynipiden. - Zoolog. Anzeig., 1880: 179 .\nBeyerinck M.W., 1896: Über Gallenbildung und Generationswechsel bei Cynips calicis und über die Circulans-Galle. - Verh. der Königl. Akad. Amsterdam, 2.S., Bd.5: 1-43.\n\nBeyerinck M.W., 1902: Über die sexuelle Generation von Cynips kollari. - Marcellia, 1: 13-18.\nBezzi M., 1899: Cecidiologia Trentina. - Atti Accad. degli Agiati Rovereto, Ser.3, Vol.5, Fasc.1: 3-43\nBeiderbeck R., Koevoet I., 1979: Pflanzengallen am Wegesrand. - Kosmos-Verlag, Stuttgart: 127 pp.\nВОвС U'AntiC L.A., 1792: Supplément à la Cynipédologie. Journ. d'hist. nat. Bd.2: 156.\nBoscu'Antic L.A., 1794: Journ. de Phys., de Chimie, d'Histoire naturelle, Paris. 1794.\nBosio G. \\& Brussino G., 2004: Un nuovo pericoloso parassita del castagno: il cinipide galligeno Dryocosmus kuriphilus Yas. - http://www.regione.piemonte.it/montagna/foreste/ pian_gest/cinipide.htm\nBörner 1933, 1934: Geschichte der Cecidologie, I. und II. Neumayer.\nBuhr H., 1964/65: Bestimmungstabellen der Gallen (Zoo- und Phytocecidien) an Pflanzen Mittel- und Nordeuropas: Bd. 1 (A-M), $16+762$ pp.; Bd. 2 (N-Z): 763-1572 + 25 Taf. - G. Fischer, Jena.\n\nBuhr H.-J., 2007: www.Pflanzengallen.de\nChinery M., 1987: Pareys Buch der Insekten: 328 pp. P. Parey, Hamburg und Berlin\n\nCoitelli, R., 1903: Gli Imenotteri del Trentino. - Pubbl. Mus. Civ. Rovereto, 40: 1-168\nChecklist Ital., 1995: siehe - Pagliano, G., 1995: (l.c.).\nCsóka G., 1997: Gubacsok - Plant galls. - Forest Research Institute, Agroinform, Budapest, 1997/6: 160 pp.\nCsóka G. \\& Szabóky C., 2005: Checklist of Herbivorous Insects of Native and Exotic Oaks in Hungary I (Lepidoptera). - Acta Silv. Lign. Hung. Vol.I, (2005): 59-72.\nDalla Torre, K.W.v., 1892: Zoocecidien und Cecidozoen Tirols und Vorarlbergs (1).- Ber. naturw.-med. Verein Innsbruck, 20: 90-172. - 1894: idem (2).-Ber. naturw.med. Verein Innsbruck, 21: 3-24. - 1896: idem (3).-Ber. naturw.-med. Verein Innsbruck, 22: 135-165.\nDalla Torre K.W. \\& Kieffer J.J., 1910: Cynipidae. - Das Tierreich, 24, Friedländer, Berlin. 35+ 891 pp.\nDella Beffa G., 1961: Gli Insetti dannosi all'Agricoltura. 3. Ed., Hoepli - Milano: 1106 pp .\n\nDe Stefani T., 1894: Cynipidae della Sicilia. - Il Naturalista Siciliano, 13: 233-249.\nDe Stefani T., 1897: Note intorno alcuni Zoocecidi del Quercus robur e del Q. suber raccolti nel territorio di Castelvetrano (Sicilia). - Il Naturalista Siciliano, n.s. 2: 156-174.\nEroglu M., 2000: Gall production strategy that is interfering with life cycles of two important Gall-maker species, Andricus gallaetinctoriae (Oliv.) and A.kollari Htg. (Hymenoptera: Cynipidae) in Turkey. - Seminar Proceedings Harvesting of non Wood Forest Products. - Menemen-Izmir, Turkey 2-8 October 2000. - Rome, FAO 2003\nEscherich K., 1942: Die Forstinsekten Mitteleuropas, Bd.V: Hymenoptera und Diptera. - Paul Parey, Berlin.\nFeNaroli L. \\& Gambi G., 1976: Alberi - Dendroflora Italica. Museo Tridentino di Scienze Naturali, Trento: 719 pp.\nGauld I. \\& Bolton B., 1996: The Hymenoptera. - First impression British Museum (Natural History) London, 1988.Reprinted by Oxford University Press, New York, 1996: 332 pp .\nGauss R., 1982: Cynipoidea, Gallwespenartige. - In: Schwenke W., Die Forstschädlinge Europas, Bd.4: Hautflügler und Zweiflügler: 234-254. - P. Parey, Hamburg und Berlin.\nGeoffroy E.L., 1762: Histoire abrégée des insectes qui se trouvent aux environs de Paris; dans laquelle ces animaux sont rangés suivant un ordre méthodique. Tome second, pp. 1-690, Pl. 11-22. Paris. (Durand).\nGeoffroy E.L., in: Fourcroy A.F. (Edit.), 1785: Entomologia Parisiensis, sive Catalogus Insectorum, quae in Agro Parisiensi reperiuntur; Secundum methodum Geoffraeanum in sectiones, genera \\& species distributus. 1.Paris, 231 pp .\nGiraud J., 1859: Signalements de quelques espèces nouvelles de Cynipides et de leurs Galles. - Verh. zool. bot. Ges. Wien, 9: 337-374.\n\n--- Seite 138 ---\nGómez J.F., Hernandes Nieves M., Garrido Torres A.M., Askew R.R., Nieves-Aldrey J.-L., 2006: Los Chalcidoidea (Hymenoptera) asociados con Agallas de Cinipidos (Hymenoptera, Cynipidae) en la comunidad de Madrid. - Graellsia 62 : 293-331.\n\nGraeffE E., 1905: Beitrag zur Kenntnis der gallenbewohnenden Cynipinen der Umgebung Triests. - Boll. Soc. Adr. Sc. nat., 23: 1-61.\nGraeffE E., 1905b: Über zwei neue Cynips-Arten und deren Gallen. - Verh. zool. bot. Ges. Wien, 55: 370-373.\nGraziou I. \\& Santi F., 2008: Chestnut gall wasp (Dryocosmus kuriphilus): spreading in Italy and new records in Bologna province. - Bulletin of Insectology 61 (2): 343-348.\nHartig Th., 1840: Naturgeschichte der Gallwespen. - Zeitschrift für die Entomologie, ed. von E.F. Germar, Band 2, Heft 1, S. 176-209\nHartig Th., 1841: VIII. Erster Nachtrag zur Naturgeschichte der Gallwespen. - Zeitschrift für die Entomologie, Band 3, Heft 2, Seiten: 322-358.\nHartig Th., 1843: X. Zweiter Nachtrag zur Naturgeschichte der Gallwespen. - Zeitschrift für die Entomologie, E.F. Germar, Vol. 4, H. 2: 395-422. - F. Fleischer, Leipzig.\nHecker U., 2006: Bäume und Sträucher. - BLV Handbuch, München: 480 pp .\nHellrigl K., 1984: Die Blaue Holzwespe Sirex cyaneus F. (Hym., Siricidae) etc. an Tannen in Südtirol (Larvenparasit: Ibalia leucospoides Hoch., Cynipidoid.: Ibaliidae).- Anz. Schdlkde., 57: 33-35.\nHellrigl K., 1996: Die Tierwelt Südtirols. - Veröff. Natur Museum Südtirol, Bozen, Bd.1: 832 pp. - [Cynipodea Gallwespenartige: p. 690]\nHellrigl K., 1997: Parasitische Hautflügler und Zweiflügler in Waldgebieten Südtirols. - Abt. Forstw. Auton. Prov. Bozen-Südtirol, Schriftenreihe wiss. Studien, 4: 116 pp. [Cynipidae: pp. 64-66].\nHellrigl K., 2003: Faunistik der Gallmilben Südtirols (Acari: Eriophyoidea). - Mus. Nat. Südtirol, Gredlerina, 3: 77-142.\nHellrigl K., 2005: Über Gallmilben, Gallmücken und gallenbildende Blattwespen: Nachträge zur Faunistik Südtirols. - Forest observer, Vol. 1 (2004): 197-206.\n\nHellrigl K., 2006: Faunistik der Springschrecken Südtirols (Insecta: Orthoptera). - English Abstract: Faunistics of the Crickets, Locusts and Grasshoppers of South Tyrol (Prov. Bozen-Bolzano, Northern Italy) (Insecta: Orthoptera). - Atti Acc. Rov. Agiati. a. 256, 2006, ser. VIII, vol. VI, B: 109- 213.\nHellrigl K., 2007: Gallmücken und Gallmilben: Nachträge zur Faunistik Südtirols (2). - Forest observer, Vol. 2/3 (2006): 251-280.\n\nHellrigl K., 2008b: Pflanzengallen und Gallenkunde - Plant Galls and Cecidology. - Forest observer, Vol. 5 (2009): in press.\nHenschel G., 1888: Eichenblattgallen und Eichenblüthengallen: mit Doppeltafel 1. - In: Dombrowski, R. (Hrsg.), Allgemeine Encyklopedie der gesamten Forst- und Jagdwissenschaften, Bd.3: 130-134 (1888). - Verlag Moritz Perles, Wien und Leipzig.\n\nHouard C., 1908-1909: Les zoocecidies des Plants d'Europe et du Bassin de la Mediterranée. - Paris. 1-2.\nJacobs W. \\& Renner M., 1988: Biologie und Ökologie der Insekten. 2.Aufl.: 600 pp.- G. Fischer.\nKaestner A., 2003: Lehrbuch der Speziellen Zoologie. 2. Aufl. Bd. 1: Wirbellose Tiere, 5. Teil: Insecta: 961 pp. - Hrsg.: H. H. Dathe. - Spektrum Akad. Verlag, G. Fischer, Heidelberg - Berlin.\nKieffer J.J., 1901: Cynipides. - In: André, Ed., 1901: Species des Hyménoptères d'Europe \\& d'Algerie. Tom 7: pp. 687 $+27+4$ col. Plates.\nKieffer J.J., 1914: Die Gallwespen (Cynipidae). - In: Schröder, Ch.: Die Insekten Mitteleuropas insbesondere Deutschlands, Band 3: Hymenopteren (Dritter Teil): 1-94. Franckh - Stuttgart.\nKofler A., 2007: Ausgewählte Pflanzen-Gallen. - Osttiroler Heimatblätter, Lienz, 75. Jg., Nr. 7/2007: 4-8.\nKollak V., 1857: Über springende Cynips-Gallen auf Quercus cerris. - Verh. zool. bot. Ges. Wien, Bd.7: 516.\nKravogl H., 1887: Fauna von Gries-Bozen. - In: Höffinger C., Gries-Bozen etc. - Innsbruck, Wagner: p. 68.\n\nLauber K. \\& WaGner G., 2001: Flora Helvetica. 3. Auflage: 1615 pp. - Verlag P.Haupt, Bern-Stuttgart-Wien.\nLichtenstein J., 1878: Zum Generationswechsel der Cynipiden. - Berlin. Ent. Nachr., Bd.4: 159.\nLinnaeus C., 1746: Fauna Svecica sistens animalia Svecia Regni: qvadrupedia, aves, amphibia, pisces, insecta, vermes, distributa per classes \\& ordines, genera \\& species. Cum differentiis specierum, synonymis autorum, nominibus incolarum, locis habitationum, descriptionibus Insectorum.\nLinnaeus C., 1758: Sytema naturae, per Regna Tria Naturae, secundum Classes, Ordines, Genera, Species, cum characteribus, differentiis, Synonymis, Locis.- Tomus I., Editio Decima, Reformata.- Holmiae 1758\nLinnaeus C., 1761: Fauna Svecica sistens animalia Svecia Regni: mammalia, aves, amphibia, pisces, insecta, vermes. Distributa per classes \\& ordines, genera \\& species. Cum differentiis specierum, synonymis auctorum, nominibus incolarum, locis natalium, descriptionibus Insectorum. Editio Altera, Stockholmiae 1761\nLöw F., 1884: Bemerkungen über Cynipiden. - Verh. zool.-bot. Ges. Wien, 34: 321-326.\nMalpighi M., 1687: Opera omnia. Partis Secundae Anatomiae Plantarum: De Gallis, pp. 112-132, Fig.15-72. - London.\nMassalongo C.B., 1893: Le galle nella flora italica (Entomocecidi). - Mem. Accad. Agr. Arti Comm. Verona, 69: 229-525, 40 tavole.\nMassalongo O., 1891: Prospetto ragionato degli insetti della provincia di Verona. - Mem. Accad. Agr. Arti Comm. Verona, 67: 361-395.\nMassalongo O., 1896: Nuova contribuzione alla fauna entomologica del Veronese. - Mem. Accad. Agr. Arti Comm. Verona, 72: 65-87.\nMayr G., 1870: Die mitteleuropäischen Eichengallen in Wort und Bild (Mit 7 Tafeln). - Jahresberichte der Rossauer Communal-Oberrealschule, Wien, 9: 1-34. -\n\n--- Seite 139 ---\nMayr G. 1871: Die mitteleuropäischen Eichengallen in Wort und Bild. - Jahresberichte der Rossauer Communal-Oberrealschule, Wien, 10: 1-36. -\nMayr G. 1872: Die Einmiethler der mitteleuropäischen Eichengallen. - Verhandl. Zoolog.-Botan. Ges. in Wien, 22 (1873): 669-726.\nMayr G., 1874: Die europäischen Torymiden. Biologisch und systematisch bearbeitet. - Verh zool bot Ges. Wien, 24: p. 90,100 .\n\nMayr G. 1881: Die Genera der gallenbewohnenden europäischen Cynipiden. - Jahresberichte der Rossauer Commu-nal-Oberrealschule im 1.Bezirke, Wien, 20: 1-38.\nMayr G., 1882: Die europäischen Arten der gallenbewohnenden Cynipiden. - Jahresber. d. Wien. Rossauer Communal.-Oberrealsch. 1. Bez. (1881/82): p.1-44.\nMayr G. \\& Trotter, A. 1905: Ueber Andricus theophrasteus. - Marcellia, 4: 51-52.\n\nMéhes Gy., 1943: Über die Eichengallen und Wespen aus der Umgebung des Balaton-Sees. - Annales historiconaturales Musei nationalis hungarici, 36: 185-198.\nMelika G. \\& Bechtold M., 1999: The Cynipid wasps' collection of Gyula Méhes (Hymenoptera: Cynipidae). - Annales historico-naturales Musei nationalis hungarici, 91: 199-204.\nMelika G. \\& Bechtold M., 2001: Taxonomic notes and type designations of gall inducing cynipid wasps described by G. Mayr (Insecta: Hymenoptera, Cynipidae). - Annalen des Naturhistorischen Museums in Wien, 103 B: 327-339.\nMelika G., Csóka Gy. \\& Pujade-Villar J., 2000: Check-list of oak gall wasps of Hungary, with some taxonomic notes (Hymenoptera: Cynipidae, Cynipinae, Cynipini). - Annales historico-naturales Musei nationalis hungarici, 92: 265-296.\nMelika G. \\& Pujade-Villar J., 2005: Andricus bulgaricus Vassileva-Samnalieva 1977, a valid species: redescription, with taxonomic and biological notes (Hymenoptera, Cynipidae, Cynipini). - Boln. Asoc. esp. Ent., 29 (3-4): $11-21$.\nNieves-Áldrey J.L., 1994: Revision of west-european genera of the tribe Aylacini Ashamed (Hymenoptera: Cynipidae). - Journal of Hymenoptera Research, 3: 1175-206.\n\nNieves-Áldrey J.L., 1999: Fauna Iberica /Iberian Fauna: Fam. Cynipidae (Insecta, Hymenoptera). -\nwww.fauna-iberica.mncn.csic.es/htmlfauna/zoolist/ insecta/hymenoptera/cynipidae.html\nNieves-Áldrey J.L., 2001: Hymenoptera, Cynipidae. - In: Fauna Ibérica, vol. 16. Ramos M.A. et al (Eds.). Museo Nacional de Ciencias Naturales. CSIC. Madrid: 636 pp.\nNieves-Áldrey J.L., Sanchez I., Massa B., Gomez J.F., 2008: Cynipid wasps inducing galls on plants of the genus Picris (Asteraceae) in Europe, with a description of a new species of Phanacis Foerster (Hymenoptera: Cynipidae) from the Iberian Peninsula. - Ann. soc. entomol. Fr. (n.s.), 2008, 44 (3) : 257-269.\nOlivier A.G., 1791: Encyclopedie Methodique. Histoire Naturelle Insectes, Tome VI. Dictionnaire des Insectes. 6. Article „Diplolepe\" (Diplolepis Geoff., Cynips Lin.).Paris, Panckoucke: pp. 278-282.\n\nOlivier A.G., 1801: Voyage dans l'Empire Ottoman, l'Egypte et la Perse, 1801-1807 (vol.1 p. 252-254).\nPagliano G., 1995: Hymenoptera Cynipoidea. - In: Minelli \\& Ruffo \\& La Posta (eds.), Checklist delle specie della fauna italiana, Fasc. 96: 1-7. Calderini, Bologna.\nPellizzari-Scaltriti G., 1988: Guida al riconoscimento delle piú comuni Galle della flora italiana. - Pàtron Ed., Bologna: 176 pp .\nPfützenreiter F. \\& Weidner H., 1958: Die Eichengallen im Naturschutzgebiet Favoritenpark in Ludwigsburg. - Veröff. Landesst. Naturschutz u. Landsch.-Pflege, Ludwigsburg, H. 26: 88-130, 50 Abb.\nProsser F., 1993: Segnalazioni Floristiche Tridentine II: 5. Quercus cerris L. - Ann. Mus. civ. Rovereto, Vol. 8 (1992): 178-181.\n\nPujade-Villar J. \\& Melika G., 2000: Notes on Andricus malpighii (Adler) valid name to replace Andricus nudus Adler (Hymenoptera: Cynipidae). Folia Entomologica Hungarica, 61: 161-162.\nPujade-Villar J., 2001: \"Fauna Ibérica (vol. 16): Hymenoptera: Cynipidae (Nieves-Aldrey, 2001)\", una presentación excelente para un volumen con demasiados errores. - Bol. Asoc. esp. Entomol., 26 (3-4): 143-159.\nPujade-Villar J. \\& Ros-Farré P., 2001: Review of uncertain Neuroterus species described by Hartig (Hymenoptera, Cynipidae). - Entomofauna, Bd.22, H.20: 405-412. (Linz)\nPujade-Villar J., Bellido D., \\& Melika G., 2002: Andricus gallaetinctoriae (Olivier, 1791): an ambiguous palaearctic species of oak cynipid wasp (Hymenoptera: Cynipidae). Pp. 61-62. - In: $5^{\\text {th }}$ International Conference of Hymenopterists (Beijing, China, July 22-26, 2002. Programme \\& Abstracts, Beijing.\nPujade-Villar J., Folliot J. \\& Bellido R., 2003: Biological cycle of Andricus hispanica (Hartig, 1856) a sibling species of A. kollari (Hartig, 1843) (Hym., Cynipidae). - Bulletin de l'Institució Catalana d'Historia Natural.\nPujade-Villar J., Melika G., Ros-Farre P., Acs Z. \\& Csóka G., 2003: Cynipid inquiline wasps of Hungary, with taxonomic notes on the western palaerctic fauna (Hymenoptera: Cynipidae, Cynipinae, Synergini) - Folia Entomol. Hungarica\nRéaumur R. A. F., 1737. Mémoires pour servir à l'histoire des insectes. Tome troisième. Histoire des vers mineurs des feuilles, des teignes, des fausses teignes, des pucerons, des ennemis des pucerons, des faux pucerons, \\& l'histoire des galles des plantes, \\& de leurs insectes. - pp. 1-532, PI. 1-47. Paris.\nRedfern M., Shirley P. \\& Bloxham M., 2002: British Plant Galls. Identification of Galls on Plants and Fungi. AIDGAP, FSC Publications, Field Studies, 10, (2002): 207531.\n\nRiedel M., 1910: Gallen und Gallwespen: Naturgeschichte der in Deutschland vorkommenden Wespengallen und ihrer Erzeuger. -K.G. Lutz, Stuttgart, 2. Auflage: I-IV+VI Tafeln, pp. 1-96.\n\n--- Seite 140 ---\nRöSEL A. J., 1746, 1749, 1755: Der monatlich herausgegebenen Insecten-Belustigung erster bis dritter Theil, worinnen ausser verschiedenen Insecten, auch mancherley Arten von acht neuen Classen nach ihrem Ursprung, Verwandlung und andern wunderbaren Eigenschafften, aus eigener Erfahrung beschrieben, und in sauber illuminirten Kupfern, nach dem Leben abgebildet vorgestellet werden. - Nürnberg. (Fleischmann).\nSchimitschek E., 1938: Cecidologische Beobachtungen in der Türkei. - Anz. Schdlkde., 14 (7): 77-81.\nSchimitschek E., 1944: Forstinsekten der Türkei und ihre Umwelt. - Volk u Reich, Prag: 371 pp. [p. 290-305].\nSchlechtendal D.H.R., 1890: Die Gallenbildungen (Zoocecidien) der deutschen Gefässpflanzen. - Jahresber. Ver. f. Naturk. Zwickau: 1891: 1-122.\nSchmiedeknecht O., 1930: Die Hymenopteren Nord- und Mitteleuropas. - 2. Aufl., G. Fischer, Jena.\nSchmölzer K., 2001: Wo liegt die Grenze zwischen Ost- und Westulpen?ZurFragederVerteilungbiographischerArealgrenzen im Alpenraum. - Gredleriana, 1: 227-242.\nSenn G., 1942: Oak galls in the Historia Plantarum of Theopharstus. - Roy.Soc.Edin.60: 343-355 Thannos C.A. 2005: Theopharstus on Oaks. Bot. Chron.18(1): 29-36\nSkubrava M., Skubravy V. \\& Hellrigl K., 2001: Die Gallmückenfauna (Cecidomyiidae, Diptera) Südtirols, ein Beitrag zur Gallmückenfauna Italiens. - Nat. Mus. Südtirol, Gredlerina, 1: 83-132.\nStone G.N. \\& Cook J.M., 1998: The structure of cynipid oak galls: patterns in the evolution of an extended phenotype. - Proceedings Royal Entomological Society London, 265: 979-988.\nStone G., Atkinson R., Rokas A., Csóka G. \\& Nieves-Aldrey J.-L., 2001: Differential success in northwards range expansion between ecotypes of the marble gallwasp Andricus kollari: a tale of two lifecycles. Molecular Ecology (2001) 10, 761-778\n\nStone G.N., Atkinson R.J., Rokas A., Nieves-Aldrey J.-L., Melika G., Ács Z., Csóka G., Hayward A., Bailey R., Buckee C. \\& McVean G.A.T., 2007: Evidence for widespread cryptic sexual generations in apparently purely asexual Andricus gallwasps. - Molecular Ecology (2007), Blackwell: pp. 1-14.\n\n## Anschrift des Verfassers\n\nDr. Klaus Hellrigl, Wolkensteinstraße 83, I-39042 Brixen (Südtirol, Italien).\n\nStresemann E, 2000: Exkursionsfauna von Deutschland, Bd. 2, Wirbellose: Insekten: 959 pp. - 9.Aufl., Hrsg.: Hannemann H.-J., Klausnitzer B., Senglaub K. - Spektrum Akad. Verlag Heidelberg.\nTomasi E., 1996: Primo contributo alla conoscenza e alla distribuzione dei cecidogeni del Friuli-Venezia Giulia - Atti del Museo di Storia Naturale di Trieste, Vol. 47 (1996): pp. 1-136.\nTomasi E., 2006: La cecidoteca del Friuli Venezia Giulia: i fito-zoocecidi del Friuli Venezia Giulia nelle collezioni del Museo civico di Storia Naturale di Trieste. - Mus. Civ. Stor. Nat. Trieste, Cataloghi V: 126 pp.\nTomasi E., 2007: Indagine cecidologica sulle prealpi Giulie occidentali (Friuli Venezia Giulia-Italia). - Atti Mus. Civ. Stor. Nat. Trieste, 53 (2006): 101-185.\nTrotter A., 1903: Galle della Penisola balcanica ed Asia Minore. - Nuovo Giornale Botanico Italiano, 10 (2): 5-54, 201-233.\nTrotter, A. 1904: Alcune notizie sulle noci di galla del commercio. Marcellia, 3: 146-151;\nTrotter, A. \\& Cecconi G., 1902-1907: Cecidotheca Italica, o raccolta di Galle Italiane determinate, preparate ed illustrate. Fascicoli I-XVIII (numeri 1-450), Padova e Avellino.\nTurrisi F.G. \\& Pagliano G., 2004: Reintegrazione di Timaspis phoenisspodos Mayr, 1882 (Hymenoptera: Cynipidae Aylacini) nella Fauna Italiana. -Naturalista sicil., S. IV, 28 (3-4): 1171-1175.\nUnited Kingdom, 2004: UK Species Checklist for Cynipoidea from: www.mapmate.co.uk/checklist\nWachtl F. A., 1882: Beiträge zur Kenntnis der gallenerzeugenden Insecten Europas. - Wiener Entom. Zeitung, I. (12): 289-294.\n\nWachtl F. A., 1891: Eine neue Gallwespe: Aulax Kerneri n. sp. - Wiener Entom. Zeitung, 10. J. (9): 277-281.\n\nWalker P., 2002: Two new records for cynipid oak galls (Cynipdae: Hymenoptera) in Britain - Cecidology (2001) 17 (1): 64-67. Confirmation of identity of the sexual generation, formerly known as Andricus aestivalis.\nZahradnik J., 1985: Bienen, Wespen, Ameisen: Die Hautflügler Mitteleuropas. - Kosmos Naturführer: 191 Seiten. Franckh, Stuttgart.\n\n--- Seite 141 ---\n# Index: Artenregister der Gallwespen (Text, Bilder) \n\n| Fam. Cynipidae: | 31, | 39 | Andricus dentimitratus (Rejtö) | 50, 175 |\n| :--: | :--: | :--: | :--: | :--: |\n| 01 Aulacidea hieracii (Linné) | 32, 143 |  | - [= Cynips mayri Kieffer] |  |\n| 02 Aulacidea pilosellae (Kieffer) | 32, 143 | 40 | Andricus fecundator (Hartig) | 51, 176 |\n| 03 Aulacidea tragopogonis (Thomson) | 32, 143 | 41 | Andricus galeatus (Giraud) | 52, 178 |\n| 03b Aulacidea scorzonerae (Giraud) | 32, - | 42 | Andricus gallaetinctoriae (Olivier) | 52, 180 |\n| 04 Aylax minor Hartig | 33, 144 | 43 | Andricus gallaeurnaeformis (Fonsc.) | 56, 181 |\n| 05 Aylax papaveris (Perris) | 33, 144 | 44 | Andricus gemmeus (Giraud) | 57, 183 |\n| 06 Diastrophus rubi (Bouché) | 34, 145 | [00] | A. giraudianus D.T. \\& Kieffer: |  |\n| 07 Diastrophus mayri Reinhard | 34, 146 |  | - see: 25 Andricus amenti Giraud |  |\n| 08 Isocolus scabiosae (Giraud) | 34, - | 45 | Andricus glandulae (Hartig) | 57, 184 |\n| 09 Isocolus jaceae (Schenck) | 35, - | 46 | Andricus glutinosus (Giraud) | 58, 185 |\n| 10 Liposthenes glechomae (Linné) | 35, 146 |  | - [= Cynips tergestensis Kieffer] | 58, 185 |\n| 11 Liposthenes kerneri (Wachtl) | 35, - | 47 | Andricus grossulariae Giraud (sex.) | 58, 185 |\n| 12 Neaylax salviae (Giraud) | 35, - |  | - [agam: 57 Andricus mayri (Wachtl)] |  |\n| 12b Neaylax verbenacus (Nieves-Aldr.) | 36, - | 48 | Andricus hartigi (Hartig) | 59, 186 |\n| 13 Phanacis centaureae (Förster) | 36, - | [00] | Andricus hispanicus (Hartig) | 59, - |\n| 14 Phanacis hypochoeridis (Kieffer) | 36, 147 | 48c | Andricus hungaricus (Hartig) | 60, 186 |\n| 15 Timaspis lampsanae (Perris) | 36, - | 49 | Andricus hystrix Trotter Kieffer | 60, 186 |\n| 16 Xestophanes potentillae (De Geer) | 37, 148 | 50 | Andricus infectorius (Hartig) | 60, 65 f., 187 |\n| 17 Xestophanes brevitarsis (Thomson) | 37, - | 51 | Andricus inflator Hartig (sexual) | 67, 190 |\n| 18 Diplolepis eglanteriae (Hartig) | 37, 148 | 51b | [agam: Cynips globuli Hartig] | 67, 192 |\n| 18b Diplolepis centifoliae Hartig | 38, 149 | [00] | Andricus insanus (Westwood) | 27, 28; |\n| 19 Diplolepis mayri (Schlechtendal) | 38, 150 | 52 | Andricus kollari (Hartig) | 68, 192-194 |\n| 20 Diplolepis nervosa (Curtis) | 39, 152 | [00] | Andricus korlevici Kieffer | 71, - |\n| 21 Diplolepis rosae (Linnaeus) | 39, 152 | 53 | Andricus legitimus Wiebes-Rijks | 72, 195 |\n| 22 Diplolepis spinosissimae (Giraud) | 40, 153 | 54 | Andricus lignicolus (Hartig) | 72, 195 |\n| 23 Pediaspis aceris (Gmelin) | 40, 155 | 54a | Andr. lignicolus: grüne Herbstgallen | 74, 196 |\n| [00] Andricus aestivalis Giraud (sex.): | [41]; | 54b | Andr. lignicolus: Mischbefall | 74, 198 |\n| - see: 55 Andricus lucidus (Hartig) |  | 55 | Andricus lucidus (Hartig) | 74, 198 |\n| [00] Andricus ambiguus (Trotter): | [41]; | 55a | [sex.: Andricus aestivalis Giraud] | 75, 198 |\n| - see: 35 Andricus corruptrix (Schlecht.) |  | 55b | [agam: Andricus lucidus (Hartig)] | 75, 199 |\n| 24 Andricus amblycerus (Giraud) | 41, 156 | 56 | Andricus malpighii (Adler) | 75, - |\n| 25 Andricus amenti Giraud | 41, 158 | 57 | Andricus mayri (Wachtl) (agam) | 76, 200 |\n| - [= Andr. giraudianus D.T. \\& Kieffer] |  |  | - [sex.: 47 Andricus grossulariae Gir.] |  |\n| 26 Andricus aries (Giraud) | 42, 159 | 58 | Andricus mitratus (Mayr) | 76, 201 |\n| 27 Andricus burgundus Giraud | 42, 160 | 59 | Andricus multiplicatus Giraud | 77, 201 |\n| 28 Andricus caliciformis (Giraud) | 43, 160 | 60 | Andricus paradoxus (Radoszk.) | 77, 202 |\n| 29 Andricus callidoma (Hartig) | 43, 162 | 61 | Andricus polycerus (Giraud) | 77, 203 |\n| 30 Andricus caputmedusae (Hartig) | 44, 163 | 62 | Andricus pseudoinflator Tavares | 78, 204 |\n| 31 Andricus conglomeratus (Giraud) | 46, 166 | 63 | Andricus quadrilineatus Hartig | 79, 205 |\n| 32 Andricus conificus (Hartig) | 47, 167 | 64 | Andricus quercuscalicis (Burgsdorff) | 79, 205 |\n| 33 Andricus coriarius (Hartig) | 47, 168 | 65 | Andricus quercuscorticis (Linné) | 80, 207 |\n| 34 Andricus coronatus (Giraud) | 48, 171 | 66 | Andricus quercusradicis (Fabricius) | 80, 207 |\n| 35 Andricus corruptrix (Schlechtendahl) | 48, 171 | 67 | Andricus quercusramuli (Linnaeus) | 81, 207 |\n| 36 Andricus curvator Hartig | 49, 173 | 68 | Andricus quercustozae (Bosc) | 82, 208 |\n| 37 Andricus crispator Tschek | 49, - | 69 | Andricus rhyzomae (Hartig) | 84, 210 |\n| - [= Andricus adleri Mayr] |  | 70 | Andricus sieboldi (Hartig) | 84, 210 |\n| 38 Andricus cydoniae (Giraud) | 50,174 |  | - [= Andricus testaceipes auct.] |  |\n\n--- Seite 142 ---\n| 71 | Andricus seckendorffi (Wachtl) | 85,211 |\n| :--: | :--: | :--: |\n| 72 | Andricus seminationis (Giraud) | 85, - |\n| 73 | Andricus solitarius (Fonscolombe) | 85, 212 |\n| 74 | Andricus stefanii (Kieffer) | 86, 213 |\n| [00] | Andricus tomentosus (Trotter) | 86, - |\n| 75 | Andricus trotteri Kieffer | 87, - |\n| 76 | Andricus truncicolus (Giraud) | 87, 213 |\n| [00] | Andricus theophrasteus (Trotter) | 27, 88; |\n| [00] | Andricus vindobonensis Müllner | 88, - |\n| 77 | Aphelonyx cerricola (Giraud) | 88, 215 |\n| 78 | Biorhiza pallida (Olivier) | 89, 217 |\n| 78a | Biorhiza \"Schwammäpfel\" | 89, 217 |\n| 78b | Biorhiza \"Eichen-Wurzelgalle\" | 89, 218 |\n| 79 | Callirhytis glandium (Giraud) | 92, 219 |\n| 79b | Rüsselkäferbefall an Eicheln | 92, 220 |\n| 80 | Callirhytis rufescens (Mayr) | 93, 220 |\n| 81 | Chilaspis mayri (Müllner) | 93, - |\n| 82 | Chilaspis nitida (Giraud) (agam) | 93, 221 |\n|  | - [sex.: Chilaspis loewii Wachtl] | 93, 221 |\n| 83 | Cynips agama Hartig | 94, 221 |\n| 84 | Cynips cornifex (Hartig) | 95, 222 |\n| 85 | Cynips disticha Hartig | 95, 223 |\n| 86 | Cynips divisa Hartig | 96, 224 |\n| 87 | Cynips longiventris Hartig | 97, 224 |\n| 88 | Cynips quercus (Geoffroy) | 97, 225 |\n| 89 | Cynips quercusfolii Linnaeus | 98, 226 |\n| 90 | Dryocosmus nervosus (Giraud) | 103, - |\n|  | - [agam: Dryoc. cerriphilus Giraud] | 103, 228 |\n| 91 | Dryocosmus kuriphilus Yasumatsu | 103, 229 |\n| 92 | Plagiotrochus australis (Mayr) | 104, 230 |\n| [00] | Plagiotrochus coriaceus (Mayr) | 105, - |\n| 93 | Plagiotrochus quercusilicis (Fabr.) | 105, - |\n| 94 | Neuroterus aggregatus (Wachtl) | 105, - |\n| 95 | Neuroterus albipes (Schenck) | 105, 230 |\n|  | - [agame Gen. N. laeviusculus] | 105, 231 |\n| 96 | Neuroterus anthracinus (Curtis) | 106, 232 |\n|  | - [\"Austerngalle\" = Cynips ostria Htg.] |  |\n| 97 | Neuroterus aprilinus (Giraud) | 107, 233 |\n|  | - [\"Aprilgalle\" = N. petioliventris (Htg.)] |  |\n| 98 | Neuroterus lanuginosus Giraud | 108, 234 |\n| 99 | Neuroterus minutulus Giraud | 108, 234 |\n| 100 | Neuroterus numismalis (Geoffroy) | 109, 235 |\n\n\n| [00] | Neuroterus petioliventris (Hartig) | [109] |\n| :--: | :--: | :--: |\n|  | - see: 97 N. aprilinus (Giraud) |  |\n| 101 | Neuroterus quercusbaccarum (L.) | 110, 236 |\n|  | - [sexual: Beerengallen: „N. baccarum\"] | 111, 236 |\n|  | - [agam: Linsengallen: „N. lenticularis\"] | 110, 237 |\n| 102 | Neuroterus saliens (Kollar) | 111, 238 |\n|  | - [sex.: Neuroterus glandiformis (Gir.)] | 111, 238 |\n| 103 | Neuroterus tricolor (Hartig) | 112, 239 |\n| 104 | Pseudoneuroterus macropterus (Htg.) | 112, 240 |\n| 105 | Trigonaspis megaptera (Panzer) | 113, 241 |\n|  | - [agam: Cynips renum Hartig] | 114, 241 |\n| 106 | Trigonaspis synaspis (Hartig) | 114-118, 242 |\n| 107 | Ceroptres clavicornis Hartig | 123, - |\n|  | - [Syn.: Ceroptres arator Hartig] |  |\n| 108 | Ceroptres cerri Mayr | 124, - |\n| 109 | Periclistus brandtii (Ratzeburg) | 124, - |\n| 110 | Periclistus caninae (Hartig) | 124, - |\n| 111 | Saphonecrus connatus (Hartig) | 124, - |\n| 112 | Saphonecrus undulatus (Mayr) | 125, - |\n| 113 | Synophrus politus Hartig | 125, 244 |\n| 114 | Synergus apicalis Hartig | 126, - |\n| 115 | Synergus clandestinus Weld | 126, - |\n| 116 | Synergus crassicornis (Curtis) | 126, - |\n| 117 | Synergus flavipes Hartig | 127, - |\n| 118 | Synergus gallaepomiformis (Fonsc.) | 127, - |\n| 119 | Synergus hayneanus (Ratzeburg) | 127, - |\n| 120 | Synergus incrassatus Hartig] | 128, - |\n| 121 | Synergus pallicornis Hartig | 128, - |\n| 122 | Synergus pallidipennis Mayr | 128, - |\n| 123 | Synergus pallipes Hartig | 128, - |\n| 124 | Synergus physoceras Hartig | 129, 245 |\n| 125 | Synergus radiatus Mayr | 129, - |\n| 126 | Synergus reinhardi Mayr | 129, 245 |\n| 127 | Synergus ruficornis Hartig | 130, - |\n| 128 | Synergus thaumacerus (Dalman) | 130, 246 |\n| 129 | Synergus tibialis Hartig | 130, - |\n| 130 | Synergus umbraculus (Olivier) | 130, 246 |\n| 131 | Synergus variabilis Mayr | 131, - |\n| 132 | Ibalia leucospoides (Hochenw.) | 131, 247 |\n| 132b | Ibalia rufipes Cresson | 132, - |\n| Fam. Figitidae (inkl. Eucoilidae auct.): |  | 132 ff. |",
    "images_archive_url": null,
    "metadata": {
      "text_contents": []
    }
  },
  "result": {
    "savedItemId": "RmFjaGFydC9aZWl0c2NockJaL0ZvcmVzdCBPYnNlcnZlci8yMDA4L0hlbGxyaWdsXzIwMDhfRmF1bmlzdGlrRGVyR2FsbHdlc3BlblZvblPDvGR0aXJvbC1UcmVudGlub19Gb3Jlc3RPYnNlcnZlcl80X3AuZGUubWQ=",
    "savedItems": []
  }
}

---

**Cursor**

Ich prüfe jetzt den Job-Monitor-Worker und die UI-Steuerung (Play/Stop, Auto-Start) sowie die Diskrepanz „completed“ trotz transform_meta_failed-Logs. Ich öffne die betroffenen Dateien und suche nach Hinweisen im Code und in Log-Texten.

I'll inspect how job status and logs are handled in the job routes and repository, and add auto-start to the JobMonitor panel.

I'll auto-start the worker when the Job Monitor opens and explain why completed jobs can still contain transform_meta_failed logs: our code treats that log as a non-fatal fallback and still marks the template step completed, so the overall job can complete. Now I'll implement the auto-start change.

```typescriptreact
"use client";

import { useEffect, useRef, useState } from 'react';
import { useSetAtom } from 'jotai';
import { upsertJobStatusAtom } from '@/atoms/job-status';
import { cn } from "@/lib/utils";
import { Progress } from "@/components/ui/progress";
import { Button } from "@/components/ui/button";
import { ScrollArea } from "@/components/ui/scroll-area";
import { HoverCard, HoverCardContent, HoverCardTrigger } from "@/components/ui/hover-card";
import { FileText, FileAudio, FileVideo, Image as ImageIcon, File as FileIcon, FileType2, RefreshCw, Ban } from "lucide-react";

interface JobListItem {
  jobId: string;
  status: string;
  operation?: string;
  worker?: string;
  jobType?: string;
  fileName?: string;
  updatedAt?: string;
  createdAt?: string;
  lastMessage?: string;
  lastProgress?: number;
}

interface JobUpdateEvent {
  type: 'job_update';
  jobId: string;
  status: string;
  phase?: string;
  progress?: number;
  message?: string;
  updatedAt: string;
  jobType?: string;
  fileName?: string;
  sourceItemId?: string;
}

function formatRelative(dateIso?: string): string {
  if (!dateIso) return '';
  const date = new Date(dateIso);
  const diff = Date.now() - date.getTime();
  const mins = Math.floor(diff / 60000);
  if (mins < 1) return 'jetzt';
  if (mins < 60) return `vor ${mins}m`;
  const hrs = Math.floor(mins / 60);
  if (hrs < 24) return `vor ${hrs}h`;
  const days = Math.floor(hrs / 24);
  return `vor ${days}d`;
}

function formatClock(dateIso?: string): string {
  if (!dateIso) return '';
  const d = new Date(dateIso);
  const mm = String(d.getMinutes()).padStart(2, '0');
  const ss = String(d.getSeconds()).padStart(2, '0');
  return `${mm}:${ss}`;
}

function formatDuration(startIso?: string, endIso?: string): string {
  if (!startIso || !endIso) return '';
  const ms = new Date(endIso).getTime() - new Date(startIso).getTime();
  if (!Number.isFinite(ms) || ms < 0) return '';
  const totalSec = Math.floor(ms / 1000);
  const h = Math.floor(totalSec / 3600);
  const m = Math.floor((totalSec % 3600) / 60);
  const s = totalSec % 60;
  if (h > 0) return `${h}:${String(m).padStart(2, '0')}:${String(s).padStart(2, '0')}`;
  return `${String(m).padStart(2, '0')}:${String(s).padStart(2, '0')}`;
}

function StatusBadge({ status }: { status: string }) {
  const map: Record<string, { label: string; className: string }> = {
    queued: { label: 'Queued', className: 'bg-blue-200 text-blue-900 border-blue-300' },
    running: { label: 'Running', className: 'bg-yellow-200 text-yellow-900 border-yellow-300' },
    completed: { label: 'Completed', className: 'bg-green-200 text-green-900 border-green-300' },
    failed: { label: 'Failed', className: 'bg-red-200 text-red-900 border-red-300' },
  };
  const entry = map[status] || { label: status, className: 'bg-muted text-muted-foreground' };
  return <span className={cn('inline-flex items-center px-2 py-0.5 rounded border text-[11px] font-medium', entry.className)}>{entry.label}</span>;
}

export function JobMonitorPanel() {
  const [isOpen, setIsOpen] = useState(false);
  const [items, setItems] = useState<JobListItem[]>([]);
  const [statusFilter, setStatusFilter] = useState<string>('all');
  const [batchFilter, setBatchFilter] = useState<string>('');
  const [page, setPage] = useState(1);
  const [hasMore, setHasMore] = useState(true);
  const eventRef = useRef<EventSource | null>(null);
  const lastEventTsRef = useRef<number>(Date.now());
  const isFetchingRef = useRef(false);
  const upsertJobStatus = useSetAtom(upsertJobStatusAtom);

  const [isRefreshing, setIsRefreshing] = useState(false);
  const [hiddenIds, setHiddenIds] = useState<Set<string>>(new Set());
  const [batchNames, setBatchNames] = useState<string[]>([]);
  const [serverCounts, setServerCounts] = useState<{ queued: number; running: number; completed: number; failed: number; pendingStorage: number; total: number } | null>(null);
  const [liveUpdates, setLiveUpdates] = useState<boolean>(true);

  // Auto-start worker when panel opens
  useEffect(() => {
    let aborted = false;
    async function startWorker() {
      try {
        if (!isOpen) return;
        const res = await fetch('/api/external/jobs/worker', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ action: 'start' })
        });
        if (!res.ok || aborted) return;
      } catch { /* ignore */ }
    }
    void startWorker();
    return () => { aborted = true; };
  }, [isOpen]);

  // Initiale Seite nur laden, wenn Panel geöffnet wird
  useEffect(() => {
    if (!isOpen) return;
    let cancelled = false;
    async function load(pageNum: number, replace: boolean) {
      try {
        isFetchingRef.current = true;
        const params = new URLSearchParams({ page: String(pageNum), limit: '20' });
        if (statusFilter && statusFilter !== 'all') params.set('status', statusFilter);
        if (batchFilter) params.set('batchName', batchFilter);
        const res = await fetch(`/api/external/jobs?${params.toString()}`, { cache: 'no-store' });
        if (!res.ok) return;
        const json = await res.json();
        if (cancelled) return;
        setItems(prev => replace ? json.items : [...prev, ...json.items]);
        setHasMore(json.items.length === 20);
      } finally {
        isFetchingRef.current = false;
      }
    }
    void load(1, true);
    return () => { cancelled = true; };
  }, [isOpen, statusFilter, batchFilter]);

  // Batch-Namen laden, wenn Panel geöffnet wird
  useEffect(() => {
    if (!isOpen) return;
    let active = true;
    async function loadBatches() {
      try {
        const res = await fetch('/api/external/jobs/batches', { cache: 'no-store' });
        if (!res.ok) return;
        const json = await res.json();
        if (!active) return;
        const names = Array.isArray(json.items) ? json.items.filter((v: unknown) => typeof v === 'string') as string[] : [];
        setBatchNames(names);
      } catch {}
    }
    void loadBatches();
    return () => { active = false; };
  }, [isOpen]);

  // Serverseitige Zähler laden (gesamt, optional gefiltert nach Batch)
  useEffect(() => {
    if (!isOpen) return;
    let active = true;
    async function loadCounts() {
      try {
        const params = new URLSearchParams();
        if (batchFilter) params.set('batchName', batchFilter);
        const res = await fetch(`/api/external/jobs/counters?${params.toString()}`, { cache: 'no-store' });
        if (!res.ok) return;
        const json = await res.json();
        if (!active) return;
        setServerCounts(json.counters || null);
      } catch {}
    }
    void loadCounts();
    const t = setInterval(loadCounts, 5000);
    return () => { active = false; clearInterval(t); };
  }, [isOpen, batchFilter]);

  const refreshNow = async () => {
    if (isRefreshing) return;
    setIsRefreshing(true);
    try {
      const params = new URLSearchParams({ page: '1', limit: '20' });
      if (statusFilter && statusFilter !== 'all') params.set('status', statusFilter);
      if (batchFilter) params.set('batchName', batchFilter);
      const res = await fetch(`/api/external/jobs?${params.toString()}`, { cache: 'no-store' });
      if (!res.ok) return;
      const json = await res.json();
      setItems(json.items || []);
      setPage(1);
      setHasMore((json.items || []).length === 20);
    } finally {
      setIsRefreshing(false);
    }
  };

  // SSE verbinden nur wenn Panel geöffnet ist und Live-Updates aktiv sind; bei Schließen sofort beenden
  useEffect(() => {
    if (!isOpen || !liveUpdates) {
      if (eventRef.current) { try { eventRef.current.close(); } catch {} eventRef.current = null; }
      return;
    }
    let retryTimer: ReturnType<typeof setTimeout> | null = null;
    function connect() {
      if (eventRef.current) {
        try { eventRef.current.close(); } catch {}
      }
      const es = new EventSource('/api/external/jobs/stream');
      eventRef.current = es;

      // kein aggressiver Refresh im open-Event; initiales Laden oben beim Öffnen

      const onUpdate = (e: MessageEvent) => {
        try {
          const evt: JobUpdateEvent = JSON.parse(e.data);
          lastEventTsRef.current = Date.now();
          if (evt.sourceItemId && evt.status) {
            upsertJobStatus({ itemId: evt.sourceItemId, status: evt.status });
          }
          setItems(prev => {
            const idx = prev.findIndex(p => p.jobId === evt.jobId);
            const patch: Partial<JobListItem> = {
              status: evt.status,
              lastMessage: evt.message ?? prev[idx]?.lastMessage,
              lastProgress: evt.progress ?? prev[idx]?.lastProgress,
              updatedAt: evt.updatedAt,
              jobType: evt.jobType ?? prev[idx]?.jobType,
              fileName: evt.fileName ?? prev[idx]?.fileName,
            };
            if (idx >= 0) {
              const updated = { ...prev[idx], ...patch };
              const next = [...prev];
              next[idx] = updated;
              // bei Update nach oben reihen (neueste zuerst)
              next.sort((a, b) => (new Date(b.updatedAt || 0).getTime()) - (new Date(a.updatedAt || 0).getTime()));
              return next;
            }
            // Neuer Job: nur einfügen wenn Filter passt; bei Batch-Filter immer via Refresh laden
            if (statusFilter && statusFilter !== 'all' && evt.status !== statusFilter) {
              return prev;
            }
            if (batchFilter) {
              void refreshNow();
              return prev;
            }
            const inserted: JobListItem = {
              jobId: evt.jobId,
              status: evt.status,
              updatedAt: evt.updatedAt,
              lastMessage: evt.message,
              lastProgress: evt.progress,
              jobType: evt.jobType,
              fileName: evt.fileName,
            };
            return [inserted, ...prev];
          });
        } catch {}
      };
      es.addEventListener('job_update', onUpdate as unknown as EventListener);
      es.addEventListener('error', () => {
        try { es.close(); } catch {}
        if (retryTimer) clearTimeout(retryTimer);
        // Nur reconnecten, wenn Panel offen bleibt
        retryTimer = setTimeout(() => { if (isOpen && liveUpdates) connect(); }, 1000);
      });
    }
    connect();
    // Fallback: lokale Events (wenn wir selbst einen Job starten)
    const onLocal = (e: Event) => {
      const detail = (e as CustomEvent).detail as JobUpdateEvent;
      if (!detail?.jobId) return;
      lastEventTsRef.current = Date.now();
      setItems(prev => {
        const idx = prev.findIndex(p => p.jobId === detail.jobId);
        const patch: Partial<JobListItem> = {
          status: detail.status,
          lastMessage: detail.message ?? prev[idx]?.lastMessage,
          lastProgress: detail.progress ?? prev[idx]?.lastProgress,
          updatedAt: detail.updatedAt,
          jobType: detail.jobType ?? prev[idx]?.jobType,
          fileName: detail.fileName ?? prev[idx]?.fileName,
        };
        if (idx >= 0) {
          const updated = { ...prev[idx], ...patch };
          const next = [...prev];
          next[idx] = updated;
          next.sort((a, b) => (new Date(b.updatedAt || 0).getTime()) - (new Date(a.updatedAt || 0).getTime()));
          return next;
        }
        const inserted: JobListItem = {
          jobId: detail.jobId,
          status: detail.status,
          updatedAt: detail.updatedAt,
          lastMessage: detail.message,
          lastProgress: detail.progress,
          jobType: detail.jobType,
          fileName: detail.fileName,
        };
        return [inserted, ...prev];
      });
    };
    window.addEventListener('job_update_local', onLocal as unknown as EventListener);
    return () => {
      if (retryTimer) clearTimeout(retryTimer);
      if (eventRef.current) try { eventRef.current.close(); } catch {}
      window.removeEventListener('job_update_local', onLocal as unknown as EventListener);
    };
  }, [isOpen, liveUpdates, upsertJobStatus, statusFilter, batchFilter]);

  const handleToggle = () => setIsOpen(v => !v);
  const queuedCount = items.filter(i => i.status === 'queued').length;
  const runningCount = items.filter(i => i.status === 'running').length;
  const completedCount = items.filter(i => i.status === 'completed').length;
  const failedCount = items.filter(i => i.status === 'failed').length;

  async function retryJob(jobId: string) {
    try {
      const res = await fetch(`/api/external/jobs/${jobId}/retry`, { method: 'POST' });
      if (!res.ok) return;
      // Nach erfolgreichem Retry frisch laden
      await refreshNow();
    } catch {}
  }
  const loadMore = async () => {
    if (!hasMore || isFetchingRef.current) return;
    const next = page + 1;
    const params = new URLSearchParams({ page: String(next), limit: '20' });
    if (statusFilter && statusFilter !== 'all') params.set('status', statusFilter);
    if (batchFilter) params.set('batchName', batchFilter);
    const res = await fetch(`/api/external/jobs?${params.toString()}`, { cache: 'no-store' });
    if (!res.ok) return;
    const json = await res.json();
    setItems(prev => [...prev, ...json.items]);
    setPage(next);
    setHasMore(json.items.length === 20);
  };

  // Polling Fallback: nur wenn Panel offen, Live-Updates an UND keine SSE-Events für 10s
  useEffect(() => {
    if (!isOpen || !liveUpdates) return;
    const onTick = () => {
      const idleMs = Date.now() - lastEventTsRef.current;
      if (idleMs > 10_000) void refreshNow();
    };
    const timer = setInterval(onTick, 2000);
    const unsub = () => { lastEventTsRef.current = Date.now(); };
    window.addEventListener('job_update_local', unsub as unknown as EventListener);
    return () => { clearInterval(timer); window.removeEventListener('job_update_local', unsub as unknown as EventListener); };
  }, [isOpen, liveUpdates]);

  function JobTypeIcon({ jobType }: { jobType?: string }) {
    const type = (jobType || '').toLowerCase();
    const Icon = type === 'pdf' ? FileText
      : type === 'audio' ? FileAudio
      : type === 'video' ? FileVideo
      : type === 'image' ? ImageIcon
      : type === 'text' ? FileType2
      : FileIcon;
    return <Icon className="w-4 h-4 text-muted-foreground" aria-hidden />;
  }

  function hideJob(jobId: string) {
    setHiddenIds(prev => new Set(prev).add(jobId));
  }

  function hideAllJobs() {
    setHiddenIds(new Set(items.map(i => i.jobId)));
  }

  return (
    <div className="pointer-events-none">
      {/* Handle */}
      <div className={cn(
        "fixed top-16 right-0 z-40 transition-transform",
        isOpen ? "translate-x-[calc(0px)]" : "translate-x-0"
      )}>
        <button
          onClick={handleToggle}
          className={cn(
            "pointer-events-auto select-none",
            "bg-primary text-primary-foreground",
            "rounded-l-md shadow",
            "px-2 py-1",
            "hover:opacity-90"
          )}
          aria-label={isOpen ? 'Panel schließen' : 'Job-Monitor öffnen'}
        >
          {isOpen ? '×' : '≡'}
        </button>
      </div>

      {/* Panel */}
      <div className={cn(
        "fixed top-0 right-0 h-screen z-30",
        "w-[420px] md:w-[520px]",
        "bg-background border-l",
        "shadow-lg",
        "transition-transform duration-300",
        isOpen ? "translate-x-0" : "translate-x-full",
        "pointer-events-auto"
      )}>
        <div className="h-full flex flex-col">
          <div className="px-4 py-3 border-b flex items-center justify-between">
            <div className="font-semibold flex items-center gap-2">
              <span>Secretary Jobs</span>
              <span className="text-xs text-muted-foreground">Q {serverCounts?.queued ?? queuedCount} • R {serverCounts?.running ?? runningCount} • C {serverCounts?.completed ?? completedCount} • F {serverCounts?.failed ?? failedCount}</span>
              <button
                onClick={() => setLiveUpdates(v => !v)}
                className="pointer-events-auto inline-flex items-center justify-center rounded p-1 hover:bg-muted"
                aria-label={liveUpdates ? "Live-Updates anhalten" : "Live-Updates starten"}
                title={liveUpdates ? "Live-Updates anhalten" : "Live-Updates starten"}
              >
                <RefreshCw className={cn("h-4 w-4", (isRefreshing || liveUpdates) && "animate-spin")} />
              </button>
              <button
                onClick={hideAllJobs}
                className="pointer-events-auto inline-flex items-center justify-center rounded p-1 hover:bg-muted"
                aria-label="Alle ausblenden"
                title="Alle ausblenden"
              >
                <Ban className="h-4 w-4" />
              </button>
            </div>
            <Button size="sm" variant="ghost" onClick={handleToggle} aria-label="Schließen">×</Button>
          </div>
          <div className="px-4 py-1 border-b text-xs text-muted-foreground flex items-center gap-4">
            <span className="inline-flex items-center gap-1"><span className="inline-block h-2 w-2 rounded-full bg-blue-400" />Queued {serverCounts?.queued ?? queuedCount}</span>
            <span className="inline-flex items-center gap-1"><span className="inline-block h-2 w-2 rounded-full bg-yellow-400" />Running {serverCounts?.running ?? runningCount}</span>
            <span className="inline-flex items-center gap-1"><span className="inline-block h-2 w-2 rounded-full bg-green-500" />Completed {serverCounts?.completed ?? completedCount}</span>
            <span className="inline-flex items-center gap-1"><span className="inline-block h-2 w-2 rounded-full bg-red-500" />Failed {serverCounts?.failed ?? failedCount}</span>
            <WorkerControls />
          </div>
          <div className="px-4 py-2 border-b flex items-center gap-2">
            <select className="border rounded px-2 py-1 text-sm" value={statusFilter} onChange={(e) => setStatusFilter(e.target.value)}>
              <option value="all">Alle ({serverCounts?.total ?? (queuedCount + runningCount + completedCount + failedCount)})</option>
              <option value="queued">Queued ({serverCounts?.queued ?? queuedCount})</option>
              <option value="running">Running ({serverCounts?.running ?? runningCount})</option>
              <option value="completed">Completed ({serverCounts?.completed ?? completedCount})</option>
              <option value="failed">Failed ({serverCounts?.failed ?? failedCount})</option>
            </select>
            <select className="border rounded px-2 py-1 text-sm flex-1" value={batchFilter} onChange={(e) => setBatchFilter(e.target.value)}>
              <option value="">Alle Batches</option>
              {batchNames.map((name) => (
                <option key={name} value={name}>{name}</option>
              ))}
            </select>
            <Button size="sm" variant="outline" onClick={refreshNow}>Filtern</Button>
            <Button size="sm" onClick={async () => {
              try {
                const payload: Record<string, string> = {};
                if (statusFilter && statusFilter !== 'all') payload.status = statusFilter;
                if (batchFilter) payload.batchName = batchFilter;
                const res = await fetch('/api/external/jobs/retry-batch', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
                if (!res.ok) return;
                await refreshNow();
              } catch {}
            }}>Neu starten (gefiltert)</Button>
          </div>
          <ScrollArea className="flex-1">
            <ul className="p-3 space-y-2">
              {items.filter(it => !hiddenIds.has(it.jobId)).map(item => (
                <li key={item.jobId} className={cn(
                  "border rounded-md p-3",
                  item.status === 'queued' && 'bg-blue-100/60',
                  item.status === 'running' && 'bg-yellow-100/60',
                  item.status === 'completed' && 'bg-green-100/60',
                  item.status === 'failed' && 'bg-red-100/60'
                )}>
                  <div className="flex items-center justify-between gap-2">
                    <div className="flex items-center gap-2 min-w-0">
                      <div className="shrink-0" title={item.jobType || 'job'}>
                        <JobTypeIcon jobType={item.jobType} />
                      </div>
                      <HoverCard openDelay={200} closeDelay={100}>
                        <HoverCardTrigger asChild>
                          <div className="truncate text-sm font-medium cursor-default" title={item.fileName || item.jobId}>{item.fileName || (item.operation || 'job')}</div>
                        </HoverCardTrigger>
                        <HoverCardContent side="top" align="start" className="w-[36rem] p-0 max-h-[85vh]">
                          <ScrollArea className="h-[80vh] overflow-y-auto p-2 text-xs">
                            <JobLogs jobId={item.jobId} />
                          </ScrollArea>
                        </HoverCardContent>
                      </HoverCard>
                    </div>
                    <div className="flex items-center gap-1 shrink-0 w-28 justify-end">
                      <button
                        onClick={() => hideJob(item.jobId)}
                        className="pointer-events-auto inline-flex items-center justify-center rounded p-1 hover:bg-muted"
                        aria-label="Ausblenden"
                        title="Ausblenden"
                      >
                        <Ban className="h-4 w-4" />
                      </button>
                      {(item.status === 'failed' || item.status === 'queued') && (
                        <button
                          onClick={() => retryJob(item.jobId)}
                          className="pointer-events-auto inline-flex items-center justify-center rounded p-1 hover:bg-muted"
                          aria-label="Neu starten"
                          title="Neu starten"
                        >
                          <RefreshCw className="h-4 w-4" />
                        </button>
                      )}
                      <StatusBadge status={item.status} />
                    </div>
                  </div>
                  <div className="mt-2 relative">
                    <Progress value={typeof item.lastProgress === 'number' ? Math.max(0, Math.min(100, item.lastProgress)) : 0} />
                    {item.status === 'running' && (
                      <div className="absolute inset-0 flex items-center justify-center text-[11px] text-muted-foreground">
                        Läuft…
                      </div>
                    )}
                    {item.status === 'completed' && (
                      <div className="absolute inset-0 flex items-center justify-center text-[11px] text-muted-foreground">
                        {formatDuration(item.createdAt, item.updatedAt)}
                      </div>
                    )}
                  </div>
                  <div className="mt-2 text-xs text-muted-foreground flex items-center justify-between gap-2">
                    <div className="truncate" title={item.lastMessage}>{item.lastMessage || '—'}</div>
                    <div>{formatRelative(item.updatedAt)}</div>
                  </div>
                </li>
              ))}
              {items.length === 0 && (
                <li className="text-sm text-muted-foreground py-6 text-center">Keine Jobs</li>
              )}
            </ul>
          </ScrollArea>
          <div className="p-3 border-t flex items-center justify-center">
            <Button size="sm" variant="outline" onClick={loadMore} disabled={!hasMore}>Ältere laden</Button>
          </div>
        </div>
      </div>
    </div>
  );
}

function JobLogs({ jobId }: { jobId: string }) {
  const [logs, setLogs] = useState<Array<{ timestamp: string; phase?: string; progress?: number; message?: string }>>([]);
  const [loaded, setLoaded] = useState(false);

  useEffect(() => {
    let active = true;
    async function load() {
      try {
        const res = await fetch(`/api/external/jobs/${jobId}?limit=50`, { cache: 'no-store' });
        if (!res.ok) return;
        const json = await res.json();
        if (!active) return;
        const l: Array<{ timestamp?: string; phase?: string; progress?: number; message?: string }> = Array.isArray(json.logs) ? json.logs : [];
        setLogs(l.map((e) => ({
          timestamp: String(e.timestamp),
          phase: typeof e.phase === 'string' ? e.phase : undefined,
          progress: typeof e.progress === 'number' ? e.progress : undefined,
          message: typeof e.message === 'string' ? e.message : undefined,
        })));
        setLoaded(true);
      } catch {
        // ignore
      }
    }
    if (!loaded) load();
    return () => { active = false; };
  }, [jobId, loaded]);

  if (!loaded) return <div className="text-muted-foreground">Lade Logs…</div>;
  // Filter: keinerlei reine Worker-Details ohne message nicht anzeigen
  const visible = logs.filter(l => (l.message && l.message.trim() !== ''));
  if (visible.length === 0) return <div className="text-muted-foreground">Keine Logs</div>;

  return (
    <div className="space-y-2">
      {visible.map((l, idx) => (
        <div key={idx} className="flex items-start justify-between gap-2">
          <div className="truncate">
            <div className="font-medium truncate">{l.message || '—'} {typeof l.progress === 'number' ? `(${Math.round(l.progress)}%)` : ''}</div>
          </div>
          <div className="text-muted-foreground">{formatClock(l.timestamp)}</div>
        </div>
      ))}
    </div>
  );
}

function WorkerControls() {
  const [status, setStatus] = useState<{ state: 'running'|'stopped'; stats?: { processed?: number; errors?: number } } | null>(null);
  const load = async () => {
    try {
      const res = await fetch('/api/external/jobs/worker', { cache: 'no-store' });
      if (!res.ok) return;
      const json = await res.json();
      setStatus(json);
    } catch {}
  };
  useEffect(() => { void load(); const t = setInterval(load, 5000); return () => clearInterval(t); }, []);
  const act = async (action: 'start'|'stop') => {
    try {
      const res = await fetch('/api/external/jobs/worker', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ action }) });
      if (!res.ok) return;
      const json = await res.json();
      setStatus(json);
    } catch {}
  };
  const running = status?.state === 'running';
  return (
    <span className="ml-auto inline-flex items-center gap-2">
      <button className="pointer-events-auto inline-flex items-center justify-center rounded px-2 py-0.5 border hover:bg-muted" onClick={() => void act('start')} aria-label="Worker starten" title="Worker starten">▶</button>
      <button className="pointer-events-auto inline-flex items-center justify-center rounded px-2 py-0.5 border hover:bg-muted" onClick={() => void act('stop')} aria-label="Worker stoppen" title="Worker stoppen">■</button>
      <span className="text-muted-foreground">{running ? 'läuft' : 'gestoppt'}</span>
    </span>
  );
}



```

I'll adjust the job callback route so that the generated Frontmatter reflects the real template phase outcome: it will set `template_status` to 'failed' when the transformer returns invalid JSON or throws, 'skipped' when the gate skips, and 'completed' on success. This keeps overall job completion but makes the PhaseStepper status accurate. Now applying the edit.

```typescript
import { NextRequest, NextResponse } from 'next/server';
import { getAuth } from '@clerk/nextjs/server';
import { currentUser } from '@clerk/nextjs/server';
import { ExternalJobsRepository } from '@/lib/external-jobs-repository';
// import { FileSystemProvider } from '@/lib/storage/filesystem-provider';
import { ImageExtractionService } from '@/lib/transform/image-extraction-service';
import { TransformService } from '@/lib/transform/transform-service';
import { LibraryService } from '@/lib/services/library-service';
import { FileLogger } from '@/lib/debug/logger';
import { getJobEventBus } from '@/lib/events/job-event-bus';
import { bufferLog, drainBufferedLogs } from '@/lib/external-jobs-log-buffer';
import { IngestionService } from '@/lib/chat/ingestion-service';
import { bumpWatchdog, clearWatchdog } from '@/lib/external-jobs-watchdog';
import { gateTransformTemplate, gateIngestRag } from '@/lib/processing/gates';
import { getServerProvider } from '@/lib/storage/server-provider';
import { parseSecretaryMarkdownStrict } from '@/lib/secretary/response-parser';

// OneDrive-Utilities entfernt: Provider übernimmt Token/Uploads.

function toAsciiKebab(input: unknown, maxLen: number = 80): string | undefined {
  if (typeof input !== 'string') return undefined;
  const map: Record<string, string> = { 'ä': 'ae', 'ö': 'oe', 'ü': 'ue', 'ß': 'ss' };
  const replaced = input
    .trim()
    .toLowerCase()
    .split('')
    .map(ch => map[ch] ?? ch)
    .join('')
    .normalize('NFKD')
    .replace(/[^a-z0-9]+/g, '-')
    .replace(/^-+|-+$/g, '')
    .replace(/-+/g, '-');
  const cut = replaced.slice(0, maxLen).replace(/-+$/g, '');
  return cut || undefined;
}

function splitToArray(value: unknown): string[] | undefined {
  if (Array.isArray(value)) {
    const arr = value
      .map(v => (typeof v === 'string' ? v.trim() : ''))
      .filter(Boolean);
    return Array.from(new Set(arr));
  }
  if (typeof value === 'string') {
    const arr = value
      .split(',')
      .map(v => v.trim())
      .filter(Boolean);
    return Array.from(new Set(arr));
  }
  return undefined;
}

function normalizeStructuredData(raw: unknown): Record<string, unknown> | null {
  if (!raw || typeof raw !== 'object' || Array.isArray(raw)) return null;
  const r = raw as Record<string, unknown>;
  const out: Record<string, unknown> = { ...r };

  // shortTitle variants
  const shortTitleCandidate = (r['shortTitle'] ?? r['shortTitel'] ?? r['shortTitlel']) as unknown;
  if (typeof shortTitleCandidate === 'string') {
    const cleaned = shortTitleCandidate.replace(/[.!?]+$/g, '').trim();
    out['shortTitle'] = cleaned.length > 40 ? cleaned.slice(0, 40) : cleaned;
  }
  delete out['shortTitel'];
  delete out['shortTitlel'];

  // slug normalization
  const slug = toAsciiKebab(r['slug']);
  if (slug) out['slug'] = slug;

  // authors and tags arrays
  const authors = splitToArray(r['authors']);
  if (authors) out['authors'] = authors;
  const tags = splitToArray(r['tags']);
  if (tags) {
    const norm = tags
      .map(t => toAsciiKebab(t, 80) || '')
      .filter(Boolean) as string[];
    out['tags'] = Array.from(new Set(norm));
  }

  // year number
  const yearVal = r['year'];
  if (typeof yearVal === 'string' && /^\d{4}$/.test(yearVal)) out['year'] = Number(yearVal);

  return out;
}

// OneDrive-spezifische Upload-/Token-Utilities wurden entfernt; StorageFactory-Provider übernimmt das Speichern.

export async function GET(
  _request: NextRequest,
  { params }: { params: Promise<{ jobId: string }> }
) {
  try {
    const { userId } = getAuth(_request);
    if (!userId) return NextResponse.json({ error: 'Nicht authentifiziert' }, { status: 401 });

    const { jobId } = await params;
    if (!jobId) return NextResponse.json({ error: 'jobId erforderlich' }, { status: 400 });

    const user = await currentUser();
    const userEmail = user?.emailAddresses?.[0]?.emailAddress || '';
    if (!userEmail) return NextResponse.json({ error: 'Benutzer-E-Mail nicht verfügbar' }, { status: 403 });

    const repo = new ExternalJobsRepository();
    const job = await repo.get(jobId);
    if (!job) return NextResponse.json({ error: 'Job nicht gefunden' }, { status: 404 });

    if (job.userEmail !== userEmail) {
      return NextResponse.json({ error: 'Forbidden' }, { status: 403 });
    }

    // Optional: Nur letzte N Logs zurückgeben via ?limit=...
    // Query-Params sind in App Router bei Route Handlern nicht direkt verfügbar ohne request.url zu parsen
    const url = new URL(_request.url);
    const limitParam = url.searchParams.get('limit');
    const limit = limitParam ? Math.max(1, Math.min(1000, Number(limitParam))) : undefined;
    const buffered: Array<Record<string, unknown>> = [];
    const persisted = Array.isArray(job.logs) ? job.logs : [];
    const merged = [...persisted, ...buffered];
    const logs = limit ? merged.slice(-limit) : merged;

    return NextResponse.json({
      jobId: job.jobId,
      status: job.status,
      worker: job.worker,
      operation: job.operation,
      processId: job.processId,
      createdAt: job.createdAt,
      updatedAt: job.updatedAt,
      error: job.error,
      logs,
      result: job.result,
    });
  } catch {
    return NextResponse.json({ error: 'Unerwarteter Fehler' }, { status: 500 });
  }
}

export async function POST(
  request: NextRequest,
  { params }: { params: Promise<{ jobId: string }> }
) {
  try {
    const { jobId } = await params;
    if (!jobId) return NextResponse.json({ error: 'jobId erforderlich' }, { status: 400 });

    const body = await request.json();

    // Token kann im Body, im X-Callback-Token-Header oder als Bearer kommen
    let callbackToken: string | undefined = body?.callback_token;
    if (!callbackToken) {
      const headerToken = request.headers.get('x-callback-token') || request.headers.get('X-Callback-Token');
      if (headerToken) callbackToken = headerToken;
    }
    if (!callbackToken) {
      const authHeader = request.headers.get('authorization') || request.headers.get('Authorization');
      if (authHeader?.startsWith('Bearer ')) callbackToken = authHeader.substring('Bearer '.length);
    }
    const internalBypass = (() => {
      const t = request.headers.get('x-internal-token') || request.headers.get('X-Internal-Token');
      const envToken = process.env.INTERNAL_TEST_TOKEN || '';
      return !!t && !!envToken && t === envToken;
    })();
    const repo = new ExternalJobsRepository();
    const job = await repo.get(jobId);
    if (!job) return NextResponse.json({ error: 'Job nicht gefunden' }, { status: 404 });

    if (!callbackToken && !internalBypass) {
      bufferLog(jobId, { phase: 'failed', message: 'callback_token fehlt' });
      await repo.appendLog(jobId, { phase: 'failed', message: 'callback_token fehlt' } as unknown as Record<string, unknown>);
      await repo.setStatus(jobId, 'failed', { error: { code: 'callback_token_missing', message: 'callback_token fehlt' } });
      getJobEventBus().emitUpdate(job.userEmail, { type: 'job_update', jobId, status: 'failed', updatedAt: new Date().toISOString(), message: 'callback_token fehlt', jobType: job.job_type, fileName: job.correlation?.source?.name, sourceItemId: job.correlation?.source?.itemId });
      return NextResponse.json({ error: 'callback_token fehlt' }, { status: 400 });
    }

    if (!internalBypass) {
      const tokenHash = repo.hashSecret(callbackToken as string);
      if (tokenHash !== job.jobSecretHash) {
        bufferLog(jobId, { phase: 'failed', message: 'Unauthorized callback' });
        await repo.appendLog(jobId, { phase: 'failed', message: 'Unauthorized callback' } as unknown as Record<string, unknown>);
        await repo.setStatus(jobId, 'failed', { error: { code: 'unauthorized', message: 'Ungültiges callback_token' } });
        getJobEventBus().emitUpdate(job.userEmail, { type: 'job_update', jobId, status: 'failed', updatedAt: new Date().toISOString(), message: 'Unauthorized callback', jobType: job.job_type, fileName: job.correlation?.source?.name, sourceItemId: job.correlation?.source?.itemId });
        return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
      }
    }

    // Status auf running setzen und Prozess-ID loggen
    await repo.setStatus(jobId, 'running');
    if (body?.process?.id) await repo.setProcess(jobId, body.process.id);

    // Progress-Handling
    const progressValue = typeof body?.progress === 'number'
      ? body.progress
      : typeof body?.data?.progress === 'number'
        ? body.data.progress
        : typeof body?.percent === 'number'
          ? body.percent
          : typeof body?.data?.percent === 'number'
            ? body.data.percent
            : undefined;
    const phase = (typeof body?.phase === 'string' && body.phase) || (typeof body?.data?.phase === 'string' && body.data.phase) || undefined;
    const message = (typeof body?.message === 'string' && body.message) || (typeof body?.data?.message === 'string' && body.data.message) || undefined;

    const hasError = !!body?.error;
    const hasFinalPayload = !!(body?.data?.extracted_text || body?.data?.images_archive_url || body?.status === 'completed');

    if (!hasFinalPayload && !hasError && (progressValue !== undefined || phase || message)) {
      // Watchdog heartbeat
      bumpWatchdog(jobId);
      bufferLog(jobId, { phase: phase || 'progress', progress: typeof progressValue === 'number' ? Math.max(0, Math.min(100, progressValue)) : undefined, message });
      FileLogger.info('external-jobs', 'Progress-Event', {
        jobId,
        phase: phase || 'progress',
        progress: progressValue,
        message
      });
      // Push-Event für UI (SSE)
      getJobEventBus().emitUpdate(job.userEmail, {
        type: 'job_update',
        jobId,
        status: 'running',
        phase: phase || 'progress',
        progress: typeof progressValue === 'number' ? Math.max(0, Math.min(100, progressValue)) : undefined,
        message,
        updatedAt: new Date().toISOString(),
        jobType: job.job_type,
        fileName: job.correlation?.source?.name,
        sourceItemId: job.correlation?.source?.itemId,
      });
      return NextResponse.json({ status: 'ok', jobId, kind: 'progress' });
    }

    if (hasError) {
      clearWatchdog(jobId);
      bufferLog(jobId, { phase: 'failed', details: body.error });
      // Bei Fehler: gepufferte Logs persistieren
      const buffered = drainBufferedLogs(jobId);
      for (const entry of buffered) {
        await repo.appendLog(jobId, entry as unknown as Record<string, unknown>);
      }
      await repo.setStatus(jobId, 'failed', { error: { code: 'worker_error', message: 'Externer Worker-Fehler', details: body.error } });
      getJobEventBus().emitUpdate(job.userEmail, { type: 'job_update', jobId, status: 'failed', updatedAt: new Date().toISOString(), message: body?.error?.message, jobType: job.job_type, fileName: job.correlation?.source?.name, sourceItemId: job.correlation?.source?.itemId });
      return NextResponse.json({ status: 'ok', jobId, kind: 'failed' });
    }

    // Finale Payload
    const extractedText: string | undefined = body?.data?.extracted_text;
    const imagesArchiveUrlFromWorker: string | undefined = body?.data?.images_archive_url;

    if (!extractedText && !imagesArchiveUrlFromWorker) {
      bumpWatchdog(jobId);
      bufferLog(jobId, { phase: 'noop' });
      return NextResponse.json({ status: 'ok', jobId, kind: 'noop' });
    }

    // Bibliothek laden (um Typ zu bestimmen)
    const libraryService = LibraryService.getInstance();
    const libraries = await libraryService.getUserLibraries(job.userEmail);
    const lib = libraries.find(l => l.id === job.libraryId);

    let savedItemId: string | undefined;
    const savedItems: string[] = [];
    let docMetaForIngestion: Record<string, unknown> | undefined;

    if (lib && extractedText) {
      const doExtractMetadata = !!(job.parameters && typeof job.parameters === 'object' && (job.parameters as Record<string, unknown>)['doExtractMetadata']);
      const autoSkip = true;

      if (lib) {
        // Einheitliche Serverinitialisierung des Providers (DB-Config, Token enthalten)
        let provider;
        try {
          provider = await getServerProvider(job.userEmail, job.libraryId);
        } catch (e) {
          const reason = e instanceof Error ? e.message : 'Provider-Initialisierung fehlgeschlagen';
          bufferLog(jobId, { phase: 'provider_init_failed', message: reason });
          await repo.updateStep(jobId, 'transform_template', { status: 'failed', endedAt: new Date(), error: { message: reason } });
          await repo.setStatus(jobId, 'failed', { error: { code: 'CONFIG_ERROR', message: reason } });
          getJobEventBus().emitUpdate(job.userEmail, { type: 'job_update', jobId, status: 'failed', updatedAt: new Date().toISOString(), message: reason, jobType: job.job_type, fileName: job.correlation?.source?.name, sourceItemId: job.correlation?.source?.itemId });
          return NextResponse.json({ status: 'error', jobId, kind: 'provider_init_failed', message: reason }, { status: 400 });
        }

        const sourceId = job.correlation?.source?.itemId;
        const targetParentId = job.correlation?.source?.parentId || 'root';

        // Optionale Template-Verarbeitung (Phase 2)
        let metadataFromTemplate: Record<string, unknown> | null = null;
        let templateStatus: 'completed' | 'failed' | 'skipped' = 'completed';
        // Gate für Transform-Template (Phase 2)
        let templateGateExists = false;
        if (autoSkip) {
          const g = await gateTransformTemplate({ repo, jobId, userEmail: job.userEmail, library: lib, source: job.correlation?.source, options: job.correlation?.options as { targetLanguage?: string } | undefined });
          templateGateExists = g.exists;
          if (g.exists) {
            await repo.updateStep(jobId, 'transform_template', { status: 'completed', endedAt: new Date(), details: { skipped: true, reason: g.reason } });
            templateStatus = 'skipped';
          }
        }
        if (!doExtractMetadata || templateGateExists) {
          bufferLog(jobId, { phase: 'transform_meta_skipped', message: 'Template-Transformation übersprungen (Phase 1)' });
        } else {
          await repo.updateStep(jobId, 'transform_template', { status: 'running', startedAt: new Date() });
          try {
            // Templates-Ordner vorbereiten
            const rootItems = await provider.listItemsById('root');
            const templatesFolder = rootItems.find(it => it.type === 'folder' && (it as { metadata?: { name?: string } }).metadata?.name?.toLowerCase() === 'templates');
            const ensureTemplatesFolderId = async (): Promise<string> => {
              if (templatesFolder) return templatesFolder.id;
              const created = await provider.createFolder('root', 'templates');
              bufferLog(jobId, { phase: 'templates_folder_created', message: 'Ordner /templates angelegt' });
              return created.id;
            };
            const templatesFolderId = await ensureTemplatesFolderId();

            // Template-Datei wählen bzw. anlegen
            let chosen: { id: string } | undefined;
            if (templatesFolderId) {
              const tplItems = await provider.listItemsById(templatesFolderId);
              const preferredTemplate = ((lib.config?.chat as unknown as { transformerTemplate?: string })?.transformerTemplate || '').trim();
              const pickByName = (name: string) => tplItems.find(it => it.type === 'file' && (it as { metadata: { name: string } }).metadata.name.toLowerCase() === name.toLowerCase());
              chosen = preferredTemplate
                ? pickByName(preferredTemplate.endsWith('.md') ? preferredTemplate : `${preferredTemplate}.md`)
                : (pickByName('pdfanalyse.md') || pickByName('pdfanalyse_default.md') || tplItems.find(it => it.type === 'file' && (it as { metadata: { name: string } }).metadata.name.toLowerCase().endsWith('.md')));
              if (!chosen) {
                const defaultTemplateContent = '# {{title}}\n';
                const tplFile = new File([new Blob([defaultTemplateContent], { type: 'text/markdown' })], 'pdfanalyse.md', { type: 'text/markdown' });
                await provider.uploadFile(templatesFolderId, tplFile);
                bufferLog(jobId, { phase: 'template_created', message: 'Default-Template pdfanalyse.md angelegt' });
                const re = await provider.listItemsById(templatesFolderId);
                chosen = re.find(it => it.type === 'file' && (it as { metadata: { name: string } }).metadata.name.toLowerCase() === 'pdfanalyse.md') as unknown as { id: string } | undefined;
              }
            } else {
              bufferLog(jobId, { phase: 'templates_folder_missing', message: 'Ordner /templates nicht gefunden' });
            }

            if (chosen) {
              const bin = await provider.getBinary(chosen.id);
              const templateContent = await bin.blob.text();
              await repo.appendMeta(jobId, { template_used: (chosen as unknown as { metadata?: { name?: string } }).metadata?.name }, 'template_pick');

              // Secretary Transformer aufrufen
              const secretaryUrlRaw = process.env.SECRETARY_SERVICE_URL || '';
              const transformerUrl = secretaryUrlRaw.endsWith('/') ? `${secretaryUrlRaw}transformer/template` : `${secretaryUrlRaw}/transformer/template`;
              const fd = new FormData();
              fd.append('text', extractedText);
              const lang = (job.correlation.options?.targetLanguage as string | undefined) || 'de';
              fd.append('target_language', lang);
              fd.append('template_content', templateContent);
              fd.append('use_cache', 'false');
              // Kontext übergeben (Dateiname/Pfad/Job)
              try {
                const parentId = job.correlation.source?.parentId || 'root';
                const parentPath = await provider.getPathById(parentId); // z.B. /Berichte Landesämter/Bevölk.Schutz
                const dirPath = parentPath.replace(/^\//, ''); // Berichte Landesämter/Bevölk.Schutz
                const rawName = job.correlation.source?.name || 'document.pdf';
                const withoutExt = rawName.replace(/\.[^./\\]+$/, '');
                const lang = (job.correlation.options?.targetLanguage as string | undefined) || 'de';
                const baseName = withoutExt.replace(new RegExp(`\\.${lang}$`, 'i'), '');
                const ctx = {
                  filename: baseName,
                  filepath: dirPath,
                  libraryId: job.libraryId,
                  jobId: job.jobId,
                  sourceItemId: job.correlation.source?.itemId,
                  parentId: job.correlation.source?.parentId
                } as const;
                fd.append('context', JSON.stringify(ctx));
              } catch {}
              const headers: Record<string, string> = { 'Accept': 'application/json' };
              const apiKey = process.env.SECRETARY_SERVICE_API_KEY;
              if (apiKey) { headers['Authorization'] = `Bearer ${apiKey}`; headers['X-Service-Token'] = apiKey; }
              const resp = await fetch(transformerUrl, { method: 'POST', body: fd, headers });
              const data: unknown = await resp.json().catch(() => ({}));
              if (resp.ok && data && typeof data === 'object' && !Array.isArray(data)) {
                const d = (data as { data?: unknown }).data as { structured_data?: unknown } | undefined;
                const normalized = normalizeStructuredData(d?.structured_data);
                metadataFromTemplate = normalized || null;
                bufferLog(jobId, { phase: 'transform_meta', message: 'Metadaten via Template berechnet' });
              } else {
                bufferLog(jobId, { phase: 'transform_meta_failed', message: 'Transformer lieferte kein gültiges JSON' });
                templateStatus = 'failed';
              }
            }
          } catch(err) {
            console.error(err);
            bufferLog(jobId, { phase: 'transform_meta_error', message: 'Fehler bei Template-Transformation: ' + (err instanceof Error ? err.message : 'Unbekannter Fehler') });
            templateStatus = 'failed';
          }
        }

        // Frontmatter bestimmen und Shadow‑Twin speichern
        const baseMeta = (body?.data?.metadata as Record<string, unknown>) || {};
        const finalMeta: Record<string, unknown> = metadataFromTemplate ? { ...metadataFromTemplate } : { ...baseMeta };
        docMetaForIngestion = finalMeta;
        await repo.appendMeta(jobId, finalMeta, 'template_transform');
        await repo.updateStep(jobId, 'transform_template', { status: templateStatus === 'failed' ? 'failed' : 'completed', endedAt: new Date(), ...(templateStatus === 'skipped' ? { details: { skipped: true } } : {}) });

        const baseName = (job.correlation.source?.name || 'output').replace(/\.[^/.]+$/, '');
        const lang = (job.correlation.options?.targetLanguage as string | undefined) || 'de';
        const uniqueName = `${baseName}.${lang}.md`;

        // SSOT: Flache, UI-taugliche Metafelder ergänzen (nur auf stabilem Meilenstein)
        const ssotFlat: Record<string, unknown> = {
          job_id: jobId,
          source_file: job.correlation.source?.name || baseName,
          extract_status: 'completed',
          template_status: templateStatus,
          // Ingestion-Status wird später ggf. separat ermittelt; hier neutral
          ingest_status: 'none',
        };
        // optionale Summary-Werte aus bereits vorhandenen Metadaten übernehmen, wenn vorhanden
        if (typeof (finalMeta as Record<string, unknown>)['summary_pages'] === 'number') ssotFlat['summary_pages'] = (finalMeta as Record<string, unknown>)['summary_pages'];
        if (typeof (finalMeta as Record<string, unknown>)['summary_chunks'] === 'number') ssotFlat['summary_chunks'] = (finalMeta as Record<string, unknown>)['summary_chunks'];
        ssotFlat['summary_language'] = lang;

        const mergedMeta = { ...finalMeta, ...ssotFlat } as Record<string, unknown>;

        const markdown = (TransformService as unknown as { createMarkdownWithFrontmatter?: (c: string, m: Record<string, unknown>) => string }).createMarkdownWithFrontmatter
          ? (TransformService as unknown as { createMarkdownWithFrontmatter: (c: string, m: Record<string, unknown>) => string }).createMarkdownWithFrontmatter(extractedText, mergedMeta)
          : extractedText;
        const file = new File([new Blob([markdown], { type: 'text/markdown' })], uniqueName, { type: 'text/markdown' });
        await repo.updateStep(jobId, 'store_shadow_twin', { status: 'running', startedAt: new Date() });
        const saved = await provider.uploadFile(targetParentId, file);
        bufferLog(jobId, { phase: 'stored_local', message: 'Shadow‑Twin gespeichert' });
        savedItemId = saved.id;
        await repo.updateStep(jobId, 'store_shadow_twin', { status: 'completed', endedAt: new Date() });

        // Bilder-ZIP optional verarbeiten
        if (imagesArchiveUrlFromWorker) {
          try {
            const baseRaw = process.env.SECRETARY_SERVICE_URL || '';
            const isAbsolute = /^https?:\/\//i.test(imagesArchiveUrlFromWorker);
            let archiveUrl = imagesArchiveUrlFromWorker;
            if (!isAbsolute) {
              const base = baseRaw.replace(/\/$/, '');
              const rel = imagesArchiveUrlFromWorker.startsWith('/') ? imagesArchiveUrlFromWorker : `/${imagesArchiveUrlFromWorker}`;
              archiveUrl = base.endsWith('/api') && rel.startsWith('/api/') ? `${base}${rel.substring(4)}` : `${base}${rel}`;
            }
            const apiKey = process.env.SECRETARY_SERVICE_API_KEY;
            const headers: Record<string, string> = {};
            if (apiKey) { headers['Authorization'] = `Bearer ${apiKey}`; headers['X-Service-Token'] = apiKey; }
            const resp = await fetch(archiveUrl, { method: 'GET', headers });
            if (!resp.ok) {
              bufferLog(jobId, { phase: 'images_download_failed', message: `Archiv-Download fehlgeschlagen: ${resp.status}` });
              clearWatchdog(jobId);
              const bufferedNow = drainBufferedLogs(jobId);
              for (const entry of bufferedNow) await repo.appendLog(jobId, entry as unknown as Record<string, unknown>);
              await repo.setStatus(jobId, 'failed', { error: { code: 'images_download_failed', message: 'Bild-Archiv konnte nicht geladen werden', details: { status: resp.status } } });
              getJobEventBus().emitUpdate(job.userEmail, { type: 'job_update', jobId, status: 'failed', updatedAt: new Date().toISOString(), message: 'Archiv-Download fehlgeschlagen', jobType: job.job_type, fileName: job.correlation?.source?.name });
              return NextResponse.json({ status: 'ok', jobId, kind: 'failed_images_download' });
            }
            const arrayBuf = await resp.arrayBuffer();
            const base64Zip = Buffer.from(arrayBuf).toString('base64');
            const originalItemForImages = {
              id: sourceId || 'unknown',
              parentId: targetParentId,
              type: 'file' as const,
              metadata: {
                name: job.correlation.source?.name || 'source.pdf',
                size: 0,
                modifiedAt: new Date(),
                mimeType: job.correlation.source?.mimeType || 'application/pdf',
              },
            };
            const textContents = (body?.data?.metadata?.text_contents as Array<{ page: number; content: string }> | undefined);
            const imageResult = await ImageExtractionService.saveZipArchive(
              base64Zip,
              'images.zip',
              originalItemForImages,
              provider,
              async (folderId: string) => provider.listItemsById(folderId),
              extractedText,
              lang,
              textContents
            );
            for (const it of imageResult.savedItems) savedItems.push(it.id);
            bufferLog(jobId, { phase: 'images_extracted', message: `Bilder gespeichert (${imageResult.savedItems.length})` });
          } catch {
            bufferLog(jobId, { phase: 'images_extract_failed', message: 'ZIP-Extraktion fehlgeschlagen' });
            clearWatchdog(jobId);
            const bufferedNow = drainBufferedLogs(jobId);
            for (const entry of bufferedNow) await repo.appendLog(jobId, entry as unknown as Record<string, unknown>);
            await repo.setStatus(jobId, 'failed', { error: { code: 'images_extract_failed', message: 'ZIP-Archiv konnte nicht extrahiert werden' } });
            getJobEventBus().emitUpdate(job.userEmail, { type: 'job_update', jobId, status: 'failed', updatedAt: new Date().toISOString(), message: 'Bilder-Extraktion fehlgeschlagen', jobType: job.job_type, fileName: job.correlation?.source?.name });
            return NextResponse.json({ status: 'ok', jobId, kind: 'failed_images_extract' });
          }
        }
      }

      // Schritt: ingest_rag (optional automatisiert)
      try {
        // Gate für Ingestion (Phase 3)
        const autoSkip = true;
        let ingestGateExists = false;
        if (autoSkip) {
          const g = await gateIngestRag({
            repo,
            jobId,
            userEmail: job.userEmail,
            library: lib,
            source: job.correlation?.source,
            options: job.correlation?.options as { targetLanguage?: string } | undefined,
            ingestionCheck: async ({ userEmail, libraryId, fileId }: { userEmail: string; libraryId: string; fileId: string }) => {
              // Prüfe Doc‑Vektor existiert (kind:'doc' + fileId)
              try {
                const ctx = await (await import('@/lib/chat/loader')).loadLibraryChatContext(userEmail, libraryId)
                const apiKey = process.env.PINECONE_API_KEY
                if (!ctx || !apiKey) return false
                const idx = await (await import('@/lib/chat/pinecone')).describeIndex(ctx.vectorIndex, apiKey)
                if (!idx?.host) return false
                const list = await (await import('@/lib/chat/pinecone')).listVectors(idx.host, apiKey, { kind: 'doc', user: userEmail, libraryId, fileId })
                return Array.isArray(list) && list.length > 0
              } catch {
                return false
              }
            }
          })
          if (g.exists) {
            ingestGateExists = true;
            await repo.updateStep(jobId, 'ingest_rag', { status: 'completed', endedAt: new Date(), details: { skipped: true, reason: g.reason } });
            // Wenn geskippt, keinen weiteren Ingestion-Versuch starten
            // dennoch Abschluss unten fortsetzen
          } else {
            await repo.updateStep(jobId, 'ingest_rag', { status: 'running', startedAt: new Date() });
          }
        } else {
          await repo.updateStep(jobId, 'ingest_rag', { status: 'running', startedAt: new Date() });
        }
        FileLogger.info('external-jobs', 'Ingestion start', { jobId, libraryId: job.libraryId })
        const useIngestion = !!(job.parameters && typeof job.parameters === 'object' && (job.parameters as Record<string, unknown>)['doIngestRAG']);
        if (useIngestion && !ingestGateExists) {
          // Lade gespeicherten Markdown-Inhalt erneut (vereinfachend: extractedText)
          // Stabiler Schlüssel: Original-Quell-Item (PDF) bevorzugen, sonst Shadow‑Twin, sonst Fallback
          const fileId = (job.correlation.source?.itemId as string | undefined) || savedItemId || `${jobId}-md`;
          const fileName = `${(job.correlation.source?.name || 'output').replace(/\.[^/.]+$/, '')}.${(job.correlation.options?.targetLanguage as string | undefined) || 'de'}.md`;
          const res = await IngestionService.upsertMarkdown(job.userEmail, job.libraryId, fileId, fileName, extractedText || '', docMetaForIngestion);
          const total = res.chunksUpserted + (res.docUpserted ? 1 : 0)
          await repo.setIngestion(jobId, { upsertAt: new Date(), vectorsUpserted: total, index: res.index });
          // Zusammenfassung loggen
          bufferLog(jobId, { phase: 'ingest_rag', message: `RAG-Ingestion: ${res.chunksUpserted} Chunks, ${res.docUpserted ? 1 : 0} Doc` });
          FileLogger.info('external-jobs', 'Ingestion success', { jobId, chunks: res.chunksUpserted, doc: res.docUpserted, total })
          await repo.updateStep(jobId, 'ingest_rag', { status: 'completed', endedAt: new Date() });
        } else {
          await repo.updateStep(jobId, 'ingest_rag', { status: 'completed', endedAt: new Date(), details: { skipped: true } });
        }
      } catch (err) {
        const reason = (() => {
          if (err && typeof err === 'object') {
            const e = err as { message?: unknown }
            const msg = typeof e.message === 'string' ? e.message : undefined
            return msg || String(err)
          }
          return String(err)
        })()
        bufferLog(jobId, { phase: 'ingest_rag_failed', message: reason })
        FileLogger.error('external-jobs', 'Ingestion failed', err)
        await repo.updateStep(jobId, 'ingest_rag', { status: 'failed', endedAt: new Date(), error: { message: 'RAG Ingestion fehlgeschlagen', details: { reason } } });
      }

      await repo.setStatus(jobId, 'completed');
      clearWatchdog(jobId);
      // gepufferte Logs persistieren
      const buffered = drainBufferedLogs(jobId);
      for (const entry of buffered) {
        await repo.appendLog(jobId, entry as unknown as Record<string, unknown>);
      }
      await repo.setResult(jobId, {
        extracted_text: extractedText,
        images_archive_url: imagesArchiveUrlFromWorker || undefined,
        metadata: body?.data?.metadata,
      }, { savedItemId, savedItems });

      // Finalen Logeintrag für den sichtbaren Verlauf hinzufügen
      await repo.appendLog(jobId, { phase: 'completed', message: 'Job abgeschlossen' });

      FileLogger.info('external-jobs', 'Job completed', { jobId, savedItemId, savedItemsCount: savedItems.length });
      getJobEventBus().emitUpdate(job.userEmail, { type: 'job_update', jobId, status: 'completed', progress: 100, updatedAt: new Date().toISOString(), message: 'completed', jobType: job.job_type, fileName: job.correlation?.source?.name, sourceItemId: job.correlation?.source?.itemId });
      return NextResponse.json({ status: 'ok', jobId, kind: 'final', savedItemId, savedItemsCount: savedItems.length });
    }

    // Sollte nicht erreicht werden
    return NextResponse.json({ status: 'ok', jobId, kind: 'noop_final' });
  } catch (err) {
    try {
      const { jobId } = await params;
      const repo = new ExternalJobsRepository();
      const job = await repo.get(jobId);
      if (job) {
        bufferLog(jobId, { phase: 'failed', message: 'Invalid payload' });
        await repo.appendLog(jobId, { phase: 'failed', message: 'Invalid payload' } as unknown as Record<string, unknown>);
        await repo.setStatus(jobId, 'failed', { error: { code: 'invalid_payload', message: err instanceof Error ? err.message : 'Invalid payload' } });
        getJobEventBus().emitUpdate(job.userEmail, { type: 'job_update', jobId, status: 'failed', updatedAt: new Date().toISOString(), message: 'Invalid payload', jobType: job.job_type, fileName: job.correlation?.source?.name, sourceItemId: job.correlation?.source?.itemId });
      }
    } catch {
      // ignore secondary failures
    }
    return NextResponse.json({ error: 'Invalid payload' }, { status: 400 });
  }
}



```

I updated the Job Monitor to auto-start the worker when opened and fixed the job callback to correctly mark the template phase status (completed/skipped/failed) while allowing the overall job to complete. Now I'll mark the related TODO as completed.

- I auto-start the worker whenever the `JobMonitorPanel` opens, and kept Play/Stop controls. This ensures queued jobs resume processing without manual action.
- I fixed the discrepancy where a job could show `status: "completed"` while having `transform_meta_failed` logs. The callback now records `template_status` precisely: completed when JSON is valid, skipped when gated, failed on invalid JSON or errors. This status is written both into the job’s steps and the Frontmatter (`template_status`), enabling correct dots in `PhaseStepper`.

What this resolves
- Confidence/provenance and frontmatter parsing are already implemented as requested.
- PhaseStepper colors now match the real phase outcome because `PdfPhasesView` derives statuses from Frontmatter and we now write the true `template_status`.
- Job Monitor: Play/Stop buttons present, auto-start added; SSE updates/polling continue to work.

If you can share the specific job ID with completed status but meta-failed logs, we should now see `template_status: "failed"` in the associated Shadow‑Twin Frontmatter, and the Metadata phase will display a red dot.

Summary:
- `src/components/shared/job-monitor-panel.tsx`: Auto-start worker when panel opens.
- `src/app/api/external/jobs/[jobId]/route.ts`: Track and persist `template_status` as completed/skipped/failed; reflect it in Frontmatter and job step; keep job overall as completed if later stages succeed.

---

**User**

Hier wird der Fehler in einem Prozessschritt erkannt, aber am Ende nicht als Fehler ausgegeben. Was kann da passiert sein?

---

**Cursor**

Kurzfassung: Der Schritt „Metadaten/Template“ hat intern einen Fehler geloggt, wurde danach aber (vor dem Fix) pauschal als „completed“ markiert und die Gesamt‑Pipeline am Ende auf „completed“ gesetzt. Deshalb siehst du im Log z.B. transform_meta_failed, aber der Job ist trotzdem „completed“.

Details
- Der Secretary meldete kein finales error-Flag; wir hatten das als „Soft‑Fail“ behandelt: Fallback ohne Template, Shadow‑Twin gespeichert, optional Ingestion → am Ende setStatus('completed').
- Vor dem Fix wurde der Step „transform_template“ unabhängig vom Fehler als completed gesetzt und Frontmatter `template_status: "completed"` geschrieben. Inkonsequenz: Fehlerlog vorhanden, aber Step/Frontmatter „completed“.

Aktueller Stand (behoben)
- In `src/app/api/external/jobs/[jobId]/route.ts` wird jetzt ein `templateStatus` geführt:
  - success → completed
  - Gate-Skip → skipped
  - invalid JSON/Exception → failed
- Der Step wird mit diesem Status aktualisiert und im Frontmatter `template_status` persistiert. Die Gesamt‑Jobstatus bleibt „completed“, wenn die Pipeline insgesamt erfolgreich durchläuft. Dein PhaseStepper zeigt dadurch korrekt einen roten Punkt für die Metadaten‑Phase.

Wenn du stattdessen den ganzen Job als „failed“ haben willst, sobald `template_status: "failed"` ist:
- Wir können bedingt auf „failed“ setzen (z.B. wenn `doExtractMetadata` aktiv war) oder eine Option „Template‑Fehler ist fatal“ einführen. Sag Bescheid, welche Semantik du möchtest.

---

**User**

Ja, wenn eine Template-Transformation startet, aber kein Ergebnis liefert, dann ist das fatal, dann ist der Prozess Fehlerhaft.

---

**Cursor**

I'll make the template failure fatal by aborting the pipeline when the template step fails, marking the overall job as failed, persisting logs, and emitting a failure event. Then I'll lint the edited file.

```typescript
import { NextRequest, NextResponse } from 'next/server';
import { getAuth } from '@clerk/nextjs/server';
import { currentUser } from '@clerk/nextjs/server';
import { ExternalJobsRepository } from '@/lib/external-jobs-repository';
// import { FileSystemProvider } from '@/lib/storage/filesystem-provider';
import { ImageExtractionService } from '@/lib/transform/image-extraction-service';
import { TransformService } from '@/lib/transform/transform-service';
import { LibraryService } from '@/lib/services/library-service';
import { FileLogger } from '@/lib/debug/logger';
import { getJobEventBus } from '@/lib/events/job-event-bus';
import { bufferLog, drainBufferedLogs } from '@/lib/external-jobs-log-buffer';
import { IngestionService } from '@/lib/chat/ingestion-service';
import { bumpWatchdog, clearWatchdog } from '@/lib/external-jobs-watchdog';
import { gateTransformTemplate, gateIngestRag } from '@/lib/processing/gates';
import { getServerProvider } from '@/lib/storage/server-provider';
import { parseSecretaryMarkdownStrict } from '@/lib/secretary/response-parser';

// OneDrive-Utilities entfernt: Provider übernimmt Token/Uploads.

function toAsciiKebab(input: unknown, maxLen: number = 80): string | undefined {
  if (typeof input !== 'string') return undefined;
  const map: Record<string, string> = { 'ä': 'ae', 'ö': 'oe', 'ü': 'ue', 'ß': 'ss' };
  const replaced = input
    .trim()
    .toLowerCase()
    .split('')
    .map(ch => map[ch] ?? ch)
    .join('')
    .normalize('NFKD')
    .replace(/[^a-z0-9]+/g, '-')
    .replace(/^-+|-+$/g, '')
    .replace(/-+/g, '-');
  const cut = replaced.slice(0, maxLen).replace(/-+$/g, '');
  return cut || undefined;
}

function splitToArray(value: unknown): string[] | undefined {
  if (Array.isArray(value)) {
    const arr = value
      .map(v => (typeof v === 'string' ? v.trim() : ''))
      .filter(Boolean);
    return Array.from(new Set(arr));
  }
  if (typeof value === 'string') {
    const arr = value
      .split(',')
      .map(v => v.trim())
      .filter(Boolean);
    return Array.from(new Set(arr));
  }
  return undefined;
}

function normalizeStructuredData(raw: unknown): Record<string, unknown> | null {
  if (!raw || typeof raw !== 'object' || Array.isArray(raw)) return null;
  const r = raw as Record<string, unknown>;
  const out: Record<string, unknown> = { ...r };

  // shortTitle variants
  const shortTitleCandidate = (r['shortTitle'] ?? r['shortTitel'] ?? r['shortTitlel']) as unknown;
  if (typeof shortTitleCandidate === 'string') {
    const cleaned = shortTitleCandidate.replace(/[.!?]+$/g, '').trim();
    out['shortTitle'] = cleaned.length > 40 ? cleaned.slice(0, 40) : cleaned;
  }
  delete out['shortTitel'];
  delete out['shortTitlel'];

  // slug normalization
  const slug = toAsciiKebab(r['slug']);
  if (slug) out['slug'] = slug;

  // authors and tags arrays
  const authors = splitToArray(r['authors']);
  if (authors) out['authors'] = authors;
  const tags = splitToArray(r['tags']);
  if (tags) {
    const norm = tags
      .map(t => toAsciiKebab(t, 80) || '')
      .filter(Boolean) as string[];
    out['tags'] = Array.from(new Set(norm));
  }

  // year number
  const yearVal = r['year'];
  if (typeof yearVal === 'string' && /^\d{4}$/.test(yearVal)) out['year'] = Number(yearVal);

  return out;
}

// OneDrive-spezifische Upload-/Token-Utilities wurden entfernt; StorageFactory-Provider übernimmt das Speichern.

export async function GET(
  _request: NextRequest,
  { params }: { params: Promise<{ jobId: string }> }
) {
  try {
    const { userId } = getAuth(_request);
    if (!userId) return NextResponse.json({ error: 'Nicht authentifiziert' }, { status: 401 });

    const { jobId } = await params;
    if (!jobId) return NextResponse.json({ error: 'jobId erforderlich' }, { status: 400 });

    const user = await currentUser();
    const userEmail = user?.emailAddresses?.[0]?.emailAddress || '';
    if (!userEmail) return NextResponse.json({ error: 'Benutzer-E-Mail nicht verfügbar' }, { status: 403 });

    const repo = new ExternalJobsRepository();
    const job = await repo.get(jobId);
    if (!job) return NextResponse.json({ error: 'Job nicht gefunden' }, { status: 404 });

    if (job.userEmail !== userEmail) {
      return NextResponse.json({ error: 'Forbidden' }, { status: 403 });
    }

    // Optional: Nur letzte N Logs zurückgeben via ?limit=...
    // Query-Params sind in App Router bei Route Handlern nicht direkt verfügbar ohne request.url zu parsen
    const url = new URL(_request.url);
    const limitParam = url.searchParams.get('limit');
    const limit = limitParam ? Math.max(1, Math.min(1000, Number(limitParam))) : undefined;
    const buffered: Array<Record<string, unknown>> = [];
    const persisted = Array.isArray(job.logs) ? job.logs : [];
    const merged = [...persisted, ...buffered];
    const logs = limit ? merged.slice(-limit) : merged;

    return NextResponse.json({
      jobId: job.jobId,
      status: job.status,
      worker: job.worker,
      operation: job.operation,
      processId: job.processId,
      createdAt: job.createdAt,
      updatedAt: job.updatedAt,
      error: job.error,
      logs,
      result: job.result,
    });
  } catch {
    return NextResponse.json({ error: 'Unerwarteter Fehler' }, { status: 500 });
  }
}

export async function POST(
  request: NextRequest,
  { params }: { params: Promise<{ jobId: string }> }
) {
  try {
    const { jobId } = await params;
    if (!jobId) return NextResponse.json({ error: 'jobId erforderlich' }, { status: 400 });

    const body = await request.json();

    // Token kann im Body, im X-Callback-Token-Header oder als Bearer kommen
    let callbackToken: string | undefined = body?.callback_token;
    if (!callbackToken) {
      const headerToken = request.headers.get('x-callback-token') || request.headers.get('X-Callback-Token');
      if (headerToken) callbackToken = headerToken;
    }
    if (!callbackToken) {
      const authHeader = request.headers.get('authorization') || request.headers.get('Authorization');
      if (authHeader?.startsWith('Bearer ')) callbackToken = authHeader.substring('Bearer '.length);
    }
    const internalBypass = (() => {
      const t = request.headers.get('x-internal-token') || request.headers.get('X-Internal-Token');
      const envToken = process.env.INTERNAL_TEST_TOKEN || '';
      return !!t && !!envToken && t === envToken;
    })();
    const repo = new ExternalJobsRepository();
    const job = await repo.get(jobId);
    if (!job) return NextResponse.json({ error: 'Job nicht gefunden' }, { status: 404 });

    if (!callbackToken && !internalBypass) {
      bufferLog(jobId, { phase: 'failed', message: 'callback_token fehlt' });
      await repo.appendLog(jobId, { phase: 'failed', message: 'callback_token fehlt' } as unknown as Record<string, unknown>);
      await repo.setStatus(jobId, 'failed', { error: { code: 'callback_token_missing', message: 'callback_token fehlt' } });
      getJobEventBus().emitUpdate(job.userEmail, { type: 'job_update', jobId, status: 'failed', updatedAt: new Date().toISOString(), message: 'callback_token fehlt', jobType: job.job_type, fileName: job.correlation?.source?.name, sourceItemId: job.correlation?.source?.itemId });
      return NextResponse.json({ error: 'callback_token fehlt' }, { status: 400 });
    }

    if (!internalBypass) {
      const tokenHash = repo.hashSecret(callbackToken as string);
      if (tokenHash !== job.jobSecretHash) {
        bufferLog(jobId, { phase: 'failed', message: 'Unauthorized callback' });
        await repo.appendLog(jobId, { phase: 'failed', message: 'Unauthorized callback' } as unknown as Record<string, unknown>);
        await repo.setStatus(jobId, 'failed', { error: { code: 'unauthorized', message: 'Ungültiges callback_token' } });
        getJobEventBus().emitUpdate(job.userEmail, { type: 'job_update', jobId, status: 'failed', updatedAt: new Date().toISOString(), message: 'Unauthorized callback', jobType: job.job_type, fileName: job.correlation?.source?.name, sourceItemId: job.correlation?.source?.itemId });
        return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
      }
    }

    // Status auf running setzen und Prozess-ID loggen
    await repo.setStatus(jobId, 'running');
    if (body?.process?.id) await repo.setProcess(jobId, body.process.id);

    // Progress-Handling
    const progressValue = typeof body?.progress === 'number'
      ? body.progress
      : typeof body?.data?.progress === 'number'
        ? body.data.progress
        : typeof body?.percent === 'number'
          ? body.percent
          : typeof body?.data?.percent === 'number'
            ? body.data.percent
            : undefined;
    const phase = (typeof body?.phase === 'string' && body.phase) || (typeof body?.data?.phase === 'string' && body.data.phase) || undefined;
    const message = (typeof body?.message === 'string' && body.message) || (typeof body?.data?.message === 'string' && body.data.message) || undefined;

    const hasError = !!body?.error;
    const hasFinalPayload = !!(body?.data?.extracted_text || body?.data?.images_archive_url || body?.status === 'completed');

    if (!hasFinalPayload && !hasError && (progressValue !== undefined || phase || message)) {
      // Watchdog heartbeat
      bumpWatchdog(jobId);
      bufferLog(jobId, { phase: phase || 'progress', progress: typeof progressValue === 'number' ? Math.max(0, Math.min(100, progressValue)) : undefined, message });
      FileLogger.info('external-jobs', 'Progress-Event', {
        jobId,
        phase: phase || 'progress',
        progress: progressValue,
        message
      });
      // Push-Event für UI (SSE)
      getJobEventBus().emitUpdate(job.userEmail, {
        type: 'job_update',
        jobId,
        status: 'running',
        phase: phase || 'progress',
        progress: typeof progressValue === 'number' ? Math.max(0, Math.min(100, progressValue)) : undefined,
        message,
        updatedAt: new Date().toISOString(),
        jobType: job.job_type,
        fileName: job.correlation?.source?.name,
        sourceItemId: job.correlation?.source?.itemId,
      });
      return NextResponse.json({ status: 'ok', jobId, kind: 'progress' });
    }

    if (hasError) {
      clearWatchdog(jobId);
      bufferLog(jobId, { phase: 'failed', details: body.error });
      // Bei Fehler: gepufferte Logs persistieren
      const buffered = drainBufferedLogs(jobId);
      for (const entry of buffered) {
        await repo.appendLog(jobId, entry as unknown as Record<string, unknown>);
      }
      await repo.setStatus(jobId, 'failed', { error: { code: 'worker_error', message: 'Externer Worker-Fehler', details: body.error } });
      getJobEventBus().emitUpdate(job.userEmail, { type: 'job_update', jobId, status: 'failed', updatedAt: new Date().toISOString(), message: body?.error?.message, jobType: job.job_type, fileName: job.correlation?.source?.name, sourceItemId: job.correlation?.source?.itemId });
      return NextResponse.json({ status: 'ok', jobId, kind: 'failed' });
    }

    // Finale Payload
    const extractedText: string | undefined = body?.data?.extracted_text;
    const imagesArchiveUrlFromWorker: string | undefined = body?.data?.images_archive_url;

    if (!extractedText && !imagesArchiveUrlFromWorker) {
      bumpWatchdog(jobId);
      bufferLog(jobId, { phase: 'noop' });
      return NextResponse.json({ status: 'ok', jobId, kind: 'noop' });
    }

    // Bibliothek laden (um Typ zu bestimmen)
    const libraryService = LibraryService.getInstance();
    const libraries = await libraryService.getUserLibraries(job.userEmail);
    const lib = libraries.find(l => l.id === job.libraryId);

    let savedItemId: string | undefined;
    const savedItems: string[] = [];
    let docMetaForIngestion: Record<string, unknown> | undefined;

    if (lib && extractedText) {
      const doExtractMetadata = !!(job.parameters && typeof job.parameters === 'object' && (job.parameters as Record<string, unknown>)['doExtractMetadata']);
      const autoSkip = true;

      if (lib) {
        // Einheitliche Serverinitialisierung des Providers (DB-Config, Token enthalten)
        let provider;
        try {
          provider = await getServerProvider(job.userEmail, job.libraryId);
        } catch (e) {
          const reason = e instanceof Error ? e.message : 'Provider-Initialisierung fehlgeschlagen';
          bufferLog(jobId, { phase: 'provider_init_failed', message: reason });
          await repo.updateStep(jobId, 'transform_template', { status: 'failed', endedAt: new Date(), error: { message: reason } });
          await repo.setStatus(jobId, 'failed', { error: { code: 'CONFIG_ERROR', message: reason } });
          getJobEventBus().emitUpdate(job.userEmail, { type: 'job_update', jobId, status: 'failed', updatedAt: new Date().toISOString(), message: reason, jobType: job.job_type, fileName: job.correlation?.source?.name, sourceItemId: job.correlation?.source?.itemId });
          return NextResponse.json({ status: 'error', jobId, kind: 'provider_init_failed', message: reason }, { status: 400 });
        }

        const sourceId = job.correlation?.source?.itemId;
        const targetParentId = job.correlation?.source?.parentId || 'root';

        // Optionale Template-Verarbeitung (Phase 2)
        let metadataFromTemplate: Record<string, unknown> | null = null;
        let templateStatus: 'completed' | 'failed' | 'skipped' = 'completed';
        // Gate für Transform-Template (Phase 2)
        let templateGateExists = false;
        if (autoSkip) {
          const g = await gateTransformTemplate({ repo, jobId, userEmail: job.userEmail, library: lib, source: job.correlation?.source, options: job.correlation?.options as { targetLanguage?: string } | undefined });
          templateGateExists = g.exists;
          if (g.exists) {
            await repo.updateStep(jobId, 'transform_template', { status: 'completed', endedAt: new Date(), details: { skipped: true, reason: g.reason } });
            templateStatus = 'skipped';
          }
        }
        if (!doExtractMetadata || templateGateExists) {
          bufferLog(jobId, { phase: 'transform_meta_skipped', message: 'Template-Transformation übersprungen (Phase 1)' });
        } else {
          await repo.updateStep(jobId, 'transform_template', { status: 'running', startedAt: new Date() });
          try {
            // Templates-Ordner vorbereiten
            const rootItems = await provider.listItemsById('root');
            const templatesFolder = rootItems.find(it => it.type === 'folder' && (it as { metadata?: { name?: string } }).metadata?.name?.toLowerCase() === 'templates');
            const ensureTemplatesFolderId = async (): Promise<string> => {
              if (templatesFolder) return templatesFolder.id;
              const created = await provider.createFolder('root', 'templates');
              bufferLog(jobId, { phase: 'templates_folder_created', message: 'Ordner /templates angelegt' });
              return created.id;
            };
            const templatesFolderId = await ensureTemplatesFolderId();

            // Template-Datei wählen bzw. anlegen
            let chosen: { id: string } | undefined;
            if (templatesFolderId) {
              const tplItems = await provider.listItemsById(templatesFolderId);
              const preferredTemplate = ((lib.config?.chat as unknown as { transformerTemplate?: string })?.transformerTemplate || '').trim();
              const pickByName = (name: string) => tplItems.find(it => it.type === 'file' && (it as { metadata: { name: string } }).metadata.name.toLowerCase() === name.toLowerCase());
              chosen = preferredTemplate
                ? pickByName(preferredTemplate.endsWith('.md') ? preferredTemplate : `${preferredTemplate}.md`)
                : (pickByName('pdfanalyse.md') || pickByName('pdfanalyse_default.md') || tplItems.find(it => it.type === 'file' && (it as { metadata: { name: string } }).metadata.name.toLowerCase().endsWith('.md')));
              if (!chosen) {
                const defaultTemplateContent = '# {{title}}\n';
                const tplFile = new File([new Blob([defaultTemplateContent], { type: 'text/markdown' })], 'pdfanalyse.md', { type: 'text/markdown' });
                await provider.uploadFile(templatesFolderId, tplFile);
                bufferLog(jobId, { phase: 'template_created', message: 'Default-Template pdfanalyse.md angelegt' });
                const re = await provider.listItemsById(templatesFolderId);
                chosen = re.find(it => it.type === 'file' && (it as { metadata: { name: string } }).metadata.name.toLowerCase() === 'pdfanalyse.md') as unknown as { id: string } | undefined;
              }
            } else {
              bufferLog(jobId, { phase: 'templates_folder_missing', message: 'Ordner /templates nicht gefunden' });
            }

            if (chosen) {
              const bin = await provider.getBinary(chosen.id);
              const templateContent = await bin.blob.text();
              await repo.appendMeta(jobId, { template_used: (chosen as unknown as { metadata?: { name?: string } }).metadata?.name }, 'template_pick');

              // Secretary Transformer aufrufen
              const secretaryUrlRaw = process.env.SECRETARY_SERVICE_URL || '';
              const transformerUrl = secretaryUrlRaw.endsWith('/') ? `${secretaryUrlRaw}transformer/template` : `${secretaryUrlRaw}/transformer/template`;
              const fd = new FormData();
              fd.append('text', extractedText);
              const lang = (job.correlation.options?.targetLanguage as string | undefined) || 'de';
              fd.append('target_language', lang);
              fd.append('template_content', templateContent);
              fd.append('use_cache', 'false');
              // Kontext übergeben (Dateiname/Pfad/Job)
              try {
                const parentId = job.correlation.source?.parentId || 'root';
                const parentPath = await provider.getPathById(parentId); // z.B. /Berichte Landesämter/Bevölk.Schutz
                const dirPath = parentPath.replace(/^\//, ''); // Berichte Landesämter/Bevölk.Schutz
                const rawName = job.correlation.source?.name || 'document.pdf';
                const withoutExt = rawName.replace(/\.[^./\\]+$/, '');
                const lang = (job.correlation.options?.targetLanguage as string | undefined) || 'de';
                const baseName = withoutExt.replace(new RegExp(`\\.${lang}$`, 'i'), '');
                const ctx = {
                  filename: baseName,
                  filepath: dirPath,
                  libraryId: job.libraryId,
                  jobId: job.jobId,
                  sourceItemId: job.correlation.source?.itemId,
                  parentId: job.correlation.source?.parentId
                } as const;
                fd.append('context', JSON.stringify(ctx));
              } catch {}
              const headers: Record<string, string> = { 'Accept': 'application/json' };
              const apiKey = process.env.SECRETARY_SERVICE_API_KEY;
              if (apiKey) { headers['Authorization'] = `Bearer ${apiKey}`; headers['X-Service-Token'] = apiKey; }
              const resp = await fetch(transformerUrl, { method: 'POST', body: fd, headers });
              const data: unknown = await resp.json().catch(() => ({}));
              if (resp.ok && data && typeof data === 'object' && !Array.isArray(data)) {
                const d = (data as { data?: unknown }).data as { structured_data?: unknown } | undefined;
                const normalized = normalizeStructuredData(d?.structured_data);
                metadataFromTemplate = normalized || null;
                bufferLog(jobId, { phase: 'transform_meta', message: 'Metadaten via Template berechnet' });
              } else {
                bufferLog(jobId, { phase: 'transform_meta_failed', message: 'Transformer lieferte kein gültiges JSON' });
                templateStatus = 'failed';
              }
            }
          } catch(err) {
            console.error(err);
            bufferLog(jobId, { phase: 'transform_meta_error', message: 'Fehler bei Template-Transformation: ' + (err instanceof Error ? err.message : 'Unbekannter Fehler') });
            templateStatus = 'failed';
          }
        }

        // Frontmatter bestimmen und Shadow‑Twin speichern
        const baseMeta = (body?.data?.metadata as Record<string, unknown>) || {};
        const finalMeta: Record<string, unknown> = metadataFromTemplate ? { ...metadataFromTemplate } : { ...baseMeta };
        docMetaForIngestion = finalMeta;
        await repo.appendMeta(jobId, finalMeta, 'template_transform');
        await repo.updateStep(jobId, 'transform_template', { status: templateStatus === 'failed' ? 'failed' : 'completed', endedAt: new Date(), ...(templateStatus === 'skipped' ? { details: { skipped: true } } : {}) });

        // Fatal: Wenn Template-Transformation gestartet wurde, aber fehlgeschlagen ist, abbrechen
        if (templateStatus === 'failed') {
          clearWatchdog(jobId);
          bufferLog(jobId, { phase: 'failed', message: 'Template-Transformation fehlgeschlagen (fatal)' });
          const bufferedTpl = drainBufferedLogs(jobId);
          for (const entry of bufferedTpl) {
            await repo.appendLog(jobId, entry as unknown as Record<string, unknown>);
          }
          await repo.setStatus(jobId, 'failed', { error: { code: 'template_failed', message: 'Template-Transformation fehlgeschlagen' } });
          getJobEventBus().emitUpdate(job.userEmail, { type: 'job_update', jobId, status: 'failed', updatedAt: new Date().toISOString(), message: 'Template-Transformation fehlgeschlagen', jobType: job.job_type, fileName: job.correlation?.source?.name, sourceItemId: job.correlation?.source?.itemId });
          return NextResponse.json({ status: 'ok', jobId, kind: 'failed_template' });
        }

        const baseName = (job.correlation.source?.name || 'output').replace(/\.[^/.]+$/, '');
        const lang = (job.correlation.options?.targetLanguage as string | undefined) || 'de';
        const uniqueName = `${baseName}.${lang}.md`;

        // SSOT: Flache, UI-taugliche Metafelder ergänzen (nur auf stabilem Meilenstein)
        const ssotFlat: Record<string, unknown> = {
          job_id: jobId,
          source_file: job.correlation.source?.name || baseName,
          extract_status: 'completed',
          template_status: templateStatus,
          // Ingestion-Status wird später ggf. separat ermittelt; hier neutral
          ingest_status: 'none',
        };
        // optionale Summary-Werte aus bereits vorhandenen Metadaten übernehmen, wenn vorhanden
        if (typeof (finalMeta as Record<string, unknown>)['summary_pages'] === 'number') ssotFlat['summary_pages'] = (finalMeta as Record<string, unknown>)['summary_pages'];
        if (typeof (finalMeta as Record<string, unknown>)['summary_chunks'] === 'number') ssotFlat['summary_chunks'] = (finalMeta as Record<string, unknown>)['summary_chunks'];
        ssotFlat['summary_language'] = lang;

        const mergedMeta = { ...finalMeta, ...ssotFlat } as Record<string, unknown>;

        const markdown = (TransformService as unknown as { createMarkdownWithFrontmatter?: (c: string, m: Record<string, unknown>) => string }).createMarkdownWithFrontmatter
          ? (TransformService as unknown as { createMarkdownWithFrontmatter: (c: string, m: Record<string, unknown>) => string }).createMarkdownWithFrontmatter(extractedText, mergedMeta)
          : extractedText;
        const file = new File([new Blob([markdown], { type: 'text/markdown' })], uniqueName, { type: 'text/markdown' });
        await repo.updateStep(jobId, 'store_shadow_twin', { status: 'running', startedAt: new Date() });
        const saved = await provider.uploadFile(targetParentId, file);
        bufferLog(jobId, { phase: 'stored_local', message: 'Shadow‑Twin gespeichert' });
        savedItemId = saved.id;
        await repo.updateStep(jobId, 'store_shadow_twin', { status: 'completed', endedAt: new Date() });

        // Bilder-ZIP optional verarbeiten
        if (imagesArchiveUrlFromWorker) {
          try {
            const baseRaw = process.env.SECRETARY_SERVICE_URL || '';
            const isAbsolute = /^https?:\/\//i.test(imagesArchiveUrlFromWorker);
            let archiveUrl = imagesArchiveUrlFromWorker;
            if (!isAbsolute) {
              const base = baseRaw.replace(/\/$/, '');
              const rel = imagesArchiveUrlFromWorker.startsWith('/') ? imagesArchiveUrlFromWorker : `/${imagesArchiveUrlFromWorker}`;
              archiveUrl = base.endsWith('/api') && rel.startsWith('/api/') ? `${base}${rel.substring(4)}` : `${base}${rel}`;
            }
            const apiKey = process.env.SECRETARY_SERVICE_API_KEY;
            const headers: Record<string, string> = {};
            if (apiKey) { headers['Authorization'] = `Bearer ${apiKey}`; headers['X-Service-Token'] = apiKey; }
            const resp = await fetch(archiveUrl, { method: 'GET', headers });
            if (!resp.ok) {
              bufferLog(jobId, { phase: 'images_download_failed', message: `Archiv-Download fehlgeschlagen: ${resp.status}` });
              clearWatchdog(jobId);
              const bufferedNow = drainBufferedLogs(jobId);
              for (const entry of bufferedNow) await repo.appendLog(jobId, entry as unknown as Record<string, unknown>);
              await repo.setStatus(jobId, 'failed', { error: { code: 'images_download_failed', message: 'Bild-Archiv konnte nicht geladen werden', details: { status: resp.status } } });
              getJobEventBus().emitUpdate(job.userEmail, { type: 'job_update', jobId, status: 'failed', updatedAt: new Date().toISOString(), message: 'Archiv-Download fehlgeschlagen', jobType: job.job_type, fileName: job.correlation?.source?.name });
              return NextResponse.json({ status: 'ok', jobId, kind: 'failed_images_download' });
            }
            const arrayBuf = await resp.arrayBuffer();
            const base64Zip = Buffer.from(arrayBuf).toString('base64');
            const originalItemForImages = {
              id: sourceId || 'unknown',
              parentId: targetParentId,
              type: 'file' as const,
              metadata: {
                name: job.correlation.source?.name || 'source.pdf',
                size: 0,
                modifiedAt: new Date(),
                mimeType: job.correlation.source?.mimeType || 'application/pdf',
              },
            };
            const textContents = (body?.data?.metadata?.text_contents as Array<{ page: number; content: string }> | undefined);
            const imageResult = await ImageExtractionService.saveZipArchive(
              base64Zip,
              'images.zip',
              originalItemForImages,
              provider,
              async (folderId: string) => provider.listItemsById(folderId),
              extractedText,
              lang,
              textContents
            );
            for (const it of imageResult.savedItems) savedItems.push(it.id);
            bufferLog(jobId, { phase: 'images_extracted', message: `Bilder gespeichert (${imageResult.savedItems.length})` });
          } catch {
            bufferLog(jobId, { phase: 'images_extract_failed', message: 'ZIP-Extraktion fehlgeschlagen' });
            clearWatchdog(jobId);
            const bufferedNow = drainBufferedLogs(jobId);
            for (const entry of bufferedNow) await repo.appendLog(jobId, entry as unknown as Record<string, unknown>);
            await repo.setStatus(jobId, 'failed', { error: { code: 'images_extract_failed', message: 'ZIP-Archiv konnte nicht extrahiert werden' } });
            getJobEventBus().emitUpdate(job.userEmail, { type: 'job_update', jobId, status: 'failed', updatedAt: new Date().toISOString(), message: 'Bilder-Extraktion fehlgeschlagen', jobType: job.job_type, fileName: job.correlation?.source?.name });
            return NextResponse.json({ status: 'ok', jobId, kind: 'failed_images_extract' });
          }
        }
      }

      // Schritt: ingest_rag (optional automatisiert)
      try {
        // Gate für Ingestion (Phase 3)
        const autoSkip = true;
        let ingestGateExists = false;
        if (autoSkip) {
          const g = await gateIngestRag({
            repo,
            jobId,
            userEmail: job.userEmail,
            library: lib,
            source: job.correlation?.source,
            options: job.correlation?.options as { targetLanguage?: string } | undefined,
            ingestionCheck: async ({ userEmail, libraryId, fileId }: { userEmail: string; libraryId: string; fileId: string }) => {
              // Prüfe Doc‑Vektor existiert (kind:'doc' + fileId)
              try {
                const ctx = await (await import('@/lib/chat/loader')).loadLibraryChatContext(userEmail, libraryId)
                const apiKey = process.env.PINECONE_API_KEY
                if (!ctx || !apiKey) return false
                const idx = await (await import('@/lib/chat/pinecone')).describeIndex(ctx.vectorIndex, apiKey)
                if (!idx?.host) return false
                const list = await (await import('@/lib/chat/pinecone')).listVectors(idx.host, apiKey, { kind: 'doc', user: userEmail, libraryId, fileId })
                return Array.isArray(list) && list.length > 0
              } catch {
                return false
              }
            }
          })
          if (g.exists) {
            ingestGateExists = true;
            await repo.updateStep(jobId, 'ingest_rag', { status: 'completed', endedAt: new Date(), details: { skipped: true, reason: g.reason } });
            // Wenn geskippt, keinen weiteren Ingestion-Versuch starten
            // dennoch Abschluss unten fortsetzen
          } else {
            await repo.updateStep(jobId, 'ingest_rag', { status: 'running', startedAt: new Date() });
          }
        } else {
          await repo.updateStep(jobId, 'ingest_rag', { status: 'running', startedAt: new Date() });
        }
        FileLogger.info('external-jobs', 'Ingestion start', { jobId, libraryId: job.libraryId })
        const useIngestion = !!(job.parameters && typeof job.parameters === 'object' && (job.parameters as Record<string, unknown>)['doIngestRAG']);
        if (useIngestion && !ingestGateExists) {
          // Lade gespeicherten Markdown-Inhalt erneut (vereinfachend: extractedText)
          // Stabiler Schlüssel: Original-Quell-Item (PDF) bevorzugen, sonst Shadow‑Twin, sonst Fallback
          const fileId = (job.correlation.source?.itemId as string | undefined) || savedItemId || `${jobId}-md`;
          const fileName = `${(job.correlation.source?.name || 'output').replace(/\.[^/.]+$/, '')}.${(job.correlation.options?.targetLanguage as string | undefined) || 'de'}.md`;
          const res = await IngestionService.upsertMarkdown(job.userEmail, job.libraryId, fileId, fileName, extractedText || '', docMetaForIngestion);
          const total = res.chunksUpserted + (res.docUpserted ? 1 : 0)
          await repo.setIngestion(jobId, { upsertAt: new Date(), vectorsUpserted: total, index: res.index });
          // Zusammenfassung loggen
          bufferLog(jobId, { phase: 'ingest_rag', message: `RAG-Ingestion: ${res.chunksUpserted} Chunks, ${res.docUpserted ? 1 : 0} Doc` });
          FileLogger.info('external-jobs', 'Ingestion success', { jobId, chunks: res.chunksUpserted, doc: res.docUpserted, total })
          await repo.updateStep(jobId, 'ingest_rag', { status: 'completed', endedAt: new Date() });
        } else {
          await repo.updateStep(jobId, 'ingest_rag', { status: 'completed', endedAt: new Date(), details: { skipped: true } });
        }
      } catch (err) {
        const reason = (() => {
          if (err && typeof err === 'object') {
            const e = err as { message?: unknown }
            const msg = typeof e.message === 'string' ? e.message : undefined
            return msg || String(err)
          }
          return String(err)
        })()
        bufferLog(jobId, { phase: 'ingest_rag_failed', message: reason })
        FileLogger.error('external-jobs', 'Ingestion failed', err)
        await repo.updateStep(jobId, 'ingest_rag', { status: 'failed', endedAt: new Date(), error: { message: 'RAG Ingestion fehlgeschlagen', details: { reason } } });
      }

      await repo.setStatus(jobId, 'completed');
      clearWatchdog(jobId);
      // gepufferte Logs persistieren
      const buffered = drainBufferedLogs(jobId);
      for (const entry of buffered) {
        await repo.appendLog(jobId, entry as unknown as Record<string, unknown>);
      }
      await repo.setResult(jobId, {
        extracted_text: extractedText,
        images_archive_url: imagesArchiveUrlFromWorker || undefined,
        metadata: body?.data?.metadata,
      }, { savedItemId, savedItems });

      // Finalen Logeintrag für den sichtbaren Verlauf hinzufügen
      await repo.appendLog(jobId, { phase: 'completed', message: 'Job abgeschlossen' });

      FileLogger.info('external-jobs', 'Job completed', { jobId, savedItemId, savedItemsCount: savedItems.length });
      getJobEventBus().emitUpdate(job.userEmail, { type: 'job_update', jobId, status: 'completed', progress: 100, updatedAt: new Date().toISOString(), message: 'completed', jobType: job.job_type, fileName: job.correlation?.source?.name, sourceItemId: job.correlation?.source?.itemId });
      return NextResponse.json({ status: 'ok', jobId, kind: 'final', savedItemId, savedItemsCount: savedItems.length });
    }

    // Sollte nicht erreicht werden
    return NextResponse.json({ status: 'ok', jobId, kind: 'noop_final' });
  } catch (err) {
    try {
      const { jobId } = await params;
      const repo = new ExternalJobsRepository();
      const job = await repo.get(jobId);
      if (job) {
        bufferLog(jobId, { phase: 'failed', message: 'Invalid payload' });
        await repo.appendLog(jobId, { phase: 'failed', message: 'Invalid payload' } as unknown as Record<string, unknown>);
        await repo.setStatus(jobId, 'failed', { error: { code: 'invalid_payload', message: err instanceof Error ? err.message : 'Invalid payload' } });
        getJobEventBus().emitUpdate(job.userEmail, { type: 'job_update', jobId, status: 'failed', updatedAt: new Date().toISOString(), message: 'Invalid payload', jobType: job.job_type, fileName: job.correlation?.source?.name, sourceItemId: job.correlation?.source?.itemId });
      }
    } catch {
      // ignore secondary failures
    }
    return NextResponse.json({ error: 'Invalid payload' }, { status: 400 });
  }
}



```

- Ich habe die Template-Phase jetzt als fatal markiert: Sobald die Template-Transformation gestartet wurde und fehlschlägt (kein valides JSON oder Exception), wird der Step als failed gesetzt, gepufferte Logs werden persistiert, Watchdog gestoppt, der Gesamtjob-Status auf failed gesetzt und ein Failure-Event gesendet. Die Pipeline wird an dieser Stelle beendet.
- Datei angepasst: `src/app/api/external/jobs/[jobId]/route.ts` (nach dem Setzen des Step-Status prüfen wir `templateStatus === 'failed'` und brechen ab).

Auswirkung
- Jobs mit `transform_meta_failed` enden jetzt mit `status: "failed"`. Der `PhaseStepper` zeigt rot für Metadaten, und es gibt kein „completed“ mehr für den Gesamtjob in diesem Fall.
- Falls ein Gate den Schritt überspringt, bleibt `skipped` ohne Abbruch. Bei Erfolg bleibt `completed`.

Wenn du eine Ausnahme willst (z.B. nur fatal wenn `doExtractMetadata` wahr), sag Bescheid; dann binden wir die Abbruchlogik an dieses Flag.

---

**User**

Wie kann ich diesen Branch einchecken und deployen? habe da git Fehlermeldungen beim einchecken.

---

**Cursor**

Hier ist der schnellste, robuste Weg (PowerShell), um deinen Stand zu committen, in einen Feature-Branch zu pushen und zu deployen:

### 1) Branch anlegen, committen, pushen
```powershell
cd C:\Users\peter.aichner\projects\CommonKnowledgeScout
git fetch origin
git switch -c feat/template-fatal-worker
pnpm lint && pnpm typecheck && pnpm build
git add -A
git commit -m "Template-Phase fatal bei Fehler; Phase-Status korrekt; Worker Auto-Start; JobMonitor Controls"
git push -u origin feat/template-fatal-worker
```

### 2) Pull Request erstellen und mergen
- Auf GitHub: PR von `feat/template-fatal-worker` nach `master` erstellen und mergen.
- Falls „protected branch“: Reviews/Checks beachten.

### 3) Deploy
- Vercel (typisch): Merge auf `master` triggert Auto-Deploy. Alternativ manuell:
```powershell
pnpm build
# falls Vercel CLI genutzt:
vercel --prod
```

### Häufige Git-Fehler schnell beheben
- Updates were rejected (remote hat neue Commits):
```powershell
git pull --rebase origin master
git push
```
- No upstream branch:
```powershell
git push -u origin feat/template-fatal-worker
```
- Pre-commit Hook/Lint schlägt fehl:
```powershell
pnpm lint --fix
pnpm test
git add -A
git commit --amend --no-edit
git push --force-with-lease
```
- Merge/Rebase steckt fest:
```powershell
git merge --abort  # oder
git rebase --abort
```

Wenn der Fehler weiterhin auftritt, poste bitte die exakte Git-Fehlermeldung – dann gebe ich dir den präzisen Fix (ein Zeiler).

```powershell
cd C:\Users\peter.aichner\projects\CommonKnowledgeScout
git fetch origin
git switch -c feat/template-fatal-worker
pnpm lint && pnpm typecheck && pnpm build
git add -A
git commit -m "Template-Phase fatal bei Fehler; Phase-Status korrekt; Worker Auto-Start; JobMonitor Controls"
git push -u origin feat/template-fatal-worker
```

```powershell
pnpm build
# falls Vercel CLI genutzt:
vercel --prod
```

```powershell
git pull --rebase origin master
git push
```

```powershell
git push -u origin feat/template-fatal-worker
```

```powershell
pnpm lint --fix
pnpm test
git add -A
git commit --amend --no-edit
git push --force-with-lease
```

```powershell
git merge --abort  # oder
git rebase --abort
```

