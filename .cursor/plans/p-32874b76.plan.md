<!-- 32874b76-2845-42f6-9fe8-f4f9fb01b0bf df540879-7fa9-4573-823c-91d3f1da2f37 -->
# Pinecone Doc‑Status Cache und UI‑Status (Minimal-invasiv)

## Ziel

- Alle Statusfelder aus Frontmatter/Job in Pinecone (kind:'doc') speichern, ohne Re‑Chunking.
- Datei‑Status in File‑List per Icon + Tooltip anzeigen.
- Ordner‑Aggregation on‑demand per Klick, zunächst clientseitig.

## Kernideen

- Neuer API‑Handler `/api/chat/[libraryId]/upsert-doc-meta` aktualisiert `${fileId}-meta`:
  - Wenn vorhanden: Metadaten mergen und upserten.
  - Wenn nicht vorhanden: 0‑Vektor der Index‑Dimension nutzen und upserten (Filter‑only Nutzung).
  - Speichert: flache Statusfelder (primitive), komplettes Frontmatter als `docMetaJson`.
- Pipeline‑Hook: Nach Schreiben des Markdown (Frontmatter) den neuen Handler aufrufen.
- APIs:
  - `/api/chat/[libraryId]/docs` um Statusfelder erweitern (für Galerie/Listenansicht).
  - `/api/chat/[libraryId]/file-status` um Statusfelder erweitern (für Einzeldatei + Debug).
- UI: `src/components/library/file-list.tsx` zeigt Status‑Icon je Datei (Tooltip listet alle Statusfelder). Ordner‑Icon löst on‑demand Rekursion aus, die Child‑Dateien lädt und Status aggregiert.

## Metadaten in Pinecone

- Flach (primitive): `extract_status`, `template_status`, `ingest_status`, `process_status`, `hasError`, `errorCode`, `errorMessage` (max ~512 chars), `lastErrorAt`, `upsertedAt`, `docModifiedAt`.
- Facetten (optional, primitive/strings): `year`, `language`, `region`, `docType`, `source`, `isScan`, `pageCount`, `authors[]`, `tags[]`.
- Voll: `docMetaJson` (Stringified Frontmatter – schemaflexibel, Quelle für Tooltips).

## Wichtige Stellen/Dateien

- API neu: `src/app/api/chat/[libraryId]/upsert-doc-meta/route.ts` (Clerk‑Auth, Index‑dim read, upsertVectorsChunked, Merge‑Logik)
- Pipeline Hook(s):
  - `src/lib/transform/transform-service.ts` (nach `createMarkdownWithFrontmatter` und Speichern: fetch Status + call upsert‑doc‑meta)
  - Zusätzlich im Secretary‑Flow: `src/app/api/secretary/process-pdf/route.ts` und `src/app/api/external/jobs/[jobId]/route.ts` beim Übergang der Schritte Status upserten
- APIs erweitern:
  - `src/app/api/chat/[libraryId]/docs/route.ts` – Statusfelder aus `docMetaJson`/flach mappen
  - `src/app/api/chat/[libraryId]/file-status/route.ts` – Statusfelder ergänzen
- UI: `src/components/library/file-list.tsx` – Status‑Icon + Tooltip, on‑demand Ordner‑Aggregation (staged)

## Essenzielle Snippets (vereinfacht)

- Upsert Doc‑Meta (neu):
```ts
// in /api/chat/[libraryId]/upsert-doc-meta/route.ts
const dim = idx.dimension || Number(process.env.OPENAI_EMBEDDINGS_DIMENSION||3072)
const zero = Array(dim).fill(0)
const id = `${fileId}-meta`
const metadata = { kind:'doc', user:userEmail, libraryId, fileId, fileName, upsertedAt:new Date().toISOString(), docMetaJson: JSON.stringify(frontmatter), ...statusFlat }
await upsertVectorsChunked(idx.host, apiKey, [{ id, values: zero, metadata }])
```

- Statusfeldernormierung (nur primitive/strings/list<string>): Kürzen `errorMessage`, `authors`/`tags` zu `string[]`.

## Tests (Vitest, Integration)

- Serializer testet Trunkierung und Typen.
- API upsert‑doc‑meta: erfolgreicher Upsert (mock pinecone).
- File‑Status API gibt Status korrekt zurück.
- Klick im File‑List zeigt Tooltip mit Status.

## Risiken/Follow‑ups

- Datei‑Move: Falls `fileId` path‑basiert ist, Meta kann verwaisen → späteres „Re‑Keying“ bei Move‑Events oder Hash‑Based stable ID.
- Ordner‑Aggregation serverseitig (Filter über `ancestorIds`) als Phase 2.

### To-dos

- [ ] Neue Route upsert-doc-meta implementieren (zero-vector upsert, merge)
- [ ] Markdown-Speichern hookt upsert-doc-meta mit Statusfeldern
- [ ] Docs-API um Statusfelder für Listen erweitern
- [ ] File-Status-API um Statusfelder erweitern
- [ ] FileList: Datei-Statusicon + Tooltip (alle Statusfelder)
- [ ] Ordnerstatus on-demand per Klick rekursiv aggregieren
- [ ] Vitest: Serializer, API upsert, File-Status, UI smoke